filename	comment	preds	stripped_code	model	model_output	prompt	runtime	meteor_score	bleu_4	rouge_1	rouge_2	rouge_L	LLM_as_judge	sentenceBERT_similarity
BRAINSia-BRAINSTools-11a70b1/ARCHIVE/BRAINSSurfaceTools/BRAINSSurfaceCommon/itkMeshToMeshRegistrationMethod.h	Method invoked by the pipeline in order to trigger the computation of the registration.	2	"using Superclass::MakeOutput;

virtual DataObjectPointer MakeOutput(size_t idx) override;

unsigned long GetMTime() const override;

protected:
MeshToMeshRegistrationMethod();
virtual ~MeshToMeshRegistrationMethod(){};
void PrintSelf(std::ostream &os, Indent indent) const override;

void GenerateData() override;

private:
MetricPointer m_Metric;
OptimizerType::Pointer m_Optimizer;

MovingMeshConstPointer m_MovingMesh;
FixedMeshConstPointer m_FixedMesh;

TransformPointer m_Transform;
InterpolatorPointer m_Interpolator;

ParametersType m_InitialTransformParameters;
ParametersType m_LastTransformParameters;
}
;
}"	claude-3-5-sonnet-20241022	This code defines a class for mesh registration that aligns two meshes using optimization, metrics, and transformation parameters while managing data objects and their relationships.	0	1	0.033112582781456956	0.007575731225158965	{'f': 0.05555555111111147, 'p': 0.08333333333333333, 'r': 0.041666666666666664}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.05555555111111147, 'p': 0.08333333333333333, 'r': 0.041666666666666664}	30	0.4103502631187439
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal simplex basis functions.	2	"static void
test_unit_basis_simplex_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_SI_Ortho *b_data_a = constructor_Basis_Data_SI_Ortho('a'),
                             *b_data_c = constructor_Basis_Data_SI_Ortho('c');

  tol = (double[]){
      10 * EPS,
      20 * EPS,
      10 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]),
      diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[1]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      20 * EPS,
      30 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]),
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      9 * EPS,
      8e4 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_25, b_data_c->grad_coef_25,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_37, b_data_c->grad_coef_37,
                              tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_25,
                                    b_data_c->grad_coef_25, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_37,
                                    b_data_c->grad_coef_37, tol[1]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_SI_Ortho(b_data_a);
  destructor_Basis_Data_SI_Ortho(b_data_c);

  assert_condition(pass);
}"	claude-3-5-sonnet-20241022	This function tests the equality between two sets of basis data ('a' and 'c') by comparing their matrices, gradients, mass matrices, and gradient evaluations within specified tolerances.	0	1	0.18518518518518517	0.009186672262412125	{'f': 0.17647058434256063, 'p': 0.3333333333333333, 'r': 0.12}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.17647058434256063, 'p': 0.3333333333333333, 'r': 0.12}	None_output	0.43820643424987793
MightyPork-avr-projects-1c993f8/projects/color-memory-game/main.c	Randomly place pairs of cards on the board	2	"void deal_cards() {

  for (uint8_t i = 0; i < CARD_COUNT; ++i) {
    board[i] = (tile_t){.color = 0, .state = GONE};
  }

  const uint8_t dealt_cards =
      get_pin(FLAG_SMALL) ? CARD_COUNT : CARD_COUNT_SMALL;

  for (uint8_t i = 0; i < (dealt_cards / 2); ++i) {

    for (uint8_t j = 0; j < 2; j++) {

      while (1) {
        const uint8_t pos = rand() % dealt_cards;

        if (board[pos].state == GONE) {
          board[pos] = (tile_t){.color = i, .state = SECRET};
          break;
        }
      }
    }
  }
}"	claude-3-5-sonnet-20241022	This function randomly distributes pairs of cards (tiles) on a game board, where each pair has the same color, and the number of cards dealt depends on a flag setting.	0	1	0.5215992647058825	0.036752344561789704	{'f': 0.36363635996326904, 'p': 0.75, 'r': 0.24}	{'f': 0.1176470555536333, 'p': 0.2857142857142857, 'r': 0.07407407407407407}	{'f': 0.3030302993572085, 'p': 0.625, 'r': 0.2}	95	0.707676112651825
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Inquiry_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function retrieves device inquiry data from a USB Mass Storage device by sending a SCSI INQUIRY command and storing the response in the provided buffer.	0	1	0.3550279329608938	0.02584145048742771	{'f': 0.36842104785318563, 'p': 0.4666666666666667, 'r': 0.30434782608695654}	{'f': 0.09756097085068434, 'p': 0.125, 'r': 0.08}	{'f': 0.15789473206371207, 'p': 0.2, 'r': 0.13043478260869565}	85	0.6778405904769897
multitheftauto-mtasa-blue-1f5e9f8/vendor/ehs/ehs.h	adds new data to psBuffer	2	"NetworkAbstraction *GetNetworkAbstraction();

int TrySend(const char *ipMessage, size_t inLength, int inFlags = 0);
}
;

class EHSServer;

class EHS {

protected:
  EHSMap oEHSMap;

  EHS *poParent;

  std::string sRegisteredAs;

  EHSServer *poEHSServer;

  EHS *m_poSourceEHS;

public:
  EHS(EHS *ipoParent = NULL, std::string isRegisteredAs = """");

  virtual ~EHS();

  void SetCertificateFile(std::string &irsCertificateFile);

  void SetCertificatePassphrase(std::string &irsCertificatePassphrase);

  void SetPassphraseCallback(int (*m_ipfOverridePassphraseCallback)(char *, int,
                                                                    int,
                                                                    void *));

  void SetParent(EHS *ipoParent, std::string isRegisteredAs);

  enum RegisterEHSResult {
    REGISTEREHSINTERFACE_INVALID = 0,
    REGISTEREHSINTERFACE_ALREADYEXISTS,
    REGISTEREHSINTERFACE_SUCCESS
  };

  RegisterEHSResult RegisterEHS(EHS *ipoEHS, const char *ipsRegisterPath);

  enum UnregisterEHSResult {
    UNREGISTEREHSINTERFACE_INVALID = 0,
    UNREGISTEREHSINTERFACE_NOTREGISTERED,
    UNREGISTEREHSINTERFACE_SUCCESS
  };

  UnregisterEHSResult UnregisterEHS(const char *ipsRegisterPath);

  virtual HttpResponse *RouteRequest(HttpRequest *ipoHttpRequest);

  virtual ResponseCode HandleRequest(HttpRequest *ipoHttpRequest,
                                     HttpResponse *ipoHttpResponse);

  virtual void HttpPulse(void){};

  virtual bool ShouldAllowConnection(const char *szAddress) { return true; }"	claude-3-5-sonnet-20241022	The `GetNetworkAbstraction()` function returns a pointer to a NetworkAbstraction object that handles network-related operations for the EHS (Embedded HTTP Server) system.	0	1	0.07575757575757576	0.009134423666564471	{'f': 0.07999999680000014, 'p': 0.2, 'r': 0.05}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07999999680000014, 'p': 0.2, 'r': 0.05}	None_output	-0.008158456534147263
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power domain attributes command and testing the received values.	3	"void arm_scmi_custom_test_power_domain_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t attributes;
  uint32_t protocol_mask = expected_flags_mask;
  uint32_t rcv_u, exp_u;
  char *domain_name;
  char *rcv_s, *exp_s;
  struct arm_scmi_protocol_execution_context *prot = protocol_execution_context;
  enum test_status res;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_domain_attributes,
                           domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_domain_attributes,
                                       domain_id)] =
        power_protocol_data.num_power_domains + 1;
    error_code =
        arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_power_domain_attributes, domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tPOWER DOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&prot->test_stats, description);
      error_code =
          arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        break;
      attributes = RETURN_VAL(received, struct arm_scmi_power_domain_attributes,
                              attributes);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_HIGH,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_LOW);
      snprintf(name, NUM_ELEMS(name),
               ""POWER STATE CHANGE NOTIFICATIONS SUPPORT"");
      if ((power_expected->power_state_notification_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_STATE_NOTIFICATION_SUPPORT))) {
        exp_u = power_expected->power_state_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_ASYNC_HIGH,
                                     POWER_DOMAIN_ATTR_ASYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER ASYNCHRONOUS SUPPORT"");
      if ((power_expected->power_asynchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_ASYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_asynchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_SYNC_HIGH,
                                     POWER_DOMAIN_ATTR_SYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER SYNCHRONOUS SUPPORT"");
      if ((power_expected->power_synchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_SYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_synchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      arm_scmi_check_and_report_dec(
          &prot->test_stats, ALL_BITS_SET, CHECK, RESERVED,
          arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_RESERVED_HIGH,
                                 POWER_DOMAIN_ATTR_RESERVED_LOW),
          ""RESERVED"");

      power_protocol_data.attributes[domain_id] = attributes;

      res = INFO;
      domain_name =
          RETURN_STR(received, struct arm_scmi_power_domain_attributes, name);
      rcv_s = domain_name;
      snprintf(name, NUM_ELEMS(name), ""DOMAIN NAME"");
      if ((power_expected->power_domain_names != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_DOMAIN_NAMES))) {
        exp_s = power_expected->power_domain_names[domain_id];
        res = (strcmp(rcv_s, exp_s) == 0) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", exp_s, rcv_s);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", rcv_s);
      }
      arm_scmi_log_test_result(&prot->test_stats, INFO, name, description);
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests power domain attributes in an ARM SCMI system by verifying various power-related features like state notifications, synchronous/asynchronous support, and domain names for each power domain.	0	1	0.25578425480769235	0.039530883746698414	{'f': 0.27906976257436455, 'p': 0.3333333333333333, 'r': 0.24}	{'f': 0.08888888400987681, 'p': 0.10526315789473684, 'r': 0.07692307692307693}	{'f': 0.2325581346673879, 'p': 0.2777777777777778, 'r': 0.2}	None_output	0.6889618039131165
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	Soft-resets the attached printer, readying it for new commands.	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a soft reset command to a connected USB printer device through the control pipe using standard USB protocol mechanisms.	0	1	0.145631067961165	0.010331208012220438	{'f': 0.13793103020214045, 'p': 0.2222222222222222, 'r': 0.1}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06896551296076128, 'p': 0.1111111111111111, 'r': 0.05}	85	0.644374668598175
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock describe rates command and testing the received values.	3	"void arm_scmi_custom_tester_clock_describe_rates(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint8_t clock_id;
  uint32_t num_rates_flags;
  uint8_t num_rates = 0;
  uint32_t rcv_u, exp_u;
  uint32_t rate_index = 0;
  uint32_t remaining_rates;
  struct arm_scmi_clock_rate *rcv_rates, *rates;
  size_t nr;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  uint64_t op1, step_size;
  struct arm_scmi_clock_rate **discrete;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_describe_rates, clock_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       clock_id)] =
        clock_protocol_data.num_clocks;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       rate_index)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                         clock_id)] = clock_id;
      rate_index = 0;

      rates = clock_protocol_data.clocks[clock_id].rates;
      do {

        test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                           rate_index)] = rate_index;
        error_code = arm_scmi_execute_and_assert_test_case(
            protocol_execution_context, test_case, &received);
        if (arm_scmi_skip_return_values(error_code, received.status))
          break;

        num_rates_flags = RETURN_VAL(
            received, struct arm_scmi_clock_describe_rates, num_rates_flags);

        remaining_rates = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_NUM_RATES_REMAINING_HIGH,
            CLK_DESCRATE_NUM_RATES_REMAINING_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      remaining_rates,
                                      ""NUMBER OF REMAINING RATES"");

        rcv_u =
            arm_scmi_get_norm_bits(num_rates_flags, CLK_DESCRATE_RESERVED_HIGH,
                                   CLK_DESCRATE_RESERVED_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                      rcv_u, ""RESERVED"");

        uint32_t format = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_RETURN_FORMAT_HIGH,
            CLK_DESCRATE_RETURN_FORMAT_LOW);
        clock_protocol_data.format = format;
        if (clock_expected->rate_format_supported) {
          arm_scmi_check_and_report_dec(
              test_stats, expected_flags_mask,
              LEFT_SHIFT(RATE_FORMAT_SUPPORTED),
              clock_expected->rate_format_supported[clock_id], format,
              ""FORMAT"");
        } else {
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(RATE_FORMAT_SUPPORTED), 0,
                                        format, ""FORMAT"");
        }

        num_rates = arm_scmi_get_norm_bits(num_rates_flags,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_HIGH,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_LOW);
        exp_u = clock_expected->num_rates == NULL
                    ? 0
                    : clock_expected->num_rates[clock_id];
        arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                      LEFT_SHIFT(CLOCK_NUM_RATES), exp_u,
                                      num_rates, ""NUMBER OF RATES"");

        rcv_rates = (struct arm_scmi_clock_rate *)&received.payload[OFFSET_RET(
            struct arm_scmi_clock_describe_rates, rates)];
        if (format == THREE_TUPLE_RATE_FORMAT) {

          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].lower,
                                        ""LOWEST RATE {LOWER}"");
          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].upper,
                                        ""LOWEST RATE {UPPER}"");

          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].lower,
                                        ""HIGHEST RATE {LOWER}"");
          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].upper,
                                        ""HIGHEST RATE {UPPER}"");

          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].lower,
                                        ""STEP SIZE {LOWER}"");
          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].upper,
                                        ""STEP SIZE {UPPER}"");

          rates[MIN_CLOCK] = rcv_rates[LOWEST_RATE];
          op1 = (((uint64_t)rcv_rates[LOWEST_RATE].upper) << 32) |
                rcv_rates[LOWEST_RATE].lower;
          step_size = (((uint64_t)rcv_rates[STEP_SIZE].upper) << 32) |
                      rcv_rates[STEP_SIZE].lower;
          op1 += step_size;
          rates[MIN_CLOCK + 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          op1 = (((uint64_t)rcv_rates[HIGHEST_RATE].upper) << 32) |
                rcv_rates[HIGHEST_RATE].lower;
          op1 -= step_size;
          rates[MAX_CLOCK - 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          rates[MAX_CLOCK] = rcv_rates[HIGHEST_RATE];

        } else {

          discrete = clock_expected->discrete_clock_rates;
          for (nr = 0; nr < num_rates; ++nr) {
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].lower;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->lower,
                                          ""LOWER WORD"");
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].upper;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->upper,
                                          ""UPPER WORD"");

            if ((rate_index + nr) == 0) {
              rates[MIN_CLOCK] = rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] =
                  rates[MAX_CLOCK] = *rcv_rates;
            } else if ((rate_index + nr) == 1) {
              rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] = rates[MAX_CLOCK] =
                  *rcv_rates;
            }
            rates[MAX_CLOCK - 1] = rates[MAX_CLOCK];
            rates[MAX_CLOCK] = *rcv_rates;
            rcv_rates += 1;
          }
        }
        rate_index += num_rates;
      } while (remaining_rates > 0);
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests and validates clock rate descriptions in an SCMI (System Control and Management Interface) implementation by checking various clock parameters and rate formats against expected values.	0	1	0.19230769230769232	0.010043468297595231	{'f': 0.23809523319727902, 'p': 0.2777777777777778, 'r': 0.20833333333333334}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.23809523319727902, 'p': 0.2777777777777778, 'r': 0.20833333333333334}	None_output	0.6658338904380798
SL-RU-MakiseGUI-971c7c7/MakiseGUI/makise.c	set new border. This region must be smaller then previous. It will be cropped. Borders need for drawing GUI. For gui elements do not leave their & their parent's borders. After setting border & drawing it you need to call makise_rem_border.	2	"MakiseBufferBorderData makise_add_border(MakiseBuffer *buffer,
                                         MakiseBufferBorder b) {
  if (buffer == 0)
    return (MakiseBufferBorderData){0};

  if (b.x < buffer->border.x)
    b.x = buffer->border.x;
  if (b.y < buffer->border.y)
    b.y = buffer->border.y;
  if (b.w > buffer->border.w + buffer->border.x - b.x)
    b.w = buffer->border.w + buffer->border.x - b.x;
  if (b.h > buffer->border.h + buffer->border.y - b.y)
    b.h = buffer->border.h + buffer->border.y - b.y;

  b.ex = b.x + b.w;
  b.ey = b.y + b.h;

  MakiseBufferBorder l = buffer->border;

  buffer->border = b;

  return (MakiseBufferBorderData){b, l};
}"	claude-3-5-sonnet-20241022	This function adds a new border to a buffer by taking a buffer pointer and border data as input, adjusting the border dimensions to fit within existing boundaries, and returning both new and old border data.	0	1	0.1421188630490956	0.012617126105118448	{'f': 0.13559321545532912, 'p': 0.11764705882352941, 'r': 0.16}	{'f': 0.028169009109304588, 'p': 0.02631578947368421, 'r': 0.030303030303030304}	{'f': 0.1016949103705834, 'p': 0.08823529411764706, 'r': 0.12}	None_output	0.4128006100654602
openastroproject-openastro-ec7e71c/ext/ffmpeg/libavformat/utils.c	Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet().	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= FFMIN(s->max_streams, INT_MAX / sizeof(*streams))) {
    if (s->max_streams < INT_MAX / sizeof(*streams))
      av_log(s, AV_LOG_ERROR,
             ""Number of streams exceeds max_streams parameter (%d), see the ""
             ""documentation if you wish to increase it\n"",
             s->max_streams);
    return NULL;
  }
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"	claude-3-5-sonnet-20241022	The function creates and initializes a new AVStream structure within an AVFormatContext, allocating necessary memory and setting default values for various stream parameters before returning the new stream pointer.	0	1	0.12728026533996684	0.016289991303435933	{'f': 0.15094339122819525, 'p': 0.14814814814814814, 'r': 0.15384615384615385}	{'f': 0.06557376552539677, 'p': 0.06060606060606061, 'r': 0.07142857142857142}	{'f': 0.15094339122819525, 'p': 0.14814814814814814, 'r': 0.15384615384615385}	None_output	0.5017750263214111
dakami-autoclave-84ab84b/old_but_working_qemu/block/io.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  enum BdrvTrackedRequestType type) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .type = type,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"	claude-3-5-sonnet-20241022	This function initializes a block device request tracking structure and adds it to the tracked requests list, recording details like the block driver state, offset, size, and request type.	0	1	0.520408163265306	0.12607162121844206	{'f': 0.3529411725778547, 'p': 0.6666666666666666, 'r': 0.24}	{'f': 0.22222221876543213, 'p': 0.5, 'r': 0.14285714285714285}	{'f': 0.3529411725778547, 'p': 0.6666666666666666, 'r': 0.24}	None_output	0.42551809549331665
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Write settings INI file via TinyFrame	2	"bool GEX_IniWrite(GexClient *gex, const char *buffer) {
  uint8_t buf[8];
  PayloadBuilder pb = pb_start(buf, 8, NULL);
  pb_u32(&pb, (uint32_t)strlen(buffer));

  GexBulk bw = (GexBulk){
      .buffer = (uint8_t *)buffer,
      .len = (uint32_t)strlen(buffer),
      .req_cmd = MSG_INI_WRITE,
      .req_data = buf,
      .req_len = (uint32_t)pb_length(&pb),
  };

  return GEX_BulkWrite(GEX_SysUnit(gex), &bw);
}"	claude-3-5-sonnet-20241022	This function writes initialization data from a provided buffer to a GEX client by preparing a bulk write operation with the buffer's length and content.	0	1	0.06329113924050632	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.27302780747413635
rexmac-pebble-chronocode-5a85c4a/src/chronocode.c	Initialize the app	2	"static void init(void) {

  SettingsStoreObject stored_settings;

  if (persist_exists(STORAGE_SETTINGS_KEY)) {
    persist_read_data(STORAGE_SETTINGS_KEY, &stored_settings,
                      sizeof(stored_settings));
    settings = stored_settings.flags;
    language_setting = stored_settings.language;
  } else {
    settings = 0;
    language_setting = LANG_EN_US;
  }

  window = window_create();
  window_set_background_color(
      window, (settings & SETTING_INVERTED) > 0 ? GColorWhite : GColorBlack);
  window_set_window_handlers(
      window, (WindowHandlers){.load = window_load, .unload = window_unload});
  window_stack_push(window, true);

  time_t now = time(NULL);
  struct tm *t = localtime(&now);
  update_time(t);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);

  Tuplet initial_settings[] = {
      TupletInteger(SETTING_SYNC_KEY_ALL_CAPS, (settings & SETTING_ALL_CAPS)),
      TupletInteger(SETTING_SYNC_KEY_INVERTED, (settings & SETTING_INVERTED)),
      TupletInteger(SETTING_SYNC_KEY_LANGUAGE, language_setting),
      TupletInteger(SETTING_SYNC_KEY_TWO_MIN_DOTS,
                    (settings & SETTING_TWO_MIN_DOTS))};
  app_sync_init(
      &settings_sync, settings_sync_buffer, sizeof(settings_sync_buffer),
      initial_settings, ARRAY_LENGTH(initial_settings),
      settings_sync_tuple_changed_callback, settings_sync_error_callback, NULL);
  app_message_open(64, 64);
}"	claude-3-5-sonnet-20241022	This function initializes the application by loading stored settings, creating the main window, setting up time display, and configuring synchronization settings for a Pebble watchface.	0	1	0.1923076923076923	0.007575731225158965	{'f': 0.07692307488165685, 'p': 0.3333333333333333, 'r': 0.043478260869565216}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07692307488165685, 'p': 0.3333333333333333, 'r': 0.043478260869565216}	75	0.49197643995285034
freeciv-freeciv-e4ead30/client/gui-sdl2/spaceshipdlg.c	Popup (or raise) the spaceship dialog for the given player.	2	"void popup_spaceship_dialog(struct player *pPlayer) {
  struct SMALL_DLG *pSpaceShp;

  if (!(pSpaceShp = get_spaceship_dialog(pPlayer))) {
    struct widget *pBuf, *pWindow;
    utf8_str *pstr;
    char cbuf[128];
    SDL_Rect area;

    pSpaceShp = fc_calloc(1, sizeof(struct SMALL_DLG));

    fc_snprintf(cbuf, sizeof(cbuf), _(""The %s Spaceship""),
                nation_adjective_for_player(pPlayer));
    pstr = create_utf8_from_char(cbuf, adj_font(12));
    pstr->style |= TTF_STYLE_BOLD;

    pWindow = create_window_skeleton(NULL, pstr, 0);

    pWindow->action = space_dialog_window_callback;
    set_wstate(pWindow, FC_WS_NORMAL);
    pWindow->data.player = pPlayer;
    pWindow->private_data.small_dlg = pSpaceShp;
    add_to_gui_list(ID_WINDOW, pWindow);
    pSpaceShp->pEndWidgetList = pWindow;

    area = pWindow->area;

    pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                            WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
    pBuf->info_label =
        create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
    pBuf->data.player = pPlayer;
    pBuf->action = exit_space_dialog_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->key = SDLK_ESCAPE;
    area.w = MAX(area.w, (pBuf->size.w + adj_size(10)));

    add_to_gui_list(ID_BUTTON, pBuf);

    pBuf = create_themeicon_button_from_chars(
        current_theme->OK_Icon, pWindow->dst, _(""Launch""), adj_font(12), 0);

    pBuf->action = launch_spaceship_callback;
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_BUTTON, pBuf);

    pstr = create_utf8_from_char(get_spaceship_descr(NULL), adj_font(12));
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_LABEL, pBuf);

    pSpaceShp->pBeginWidgetList = pBuf;

    area.w = MAX(area.w, adj_size(300) - (pWindow->size.w - pWindow->area.w));

    resize_window(pWindow, NULL, NULL,
                  (pWindow->size.w - pWindow->area.w) + area.w,
                  (pWindow->size.h - pWindow->area.h) + area.h);

    area = pWindow->area;

    widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                        (main_window_height() - pWindow->size.h) / 2);

    pBuf = pWindow->prev;
    pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
    pBuf->size.y = pWindow->size.y + adj_size(2);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + area.h - pBuf->size.h - adj_size(7);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + adj_size(7);

    dialog_list_prepend(dialog_list, pSpaceShp);

    refresh_spaceship_dialog(pPlayer);
  } else {
    if (select_window_group_dialog(pSpaceShp->pBeginWidgetList,
                                   pSpaceShp->pEndWidgetList)) {
      widget_flush(pSpaceShp->pEndWidgetList);
    }
  }
}"	claude-3-5-sonnet-20241022	This function creates and displays a dialog window showing spaceship information for a player, allowing them to view details and launch their spaceship in the game.	0	1	0.21551724137931033	0.010864991539917157	{'f': 0.31249999595703126, 'p': 0.5555555555555556, 'r': 0.21739130434782608}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.18749999595703135, 'p': 0.3333333333333333, 'r': 0.13043478260869565}	None_output	0.7070035934448242
particle-iot-device-os-7fbf145/wiring/inc/spark_wiring_mesh.h	Determines if the given handler exists.	2	"#include ""scope_guard.h""
#include <memory>

#include ""spark_wiring_thread.h""

namespace spark {

class MeshSignal : public particle::Signal {
public:
  int rssi = 2;
  int qual = 0;

  MeshSignal() {}
  virtual ~MeshSignal(){};

  operator int8_t() const { return 2; }

  virtual hal_net_access_tech_t getAccessTechnology() const {
    return NET_ACCESS_TECHNOLOGY_IEEE802154;
  }

  virtual float getStrength() const { return 0.0f; }"	claude-3-5-sonnet-20241022	This code defines a MeshSignal class for handling mesh network signals, inheriting from particle::Signal, with basic signal strength and quality attributes.	0	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.12044047564268112
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the aggregated slab journal statistics for the slabs in this allocator.	2	"SlabJournalStatistics
getSlabJournalStatistics(const BlockAllocator *allocator) {
  const AtomicSlabJournalStatistics *atoms = &allocator->slabJournalStatistics;
  return (SlabJournalStatistics){
      .diskFullCount = atomicLoad64(&atoms->diskFullCount),
      .flushCount = atomicLoad64(&atoms->flushCount),
      .blockedCount = atomicLoad64(&atoms->blockedCount),
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
      .tailBusyCount = atomicLoad64(&atoms->tailBusyCount),
  };
}"	claude-3-5-sonnet-20241022	This function retrieves statistical data about slab journal operations from a block allocator by atomically loading various counters related to disk usage, flushes, blocks, and busy states.	0	1	0.27555555555555555	0.01633647013102316	{'f': 0.15789473272853197, 'p': 0.2727272727272727, 'r': 0.1111111111111111}	{'f': 0.054054049875822095, 'p': 0.09090909090909091, 'r': 0.038461538461538464}	{'f': 0.15789473272853197, 'p': 0.2727272727272727, 'r': 0.1111111111111111}	85	0.7164067029953003
opalenzuela-opendomo-1adadbd/src/odbase/src/script.c	Process a comments line and format the output in HTML or XML.	2	"script_process_comments(const char *buf) {
  char tipname[50];
  char *classname = NULL;
  char *contents = NULL;

  if (strlen(buf) < 3)
    return;

  if (gui == html) {
    if ((buf[0] == '-') && (buf[1] == '-')) {
      printf(""\t<hr/>\n"");
    } else if (SPELL3(buf, 'E', 'R', 'R')) {
      printf(""\t<p class='error'>%s</p>\n"", T(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R')) {
      printf(""\t<p class='warning'>%s</p>\n"", T(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F')) {
      printf(""\t<p class='info'>%s</p>\n"", T(buf += 5));
    } else if (SPELL3(buf, 'T', 'I', 'P')) {
      printf(""\t<p class='tooltip tip'>%s</p>\n"", T(buf += 4));
    } else if (SPELL3(buf, 'L', 'O', 'A')) {

      printf(""\t<p class='loading'>%s</p>\n"", T(buf += 8));

      printf(""<script type='text/Javascript'>\n""
             ""$(function($){\n""
             ""	$('p.loading').hide() ;\n""
             ""});\n""
             ""</script>\n"");
    } else if (SPELL3(buf, 'U', 'R', 'L')) {
      printf(""\t<p class='link'>""
             ""<a href='%s' target='_blank'>%s</a></p>\n"",
             buf += 4, buf);
    } else if (buf[0] == '>') {
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    } else {

      if (buf[0] == ' ') {
        printf(""\t<p class='comments'>%s</p>\n"", T(buf += 1));
      } else {
        classname = strtok(buf, "" "");
        contents = strtok(NULL, ""\n"");

        printf(""\t<p class='%s'>%s</p>\n"", classname, T(contents));
      }
    }
  } else {
    if (SPELL3(buf, 'E', 'R', 'R') || SPELL3(buf, 'e', 'r', 'r')) {
      printf(""\t<error description='%s'/>\n"", CT(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R') || SPELL3(buf, 'w', 'a', 'r')) {
      printf(""\t<warning description='%s'/>\n"", CT(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F') || SPELL3(buf, 'i', 'n', 'f'))
      printf(""\t<info description='%s'/>\n"", CT(buf += 5));
    else if (buf[0] == '>')
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    else
      printf(""\t<message description='%s'/>\n"", CT(buf += 1));
  }
}"	claude-3-5-sonnet-20241022	This function processes different types of comments (like errors, warnings, info) and formats them into either HTML or XML output based on the input string and GUI mode.	0	1	0.5060820624546114	0.04108404733153058	{'f': 0.358974354714004, 'p': 0.5833333333333334, 'r': 0.25925925925925924}	{'f': 0.10526315378116359, 'p': 0.18181818181818182, 'r': 0.07407407407407407}	{'f': 0.25641025214990143, 'p': 0.4166666666666667, 'r': 0.18518518518518517}	None_output	0.6217278838157654
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	The function retrieves inquiry data from a USB Mass Storage device by sending a SCSI INQUIRY command to a specific Logical Unit Number (LUN) and stores the response in the provided buffer.	0	1	0.3712307348670985	0.021370288986214202	{'f': 0.36363635914256204, 'p': 0.5333333333333333, 'r': 0.27586206896551724}	{'f': 0.08510637848800386, 'p': 0.125, 'r': 0.06451612903225806}	{'f': 0.13636363186983486, 'p': 0.2, 'r': 0.10344827586206896}	None_output	0.6700239777565002
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/handler/mimemap.c	returns the default mime attributes given a mime type	2	"void h2o_mimemap_get_default_attributes(const char *_mime,
                                        h2o_mime_attributes_t *attr) {
  char *mime = alloca(strlen(_mime) + 1);
  strcpy(mime, _mime);

  const char *type_end_at;

  if ((type_end_at = strchr(mime, ';')) == NULL)
    type_end_at = mime + strlen(mime);

  *attr = (h2o_mime_attributes_t){0};

  if (h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/css"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/javascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/javascript""))) {
    attr->is_compressible = 1;
    attr->priority = H2O_MIME_ATTRIBUTE_PRIORITY_HIGHEST;
  } else if (h2o_memis(mime, type_end_at - mime,
                       H2O_STRLIT(""application/json"")) ||
             strncmp(mime, ""text/"", 5) == 0 ||
             h2o_strstr(mime, type_end_at - mime, H2O_STRLIT(""+xml"")) !=
                 SIZE_MAX) {
    attr->is_compressible = 1;
  }
}"	claude-3-5-sonnet-20241022	This function examines a MIME type string and sets default attributes (compression and priority) based on the content type, particularly for CSS, JavaScript, JSON, text, and XML-related files.	0	1	0.39118246687054026	0.010043468297595231	{'f': 0.3030302993572085, 'p': 0.625, 'r': 0.2}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1818181781450873, 'p': 0.375, 'r': 0.12}	None_output	0.5700439810752869
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/KeyboardHost/KeyboardHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs.	1	"void Keyboard_HID_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    ReadNextReport();

    break;
  }
}"	claude-3-5-sonnet-20241022	This function handles USB keyboard enumeration and configuration in a host system, processing device states and reading keyboard reports while managing any potential errors that occur during the process.	0	1	0.14195583596214512	0.009492360190436455	{'f': 0.23529411266435996, 'p': 0.25, 'r': 0.2222222222222222}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.19607842638985018, 'p': 0.20833333333333334, 'r': 0.18518518518518517}	None_output	0.45881718397140503
HiPhish-XeenTools-ee7c26c/Source/cpp/cpp_tool.c	Read a copy-protection entry from file.	2	"int xeen_read_copy_protection(FILE *fp, long o, int index,
                              XeenCopyProtection *prot) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
    INVALID_DATA,
  } error = SUCCESS;

  uint8_t bytes[LENGTH];

  uint8_t counter = (index * 16);

  if (!fp || !prot) {
    error = INVALID_ARGS;
    goto end;
  } else if (prot->line != 0 || prot->page != 0 || prot->word != 0 ||
             prot->string[0] != '\0') {
    error = INVALID_ARGS;
    goto end;
  }

  if (fseek(fp, o + LENGTH * index, SEEK_SET)) {
    error = FREAD_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), LENGTH, fp) != sizeof(uint8_t) * LENGTH) {
    error = FREAD_FAIL;
    goto end;
  }

  for (int i = 0; i < LENGTH; ++i) {
    bytes[i] ^= (counter++);
  }

  if (bytes[LENGTH - 1] != '\0') {
    error = INVALID_DATA;
    goto end;
  }

  *prot = (XeenCopyProtection){
      .page = bytes[0],
      .line = bytes[1],
      .word = bytes[2],
  };

  for (int i = 0; i < XEEN_CPP_LENGTH; ++i) {
    prot->string[i] = bytes[3 + i];
  }

end:
  return error;
}"	claude-3-5-sonnet-20241022	The function reads and decrypts copy protection data from a file, storing page number, line number, word number, and associated string in a XeenCopyProtection structure after validating input parameters and data integrity.	0	1	0.23255813953488375	0.007678432706586176	{'f': 0.18749999695312503, 'p': 0.5, 'r': 0.11538461538461539}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.12499999695312508, 'p': 0.3333333333333333, 'r': 0.07692307692307693}	75	0.5441007614135742
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Core/HostStandardReq.c	Selects a given alternative setting for the specified interface, via a SET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_SetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        const uint8_t AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_SetInterface,
      .wValue = AltSetting,
      .wIndex = InterfaceIndex,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sets an alternative interface setting for a USB device by sending a control request to change the specified interface index to the desired alternate setting value.	0	1	0.4820018459645165	0.05911245883122324	{'f': 0.4999999951125001, 'p': 0.5882352941176471, 'r': 0.43478260869565216}	{'f': 0.22222221742222234, 'p': 0.2777777777777778, 'r': 0.18518518518518517}	{'f': 0.3499999951125, 'p': 0.4117647058823529, 'r': 0.30434782608695654}	None_output	0.6808099746704102
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Constructs a quaternion from a four-element vector. Note that the imaginary (vector) part of the quaternion comes from lanes 0, 1, and 2 of the vector, and the real (scalar) part comes from lane 3.	2	"static inline SIMD_CFUNC simd_quatd simd_quaternion(simd_double4 xyzr) {
  return (simd_quatd){xyzr};
}"	claude-3-5-sonnet-20241022	This function creates a quaternion (simd_quatd) from a 4D vector (simd_double4) where x, y, z represent the vector part and r represents the scalar part.	0	1	0.2508169934640523	0.025133014281991013	{'f': 0.37209301825851815, 'p': 0.36363636363636365, 'r': 0.38095238095238093}	{'f': 0.1785714236734695, 'p': 0.15625, 'r': 0.20833333333333334}	{'f': 0.37209301825851815, 'p': 0.36363636363636365, 'r': 0.38095238095238093}	None_output	0.6371500492095947
freeciv-freeciv-e4ead30/client/gui-sdl2/repodlgs.c	Popup (or raise) the economy report (F5). It may or may not be modal.	2	"void economy_report_dialog_popup(bool make_modal) {
  SDL_Color bg_color = {255, 255, 255, 128};
  SDL_Color bg_color2 = {255, 255, 255, 136};
  SDL_Color bg_color3 = {255, 255, 255, 64};
  struct widget *pBuf;
  struct widget *pWindow, *pLast;
  utf8_str *pstr, *pstr2;
  SDL_Surface *pSurf, *pText_Name, *pText, *pZoom;
  SDL_Surface *pBackground;
  int i, count, h = 0;
  int w = 0;
  int w2 = 0;
  int w3 = 0;
  int tax, total, entries_used = 0;
  char cbuf[128];
  struct improvement_entry entries[B_LAST];
  SDL_Rect dst;
  SDL_Rect area;
  struct government *pGov = government_of_player(client.conn.playing);
  SDL_Surface *pTreasuryText;
  SDL_Surface *pTaxRateText;
  SDL_Surface *pTotalIncomeText;
  SDL_Surface *pTotalCostText;
  SDL_Surface *pNetIncomeText;
  SDL_Surface *pMaxRateText;

  if (pEconomyDlg) {
    return;
  }

  pBuf = get_tax_rates_widget();
  set_wstate(pBuf, FC_WS_DISABLED);
  widget_redraw(pBuf);
  widget_mark_dirty(pBuf);

  pEconomyDlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  get_economy_report_data(entries, &entries_used, &total, &tax);

  pstr = create_utf8_from_char(_(""Economy Report""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);
  pEconomyDlg->pEndWidgetList = pWindow;
  set_wstate(pWindow, FC_WS_NORMAL);
  pWindow->action = economy_dialog_callback;

  add_to_gui_list(ID_ECONOMY_DIALOG_WINDOW, pWindow);

  area = pWindow->area;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Treasury: ""));
  pstr2 = create_utf8_from_char(cbuf, adj_font(12));
  pstr2->style |= TTF_STYLE_BOLD;
  pTreasuryText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTreasuryText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", client.conn.playing->economic.gold);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(pIcons->pBIG_Coin, pWindow->dst, pstr,
                          (WF_RESTORE_BACKGROUND | WF_ICON_CENTER_RIGHT));

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Tax Rate: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTaxRateText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTaxRateText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "", client.conn.playing->economic.tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w + pBuf->next->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTotalIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Cost: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalCostText = create_text_surf_from_utf8(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Net Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pNetIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pNetIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax - total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  if (tax - total < 0) {
    pstr->fgcol = *get_theme_color(COLOR_THEME_ECONOMYDLG_NEG_TEXT);
  }

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""%s max rate : %d%%""),
              government_name_translation(pGov),
              get_player_bonus(client.conn.playing, EFT_MAX_RATES));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pMaxRateText = create_text_surf_from_utf8(pstr2);

  FREEUTF8STR(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_LUX_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);
  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);
  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_BLOCK_CHECKBOX, pBuf);

  w2 = adj_size(10) + pBuf->size.w;

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.luxury;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_SCROLLBAR, pBuf);

  w2 += adj_size(184);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.luxury);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Luxury, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);
  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_LABEL, pBuf);

  w2 += (adj_size(5) + pBuf->size.w + adj_size(10));

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_SCI_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);

  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);

  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_BLOCK_CHECKBOX, pBuf);

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.science;

  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_SCROLLBAR, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.science);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Colb, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_LABEL, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Update""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon_button(current_theme->Small_OK_Icon, pWindow->dst,
                                 pstr, 0);
  pBuf->action = apply_taxrates_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_OK_BUTTON, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Close Dialog (Esc)""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label = pstr;
  pBuf->action = exit_economy_dialog_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_CANCEL_BUTTON, pBuf);

  h += adj_size(5);

  pLast = pBuf;
  if (entries_used > 0) {

    pBackground = create_surf(adj_size(116), adj_size(116), SDL_SWSURFACE);

    SDL_FillRect(pBackground, NULL, map_rgba(pBackground->format, bg_color));

    create_frame(pBackground, 0, 0, pBackground->w - 1, pBackground->h - 1,
                 get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (SF_CENTER | TTF_STYLE_BOLD);
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};

    for (i = 0; i < entries_used; i++) {
      struct improvement_entry *p = &entries[i];
      struct impr_type *pImprove = p->type;

      pSurf = crop_rect_from_surface(pBackground, NULL);

      fc_snprintf(cbuf, sizeof(cbuf), ""%s"",
                  improvement_name_translation(pImprove));

      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style |= TTF_STYLE_BOLD;
      pText_Name =
          create_text_surf_smaller_than_w(pstr, pSurf->w - adj_size(4));

      fc_snprintf(cbuf, sizeof(cbuf), ""%s %d\n%s %d"", _(""Built""), p->count,
                  _(""U Total""), p->total_cost);
      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style &= ~TTF_STYLE_BOLD;

      pText = create_text_surf_from_utf8(pstr);

      pZoom = get_building_surface(pImprove);
      pZoom = zoomSurface(pZoom, DEFAULT_ZOOM * ((float)54 / pZoom->w),
                          DEFAULT_ZOOM * ((float)54 / pZoom->w), 1);

      dst.x = (pSurf->w - pZoom->w) / 2;
      dst.y = (pSurf->h / 2 - pZoom->h) / 2;
      alphablit(pZoom, NULL, pSurf, &dst, 255);
      dst.y += pZoom->h;
      FREESURFACE(pZoom);

      dst.x = (pSurf->w - pText_Name->w) / 2;
      dst.y += ((pSurf->h - dst.y) -
                (pText_Name->h + (pIcons->pBIG_Coin->h + 2) + pText->h)) /
               2;
      alphablit(pText_Name, NULL, pSurf, &dst, 255);

      dst.y += pText_Name->h;
      if (p->cost) {
        dst.x = (pSurf->w - p->cost * (pIcons->pBIG_Coin->w + 1)) / 2;
        for (count = 0; count < p->cost; count++) {
          alphablit(pIcons->pBIG_Coin, NULL, pSurf, &dst, 255);
          dst.x += pIcons->pBIG_Coin->w + 1;
        }
      } else {

        if (!is_wonder(pImprove)) {
          copy_chars_to_utf8_str(pstr, _(""Nation""));
        } else {
          copy_chars_to_utf8_str(pstr, _(""Wonder""));
        }

        pZoom = create_text_surf_from_utf8(pstr);

        dst.x = (pSurf->w - pZoom->w) / 2;
        alphablit(pZoom, NULL, pSurf, &dst, 255);
        FREESURFACE(pZoom);
      }

      dst.y += (pIcons->pBIG_Coin->h + adj_size(2));
      dst.x = (pSurf->w - pText->w) / 2;
      alphablit(pText, NULL, pSurf, &dst, 255);

      FREESURFACE(pText);
      FREESURFACE(pText_Name);

      pBuf =
          create_icon2(pSurf, pWindow->dst,
                       (WF_RESTORE_BACKGROUND | WF_FREE_THEME | WF_FREE_DATA));

      set_wstate(pBuf, FC_WS_NORMAL);

      pBuf->data.cont = fc_calloc(1, sizeof(struct CONTAINER));
      pBuf->data.cont->id0 = improvement_number(p->type);
      pBuf->data.cont->id1 = p->count;
      pBuf->action = popup_sell_impr_callback;

      add_to_gui_list(MAX_ID - i, pBuf);

      if (i > (TARGETS_ROW * TARGETS_COL - 1)) {
        set_wflag(pBuf, WF_HIDDEN);
      }
    }

    FREEUTF8STR(pstr);
    FREESURFACE(pBackground);

    pEconomyDlg->pEndActiveWidgetList = pLast->prev;
    pEconomyDlg->pBeginWidgetList = pBuf;
    pEconomyDlg->pBeginActiveWidgetList = pEconomyDlg->pBeginWidgetList;

    if (entries_used > (TARGETS_ROW * TARGETS_COL)) {
      pEconomyDlg->pActiveWidgetList = pEconomyDlg->pEndActiveWidgetList;
      count = create_vertical_scrollbar(pEconomyDlg, TARGETS_COL, TARGETS_ROW,
                                        TRUE, TRUE);
      h += (TARGETS_ROW * pBuf->size.h + adj_size(10));
    } else {
      count = 0;
      if (entries_used > TARGETS_COL) {
        h += pBuf->size.h;
      }
      h += (adj_size(10) + pBuf->size.h);
    }
    count = TARGETS_COL * pBuf->size.w + count;
  } else {
    pEconomyDlg->pBeginWidgetList = pBuf;
    h += adj_size(10);
    count = 0;
  }

  area.w = MAX(area.w, MAX(adj_size(10) + w3 + w + w2, count));
  area.h = h;

  pBackground = theme_get_background(theme, BACKGROUND_ECONOMYDLG);
  if (resize_window(pWindow, pBackground, NULL,
                    (pWindow->size.w - pWindow->area.w) + area.w,
                    (pWindow->size.h - pWindow->area.h) + area.h)) {
    FREESURFACE(pBackground);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + adj_size(10) + pTreasuryText->w;
  pBuf->size.y = area.y + adj_size(5);

  w = pTreasuryText->w + pBuf->size.w;
  h = pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTaxRateText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTaxRateText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalCostText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalCostText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pNetIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pNetIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  dst.x = area.x;
  dst.y = area.y;
  dst.w = area.w;
  dst.h = h + adj_size(15);
  h = dst.h;

  fill_rect_alpha(pWindow->theme, &dst, &bg_color2);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  dst.x = area.x + adj_size(10);
  dst.y = area.y + adj_size(5);

  alphablit(pTreasuryText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTreasuryText->h;
  FREESURFACE(pTreasuryText);

  alphablit(pTaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTaxRateText->h;
  FREESURFACE(pTaxRateText);

  alphablit(pTotalIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalIncomeText->h;
  FREESURFACE(pTotalIncomeText);

  alphablit(pTotalCostText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalCostText->h;
  FREESURFACE(pTotalCostText);

  alphablit(pNetIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pNetIncomeText->h;
  FREESURFACE(pNetIncomeText);

  dst.x = area.x + adj_size(10) + w +
          ((area.w - (w + adj_size(10)) - pMaxRateText->w) / 2);
  dst.y = area.y + adj_size(5);

  alphablit(pMaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += (pMaxRateText->h + 1);
  FREESURFACE(pMaxRateText);

  dst.x = area.x + adj_size(10) + w +
          (area.w - (w + adj_size(10)) - adj_size(184)) / 2;
  dst.w = adj_size(184);
  dst.h = current_theme->Horiz->h - adj_size(2);

  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.luxury * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  dst.y += current_theme->Horiz->h + 1;
  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.science * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + (dst.w - pBuf->size.w) / 2;
  pBuf->size.y = dst.y + dst.h + adj_size(3);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  if (entries_used > 0) {
    setup_vertical_widgets_position(TARGETS_COL, area.x, area.y + h, 0, 0,
                                    pEconomyDlg->pBeginActiveWidgetList,
                                    pEconomyDlg->pEndActiveWidgetList);
    if (pEconomyDlg->pScroll) {
      setup_vertical_scrollbar_area(pEconomyDlg->pScroll, area.x + area.w - 1,
                                    area.y + h, area.h - h - 1, TRUE);
    }
  }

  redraw_group(pEconomyDlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);
  flush_dirty();
}"	claude-3-5-sonnet-20241022	The function creates and displays an economy report dialog window showing treasury, tax rates, income, costs, and building maintenance details for a player in the game.	0	1	0.20764802631578952	0.01700463072175106	{'f': 0.16216215777940113, 'p': 0.25, 'r': 0.12}	{'f': 0.05263157444598377, 'p': 0.07692307692307693, 'r': 0.04}	{'f': 0.10810810372534715, 'p': 0.16666666666666666, 'r': 0.08}	75	0.5083796977996826
darktable-org-darktable-32fab21/src/iop/flip.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_flip_params_t p = (dt_iop_flip_params_t){ORIENTATION_NONE};
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  p.orientation = ORIENTATION_NULL;
  dt_gui_presets_add_generic(_(""autodetect""), self->op, self->version(), &p,
                             sizeof(p), 1);
  dt_gui_presets_update_autoapply(_(""autodetect""), self->op, self->version(),
                                  1);

  p.orientation = ORIENTATION_NONE;
  dt_gui_presets_add_generic(_(""no rotation""), self->op, self->version(), &p,
                             sizeof(p), 1);

  p.orientation = ORIENTATION_FLIP_HORIZONTALLY;
  dt_gui_presets_add_generic(_(""flip horizontally""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_FLIP_VERTICALLY;
  dt_gui_presets_add_generic(_(""flip vertically""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by -90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CCW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by  90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_180_DEG;
  dt_gui_presets_add_generic(_(""rotate by 180 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	This function initializes preset orientations for image flipping and rotation operations in darktable, including options like autodetect, no rotation, horizontal/vertical flips, and various degree rotations.	0	1	0.16853932584269662	0.009970222994544455	{'f': 0.1538461490072322, 'p': 0.1875, 'r': 0.13043478260869565}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1538461490072322, 'p': 0.1875, 'r': 0.13043478260869565}	75	0.3377605080604553
DelusionalLogic-NeoComp-271e784/src/compton.c	Do the actual work.	2	"void session_run(session_t *ps) {
#ifdef DEBUG_PROFILE
  struct ProfilerWriterSession profSess;
  profilerWriter_init(&profSess);
#endif

  paint_preprocess(ps);

  timestamp lastTime;
  if (!getTime(&lastTime)) {
    printf_errf(""Failed getting time"");
    session_destroy(ps);
    exit(1);
  }

  assign_depth(&ps->win_list, &ps->order);

  ps->idling = false;

  while (!ps->reset) {

    zone_start(&ZONE_global);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    zone_enter(&ZONE_input);

    while (mainloop(ps))
      ;

    Swiss *em = &ps->win_list;

    for_components(it, em, COMPONENT_PHYSICAL, COMPONENT_TRACKS_WINDOW,
                   COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct TracksWindowComponent *window =
          swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);

      XWindowAttributes attribs;
      if (!XGetWindowAttributes(ps->xcontext.display, window->id, &attribs)) {
        printf_errf(""Failed getting window attributes while mapping"");
        swiss_removeComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
        continue;
      }

      Vector2 extents = {{attribs.width + attribs.border_width * 2,
                          attribs.height + attribs.border_width * 2}};

      Vector2 offset = {{-attribs.border_width, -attribs.border_width}};

      XserverRegion window_region = XFixesCreateRegionFromWindow(
          ps->xcontext.display, window->id, ShapeBounding);

      XRectangle default_clip = {.x = offset.x,
                                 .y = offset.y,
                                 .width = extents.x,
                                 .height = extents.y};
      XserverRegion default_clip_region =
          XFixesCreateRegion(ps->xcontext.display, &default_clip, 1);
      XFixesIntersectRegion(ps->xcontext.display, window_region, window_region,
                            default_clip_region);

      int rect_count;
      XRectangle *rects =
          XFixesFetchRegion(ps->xcontext.display, window_region, &rect_count);

      XFixesDestroyRegion(ps->xcontext.display, window_region);

      vector_init(&shapeDamaged->rects, sizeof(struct Rect), rect_count);

      convert_xrects_to_relative_rect(rects, rect_count, &extents, &offset,
                                      &shapeDamaged->rects);
    }

    zone_leave(&ZONE_input);

    timestamp currentTime;
    if (!getTime(&currentTime)) {
      printf_errf(""Failed getting time"");
      exit(1);
    }

    double dt = timeDiff(&lastTime, &currentTime);

    ps->skip_poll = false;

    if (ps->o.benchmark) {
      if (ps->o.benchmark_wid) {
        win *w = find_win(ps, ps->o.benchmark_wid);
        if (!w) {
          printf_errf(""(): Couldn't find specified benchmark window."");
          session_destroy(ps);
          exit(1);
        }
      }
    }

    ps->idling = true;

    zone_enter(&ZONE_preprocess);

    paint_preprocess(ps);

    zone_leave(&ZONE_preprocess);

    zone_enter(&ZONE_update);

    zone_enter(&ZONE_update_z);
    assign_depth(&ps->win_list, &ps->order);
    zone_leave(&ZONE_update_z);

    zone_enter(&ZONE_update_wintype);

    for_components(it, em, COMPONENT_MAP, CQ_END) {
      swiss_addComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
    }

    fill_wintype_changes(&ps->win_list, ps);

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      swiss_ensureComponent(em, COMPONENT_FOCUS_CHANGE, it.id);
    }

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      struct WintypeChangedComponent *wintypeChanged =
          swiss_getComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
      struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

      w->window_type = wintypeChanged->newType;
    }
    zone_leave(&ZONE_update_wintype);

    if (ps->o.shadow_blacklist) {
      zone_enter(&ZONE_update_shadow_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->shadow = (ps->o.wintype_shadow[w->window_type] &&
                       !win_match(ps, w, ps->o.shadow_blacklist) &&
                       !(ps->o.respect_prop_shadow));
        }
      }
      zone_leave(&ZONE_update_shadow_blacklist);
    }

    if (ps->o.fade_blacklist) {
      zone_enter(&ZONE_update_fade_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

        if (win_mapped(em, it.id)) {

          if (win_match(ps, w, ps->o.fade_blacklist)) {
            w->fade = false;
          } else {
            w->fade = ps->o.wintype_fade[w->window_type];
          }
        }
      }
      zone_leave(&ZONE_update_fade_blacklist);
    }

    if (ps->o.blur_background_blacklist) {
      zone_enter(&ZONE_update_blur_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          bool blur_background_new =
              ps->o.blur_background &&
              !win_match(ps, w, ps->o.blur_background_blacklist);

          win_set_blur_background(ps, w, blur_background_new);
        }
      }
      zone_leave(&ZONE_update_blur_blacklist);
    }

    if (ps->o.paint_blacklist) {
      zone_enter(&ZONE_update_paint_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->paint_excluded = win_match(ps, w, ps->o.paint_blacklist);
        }
      }
      zone_leave(&ZONE_update_paint_blacklist);
    }

    zone_enter(&ZONE_input_react);
    commit_destroy(&ps->win_list);
    commit_map(&ps->win_list, &ps->atoms, &ps->xcontext);
    commit_unmap(&ps->win_list, &ps->xcontext);
    commit_opacity_change(&ps->win_list, ps->o.opacity_fade_time,
                          ps->o.bg_opacity_fade_time);
    commit_move(&ps->win_list, &ps->order);
    commit_resize(&ps->win_list, &ps->order);
    commit_reshape(&ps->win_list, &ps->xcontext);
    zone_leave(&ZONE_input_react);

    zone_enter(&ZONE_make_cutout);
    {
      XserverRegion newShape = XFixesCreateRegion(ps->dpy, NULL, 0);
      for_components(it, em, COMPONENT_MUD, COMPONENT_TRACKS_WINDOW,
                     COMPONENT_PHYSICAL, CQ_NOT, COMPONENT_REDIRECTED, CQ_END) {
        struct TracksWindowComponent *tracksWindow =
            swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
        struct PhysicalComponent *physical =
            swiss_getComponent(em, COMPONENT_PHYSICAL, it.id);

        if (win_mapped(em, it.id)) {
          XserverRegion windowRegion = XFixesCreateRegionFromWindow(
              ps->xcontext.display, tracksWindow->id, ShapeBounding);
          XFixesTranslateRegion(ps->dpy, windowRegion, physical->position.x + 1,
                                physical->position.y + 1);
          XFixesUnionRegion(ps->xcontext.display, newShape, newShape,
                            windowRegion);
          XFixesDestroyRegion(ps->xcontext.display, windowRegion);
        }
      }
      XFixesInvertRegion(ps->dpy, newShape,
                         &(XRectangle){0, 0, ps->root_size.x, ps->root_size.y},
                         newShape);
      XFixesSetWindowShapeRegion(ps->dpy, ps->overlay, ShapeBounding, 0, 0,
                                 newShape);
      XFixesDestroyRegion(ps->xcontext.display, newShape);
    }
    zone_leave(&ZONE_make_cutout);

    zone_enter(&ZONE_prop_blur_damage);
    damage_blur_over_damaged(&ps->win_list, &ps->order);
    zone_leave(&ZONE_prop_blur_damage);

    zone_enter(&ZONE_update_textures);
    update_window_textures(&ps->win_list, &ps->xcontext,
                           &ps->psglx->shared_fbo);
    zone_leave(&ZONE_update_textures);

    update_focused_state(&ps->win_list, ps);
    calculate_window_opacity(ps, &ps->win_list);
    start_focus_fade(&ps->win_list, ps->o.opacity_fade_time,
                     ps->o.bg_opacity_fade_time, ps->o.dim_fade_time);

    zone_enter(&ZONE_update_fade);

    damage_blur_over_fade(&ps->win_list);
    syncronize_fade_opacity(&ps->win_list);
    if (do_win_fade(&ps->curve, dt, &ps->win_list)) {
      ps->skip_poll = true;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      t->time += dt;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      if (t->time >= t->duration)
        swiss_removeComponent(em, COMPONENT_TRANSITIONING, it.id);
    }

    zone_leave(&ZONE_update_fade);

    transition_faded_entities(&ps->win_list);
    remove_texture_invis_windows(&ps->win_list);
    finish_destroyed_windows(&ps->win_list, ps);
    zone_leave(&ZONE_update);

    Vector opaque;
    vector_init(&opaque, sizeof(win_id), ps->order.size);
    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED, CQ_NOT,
                   COMPONENT_BGOPACITY, COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&opaque, &it.id);
    }
    vector_qsort(&opaque, window_zcmp, &ps->win_list);
    Vector transparent;
    vector_init(&transparent, sizeof(win_id), ps->order.size);

    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED,
                   COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&transparent, &it.id);
    }
    vector_qsort(&transparent, window_zcmp, &ps->win_list);

    Vector opaque_shadow;
    vector_init(&opaque_shadow, sizeof(win_id), ps->order.size);
    fetchSortedWindowsWith(&ps->win_list, &opaque_shadow, COMPONENT_MUD,
                           COMPONENT_Z, COMPONENT_PHYSICAL, CQ_NOT,
                           COMPONENT_OPACITY, COMPONENT_SHADOW, CQ_END);

    zone_enter(&ZONE_effect_textures);

    zone_enter(&ZONE_update_shadow);
    windowlist_updateShadow(ps, &transparent);
    zone_leave(&ZONE_update_shadow);

    if (ps->o.blur_background)
      windowlist_updateBlur(ps);

    zone_leave(&ZONE_effect_textures);

    {
      static int paint = 0;

      zone_enter(&ZONE_paint);

      glDepthMask(GL_TRUE);
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      static const GLenum DRAWBUFS[2] = {GL_BACK_LEFT};
      glDrawBuffers(1, DRAWBUFS);
      glViewport(0, 0, ps->root_size.x, ps->root_size.y);

      glClearDepth(1.0);
      glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
      glDepthFunc(GL_LESS);

      windowlist_drawBackground(ps, &opaque);
      windowlist_drawTint(ps);
      windowlist_draw(ps, &opaque);

      paint_root(ps);

      windowlist_drawTransparent(ps, &transparent);

#ifdef DEBUG_WINDOWS

      draw_component_debug(&ps->win_list, &ps->root_size);
#endif

      vector_kill(&opaque_shadow);
      vector_kill(&transparent);
      vector_kill(&opaque);

      zone_leave(&ZONE_paint);

      paint++;
      if (ps->o.benchmark && paint >= ps->o.benchmark) {
#ifdef DEBUG_PROFILE
        profilerWriter_kill(&profSess);
#endif
        session_destroy(ps);
        exit(0);
      }
    }

    zone_enter(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_MAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_UNMAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_MOVE);
    swiss_removeComponentWhere(
        &ps->win_list, COMPONENT_RESIZE,
        (enum ComponentType[]){COMPONENT_PHYSICAL, CQ_END});

    swiss_resetComponent(em, COMPONENT_WINTYPE_CHANGE);

    swiss_resetComponent(&ps->win_list, COMPONENT_FOCUS_CHANGE);

    for_components(it, em, COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
      if (shapeDamaged->rects.elementSize != 0) {
        vector_kill(&shapeDamaged->rects);
      }
    }
    swiss_resetComponent(&ps->win_list, COMPONENT_SHAPE_DAMAGED);

    zone_leave(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_CONTENTS_DAMAGED);

#ifdef FRAMERATE_DISPLAY
    update_debug_graph(&ps->debug_graph, currentTime);
    draw_debug_graph(&ps->debug_graph, &(Vector2){{10, ps->root_size.y - 10}});
#endif

    struct ZoneEventStream *event_stream = zone_package(&ZONE_global);
#ifdef DEBUG_PROFILE

    profilerWriter_emitFrame(&profSess, event_stream);
#endif

    glXSwapBuffers(ps->dpy, get_tgt_window(ps));
    glFinish();

    lastTime = currentTime;
  }

#ifdef DEBUG_PROFILE
  profilerWriter_kill(&profSess);
#endif
}"	claude-3-5-sonnet-20241022	This function manages the main rendering loop of a compositing window manager, handling window updates, effects (like shadows and blur), and drawing them to the screen using OpenGL.	0	1	0.15625000000000003	0.006716472052354862	{'f': 0.06896551486325811, 'p': 0.25, 'r': 0.04}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06896551486325811, 'p': 0.25, 'r': 0.04}	None_output	0.1082051694393158
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t),
                           NO_STREAM_CALLBACK);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
      NO_STREAM_CALLBACK);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	This function sends control line state changes from a USB CDC device to the host through a notification endpoint using a standard USB request header structure.	0	1	0.12975901334258588	0.009295829121333954	{'f': 0.24999999565200623, 'p': 0.1836734693877551, 'r': 0.391304347826087}	{'f': 0.04597700739859992, 'p': 0.03225806451612903, 'r': 0.08}	{'f': 0.22222221787422847, 'p': 0.16326530612244897, 'r': 0.34782608695652173}	None_output	0.7693960666656494
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities.	1	"uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
                          SCSI_Inquiry_Response_t *const InquiryPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, InquiryPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI INQUIRY command to a mass storage device to retrieve device information and stores the response in the provided InquiryPtr structure.	0	1	0.44246495327102797	0.03152861344254501	{'f': 0.43243242752373995, 'p': 0.5, 'r': 0.38095238095238093}	{'f': 0.13953487878853452, 'p': 0.15789473684210525, 'r': 0.125}	{'f': 0.3243243194156319, 'p': 0.375, 'r': 0.2857142857142857}	None_output	0.6801868081092834
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Publishes the message to the current process and frees the strings.	2	"static void fio_publish2process(fio_msg_internal_s *m) {
  fio_msg_internal_finalize(m);
  channel_s *ch;
  if (m->filter) {
    ch = fio_filter_find_dup(m->filter);
    if (!ch) {
      goto finish;
    }
  } else {
    ch = fio_channel_find_dup(m->channel);
  }

  if (ch) {
    fio_defer_push_urgent(fio_publish2channel_task, ch,
                          fio_msg_internal_dup(m));
  }
  if (m->filter == 0) {

    fio_lock(&fio_postoffice.patterns.lock);
    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {
      if (!p->hash) {
        continue;
      }

      if (p->obj->match(
              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},
              m->channel)) {
        fio_channel_dup(p->obj);
        fio_defer_push_urgent(fio_publish2channel_task, p->obj,
                              fio_msg_internal_dup(m));
      }
    }
    fio_unlock(&fio_postoffice.patterns.lock);
  }
finish:
  fio_msg_internal_free(m);
}"	claude-3-5-sonnet-20241022	This function handles message publishing within a process by finalizing the message, finding appropriate channels (either through filters or direct matching), and dispatching the message to matched channels using deferred tasks.	0	1	0.36891679748822603	0.03550467708240432	{'f': 0.2777777740277778, 'p': 0.5555555555555556, 'r': 0.18518518518518517}	{'f': 0.10256409875082198, 'p': 0.2, 'r': 0.06896551724137931}	{'f': 0.16666666291666676, 'p': 0.3333333333333333, 'r': 0.1111111111111111}	30	0.5562490820884705
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/macsub.c	Returns a macro substitution result wrapping a silent error as produced by ava_macsub_silent_error().	2	"ava_macro_subst_result
ava_macsub_silent_error_result(const ava_compile_location *location) {
  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = ava_macsub_silent_error(location)};
}"	claude-3-5-sonnet-20241022	This function creates and returns a macro substitution result structure indicating a completed substitution with a silent error node at the specified location.	0	1	0.4508928571428571	0.14908960803395838	{'f': 0.3749999953125, 'p': 0.5, 'r': 0.3}	{'f': 0.29411764249134953, 'p': 0.4166666666666667, 'r': 0.22727272727272727}	{'f': 0.3749999953125, 'p': 0.5, 'r': 0.3}	85	0.5392493009567261
opticron-libuweave-2e5e385/src/ble_transport.c	Initializes a BLE transport service to handle BLE input and registers it in the runloop.	0	"bool uw_ble_transport_init(UwBleTransport *transport, UwDevice *device) {
  assert(transport != NULL && device != NULL);

  memset(transport, 0, sizeof(UwBleTransport));
  transport->device = device;

  uw_buffer_init(&transport->read_buffer, transport->read_data,
                 sizeof(transport->read_data));

  uw_buffer_init(&transport->write_buffer, transport->write_data,
                 sizeof(transport->write_data));

  uw_session_init_(&transport->session, device);

  uw_device_channel_init_(
      &transport->device_channel,
      (UwDeviceChannelHandshakeConfig){.handler = handshake_exchange_handler_,
                                       .data = (void *)transport},
      (UwDeviceChannelConnectionResetConfig){
          .handler = connection_reset_handler_, .data = (void *)transport},
      &transport->read_buffer, &transport->write_buffer, UW_BLE_PACKET_SIZE);

  uw_service_init_(&transport->service, service_start_handler_,
                   service_event_handler_, service_stop_handler_, transport);

  uw_device_register_service_(transport->device, &transport->service);

  UwSettings *settings = uw_device_get_settings(transport->device);
  settings->supports_ble_40 = true;

  return true;
}"	claude-3-5-sonnet-20241022	This function initializes a Bluetooth Low Energy (BLE) transport structure by setting up buffers, session, device channel, and service configurations while registering it with the device.	0	1	0.4274978912660072	0.02101654884156187	{'f': 0.35897435437212366, 'p': 0.5, 'r': 0.28}	{'f': 0.051282046679816326, 'p': 0.07142857142857142, 'r': 0.04}	{'f': 0.3076923030900723, 'p': 0.42857142857142855, 'r': 0.24}	None_output	0.6894426941871643
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command.	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a Mass Storage Reset command to a USB mass storage device to reset its interface state through a control request.	0	1	0.28113553113553114	0.010757132026790277	{'f': 0.3461538414201184, 'p': 0.28125, 'r': 0.45}	{'f': 0.06249999548828158, 'p': 0.047619047619047616, 'r': 0.09090909090909091}	{'f': 0.23076922603550304, 'p': 0.1875, 'r': 0.3}	95	0.7655993700027466
graphitemaster-redroid-9cdd940/string.c	Constructs an empty managed string object.	2	"string_t *string_construct(void) {
  string_t *string =
      memcpy(malloc(sizeof(string_t)),
             &(string_t){.buffer = malloc(8), .allocated = 8, .length = 0},
             sizeof(string_t));
  *string->buffer = '\0';
  return string;
}"	claude-3-5-sonnet-20241022	This function creates and initializes a new string_t structure with an empty 8-byte buffer, setting its allocated size to 8 and length to 0, then returns a pointer to the structure.	0	1	0.2205882352941176	0.012756976469629349	{'f': 0.12499999695312508, 'p': 0.3333333333333333, 'r': 0.07692307692307693}	{'f': 0.05714285469387766, 'p': 0.2, 'r': 0.03333333333333333}	{'f': 0.12499999695312508, 'p': 0.3333333333333333, 'r': 0.07692307692307693}	None_output	0.4430655837059021
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/MassStorageHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read in blocks from the device and print them to the serial port.	1	"TASK(USB_MassStore_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Mass Storage Disk Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    UpdateStatus(Status_Busy);

    if ((ErrorCode = MassStore_GetMaxLUN(&MassStore_MaxLUNIndex)) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Get Max LUN""), false, ErrorCode);
      break;
    }

    printf_P(PSTR(""Total LUNs: %d.\r\n""), (MassStore_MaxLUNIndex + 1));

    if ((ErrorCode = MassStore_MassStorageReset()) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Mass Storage Reset""), false, ErrorCode);
      break;
    }

    SCSI_Request_Sense_Response_t SenseData;
    if (((ErrorCode = MassStore_RequestSense(0, &SenseData)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Request Sense""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    if (((ErrorCode = MassStore_PreventAllowMediumRemoval(0, true)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Prevent/Allow Medium Removal""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""Waiting until ready..""));

    do {
      Serial_TxByte('.');

      if ((ErrorCode = MassStore_TestUnitReady(0)) != 0) {
        ShowDiskReadError(PSTR(""Test Unit Ready""), false, ErrorCode);
        break;
      }
    } while ((SCSICommandStatus.Status != Command_Pass) && USB_IsConnected);

    if (!(USB_IsConnected))
      break;

    puts_P(PSTR(""\r\nRetrieving Capacity... ""));

    SCSI_Capacity_t DiskCapacity;

    if (((ErrorCode = MassStore_ReadCapacity(0, &DiskCapacity)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Capacity""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    printf_P(PSTR(""%lu blocks of %lu bytes.\r\n""), DiskCapacity.Blocks,
             DiskCapacity.BlockSize);

    uint8_t BlockBuffer[DiskCapacity.BlockSize];

    if (((ErrorCode = MassStore_ReadDeviceBlock(
              0, 0x00000000, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Device Block""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""\r\nContents of first block:\r\n""));

    for (uint16_t Chunk = 0; Chunk < (DiskCapacity.BlockSize >> 4); Chunk++) {

      uint8_t *ChunkPtr = &BlockBuffer[Chunk << 4];

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        printf_P(PSTR(""%.2X ""), CurrByte);
      }

      puts_P(PSTR(""    ""));

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      puts_P(PSTR(""\r\n""));
    }

    puts_P(PSTR(""\r\n\r\nPress board button to read entire ASCII contents of ""
                ""disk...\r\n\r\n""));

    while (!(Buttons_GetStatus() & BUTTONS_BUTTON1)) {

      if (!(USB_IsConnected))
        break;
    }

    for (uint32_t CurrBlock = 0; CurrBlock < DiskCapacity.Blocks; CurrBlock++) {

      if (((ErrorCode = MassStore_ReadDeviceBlock(
                0, CurrBlock, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
          (SCSICommandStatus.Status != Command_Pass)) {
        ShowDiskReadError(PSTR(""Read Device Block""),
                          (SCSICommandStatus.Status != Command_Pass),
                          ErrorCode);
        break;
      }

      for (uint16_t Byte = 0; Byte < DiskCapacity.BlockSize; Byte++) {
        char CurrByte = BlockBuffer[Byte];

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      if (!(USB_IsConnected))
        break;
    }

    UpdateStatus(Status_USBReady);

    while (USB_IsConnected)
      ;

    break;
  }
}"	claude-3-5-sonnet-20241022	This function implements a USB Mass Storage host that enumerates a connected storage device, reads its capacity and contents, and can display the data in both hexadecimal and ASCII formats.	0	1	0.13745704467353953	0.009337534921653758	{'f': 0.16326530117451077, 'p': 0.18181818181818182, 'r': 0.14814814814814814}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.12244897464389858, 'p': 0.13636363636363635, 'r': 0.1111111111111111}	None_output	0.3968375325202942
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_ps(float __a, float __b, float __c, float __d, float __e, float __f,
               float __g, float __h) {
  return (__m256){__a, __b, __c, __d, __e, __f, __g, __h};
}"	claude-3-5-sonnet-20241022	This function creates a 256-bit vector by setting 8 single-precision floating-point values in reverse order from the input parameters.	0	1	0.10344827586206898	0.01340082578177889	{'f': 0.18749999517578136, 'p': 0.23076923076923078, 'r': 0.15789473684210525}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.18749999517578136, 'p': 0.23076923076923078, 'r': 0.15789473684210525}	10	0.34249699115753174
pgrawehr-golgotha-5d70da4/string/string.h	Attempts to convert the string to a number.	2	"i4_str *read_string();

w32 read_ascii(char *buffer, w32 buffer_size);

sw32 read_number(i4_bool throwexception = i4_F);

double read_float(i4_bool throwexception = i4_F);
}
;

virtual ~i4_const_str(){};

const iterator end() const { return ptr + len; }
iterator end() { return ptr + len; }

const iterator begin() const { return ptr; }
iterator begin() { return ptr; }

w32 length() const { return len; }"	claude-3-5-sonnet-20241022	These functions handle string reading, ASCII character reading, number reading, floating-point reading, and provide basic string operations like iterators and length measurement in a custom string implementation.	0	1	0.15151515151515152	0.009186672262412125	{'f': 0.21428571053571432, 'p': 0.42857142857142855, 'r': 0.14285714285714285}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.14285713910714296, 'p': 0.2857142857142857, 'r': 0.09523809523809523}	None_output	0.4298255443572998
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Close a stream	2	"void stream_close(pony_ctx_t **ctx, stream_t *s) {
  struct scons *scons = scons_mk(*ctx, NULL);
  scons->eos = true;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
}"	claude-3-5-sonnet-20241022	This function closes a stream by creating a new stream constructor (scons) with an end-of-stream marker and fulfilling the stream's future with this constructor.	0	1	0.2941176470588236	0.016734480530603443	{'f': 0.1739130412098299, 'p': 0.6666666666666666, 'r': 0.1}	{'f': 0.07999999852800002, 'p': 0.5, 'r': 0.043478260869565216}	{'f': 0.1739130412098299, 'p': 0.6666666666666666, 'r': 0.1}	75	0.7088819742202759
HarveyHunt-howm-81b1d82/src/monitor.c	Create a single monitor for use with default X11.	2	"static void scan_x11_monitor(void) {
  monitor_t *m =
      create_monitor((xcb_rectangle_t){0, 0, screen_width, screen_height});

  add_ws(m);
}"	claude-3-5-sonnet-20241022	This function creates a monitor spanning the entire screen dimensions and adds a workspace to it.	0	1	0.20618556701030927	0.014628063653657535	{'f': 0.1666666619791668, 'p': 0.2222222222222222, 'r': 0.13333333333333333}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1666666619791668, 'p': 0.2222222222222222, 'r': 0.13333333333333333}	None_output	0.47824621200561523
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, BlockBuffer);
}"	claude-3-5-sonnet-20241022	This function reads data blocks from a connected USB Mass Storage device by sending a SCSI READ_10 command and retrieving the specified number of blocks into a buffer.	0	1	0.5419461456206864	0.019427446513842185	{'f': 0.38888888464506177, 'p': 0.6363636363636364, 'r': 0.28}	{'f': 0.05405405010956932, 'p': 0.1, 'r': 0.037037037037037035}	{'f': 0.22222221797839511, 'p': 0.36363636363636365, 'r': 0.16}	85	0.6513697504997253
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/CDC.c	Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.	2	"uint8_t CDC_Host_SendBreak(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo,
                           const uint8_t Duration) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SendBreak,
      .wValue = Duration,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a break signal of specified duration from a USB host to a CDC (Communication Device Class) device through the control pipe.	0	1	0.19379844961240314	0.011394659250985381	{'f': 0.24390243405116013, 'p': 0.2631578947368421, 'r': 0.22727272727272727}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1951219462462821, 'p': 0.21052631578947367, 'r': 0.18181818181818182}	85	0.5330344438552856
ikeydoherty-ui-tests-41140ce/src/popover.c	Work out the geometry for the relative_to widget in absolute coordinates on the screen.	2	"static void budgie_popover_compute_widget_geometry(GtkWidget *parent_widget,
                                                   GdkRectangle *target) {
  GtkAllocation alloc = {0};
  GtkWidget *toplevel = NULL;
  GdkWindow *toplevel_window = NULL;
  gint rx, ry = 0;
  gint x, y = 0;

  if (!parent_widget) {
    g_warning(""compute_widget_geometry(): missing relative_widget"");
    return;
  }

  toplevel = gtk_widget_get_toplevel(parent_widget);
  toplevel_window = gtk_widget_get_window(toplevel);
  gdk_window_get_position(toplevel_window, &x, &y);
  gtk_widget_translate_coordinates(parent_widget, toplevel, x, y, &rx, &ry);
  gtk_widget_get_allocation(parent_widget, &alloc);

  *target = (GdkRectangle){
      .x = rx, .y = ry, .width = alloc.width, .height = alloc.height};
}"	claude-3-5-sonnet-20241022	This function calculates and sets the geometric position and dimensions of a GTK widget relative to its parent widget's coordinates in the window system.	0	1	0.19999999999999998	0.011833064662823948	{'f': 0.23529411307958487, 'p': 0.3333333333333333, 'r': 0.18181818181818182}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.17647058366782017, 'p': 0.25, 'r': 0.13636363636363635}	75	0.6293768882751465
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/hash-map-impl.c	Builds a new hash table for the given hash map. A call to ava_hash_map_vacuum() is implied.	2	"static size_t ava_hash_map_rehash(ava_hash_map *restrict map,
                                  size_t num_elements, ava_bool permit_ascii9) {
  size_t i, orig_num_elements;
  size_t new_size AVA_UNUSED;
  ava_list_value keys;
  ava_hash_map_hash_function preferred_hash_function;
  ava_bool vacuumed;
  const ava_hash_map_index *restrict old_index = map->index;

  orig_num_elements = num_elements;
  num_elements = ava_hash_map_vacuum(map, num_elements);
  vacuumed = orig_num_elements != num_elements;

  keys = (ava_list_value){ava_value_with_ulong(map->keys, num_elements)};

  if (NULL != map->index || num_elements > ASCII9_SIZE_THRESH) {
    preferred_hash_function = map->index->hash_function;
  } else {
    preferred_hash_function = ava_hmhf_ascii9;
    for (i = 0; i < num_elements && preferred_hash_function != ava_hmhf_value;
         ++i) {
      if (!is_ascii9_string(map->esba_trait->index(keys, i))) {
        preferred_hash_function = ava_hmhf_value;
      }
    }
  }

  map->index = ava_hash_map_index_new(desired_capacity(num_elements));
  map->index->num_elements = 0;
  map->index->hash_function =
      permit_ascii9 ? preferred_hash_function : ava_hmhf_value;
  memset(map->index->indices, -1, sizeof(TYPE) * (map->index->mask + 1));

  if (old_index && !vacuumed &&
      map->index->hash_function == old_index->hash_function) {

    for (i = 0; i < num_elements; ++i) {
      map->index->hash_cache[i] = old_index->hash_cache[i];
      ava_hash_map_put_direct(map, i, old_index->hash_cache[i]);
    }
    map->index->num_elements = num_elements;
  } else {
    for (i = 0; i < num_elements; ++i) {
      new_size = ava_hash_map_put(map, i, map->esba_trait->index(keys, i));
      assert(i + 1 == new_size);
      ++map->index->num_elements;
    }
  }

  return num_elements;
}"	claude-3-5-sonnet-20241022	This function rehashes a hash map by creating a new index structure, choosing between ASCII9 or value-based hashing, and reorganizing the elements while potentially optimizing the process if certain conditions are met.	0	1	0.2724953617810761	0.01844982575005087	{'f': 0.22222221777777784, 'p': 0.3333333333333333, 'r': 0.16666666666666666}	{'f': 0.0869565173440456, 'p': 0.13333333333333333, 'r': 0.06451612903225806}	{'f': 0.13333332888888905, 'p': 0.2, 'r': 0.1}	None_output	0.5117814540863037
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer.	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function reads data blocks from a USB mass storage device by sending a SCSI READ_10 command and retrieving the specified number of blocks into a buffer.	0	1	0.406306200641176	0.07305891545072536	{'f': 0.4680851013852422, 'p': 0.4782608695652174, 'r': 0.4583333333333333}	{'f': 0.19607842637447148, 'p': 0.2, 'r': 0.19230769230769232}	{'f': 0.2978723354277954, 'p': 0.30434782608695654, 'r': 0.2916666666666667}	None_output	0.7286002039909363
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_rate_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  uint32_t *clock_rate;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int error_code;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_rate_get, clock_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
        clock_protocol_data.num_clocks;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
          clock_id;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      clock_rate =
          &(received.payload[OFFSET_RET(struct arm_scmi_clock_rate_get, rate)]);
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.lower,
          clock_rate[0], ""CLOCK RATE LOWER"");
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.upper,
          clock_rate[1], ""CLOCK RATE UPPER"");
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests the SCMI clock rate get functionality by sending requests for different clock IDs and comparing the received rates with expected values.	0	1	0.3366553232863393	0.02975858216526934	{'f': 0.44999999505, 'p': 0.5, 'r': 0.4090909090909091}	{'f': 0.09523809028344697, 'p': 0.10526315789473684, 'r': 0.08695652173913043}	{'f': 0.39999999505, 'p': 0.4444444444444444, 'r': 0.36363636363636365}	None_output	0.7114021182060242
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/maps.c	Create a new definite map	2	"cbor_item_t *cbor_new_definite_map(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = size,
                                    .type = _CBOR_METADATA_DEFINITE,
                                    .end_ptr = 0}},
      .data = _cbor_alloc_multiple(sizeof(struct cbor_pair), size)};
  if (item->data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }
  return item;
}"	claude-3-5-sonnet-20241022	The function creates a new CBOR map item with a specified size, allocating memory for the map structure and its pairs while initializing necessary metadata.	0	1	0.2857142857142857	0.01772984226469502	{'f': 0.21428571135204083, 'p': 0.6, 'r': 0.13043478260869565}	{'f': 0.07142856897959192, 'p': 0.25, 'r': 0.041666666666666664}	{'f': 0.21428571135204083, 'p': 0.6, 'r': 0.13043478260869565}	85	0.4090050458908081
PJK-libcbor-87f977e/src/cbor/arrays.c	Create new indefinite array	2	"cbor_item_t *cbor_new_indefinite_array() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                      .allocated = 0,
                                      .end_ptr = 0}},
      .data = NULL};
  return item;
}"	claude-3-5-sonnet-20241022	This function creates and returns a new CBOR array item with indefinite length, initializing it with default values and a reference count of 1.	0	1	0.33333333333333337	0.01041441909198652	{'f': 0.23999999731200003, 'p': 0.75, 'r': 0.14285714285714285}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15999999731200001, 'p': 0.5, 'r': 0.09523809523809523}	None_output	0.5700929164886475
freeciv-freeciv-e4ead30/client/gui-sdl2/plrdlg.c	Popup (or raise) the player list dialog.	2	"void popup_players_dialog(bool raise) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL, *pZoomed = NULL;
  utf8_str *pstr;
  SDL_Rect dst;
  int i, n, h;
  double a, b, r;
  SDL_Rect area;

  if (pPlayers_Dlg) {
    return;
  }

  n = 0;
  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }
    n++;
  }
  players_iterate_end;

  if (n < 2) {
    return;
  }

  pPlayers_Dlg = fc_calloc(1, sizeof(struct SMALL_DLG));

  pstr = create_utf8_from_char(Q_(""?header:Players""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = players_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_WINDOW, pWindow);
  pPlayers_Dlg->pEndWidgetList = pWindow;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  pBuf->action = exit_players_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_BUTTON, pBuf);

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_NEUTRAL_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_neutral_status_callback;
      pBuf->key = SDLK_n;
      break;
    case DS_WAR:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_WAR_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_war_status_callback;
      pBuf->key = SDLK_w;
      break;
    case DS_CEASEFIRE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_CEASEFIRE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_ceasefire_status_callback;
      pBuf->key = SDLK_c;
      break;
    case DS_PEACE:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_PEACE_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_peace_status_callback;
      pBuf->key = SDLK_p;
      break;
    case DS_ALLIANCE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_ALLIANCE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_alliance_status_callback;
      pBuf->key = SDLK_a;
      break;
    default:

      continue;
      break;
    }
    set_wstate(pBuf, FC_WS_NORMAL);
    add_to_gui_list(ID_CHECKBOX, pBuf);
  }

  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

    pLogo = get_nation_flag_surface(nation_of_player(pPlayer));
    {

      double zoom = DEFAULT_ZOOM * (60.0 - n) / pLogo->h;

      pZoomed = zoomSurface(pLogo, zoom, zoom, 1);
    }

    pBuf = create_icon2(pZoomed, pWindow->dst,
                        WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                            WF_FREE_THEME);
    pBuf->info_label = pstr;

    if (!pPlayer->is_alive) {
      pstr = create_utf8_from_char(_(""R.I.P.""), adj_font(10));
      pstr->style |= TTF_STYLE_BOLD;
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_TEXT);
      pLogo = create_text_surf_from_utf8(pstr);
      FREEUTF8STR(pstr);

      dst.x = (pZoomed->w - pLogo->w) / 2;
      dst.y = (pZoomed->h - pLogo->h) / 2;
      alphablit(pLogo, NULL, pZoomed, &dst, 255);
      FREESURFACE(pLogo);
    }

    if (pPlayer->is_alive) {
      set_wstate(pBuf, FC_WS_NORMAL);
    }

    pBuf->data.player = pPlayer;

    pBuf->action = player_callback;

    add_to_gui_list(ID_LABEL, pBuf);
  }
  players_iterate_end;

  pPlayers_Dlg->pBeginWidgetList = pBuf;

  resize_window(pWindow, NULL, NULL, adj_size(500), adj_size(400));

  area = pWindow->area;

  r = MIN(area.w, area.h);
  r -= ((MAX(pBuf->size.w, pBuf->size.h) * 2));
  r /= 2;
  a = (2.0 * M_PI) / n;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  n = area.y;
  pstr = create_utf8_str(NULL, 0, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ARMISTICE);
      break;
    case DS_WAR:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_WAR);
      break;
    case DS_CEASEFIRE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_CEASEFIRE);
      break;
    case DS_PEACE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_PEACE);
      break;
    case DS_ALLIANCE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ALLIANCE);
      break;
    default:

      continue;
      break;
    }

    copy_chars_to_utf8_str(pstr, diplstate_type_translated_name(i));
    pLogo = create_text_surf_from_utf8(pstr);

    pBuf = pBuf->prev;
    h = MAX(pBuf->size.h, pLogo->h);
    pBuf->size.x = area.x + adj_size(5);
    pBuf->size.y = n + (h - pBuf->size.h) / 2;

    dst.x = adj_size(5) + pBuf->size.w + adj_size(6);
    dst.y = n + (h - pLogo->h) / 2;
    alphablit(pLogo, NULL, pWindow->theme, &dst, 255);
    n += h;
    FREESURFACE(pLogo);
  }
  FREEUTF8STR(pstr);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 - pBuf->size.w / 2;
  pBuf->size.y = area.y + area.h / 2 - r - pBuf->size.h / 2;

  n = 1;
  if (pBuf != pPlayers_Dlg->pBeginWidgetList) {
    do {
      pBuf = pBuf->prev;
      b = M_PI_2 + n * a;
      pBuf->size.x = area.x + area.w / 2 - r * cos(b) - pBuf->size.w / 2;
      pBuf->size.y = area.y + area.h / 2 - r * sin(b) - pBuf->size.h / 2;
      n++;
    } while (pBuf != pPlayers_Dlg->pBeginWidgetList);
  }

  players_dialog_update();
}"	claude-3-5-sonnet-20241022	This function creates and displays a dialog window showing all active players in a game, with their nation flags arranged in a circle and diplomatic status indicators represented by checkboxes.	0	1	0.10752688172043011	0.006244385951234721	{'f': 0.060606057263544726, 'p': 0.14285714285714285, 'r': 0.038461538461538464}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.060606057263544726, 'p': 0.14285714285714285, 'r': 0.038461538461538464}	None_output	0.4054163694381714
darktable-org-darktable-32fab21/src/iop/borders.c	this is the chance to update default parameters, after the full raw is loaded.	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_borders_params_t tmp =
      (dt_iop_borders_params_t){{1.0f, 1.0f, 1.0f},
                                DT_IOP_BORDERS_ASPECT_CONSTANT_VALUE,
                                ""constant border"",
                                0,
                                0.1f,
                                0.5f,
                                ""1/2"",
                                0.5f,
                                ""1/2"",
                                0.0f,
                                0.5f,
                                {0.0f, 0.0f, 0.0f},
                                TRUE};
  memcpy(self->params, &tmp, sizeof(dt_iop_borders_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_borders_params_t));
  self->default_enabled = 0;
}"	claude-3-5-sonnet-20241022	This function resets both current and default parameters of a border effect module to predefined values, including color, aspect ratio, size, and position settings.	0	1	0.21041666666666667	0.01851974703879588	{'f': 0.1714285669224491, 'p': 0.25, 'r': 0.13043478260869565}	{'f': 0.05555555094135841, 'p': 0.07692307692307693, 'r': 0.043478260869565216}	{'f': 0.114285709779592, 'p': 0.16666666666666666, 'r': 0.08695652173913043}	None_output	0.36493122577667236
xipengwang-FLAG-cd1815e/april2/src/vx/vxo_sphere.c	In this implementation, the only data passed to the shader are the texture coordinates. These texture coordinates can be trivially converted into latitude and longitude, but are adjusted so that the triangles render textures properly across the longitude=PI boundary. The shader computes lat/lon from the shader coordinates, then computes xyz.	2	"vx_object_t *vxo_sphere_textured(vx_resource_t *texture_resource) {
  static vx_resource_t *program_resource = NULL;
  static vx_resource_t *sts_resource = NULL;
  static vx_resource_t *tris_resource = NULL;
  static int nvertices = 0, napositions = 0;

  vx_lock();

  if (program_resource == NULL) {

    zarray_t *vertex_datas = zarray_create(sizeof(struct vertex_data));
    zarray_t *tris = zarray_create(sizeof(uint16_t[3]));

    const double v = sqrt(3) / 3;
    double *xyza = (double[]){v, v, v};
    double *xyzb = (double[]){-v, -v, v};
    double *xyzc = (double[]){-v, v, -v};
    double *xyzd = (double[]){v, -v, -v};

    int depth = 4;

    recurse(vertex_datas, tris, xyza, xyzc, xyzb, depth);
    recurse(vertex_datas, tris, xyza, xyzb, xyzd, depth);
    recurse(vertex_datas, tris, xyza, xyzd, xyzc, depth);
    recurse(vertex_datas, tris, xyzb, xyzc, xyzd, depth);

    zarray_t *sts = zarray_create(sizeof(float[2]));

    for (int i = 0; i < zarray_size(vertex_datas); i++) {
      struct vertex_data *vd;
      zarray_get_volatile(vertex_datas, i, &vd);

      float *st = (float[]){vd->st[0], vd->st[1]};

      zarray_add(sts, st);
    }

    nvertices = zarray_size(tris) * 3;

    char vertex_shader_src[] =
        ""#define PI 3.14159265358979323846264338\n""
        ""attribute vec2 st; \n""
        ""varying vec2 vtexcoord; \n""
        ""uniform mat4 VX_P;\n""
        ""uniform mat4 VX_V;\n""
        ""uniform mat4 VX_M;\n""
        ""void main(void) {\n""
        ""  float lat = (PI / 2.0) - PI * st.y; \n ""
        ""  float lon = 2.0 * PI * st.x; \n ""
        ""  vtexcoord = st.xy; \n""
        ""  float r = cos(lat); \n ""
        ""  vec3 xyz = vec3(r*cos(lon), r*sin(lon), sin(lat)); \n ""
        ""  gl_Position = VX_P * VX_V * VX_M * vec4(xyz, 1.0);\n""
        ""}"";

    char fragment_shader_src[] = ""precision mediump float; \n""
                                 ""varying vec2 vtexcoord; \n""
                                 ""uniform sampler2D texture; \n""
                                 ""void main(void) {\n""
                                 ""  vec4 c = texture2D(texture, vtexcoord);\n""
                                 ""  gl_FragColor = vec4(c.r, c.g, c.b, 1);\n""
                                 ""}\n"";

    program_resource =
        vx_resource_make_program(vertex_shader_src, fragment_shader_src);
    program_resource->incref(program_resource);

    sts_resource = vx_resource_make_attr_f32_copy((float *)sts->data,
                                                  zarray_size(sts) * 2, 2);
    sts_resource->incref(sts_resource);

    tris_resource =
        vx_resource_make_idx_u16_copy((uint16_t *)tris->data, nvertices);
    tris_resource->incref(tris_resource);
  }

  vx_unlock();

  return vxo_generic_create(
      program_resource, (struct vxo_generic_uniformf[]){{.name = NULL}},
      (struct vxo_generic_attribute[]){{.name = ""st"", .resource = sts_resource},
                                       {.name = NULL}},
      (struct vxo_generic_texture[]){
          {.name = ""texture"", .resource = texture_resource}, {.name = NULL}},
      (struct vxo_generic_draw[]){
          {.command = VX_GL_TRIANGLES,
           .first = 0,
           .count = nvertices,
           .indices_resource = tris_resource},
          {.count = 0},
      });
}"	claude-3-5-sonnet-20241022	This function creates a textured sphere by dividing a tetrahedron into triangles recursively and applying texture coordinates, using vertex and fragment shaders for rendering.	0	1	0.09493670886075949	0.007122157099271659	{'f': 0.16666666202222233, 'p': 0.13157894736842105, 'r': 0.22727272727272727}	{'f': 0.028571424159184355, 'p': 0.02127659574468085, 'r': 0.043478260869565216}	{'f': 0.09999999535555577, 'p': 0.07894736842105263, 'r': 0.13636363636363635}	75	0.566832959651947
AsydSolutions-monit-9e43388/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVh"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""id"", no_argument, NULL, 'i'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""version"", no_argument, NULL, 'V'},
                              {""help"", no_argument, NULL, 'h'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.controlfile = Str_dup(f);
      break;
    }
    case 'd': {
      Run.isdaemon = true;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.logfile = Str_dup(optarg);
      if (IS(Run.logfile, ""syslog""))
        Run.use_syslog = true;
      Run.dolog = true;
      break;
    }
    case 'p': {
      Run.pidfile = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.statefile = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.init = true;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.idfile);
      Util_monitId(Run.idfile);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"	claude-3-5-sonnet-20241022	This function handles command-line options for the Monit program, parsing various flags and arguments to configure program behavior such as daemon mode, logging, configuration files, and other runtime settings.	0	1	0.1923076923076923	0.009152541620698935	{'f': 0.186046506955111, 'p': 0.25, 'r': 0.14814814814814814}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.09302325114115761, 'p': 0.125, 'r': 0.07407407407407407}	None_output	0.3912104666233063
braice-MuMuDVB-745259a/src/sap.c	Initialize sap variables	2	"void init_sap_v(sap_p_t *sap_p) {
  *sap_p = (sap_p_t){
      .sap_messages4 = NULL,
      .sap_messages6 = NULL,
      .sap = OPTION_UNDEFINED,
      .sap_interval = SAP_DEFAULT_INTERVAL,
      .sap_sending_ip4 = ""0.0.0.0"",
      .sap_sending_ip6 = ""::"",
      .sap_default_group = """",
      .sap_organisation = ""MuMuDVB"",
      .sap_uri = ""\0"",
      .sap_ttl = SAP_DEFAULT_TTL,
  };
}"	claude-3-5-sonnet-20241022	This function initializes a SAP (Session Announcement Protocol) structure with default values for its various parameters including IP addresses, interval, TTL, and other settings.	0	1	0.19607843137254902	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.5355895757675171
RfidResearchGroup-proxmark3-1650889/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLogEx(WARNING, ""missing addr"");
    return 0;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    req[reqlen++] = iso15cmd;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    if (!getUID(uid)) {
      PrintAndLogEx(WARNING, ""No tag found"");
      return 0;
    }
    memcpy(&req[reqlen], uid, sizeof(uid));
    PrintAndLogEx(NORMAL, ""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += sizeof(uid);
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLogEx(NORMAL, ""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], uid, sizeof(uid));
    reqlen += sizeof(uid);
    break;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"	claude-3-5-sonnet-20241022	The function prepares and formats commands for ISO15693 protocol communication, handling different addressing modes (no address, UID from tag, or manually specified UID) and command options for USB device interaction.	0	1	0.09090909090909091	0.00821807407726565	{'f': 0.14285713826530627, 'p': 0.2, 'r': 0.1111111111111111}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.09523809064625872, 'p': 0.13333333333333333, 'r': 0.07407407407407407}	75	0.38828858733177185
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c	Clears a stall condition on the given pipe, via a CLEAR FEATURE standard request to the attached device.	1	"uint8_t USB_Host_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_SEL_EndpointHalt,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	The function clears a stall condition on a specified USB endpoint by sending a control request to the device with the Clear Feature command.	0	1	0.5829674874339886	0.15573188896329046	{'f': 0.43243242752373995, 'p': 0.5, 'r': 0.38095238095238093}	{'f': 0.24999999511250007, 'p': 0.29411764705882354, 'r': 0.21739130434782608}	{'f': 0.43243242752373995, 'p': 0.5, 'r': 0.38095238095238093}	None_output	0.7203502655029297
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/pub.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){pub,
                  'p',
                  ""pub"",
                  ""extract the public key from a private key/certificate"",
                  {""[--in file|--keyid hex] [--type rsa|ecdsa|pkcs10|x509]"",
                   ""[--outform der|pem|pgp]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""keyid"", 'x', 1, ""keyid on smartcard of private key""},
                      {""type"", 't', 1, ""type of credential, default: rsa""},
                      {""outform"", 'f', 1, ""encoding of extracted public key""},
                  }});
}"	claude-3-5-sonnet-20241022	This function registers a command for extracting public keys from private keys/certificates with various input and output options during program initialization.	0	1	0.20833333333333334	0.009134423666564471	{'f': 0.0833333311458334, 'p': 0.3333333333333333, 'r': 0.047619047619047616}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0833333311458334, 'p': 0.3333333333333333, 'r': 0.047619047619047616}	None_output	0.4159244894981384
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to zero.	2	_mm256_setzero_pd(void) { return __extension__(__m256d){0, 0, 0, 0}; }	claude-3-5-sonnet-20241022	It returns a 256-bit vector containing four double-precision floating-point zeros (0.0).	0	1	0.275089605734767	0.03009034171528095	{'f': 0.3076923028106509, 'p': 0.26666666666666666, 'r': 0.36363636363636365}	{'f': 0.07999999520000028, 'p': 0.06666666666666667, 'r': 0.1}	{'f': 0.23076922588757406, 'p': 0.2, 'r': 0.2727272727272727}	None_output	0.7563362121582031
vm6502q-qrack-df6132d/include/qinterface.hpp	"Quantum analog of classical ""XOR"" gate. Takes one qubit input and one classical bit input. Measures the outputBit, then overwrites it with result."	2	"}

virtual ~QInterface(){};

int GetQubitCount() { return qubitCount; }"	claude-3-5-sonnet-20241022	This code shows a virtual destructor and a getter method to return the number of qubits in the quantum interface.	0	1	0.15418502202643172	0.010908370635616393	{'f': 0.15789473185595584, 'p': 0.15, 'r': 0.16666666666666666}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1052631529085875, 'p': 0.1, 'r': 0.1111111111111111}	10	0.5268744230270386
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Retrieves the device sense data, indicating the current device state and error codes for the previously issued command.	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Request_Sense_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, SenseData);
}"	claude-3-5-sonnet-20241022	This function sends a REQUEST SENSE command to a USB Mass Storage device to retrieve error information and stores the response in the provided SenseData structure.	0	1	0.2127659574468085	0.011371681934875243	{'f': 0.2631578899584488, 'p': 0.3333333333333333, 'r': 0.21739130434782608}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.10526315311634371, 'p': 0.13333333333333333, 'r': 0.08695652173913043}	85	0.6453884243965149
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the list parser state struct with data to be parsed.	2	"psyc_parse_list_buffer_set(PsycParseListState *state, const char *buffer,
                           size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	This function initializes a parsing state by setting its buffer to the provided input string and resetting the cursor position to zero.	0	1	0.22292993630573252	0.012990806323574158	{'f': 0.2857142808163266, 'p': 0.3333333333333333, 'r': 0.25}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.2285714236734695, 'p': 0.26666666666666666, 'r': 0.2}	75	0.4917184114456177
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the update modifier parser state struct with data to be parsed.	2	"psyc_parse_update_buffer_set(PsycParseUpdateState *state, const char *buffer,
                             size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	This function initializes a parsing state by setting a buffer with given content and length, and resets the cursor position to the beginning (zero) for subsequent parsing operations.	0	1	0.30932049418604657	0.010511846841633778	{'f': 0.29999999520000004, 'p': 0.375, 'r': 0.25}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1999999952000001, 'p': 0.25, 'r': 0.16666666666666666}	None_output	0.46293818950653076
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Construct the metric terms (and optionally the jacobian determinant) terms at the nodes of input type for the volume under consideration.	2	"static void
constructor_volume_metric_terms_T(const char node_type,
                                  struct Solver_Volume_T *const s_vol) {

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Geometry_Element *g_e =
      &((struct Solver_Element *)vol->element)->g_e;

  const int p = s_vol->p_ref;
  const bool curved = vol->curved;
  const int p_g = (curved ? p : 1);

  struct Container {
    struct Multiarray_Operator *cv1_vg_vX;
    const struct Operator *vv0_vm_vX;
    struct Multiarray_T *metrics_vX;
    struct Multiarray_T *jacobian_det_vX;
  } con;
  struct Multiarray_Operator cv1_vg_vm =
      set_MO_from_MO(g_e->cv1_vg_vm[curved], 1, (ptrdiff_t[]){0, 0, p_g, p_g});
  struct Multiarray_Operator cv1_vg_vc =
      set_MO_from_MO(g_e->cv1_vg_vc[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});
  struct Multiarray_Operator cv1_vg_vs =
      set_MO_from_MO(g_e->cv1_vg_vs[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});

  switch (node_type) {
  case 'm':
    con.cv1_vg_vX = &cv1_vg_vm;
    con.vv0_vm_vX = NULL;
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vm;
    con.jacobian_det_vX = NULL;
    break;
  case 'c':
    con.cv1_vg_vX = &cv1_vg_vc;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vc[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vc;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vc;
    break;
  case 's':
    con.cv1_vg_vX = &cv1_vg_vs;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vs[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vs;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vs;
    break;
  default:
    EXIT_ERROR(""Unsupported: %c\n"", node_type);
    break;
  }
  const ptrdiff_t n_vX = con.cv1_vg_vX->data[0]->op_std->ext_0;
  struct Multiarray_T *const jacobian_vX =
      constructor_empty_Multiarray_T('C', 3, (ptrdiff_t[]){n_vX, DIM, DIM});

  const char op_format = get_set_op_format(0);
  const struct const_Multiarray_T *const geom_coef = s_vol->geom_coef;
  for (ptrdiff_t row = 0; row < DIM; ++row)
    mm_NN1C_Operator_Multiarray_T(con.cv1_vg_vX->data[row], geom_coef,
                                  jacobian_vX, op_format, 2, NULL, &row);

  if (node_type == 'm') {
    compute_cofactors_T((struct const_Multiarray_T *)jacobian_vX,
                        con.metrics_vX);
  } else {
    assert(compute_size(s_vol->metrics_vm->order, s_vol->metrics_vm->extents) >
           0);
    const struct const_Multiarray_T *const met_vm = s_vol->metrics_vm;
    resize_Multiarray_T(con.metrics_vX, 3, (ptrdiff_t[]){n_vX, DIM, DIM});
    mm_NN1C_Operator_Multiarray_T(con.vv0_vm_vX, met_vm, con.metrics_vX,
                                  op_format, met_vm->order, NULL, NULL);
  }

  if (con.jacobian_det_vX) {
    const ptrdiff_t *const perm = set_jacobian_permutation(DIM);
    permute_Multiarray_T(jacobian_vX, perm, jacobian_vX->layout);

    compute_detJV_T((struct const_Multiarray_T *)jacobian_vX,
                    con.jacobian_det_vX);
  }
  destructor_Multiarray_T(jacobian_vX);
}"	claude-3-5-sonnet-20241022	This function computes geometric metrics and Jacobian determinants for volume elements in a numerical solver, using different node types ('m', 'c', 's') and handling curved geometries.	0	1	0.2474563953488372	0.00956240657444202	{'f': 0.14285713803854888, 'p': 0.17647058823529413, 'r': 0.12}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.14285713803854888, 'p': 0.17647058823529413, 'r': 0.12}	None_output	0.6975902915000916
freeciv-freeciv-e4ead30/client/gui-sdl2/mapview.c	Typically an info box is provided to tell the player about the state of their civilization. This function is called when the label is changed.	2	"void update_info_label(void) {
  SDL_Color bg_color = {0, 0, 0, 80};
  SDL_Surface *pTmp = NULL;
  char buffer[512];
#ifdef SMALL_SCREEN
  SDL_Rect area = {0, 0, 0, 0};
#else
  SDL_Rect area = {0, 3, 0, 0};
#endif
  struct utf8_str *ptext;

  if (get_current_client_page() != PAGE_GAME) {
    return;
  }

#ifdef SMALL_SCREEN
  ptext = create_utf8_str(NULL, 0, 8);
#else
  ptext = create_utf8_str(NULL, 0, 10);
#endif

  ptext->style |= TTF_STYLE_BOLD;
  ptext->fgcol = *get_theme_color(COLOR_THEME_MAPVIEW_INFO_TEXT);
  ptext->bgcol = (SDL_Color){0, 0, 0, 0};

  if (NULL != client.conn.playing) {
#ifdef SMALL_SCREEN
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold);
#else
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d Tax: %d Lux: %d Sci: %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold,
                client.conn.playing->economic.tax,
                client.conn.playing->economic.luxury,
                client.conn.playing->economic.science);
#endif

    copy_chars_to_utf8_str(ptext, buffer);
    pTmp = create_text_surf_from_utf8(ptext);

    area.x = (main_window_width() - pTmp->w) / 2 - adj_size(5);
    area.w = pTmp->w + adj_size(8);
    area.h = pTmp->h + adj_size(4);

    SDL_FillRect(Main.gui->surface, &area,
                 map_rgba(Main.gui->surface->format, bg_color));

    create_line(Main.gui->surface, area.x + 1, area.y, area.x + area.w - 2,
                area.y, get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x + 1, area.y + area.h - 1,
                area.x + area.w - 2, area.y + area.h - 1,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    create_line(Main.gui->surface, area.x + area.w - 1, area.y + 1,
                area.x + area.w - 1, area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x, area.y + 1, area.x,
                area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    blit_entire_src(pTmp, Main.gui->surface, area.x + adj_size(5),
                    area.y + adj_size(2));

    dirty_sdl_rect(&area);

    FREESURFACE(pTmp);
  }

  set_indicator_icons(client_research_sprite(), client_warming_sprite(),
                      client_cooling_sprite(), client_government_sprite());

  update_timeout_label();

  FREEUTF8STR(ptext);

  queue_flush();
}"	claude-3-5-sonnet-20241022	This function updates and displays game information including population, year, gold, and other economic indicators in a labeled area at the top of the game screen using SDL graphics library.	0	1	0.16721132897603486	0.016604746091696276	{'f': 0.1666666617447918, 'p': 0.19047619047619047, 'r': 0.14814814814814814}	{'f': 0.03773584410110425, 'p': 0.041666666666666664, 'r': 0.034482758620689655}	{'f': 0.08333332841145863, 'p': 0.09523809523809523, 'r': 0.07407407407407407}	None_output	0.49785274267196655
darktable-org-darktable-32fab21/src/iop/lowpass.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""local contrast mask""), self->op, self->version(),
      &(dt_iop_lowpass_params_t){0, 50.0f, -1.0f, 0.0f, 0.0f,
                                 LOWPASS_ALGO_GAUSSIAN, 1},
      sizeof(dt_iop_lowpass_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	This function initializes a preset for a local contrast mask filter in darktable by adding default parameters to the database using SQL transactions.	0	1	0.2113636363636364	0.009849349468888718	{'f': 0.1052631530193908, 'p': 0.125, 'r': 0.09090909090909091}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1052631530193908, 'p': 0.125, 'r': 0.09090909090909091}	None_output	0.348193883895874
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance limits set command and testing the received values.	3	"void arm_scmi_custom_test_performance_limits_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 3;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_max)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MAX - 1];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_min)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MIN + 1];
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_max)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX] + 1;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_min)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN] - 1;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX - 1];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN + 1];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_SUCCESS
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        ptr_data->domain_runtime_values[domain_id].range_min =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_min)];
        ptr_data->domain_runtime_values[domain_id].range_max =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_max)];
      }
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests the SCMI performance limits setting functionality by validating different parameter combinations (domain ID, range maximum, range minimum) and checking if the system responds correctly to valid and invalid inputs.	0	1	0.35094339622641507	0.01687589360987099	{'f': 0.25531914421004986, 'p': 0.3333333333333333, 'r': 0.20689655172413793}	{'f': 0.03999999528800055, 'p': 0.05263157894736842, 'r': 0.03225806451612903}	{'f': 0.21276595272068824, 'p': 0.2777777777777778, 'r': 0.1724137931034483}	None_output	0.5798574090003967
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host.	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t));

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;

      FrameIN.FrameInBuffer = true;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t));

      Endpoint_Write_Stream_LE(FrameOUT.FrameData,
                               RNDISPacketHeader.DataLength);

      Endpoint_ClearIN();

      FrameOUT.FrameInBuffer = false;
    }
  }
}"	claude-3-5-sonnet-20241022	This function handles RNDIS (Remote Network Driver Interface Specification) communication tasks, including processing incoming packets, managing message headers, and transmitting outgoing data between the USB device and host.	0	1	0.10460251046025104	0.00497948402394365	{'f': 0.1999999950500001, 'p': 0.18181818181818182, 'r': 0.2222222222222222}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1333333283833335, 'p': 0.12121212121212122, 'r': 0.14814814814814814}	None_output	0.6030166149139404
dm-vdo-kvdo-8df6805/vdo/base/slab.c	Measure and initialize the configuration to use for each slab.	2	"int configureSlab(BlockCount slabSize, BlockCount slabJournalBlocks,
                  SlabConfig *slabConfig) {
  if (slabJournalBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount refBlocks =
      getSavedReferenceCountSize(slabSize - slabJournalBlocks);
  BlockCount metaBlocks = (refBlocks + slabJournalBlocks);

  if (metaBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount dataBlocks = slabSize - metaBlocks;
  if ((slabSize < 1024) && !isPowerOfTwo(dataBlocks)) {
    dataBlocks = ((BlockCount)1 << logBaseTwo(dataBlocks));
  }

  BlockCount flushingThreshold = ((slabJournalBlocks * 3) + 3) / 4;

  BlockCount remaining = slabJournalBlocks - flushingThreshold;
  BlockCount blockingThreshold = flushingThreshold + ((remaining * 5) / 7);

  BlockCount minimalExtraSpace =
      1 + (MAXIMUM_USER_VIOS / SLAB_JOURNAL_FULL_ENTRIES_PER_BLOCK);
  BlockCount scrubbingThreshold = blockingThreshold;
  if (slabJournalBlocks > minimalExtraSpace) {
    scrubbingThreshold = slabJournalBlocks - minimalExtraSpace;
  }
  if (blockingThreshold > scrubbingThreshold) {
    blockingThreshold = scrubbingThreshold;
  }

  *slabConfig =
      (SlabConfig){.slabBlocks = slabSize,
                   .dataBlocks = dataBlocks,
                   .referenceCountBlocks = refBlocks,
                   .slabJournalBlocks = slabJournalBlocks,
                   .slabJournalFlushingThreshold = flushingThreshold,
                   .slabJournalBlockingThreshold = blockingThreshold,
                   .slabJournalScrubbingThreshold = scrubbingThreshold};
  return VDO_SUCCESS;
}"	claude-3-5-sonnet-20241022	This function configures a storage slab by calculating various thresholds and block allocations, ensuring proper distribution of space between data blocks, reference counts, and journal blocks while validating the configuration parameters.	0	1	0.3074380165289256	0.015170687183605524	{'f': 0.20512820131492446, 'p': 0.4, 'r': 0.13793103448275862}	{'f': 0.051282047731755674, 'p': 0.1111111111111111, 'r': 0.03333333333333333}	{'f': 0.15384615003287322, 'p': 0.3, 'r': 0.10344827586206896}	None_output	0.4723973870277405
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	Paint menubar.	2	"virtual ~Font(){};

virtual int getHeight() const = 0;

virtual int getAscent() const = 0;

template <typename STR>
int getWidth(const STR s, Size start = 0, Size len = (Size)-1) const {
  return this->getWidth(String(s), start, len);
}

virtual int getWidth(Char c = 'M') const = 0;

virtual int getWidth(const String &s, Size start = 0,
                     Size len = (Size)-1) const {
  int width = 0;
  if (start + len > s.size())
    len = (Size)(s.size() - start);
  while (len--)
    width += getWidth(s[start++]);
  return width;
}"	claude-3-5-sonnet-20241022	This code defines font-related functions to calculate text dimensions (height, ascent, and width) for both single characters and strings, with the base Font class providing virtual methods for derived font classes to implement.	0	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	-0.037952423095703125
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	Retrieves the current alternative setting for the specified interface, via a GET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_GetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        uint8_t *const AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetInterface,
      .wValue = 0,
      .wIndex = InterfaceIndex,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(AltSetting);
}"	claude-3-5-sonnet-20241022	This function retrieves the current alternate setting of a specified USB interface by sending a control request to the device and storing the result in the AltSetting parameter.	0	1	0.5045939757961404	0.05090608483649872	{'f': 0.4390243853896491, 'p': 0.5294117647058824, 'r': 0.375}	{'f': 0.1333333285333335, 'p': 0.16666666666666666, 'r': 0.1111111111111111}	{'f': 0.4390243853896491, 'p': 0.5294117647058824, 'r': 0.375}	95	0.6925735473632812
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = CPU_TO_LE16(0),
      .wIndex = CPU_TO_LE16(0),
      .wLength = CPU_TO_LE16(
          sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost)),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	This function sends control line state changes from a USB CDC device to the host by writing notification data through the configured notification endpoint.	0	1	0.11627906976744186	0.008311095129601858	{'f': 0.25352112248363423, 'p': 0.1836734693877551, 'r': 0.4090909090909091}	{'f': 0.04705881958200726, 'p': 0.03225806451612903, 'r': 0.08695652173913043}	{'f': 0.1690140802301132, 'p': 0.12244897959183673, 'r': 0.2727272727272727}	85	0.7988462448120117
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/verify.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      verify,
      'v',
      ""verify"",
      ""verify a certificate using the CA certificate"",
      {""[--in file] [--ca file]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""X.509 certificate to verify, default: stdin""},
          {""cacert"", 'c', 1, ""CA certificate, default: verify self signed""},
      }});
}"	claude-3-5-sonnet-20241022	This function registers a command to verify X.509 certificates, defining its options and parameters, using the command_register function at program startup due to the constructor attribute.	0	1	0.2830188679245283	0.008640609739997756	{'f': 0.15384615180473374, 'p': 0.6666666666666666, 'r': 0.08695652173913043}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07692307488165685, 'p': 0.3333333333333333, 'r': 0.043478260869565216}	None_output	0.45852160453796387
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float2() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_16}}};
  return item;
}"	claude-3-5-sonnet-20241022	The function allocates and initializes a new CBOR item structure for a 16-bit floating-point number with necessary metadata and memory management.	0	1	0.1212121212121212	0.02297185935845028	{'f': 0.24242423753902673, 'p': 0.2857142857142857, 'r': 0.21052631578947367}	{'f': 0.05882352456747445, 'p': 0.07142857142857142, 'r': 0.05}	{'f': 0.18181817693296617, 'p': 0.21428571428571427, 'r': 0.15789473684210525}	None_output	0.3718982934951782
phase4ground-joco-2018-badge-782fd35/firmware/manbearpig/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    mbp_tooth_eye_stop();
    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
  mbp_tooth_eye_start();
}"	claude-3-5-sonnet-20241022	"This function allows users to select and play LED animation files from a ""BLING"" directory, managing menu display, file loading, and LED animation timing through a timer-based callback system."	0	1	0.08241758241758242	0.006471824245088331	{'f': 0.05263157444598377, 'p': 0.07692307692307693, 'r': 0.04}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.05263157444598377, 'p': 0.07692307692307693, 'r': 0.04}	50	0.4163548946380615
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	The firmware version is the SHA256 hash.	1	"arm_uc_error_t ARM_UC_ControlCenter_ReportVersion(uint64_t version) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportVersion: %"" PRIu64, version);

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct) {
    arm_uc_monitor_struct->SendVersion(version);
    result.code = ERR_NONE;
  }

  return result;
}"	claude-3-5-sonnet-20241022	This function reports the firmware version to a monitor structure and returns a status code indicating success or failure of the operation.	0	1	0.4411764705882353	0.020331710659744474	{'f': 0.22222221838134434, 'p': 0.42857142857142855, 'r': 0.15}	{'f': 0.07407407061728412, 'p': 0.16666666666666666, 'r': 0.047619047619047616}	{'f': 0.22222221838134434, 'p': 0.42857142857142855, 'r': 0.15}	None_output	0.5742251873016357
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function retrieves the maximum Logical Unit Number (LUN) index from a USB mass storage device through a control request, returning 0 if the request is stalled.	0	1	0.36979644934190387	0.020876149875884896	{'f': 0.32558139041644135, 'p': 0.3684210526315789, 'r': 0.2916666666666667}	{'f': 0.043478255954631936, 'p': 0.05, 'r': 0.038461538461538464}	{'f': 0.13953487878853452, 'p': 0.15789473684210525, 'r': 0.125}	85	0.6336708068847656
boazsegev-iodine-b6bdf50/ext/iodine/http1.c	Creates an HTTP1 protocol object and handles any unread data in the buffer (if any).	2	"fio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,
                          void *unread_data, size_t unread_length) {
  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)
    return NULL;
  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);

  FIO_ASSERT_ALLOC(p);
  *p = (http1pr_s){
      .p.protocol =
          {
              .on_data = http1_on_data_first_time,
              .on_close = http1_on_close,
              .on_ready = http1_on_ready,
          },
      .p.uuid = uuid,
      .p.settings = settings,
      .max_header_size = settings->max_header_size,
      .is_client = settings->is_client,
  };
  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    memcpy(p->buf, unread_data, unread_length);
    p->buf_len = unread_length;
  }
  fio_attach(uuid, &p->p.protocol);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  return &p->p.protocol;
}"	claude-3-5-sonnet-20241022	This function initializes and creates a new HTTP/1.x protocol handler, setting up necessary structures and configurations while handling any unread data before attaching it to the connection.	0	1	0.32841435185185186	0.04108404733153058	{'f': 0.29999999545000006, 'p': 0.42857142857142855, 'r': 0.23076923076923078}	{'f': 0.09999999545000023, 'p': 0.14285714285714285, 'r': 0.07692307692307693}	{'f': 0.29999999545000006, 'p': 0.42857142857142855, 'r': 0.23076923076923078}	85	0.7136008739471436
Decawave-mynewt-dw1000-apps-be5c28a/apps/listener/src/bleprph.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"bleprph_advertise(void) {
  uint8_t own_addr_type;
  struct ble_gap_adv_params adv_params;
  struct ble_hs_adv_fields fields;
  const char *name;
  int rc;

  rc = ble_hs_id_infer_auto(0, &own_addr_type);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error determining address type; rc=%d\n"", rc);
    return;
  }

  memset(&fields, 0, sizeof fields);

  fields.flags = BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP;

  fields.tx_pwr_lvl_is_present = 1;
  fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

  name = ble_svc_gap_device_name();
  fields.name = (uint8_t *)name;
  fields.name_len = strlen(name);
  fields.name_is_complete = 1;

  fields.uuids16 = (ble_uuid16_t[]){BLE_UUID16_INIT(GATT_SVR_SVC_ALERT_UUID)};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  memset(&adv_params, 0, sizeof adv_params);
  adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
  adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
  rc = ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params,
                         bleprph_gap_event, NULL);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"	claude-3-5-sonnet-20241022	This function configures and starts BLE advertising by setting up advertising parameters, device name, service UUIDs, and other fields to make the device discoverable by other BLE devices.	0	1	0.12987012987012989	0.009498525867740094	{'f': 0.23529411307958487, 'p': 0.3333333333333333, 'r': 0.18181818181818182}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.17647058366782017, 'p': 0.25, 'r': 0.13636363636363635}	75	0.5418449640274048
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabKey request. Creates a grab for the client's keyboard and adds it to the list of passive grabs.	2	"ProcGrabKey(ClientPtr client) {
  WindowPtr pWin;

  REQUEST(xGrabKeyReq);
  GrabPtr grab;
  DeviceIntPtr keybd = PickKeyboard(client);
  int rc;
  GrabParameters param;
  GrabMask mask;

  REQUEST_SIZE_MATCH(xGrabKeyReq);

  param = (GrabParameters){.grabtype = CORE,
                           .ownerEvents = stuff->ownerEvents,
                           .this_device_mode = stuff->keyboardMode,
                           .other_devices_mode = stuff->pointerMode,
                           .modifiers = stuff->modifiers};

  rc = CheckGrabValues(client, &param);
  if (rc != Success)
    return rc;

  if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
       (stuff->key < keybd->key->xkbInfo->desc->min_key_code)) &&
      (stuff->key != AnyKey)) {
    client->errorValue = stuff->key;
    return BadValue;
  }
  rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
  if (rc != Success)
    return rc;

  mask.core = (KeyPressMask | KeyReleaseMask);

  grab = CreateGrab(client->index, keybd, keybd, pWin, CORE, &mask, &param,
                    KeyPress, stuff->key, NullWindow, NullCursor);
  if (!grab)
    return BadAlloc;
  return AddPassiveGrabToList(client, grab);
}"	claude-3-5-sonnet-20241022	The function `ProcGrabKey` handles key grab requests from clients by creating and registering a passive grab for a specific key combination on a window, with specified grab parameters and modes.	0	1	0.30121792083514576	0.017379110740253053	{'f': 0.27272726776859507, 'p': 0.3, 'r': 0.25}	{'f': 0.03999999512800059, 'p': 0.047619047619047616, 'r': 0.034482758620689655}	{'f': 0.18181817685950424, 'p': 0.2, 'r': 0.16666666666666666}	None_output	0.6448510885238647
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/AndroidAccessoryClassHost.c	Starts Accessory Mode in the attached Android device. This function will validate the device's Android Open Accessory protocol version, send the configured property strings, and request a switch to Android Open Accessory mode.	1	"uint8_t
AOA_Host_StartAccessoryMode(USB_ClassInfo_AOA_Host_t *const AOAInterfaceInfo) {
  uint8_t ErrorCode;

  uint16_t AccessoryProtocol;
  if ((ErrorCode = AOA_Host_GetAccessoryProtocol(&AccessoryProtocol)) !=
      HOST_WAITERROR_Successful)
    return ErrorCode;

  if (AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV1))
    return AOA_ERROR_LOGICAL_CMD_FAILED;

  for (uint8_t PropertyIndex = 0; PropertyIndex < AOA_STRING_TOTAL_STRINGS;
       PropertyIndex++) {
    if ((ErrorCode = AOA_Host_SendPropertyString(
             AOAInterfaceInfo, PropertyIndex)) != HOST_WAITERROR_Successful)
      return ErrorCode;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE),
      .bRequest = AOA_REQ_StartAccessoryMode,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function initializes Android Open Accessory (AOA) mode by checking protocol compatibility, sending property strings, and issuing a control request to start accessory mode on a connected USB device.	0	1	0.4481462546390971	0.06132760947791633	{'f': 0.5283018817942329, 'p': 0.5384615384615384, 'r': 0.5185185185185185}	{'f': 0.17241378810939373, 'p': 0.16666666666666666, 'r': 0.17857142857142858}	{'f': 0.4528301836810253, 'p': 0.46153846153846156, 'r': 0.4444444444444444}	95	0.8341637849807739
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	_mm_set1_epi64(__m64 __q) { return (__m128i){(long long)__q, (long long)__q}; }	claude-3-5-sonnet-20241022	This intrinsic function creates a 128-bit vector by duplicating a 64-bit value into both the lower and upper halves of the vector.	0	1	0.28810060060060055	0.024178614976744797	{'f': 0.3124999951757813, 'p': 0.38461538461538464, 'r': 0.2631578947368421}	{'f': 0.058823524688581694, 'p': 0.07692307692307693, 'r': 0.047619047619047616}	{'f': 0.2499999951757813, 'p': 0.3076923076923077, 'r': 0.21052631578947367}	10	0.4185677170753479
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/fifo.c	Move data pointers and pts offset samples forward.	2	"static void buffer_offset(AVFilterLink *link, AVFrame *frame, int offset) {
  int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
  int planar = av_sample_fmt_is_planar(link->format);
  int planes = planar ? nb_channels : 1;
  int block_align =
      av_get_bytes_per_sample(link->format) * (planar ? 1 : nb_channels);
  int i;

  av_assert0(frame->nb_samples > offset);

  for (i = 0; i < planes; i++)
    frame->extended_data[i] += block_align * offset;
  if (frame->data != frame->extended_data)
    memcpy(frame->data, frame->extended_data,
           FFMIN(planes, FF_ARRAY_ELEMS(frame->data)) * sizeof(*frame->data));
  frame->linesize[0] -= block_align * offset;
  frame->nb_samples -= offset;

  if (frame->pts != AV_NOPTS_VALUE) {
    frame->pts += av_rescale_q(offset, (AVRational){1, link->sample_rate},
                               link->time_base);
  }
}"	claude-3-5-sonnet-20241022	The function adjusts audio frame data by applying an offset, updating sample counts, buffer positions, and timestamps while handling both planar and non-planar audio formats.	0	1	0.20618556701030927	0.009970222994544455	{'f': 0.1935483832674298, 'p': 0.375, 'r': 0.13043478260869565}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1290322542351718, 'p': 0.25, 'r': 0.08695652173913043}	65	0.3554680347442627
vasyutin-qnetmap-3e0b0a1/lib/src/qnetmap_label.h	draw the geometry	2	"virtual ~TLabel(){};

virtual void drawGeometry(QPainter *Painter_, const QRect &Viewport_,
                          const QPoint Offset_ = QPoint());

virtual const QString &text(void) const { return m_Text; }

virtual void setText(QString &Text_) {
  m_Text = Text_;
  calculateBoundingBox();
}"	claude-3-5-sonnet-20241022	These functions define a virtual destructor and essential methods for a text label class, allowing text manipulation, geometry drawing, and automatic bounding box calculation for derived classes.	0	1	0.1851851851851852	0.006980361417366381	{'f': 0.07692307488165685, 'p': 0.3333333333333333, 'r': 0.043478260869565216}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07692307488165685, 'p': 0.3333333333333333, 'r': 0.043478260869565216}	30	0.28614741563796997
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/integration/test_integration.c	Adapt the initial mesh if a adaptation parameters are provided in the input file.	2	"void adapt_initial_mesh_if_required(struct Simulation *const sim) {
  const int *count_to_find = (int[]){2, 3};
  int count_found = 0;

  struct Adaptation_Data adapt_data = {
      .adapt_h =
          {
              0,
              0,
          },
      .xyz_ve_refine = NULL,
      .xyz_ve_ml = NULL,
      .xyz_ve_p = NULL,
  };

  char line[STRLEN_MAX];
  FILE *input_file = fopen_input('t', NULL, NULL);
  while (fgets(line, sizeof(line), input_file)) {
    read_skip_name_i(""n_adapt_h_refine"", line, &adapt_data.adapt_h[0]);
    if (strstr(line, ""xyz_ve_refine"")) {
      ++count_found;
      adapt_data.xyz_ve_refine =
          constructor_file_const_Multiarray_d(input_file, true);
    }
    if (strstr(line, ""xyz_ve_mesh_level"")) {
      ++count_found;
      adapt_data.xyz_ve_ml = constructor_file_const_Vector_i(input_file, true);
    }
    if (strstr(line, ""xyz_ve_polynomial_order"")) {
      ++count_found;
      adapt_data.xyz_ve_p = constructor_file_const_Vector_i(input_file, true);
    }
  }
  fclose(input_file);

  if (adapt_data.xyz_ve_refine == NULL) {
    assert(adapt_data.xyz_ve_ml == NULL || adapt_data.xyz_ve_p == NULL);
    return;
  }

  if (count_found < count_to_find[0] || count_found > count_to_find[1])
    EXIT_ERROR(
        ""Did not find the required number of variables (Found: %d/[%d,%d]).\n"",
        count_found, count_to_find[0], count_to_find[1]);

  adapt_hp(sim, ADAPT_S_XYZ_VE, &adapt_data);
  for (int i = 0; i < adapt_data.adapt_h[0]; ++i)
    adapt_hp(sim, ADAPT_S_H_REFINE, NULL);
  for (int i = 0; i < adapt_data.adapt_h[1]; ++i)
    adapt_hp(sim, ADAPT_S_H_COARSE, NULL);

  destructor_const_Multiarray_d(adapt_data.xyz_ve_refine);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_ml);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_p);
}"	claude-3-5-sonnet-20241022	This function reads mesh adaptation parameters from an input file and applies them to modify the mesh properties (refinement, coarsening, and polynomial orders) in a simulation.	0	1	0.41529605263157904	0.02584145048742771	{'f': 0.43243242787436087, 'p': 0.6153846153846154, 'r': 0.3333333333333333}	{'f': 0.105263153393352, 'p': 0.15384615384615385, 'r': 0.08}	{'f': 0.27027026571219875, 'p': 0.38461538461538464, 'r': 0.20833333333333334}	None_output	0.5840120911598206
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/AudioInputHost/AudioInputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Could not set requested Audio sample rate.\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  DDRC |= (1 << 6);

  TCCR3A = ((1 << WGM30) | (1 << COM3A1) | (1 << COM3A0));
  TCCR3B = ((1 << WGM32) | (1 << CS30));

  puts_P(PSTR(""Microphone Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"	claude-3-5-sonnet-20241022	This function handles the USB device enumeration process for a microphone, configuring audio settings (like sample rate) and setting up timers after successful device connection.	0	1	0.1624548736462094	0.01051591417454286	{'f': 0.24489795418575602, 'p': 0.24, 'r': 0.25}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1224489745939194, 'p': 0.12, 'r': 0.125}	75	0.539341390132904
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Read the settings INI file via TinyFrame	2	"uint32_t GEX_IniRead(GexClient *gex, char *buffer, uint32_t maxlen) {
  GexBulk br = (GexBulk){
      .buffer = (uint8_t *)buffer, .capacity = maxlen, .req_cmd = MSG_INI_READ};

  uint32_t actuallyRead = GEX_BulkRead(GEX_SysUnit(gex), &br);

  if (actuallyRead == maxlen) {
    actuallyRead--;
  }

  buffer[actuallyRead] = 0;
  return actuallyRead;
}"	claude-3-5-sonnet-20241022	This function reads initialization data into a provided buffer from a GEX system, ensuring null-termination, and returns the number of bytes read.	0	1	0.11764705882352941	0.008687475782716616	{'f': 0.07142856767857161, 'p': 0.14285714285714285, 'r': 0.047619047619047616}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07142856767857161, 'p': 0.14285714285714285, 'r': 0.047619047619047616}	None_output	0.21936509013175964
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	Wraps a packet like commonSetup, but will do the whole packet including headers not just the message body. This is used by the PacketEncoder tests.	2	"testrigencoder_CommonSetupWholePacket(uint8_t *packet, size_t length,
                                      TruthTableEntry *truthTable) {
  TestData *data = parcMemory_AllocateAndClear(sizeof(TestData));
  assertNotNull(data, ""parcMemory_AllocateAndClear(%zu) returned NULL"",
                sizeof(TestData));

  data->memoryRegion = parcBuffer_Wrap(packet, length, 0, length);
  data->encoder = ccnxCodecTlvEncoder_Create();

  data->dictionary = ccnxTlvDictionary_Create(
      CCNxCodecSchemaV1TlvDictionary_MessageFastArray_END,
      CCNxCodecSchemaV1TlvDictionary_Lists_END);

  data->packet = packet;
  data->packetLength = length;
  data->truthTable = truthTable;

  buildPacketDictionary(data, data->dictionary, (TlvExtent){0, length});

  return data;
}"	claude-3-5-sonnet-20241022	This function initializes test data structures for encoding packets by allocating memory, creating necessary objects, and setting up a dictionary with the provided packet data and truth table.	0	1	0.17786561264822134	0.010043468297595231	{'f': 0.20833332836805565, 'p': 0.22727272727272727, 'r': 0.19230769230769232}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1249999950347224, 'p': 0.13636363636363635, 'r': 0.11538461538461539}	45	0.5158921480178833
ryankurte-micro-gui-1e3ce05/source/graphics.c	This performs bounds checking and translation based on the graphics context	2	"static void plot(ugui_graphics_t *graphics, uint32_t x, uint32_t y) {

  uint32_t new_x = x + graphics->offset_x;
  uint32_t new_y = y + graphics->offset_y;

  if ((new_x < graphics->w) && (x < graphics->limit_w) &&
      (new_y < graphics->h) && (y < graphics->limit_h)) {
    _ugui_buffer_set(graphics->buffer, &(ugui_point_t){.x = new_x, .y = new_y},
                     1);
  }
}"	claude-3-5-sonnet-20241022	This function plots a single pixel at coordinates (x, y) on a graphics buffer, applying offsets and checking boundaries before setting the pixel value.	0	1	0.24390243902439024	0.012384901282810543	{'f': 0.36363635919191917, 'p': 0.5454545454545454, 'r': 0.2727272727272727}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.18181817737373748, 'p': 0.2727272727272727, 'r': 0.13636363636363635}	None_output	0.511798083782196
darktable-org-darktable-32fab21/src/iop/borders.c	callback methods for gui. synch gtk interface with gui params, if necessary. gui callbacks, these are needed.	2	"void gui_update(struct dt_iop_module_t *self) {
  dt_iop_borders_gui_data_t *g = (dt_iop_borders_gui_data_t *)self->gui_data;
  dt_iop_borders_params_t *p = (dt_iop_borders_params_t *)self->params;
  dt_bauhaus_slider_set(g->size, p->size * 100.0f);

  int k = 0;
  for (; k < DT_IOP_BORDERS_ASPECT_COUNT; k++) {
    if (fabsf(p->aspect - g->aspect_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->aspect, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_ASPECT_COUNT) {
    dt_bauhaus_combobox_set_text(g->aspect, p->aspect_text);
    dt_bauhaus_combobox_set(g->aspect, -1);
  }

  dt_bauhaus_combobox_set(g->aspect_orient, p->aspect_orient);

  for (k = 0; k < DT_IOP_BORDERS_POSITION_H_COUNT; k++) {
    if (fabsf(p->pos_h - g->pos_h_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_h, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_H_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_h, p->pos_h_text);
    dt_bauhaus_combobox_set(g->pos_h, -1);
  }

  for (k = 0; k < DT_IOP_BORDERS_POSITION_V_COUNT; k++) {
    if (fabsf(p->pos_v - g->pos_v_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_v, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_V_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_v, p->pos_v_text);
    dt_bauhaus_combobox_set(g->pos_v, -1);
  }

  dt_bauhaus_slider_set(g->frame_size, p->frame_size * 100.0f);
  dt_bauhaus_slider_set(g->frame_offset, p->frame_offset * 100.0f);

  GdkRGBA c = (GdkRGBA){.red = p->color[0],
                        .green = p->color[1],
                        .blue = p->color[2],
                        .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->colorpick), &c);

  GdkRGBA fc = (GdkRGBA){.red = p->frame_color[0],
                         .green = p->frame_color[1],
                         .blue = p->frame_color[2],
                         .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->frame_colorpick), &fc);
}"	claude-3-5-sonnet-20241022	This function updates the GUI elements (sliders, comboboxes, color pickers) of the borders module in darktable based on the current parameter values stored in the module's data structure.	0	1	0.027624309392265196	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.32290118932724
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavutil/rational.c	Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign.	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (fabs(d) > INT_MAX + 3LL)
    return (AVRational){d < 0 ? -1 : 1, 0};
  frexp(d, &exponent);
  exponent = FFMAX(exponent - 1, 0);
  den = 1LL << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"	claude-3-5-sonnet-20241022	This function converts a floating-point number (double) to a rational number (fraction) with controlled precision, representing it as a numerator and denominator pair within specified maximum values.	0	1	0.20833333333333331	0.044147681940077975	{'f': 0.32558139041644135, 'p': 0.3684210526315789, 'r': 0.2916666666666667}	{'f': 0.08695651682419688, 'p': 0.1, 'r': 0.07692307692307693}	{'f': 0.23255813460248795, 'p': 0.2631578947368421, 'r': 0.20833333333333334}	None_output	0.6944957971572876
ThierryNg-pokecopy-57caaae/Pokecopy.spritebuilder/Source/libs/cocos2d-iphone/cocos2d/ccTypes.h	helper that creates a ccColor4f type	2	"static inline ccColor4F ccc4f(const GLfloat r, const GLfloat g, const GLfloat b,
                              const GLfloat a) {
  return (ccColor4F){r, g, b, a};
}"	claude-3-5-sonnet-20241022	This function creates and returns a ccColor4F structure with four float values representing red, green, blue, and alpha color components.	0	1	0.34534534534534533	0.011451997463067555	{'f': 0.15999999635200007, 'p': 0.3333333333333333, 'r': 0.10526315789473684}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15999999635200007, 'p': 0.3333333333333333, 'r': 0.10526315789473684}	85	0.5677048563957214
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/LowLevel/Host.c	Clears a stall condition on the given pipe, via a ClearFeature request to the attached device.	2	"uint8_t USB_Host_ClearPipeStall(uint8_t EndpointNum) {
  if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    EndpointNum |= ENDPOINT_DESCRIPTOR_DIR_IN;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function clears a stalled USB pipe by sending a control request to the device, resetting the endpoint's halt condition and allowing data transfer to resume.	0	1	0.4698590179873603	0.047326568651956204	{'f': 0.3783783736742148, 'p': 0.5, 'r': 0.30434782608695654}	{'f': 0.09999999531250023, 'p': 0.13333333333333333, 'r': 0.08}	{'f': 0.32432431962016073, 'p': 0.42857142857142855, 'r': 0.2608695652173913}	None_output	0.6835981607437134
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI INQUIRY command to a USB mass storage device to retrieve device information and stores the response data in the provided InquiryData structure.	0	1	0.4133333333333333	0.010438074937942448	{'f': 0.21052631101108046, 'p': 0.26666666666666666, 'r': 0.17391304347826086}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.10526315311634371, 'p': 0.13333333333333333, 'r': 0.08695652173913043}	85	0.6887564063072205
varunjampani-video_prop_networks-4f4a398/lib/caffe/include/caffe/malabar_layers.hpp	Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true.	2	"template <typename Dtype> class MatMulLayer : public Layer<Dtype> {
public:
  explicit MatMulLayer(const LayerParameter &param) : Layer<Dtype>(param) {
    LayerParameter tmp_param;
    tmp_param.mutable_concat_param()->set_concat_dim(3);
    concat_layer_.reset(new ConcatLayer<Dtype>(tmp_param));
  }
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul""; }
  virtual inline int MinNumBottomBlobs() const { return 2; }
  virtual inline int ExactNumTopBlobs() const { return 1; }

protected:
  virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Forward_gpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  virtual void Backward_gpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  Blob<Dtype> tmp_k_;
  boost::shared_ptr<ConcatLayer<Dtype>> concat_layer_;
};

template <typename Dtype> class MatMul2Layer : public Layer<Dtype> {
public:
  explicit MatMul2Layer(const LayerParameter &param) : Layer<Dtype>(param){};
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul2""; }"	claude-3-5-sonnet-20241022	Both MatMulLayer and MatMul2Layer classes are designed to perform matrix multiplication operations on input blobs, with MatMulLayer having additional concatenation functionality through ConcatLayer.	0	1	0.07731958762886597	0.009849349468888718	{'f': 0.1052631530193908, 'p': 0.125, 'r': 0.09090909090909091}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1052631530193908, 'p': 0.125, 'r': 0.09090909090909091}	None_output	0.32485634088516235
moehriegitt-hob3l-40cfda8/src/csg3.c	From an array of points in the rough shape of a tower, make a polyhedron. 'Tower' means the shape consists of layers of polygon points stack on each other. This function also handles the case of the top collapsing into a single point. So this shape works for (polyhedronized) cylinders, cones, spheres, cubes, and linear_extrudes. If the connecting quads are not planar, then tri_side can be set to non-false to split them into triangles. This shape is probably not nice, but correct in that the faces are planar, since every triangle is trivially planar). The top and bottom faces must be planar. rev^(m->d < 0) inverts face vertex order to allow managing mirroring and negative determinants. This also gives some freedom for the construction: if top and bottom are swapped (i.e., the points 0..fn-1 are the top, not the bottom), then rev be passed as non-false. This also runs xform and minmax, but not make_edges.	2	"static bool faces_n_edges_from_tower(cp_csg3_poly_t *o, ctxt_t *c,
                                     cp_mat3wi_t const *m, cp_loc_t loc,
                                     size_t fn, size_t fnz, bool rev,
                                     unsigned tri_side, bool may_need_tri) {

  unsigned orient = 0;
  bool need_tri = false;
  if (may_need_tri) {
    for (cp_size_each(i, fn)) {
      size_t j = cp_wrap_add1(i, fn);
      size_t k = cp_wrap_add1(j, fn);
      orient |=
          1U << (1 + cp_vec2_right_normal3_z(&cp_v_nth(&o->point, i).coord.b,
                                             &cp_v_nth(&o->point, j).coord.b,
                                             &cp_v_nth(&o->point, k).coord.b));
      if ((orient & 5) == 5) {
        need_tri = true;
        break;
      }
    }
  }

  cp_v_size3_t tri = {0};
  if (need_tri) {
    cp_vec2_arr_ref_t a2;
    cp_vec2_arr_ref_from_a_vec3_loc_xy(&a2, &o->point);
    if (!cp_csg2_tri_vec2_arr_ref(&tri, c->tmp, c->err, loc, &a2, fn)) {
      return false;
    }
  }

  if (m->d < 0) {
    rev = !rev;
  }

  for (cp_v_each(i, &o->point)) {
    cp_vec3w_xform(&cp_v_nth(&o->point, i).coord, &m->n,
                   &cp_v_nth(&o->point, i).coord);
  }

  bool has_top = (o->point.size == fn * fnz);
  assert(has_top || (o->point.size == 1 + (fn * (fnz - 1))));

  size_t k = 0;
  size_t bt_cnt = tri.size ? tri.size : 1U;
  cp_v_init0(&o->face, (bt_cnt * (1U + !!has_top)) +
                           ((fnz - 2) * fn * (1U + !!tri_side)) +
                           (fn * (1U + !!(tri_side && has_top))));

  face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, false);

  if (has_top) {
    face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, true);
  }

  cp_v_fini(&tri);

  cp_csg3_face_t *f;
  for (cp_size_each(i, fnz, 1, !has_top)) {
    size_t k1 = i * fn;
    size_t k0 = k1 - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      switch (tri_side) {
      case TRI_LEFT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j0},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j1},
                                 3, !rev, loc);
        break;
      case TRI_RIGHT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j0},
                                 3, !rev, loc);
        break;
      case TRI_NONE:
        face_init_from_point_ref(
            f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1, k1 + j0}, 4, !rev,
            loc);
        break;
      default:
        assert(0);
      }
    }
  }

  if (!has_top) {

    size_t kw = o->point.size - 1;
    size_t kv = kw - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      face_init_from_point_ref(f, o, (size_t[4]){kv + j0, kv + j1, kw}, 3, !rev,
                               loc);
    }
  }

  assert(o->face.size == k);
  return poly_make_edges(o, c);
}"	claude-3-5-sonnet-20241022	This function generates faces and edges for a 3D tower-like polygon by processing vertex points, handling triangulation if needed, and creating faces with proper orientations based on input parameters.	0	1	0.06007067137809187	0.00029346315278103803	{'f': 0.1746031712358277, 'p': 0.1111111111111111, 'r': 0.4074074074074074}	{'f': 0.011299432364902157, 'p': 0.006711409395973154, 'r': 0.03571428571428571}	{'f': 0.09523809187074841, 'p': 0.06060606060606061, 'r': 0.2222222222222222}	85	0.6921002864837646
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	Parse a packet, add all split parts to parse_queue.	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->buf && out_pkt.data == pkt->data) {

      out_pkt.buf = av_buffer_ref(pkt->buf);
      if (!out_pkt.buf) {
        ret = AVERROR(ENOMEM);
        goto fail;
      }
    } else {
      ret = av_packet_make_refcounted(&out_pkt);
      if (ret < 0)
        goto fail;
    }

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;
    out_pkt.flags |= pkt->flags & AV_PKT_FLAG_DISCARD;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = ff_packet_list_put(&s->internal->parse_queue,
                             &s->internal->parse_queue_end, &out_pkt, 0);
    if (ret < 0) {
      av_packet_unref(&out_pkt);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"	claude-3-5-sonnet-20241022	This function parses input packets using a stream parser, processes their fields (timestamps, duration, flags), and adds the parsed packets to a queue for further processing in the FFmpeg media framework.	0	1	0.26785714285714285	0.007173775053353474	{'f': 0.10810810442658889, 'p': 0.2222222222222222, 'r': 0.07142857142857142}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.10810810442658889, 'p': 0.2222222222222222, 'r': 0.07142857142857142}	None_output	0.4551727771759033
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices.	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"	claude-3-5-sonnet-20241022	This function switches a HID device to boot protocol mode by sending a control request and updates the interface state accordingly.	0	1	0.3057650862068965	0.024289783953423513	{'f': 0.2941176422145329, 'p': 0.35714285714285715, 'r': 0.25}	{'f': 0.05555555061728439, 'p': 0.0625, 'r': 0.05}	{'f': 0.23529411280276827, 'p': 0.2857142857142857, 'r': 0.2}	None_output	0.7054739594459534
opticron-libuweave-2e5e385/src/macaroon_helpers.c	Mint an initial server authentication token (SAT).	2	"bool uw_macaroon_mint_server_authentication_token_(
    const uint8_t *root_key, size_t root_key_len, const uint8_t *token_str,
    size_t token_str_len,
    const uint8_t nonce[UW_MACAROON_INIT_DELEGATION_NONCE_SIZE],
    uint8_t *buffer, size_t buffer_size, UwMacaroon *new_macaroon) {
  if (root_key == NULL || root_key_len == 0 || nonce == NULL ||
      buffer == NULL || buffer_size == 0 || new_macaroon == NULL) {
    return false;
  }
  if (token_str == NULL && token_str_len != 0) {
    return false;
  }

  *new_macaroon = (UwMacaroon){};

  const size_t num_caveats = 2;
  UwMacaroonCaveat **caveat_list =
      allocate_caveat_list_(num_caveats, &buffer, &buffer_size);
  if (caveat_list == NULL) {
    return false;
  }

  size_t needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeServerAuthenticationTokenV1, token_str_len);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_server_authentication_token_(
          token_str, token_str_len, buffer, needed_buffer_size,
          caveat_list[0])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeNonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_nonce_(
          nonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE, buffer,
          needed_buffer_size, caveat_list[1])) {
    return false;
  }

  UwMacaroonContext context = {};
  return uw_macaroon_create_from_root_key_(
      new_macaroon, root_key, root_key_len, &context,
      (const UwMacaroonCaveat *const *)caveat_list, num_caveats);
}"	claude-3-5-sonnet-20241022	This function creates a secure authentication token (macaroon) with two caveats: a server authentication token and a nonce, using a root key and other parameters for validation and security purposes.	0	1	0.3166069295101554	0.030904914794178312	{'f': 0.19999999642222227, 'p': 0.42857142857142855, 'r': 0.13043478260869565}	{'f': 0.11764705591695508, 'p': 0.3333333333333333, 'r': 0.07142857142857142}	{'f': 0.19999999642222227, 'p': 0.42857142857142855, 'r': 0.13043478260869565}	None_output	0.4280126392841339
vsfteam-vsf-c4a58f3/release/kernel/beta/example/usrapp/template/main_fsm_simple.c	You cannot ignore fsm_initialiser at any time	4	"fsm_initialiser(user_task_b_t, args(vsf_sem_t *ptSEM))
    init_body(this.psem = ptSEM;)

        implement_fsm(user_task_b_t) def_states(PRINT, DELAY);

    body(
        on_start(
            update_state_to(PRINT);
        )
        
        state(PRINT){
  printf(""hello world! \r\n"");
  update_state_to(DELAY);                                              
        }"	claude-3-5-sonnet-20241022	"This function initializes a finite state machine with two states (PRINT and DELAY) and sets up a task to print ""hello world!"" before transitioning to the DELAY state."	0	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.21777698397636414
kernkonzept-l4re-core-0dd677e/l4sys/include/types.h	Create a message tag from the specified values.	2	"l4_msgtag_t l4_msgtag(long label, unsigned words, unsigned items,
                      unsigned flags) L4_NOTHROW {
  return (l4_msgtag_t){
      (l4_mword_t)((l4_umword_t)label << 16) | (l4_mword_t)(words & 0x3f) |
      (l4_mword_t)((items & 0x3f) << 6) | (l4_mword_t)(flags & 0xf000)};
}"	claude-3-5-sonnet-20241022	This function creates an L4 message tag by combining a label, word count, item count, and flags into a single packed value used for Inter-Process Communication (IPC) in L4 microkernels.	0	1	0.3647058823529412	0.014614031921776127	{'f': 0.1714285679020409, 'p': 0.375, 'r': 0.1111111111111111}	{'f': 0.05555555242283968, 'p': 0.14285714285714285, 'r': 0.034482758620689655}	{'f': 0.11428571075918378, 'p': 0.25, 'r': 0.07407407407407407}	None_output	0.45556867122650146
cascadeo-monit-8857544/src/status.c	Show all services in the service list.	2	"boolean_t status(const char *level, const char *group, const char *service) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    Socket_print(S, ""GET /_status?format=text&level=%s"", level);
    if (group) {
      char *_group = Util_urlEncode((char *)group);
      Socket_print(S, ""&group=%s"", _group);
      FREE(_group);
    }
    if (service) {
      char *_service = Util_urlEncode((char *)service);
      Socket_print(S, ""&service=%s"", _service);
      FREE(_service);
    }
    char *_auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, "" HTTP/1.0\r\n%s\r\n"", _auth ? _auth : """");
    FREE(_auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"	claude-3-5-sonnet-20241022	The function checks the status of monitored services by connecting to a Monit daemon through HTTP(S) or Unix socket, requesting status information based on specified parameters, and displaying the results.	0	1	0.16129032258064518	0.007425868202031369	{'f': 0.11428571108571438, 'p': 0.2857142857142857, 'r': 0.07142857142857142}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.11428571108571438, 'p': 0.2857142857142857, 'r': 0.07142857142857142}	None_output	0.28597044944763184
boazsegev-iodine-b6bdf50/ext/iodine/fio_tls_missing.c	Schedules the ALPN protocol callback.	2	"FIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,
                                 void *udata_connection) {
  if (!alpn || !alpn->on_selected)
    return;
  alpn_task_s *t = fio_malloc(sizeof(*t));
  *t = (alpn_task_s){
      .alpn = *alpn,
      .uuid = uuid,
      .udata_connection = udata_connection,
  };

  fio_defer(alpn_select___task, t, NULL);
}"	claude-3-5-sonnet-20241022	This function creates and schedules a deferred task for ALPN (Application-Layer Protocol Negotiation) selection by allocating memory for task data and setting up the necessary parameters.	0	1	0.28169014084507044	0.008640609739997756	{'f': 0.14285713992346943, 'p': 0.4, 'r': 0.08695652173913043}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07142856849489808, 'p': 0.2, 'r': 0.043478260869565216}	None_output	0.7010536193847656
rockchip-linux-coreboot-adde3ea/src/cpu/intel/speedstep/speedstep.c	This is generic code and should work at least for Merom and Penryn processors. It is used to generate acpi tables and configure EMTTM.	4	"void speedstep_gen_pstates(sst_table_t *const table) {
  sst_params_t params;

  speedstep_get_limits(&params);

  const int power_diff2 = (params.max.power - params.min.power) * 2;
  const int vid_diff2 = (params.max.vid - params.min.vid) * 2;
  const int max_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.max);
  const int min_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.min);
  const int ratio_diff2 = max_ratio2 - min_ratio2;

  int states, step2 = 0;
  do {
    step2 += 2 * 2;
    states = ratio_diff2 / step2 + 1;
  } while (states > SPEEDSTEP_MAX_NORMAL_STATES);
  if (step2 > 4)
    printk(BIOS_INFO,
           ""Enhanced Speedstep processor with ""
           ""more than %d possible p-states.\n"",
           SPEEDSTEP_MAX_NORMAL_STATES);
  if (states < 2)
    states = 2;

  table->num_states = 0;

  if (params.turbo.is_turbo)
    table->states[table->num_states++] = params.turbo;

  table->states[table->num_states] = params.max;

  if ((params.max.dynfsb == params.min.dynfsb) &&
      (params.max.nonint == params.min.nonint) &&
      (params.max.ratio == params.min.ratio))
    table->states[table->num_states].vid = params.min.vid;
  ++table->num_states;
  --states;

  const int power_step = (power_diff2 / states) / 2;
  const int vid_step = (vid_diff2 / states) / 2;
  const int ratio_step = step2 / 2;
  int power = params.min.power + (states - 1) * power_step;
  int vid = params.min.vid + (states - 1) * vid_step;
  int ratio = params.min.ratio + (states - 1) * ratio_step;
  for (; states > 0; --states) {
    table->states[table->num_states++] =
        (sst_state_t){0, 0, ratio, vid, 0, 0, power};
    power -= power_step;
    vid -= vid_step;
    ratio -= ratio_step;
  }

  if (params.slfm.is_slfm)
    table->states[table->num_states++] = params.slfm;
}"	claude-3-5-sonnet-20241022	This function generates a table of P-states (power states) for SpeedStep-enabled processors by calculating intermediate states between minimum and maximum power levels, including turbo and SLFM modes if available.	0	1	0.163265306122449	0.00967763449717078	{'f': 0.17021276101403365, 'p': 0.19047619047619047, 'r': 0.15384615384615385}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.127659569524672, 'p': 0.14285714285714285, 'r': 0.11538461538461539}	None_output	0.41098886728286743
BRAINSia-BRAINSTools-11a70b1/ARCHIVE/BRAINSSurfaceTools/BRAINSSurfaceCommon/itkMeshToMeshRegistrationMethod.h	Method invoked by the pipeline in order to trigger the computation of the registration.	2	"using Superclass::MakeOutput;

virtual DataObjectPointer MakeOutput(size_t idx) override;

unsigned long GetMTime() const override;

protected:
MeshToMeshRegistrationMethod();
virtual ~MeshToMeshRegistrationMethod(){};
void PrintSelf(std::ostream &os, Indent indent) const override;

void GenerateData() override;

private:
MetricPointer m_Metric;
OptimizerType::Pointer m_Optimizer;

MovingMeshConstPointer m_MovingMesh;
FixedMeshConstPointer m_FixedMesh;

TransformPointer m_Transform;
InterpolatorPointer m_Interpolator;

ParametersType m_InitialTransformParameters;
ParametersType m_LastTransformParameters;
}
;
}"	claude-3-5-sonnet-20241022	This code defines a class for mesh-to-mesh registration, implementing methods and storing components needed for aligning two meshes using optimization, transformation, and interpolation techniques.	1	1	0.06666666666666667	0.007913247271422612	{'f': 0.05882352484429102, 'p': 0.08333333333333333, 'r': 0.045454545454545456}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.05882352484429102, 'p': 0.08333333333333333, 'r': 0.045454545454545456}	None_output	0.41880661249160767
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal simplex basis functions.	2	"static void
test_unit_basis_simplex_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_SI_Ortho *b_data_a = constructor_Basis_Data_SI_Ortho('a'),
                             *b_data_c = constructor_Basis_Data_SI_Ortho('c');

  tol = (double[]){
      10 * EPS,
      20 * EPS,
      10 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]),
      diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[1]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      20 * EPS,
      30 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]),
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      9 * EPS,
      8e4 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_25, b_data_c->grad_coef_25,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_37, b_data_c->grad_coef_37,
                              tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_25,
                                    b_data_c->grad_coef_25, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_37,
                                    b_data_c->grad_coef_37, tol[1]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_SI_Ortho(b_data_a);
  destructor_Basis_Data_SI_Ortho(b_data_c);

  assert_condition(pass);
}"	claude-3-5-sonnet-20241022	This function tests the equivalence of basis function data between two different simplex orthonormal basis implementations by comparing various matrices and arrays within specified tolerances.	1	1	0.2830188679245283	0.011328360454400999	{'f': 0.31249999595703126, 'p': 0.5555555555555556, 'r': 0.21739130434782608}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.2499999959570313, 'p': 0.4444444444444444, 'r': 0.17391304347826086}	None_output	0.7595680952072144
MightyPork-avr-projects-1c993f8/projects/color-memory-game/main.c	Randomly place pairs of cards on the board	2	"void deal_cards() {

  for (uint8_t i = 0; i < CARD_COUNT; ++i) {
    board[i] = (tile_t){.color = 0, .state = GONE};
  }

  const uint8_t dealt_cards =
      get_pin(FLAG_SMALL) ? CARD_COUNT : CARD_COUNT_SMALL;

  for (uint8_t i = 0; i < (dealt_cards / 2); ++i) {

    for (uint8_t j = 0; j < 2; j++) {

      while (1) {
        const uint8_t pos = rand() % dealt_cards;

        if (board[pos].state == GONE) {
          board[pos] = (tile_t){.color = i, .state = SECRET};
          break;
        }
      }
    }
  }
}"	claude-3-5-sonnet-20241022	This function randomly distributes pairs of cards on a game board, where each pair shares the same color, and the number of cards dealt depends on a flag setting.	1	1	0.5267636138613861	0.08914609827874222	{'f': 0.3749999962500001, 'p': 0.75, 'r': 0.25}	{'f': 0.1818181784756658, 'p': 0.42857142857142855, 'r': 0.11538461538461539}	{'f': 0.31249999625, 'p': 0.625, 'r': 0.20833333333333334}	95	0.7171522378921509
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Inquiry_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI INQUIRY command to a USB mass storage device to retrieve detailed information about a specific Logical Unit Number (LUN) and stores the response in the provided InquiryData structure.	1	1	0.31395194477631755	0.008447063994683927	{'f': 0.18181817732438027, 'p': 0.26666666666666666, 'r': 0.13793103448275862}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.04545454096074425, 'p': 0.06666666666666667, 'r': 0.034482758620689655}	None_output	0.7175087928771973
multitheftauto-mtasa-blue-1f5e9f8/vendor/ehs/ehs.h	adds new data to psBuffer	2	"NetworkAbstraction *GetNetworkAbstraction();

int TrySend(const char *ipMessage, size_t inLength, int inFlags = 0);
}
;

class EHSServer;

class EHS {

protected:
  EHSMap oEHSMap;

  EHS *poParent;

  std::string sRegisteredAs;

  EHSServer *poEHSServer;

  EHS *m_poSourceEHS;

public:
  EHS(EHS *ipoParent = NULL, std::string isRegisteredAs = """");

  virtual ~EHS();

  void SetCertificateFile(std::string &irsCertificateFile);

  void SetCertificatePassphrase(std::string &irsCertificatePassphrase);

  void SetPassphraseCallback(int (*m_ipfOverridePassphraseCallback)(char *, int,
                                                                    int,
                                                                    void *));

  void SetParent(EHS *ipoParent, std::string isRegisteredAs);

  enum RegisterEHSResult {
    REGISTEREHSINTERFACE_INVALID = 0,
    REGISTEREHSINTERFACE_ALREADYEXISTS,
    REGISTEREHSINTERFACE_SUCCESS
  };

  RegisterEHSResult RegisterEHS(EHS *ipoEHS, const char *ipsRegisterPath);

  enum UnregisterEHSResult {
    UNREGISTEREHSINTERFACE_INVALID = 0,
    UNREGISTEREHSINTERFACE_NOTREGISTERED,
    UNREGISTEREHSINTERFACE_SUCCESS
  };

  UnregisterEHSResult UnregisterEHS(const char *ipsRegisterPath);

  virtual HttpResponse *RouteRequest(HttpRequest *ipoHttpRequest);

  virtual ResponseCode HandleRequest(HttpRequest *ipoHttpRequest,
                                     HttpResponse *ipoHttpResponse);

  virtual void HttpPulse(void){};

  virtual bool ShouldAllowConnection(const char *szAddress) { return true; }"	claude-3-5-sonnet-20241022	The function `GetNetworkAbstraction()` returns a pointer to a NetworkAbstraction object that handles network communication operations in the server.	1	1	0.07936507936507937	0.010802314890908065	{'f': 0.09090908739669434, 'p': 0.2, 'r': 0.058823529411764705}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.09090908739669434, 'p': 0.2, 'r': 0.058823529411764705}	20	0.06781876087188721
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power domain attributes command and testing the received values.	3	"void arm_scmi_custom_test_power_domain_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t attributes;
  uint32_t protocol_mask = expected_flags_mask;
  uint32_t rcv_u, exp_u;
  char *domain_name;
  char *rcv_s, *exp_s;
  struct arm_scmi_protocol_execution_context *prot = protocol_execution_context;
  enum test_status res;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_domain_attributes,
                           domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_domain_attributes,
                                       domain_id)] =
        power_protocol_data.num_power_domains + 1;
    error_code =
        arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_power_domain_attributes, domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tPOWER DOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&prot->test_stats, description);
      error_code =
          arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        break;
      attributes = RETURN_VAL(received, struct arm_scmi_power_domain_attributes,
                              attributes);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_HIGH,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_LOW);
      snprintf(name, NUM_ELEMS(name),
               ""POWER STATE CHANGE NOTIFICATIONS SUPPORT"");
      if ((power_expected->power_state_notification_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_STATE_NOTIFICATION_SUPPORT))) {
        exp_u = power_expected->power_state_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_ASYNC_HIGH,
                                     POWER_DOMAIN_ATTR_ASYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER ASYNCHRONOUS SUPPORT"");
      if ((power_expected->power_asynchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_ASYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_asynchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_SYNC_HIGH,
                                     POWER_DOMAIN_ATTR_SYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER SYNCHRONOUS SUPPORT"");
      if ((power_expected->power_synchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_SYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_synchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      arm_scmi_check_and_report_dec(
          &prot->test_stats, ALL_BITS_SET, CHECK, RESERVED,
          arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_RESERVED_HIGH,
                                 POWER_DOMAIN_ATTR_RESERVED_LOW),
          ""RESERVED"");

      power_protocol_data.attributes[domain_id] = attributes;

      res = INFO;
      domain_name =
          RETURN_STR(received, struct arm_scmi_power_domain_attributes, name);
      rcv_s = domain_name;
      snprintf(name, NUM_ELEMS(name), ""DOMAIN NAME"");
      if ((power_expected->power_domain_names != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_DOMAIN_NAMES))) {
        exp_s = power_expected->power_domain_names[domain_id];
        res = (strcmp(rcv_s, exp_s) == 0) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", exp_s, rcv_s);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", rcv_s);
      }
      arm_scmi_log_test_result(&prot->test_stats, INFO, name, description);
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests the attributes of power domains in an SCMI system, including their notification support, synchronous/asynchronous capabilities, and domain names, while validating against expected values.	1	1	0.283471173438811	0.011818473926491593	{'f': 0.3181818133471075, 'p': 0.3888888888888889, 'r': 0.2692307692307692}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.22727272243801666, 'p': 0.2777777777777778, 'r': 0.19230769230769232}	75	0.6980706453323364
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	Soft-resets the attached printer, readying it for new commands.	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a soft reset command to a USB printer device through the control pipe using class-specific requests to reset the printer's state.	1	1	0.14285714285714288	0.009410489957951634	{'f': 0.13793103020214045, 'p': 0.2222222222222222, 'r': 0.1}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06896551296076128, 'p': 0.1111111111111111, 'r': 0.05}	85	0.6633822917938232
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock describe rates command and testing the received values.	3	"void arm_scmi_custom_tester_clock_describe_rates(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint8_t clock_id;
  uint32_t num_rates_flags;
  uint8_t num_rates = 0;
  uint32_t rcv_u, exp_u;
  uint32_t rate_index = 0;
  uint32_t remaining_rates;
  struct arm_scmi_clock_rate *rcv_rates, *rates;
  size_t nr;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  uint64_t op1, step_size;
  struct arm_scmi_clock_rate **discrete;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_describe_rates, clock_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       clock_id)] =
        clock_protocol_data.num_clocks;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       rate_index)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                         clock_id)] = clock_id;
      rate_index = 0;

      rates = clock_protocol_data.clocks[clock_id].rates;
      do {

        test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                           rate_index)] = rate_index;
        error_code = arm_scmi_execute_and_assert_test_case(
            protocol_execution_context, test_case, &received);
        if (arm_scmi_skip_return_values(error_code, received.status))
          break;

        num_rates_flags = RETURN_VAL(
            received, struct arm_scmi_clock_describe_rates, num_rates_flags);

        remaining_rates = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_NUM_RATES_REMAINING_HIGH,
            CLK_DESCRATE_NUM_RATES_REMAINING_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      remaining_rates,
                                      ""NUMBER OF REMAINING RATES"");

        rcv_u =
            arm_scmi_get_norm_bits(num_rates_flags, CLK_DESCRATE_RESERVED_HIGH,
                                   CLK_DESCRATE_RESERVED_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                      rcv_u, ""RESERVED"");

        uint32_t format = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_RETURN_FORMAT_HIGH,
            CLK_DESCRATE_RETURN_FORMAT_LOW);
        clock_protocol_data.format = format;
        if (clock_expected->rate_format_supported) {
          arm_scmi_check_and_report_dec(
              test_stats, expected_flags_mask,
              LEFT_SHIFT(RATE_FORMAT_SUPPORTED),
              clock_expected->rate_format_supported[clock_id], format,
              ""FORMAT"");
        } else {
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(RATE_FORMAT_SUPPORTED), 0,
                                        format, ""FORMAT"");
        }

        num_rates = arm_scmi_get_norm_bits(num_rates_flags,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_HIGH,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_LOW);
        exp_u = clock_expected->num_rates == NULL
                    ? 0
                    : clock_expected->num_rates[clock_id];
        arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                      LEFT_SHIFT(CLOCK_NUM_RATES), exp_u,
                                      num_rates, ""NUMBER OF RATES"");

        rcv_rates = (struct arm_scmi_clock_rate *)&received.payload[OFFSET_RET(
            struct arm_scmi_clock_describe_rates, rates)];
        if (format == THREE_TUPLE_RATE_FORMAT) {

          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].lower,
                                        ""LOWEST RATE {LOWER}"");
          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].upper,
                                        ""LOWEST RATE {UPPER}"");

          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].lower,
                                        ""HIGHEST RATE {LOWER}"");
          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].upper,
                                        ""HIGHEST RATE {UPPER}"");

          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].lower,
                                        ""STEP SIZE {LOWER}"");
          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].upper,
                                        ""STEP SIZE {UPPER}"");

          rates[MIN_CLOCK] = rcv_rates[LOWEST_RATE];
          op1 = (((uint64_t)rcv_rates[LOWEST_RATE].upper) << 32) |
                rcv_rates[LOWEST_RATE].lower;
          step_size = (((uint64_t)rcv_rates[STEP_SIZE].upper) << 32) |
                      rcv_rates[STEP_SIZE].lower;
          op1 += step_size;
          rates[MIN_CLOCK + 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          op1 = (((uint64_t)rcv_rates[HIGHEST_RATE].upper) << 32) |
                rcv_rates[HIGHEST_RATE].lower;
          op1 -= step_size;
          rates[MAX_CLOCK - 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          rates[MAX_CLOCK] = rcv_rates[HIGHEST_RATE];

        } else {

          discrete = clock_expected->discrete_clock_rates;
          for (nr = 0; nr < num_rates; ++nr) {
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].lower;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->lower,
                                          ""LOWER WORD"");
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].upper;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->upper,
                                          ""UPPER WORD"");

            if ((rate_index + nr) == 0) {
              rates[MIN_CLOCK] = rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] =
                  rates[MAX_CLOCK] = *rcv_rates;
            } else if ((rate_index + nr) == 1) {
              rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] = rates[MAX_CLOCK] =
                  *rcv_rates;
            }
            rates[MAX_CLOCK - 1] = rates[MAX_CLOCK];
            rates[MAX_CLOCK] = *rcv_rates;
            rcv_rates += 1;
          }
        }
        rate_index += num_rates;
      } while (remaining_rates > 0);
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests and validates the clock rate description capabilities of an SCMI (System Control and Management Interface) implementation, checking both discrete and three-tuple rate formats across different clock IDs.	1	1	0.16666666666666666	0.015703799285850036	{'f': 0.18181817698347122, 'p': 0.2222222222222222, 'r': 0.15384615384615385}	{'f': 0.04166666188368111, 'p': 0.05263157894736842, 'r': 0.034482758620689655}	{'f': 0.18181817698347122, 'p': 0.2222222222222222, 'r': 0.15384615384615385}	None_output	0.6059683561325073
SL-RU-MakiseGUI-971c7c7/MakiseGUI/makise.c	set new border. This region must be smaller then previous. It will be cropped. Borders need for drawing GUI. For gui elements do not leave their & their parent's borders. After setting border & drawing it you need to call makise_rem_border.	2	"MakiseBufferBorderData makise_add_border(MakiseBuffer *buffer,
                                         MakiseBufferBorder b) {
  if (buffer == 0)
    return (MakiseBufferBorderData){0};

  if (b.x < buffer->border.x)
    b.x = buffer->border.x;
  if (b.y < buffer->border.y)
    b.y = buffer->border.y;
  if (b.w > buffer->border.w + buffer->border.x - b.x)
    b.w = buffer->border.w + buffer->border.x - b.x;
  if (b.h > buffer->border.h + buffer->border.y - b.y)
    b.h = buffer->border.h + buffer->border.y - b.y;

  b.ex = b.x + b.w;
  b.ey = b.y + b.h;

  MakiseBufferBorder l = buffer->border;

  buffer->border = b;

  return (MakiseBufferBorderData){b, l};
}"	claude-3-5-sonnet-20241022	The function adds a new border to a buffer while ensuring it stays within the existing border limits, returning both the new and previous border data in a single structure.	1	1	0.11811023622047245	0.0128747618956248	{'f': 0.172413788252081, 'p': 0.14705882352941177, 'r': 0.20833333333333334}	{'f': 0.029850741358878063, 'p': 0.02631578947368421, 'r': 0.034482758620689655}	{'f': 0.10344827101070177, 'p': 0.08823529411764706, 'r': 0.125}	None_output	0.30848267674446106
openastroproject-openastro-ec7e71c/ext/ffmpeg/libavformat/utils.c	Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet().	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= FFMIN(s->max_streams, INT_MAX / sizeof(*streams))) {
    if (s->max_streams < INT_MAX / sizeof(*streams))
      av_log(s, AV_LOG_ERROR,
             ""Number of streams exceeds max_streams parameter (%d), see the ""
             ""documentation if you wish to increase it\n"",
             s->max_streams);
    return NULL;
  }
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"	claude-3-5-sonnet-20241022	This function creates and initializes a new stream (AVStream) within a format context (AVFormatContext), allocating necessary memory and setting default values for various stream parameters.	1	1	0.11238670694864047	0.02810936542698351	{'f': 0.12244897464389858, 'p': 0.1111111111111111, 'r': 0.13636363636363635}	{'f': 0.0701754337211453, 'p': 0.06060606060606061, 'r': 0.08333333333333333}	{'f': 0.12244897464389858, 'p': 0.1111111111111111, 'r': 0.13636363636363635}	85	0.4894830584526062
dakami-autoclave-84ab84b/old_but_working_qemu/block/io.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  enum BdrvTrackedRequestType type) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .type = type,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"	claude-3-5-sonnet-20241022	This function initializes and registers a new block device request tracking structure with specified parameters (like offset, bytes, type) and adds it to the block driver state's tracked requests list.	1	1	0.5717962860820004	0.0406731552331291	{'f': 0.324324320642805, 'p': 0.6666666666666666, 'r': 0.21428571428571427}	{'f': 0.16216215877282697, 'p': 0.375, 'r': 0.10344827586206896}	{'f': 0.324324320642805, 'p': 0.6666666666666666, 'r': 0.21428571428571427}	75	0.4259535074234009
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Write settings INI file via TinyFrame	2	"bool GEX_IniWrite(GexClient *gex, const char *buffer) {
  uint8_t buf[8];
  PayloadBuilder pb = pb_start(buf, 8, NULL);
  pb_u32(&pb, (uint32_t)strlen(buffer));

  GexBulk bw = (GexBulk){
      .buffer = (uint8_t *)buffer,
      .len = (uint32_t)strlen(buffer),
      .req_cmd = MSG_INI_WRITE,
      .req_data = buf,
      .req_len = (uint32_t)pb_length(&pb),
  };

  return GEX_BulkWrite(GEX_SysUnit(gex), &bw);
}"	claude-3-5-sonnet-20241022	This function writes initialization data from a provided buffer to a GEX system unit by creating a bulk write request with the buffer's length and content.	1	1	0.0625	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.2806772291660309
rexmac-pebble-chronocode-5a85c4a/src/chronocode.c	Initialize the app	2	"static void init(void) {

  SettingsStoreObject stored_settings;

  if (persist_exists(STORAGE_SETTINGS_KEY)) {
    persist_read_data(STORAGE_SETTINGS_KEY, &stored_settings,
                      sizeof(stored_settings));
    settings = stored_settings.flags;
    language_setting = stored_settings.language;
  } else {
    settings = 0;
    language_setting = LANG_EN_US;
  }

  window = window_create();
  window_set_background_color(
      window, (settings & SETTING_INVERTED) > 0 ? GColorWhite : GColorBlack);
  window_set_window_handlers(
      window, (WindowHandlers){.load = window_load, .unload = window_unload});
  window_stack_push(window, true);

  time_t now = time(NULL);
  struct tm *t = localtime(&now);
  update_time(t);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);

  Tuplet initial_settings[] = {
      TupletInteger(SETTING_SYNC_KEY_ALL_CAPS, (settings & SETTING_ALL_CAPS)),
      TupletInteger(SETTING_SYNC_KEY_INVERTED, (settings & SETTING_INVERTED)),
      TupletInteger(SETTING_SYNC_KEY_LANGUAGE, language_setting),
      TupletInteger(SETTING_SYNC_KEY_TWO_MIN_DOTS,
                    (settings & SETTING_TWO_MIN_DOTS))};
  app_sync_init(
      &settings_sync, settings_sync_buffer, sizeof(settings_sync_buffer),
      initial_settings, ARRAY_LENGTH(initial_settings),
      settings_sync_tuple_changed_callback, settings_sync_error_callback, NULL);
  app_message_open(64, 64);
}"	claude-3-5-sonnet-20241022	This function initializes a Pebble watchface app by loading stored settings, creating the main window, setting up time display, and configuring synchronization with the phone app.	1	1	0.2830188679245283	0.008640609739997756	{'f': 0.1481481461728395, 'p': 0.6666666666666666, 'r': 0.08333333333333333}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1481481461728395, 'p': 0.6666666666666666, 'r': 0.08333333333333333}	75	0.5246872305870056
freeciv-freeciv-e4ead30/client/gui-sdl2/spaceshipdlg.c	Popup (or raise) the spaceship dialog for the given player.	2	"void popup_spaceship_dialog(struct player *pPlayer) {
  struct SMALL_DLG *pSpaceShp;

  if (!(pSpaceShp = get_spaceship_dialog(pPlayer))) {
    struct widget *pBuf, *pWindow;
    utf8_str *pstr;
    char cbuf[128];
    SDL_Rect area;

    pSpaceShp = fc_calloc(1, sizeof(struct SMALL_DLG));

    fc_snprintf(cbuf, sizeof(cbuf), _(""The %s Spaceship""),
                nation_adjective_for_player(pPlayer));
    pstr = create_utf8_from_char(cbuf, adj_font(12));
    pstr->style |= TTF_STYLE_BOLD;

    pWindow = create_window_skeleton(NULL, pstr, 0);

    pWindow->action = space_dialog_window_callback;
    set_wstate(pWindow, FC_WS_NORMAL);
    pWindow->data.player = pPlayer;
    pWindow->private_data.small_dlg = pSpaceShp;
    add_to_gui_list(ID_WINDOW, pWindow);
    pSpaceShp->pEndWidgetList = pWindow;

    area = pWindow->area;

    pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                            WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
    pBuf->info_label =
        create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
    pBuf->data.player = pPlayer;
    pBuf->action = exit_space_dialog_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->key = SDLK_ESCAPE;
    area.w = MAX(area.w, (pBuf->size.w + adj_size(10)));

    add_to_gui_list(ID_BUTTON, pBuf);

    pBuf = create_themeicon_button_from_chars(
        current_theme->OK_Icon, pWindow->dst, _(""Launch""), adj_font(12), 0);

    pBuf->action = launch_spaceship_callback;
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_BUTTON, pBuf);

    pstr = create_utf8_from_char(get_spaceship_descr(NULL), adj_font(12));
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_LABEL, pBuf);

    pSpaceShp->pBeginWidgetList = pBuf;

    area.w = MAX(area.w, adj_size(300) - (pWindow->size.w - pWindow->area.w));

    resize_window(pWindow, NULL, NULL,
                  (pWindow->size.w - pWindow->area.w) + area.w,
                  (pWindow->size.h - pWindow->area.h) + area.h);

    area = pWindow->area;

    widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                        (main_window_height() - pWindow->size.h) / 2);

    pBuf = pWindow->prev;
    pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
    pBuf->size.y = pWindow->size.y + adj_size(2);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + area.h - pBuf->size.h - adj_size(7);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + adj_size(7);

    dialog_list_prepend(dialog_list, pSpaceShp);

    refresh_spaceship_dialog(pPlayer);
  } else {
    if (select_window_group_dialog(pSpaceShp->pBeginWidgetList,
                                   pSpaceShp->pEndWidgetList)) {
      widget_flush(pSpaceShp->pEndWidgetList);
    }
  }
}"	claude-3-5-sonnet-20241022	This function creates and displays a dialog window for managing a player's spaceship, showing information about the spaceship's status and providing options to launch it or close the dialog.	1	1	0.29411764705882354	0.010128952330932188	{'f': 0.29411764316609, 'p': 0.5555555555555556, 'r': 0.2}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.17647058434256063, 'p': 0.3333333333333333, 'r': 0.12}	None_output	0.7173128128051758
particle-iot-device-os-7fbf145/wiring/inc/spark_wiring_mesh.h	Determines if the given handler exists.	2	"#include ""scope_guard.h""
#include <memory>

#include ""spark_wiring_thread.h""

namespace spark {

class MeshSignal : public particle::Signal {
public:
  int rssi = 2;
  int qual = 0;

  MeshSignal() {}
  virtual ~MeshSignal(){};

  operator int8_t() const { return 2; }

  virtual hal_net_access_tech_t getAccessTechnology() const {
    return NET_ACCESS_TECHNOLOGY_IEEE802154;
  }

  virtual float getStrength() const { return 0.0f; }"	claude-3-5-sonnet-20241022	This code defines a MeshSignal class that inherits from particle::Signal to handle mesh network signal properties with basic attributes like RSSI and quality, using IEEE 802.15.4 technology.	1	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.06549397855997086
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the aggregated slab journal statistics for the slabs in this allocator.	2	"SlabJournalStatistics
getSlabJournalStatistics(const BlockAllocator *allocator) {
  const AtomicSlabJournalStatistics *atoms = &allocator->slabJournalStatistics;
  return (SlabJournalStatistics){
      .diskFullCount = atomicLoad64(&atoms->diskFullCount),
      .flushCount = atomicLoad64(&atoms->flushCount),
      .blockedCount = atomicLoad64(&atoms->blockedCount),
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
      .tailBusyCount = atomicLoad64(&atoms->tailBusyCount),
  };
}"	claude-3-5-sonnet-20241022	This function retrieves various statistical counters related to slab journal operations from a BlockAllocator by atomically loading values from its slabJournalStatistics structure and returning them in a new SlabJournalStatistics object.	1	1	0.2695652173913044	0.014614031921776127	{'f': 0.1538461497961868, 'p': 0.2727272727272727, 'r': 0.10714285714285714}	{'f': 0.049999996012500325, 'p': 0.09090909090909091, 'r': 0.034482758620689655}	{'f': 0.1538461497961868, 'p': 0.2727272727272727, 'r': 0.10714285714285714}	None_output	0.688721239566803
opalenzuela-opendomo-1adadbd/src/odbase/src/script.c	Process a comments line and format the output in HTML or XML.	2	"script_process_comments(const char *buf) {
  char tipname[50];
  char *classname = NULL;
  char *contents = NULL;

  if (strlen(buf) < 3)
    return;

  if (gui == html) {
    if ((buf[0] == '-') && (buf[1] == '-')) {
      printf(""\t<hr/>\n"");
    } else if (SPELL3(buf, 'E', 'R', 'R')) {
      printf(""\t<p class='error'>%s</p>\n"", T(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R')) {
      printf(""\t<p class='warning'>%s</p>\n"", T(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F')) {
      printf(""\t<p class='info'>%s</p>\n"", T(buf += 5));
    } else if (SPELL3(buf, 'T', 'I', 'P')) {
      printf(""\t<p class='tooltip tip'>%s</p>\n"", T(buf += 4));
    } else if (SPELL3(buf, 'L', 'O', 'A')) {

      printf(""\t<p class='loading'>%s</p>\n"", T(buf += 8));

      printf(""<script type='text/Javascript'>\n""
             ""$(function($){\n""
             ""	$('p.loading').hide() ;\n""
             ""});\n""
             ""</script>\n"");
    } else if (SPELL3(buf, 'U', 'R', 'L')) {
      printf(""\t<p class='link'>""
             ""<a href='%s' target='_blank'>%s</a></p>\n"",
             buf += 4, buf);
    } else if (buf[0] == '>') {
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    } else {

      if (buf[0] == ' ') {
        printf(""\t<p class='comments'>%s</p>\n"", T(buf += 1));
      } else {
        classname = strtok(buf, "" "");
        contents = strtok(NULL, ""\n"");

        printf(""\t<p class='%s'>%s</p>\n"", classname, T(contents));
      }
    }
  } else {
    if (SPELL3(buf, 'E', 'R', 'R') || SPELL3(buf, 'e', 'r', 'r')) {
      printf(""\t<error description='%s'/>\n"", CT(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R') || SPELL3(buf, 'w', 'a', 'r')) {
      printf(""\t<warning description='%s'/>\n"", CT(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F') || SPELL3(buf, 'i', 'n', 'f'))
      printf(""\t<info description='%s'/>\n"", CT(buf += 5));
    else if (buf[0] == '>')
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    else
      printf(""\t<message description='%s'/>\n"", CT(buf += 1));
  }
}"	claude-3-5-sonnet-20241022	This function processes and formats different types of comments (like errors, warnings, info, tooltips) and outputs them in either HTML or XML format based on the input buffer content.	1	1	0.543065693430657	0.040931410461557835	{'f': 0.3999999958, 'p': 0.6666666666666666, 'r': 0.2857142857142857}	{'f': 0.10256409851413557, 'p': 0.18181818181818182, 'r': 0.07142857142857142}	{'f': 0.29999999580000003, 'p': 0.5, 'r': 0.21428571428571427}	85	0.6074992418289185
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI INQUIRY command to a USB Mass Storage device to retrieve information about a specific Logical Unit Number (LUN) and stores the response data in the provided buffer.	1	1	0.3435135135135135	0.017448767890681335	{'f': 0.32558139080584103, 'p': 0.4666666666666667, 'r': 0.25}	{'f': 0.0425531869986424, 'p': 0.0625, 'r': 0.03225806451612903}	{'f': 0.18604650708491086, 'p': 0.26666666666666666, 'r': 0.14285714285714285}	95	0.6877444982528687
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/handler/mimemap.c	returns the default mime attributes given a mime type	2	"void h2o_mimemap_get_default_attributes(const char *_mime,
                                        h2o_mime_attributes_t *attr) {
  char *mime = alloca(strlen(_mime) + 1);
  strcpy(mime, _mime);

  const char *type_end_at;

  if ((type_end_at = strchr(mime, ';')) == NULL)
    type_end_at = mime + strlen(mime);

  *attr = (h2o_mime_attributes_t){0};

  if (h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/css"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/javascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/javascript""))) {
    attr->is_compressible = 1;
    attr->priority = H2O_MIME_ATTRIBUTE_PRIORITY_HIGHEST;
  } else if (h2o_memis(mime, type_end_at - mime,
                       H2O_STRLIT(""application/json"")) ||
             strncmp(mime, ""text/"", 5) == 0 ||
             h2o_strstr(mime, type_end_at - mime, H2O_STRLIT(""+xml"")) !=
                 SIZE_MAX) {
    attr->is_compressible = 1;
  }
}"	claude-3-5-sonnet-20241022	This function determines default MIME attributes for different content types, setting compression and priority flags based on the MIME type, particularly for text-based content like CSS, JavaScript, JSON, and XML files.	1	1	0.5022321428571428	0.008531104334876973	{'f': 0.228571425044898, 'p': 0.5, 'r': 0.14814814814814814}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1714285679020409, 'p': 0.375, 'r': 0.1111111111111111}	None_output	0.6243785619735718
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/KeyboardHost/KeyboardHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs.	1	"void Keyboard_HID_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    ReadNextReport();

    break;
  }
}"	claude-3-5-sonnet-20241022	This function handles USB keyboard device enumeration and configuration in a host system, transitioning through different states to establish communication and read keyboard reports.	1	1	0.12820512820512822	0.00922283458304764	{'f': 0.26086956022684316, 'p': 0.25, 'r': 0.2727272727272727}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.217391299357278, 'p': 0.20833333333333334, 'r': 0.22727272727272727}	None_output	0.50330650806427
HiPhish-XeenTools-ee7c26c/Source/cpp/cpp_tool.c	Read a copy-protection entry from file.	2	"int xeen_read_copy_protection(FILE *fp, long o, int index,
                              XeenCopyProtection *prot) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
    INVALID_DATA,
  } error = SUCCESS;

  uint8_t bytes[LENGTH];

  uint8_t counter = (index * 16);

  if (!fp || !prot) {
    error = INVALID_ARGS;
    goto end;
  } else if (prot->line != 0 || prot->page != 0 || prot->word != 0 ||
             prot->string[0] != '\0') {
    error = INVALID_ARGS;
    goto end;
  }

  if (fseek(fp, o + LENGTH * index, SEEK_SET)) {
    error = FREAD_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), LENGTH, fp) != sizeof(uint8_t) * LENGTH) {
    error = FREAD_FAIL;
    goto end;
  }

  for (int i = 0; i < LENGTH; ++i) {
    bytes[i] ^= (counter++);
  }

  if (bytes[LENGTH - 1] != '\0') {
    error = INVALID_DATA;
    goto end;
  }

  *prot = (XeenCopyProtection){
      .page = bytes[0],
      .line = bytes[1],
      .word = bytes[2],
  };

  for (int i = 0; i < XEEN_CPP_LENGTH; ++i) {
    prot->string[i] = bytes[3 + i];
  }

end:
  return error;
}"	claude-3-5-sonnet-20241022	This function reads copy protection data from a file at a specific offset, decrypts it using XOR operations, and stores the decrypted information (page, line, word, and string) in a XeenCopyProtection structure.	1	1	0.23255813953488375	0.007678432706586176	{'f': 0.17142856858775513, 'p': 0.5, 'r': 0.10344827586206896}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.11428571144489805, 'p': 0.3333333333333333, 'r': 0.06896551724137931}	60	0.6211997866630554
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Core/HostStandardReq.c	Selects a given alternative setting for the specified interface, via a SET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_SetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        const uint8_t AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_SetInterface,
      .wValue = AltSetting,
      .wIndex = InterfaceIndex,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a USB control request to set an alternative interface setting for a specified interface on a connected USB device using the control pipe.	1	1	0.46000660799567483	0.03096815816279625	{'f': 0.526315784529086, 'p': 0.5882352941176471, 'r': 0.47619047619047616}	{'f': 0.13953487885343446, 'p': 0.16666666666666666, 'r': 0.12}	{'f': 0.3684210476869806, 'p': 0.4117647058823529, 'r': 0.3333333333333333}	95	0.6189160346984863
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Constructs a quaternion from a four-element vector. Note that the imaginary (vector) part of the quaternion comes from lanes 0, 1, and 2 of the vector, and the real (scalar) part comes from lane 3.	2	"static inline SIMD_CFUNC simd_quatd simd_quaternion(simd_double4 xyzr) {
  return (simd_quatd){xyzr};
}"	claude-3-5-sonnet-20241022	This function creates a quaternion (simd_quatd) from a 4D double-precision vector (simd_double4) where xyz represents the vector part and r represents the scalar part.	1	1	0.25155686660111437	0.024765147087879785	{'f': 0.3902438974657942, 'p': 0.36363636363636365, 'r': 0.42105263157894735}	{'f': 0.18518518035665305, 'p': 0.15625, 'r': 0.22727272727272727}	{'f': 0.3902438974657942, 'p': 0.36363636363636365, 'r': 0.42105263157894735}	95	0.604168176651001
freeciv-freeciv-e4ead30/client/gui-sdl2/repodlgs.c	Popup (or raise) the economy report (F5). It may or may not be modal.	2	"void economy_report_dialog_popup(bool make_modal) {
  SDL_Color bg_color = {255, 255, 255, 128};
  SDL_Color bg_color2 = {255, 255, 255, 136};
  SDL_Color bg_color3 = {255, 255, 255, 64};
  struct widget *pBuf;
  struct widget *pWindow, *pLast;
  utf8_str *pstr, *pstr2;
  SDL_Surface *pSurf, *pText_Name, *pText, *pZoom;
  SDL_Surface *pBackground;
  int i, count, h = 0;
  int w = 0;
  int w2 = 0;
  int w3 = 0;
  int tax, total, entries_used = 0;
  char cbuf[128];
  struct improvement_entry entries[B_LAST];
  SDL_Rect dst;
  SDL_Rect area;
  struct government *pGov = government_of_player(client.conn.playing);
  SDL_Surface *pTreasuryText;
  SDL_Surface *pTaxRateText;
  SDL_Surface *pTotalIncomeText;
  SDL_Surface *pTotalCostText;
  SDL_Surface *pNetIncomeText;
  SDL_Surface *pMaxRateText;

  if (pEconomyDlg) {
    return;
  }

  pBuf = get_tax_rates_widget();
  set_wstate(pBuf, FC_WS_DISABLED);
  widget_redraw(pBuf);
  widget_mark_dirty(pBuf);

  pEconomyDlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  get_economy_report_data(entries, &entries_used, &total, &tax);

  pstr = create_utf8_from_char(_(""Economy Report""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);
  pEconomyDlg->pEndWidgetList = pWindow;
  set_wstate(pWindow, FC_WS_NORMAL);
  pWindow->action = economy_dialog_callback;

  add_to_gui_list(ID_ECONOMY_DIALOG_WINDOW, pWindow);

  area = pWindow->area;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Treasury: ""));
  pstr2 = create_utf8_from_char(cbuf, adj_font(12));
  pstr2->style |= TTF_STYLE_BOLD;
  pTreasuryText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTreasuryText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", client.conn.playing->economic.gold);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(pIcons->pBIG_Coin, pWindow->dst, pstr,
                          (WF_RESTORE_BACKGROUND | WF_ICON_CENTER_RIGHT));

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Tax Rate: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTaxRateText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTaxRateText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "", client.conn.playing->economic.tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w + pBuf->next->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTotalIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Cost: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalCostText = create_text_surf_from_utf8(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Net Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pNetIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pNetIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax - total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  if (tax - total < 0) {
    pstr->fgcol = *get_theme_color(COLOR_THEME_ECONOMYDLG_NEG_TEXT);
  }

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""%s max rate : %d%%""),
              government_name_translation(pGov),
              get_player_bonus(client.conn.playing, EFT_MAX_RATES));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pMaxRateText = create_text_surf_from_utf8(pstr2);

  FREEUTF8STR(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_LUX_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);
  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);
  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_BLOCK_CHECKBOX, pBuf);

  w2 = adj_size(10) + pBuf->size.w;

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.luxury;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_SCROLLBAR, pBuf);

  w2 += adj_size(184);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.luxury);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Luxury, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);
  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_LABEL, pBuf);

  w2 += (adj_size(5) + pBuf->size.w + adj_size(10));

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_SCI_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);

  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);

  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_BLOCK_CHECKBOX, pBuf);

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.science;

  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_SCROLLBAR, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.science);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Colb, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_LABEL, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Update""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon_button(current_theme->Small_OK_Icon, pWindow->dst,
                                 pstr, 0);
  pBuf->action = apply_taxrates_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_OK_BUTTON, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Close Dialog (Esc)""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label = pstr;
  pBuf->action = exit_economy_dialog_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_CANCEL_BUTTON, pBuf);

  h += adj_size(5);

  pLast = pBuf;
  if (entries_used > 0) {

    pBackground = create_surf(adj_size(116), adj_size(116), SDL_SWSURFACE);

    SDL_FillRect(pBackground, NULL, map_rgba(pBackground->format, bg_color));

    create_frame(pBackground, 0, 0, pBackground->w - 1, pBackground->h - 1,
                 get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (SF_CENTER | TTF_STYLE_BOLD);
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};

    for (i = 0; i < entries_used; i++) {
      struct improvement_entry *p = &entries[i];
      struct impr_type *pImprove = p->type;

      pSurf = crop_rect_from_surface(pBackground, NULL);

      fc_snprintf(cbuf, sizeof(cbuf), ""%s"",
                  improvement_name_translation(pImprove));

      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style |= TTF_STYLE_BOLD;
      pText_Name =
          create_text_surf_smaller_than_w(pstr, pSurf->w - adj_size(4));

      fc_snprintf(cbuf, sizeof(cbuf), ""%s %d\n%s %d"", _(""Built""), p->count,
                  _(""U Total""), p->total_cost);
      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style &= ~TTF_STYLE_BOLD;

      pText = create_text_surf_from_utf8(pstr);

      pZoom = get_building_surface(pImprove);
      pZoom = zoomSurface(pZoom, DEFAULT_ZOOM * ((float)54 / pZoom->w),
                          DEFAULT_ZOOM * ((float)54 / pZoom->w), 1);

      dst.x = (pSurf->w - pZoom->w) / 2;
      dst.y = (pSurf->h / 2 - pZoom->h) / 2;
      alphablit(pZoom, NULL, pSurf, &dst, 255);
      dst.y += pZoom->h;
      FREESURFACE(pZoom);

      dst.x = (pSurf->w - pText_Name->w) / 2;
      dst.y += ((pSurf->h - dst.y) -
                (pText_Name->h + (pIcons->pBIG_Coin->h + 2) + pText->h)) /
               2;
      alphablit(pText_Name, NULL, pSurf, &dst, 255);

      dst.y += pText_Name->h;
      if (p->cost) {
        dst.x = (pSurf->w - p->cost * (pIcons->pBIG_Coin->w + 1)) / 2;
        for (count = 0; count < p->cost; count++) {
          alphablit(pIcons->pBIG_Coin, NULL, pSurf, &dst, 255);
          dst.x += pIcons->pBIG_Coin->w + 1;
        }
      } else {

        if (!is_wonder(pImprove)) {
          copy_chars_to_utf8_str(pstr, _(""Nation""));
        } else {
          copy_chars_to_utf8_str(pstr, _(""Wonder""));
        }

        pZoom = create_text_surf_from_utf8(pstr);

        dst.x = (pSurf->w - pZoom->w) / 2;
        alphablit(pZoom, NULL, pSurf, &dst, 255);
        FREESURFACE(pZoom);
      }

      dst.y += (pIcons->pBIG_Coin->h + adj_size(2));
      dst.x = (pSurf->w - pText->w) / 2;
      alphablit(pText, NULL, pSurf, &dst, 255);

      FREESURFACE(pText);
      FREESURFACE(pText_Name);

      pBuf =
          create_icon2(pSurf, pWindow->dst,
                       (WF_RESTORE_BACKGROUND | WF_FREE_THEME | WF_FREE_DATA));

      set_wstate(pBuf, FC_WS_NORMAL);

      pBuf->data.cont = fc_calloc(1, sizeof(struct CONTAINER));
      pBuf->data.cont->id0 = improvement_number(p->type);
      pBuf->data.cont->id1 = p->count;
      pBuf->action = popup_sell_impr_callback;

      add_to_gui_list(MAX_ID - i, pBuf);

      if (i > (TARGETS_ROW * TARGETS_COL - 1)) {
        set_wflag(pBuf, WF_HIDDEN);
      }
    }

    FREEUTF8STR(pstr);
    FREESURFACE(pBackground);

    pEconomyDlg->pEndActiveWidgetList = pLast->prev;
    pEconomyDlg->pBeginWidgetList = pBuf;
    pEconomyDlg->pBeginActiveWidgetList = pEconomyDlg->pBeginWidgetList;

    if (entries_used > (TARGETS_ROW * TARGETS_COL)) {
      pEconomyDlg->pActiveWidgetList = pEconomyDlg->pEndActiveWidgetList;
      count = create_vertical_scrollbar(pEconomyDlg, TARGETS_COL, TARGETS_ROW,
                                        TRUE, TRUE);
      h += (TARGETS_ROW * pBuf->size.h + adj_size(10));
    } else {
      count = 0;
      if (entries_used > TARGETS_COL) {
        h += pBuf->size.h;
      }
      h += (adj_size(10) + pBuf->size.h);
    }
    count = TARGETS_COL * pBuf->size.w + count;
  } else {
    pEconomyDlg->pBeginWidgetList = pBuf;
    h += adj_size(10);
    count = 0;
  }

  area.w = MAX(area.w, MAX(adj_size(10) + w3 + w + w2, count));
  area.h = h;

  pBackground = theme_get_background(theme, BACKGROUND_ECONOMYDLG);
  if (resize_window(pWindow, pBackground, NULL,
                    (pWindow->size.w - pWindow->area.w) + area.w,
                    (pWindow->size.h - pWindow->area.h) + area.h)) {
    FREESURFACE(pBackground);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + adj_size(10) + pTreasuryText->w;
  pBuf->size.y = area.y + adj_size(5);

  w = pTreasuryText->w + pBuf->size.w;
  h = pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTaxRateText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTaxRateText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalCostText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalCostText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pNetIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pNetIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  dst.x = area.x;
  dst.y = area.y;
  dst.w = area.w;
  dst.h = h + adj_size(15);
  h = dst.h;

  fill_rect_alpha(pWindow->theme, &dst, &bg_color2);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  dst.x = area.x + adj_size(10);
  dst.y = area.y + adj_size(5);

  alphablit(pTreasuryText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTreasuryText->h;
  FREESURFACE(pTreasuryText);

  alphablit(pTaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTaxRateText->h;
  FREESURFACE(pTaxRateText);

  alphablit(pTotalIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalIncomeText->h;
  FREESURFACE(pTotalIncomeText);

  alphablit(pTotalCostText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalCostText->h;
  FREESURFACE(pTotalCostText);

  alphablit(pNetIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pNetIncomeText->h;
  FREESURFACE(pNetIncomeText);

  dst.x = area.x + adj_size(10) + w +
          ((area.w - (w + adj_size(10)) - pMaxRateText->w) / 2);
  dst.y = area.y + adj_size(5);

  alphablit(pMaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += (pMaxRateText->h + 1);
  FREESURFACE(pMaxRateText);

  dst.x = area.x + adj_size(10) + w +
          (area.w - (w + adj_size(10)) - adj_size(184)) / 2;
  dst.w = adj_size(184);
  dst.h = current_theme->Horiz->h - adj_size(2);

  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.luxury * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  dst.y += current_theme->Horiz->h + 1;
  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.science * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + (dst.w - pBuf->size.w) / 2;
  pBuf->size.y = dst.y + dst.h + adj_size(3);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  if (entries_used > 0) {
    setup_vertical_widgets_position(TARGETS_COL, area.x, area.y + h, 0, 0,
                                    pEconomyDlg->pBeginActiveWidgetList,
                                    pEconomyDlg->pEndActiveWidgetList);
    if (pEconomyDlg->pScroll) {
      setup_vertical_scrollbar_area(pEconomyDlg->pScroll, area.x + area.w - 1,
                                    area.y + h, area.h - h - 1, TRUE);
    }
  }

  redraw_group(pEconomyDlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);
  flush_dirty();
}"	claude-3-5-sonnet-20241022	This function creates and displays the Economy Report dialog in a game interface, showing financial information like treasury, tax rates, income, and costs, along with controls for adjusting economic settings.	1	1	0.24038461538461542	0.006244385951234721	{'f': 0.04878048366448578, 'p': 0.08333333333333333, 'r': 0.034482758620689655}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.04878048366448578, 'p': 0.08333333333333333, 'r': 0.034482758620689655}	None_output	0.5749777555465698
darktable-org-darktable-32fab21/src/iop/flip.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_flip_params_t p = (dt_iop_flip_params_t){ORIENTATION_NONE};
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  p.orientation = ORIENTATION_NULL;
  dt_gui_presets_add_generic(_(""autodetect""), self->op, self->version(), &p,
                             sizeof(p), 1);
  dt_gui_presets_update_autoapply(_(""autodetect""), self->op, self->version(),
                                  1);

  p.orientation = ORIENTATION_NONE;
  dt_gui_presets_add_generic(_(""no rotation""), self->op, self->version(), &p,
                             sizeof(p), 1);

  p.orientation = ORIENTATION_FLIP_HORIZONTALLY;
  dt_gui_presets_add_generic(_(""flip horizontally""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_FLIP_VERTICALLY;
  dt_gui_presets_add_generic(_(""flip vertically""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by -90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CCW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by  90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_180_DEG;
  dt_gui_presets_add_generic(_(""rotate by 180 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	This function initializes preset orientations for image flipping and rotation operations, including options like autodetect, no rotation, horizontal/vertical flips, and various degree rotations.	1	1	0.17045454545454544	0.010900096978029118	{'f': 0.16216215725346983, 'p': 0.1875, 'r': 0.14285714285714285}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.16216215725346983, 'p': 0.1875, 'r': 0.14285714285714285}	65	0.40844881534576416
DelusionalLogic-NeoComp-271e784/src/compton.c	Do the actual work.	2	"void session_run(session_t *ps) {
#ifdef DEBUG_PROFILE
  struct ProfilerWriterSession profSess;
  profilerWriter_init(&profSess);
#endif

  paint_preprocess(ps);

  timestamp lastTime;
  if (!getTime(&lastTime)) {
    printf_errf(""Failed getting time"");
    session_destroy(ps);
    exit(1);
  }

  assign_depth(&ps->win_list, &ps->order);

  ps->idling = false;

  while (!ps->reset) {

    zone_start(&ZONE_global);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    zone_enter(&ZONE_input);

    while (mainloop(ps))
      ;

    Swiss *em = &ps->win_list;

    for_components(it, em, COMPONENT_PHYSICAL, COMPONENT_TRACKS_WINDOW,
                   COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct TracksWindowComponent *window =
          swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);

      XWindowAttributes attribs;
      if (!XGetWindowAttributes(ps->xcontext.display, window->id, &attribs)) {
        printf_errf(""Failed getting window attributes while mapping"");
        swiss_removeComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
        continue;
      }

      Vector2 extents = {{attribs.width + attribs.border_width * 2,
                          attribs.height + attribs.border_width * 2}};

      Vector2 offset = {{-attribs.border_width, -attribs.border_width}};

      XserverRegion window_region = XFixesCreateRegionFromWindow(
          ps->xcontext.display, window->id, ShapeBounding);

      XRectangle default_clip = {.x = offset.x,
                                 .y = offset.y,
                                 .width = extents.x,
                                 .height = extents.y};
      XserverRegion default_clip_region =
          XFixesCreateRegion(ps->xcontext.display, &default_clip, 1);
      XFixesIntersectRegion(ps->xcontext.display, window_region, window_region,
                            default_clip_region);

      int rect_count;
      XRectangle *rects =
          XFixesFetchRegion(ps->xcontext.display, window_region, &rect_count);

      XFixesDestroyRegion(ps->xcontext.display, window_region);

      vector_init(&shapeDamaged->rects, sizeof(struct Rect), rect_count);

      convert_xrects_to_relative_rect(rects, rect_count, &extents, &offset,
                                      &shapeDamaged->rects);
    }

    zone_leave(&ZONE_input);

    timestamp currentTime;
    if (!getTime(&currentTime)) {
      printf_errf(""Failed getting time"");
      exit(1);
    }

    double dt = timeDiff(&lastTime, &currentTime);

    ps->skip_poll = false;

    if (ps->o.benchmark) {
      if (ps->o.benchmark_wid) {
        win *w = find_win(ps, ps->o.benchmark_wid);
        if (!w) {
          printf_errf(""(): Couldn't find specified benchmark window."");
          session_destroy(ps);
          exit(1);
        }
      }
    }

    ps->idling = true;

    zone_enter(&ZONE_preprocess);

    paint_preprocess(ps);

    zone_leave(&ZONE_preprocess);

    zone_enter(&ZONE_update);

    zone_enter(&ZONE_update_z);
    assign_depth(&ps->win_list, &ps->order);
    zone_leave(&ZONE_update_z);

    zone_enter(&ZONE_update_wintype);

    for_components(it, em, COMPONENT_MAP, CQ_END) {
      swiss_addComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
    }

    fill_wintype_changes(&ps->win_list, ps);

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      swiss_ensureComponent(em, COMPONENT_FOCUS_CHANGE, it.id);
    }

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      struct WintypeChangedComponent *wintypeChanged =
          swiss_getComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
      struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

      w->window_type = wintypeChanged->newType;
    }
    zone_leave(&ZONE_update_wintype);

    if (ps->o.shadow_blacklist) {
      zone_enter(&ZONE_update_shadow_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->shadow = (ps->o.wintype_shadow[w->window_type] &&
                       !win_match(ps, w, ps->o.shadow_blacklist) &&
                       !(ps->o.respect_prop_shadow));
        }
      }
      zone_leave(&ZONE_update_shadow_blacklist);
    }

    if (ps->o.fade_blacklist) {
      zone_enter(&ZONE_update_fade_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

        if (win_mapped(em, it.id)) {

          if (win_match(ps, w, ps->o.fade_blacklist)) {
            w->fade = false;
          } else {
            w->fade = ps->o.wintype_fade[w->window_type];
          }
        }
      }
      zone_leave(&ZONE_update_fade_blacklist);
    }

    if (ps->o.blur_background_blacklist) {
      zone_enter(&ZONE_update_blur_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          bool blur_background_new =
              ps->o.blur_background &&
              !win_match(ps, w, ps->o.blur_background_blacklist);

          win_set_blur_background(ps, w, blur_background_new);
        }
      }
      zone_leave(&ZONE_update_blur_blacklist);
    }

    if (ps->o.paint_blacklist) {
      zone_enter(&ZONE_update_paint_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->paint_excluded = win_match(ps, w, ps->o.paint_blacklist);
        }
      }
      zone_leave(&ZONE_update_paint_blacklist);
    }

    zone_enter(&ZONE_input_react);
    commit_destroy(&ps->win_list);
    commit_map(&ps->win_list, &ps->atoms, &ps->xcontext);
    commit_unmap(&ps->win_list, &ps->xcontext);
    commit_opacity_change(&ps->win_list, ps->o.opacity_fade_time,
                          ps->o.bg_opacity_fade_time);
    commit_move(&ps->win_list, &ps->order);
    commit_resize(&ps->win_list, &ps->order);
    commit_reshape(&ps->win_list, &ps->xcontext);
    zone_leave(&ZONE_input_react);

    zone_enter(&ZONE_make_cutout);
    {
      XserverRegion newShape = XFixesCreateRegion(ps->dpy, NULL, 0);
      for_components(it, em, COMPONENT_MUD, COMPONENT_TRACKS_WINDOW,
                     COMPONENT_PHYSICAL, CQ_NOT, COMPONENT_REDIRECTED, CQ_END) {
        struct TracksWindowComponent *tracksWindow =
            swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
        struct PhysicalComponent *physical =
            swiss_getComponent(em, COMPONENT_PHYSICAL, it.id);

        if (win_mapped(em, it.id)) {
          XserverRegion windowRegion = XFixesCreateRegionFromWindow(
              ps->xcontext.display, tracksWindow->id, ShapeBounding);
          XFixesTranslateRegion(ps->dpy, windowRegion, physical->position.x + 1,
                                physical->position.y + 1);
          XFixesUnionRegion(ps->xcontext.display, newShape, newShape,
                            windowRegion);
          XFixesDestroyRegion(ps->xcontext.display, windowRegion);
        }
      }
      XFixesInvertRegion(ps->dpy, newShape,
                         &(XRectangle){0, 0, ps->root_size.x, ps->root_size.y},
                         newShape);
      XFixesSetWindowShapeRegion(ps->dpy, ps->overlay, ShapeBounding, 0, 0,
                                 newShape);
      XFixesDestroyRegion(ps->xcontext.display, newShape);
    }
    zone_leave(&ZONE_make_cutout);

    zone_enter(&ZONE_prop_blur_damage);
    damage_blur_over_damaged(&ps->win_list, &ps->order);
    zone_leave(&ZONE_prop_blur_damage);

    zone_enter(&ZONE_update_textures);
    update_window_textures(&ps->win_list, &ps->xcontext,
                           &ps->psglx->shared_fbo);
    zone_leave(&ZONE_update_textures);

    update_focused_state(&ps->win_list, ps);
    calculate_window_opacity(ps, &ps->win_list);
    start_focus_fade(&ps->win_list, ps->o.opacity_fade_time,
                     ps->o.bg_opacity_fade_time, ps->o.dim_fade_time);

    zone_enter(&ZONE_update_fade);

    damage_blur_over_fade(&ps->win_list);
    syncronize_fade_opacity(&ps->win_list);
    if (do_win_fade(&ps->curve, dt, &ps->win_list)) {
      ps->skip_poll = true;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      t->time += dt;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      if (t->time >= t->duration)
        swiss_removeComponent(em, COMPONENT_TRANSITIONING, it.id);
    }

    zone_leave(&ZONE_update_fade);

    transition_faded_entities(&ps->win_list);
    remove_texture_invis_windows(&ps->win_list);
    finish_destroyed_windows(&ps->win_list, ps);
    zone_leave(&ZONE_update);

    Vector opaque;
    vector_init(&opaque, sizeof(win_id), ps->order.size);
    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED, CQ_NOT,
                   COMPONENT_BGOPACITY, COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&opaque, &it.id);
    }
    vector_qsort(&opaque, window_zcmp, &ps->win_list);
    Vector transparent;
    vector_init(&transparent, sizeof(win_id), ps->order.size);

    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED,
                   COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&transparent, &it.id);
    }
    vector_qsort(&transparent, window_zcmp, &ps->win_list);

    Vector opaque_shadow;
    vector_init(&opaque_shadow, sizeof(win_id), ps->order.size);
    fetchSortedWindowsWith(&ps->win_list, &opaque_shadow, COMPONENT_MUD,
                           COMPONENT_Z, COMPONENT_PHYSICAL, CQ_NOT,
                           COMPONENT_OPACITY, COMPONENT_SHADOW, CQ_END);

    zone_enter(&ZONE_effect_textures);

    zone_enter(&ZONE_update_shadow);
    windowlist_updateShadow(ps, &transparent);
    zone_leave(&ZONE_update_shadow);

    if (ps->o.blur_background)
      windowlist_updateBlur(ps);

    zone_leave(&ZONE_effect_textures);

    {
      static int paint = 0;

      zone_enter(&ZONE_paint);

      glDepthMask(GL_TRUE);
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      static const GLenum DRAWBUFS[2] = {GL_BACK_LEFT};
      glDrawBuffers(1, DRAWBUFS);
      glViewport(0, 0, ps->root_size.x, ps->root_size.y);

      glClearDepth(1.0);
      glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
      glDepthFunc(GL_LESS);

      windowlist_drawBackground(ps, &opaque);
      windowlist_drawTint(ps);
      windowlist_draw(ps, &opaque);

      paint_root(ps);

      windowlist_drawTransparent(ps, &transparent);

#ifdef DEBUG_WINDOWS

      draw_component_debug(&ps->win_list, &ps->root_size);
#endif

      vector_kill(&opaque_shadow);
      vector_kill(&transparent);
      vector_kill(&opaque);

      zone_leave(&ZONE_paint);

      paint++;
      if (ps->o.benchmark && paint >= ps->o.benchmark) {
#ifdef DEBUG_PROFILE
        profilerWriter_kill(&profSess);
#endif
        session_destroy(ps);
        exit(0);
      }
    }

    zone_enter(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_MAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_UNMAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_MOVE);
    swiss_removeComponentWhere(
        &ps->win_list, COMPONENT_RESIZE,
        (enum ComponentType[]){COMPONENT_PHYSICAL, CQ_END});

    swiss_resetComponent(em, COMPONENT_WINTYPE_CHANGE);

    swiss_resetComponent(&ps->win_list, COMPONENT_FOCUS_CHANGE);

    for_components(it, em, COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
      if (shapeDamaged->rects.elementSize != 0) {
        vector_kill(&shapeDamaged->rects);
      }
    }
    swiss_resetComponent(&ps->win_list, COMPONENT_SHAPE_DAMAGED);

    zone_leave(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_CONTENTS_DAMAGED);

#ifdef FRAMERATE_DISPLAY
    update_debug_graph(&ps->debug_graph, currentTime);
    draw_debug_graph(&ps->debug_graph, &(Vector2){{10, ps->root_size.y - 10}});
#endif

    struct ZoneEventStream *event_stream = zone_package(&ZONE_global);
#ifdef DEBUG_PROFILE

    profilerWriter_emitFrame(&profSess, event_stream);
#endif

    glXSwapBuffers(ps->dpy, get_tgt_window(ps));
    glFinish();

    lastTime = currentTime;
  }

#ifdef DEBUG_PROFILE
  profilerWriter_kill(&profSess);
#endif
}"	claude-3-5-sonnet-20241022	This function appears to be the main rendering loop of a compositing window manager, handling window updates, effects (like shadows and blur), and drawing windows to the screen using OpenGL.	1	1	0.15151515151515152	0.006244385951234721	{'f': 0.06666666435555564, 'p': 0.25, 'r': 0.038461538461538464}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06666666435555564, 'p': 0.25, 'r': 0.038461538461538464}	None_output	0.08198805898427963
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t),
                           NO_STREAM_CALLBACK);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
      NO_STREAM_CALLBACK);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	This function sends control line state changes (like carrier detect or ring indicator) from a USB CDC device to the host through the notification endpoint using specific USB protocol structures.	1	1	0.1228878648233487	0.011655008154172364	{'f': 0.2597402551121606, 'p': 0.20408163265306123, 'r': 0.35714285714285715}	{'f': 0.04395603961357367, 'p': 0.03225806451612903, 'r': 0.06896551724137931}	{'f': 0.2077922031641087, 'p': 0.16326530612244897, 'r': 0.2857142857142857}	95	0.7358025312423706
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities.	1	"uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
                          SCSI_Inquiry_Response_t *const InquiryPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, InquiryPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function sends an INQUIRY command to a USB mass storage device to retrieve device information and stores the response in the provided buffer.	1	1	0.37500485003686024	0.02898497051727735	{'f': 0.37837837346968595, 'p': 0.4375, 'r': 0.3333333333333333}	{'f': 0.09523809028344697, 'p': 0.10526315789473684, 'r': 0.08695652173913043}	{'f': 0.21621621130752386, 'p': 0.25, 'r': 0.19047619047619047}	None_output	0.48021072149276733
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Publishes the message to the current process and frees the strings.	2	"static void fio_publish2process(fio_msg_internal_s *m) {
  fio_msg_internal_finalize(m);
  channel_s *ch;
  if (m->filter) {
    ch = fio_filter_find_dup(m->filter);
    if (!ch) {
      goto finish;
    }
  } else {
    ch = fio_channel_find_dup(m->channel);
  }

  if (ch) {
    fio_defer_push_urgent(fio_publish2channel_task, ch,
                          fio_msg_internal_dup(m));
  }
  if (m->filter == 0) {

    fio_lock(&fio_postoffice.patterns.lock);
    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {
      if (!p->hash) {
        continue;
      }

      if (p->obj->match(
              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},
              m->channel)) {
        fio_channel_dup(p->obj);
        fio_defer_push_urgent(fio_publish2channel_task, p->obj,
                              fio_msg_internal_dup(m));
      }
    }
    fio_unlock(&fio_postoffice.patterns.lock);
  }
finish:
  fio_msg_internal_free(m);
}"	claude-3-5-sonnet-20241022	This function publishes a message either to a specific channel or filtered channels, handles pattern matching for channel subscriptions, and manages message duplication and cleanup.	1	1	0.16129032258064516	0.009970222994544455	{'f': 0.19999999580000008, 'p': 0.3333333333333333, 'r': 0.14285714285714285}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.19999999580000008, 'p': 0.3333333333333333, 'r': 0.14285714285714285}	20	0.4257349371910095
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/macsub.c	Returns a macro substitution result wrapping a silent error as produced by ava_macsub_silent_error().	2	"ava_macro_subst_result
ava_macsub_silent_error_result(const ava_compile_location *location) {
  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = ava_macsub_silent_error(location)};
}"	claude-3-5-sonnet-20241022	This function creates and returns a macro substitution result structure indicating a completed status and containing a silent error node at the specified location.	1	1	0.5319148936170213	0.1424465913886198	{'f': 0.36363635900826446, 'p': 0.5, 'r': 0.2857142857142857}	{'f': 0.2857142812081633, 'p': 0.4166666666666667, 'r': 0.21739130434782608}	{'f': 0.36363635900826446, 'p': 0.5, 'r': 0.2857142857142857}	None_output	0.44157105684280396
opticron-libuweave-2e5e385/src/ble_transport.c	Initializes a BLE transport service to handle BLE input and registers it in the runloop.	0	"bool uw_ble_transport_init(UwBleTransport *transport, UwDevice *device) {
  assert(transport != NULL && device != NULL);

  memset(transport, 0, sizeof(UwBleTransport));
  transport->device = device;

  uw_buffer_init(&transport->read_buffer, transport->read_data,
                 sizeof(transport->read_data));

  uw_buffer_init(&transport->write_buffer, transport->write_data,
                 sizeof(transport->write_data));

  uw_session_init_(&transport->session, device);

  uw_device_channel_init_(
      &transport->device_channel,
      (UwDeviceChannelHandshakeConfig){.handler = handshake_exchange_handler_,
                                       .data = (void *)transport},
      (UwDeviceChannelConnectionResetConfig){
          .handler = connection_reset_handler_, .data = (void *)transport},
      &transport->read_buffer, &transport->write_buffer, UW_BLE_PACKET_SIZE);

  uw_service_init_(&transport->service, service_start_handler_,
                   service_event_handler_, service_stop_handler_, transport);

  uw_device_register_service_(transport->device, &transport->service);

  UwSettings *settings = uw_device_get_settings(transport->device);
  settings->supports_ble_40 = true;

  return true;
}"	claude-3-5-sonnet-20241022	This function initializes a Bluetooth Low Energy (BLE) transport structure by setting up buffers, session, device channel, and service configurations while registering it with the device and enabling BLE 4.0 support.	1	1	0.4990963855421686	0.018041089138224272	{'f': 0.33333332888888895, 'p': 0.5, 'r': 0.25}	{'f': 0.0454545411157029, 'p': 0.07142857142857142, 'r': 0.03333333333333333}	{'f': 0.28571428126984133, 'p': 0.42857142857142855, 'r': 0.21428571428571427}	75	0.6737433671951294
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command.	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a Mass Storage Reset command to a USB storage device through the control pipe to reset the device to its default state.	1	1	0.23900301254114215	0.010384979504547183	{'f': 0.3461538414201184, 'p': 0.28125, 'r': 0.45}	{'f': 0.03030302567493184, 'p': 0.023809523809523808, 'r': 0.041666666666666664}	{'f': 0.2692307644970415, 'p': 0.21875, 'r': 0.35}	95	0.7282798886299133
graphitemaster-redroid-9cdd940/string.c	Constructs an empty managed string object.	2	"string_t *string_construct(void) {
  string_t *string =
      memcpy(malloc(sizeof(string_t)),
             &(string_t){.buffer = malloc(8), .allocated = 8, .length = 0},
             sizeof(string_t));
  *string->buffer = '\0';
  return string;
}"	claude-3-5-sonnet-20241022	This function creates and initializes a new string structure with an empty 8-byte buffer, setting its allocated size to 8 and length to 0, then returns a pointer to this structure.	1	1	0.30065359477124187	0.014117915208981237	{'f': 0.18749999695312503, 'p': 0.5, 'r': 0.11538461538461539}	{'f': 0.05714285469387766, 'p': 0.2, 'r': 0.03333333333333333}	{'f': 0.12499999695312508, 'p': 0.3333333333333333, 'r': 0.07692307692307693}	None_output	0.4434671998023987
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/MassStorageHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read in blocks from the device and print them to the serial port.	1	"TASK(USB_MassStore_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Mass Storage Disk Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    UpdateStatus(Status_Busy);

    if ((ErrorCode = MassStore_GetMaxLUN(&MassStore_MaxLUNIndex)) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Get Max LUN""), false, ErrorCode);
      break;
    }

    printf_P(PSTR(""Total LUNs: %d.\r\n""), (MassStore_MaxLUNIndex + 1));

    if ((ErrorCode = MassStore_MassStorageReset()) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Mass Storage Reset""), false, ErrorCode);
      break;
    }

    SCSI_Request_Sense_Response_t SenseData;
    if (((ErrorCode = MassStore_RequestSense(0, &SenseData)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Request Sense""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    if (((ErrorCode = MassStore_PreventAllowMediumRemoval(0, true)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Prevent/Allow Medium Removal""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""Waiting until ready..""));

    do {
      Serial_TxByte('.');

      if ((ErrorCode = MassStore_TestUnitReady(0)) != 0) {
        ShowDiskReadError(PSTR(""Test Unit Ready""), false, ErrorCode);
        break;
      }
    } while ((SCSICommandStatus.Status != Command_Pass) && USB_IsConnected);

    if (!(USB_IsConnected))
      break;

    puts_P(PSTR(""\r\nRetrieving Capacity... ""));

    SCSI_Capacity_t DiskCapacity;

    if (((ErrorCode = MassStore_ReadCapacity(0, &DiskCapacity)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Capacity""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    printf_P(PSTR(""%lu blocks of %lu bytes.\r\n""), DiskCapacity.Blocks,
             DiskCapacity.BlockSize);

    uint8_t BlockBuffer[DiskCapacity.BlockSize];

    if (((ErrorCode = MassStore_ReadDeviceBlock(
              0, 0x00000000, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Device Block""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""\r\nContents of first block:\r\n""));

    for (uint16_t Chunk = 0; Chunk < (DiskCapacity.BlockSize >> 4); Chunk++) {

      uint8_t *ChunkPtr = &BlockBuffer[Chunk << 4];

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        printf_P(PSTR(""%.2X ""), CurrByte);
      }

      puts_P(PSTR(""    ""));

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      puts_P(PSTR(""\r\n""));
    }

    puts_P(PSTR(""\r\n\r\nPress board button to read entire ASCII contents of ""
                ""disk...\r\n\r\n""));

    while (!(Buttons_GetStatus() & BUTTONS_BUTTON1)) {

      if (!(USB_IsConnected))
        break;
    }

    for (uint32_t CurrBlock = 0; CurrBlock < DiskCapacity.Blocks; CurrBlock++) {

      if (((ErrorCode = MassStore_ReadDeviceBlock(
                0, CurrBlock, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
          (SCSICommandStatus.Status != Command_Pass)) {
        ShowDiskReadError(PSTR(""Read Device Block""),
                          (SCSICommandStatus.Status != Command_Pass),
                          ErrorCode);
        break;
      }

      for (uint16_t Byte = 0; Byte < DiskCapacity.BlockSize; Byte++) {
        char CurrByte = BlockBuffer[Byte];

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      if (!(USB_IsConnected))
        break;
    }

    UpdateStatus(Status_USBReady);

    while (USB_IsConnected)
      ;

    break;
  }
}"	claude-3-5-sonnet-20241022	This function manages USB mass storage device interactions, handling device enumeration, configuration, and data reading operations through different states of the USB host connection.	1	1	0.14035087719298245	0.017881935836029296	{'f': 0.22727272227272738, 'p': 0.22727272727272727, 'r': 0.22727272727272727}	{'f': 0.03921568132256887, 'p': 0.03571428571428571, 'r': 0.043478260869565216}	{'f': 0.13636363136363655, 'p': 0.13636363636363635, 'r': 0.13636363636363635}	75	0.4826784133911133
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_ps(float __a, float __b, float __c, float __d, float __e, float __f,
               float __g, float __h) {
  return (__m256){__a, __b, __c, __d, __e, __f, __g, __h};
}"	claude-3-5-sonnet-20241022	This function creates a 256-bit vector by setting 8 single-precision floating-point values in reverse order (from left to right) into an AVX vector register.	1	1	0.13333333333333333	0.011191021613657745	{'f': 0.22222221760802477, 'p': 0.3076923076923077, 'r': 0.17391304347826086}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.16666666205246927, 'p': 0.23076923076923078, 'r': 0.13043478260869565}	10	0.32433974742889404
pgrawehr-golgotha-5d70da4/string/string.h	Attempts to convert the string to a number.	2	"i4_str *read_string();

w32 read_ascii(char *buffer, w32 buffer_size);

sw32 read_number(i4_bool throwexception = i4_F);

double read_float(i4_bool throwexception = i4_F);
}
;

virtual ~i4_const_str(){};

const iterator end() const { return ptr + len; }
iterator end() { return ptr + len; }

const iterator begin() const { return ptr; }
iterator begin() { return ptr; }

w32 length() const { return len; }"	claude-3-5-sonnet-20241022	These functions provide string manipulation capabilities, allowing reading and conversion of strings, ASCII characters, numbers, and floating-point values, as well as basic string operations like iteration and length determination.	1	1	0.14851485148514854	0.006471824245088331	{'f': 0.06249999658203144, 'p': 0.14285714285714285, 'r': 0.04}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06249999658203144, 'p': 0.14285714285714285, 'r': 0.04}	50	0.4670974612236023
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Close a stream	2	"void stream_close(pony_ctx_t **ctx, stream_t *s) {
  struct scons *scons = scons_mk(*ctx, NULL);
  scons->eos = true;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
}"	claude-3-5-sonnet-20241022	This function closes a stream by creating a stream constructor (scons) with an end-of-stream flag set to true, then fulfilling the stream's future with this constructor.	1	1	0.4821802935010482	0.015365418390819783	{'f': 0.159999997888, 'p': 0.6666666666666666, 'r': 0.09090909090909091}	{'f': 0.0769230755029586, 'p': 0.5, 'r': 0.041666666666666664}	{'f': 0.159999997888, 'p': 0.6666666666666666, 'r': 0.09090909090909091}	85	0.7375410795211792
HarveyHunt-howm-81b1d82/src/monitor.c	Create a single monitor for use with default X11.	2	"static void scan_x11_monitor(void) {
  monitor_t *m =
      create_monitor((xcb_rectangle_t){0, 0, screen_width, screen_height});

  add_ws(m);
}"	claude-3-5-sonnet-20241022	This function creates a monitor with the dimensions of the screen and adds a workspace to it in an X11 environment.	1	1	0.29411764705882354	0.01291802583371725	{'f': 0.28571428135204086, 'p': 0.4444444444444444, 'r': 0.21052631578947367}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.28571428135204086, 'p': 0.4444444444444444, 'r': 0.21052631578947367}	75	0.5972020626068115
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, BlockBuffer);
}"	claude-3-5-sonnet-20241022	This function reads data blocks from a USB Mass Storage device by sending a SCSI READ_10 command and storing the received data in a specified buffer.	1	1	0.5050000000000001	0.02022202784230022	{'f': 0.35294117209342557, 'p': 0.5454545454545454, 'r': 0.2608695652173913}	{'f': 0.05714285306122478, 'p': 0.1, 'r': 0.04}	{'f': 0.23529411326989624, 'p': 0.36363636363636365, 'r': 0.17391304347826086}	85	0.6531680226325989
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/CDC.c	Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.	2	"uint8_t CDC_Host_SendBreak(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo,
                           const uint8_t Duration) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SendBreak,
      .wValue = Duration,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a break signal with specified duration to a connected CDC device through USB control pipe using host-to-device communication.	1	1	0.20863970588235295	0.01076515293242854	{'f': 0.20512820013149255, 'p': 0.21052631578947367, 'r': 0.2}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15384614884944134, 'p': 0.15789473684210525, 'r': 0.15}	85	0.5064059495925903
ikeydoherty-ui-tests-41140ce/src/popover.c	Work out the geometry for the relative_to widget in absolute coordinates on the screen.	2	"static void budgie_popover_compute_widget_geometry(GtkWidget *parent_widget,
                                                   GdkRectangle *target) {
  GtkAllocation alloc = {0};
  GtkWidget *toplevel = NULL;
  GdkWindow *toplevel_window = NULL;
  gint rx, ry = 0;
  gint x, y = 0;

  if (!parent_widget) {
    g_warning(""compute_widget_geometry(): missing relative_widget"");
    return;
  }

  toplevel = gtk_widget_get_toplevel(parent_widget);
  toplevel_window = gtk_widget_get_window(toplevel);
  gdk_window_get_position(toplevel_window, &x, &y);
  gtk_widget_translate_coordinates(parent_widget, toplevel, x, y, &rx, &ry);
  gtk_widget_get_allocation(parent_widget, &alloc);

  *target = (GdkRectangle){
      .x = rx, .y = ry, .width = alloc.width, .height = alloc.height};
}"	claude-3-5-sonnet-20241022	This function calculates and sets the position and size of a popup window (popover) relative to its parent widget in GTK by translating coordinates and retrieving allocations.	1	1	0.24313725490196078	0.017554679594930896	{'f': 0.21621621183345519, 'p': 0.3333333333333333, 'r': 0.16}	{'f': 0.05128204683760723, 'p': 0.07692307692307693, 'r': 0.038461538461538464}	{'f': 0.21621621183345519, 'p': 0.3333333333333333, 'r': 0.16}	75	0.48256218433380127
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/hash-map-impl.c	Builds a new hash table for the given hash map. A call to ava_hash_map_vacuum() is implied.	2	"static size_t ava_hash_map_rehash(ava_hash_map *restrict map,
                                  size_t num_elements, ava_bool permit_ascii9) {
  size_t i, orig_num_elements;
  size_t new_size AVA_UNUSED;
  ava_list_value keys;
  ava_hash_map_hash_function preferred_hash_function;
  ava_bool vacuumed;
  const ava_hash_map_index *restrict old_index = map->index;

  orig_num_elements = num_elements;
  num_elements = ava_hash_map_vacuum(map, num_elements);
  vacuumed = orig_num_elements != num_elements;

  keys = (ava_list_value){ava_value_with_ulong(map->keys, num_elements)};

  if (NULL != map->index || num_elements > ASCII9_SIZE_THRESH) {
    preferred_hash_function = map->index->hash_function;
  } else {
    preferred_hash_function = ava_hmhf_ascii9;
    for (i = 0; i < num_elements && preferred_hash_function != ava_hmhf_value;
         ++i) {
      if (!is_ascii9_string(map->esba_trait->index(keys, i))) {
        preferred_hash_function = ava_hmhf_value;
      }
    }
  }

  map->index = ava_hash_map_index_new(desired_capacity(num_elements));
  map->index->num_elements = 0;
  map->index->hash_function =
      permit_ascii9 ? preferred_hash_function : ava_hmhf_value;
  memset(map->index->indices, -1, sizeof(TYPE) * (map->index->mask + 1));

  if (old_index && !vacuumed &&
      map->index->hash_function == old_index->hash_function) {

    for (i = 0; i < num_elements; ++i) {
      map->index->hash_cache[i] = old_index->hash_cache[i];
      ava_hash_map_put_direct(map, i, old_index->hash_cache[i]);
    }
    map->index->num_elements = num_elements;
  } else {
    for (i = 0; i < num_elements; ++i) {
      new_size = ava_hash_map_put(map, i, map->esba_trait->index(keys, i));
      assert(i + 1 == new_size);
      ++map->index->num_elements;
    }
  }

  return num_elements;
}"	claude-3-5-sonnet-20241022	The function rehashes a hash map by creating a new index structure, either preserving the existing hash function or selecting a new one based on the data, and then rebuilds the map's internal structure.	1	1	0.19662921348314608	0.018120458368871713	{'f': 0.2439024343842951, 'p': 0.3333333333333333, 'r': 0.19230769230769232}	{'f': 0.08510637863286577, 'p': 0.13333333333333333, 'r': 0.0625}	{'f': 0.19512194657941712, 'p': 0.26666666666666666, 'r': 0.15384615384615385}	None_output	0.5611799955368042
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer.	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function reads a specified number of data blocks from a USB mass storage device at a given block address and stores the data in a buffer while handling any potential errors.	1	1	0.32059314954051793	0.043179000236065884	{'f': 0.35294117151864673, 'p': 0.391304347826087, 'r': 0.32142857142857145}	{'f': 0.10714285220025532, 'p': 0.12, 'r': 0.0967741935483871}	{'f': 0.23529411269511738, 'p': 0.2608695652173913, 'r': 0.21428571428571427}	None_output	0.5220605134963989
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_rate_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  uint32_t *clock_rate;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int error_code;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_rate_get, clock_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
        clock_protocol_data.num_clocks;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
          clock_id;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      clock_rate =
          &(received.payload[OFFSET_RET(struct arm_scmi_clock_rate_get, rate)]);
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.lower,
          clock_rate[0], ""CLOCK RATE LOWER"");
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.upper,
          clock_rate[1], ""CLOCK RATE UPPER"");
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests the SCMI clock rate retrieval functionality by checking if the correct clock rates are returned for valid clock IDs and handling invalid cases.	1	1	0.2184466019417476	0.02101654884156187	{'f': 0.2926829219036289, 'p': 0.3333333333333333, 'r': 0.2608695652173913}	{'f': 0.04545454054752119, 'p': 0.05263157894736842, 'r': 0.04}	{'f': 0.24390243409875084, 'p': 0.2777777777777778, 'r': 0.21739130434782608}	45	0.6753137707710266
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/maps.c	Create a new definite map	2	"cbor_item_t *cbor_new_definite_map(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = size,
                                    .type = _CBOR_METADATA_DEFINITE,
                                    .end_ptr = 0}},
      .data = _cbor_alloc_multiple(sizeof(struct cbor_pair), size)};
  if (item->data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }
  return item;
}"	claude-3-5-sonnet-20241022	This function creates a new CBOR map item with a specified size, allocating memory for both the item structure and its pairs, while setting initial metadata and reference count.	1	1	0.2702702702702703	0.0151463165231073	{'f': 0.19354838439125913, 'p': 0.6, 'r': 0.11538461538461539}	{'f': 0.062499997812500076, 'p': 0.25, 'r': 0.03571428571428571}	{'f': 0.19354838439125913, 'p': 0.6, 'r': 0.11538461538461539}	75	0.3132503628730774
PJK-libcbor-87f977e/src/cbor/arrays.c	Create new indefinite array	2	"cbor_item_t *cbor_new_indefinite_array() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                      .allocated = 0,
                                      .end_ptr = 0}},
      .data = NULL};
  return item;
}"	claude-3-5-sonnet-20241022	This function creates and returns a new empty CBOR array item with indefinite length, initializing its metadata and setting its reference count to 1.	1	1	0.33333333333333337	0.01041441909198652	{'f': 0.23076922816568046, 'p': 0.75, 'r': 0.13636363636363635}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1538461512426036, 'p': 0.5, 'r': 0.09090909090909091}	85	0.5163218975067139
freeciv-freeciv-e4ead30/client/gui-sdl2/plrdlg.c	Popup (or raise) the player list dialog.	2	"void popup_players_dialog(bool raise) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL, *pZoomed = NULL;
  utf8_str *pstr;
  SDL_Rect dst;
  int i, n, h;
  double a, b, r;
  SDL_Rect area;

  if (pPlayers_Dlg) {
    return;
  }

  n = 0;
  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }
    n++;
  }
  players_iterate_end;

  if (n < 2) {
    return;
  }

  pPlayers_Dlg = fc_calloc(1, sizeof(struct SMALL_DLG));

  pstr = create_utf8_from_char(Q_(""?header:Players""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = players_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_WINDOW, pWindow);
  pPlayers_Dlg->pEndWidgetList = pWindow;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  pBuf->action = exit_players_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_BUTTON, pBuf);

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_NEUTRAL_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_neutral_status_callback;
      pBuf->key = SDLK_n;
      break;
    case DS_WAR:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_WAR_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_war_status_callback;
      pBuf->key = SDLK_w;
      break;
    case DS_CEASEFIRE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_CEASEFIRE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_ceasefire_status_callback;
      pBuf->key = SDLK_c;
      break;
    case DS_PEACE:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_PEACE_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_peace_status_callback;
      pBuf->key = SDLK_p;
      break;
    case DS_ALLIANCE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_ALLIANCE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_alliance_status_callback;
      pBuf->key = SDLK_a;
      break;
    default:

      continue;
      break;
    }
    set_wstate(pBuf, FC_WS_NORMAL);
    add_to_gui_list(ID_CHECKBOX, pBuf);
  }

  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

    pLogo = get_nation_flag_surface(nation_of_player(pPlayer));
    {

      double zoom = DEFAULT_ZOOM * (60.0 - n) / pLogo->h;

      pZoomed = zoomSurface(pLogo, zoom, zoom, 1);
    }

    pBuf = create_icon2(pZoomed, pWindow->dst,
                        WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                            WF_FREE_THEME);
    pBuf->info_label = pstr;

    if (!pPlayer->is_alive) {
      pstr = create_utf8_from_char(_(""R.I.P.""), adj_font(10));
      pstr->style |= TTF_STYLE_BOLD;
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_TEXT);
      pLogo = create_text_surf_from_utf8(pstr);
      FREEUTF8STR(pstr);

      dst.x = (pZoomed->w - pLogo->w) / 2;
      dst.y = (pZoomed->h - pLogo->h) / 2;
      alphablit(pLogo, NULL, pZoomed, &dst, 255);
      FREESURFACE(pLogo);
    }

    if (pPlayer->is_alive) {
      set_wstate(pBuf, FC_WS_NORMAL);
    }

    pBuf->data.player = pPlayer;

    pBuf->action = player_callback;

    add_to_gui_list(ID_LABEL, pBuf);
  }
  players_iterate_end;

  pPlayers_Dlg->pBeginWidgetList = pBuf;

  resize_window(pWindow, NULL, NULL, adj_size(500), adj_size(400));

  area = pWindow->area;

  r = MIN(area.w, area.h);
  r -= ((MAX(pBuf->size.w, pBuf->size.h) * 2));
  r /= 2;
  a = (2.0 * M_PI) / n;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  n = area.y;
  pstr = create_utf8_str(NULL, 0, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ARMISTICE);
      break;
    case DS_WAR:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_WAR);
      break;
    case DS_CEASEFIRE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_CEASEFIRE);
      break;
    case DS_PEACE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_PEACE);
      break;
    case DS_ALLIANCE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ALLIANCE);
      break;
    default:

      continue;
      break;
    }

    copy_chars_to_utf8_str(pstr, diplstate_type_translated_name(i));
    pLogo = create_text_surf_from_utf8(pstr);

    pBuf = pBuf->prev;
    h = MAX(pBuf->size.h, pLogo->h);
    pBuf->size.x = area.x + adj_size(5);
    pBuf->size.y = n + (h - pBuf->size.h) / 2;

    dst.x = adj_size(5) + pBuf->size.w + adj_size(6);
    dst.y = n + (h - pLogo->h) / 2;
    alphablit(pLogo, NULL, pWindow->theme, &dst, 255);
    n += h;
    FREESURFACE(pLogo);
  }
  FREEUTF8STR(pstr);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 - pBuf->size.w / 2;
  pBuf->size.y = area.y + area.h / 2 - r - pBuf->size.h / 2;

  n = 1;
  if (pBuf != pPlayers_Dlg->pBeginWidgetList) {
    do {
      pBuf = pBuf->prev;
      b = M_PI_2 + n * a;
      pBuf->size.x = area.x + area.w / 2 - r * cos(b) - pBuf->size.w / 2;
      pBuf->size.y = area.y + area.h / 2 - r * sin(b) - pBuf->size.h / 2;
      n++;
    } while (pBuf != pPlayers_Dlg->pBeginWidgetList);
  }

  players_dialog_update();
}"	claude-3-5-sonnet-20241022	This function creates and displays a dialog window showing player information in a circular arrangement, including nation flags, diplomatic status checkboxes, and player relationships in a multiplayer game environment.	1	1	0.10869565217391305	0.007696339439306161	{'f': 0.12903225456815828, 'p': 0.2857142857142857, 'r': 0.08333333333333333}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0645161255359003, 'p': 0.14285714285714285, 'r': 0.041666666666666664}	30	0.37614282965660095
darktable-org-darktable-32fab21/src/iop/borders.c	this is the chance to update default parameters, after the full raw is loaded.	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_borders_params_t tmp =
      (dt_iop_borders_params_t){{1.0f, 1.0f, 1.0f},
                                DT_IOP_BORDERS_ASPECT_CONSTANT_VALUE,
                                ""constant border"",
                                0,
                                0.1f,
                                0.5f,
                                ""1/2"",
                                0.5f,
                                ""1/2"",
                                0.0f,
                                0.5f,
                                {0.0f, 0.0f, 0.0f},
                                TRUE};
  memcpy(self->params, &tmp, sizeof(dt_iop_borders_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_borders_params_t));
  self->default_enabled = 0;
}"	claude-3-5-sonnet-20241022	This function resets the border parameters of an image processing module to their default values by copying predefined settings into both the current and default parameter structures.	1	1	0.19607843137254904	0.010438074937942448	{'f': 0.21621621183345519, 'p': 0.3333333333333333, 'r': 0.16}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.16216215777940113, 'p': 0.25, 'r': 0.12}	20	0.46287471055984497
xipengwang-FLAG-cd1815e/april2/src/vx/vxo_sphere.c	In this implementation, the only data passed to the shader are the texture coordinates. These texture coordinates can be trivially converted into latitude and longitude, but are adjusted so that the triangles render textures properly across the longitude=PI boundary. The shader computes lat/lon from the shader coordinates, then computes xyz.	2	"vx_object_t *vxo_sphere_textured(vx_resource_t *texture_resource) {
  static vx_resource_t *program_resource = NULL;
  static vx_resource_t *sts_resource = NULL;
  static vx_resource_t *tris_resource = NULL;
  static int nvertices = 0, napositions = 0;

  vx_lock();

  if (program_resource == NULL) {

    zarray_t *vertex_datas = zarray_create(sizeof(struct vertex_data));
    zarray_t *tris = zarray_create(sizeof(uint16_t[3]));

    const double v = sqrt(3) / 3;
    double *xyza = (double[]){v, v, v};
    double *xyzb = (double[]){-v, -v, v};
    double *xyzc = (double[]){-v, v, -v};
    double *xyzd = (double[]){v, -v, -v};

    int depth = 4;

    recurse(vertex_datas, tris, xyza, xyzc, xyzb, depth);
    recurse(vertex_datas, tris, xyza, xyzb, xyzd, depth);
    recurse(vertex_datas, tris, xyza, xyzd, xyzc, depth);
    recurse(vertex_datas, tris, xyzb, xyzc, xyzd, depth);

    zarray_t *sts = zarray_create(sizeof(float[2]));

    for (int i = 0; i < zarray_size(vertex_datas); i++) {
      struct vertex_data *vd;
      zarray_get_volatile(vertex_datas, i, &vd);

      float *st = (float[]){vd->st[0], vd->st[1]};

      zarray_add(sts, st);
    }

    nvertices = zarray_size(tris) * 3;

    char vertex_shader_src[] =
        ""#define PI 3.14159265358979323846264338\n""
        ""attribute vec2 st; \n""
        ""varying vec2 vtexcoord; \n""
        ""uniform mat4 VX_P;\n""
        ""uniform mat4 VX_V;\n""
        ""uniform mat4 VX_M;\n""
        ""void main(void) {\n""
        ""  float lat = (PI / 2.0) - PI * st.y; \n ""
        ""  float lon = 2.0 * PI * st.x; \n ""
        ""  vtexcoord = st.xy; \n""
        ""  float r = cos(lat); \n ""
        ""  vec3 xyz = vec3(r*cos(lon), r*sin(lon), sin(lat)); \n ""
        ""  gl_Position = VX_P * VX_V * VX_M * vec4(xyz, 1.0);\n""
        ""}"";

    char fragment_shader_src[] = ""precision mediump float; \n""
                                 ""varying vec2 vtexcoord; \n""
                                 ""uniform sampler2D texture; \n""
                                 ""void main(void) {\n""
                                 ""  vec4 c = texture2D(texture, vtexcoord);\n""
                                 ""  gl_FragColor = vec4(c.r, c.g, c.b, 1);\n""
                                 ""}\n"";

    program_resource =
        vx_resource_make_program(vertex_shader_src, fragment_shader_src);
    program_resource->incref(program_resource);

    sts_resource = vx_resource_make_attr_f32_copy((float *)sts->data,
                                                  zarray_size(sts) * 2, 2);
    sts_resource->incref(sts_resource);

    tris_resource =
        vx_resource_make_idx_u16_copy((uint16_t *)tris->data, nvertices);
    tris_resource->incref(tris_resource);
  }

  vx_unlock();

  return vxo_generic_create(
      program_resource, (struct vxo_generic_uniformf[]){{.name = NULL}},
      (struct vxo_generic_attribute[]){{.name = ""st"", .resource = sts_resource},
                                       {.name = NULL}},
      (struct vxo_generic_texture[]){
          {.name = ""texture"", .resource = texture_resource}, {.name = NULL}},
      (struct vxo_generic_draw[]){
          {.command = VX_GL_TRIANGLES,
           .first = 0,
           .count = nvertices,
           .indices_resource = tris_resource},
          {.count = 0},
      });
}"	claude-3-5-sonnet-20241022	This function creates a textured sphere object in a 3D graphics system by generating vertices, texture coordinates, and triangle indices, then setting up shaders to render the sphere with a provided texture.	1	1	0.1452282157676349	0.00994200825682664	{'f': 0.21212120723599642, 'p': 0.18421052631578946, 'r': 0.25}	{'f': 0.025641020851414436, 'p': 0.02127659574468085, 'r': 0.03225806451612903}	{'f': 0.15151514662993587, 'p': 0.13157894736842105, 'r': 0.17857142857142858}	75	0.5428369045257568
AsydSolutions-monit-9e43388/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVh"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""id"", no_argument, NULL, 'i'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""version"", no_argument, NULL, 'V'},
                              {""help"", no_argument, NULL, 'h'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.controlfile = Str_dup(f);
      break;
    }
    case 'd': {
      Run.isdaemon = true;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.logfile = Str_dup(optarg);
      if (IS(Run.logfile, ""syslog""))
        Run.use_syslog = true;
      Run.dolog = true;
      break;
    }
    case 'p': {
      Run.pidfile = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.statefile = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.init = true;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.idfile);
      Util_monitId(Run.idfile);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"	claude-3-5-sonnet-20241022	This function processes command-line arguments and options for the Monit program, handling various parameters like configuration file path, daemon mode, logging settings, and other operational flags.	1	1	0.19553072625698323	0.010864991539917157	{'f': 0.24390243426531835, 'p': 0.3125, 'r': 0.2}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1463414586555623, 'p': 0.1875, 'r': 0.12}	85	0.35943013429641724
braice-MuMuDVB-745259a/src/sap.c	Initialize sap variables	2	"void init_sap_v(sap_p_t *sap_p) {
  *sap_p = (sap_p_t){
      .sap_messages4 = NULL,
      .sap_messages6 = NULL,
      .sap = OPTION_UNDEFINED,
      .sap_interval = SAP_DEFAULT_INTERVAL,
      .sap_sending_ip4 = ""0.0.0.0"",
      .sap_sending_ip6 = ""::"",
      .sap_default_group = """",
      .sap_organisation = ""MuMuDVB"",
      .sap_uri = ""\0"",
      .sap_ttl = SAP_DEFAULT_TTL,
  };
}"	claude-3-5-sonnet-20241022	This function initializes a SAP (Session Announcement Protocol) structure with default values, setting various parameters like messages, intervals, IP addresses, organization name, and TTL.	1	1	0.19607843137254902	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	75	0.5653496980667114
RfidResearchGroup-proxmark3-1650889/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLogEx(WARNING, ""missing addr"");
    return 0;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    req[reqlen++] = iso15cmd;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    if (!getUID(uid)) {
      PrintAndLogEx(WARNING, ""No tag found"");
      return 0;
    }
    memcpy(&req[reqlen], uid, sizeof(uid));
    PrintAndLogEx(NORMAL, ""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += sizeof(uid);
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLogEx(NORMAL, ""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], uid, sizeof(uid));
    reqlen += sizeof(uid);
    break;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"	claude-3-5-sonnet-20241022	This function prepares a command for ISO15693 communication by processing input parameters and formatting them into a request structure with options for addressing specific tags using their UIDs.	1	1	0.15337423312883433	0.016891032976324306	{'f': 0.19512194657941712, 'p': 0.26666666666666666, 'r': 0.15384615384615385}	{'f': 0.048780483307555446, 'p': 0.07142857142857142, 'r': 0.037037037037037035}	{'f': 0.09756097096966114, 'p': 0.13333333333333333, 'r': 0.07692307692307693}	None_output	0.5669865608215332
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c	Clears a stall condition on the given pipe, via a CLEAR FEATURE standard request to the attached device.	1	"uint8_t USB_Host_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_SEL_EndpointHalt,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function sends a USB control request to clear a stall condition on a specified endpoint, allowing data transfer to resume on that endpoint.	1	1	0.33938172043010756	0.12173115521158184	{'f': 0.34285713789387756, 'p': 0.375, 'r': 0.3157894736842105}	{'f': 0.1999999951125001, 'p': 0.23529411764705882, 'r': 0.17391304347826086}	{'f': 0.28571428075102046, 'p': 0.3125, 'r': 0.2631578947368421}	90	0.6254920959472656
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/pub.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){pub,
                  'p',
                  ""pub"",
                  ""extract the public key from a private key/certificate"",
                  {""[--in file|--keyid hex] [--type rsa|ecdsa|pkcs10|x509]"",
                   ""[--outform der|pem|pgp]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""keyid"", 'x', 1, ""keyid on smartcard of private key""},
                      {""type"", 't', 1, ""type of credential, default: rsa""},
                      {""outform"", 'f', 1, ""encoding of extracted public key""},
                  }});
}"	claude-3-5-sonnet-20241022	This function registers a command to extract public keys from various credential types (private keys/certificates) with specified input sources and output formats using the command_register function.	1	1	0.2830188679245283	0.008640609739997756	{'f': 0.14285714094387758, 'p': 0.6666666666666666, 'r': 0.08}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07142856951530618, 'p': 0.3333333333333333, 'r': 0.04}	None_output	0.45432931184768677
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to zero.	2	_mm256_setzero_pd(void) { return __extension__(__m256d){0, 0, 0, 0}; }	claude-3-5-sonnet-20241022	This function returns a 256-bit vector containing four double-precision floating-point zeros (0.0) using AVX intrinsics.	1	1	0.26816911250873515	0.03109754171746996	{'f': 0.26666666166666675, 'p': 0.26666666666666666, 'r': 0.26666666666666666}	{'f': 0.06896551224732497, 'p': 0.06666666666666667, 'r': 0.07142857142857142}	{'f': 0.19999999500000015, 'p': 0.2, 'r': 0.2}	95	0.739989161491394
vm6502q-qrack-df6132d/include/qinterface.hpp	"Quantum analog of classical ""XOR"" gate. Takes one qubit input and one classical bit input. Measures the outputBit, then overwrites it with result."	2	"}

virtual ~QInterface(){};

int GetQubitCount() { return qubitCount; }"	claude-3-5-sonnet-20241022	These functions define a virtual destructor for cleanup and a getter method to return the number of qubits in the quantum interface.	1	1	0.15283842794759828	0.010925297262553601	{'f': 0.14999999500000016, 'p': 0.15, 'r': 0.15}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.09999999500000027, 'p': 0.1, 'r': 0.1}	20	0.5067676901817322
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Retrieves the device sense data, indicating the current device state and error codes for the previously issued command.	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Request_Sense_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, SenseData);
}"	claude-3-5-sonnet-20241022	The function sends a REQUEST SENSE command to a USB mass storage device to retrieve error information about the last executed command and stores the response in the provided SenseData structure.	1	1	0.23316062176165805	0.009812163258584559	{'f': 0.2439024343842951, 'p': 0.3333333333333333, 'r': 0.19230769230769232}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.14634145877453913, 'p': 0.2, 'r': 0.11538461538461539}	90	0.6726872324943542
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the list parser state struct with data to be parsed.	2	"psyc_parse_list_buffer_set(PsycParseListState *state, const char *buffer,
                           size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	This function initializes a parsing state by setting a buffer and its length while resetting the cursor position to zero for parsing list-formatted data.	1	1	0.3346108490566037	0.012384901282810543	{'f': 0.3243243195032871, 'p': 0.4, 'r': 0.2727272727272727}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.21621621139517908, 'p': 0.26666666666666666, 'r': 0.18181818181818182}	75	0.5929000973701477
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the update modifier parser state struct with data to be parsed.	2	"psyc_parse_update_buffer_set(PsycParseUpdateState *state, const char *buffer,
                             size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	This function initializes a parsing state by setting a buffer with given content and length while resetting the cursor position to zero for subsequent parsing operations.	1	1	0.3129595588235294	0.011371681934875243	{'f': 0.29999999520000004, 'p': 0.375, 'r': 0.25}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1999999952000001, 'p': 0.25, 'r': 0.16666666666666666}	75	0.4684368968009949
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Construct the metric terms (and optionally the jacobian determinant) terms at the nodes of input type for the volume under consideration.	2	"static void
constructor_volume_metric_terms_T(const char node_type,
                                  struct Solver_Volume_T *const s_vol) {

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Geometry_Element *g_e =
      &((struct Solver_Element *)vol->element)->g_e;

  const int p = s_vol->p_ref;
  const bool curved = vol->curved;
  const int p_g = (curved ? p : 1);

  struct Container {
    struct Multiarray_Operator *cv1_vg_vX;
    const struct Operator *vv0_vm_vX;
    struct Multiarray_T *metrics_vX;
    struct Multiarray_T *jacobian_det_vX;
  } con;
  struct Multiarray_Operator cv1_vg_vm =
      set_MO_from_MO(g_e->cv1_vg_vm[curved], 1, (ptrdiff_t[]){0, 0, p_g, p_g});
  struct Multiarray_Operator cv1_vg_vc =
      set_MO_from_MO(g_e->cv1_vg_vc[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});
  struct Multiarray_Operator cv1_vg_vs =
      set_MO_from_MO(g_e->cv1_vg_vs[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});

  switch (node_type) {
  case 'm':
    con.cv1_vg_vX = &cv1_vg_vm;
    con.vv0_vm_vX = NULL;
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vm;
    con.jacobian_det_vX = NULL;
    break;
  case 'c':
    con.cv1_vg_vX = &cv1_vg_vc;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vc[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vc;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vc;
    break;
  case 's':
    con.cv1_vg_vX = &cv1_vg_vs;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vs[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vs;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vs;
    break;
  default:
    EXIT_ERROR(""Unsupported: %c\n"", node_type);
    break;
  }
  const ptrdiff_t n_vX = con.cv1_vg_vX->data[0]->op_std->ext_0;
  struct Multiarray_T *const jacobian_vX =
      constructor_empty_Multiarray_T('C', 3, (ptrdiff_t[]){n_vX, DIM, DIM});

  const char op_format = get_set_op_format(0);
  const struct const_Multiarray_T *const geom_coef = s_vol->geom_coef;
  for (ptrdiff_t row = 0; row < DIM; ++row)
    mm_NN1C_Operator_Multiarray_T(con.cv1_vg_vX->data[row], geom_coef,
                                  jacobian_vX, op_format, 2, NULL, &row);

  if (node_type == 'm') {
    compute_cofactors_T((struct const_Multiarray_T *)jacobian_vX,
                        con.metrics_vX);
  } else {
    assert(compute_size(s_vol->metrics_vm->order, s_vol->metrics_vm->extents) >
           0);
    const struct const_Multiarray_T *const met_vm = s_vol->metrics_vm;
    resize_Multiarray_T(con.metrics_vX, 3, (ptrdiff_t[]){n_vX, DIM, DIM});
    mm_NN1C_Operator_Multiarray_T(con.vv0_vm_vX, met_vm, con.metrics_vX,
                                  op_format, met_vm->order, NULL, NULL);
  }

  if (con.jacobian_det_vX) {
    const ptrdiff_t *const perm = set_jacobian_permutation(DIM);
    permute_Multiarray_T(jacobian_vX, perm, jacobian_vX->layout);

    compute_detJV_T((struct const_Multiarray_T *)jacobian_vX,
                    con.jacobian_det_vX);
  }
  destructor_Multiarray_T(jacobian_vX);
}"	claude-3-5-sonnet-20241022	This function computes metric terms (Jacobian, metrics, determinant) at different node types ('m', 'c', 's') for volume elements in a numerical solver using geometric operations and matrix manipulations.	1	1	0.23041474654377878	0.019427446513842185	{'f': 0.3111111064098766, 'p': 0.4117647058823529, 'r': 0.25}	{'f': 0.04255318660027218, 'p': 0.05, 'r': 0.037037037037037035}	{'f': 0.26666666196543215, 'p': 0.35294117647058826, 'r': 0.21428571428571427}	85	0.7457132339477539
freeciv-freeciv-e4ead30/client/gui-sdl2/mapview.c	Typically an info box is provided to tell the player about the state of their civilization. This function is called when the label is changed.	2	"void update_info_label(void) {
  SDL_Color bg_color = {0, 0, 0, 80};
  SDL_Surface *pTmp = NULL;
  char buffer[512];
#ifdef SMALL_SCREEN
  SDL_Rect area = {0, 0, 0, 0};
#else
  SDL_Rect area = {0, 3, 0, 0};
#endif
  struct utf8_str *ptext;

  if (get_current_client_page() != PAGE_GAME) {
    return;
  }

#ifdef SMALL_SCREEN
  ptext = create_utf8_str(NULL, 0, 8);
#else
  ptext = create_utf8_str(NULL, 0, 10);
#endif

  ptext->style |= TTF_STYLE_BOLD;
  ptext->fgcol = *get_theme_color(COLOR_THEME_MAPVIEW_INFO_TEXT);
  ptext->bgcol = (SDL_Color){0, 0, 0, 0};

  if (NULL != client.conn.playing) {
#ifdef SMALL_SCREEN
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold);
#else
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d Tax: %d Lux: %d Sci: %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold,
                client.conn.playing->economic.tax,
                client.conn.playing->economic.luxury,
                client.conn.playing->economic.science);
#endif

    copy_chars_to_utf8_str(ptext, buffer);
    pTmp = create_text_surf_from_utf8(ptext);

    area.x = (main_window_width() - pTmp->w) / 2 - adj_size(5);
    area.w = pTmp->w + adj_size(8);
    area.h = pTmp->h + adj_size(4);

    SDL_FillRect(Main.gui->surface, &area,
                 map_rgba(Main.gui->surface->format, bg_color));

    create_line(Main.gui->surface, area.x + 1, area.y, area.x + area.w - 2,
                area.y, get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x + 1, area.y + area.h - 1,
                area.x + area.w - 2, area.y + area.h - 1,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    create_line(Main.gui->surface, area.x + area.w - 1, area.y + 1,
                area.x + area.w - 1, area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x, area.y + 1, area.x,
                area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    blit_entire_src(pTmp, Main.gui->surface, area.x + adj_size(5),
                    area.y + adj_size(2));

    dirty_sdl_rect(&area);

    FREESURFACE(pTmp);
  }

  set_indicator_icons(client_research_sprite(), client_warming_sprite(),
                      client_cooling_sprite(), client_government_sprite());

  update_timeout_label();

  FREEUTF8STR(ptext);

  queue_flush();
}"	claude-3-5-sonnet-20241022	This function updates and displays game information (like population, year, gold, etc.) along with various indicator icons in a labeled area at the top of the game screen interface.	1	1	0.16786964129483814	0.017209538164201187	{'f': 0.1666666617447918, 'p': 0.19047619047619047, 'r': 0.14814814814814814}	{'f': 0.038461533491124904, 'p': 0.041666666666666664, 'r': 0.03571428571428571}	{'f': 0.08333332841145863, 'p': 0.09523809523809523, 'r': 0.07407407407407407}	75	0.6058955788612366
darktable-org-darktable-32fab21/src/iop/lowpass.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""local contrast mask""), self->op, self->version(),
      &(dt_iop_lowpass_params_t){0, 50.0f, -1.0f, 0.0f, 0.0f,
                                 LOWPASS_ALGO_GAUSSIAN, 1},
      sizeof(dt_iop_lowpass_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	"This function initializes a preset called ""local contrast mask"" for the lowpass module in Darktable, storing its parameters in the database within a transaction."	1	1	0.1977401129943503	0.011191021613657745	{'f': 0.21621621130752386, 'p': 0.25, 'r': 0.19047619047619047}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.16216215725346983, 'p': 0.1875, 'r': 0.14285714285714285}	70	0.35611021518707275
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance limits set command and testing the received values.	3	"void arm_scmi_custom_test_performance_limits_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 3;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_max)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MAX - 1];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_min)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MIN + 1];
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_max)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX] + 1;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_min)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN] - 1;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX - 1];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN + 1];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_SUCCESS
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        ptr_data->domain_runtime_values[domain_id].range_min =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_min)];
        ptr_data->domain_runtime_values[domain_id].range_max =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_max)];
      }
    }
  }
}"	claude-3-5-sonnet-20241022	This function tests performance limit settings for different domains by validating domain IDs and range values, while handling invalid parameters and updating runtime values when successful.	1	1	0.33411242958168524	0.010864991539917157	{'f': 0.23809523319727902, 'p': 0.2777777777777778, 'r': 0.20833333333333334}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.19047618557823143, 'p': 0.2222222222222222, 'r': 0.16666666666666666}	75	0.6597990393638611
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host.	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t));

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;

      FrameIN.FrameInBuffer = true;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t));

      Endpoint_Write_Stream_LE(FrameOUT.FrameData,
                               RNDISPacketHeader.DataLength);

      Endpoint_ClearIN();

      FrameOUT.FrameInBuffer = false;
    }
  }
}"	claude-3-5-sonnet-20241022	This function handles RNDIS (Remote Network Driver Interface Specification) communication tasks, managing data packets between a USB device and host through endpoint transfers and message processing.	1	1	0.09453781512605042	0.0046954172090601055	{'f': 0.2068965468192629, 'p': 0.18181818181818182, 'r': 0.24}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.10344827095719404, 'p': 0.09090909090909091, 'r': 0.12}	85	0.6092077493667603
dm-vdo-kvdo-8df6805/vdo/base/slab.c	Measure and initialize the configuration to use for each slab.	2	"int configureSlab(BlockCount slabSize, BlockCount slabJournalBlocks,
                  SlabConfig *slabConfig) {
  if (slabJournalBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount refBlocks =
      getSavedReferenceCountSize(slabSize - slabJournalBlocks);
  BlockCount metaBlocks = (refBlocks + slabJournalBlocks);

  if (metaBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount dataBlocks = slabSize - metaBlocks;
  if ((slabSize < 1024) && !isPowerOfTwo(dataBlocks)) {
    dataBlocks = ((BlockCount)1 << logBaseTwo(dataBlocks));
  }

  BlockCount flushingThreshold = ((slabJournalBlocks * 3) + 3) / 4;

  BlockCount remaining = slabJournalBlocks - flushingThreshold;
  BlockCount blockingThreshold = flushingThreshold + ((remaining * 5) / 7);

  BlockCount minimalExtraSpace =
      1 + (MAXIMUM_USER_VIOS / SLAB_JOURNAL_FULL_ENTRIES_PER_BLOCK);
  BlockCount scrubbingThreshold = blockingThreshold;
  if (slabJournalBlocks > minimalExtraSpace) {
    scrubbingThreshold = slabJournalBlocks - minimalExtraSpace;
  }
  if (blockingThreshold > scrubbingThreshold) {
    blockingThreshold = scrubbingThreshold;
  }

  *slabConfig =
      (SlabConfig){.slabBlocks = slabSize,
                   .dataBlocks = dataBlocks,
                   .referenceCountBlocks = refBlocks,
                   .slabJournalBlocks = slabJournalBlocks,
                   .slabJournalFlushingThreshold = flushingThreshold,
                   .slabJournalBlockingThreshold = blockingThreshold,
                   .slabJournalScrubbingThreshold = scrubbingThreshold};
  return VDO_SUCCESS;
}"	claude-3-5-sonnet-20241022	This function configures a VDO slab by calculating various thresholds and block allocations based on input parameters, then stores the configuration in a SlabConfig structure.	1	1	0.3234782608695652	0.019051955393615476	{'f': 0.23529411349480975, 'p': 0.4, 'r': 0.16666666666666666}	{'f': 0.06060605663911872, 'p': 0.1111111111111111, 'r': 0.041666666666666664}	{'f': 0.17647058408304508, 'p': 0.3, 'r': 0.125}	65	0.626319408416748
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	Paint menubar.	2	"virtual ~Font(){};

virtual int getHeight() const = 0;

virtual int getAscent() const = 0;

template <typename STR>
int getWidth(const STR s, Size start = 0, Size len = (Size)-1) const {
  return this->getWidth(String(s), start, len);
}

virtual int getWidth(Char c = 'M') const = 0;

virtual int getWidth(const String &s, Size start = 0,
                     Size len = (Size)-1) const {
  int width = 0;
  if (start + len > s.size())
    len = (Size)(s.size() - start);
  while (len--)
    width += getWidth(s[start++]);
  return width;
}"	claude-3-5-sonnet-20241022	This code defines a virtual Font class interface with methods to calculate font metrics like height, ascent, and width for both individual characters and strings.	1	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.03709537163376808
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	Retrieves the current alternative setting for the specified interface, via a GET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_GetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        uint8_t *const AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetInterface,
      .wValue = 0,
      .wIndex = InterfaceIndex,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(AltSetting);
}"	claude-3-5-sonnet-20241022	This function retrieves the current alternate setting value for a specified USB interface by sending a Get Interface control request to the connected USB device.	1	1	0.6826530612244897	0.057418658700625666	{'f': 0.5128205079026957, 'p': 0.5882352941176471, 'r': 0.45454545454545453}	{'f': 0.14285713795918387, 'p': 0.16666666666666666, 'r': 0.125}	{'f': 0.5128205079026957, 'p': 0.5882352941176471, 'r': 0.45454545454545453}	95	0.7463271617889404
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = CPU_TO_LE16(0),
      .wIndex = CPU_TO_LE16(0),
      .wLength = CPU_TO_LE16(
          sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost)),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	This function sends control line state changes from a USB CDC device to the host through the notification endpoint, updating the host about changes in control signals like carrier detect or ring indicator.	1	1	0.18241139473118506	0.01499524744282278	{'f': 0.2597402551121606, 'p': 0.20408163265306123, 'r': 0.35714285714285715}	{'f': 0.04301074824372805, 'p': 0.03225806451612903, 'r': 0.06451612903225806}	{'f': 0.12987012524203084, 'p': 0.10204081632653061, 'r': 0.17857142857142858}	95	0.7563502192497253
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/verify.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      verify,
      'v',
      ""verify"",
      ""verify a certificate using the CA certificate"",
      {""[--in file] [--ca file]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""X.509 certificate to verify, default: stdin""},
          {""cacert"", 'c', 1, ""CA certificate, default: verify self signed""},
      }});
}"	claude-3-5-sonnet-20241022	The function registers a command that verifies X.509 certificates using a CA certificate, with options for input file, CA certificate, and help information.	1	1	0.30000000000000004	0.008282282660969604	{'f': 0.0869565194706995, 'p': 0.3333333333333333, 'r': 0.05}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0869565194706995, 'p': 0.3333333333333333, 'r': 0.05}	30	0.43521416187286377
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float2() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_16}}};
  return item;
}"	claude-3-5-sonnet-20241022	This function creates and returns a new CBOR float item with 16-bit precision (half-precision), allocating memory for the item structure and its data storage.	1	1	0.3777939747327502	0.02898497051727735	{'f': 0.2777777730246914, 'p': 0.35714285714285715, 'r': 0.22727272727272727}	{'f': 0.16216215745799867, 'p': 0.21428571428571427, 'r': 0.13043478260869565}	{'f': 0.2777777730246914, 'p': 0.35714285714285715, 'r': 0.22727272727272727}	75	0.421836793422699
phase4ground-joco-2018-badge-782fd35/firmware/manbearpig/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    mbp_tooth_eye_stop();
    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
  mbp_tooth_eye_start();
}"	claude-3-5-sonnet-20241022	"This function allows users to select and play LED animations from RGB files stored in the ""BLING"" directory, displaying them on a menu interface while managing memory and timer resources."	1	1	0.0819672131147541	0.006244385951234721	{'f': 0.04761904334467159, 'p': 0.07692307692307693, 'r': 0.034482758620689655}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.04761904334467159, 'p': 0.07692307692307693, 'r': 0.034482758620689655}	45	0.4159696102142334
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	The firmware version is the SHA256 hash.	1	"arm_uc_error_t ARM_UC_ControlCenter_ReportVersion(uint64_t version) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportVersion: %"" PRIu64, version);

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct) {
    arm_uc_monitor_struct->SendVersion(version);
    result.code = ERR_NONE;
  }

  return result;
}"	claude-3-5-sonnet-20241022	This function reports the firmware version to a monitor structure and returns an error code indicating success or failure of the operation.	1	1	0.4411764705882353	0.020331710659744474	{'f': 0.21428571053571432, 'p': 0.42857142857142855, 'r': 0.14285714285714285}	{'f': 0.07407407061728412, 'p': 0.16666666666666666, 'r': 0.047619047619047616}	{'f': 0.21428571053571432, 'p': 0.42857142857142855, 'r': 0.14285714285714285}	20	0.5749050974845886
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	This function retrieves the maximum Logical Unit Number (LUN) from a USB mass storage device through a control request, returning 0 if the device stalls the request.	1	1	0.36979644934190387	0.020876149875884896	{'f': 0.2926829218560381, 'p': 0.3157894736842105, 'r': 0.2727272727272727}	{'f': 0.043478255954631936, 'p': 0.05, 'r': 0.038461538461538464}	{'f': 0.1951219462462821, 'p': 0.21052631578947367, 'r': 0.18181818181818182}	85	0.5623413920402527
boazsegev-iodine-b6bdf50/ext/iodine/http1.c	Creates an HTTP1 protocol object and handles any unread data in the buffer (if any).	2	"fio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,
                          void *unread_data, size_t unread_length) {
  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)
    return NULL;
  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);

  FIO_ASSERT_ALLOC(p);
  *p = (http1pr_s){
      .p.protocol =
          {
              .on_data = http1_on_data_first_time,
              .on_close = http1_on_close,
              .on_ready = http1_on_ready,
          },
      .p.uuid = uuid,
      .p.settings = settings,
      .max_header_size = settings->max_header_size,
      .is_client = settings->is_client,
  };
  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    memcpy(p->buf, unread_data, unread_length);
    p->buf_len = unread_length;
  }
  fio_attach(uuid, &p->p.protocol);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  return &p->p.protocol;
}"	claude-3-5-sonnet-20241022	The function initializes and returns a new HTTP/1.x protocol handler, setting up necessary structures and configurations for processing HTTP requests and responses.	1	1	0.09554140127388534	0.010331208012220438	{'f': 0.11764705397923896, 'p': 0.14285714285714285, 'r': 0.1}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.11764705397923896, 'p': 0.14285714285714285, 'r': 0.1}	85	0.6389769315719604
Decawave-mynewt-dw1000-apps-be5c28a/apps/listener/src/bleprph.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"bleprph_advertise(void) {
  uint8_t own_addr_type;
  struct ble_gap_adv_params adv_params;
  struct ble_hs_adv_fields fields;
  const char *name;
  int rc;

  rc = ble_hs_id_infer_auto(0, &own_addr_type);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error determining address type; rc=%d\n"", rc);
    return;
  }

  memset(&fields, 0, sizeof fields);

  fields.flags = BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP;

  fields.tx_pwr_lvl_is_present = 1;
  fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

  name = ble_svc_gap_device_name();
  fields.name = (uint8_t *)name;
  fields.name_len = strlen(name);
  fields.name_is_complete = 1;

  fields.uuids16 = (ble_uuid16_t[]){BLE_UUID16_INIT(GATT_SVR_SVC_ALERT_UUID)};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  memset(&adv_params, 0, sizeof adv_params);
  adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
  adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
  rc = ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params,
                         bleprph_gap_event, NULL);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"	claude-3-5-sonnet-20241022	This function configures and starts BLE advertising with specified parameters such as device name, flags, power level, and service UUIDs, allowing the device to be discovered by other BLE devices.	1	1	0.2733262108262108	0.015703799285850036	{'f': 0.2051282008678502, 'p': 0.3333333333333333, 'r': 0.14814814814814814}	{'f': 0.04761904334467159, 'p': 0.07692307692307693, 'r': 0.034482758620689655}	{'f': 0.15384614958579892, 'p': 0.25, 'r': 0.1111111111111111}	75	0.5070207118988037
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabKey request. Creates a grab for the client's keyboard and adds it to the list of passive grabs.	2	"ProcGrabKey(ClientPtr client) {
  WindowPtr pWin;

  REQUEST(xGrabKeyReq);
  GrabPtr grab;
  DeviceIntPtr keybd = PickKeyboard(client);
  int rc;
  GrabParameters param;
  GrabMask mask;

  REQUEST_SIZE_MATCH(xGrabKeyReq);

  param = (GrabParameters){.grabtype = CORE,
                           .ownerEvents = stuff->ownerEvents,
                           .this_device_mode = stuff->keyboardMode,
                           .other_devices_mode = stuff->pointerMode,
                           .modifiers = stuff->modifiers};

  rc = CheckGrabValues(client, &param);
  if (rc != Success)
    return rc;

  if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
       (stuff->key < keybd->key->xkbInfo->desc->min_key_code)) &&
      (stuff->key != AnyKey)) {
    client->errorValue = stuff->key;
    return BadValue;
  }
  rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
  if (rc != Success)
    return rc;

  mask.core = (KeyPressMask | KeyReleaseMask);

  grab = CreateGrab(client->index, keybd, keybd, pWin, CORE, &mask, &param,
                    KeyPress, stuff->key, NullWindow, NullCursor);
  if (!grab)
    return BadAlloc;
  return AddPassiveGrabToList(client, grab);
}"	claude-3-5-sonnet-20241022	The ProcGrabKey function handles key grab requests from clients by creating and registering a passive key grab on a specified window with given parameters and modifiers.	1	1	0.22321428571428567	0.010864991539917157	{'f': 0.23809523310657604, 'p': 0.25, 'r': 0.22727272727272727}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1904761854875285, 'p': 0.2, 'r': 0.18181818181818182}	85	0.6200530529022217
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/AndroidAccessoryClassHost.c	Starts Accessory Mode in the attached Android device. This function will validate the device's Android Open Accessory protocol version, send the configured property strings, and request a switch to Android Open Accessory mode.	1	"uint8_t
AOA_Host_StartAccessoryMode(USB_ClassInfo_AOA_Host_t *const AOAInterfaceInfo) {
  uint8_t ErrorCode;

  uint16_t AccessoryProtocol;
  if ((ErrorCode = AOA_Host_GetAccessoryProtocol(&AccessoryProtocol)) !=
      HOST_WAITERROR_Successful)
    return ErrorCode;

  if (AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV1))
    return AOA_ERROR_LOGICAL_CMD_FAILED;

  for (uint8_t PropertyIndex = 0; PropertyIndex < AOA_STRING_TOTAL_STRINGS;
       PropertyIndex++) {
    if ((ErrorCode = AOA_Host_SendPropertyString(
             AOAInterfaceInfo, PropertyIndex)) != HOST_WAITERROR_Successful)
      return ErrorCode;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE),
      .bRequest = AOA_REQ_StartAccessoryMode,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	The function configures and initiates Android Open Accessory (AOA) mode on a connected USB device by verifying protocol compatibility, sending property strings, and triggering accessory mode activation.	1	1	0.38966049382716045	0.054136315255988256	{'f': 0.4313725440215302, 'p': 0.4230769230769231, 'r': 0.44}	{'f': 0.14285713788265325, 'p': 0.13333333333333333, 'r': 0.15384615384615385}	{'f': 0.35294117147251064, 'p': 0.34615384615384615, 'r': 0.36}	95	0.8094021081924438
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	_mm_set1_epi64(__m64 __q) { return (__m128i){(long long)__q, (long long)__q}; }	claude-3-5-sonnet-20241022	This function creates a 128-bit vector by duplicating a 64-bit value into both the lower and upper halves of the vector.	1	1	0.17006802721088438	0.013659149296955463	{'f': 0.2580645112591052, 'p': 0.3076923076923077, 'r': 0.2222222222222222}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.19354838222684714, 'p': 0.23076923076923078, 'r': 0.16666666666666666}	10	0.2891126871109009
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/fifo.c	Move data pointers and pts offset samples forward.	2	"static void buffer_offset(AVFilterLink *link, AVFrame *frame, int offset) {
  int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
  int planar = av_sample_fmt_is_planar(link->format);
  int planes = planar ? nb_channels : 1;
  int block_align =
      av_get_bytes_per_sample(link->format) * (planar ? 1 : nb_channels);
  int i;

  av_assert0(frame->nb_samples > offset);

  for (i = 0; i < planes; i++)
    frame->extended_data[i] += block_align * offset;
  if (frame->data != frame->extended_data)
    memcpy(frame->data, frame->extended_data,
           FFMIN(planes, FF_ARRAY_ELEMS(frame->data)) * sizeof(*frame->data));
  frame->linesize[0] -= block_align * offset;
  frame->nb_samples -= offset;

  if (frame->pts != AV_NOPTS_VALUE) {
    frame->pts += av_rescale_q(offset, (AVRational){1, link->sample_rate},
                               link->time_base);
  }
}"	claude-3-5-sonnet-20241022	The function adjusts audio frame data by moving the starting point forward by a specified offset while updating sample count, timestamps, and memory pointers accordingly.	1	1	0.36082474226804123	0.011328360454400999	{'f': 0.31249999625, 'p': 0.625, 'r': 0.20833333333333334}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.12499999625000012, 'p': 0.25, 'r': 0.08333333333333333}	75	0.49577218294143677
vasyutin-qnetmap-3e0b0a1/lib/src/qnetmap_label.h	draw the geometry	2	"virtual ~TLabel(){};

virtual void drawGeometry(QPainter *Painter_, const QRect &Viewport_,
                          const QPoint Offset_ = QPoint());

virtual const QString &text(void) const { return m_Text; }

virtual void setText(QString &Text_) {
  m_Text = Text_;
  calculateBoundingBox();
}"	claude-3-5-sonnet-20241022	These functions define a virtual destructor and essential methods for a label class, handling text manipulation and geometric rendering with inheritance support.	1	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	50	0.25038138031959534
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/integration/test_integration.c	Adapt the initial mesh if a adaptation parameters are provided in the input file.	2	"void adapt_initial_mesh_if_required(struct Simulation *const sim) {
  const int *count_to_find = (int[]){2, 3};
  int count_found = 0;

  struct Adaptation_Data adapt_data = {
      .adapt_h =
          {
              0,
              0,
          },
      .xyz_ve_refine = NULL,
      .xyz_ve_ml = NULL,
      .xyz_ve_p = NULL,
  };

  char line[STRLEN_MAX];
  FILE *input_file = fopen_input('t', NULL, NULL);
  while (fgets(line, sizeof(line), input_file)) {
    read_skip_name_i(""n_adapt_h_refine"", line, &adapt_data.adapt_h[0]);
    if (strstr(line, ""xyz_ve_refine"")) {
      ++count_found;
      adapt_data.xyz_ve_refine =
          constructor_file_const_Multiarray_d(input_file, true);
    }
    if (strstr(line, ""xyz_ve_mesh_level"")) {
      ++count_found;
      adapt_data.xyz_ve_ml = constructor_file_const_Vector_i(input_file, true);
    }
    if (strstr(line, ""xyz_ve_polynomial_order"")) {
      ++count_found;
      adapt_data.xyz_ve_p = constructor_file_const_Vector_i(input_file, true);
    }
  }
  fclose(input_file);

  if (adapt_data.xyz_ve_refine == NULL) {
    assert(adapt_data.xyz_ve_ml == NULL || adapt_data.xyz_ve_p == NULL);
    return;
  }

  if (count_found < count_to_find[0] || count_found > count_to_find[1])
    EXIT_ERROR(
        ""Did not find the required number of variables (Found: %d/[%d,%d]).\n"",
        count_found, count_to_find[0], count_to_find[1]);

  adapt_hp(sim, ADAPT_S_XYZ_VE, &adapt_data);
  for (int i = 0; i < adapt_data.adapt_h[0]; ++i)
    adapt_hp(sim, ADAPT_S_H_REFINE, NULL);
  for (int i = 0; i < adapt_data.adapt_h[1]; ++i)
    adapt_hp(sim, ADAPT_S_H_COARSE, NULL);

  destructor_const_Multiarray_d(adapt_data.xyz_ve_refine);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_ml);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_p);
}"	claude-3-5-sonnet-20241022	This function reads mesh adaptation parameters from an input file and applies adaptive refinement or coarsening to the simulation mesh based on specified criteria and vertex coordinates.	1	1	0.37414965986394555	0.023103257620595924	{'f': 0.3157894691828255, 'p': 0.46153846153846156, 'r': 0.24}	{'f': 0.10256409811965832, 'p': 0.15384615384615385, 'r': 0.07692307692307693}	{'f': 0.2631578902354571, 'p': 0.38461538461538464, 'r': 0.2}	85	0.5924063920974731
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/AudioInputHost/AudioInputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Could not set requested Audio sample rate.\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  DDRC |= (1 << 6);

  TCCR3A = ((1 << WGM30) | (1 << COM3A1) | (1 << COM3A0));
  TCCR3B = ((1 << WGM32) | (1 << CS30));

  puts_P(PSTR(""Microphone Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"	claude-3-5-sonnet-20241022	This function handles USB microphone device enumeration, configuring settings like sample rate and interfaces, and sets up timers for audio processing once the device is successfully connected.	1	1	0.16129032258064518	0.01094126252323493	{'f': 0.27999999500000006, 'p': 0.28, 'r': 0.28}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15999999500000017, 'p': 0.16, 'r': 0.16}	75	0.5049864649772644
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Read the settings INI file via TinyFrame	2	"uint32_t GEX_IniRead(GexClient *gex, char *buffer, uint32_t maxlen) {
  GexBulk br = (GexBulk){
      .buffer = (uint8_t *)buffer, .capacity = maxlen, .req_cmd = MSG_INI_READ};

  uint32_t actuallyRead = GEX_BulkRead(GEX_SysUnit(gex), &br);

  if (actuallyRead == maxlen) {
    actuallyRead--;
  }

  buffer[actuallyRead] = 0;
  return actuallyRead;
}"	claude-3-5-sonnet-20241022	The function reads configuration data into a buffer from a GEX system unit, ensuring the buffer is null-terminated, and returns the number of bytes actually read.	1	1	0.11235955056179776	0.0072658577559704465	{'f': 0.06666666308888908, 'p': 0.14285714285714285, 'r': 0.043478260869565216}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06666666308888908, 'p': 0.14285714285714285, 'r': 0.043478260869565216}	None_output	0.3182032108306885
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	Wraps a packet like commonSetup, but will do the whole packet including headers not just the message body. This is used by the PacketEncoder tests.	2	"testrigencoder_CommonSetupWholePacket(uint8_t *packet, size_t length,
                                      TruthTableEntry *truthTable) {
  TestData *data = parcMemory_AllocateAndClear(sizeof(TestData));
  assertNotNull(data, ""parcMemory_AllocateAndClear(%zu) returned NULL"",
                sizeof(TestData));

  data->memoryRegion = parcBuffer_Wrap(packet, length, 0, length);
  data->encoder = ccnxCodecTlvEncoder_Create();

  data->dictionary = ccnxTlvDictionary_Create(
      CCNxCodecSchemaV1TlvDictionary_MessageFastArray_END,
      CCNxCodecSchemaV1TlvDictionary_Lists_END);

  data->packet = packet;
  data->packetLength = length;
  data->truthTable = truthTable;

  buildPacketDictionary(data, data->dictionary, (TlvExtent){0, length});

  return data;
}"	claude-3-5-sonnet-20241022	This function initializes test data by creating a TestData structure, wrapping a packet buffer, setting up an encoder and dictionary, and building a packet dictionary with the provided parameters.	1	1	0.19685039370078744	0.01801210737536247	{'f': 0.217391299357278, 'p': 0.22727272727272727, 'r': 0.20833333333333334}	{'f': 0.03921568129181148, 'p': 0.041666666666666664, 'r': 0.037037037037037035}	{'f': 0.13043477761814765, 'p': 0.13636363636363635, 'r': 0.125}	45	0.5256917476654053
ryankurte-micro-gui-1e3ce05/source/graphics.c	This performs bounds checking and translation based on the graphics context	2	"static void plot(ugui_graphics_t *graphics, uint32_t x, uint32_t y) {

  uint32_t new_x = x + graphics->offset_x;
  uint32_t new_y = y + graphics->offset_y;

  if ((new_x < graphics->w) && (x < graphics->limit_w) &&
      (new_y < graphics->h) && (y < graphics->limit_h)) {
    _ugui_buffer_set(graphics->buffer, &(ugui_point_t){.x = new_x, .y = new_y},
                     1);
  }
}"	claude-3-5-sonnet-20241022	This function plots a single pixel at coordinates (x,y) on a graphics buffer, applying offsets and boundary checks to ensure the point falls within valid display limits.	1	1	0.2777777777777778	0.010438074937942448	{'f': 0.270270266092038, 'p': 0.45454545454545453, 'r': 0.19230769230769232}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.16216215798392997, 'p': 0.2727272727272727, 'r': 0.11538461538461539}	75	0.6039602756500244
darktable-org-darktable-32fab21/src/iop/borders.c	callback methods for gui. synch gtk interface with gui params, if necessary. gui callbacks, these are needed.	2	"void gui_update(struct dt_iop_module_t *self) {
  dt_iop_borders_gui_data_t *g = (dt_iop_borders_gui_data_t *)self->gui_data;
  dt_iop_borders_params_t *p = (dt_iop_borders_params_t *)self->params;
  dt_bauhaus_slider_set(g->size, p->size * 100.0f);

  int k = 0;
  for (; k < DT_IOP_BORDERS_ASPECT_COUNT; k++) {
    if (fabsf(p->aspect - g->aspect_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->aspect, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_ASPECT_COUNT) {
    dt_bauhaus_combobox_set_text(g->aspect, p->aspect_text);
    dt_bauhaus_combobox_set(g->aspect, -1);
  }

  dt_bauhaus_combobox_set(g->aspect_orient, p->aspect_orient);

  for (k = 0; k < DT_IOP_BORDERS_POSITION_H_COUNT; k++) {
    if (fabsf(p->pos_h - g->pos_h_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_h, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_H_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_h, p->pos_h_text);
    dt_bauhaus_combobox_set(g->pos_h, -1);
  }

  for (k = 0; k < DT_IOP_BORDERS_POSITION_V_COUNT; k++) {
    if (fabsf(p->pos_v - g->pos_v_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_v, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_V_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_v, p->pos_v_text);
    dt_bauhaus_combobox_set(g->pos_v, -1);
  }

  dt_bauhaus_slider_set(g->frame_size, p->frame_size * 100.0f);
  dt_bauhaus_slider_set(g->frame_offset, p->frame_offset * 100.0f);

  GdkRGBA c = (GdkRGBA){.red = p->color[0],
                        .green = p->color[1],
                        .blue = p->color[2],
                        .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->colorpick), &c);

  GdkRGBA fc = (GdkRGBA){.red = p->frame_color[0],
                         .green = p->frame_color[1],
                         .blue = p->frame_color[2],
                         .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->frame_colorpick), &fc);
}"	claude-3-5-sonnet-20241022	This function updates the GUI elements (sliders, comboboxes, color pickers) of the borders module with values from the current parameters structure.	1	1	0.057471264367816084	0.009134423666564471	{'f': 0.058823524480969266, 'p': 0.06666666666666667, 'r': 0.05263157894736842}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.058823524480969266, 'p': 0.06666666666666667, 'r': 0.05263157894736842}	75	0.3853755295276642
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavutil/rational.c	Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign.	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (fabs(d) > INT_MAX + 3LL)
    return (AVRational){d < 0 ? -1 : 1, 0};
  frexp(d, &exponent);
  exponent = FFMAX(exponent - 1, 0);
  den = 1LL << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"	claude-3-5-sonnet-20241022	This function converts a double-precision floating-point number into a rational fraction representation with a specified maximum denominator value, returning an AVRational structure containing the numerator and denominator.	1	1	0.1388888888888889	0.018561813742586367	{'f': 0.18604650669551123, 'p': 0.21052631578947367, 'r': 0.16666666666666666}	{'f': 0.043478255954631936, 'p': 0.05, 'r': 0.038461538461538464}	{'f': 0.18604650669551123, 'p': 0.21052631578947367, 'r': 0.16666666666666666}	85	0.6361103057861328
ThierryNg-pokecopy-57caaae/Pokecopy.spritebuilder/Source/libs/cocos2d-iphone/cocos2d/ccTypes.h	helper that creates a ccColor4f type	2	"static inline ccColor4F ccc4f(const GLfloat r, const GLfloat g, const GLfloat b,
                              const GLfloat a) {
  return (ccColor4F){r, g, b, a};
}"	claude-3-5-sonnet-20241022	This function creates and returns a ccColor4F structure with four floating-point values representing red, green, blue, and alpha color components.	1	1	0.34534534534534533	0.011451997463067555	{'f': 0.15999999635200007, 'p': 0.3333333333333333, 'r': 0.10526315789473684}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15999999635200007, 'p': 0.3333333333333333, 'r': 0.10526315789473684}	85	0.5722008943557739
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/LowLevel/Host.c	Clears a stall condition on the given pipe, via a ClearFeature request to the attached device.	2	"uint8_t USB_Host_ClearPipeStall(uint8_t EndpointNum) {
  if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    EndpointNum |= ENDPOINT_DESCRIPTOR_DIR_IN;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function clears a stall condition on a USB device endpoint by sending a control request to clear the endpoint halt feature.	1	1	0.4990963855421686	0.1423071532720465	{'f': 0.4848484799632691, 'p': 0.5714285714285714, 'r': 0.42105263157894735}	{'f': 0.2222222173611112, 'p': 0.26666666666666666, 'r': 0.19047619047619047}	{'f': 0.42424241935720847, 'p': 0.5, 'r': 0.3684210526315789}	95	0.6503503322601318
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI inquiry command to a USB mass storage device to retrieve device information and stores the response in the InquiryData structure.	1	1	0.3866694409765571	0.011328360454400999	{'f': 0.2222222173611112, 'p': 0.26666666666666666, 'r': 0.19047619047619047}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1111111062500002, 'p': 0.13333333333333333, 'r': 0.09523809523809523}	85	0.6920891404151917
varunjampani-video_prop_networks-4f4a398/lib/caffe/include/caffe/malabar_layers.hpp	Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true.	2	"template <typename Dtype> class MatMulLayer : public Layer<Dtype> {
public:
  explicit MatMulLayer(const LayerParameter &param) : Layer<Dtype>(param) {
    LayerParameter tmp_param;
    tmp_param.mutable_concat_param()->set_concat_dim(3);
    concat_layer_.reset(new ConcatLayer<Dtype>(tmp_param));
  }
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul""; }
  virtual inline int MinNumBottomBlobs() const { return 2; }
  virtual inline int ExactNumTopBlobs() const { return 1; }

protected:
  virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Forward_gpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  virtual void Backward_gpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  Blob<Dtype> tmp_k_;
  boost::shared_ptr<ConcatLayer<Dtype>> concat_layer_;
};

template <typename Dtype> class MatMul2Layer : public Layer<Dtype> {
public:
  explicit MatMul2Layer(const LayerParameter &param) : Layer<Dtype>(param){};
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul2""; }"	claude-3-5-sonnet-20241022	The code defines two layer classes (MatMulLayer and MatMul2Layer) for matrix multiplication operations in a neural network framework, with support for both CPU and GPU computations.	1	1	0.15228426395939085	0.010275474580767148	{'f': 0.14999999520000015, 'p': 0.1875, 'r': 0.125}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.09999999520000023, 'p': 0.125, 'r': 0.08333333333333333}	50	0.38353949785232544
moehriegitt-hob3l-40cfda8/src/csg3.c	From an array of points in the rough shape of a tower, make a polyhedron. 'Tower' means the shape consists of layers of polygon points stack on each other. This function also handles the case of the top collapsing into a single point. So this shape works for (polyhedronized) cylinders, cones, spheres, cubes, and linear_extrudes. If the connecting quads are not planar, then tri_side can be set to non-false to split them into triangles. This shape is probably not nice, but correct in that the faces are planar, since every triangle is trivially planar). The top and bottom faces must be planar. rev^(m->d < 0) inverts face vertex order to allow managing mirroring and negative determinants. This also gives some freedom for the construction: if top and bottom are swapped (i.e., the points 0..fn-1 are the top, not the bottom), then rev be passed as non-false. This also runs xform and minmax, but not make_edges.	2	"static bool faces_n_edges_from_tower(cp_csg3_poly_t *o, ctxt_t *c,
                                     cp_mat3wi_t const *m, cp_loc_t loc,
                                     size_t fn, size_t fnz, bool rev,
                                     unsigned tri_side, bool may_need_tri) {

  unsigned orient = 0;
  bool need_tri = false;
  if (may_need_tri) {
    for (cp_size_each(i, fn)) {
      size_t j = cp_wrap_add1(i, fn);
      size_t k = cp_wrap_add1(j, fn);
      orient |=
          1U << (1 + cp_vec2_right_normal3_z(&cp_v_nth(&o->point, i).coord.b,
                                             &cp_v_nth(&o->point, j).coord.b,
                                             &cp_v_nth(&o->point, k).coord.b));
      if ((orient & 5) == 5) {
        need_tri = true;
        break;
      }
    }
  }

  cp_v_size3_t tri = {0};
  if (need_tri) {
    cp_vec2_arr_ref_t a2;
    cp_vec2_arr_ref_from_a_vec3_loc_xy(&a2, &o->point);
    if (!cp_csg2_tri_vec2_arr_ref(&tri, c->tmp, c->err, loc, &a2, fn)) {
      return false;
    }
  }

  if (m->d < 0) {
    rev = !rev;
  }

  for (cp_v_each(i, &o->point)) {
    cp_vec3w_xform(&cp_v_nth(&o->point, i).coord, &m->n,
                   &cp_v_nth(&o->point, i).coord);
  }

  bool has_top = (o->point.size == fn * fnz);
  assert(has_top || (o->point.size == 1 + (fn * (fnz - 1))));

  size_t k = 0;
  size_t bt_cnt = tri.size ? tri.size : 1U;
  cp_v_init0(&o->face, (bt_cnt * (1U + !!has_top)) +
                           ((fnz - 2) * fn * (1U + !!tri_side)) +
                           (fn * (1U + !!(tri_side && has_top))));

  face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, false);

  if (has_top) {
    face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, true);
  }

  cp_v_fini(&tri);

  cp_csg3_face_t *f;
  for (cp_size_each(i, fnz, 1, !has_top)) {
    size_t k1 = i * fn;
    size_t k0 = k1 - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      switch (tri_side) {
      case TRI_LEFT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j0},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j1},
                                 3, !rev, loc);
        break;
      case TRI_RIGHT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j0},
                                 3, !rev, loc);
        break;
      case TRI_NONE:
        face_init_from_point_ref(
            f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1, k1 + j0}, 4, !rev,
            loc);
        break;
      default:
        assert(0);
      }
    }
  }

  if (!has_top) {

    size_t kw = o->point.size - 1;
    size_t kv = kw - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      face_init_from_point_ref(f, o, (size_t[4]){kv + j0, kv + j1, kw}, 3, !rev,
                               loc);
    }
  }

  assert(o->face.size == k);
  return poly_make_edges(o, c);
}"	claude-3-5-sonnet-20241022	This function creates faces and edges for a 3D polygon tower structure by processing vertices, triangulating when necessary, and handling both top and side faces while respecting orientation and transformation parameters.	1	1	0.05998588567395906	0.00045821063443777143	{'f': 0.14285713948979603, 'p': 0.09090909090909091, 'r': 0.3333333333333333}	{'f': 0.02234636592490906, 'p': 0.013422818791946308, 'r': 0.06666666666666667}	{'f': 0.09523809187074841, 'p': 0.06060606060606061, 'r': 0.2222222222222222}	85	0.7206642031669617
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	Parse a packet, add all split parts to parse_queue.	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->buf && out_pkt.data == pkt->data) {

      out_pkt.buf = av_buffer_ref(pkt->buf);
      if (!out_pkt.buf) {
        ret = AVERROR(ENOMEM);
        goto fail;
      }
    } else {
      ret = av_packet_make_refcounted(&out_pkt);
      if (ret < 0)
        goto fail;
    }

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;
    out_pkt.flags |= pkt->flags & AV_PKT_FLAG_DISCARD;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = ff_packet_list_put(&s->internal->parse_queue,
                             &s->internal->parse_queue_end, &out_pkt, 0);
    if (ret < 0) {
      av_packet_unref(&out_pkt);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"	claude-3-5-sonnet-20241022	This function parses input packets into output packets by handling packet data, timestamps, flags, and side data, while managing memory references and performing necessary transformations for different media types.	1	1	0.13636363636363635	0.006471824245088331	{'f': 0.05714285332244924, 'p': 0.1111111111111111, 'r': 0.038461538461538464}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.05714285332244924, 'p': 0.1111111111111111, 'r': 0.038461538461538464}	45	0.43915557861328125
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices.	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"	claude-3-5-sonnet-20241022	This function configures a HID device to use the boot protocol mode by sending a control request, updating interface states, and setting the report size to 8 bytes.	1	1	0.32262465043312194	0.018693000799960027	{'f': 0.25641025180802113, 'p': 0.35714285714285715, 'r': 0.2}	{'f': 0.04651162323418111, 'p': 0.0625, 'r': 0.037037037037037035}	{'f': 0.25641025180802113, 'p': 0.35714285714285715, 'r': 0.2}	85	0.7599328756332397
opticron-libuweave-2e5e385/src/macaroon_helpers.c	Mint an initial server authentication token (SAT).	2	"bool uw_macaroon_mint_server_authentication_token_(
    const uint8_t *root_key, size_t root_key_len, const uint8_t *token_str,
    size_t token_str_len,
    const uint8_t nonce[UW_MACAROON_INIT_DELEGATION_NONCE_SIZE],
    uint8_t *buffer, size_t buffer_size, UwMacaroon *new_macaroon) {
  if (root_key == NULL || root_key_len == 0 || nonce == NULL ||
      buffer == NULL || buffer_size == 0 || new_macaroon == NULL) {
    return false;
  }
  if (token_str == NULL && token_str_len != 0) {
    return false;
  }

  *new_macaroon = (UwMacaroon){};

  const size_t num_caveats = 2;
  UwMacaroonCaveat **caveat_list =
      allocate_caveat_list_(num_caveats, &buffer, &buffer_size);
  if (caveat_list == NULL) {
    return false;
  }

  size_t needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeServerAuthenticationTokenV1, token_str_len);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_server_authentication_token_(
          token_str, token_str_len, buffer, needed_buffer_size,
          caveat_list[0])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeNonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_nonce_(
          nonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE, buffer,
          needed_buffer_size, caveat_list[1])) {
    return false;
  }

  UwMacaroonContext context = {};
  return uw_macaroon_create_from_root_key_(
      new_macaroon, root_key, root_key_len, &context,
      (const UwMacaroonCaveat *const *)caveat_list, num_caveats);
}"	claude-3-5-sonnet-20241022	This function creates a server authentication macaroon token with two caveats (authentication token and nonce) using a root key and returns the newly created macaroon.	1	1	0.2904040404040404	0.021084454569051277	{'f': 0.22222221838134434, 'p': 0.42857142857142855, 'r': 0.15}	{'f': 0.13333333013333343, 'p': 0.3333333333333333, 'r': 0.08333333333333333}	{'f': 0.22222221838134434, 'p': 0.42857142857142855, 'r': 0.15}	75	0.4367929697036743
vsfteam-vsf-c4a58f3/release/kernel/beta/example/usrapp/template/main_fsm_simple.c	You cannot ignore fsm_initialiser at any time	4	"fsm_initialiser(user_task_b_t, args(vsf_sem_t *ptSEM))
    init_body(this.psem = ptSEM;)

        implement_fsm(user_task_b_t) def_states(PRINT, DELAY);

    body(
        on_start(
            update_state_to(PRINT);
        )
        
        state(PRINT){
  printf(""hello world! \r\n"");
  update_state_to(DELAY);                                              
        }"	claude-3-5-sonnet-20241022	"This function initializes a Finite State Machine (FSM) with two states (PRINT and DELAY) that prints ""hello world!"" and manages state transitions using semaphores."	1	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	20	0.3500809967517853
kernkonzept-l4re-core-0dd677e/l4sys/include/types.h	Create a message tag from the specified values.	2	"l4_msgtag_t l4_msgtag(long label, unsigned words, unsigned items,
                      unsigned flags) L4_NOTHROW {
  return (l4_msgtag_t){
      (l4_mword_t)((l4_umword_t)label << 16) | (l4_mword_t)(words & 0x3f) |
      (l4_mword_t)((items & 0x3f) << 6) | (l4_mword_t)(flags & 0xf000)};
}"	claude-3-5-sonnet-20241022	This function constructs an L4 message tag by combining a label, word count, item count, and flags into a single packed data structure used for IPC communication.	1	1	0.25813692480359146	0.01633647013102316	{'f': 0.1818181781450873, 'p': 0.375, 'r': 0.12}	{'f': 0.060606057263544726, 'p': 0.14285714285714285, 'r': 0.038461538461538464}	{'f': 0.12121211753902673, 'p': 0.25, 'r': 0.08}	75	0.4877373278141022
cascadeo-monit-8857544/src/status.c	Show all services in the service list.	2	"boolean_t status(const char *level, const char *group, const char *service) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    Socket_print(S, ""GET /_status?format=text&level=%s"", level);
    if (group) {
      char *_group = Util_urlEncode((char *)group);
      Socket_print(S, ""&group=%s"", _group);
      FREE(_group);
    }
    if (service) {
      char *_service = Util_urlEncode((char *)service);
      Socket_print(S, ""&service=%s"", _service);
      FREE(_service);
    }
    char *_auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, "" HTTP/1.0\r\n%s\r\n"", _auth ? _auth : """");
    FREE(_auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"	claude-3-5-sonnet-20241022	This function checks and retrieves the status of monitored services by connecting to the Monit daemon through HTTP/UNIX socket, returning true if successful or false if any errors occur.	1	1	0.10869565217391305	0.007696339439306161	{'f': 0.1176470555536333, 'p': 0.2857142857142857, 'r': 0.07407407407407407}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.1176470555536333, 'p': 0.2857142857142857, 'r': 0.07407407407407407}	20	0.23872867226600647
boazsegev-iodine-b6bdf50/ext/iodine/fio_tls_missing.c	Schedules the ALPN protocol callback.	2	"FIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,
                                 void *udata_connection) {
  if (!alpn || !alpn->on_selected)
    return;
  alpn_task_s *t = fio_malloc(sizeof(*t));
  *t = (alpn_task_s){
      .alpn = *alpn,
      .uuid = uuid,
      .udata_connection = udata_connection,
  };

  fio_defer(alpn_select___task, t, NULL);
}"	claude-3-5-sonnet-20241022	The function creates and schedules a deferred task for ALPN (Application-Layer Protocol Negotiation) selection by allocating memory for task data and setting up relevant parameters.	1	1	0.2857142857142857	0.007575731225158965	{'f': 0.07407407105624156, 'p': 0.2, 'r': 0.045454545454545456}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07407407105624156, 'p': 0.2, 'r': 0.045454545454545456}	75	0.6947708129882812
rockchip-linux-coreboot-adde3ea/src/cpu/intel/speedstep/speedstep.c	This is generic code and should work at least for Merom and Penryn processors. It is used to generate acpi tables and configure EMTTM.	4	"void speedstep_gen_pstates(sst_table_t *const table) {
  sst_params_t params;

  speedstep_get_limits(&params);

  const int power_diff2 = (params.max.power - params.min.power) * 2;
  const int vid_diff2 = (params.max.vid - params.min.vid) * 2;
  const int max_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.max);
  const int min_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.min);
  const int ratio_diff2 = max_ratio2 - min_ratio2;

  int states, step2 = 0;
  do {
    step2 += 2 * 2;
    states = ratio_diff2 / step2 + 1;
  } while (states > SPEEDSTEP_MAX_NORMAL_STATES);
  if (step2 > 4)
    printk(BIOS_INFO,
           ""Enhanced Speedstep processor with ""
           ""more than %d possible p-states.\n"",
           SPEEDSTEP_MAX_NORMAL_STATES);
  if (states < 2)
    states = 2;

  table->num_states = 0;

  if (params.turbo.is_turbo)
    table->states[table->num_states++] = params.turbo;

  table->states[table->num_states] = params.max;

  if ((params.max.dynfsb == params.min.dynfsb) &&
      (params.max.nonint == params.min.nonint) &&
      (params.max.ratio == params.min.ratio))
    table->states[table->num_states].vid = params.min.vid;
  ++table->num_states;
  --states;

  const int power_step = (power_diff2 / states) / 2;
  const int vid_step = (vid_diff2 / states) / 2;
  const int ratio_step = step2 / 2;
  int power = params.min.power + (states - 1) * power_step;
  int vid = params.min.vid + (states - 1) * vid_step;
  int ratio = params.min.ratio + (states - 1) * ratio_step;
  for (; states > 0; --states) {
    table->states[table->num_states++] =
        (sst_state_t){0, 0, ratio, vid, 0, 0, power};
    power -= power_step;
    vid -= vid_step;
    ratio -= ratio_step;
  }

  if (params.slfm.is_slfm)
    table->states[table->num_states++] = params.slfm;
}"	claude-3-5-sonnet-20241022	This function generates a table of P-states (performance states) for Intel SpeedStep technology by calculating power, voltage ID, and frequency ratio values between minimum and maximum limits.	1	1	0.1440329218106996	0.009871721786705418	{'f': 0.127659569524672, 'p': 0.14285714285714285, 'r': 0.11538461538461539}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.127659569524672, 'p': 0.14285714285714285, 'r': 0.11538461538461539}	30	0.41266930103302
BRAINSia-BRAINSTools-11a70b1/ARCHIVE/BRAINSSurfaceTools/BRAINSSurfaceCommon/itkMeshToMeshRegistrationMethod.h	Method invoked by the pipeline in order to trigger the computation of the registration.	2	"using Superclass::MakeOutput;

virtual DataObjectPointer MakeOutput(size_t idx) override;

unsigned long GetMTime() const override;

protected:
MeshToMeshRegistrationMethod();
virtual ~MeshToMeshRegistrationMethod(){};
void PrintSelf(std::ostream &os, Indent indent) const override;

void GenerateData() override;

private:
MetricPointer m_Metric;
OptimizerType::Pointer m_Optimizer;

MovingMeshConstPointer m_MovingMesh;
FixedMeshConstPointer m_FixedMesh;

TransformPointer m_Transform;
InterpolatorPointer m_Interpolator;

ParametersType m_InitialTransformParameters;
ParametersType m_LastTransformParameters;
}
;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.0903693214058876
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal simplex basis functions.	2	"static void
test_unit_basis_simplex_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_SI_Ortho *b_data_a = constructor_Basis_Data_SI_Ortho('a'),
                             *b_data_c = constructor_Basis_Data_SI_Ortho('c');

  tol = (double[]){
      10 * EPS,
      20 * EPS,
      10 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]),
      diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[1]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      20 * EPS,
      30 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]),
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      9 * EPS,
      8e4 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_25, b_data_c->grad_coef_25,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_37, b_data_c->grad_coef_37,
                              tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_25,
                                    b_data_c->grad_coef_25, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_37,
                                    b_data_c->grad_coef_37, tol[1]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_SI_Ortho(b_data_a);
  destructor_Basis_Data_SI_Ortho(b_data_c);

  assert_condition(pass);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.008618887513875961
MightyPork-avr-projects-1c993f8/projects/color-memory-game/main.c	Randomly place pairs of cards on the board	2	"void deal_cards() {

  for (uint8_t i = 0; i < CARD_COUNT; ++i) {
    board[i] = (tile_t){.color = 0, .state = GONE};
  }

  const uint8_t dealt_cards =
      get_pin(FLAG_SMALL) ? CARD_COUNT : CARD_COUNT_SMALL;

  for (uint8_t i = 0; i < (dealt_cards / 2); ++i) {

    for (uint8_t j = 0; j < 2; j++) {

      while (1) {
        const uint8_t pos = rand() % dealt_cards;

        if (board[pos].state == GONE) {
          board[pos] = (tile_t){.color = i, .state = SECRET};
          break;
        }
      }
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.05416938662528992
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Inquiry_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.06865318864583969
multitheftauto-mtasa-blue-1f5e9f8/vendor/ehs/ehs.h	adds new data to psBuffer	2	"NetworkAbstraction *GetNetworkAbstraction();

int TrySend(const char *ipMessage, size_t inLength, int inFlags = 0);
}
;

class EHSServer;

class EHS {

protected:
  EHSMap oEHSMap;

  EHS *poParent;

  std::string sRegisteredAs;

  EHSServer *poEHSServer;

  EHS *m_poSourceEHS;

public:
  EHS(EHS *ipoParent = NULL, std::string isRegisteredAs = """");

  virtual ~EHS();

  void SetCertificateFile(std::string &irsCertificateFile);

  void SetCertificatePassphrase(std::string &irsCertificatePassphrase);

  void SetPassphraseCallback(int (*m_ipfOverridePassphraseCallback)(char *, int,
                                                                    int,
                                                                    void *));

  void SetParent(EHS *ipoParent, std::string isRegisteredAs);

  enum RegisterEHSResult {
    REGISTEREHSINTERFACE_INVALID = 0,
    REGISTEREHSINTERFACE_ALREADYEXISTS,
    REGISTEREHSINTERFACE_SUCCESS
  };

  RegisterEHSResult RegisterEHS(EHS *ipoEHS, const char *ipsRegisterPath);

  enum UnregisterEHSResult {
    UNREGISTEREHSINTERFACE_INVALID = 0,
    UNREGISTEREHSINTERFACE_NOTREGISTERED,
    UNREGISTEREHSINTERFACE_SUCCESS
  };

  UnregisterEHSResult UnregisterEHS(const char *ipsRegisterPath);

  virtual HttpResponse *RouteRequest(HttpRequest *ipoHttpRequest);

  virtual ResponseCode HandleRequest(HttpRequest *ipoHttpRequest,
                                     HttpResponse *ipoHttpResponse);

  virtual void HttpPulse(void){};

  virtual bool ShouldAllowConnection(const char *szAddress) { return true; }"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.2469317615032196
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power domain attributes command and testing the received values.	3	"void arm_scmi_custom_test_power_domain_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t attributes;
  uint32_t protocol_mask = expected_flags_mask;
  uint32_t rcv_u, exp_u;
  char *domain_name;
  char *rcv_s, *exp_s;
  struct arm_scmi_protocol_execution_context *prot = protocol_execution_context;
  enum test_status res;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_domain_attributes,
                           domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_domain_attributes,
                                       domain_id)] =
        power_protocol_data.num_power_domains + 1;
    error_code =
        arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_power_domain_attributes, domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tPOWER DOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&prot->test_stats, description);
      error_code =
          arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        break;
      attributes = RETURN_VAL(received, struct arm_scmi_power_domain_attributes,
                              attributes);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_HIGH,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_LOW);
      snprintf(name, NUM_ELEMS(name),
               ""POWER STATE CHANGE NOTIFICATIONS SUPPORT"");
      if ((power_expected->power_state_notification_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_STATE_NOTIFICATION_SUPPORT))) {
        exp_u = power_expected->power_state_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_ASYNC_HIGH,
                                     POWER_DOMAIN_ATTR_ASYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER ASYNCHRONOUS SUPPORT"");
      if ((power_expected->power_asynchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_ASYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_asynchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_SYNC_HIGH,
                                     POWER_DOMAIN_ATTR_SYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER SYNCHRONOUS SUPPORT"");
      if ((power_expected->power_synchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_SYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_synchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      arm_scmi_check_and_report_dec(
          &prot->test_stats, ALL_BITS_SET, CHECK, RESERVED,
          arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_RESERVED_HIGH,
                                 POWER_DOMAIN_ATTR_RESERVED_LOW),
          ""RESERVED"");

      power_protocol_data.attributes[domain_id] = attributes;

      res = INFO;
      domain_name =
          RETURN_STR(received, struct arm_scmi_power_domain_attributes, name);
      rcv_s = domain_name;
      snprintf(name, NUM_ELEMS(name), ""DOMAIN NAME"");
      if ((power_expected->power_domain_names != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_DOMAIN_NAMES))) {
        exp_s = power_expected->power_domain_names[domain_id];
        res = (strcmp(rcv_s, exp_s) == 0) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", exp_s, rcv_s);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", rcv_s);
      }
      arm_scmi_log_test_result(&prot->test_stats, INFO, name, description);
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.13429459929466248
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	Soft-resets the attached printer, readying it for new commands.	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1427752524614334
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock describe rates command and testing the received values.	3	"void arm_scmi_custom_tester_clock_describe_rates(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint8_t clock_id;
  uint32_t num_rates_flags;
  uint8_t num_rates = 0;
  uint32_t rcv_u, exp_u;
  uint32_t rate_index = 0;
  uint32_t remaining_rates;
  struct arm_scmi_clock_rate *rcv_rates, *rates;
  size_t nr;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  uint64_t op1, step_size;
  struct arm_scmi_clock_rate **discrete;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_describe_rates, clock_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       clock_id)] =
        clock_protocol_data.num_clocks;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       rate_index)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                         clock_id)] = clock_id;
      rate_index = 0;

      rates = clock_protocol_data.clocks[clock_id].rates;
      do {

        test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                           rate_index)] = rate_index;
        error_code = arm_scmi_execute_and_assert_test_case(
            protocol_execution_context, test_case, &received);
        if (arm_scmi_skip_return_values(error_code, received.status))
          break;

        num_rates_flags = RETURN_VAL(
            received, struct arm_scmi_clock_describe_rates, num_rates_flags);

        remaining_rates = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_NUM_RATES_REMAINING_HIGH,
            CLK_DESCRATE_NUM_RATES_REMAINING_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      remaining_rates,
                                      ""NUMBER OF REMAINING RATES"");

        rcv_u =
            arm_scmi_get_norm_bits(num_rates_flags, CLK_DESCRATE_RESERVED_HIGH,
                                   CLK_DESCRATE_RESERVED_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                      rcv_u, ""RESERVED"");

        uint32_t format = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_RETURN_FORMAT_HIGH,
            CLK_DESCRATE_RETURN_FORMAT_LOW);
        clock_protocol_data.format = format;
        if (clock_expected->rate_format_supported) {
          arm_scmi_check_and_report_dec(
              test_stats, expected_flags_mask,
              LEFT_SHIFT(RATE_FORMAT_SUPPORTED),
              clock_expected->rate_format_supported[clock_id], format,
              ""FORMAT"");
        } else {
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(RATE_FORMAT_SUPPORTED), 0,
                                        format, ""FORMAT"");
        }

        num_rates = arm_scmi_get_norm_bits(num_rates_flags,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_HIGH,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_LOW);
        exp_u = clock_expected->num_rates == NULL
                    ? 0
                    : clock_expected->num_rates[clock_id];
        arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                      LEFT_SHIFT(CLOCK_NUM_RATES), exp_u,
                                      num_rates, ""NUMBER OF RATES"");

        rcv_rates = (struct arm_scmi_clock_rate *)&received.payload[OFFSET_RET(
            struct arm_scmi_clock_describe_rates, rates)];
        if (format == THREE_TUPLE_RATE_FORMAT) {

          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].lower,
                                        ""LOWEST RATE {LOWER}"");
          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].upper,
                                        ""LOWEST RATE {UPPER}"");

          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].lower,
                                        ""HIGHEST RATE {LOWER}"");
          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].upper,
                                        ""HIGHEST RATE {UPPER}"");

          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].lower,
                                        ""STEP SIZE {LOWER}"");
          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].upper,
                                        ""STEP SIZE {UPPER}"");

          rates[MIN_CLOCK] = rcv_rates[LOWEST_RATE];
          op1 = (((uint64_t)rcv_rates[LOWEST_RATE].upper) << 32) |
                rcv_rates[LOWEST_RATE].lower;
          step_size = (((uint64_t)rcv_rates[STEP_SIZE].upper) << 32) |
                      rcv_rates[STEP_SIZE].lower;
          op1 += step_size;
          rates[MIN_CLOCK + 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          op1 = (((uint64_t)rcv_rates[HIGHEST_RATE].upper) << 32) |
                rcv_rates[HIGHEST_RATE].lower;
          op1 -= step_size;
          rates[MAX_CLOCK - 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          rates[MAX_CLOCK] = rcv_rates[HIGHEST_RATE];

        } else {

          discrete = clock_expected->discrete_clock_rates;
          for (nr = 0; nr < num_rates; ++nr) {
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].lower;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->lower,
                                          ""LOWER WORD"");
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].upper;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->upper,
                                          ""UPPER WORD"");

            if ((rate_index + nr) == 0) {
              rates[MIN_CLOCK] = rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] =
                  rates[MAX_CLOCK] = *rcv_rates;
            } else if ((rate_index + nr) == 1) {
              rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] = rates[MAX_CLOCK] =
                  *rcv_rates;
            }
            rates[MAX_CLOCK - 1] = rates[MAX_CLOCK];
            rates[MAX_CLOCK] = *rcv_rates;
            rcv_rates += 1;
          }
        }
        rate_index += num_rates;
      } while (remaining_rates > 0);
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.07983013242483139
SL-RU-MakiseGUI-971c7c7/MakiseGUI/makise.c	set new border. This region must be smaller then previous. It will be cropped. Borders need for drawing GUI. For gui elements do not leave their & their parent's borders. After setting border & drawing it you need to call makise_rem_border.	2	"MakiseBufferBorderData makise_add_border(MakiseBuffer *buffer,
                                         MakiseBufferBorder b) {
  if (buffer == 0)
    return (MakiseBufferBorderData){0};

  if (b.x < buffer->border.x)
    b.x = buffer->border.x;
  if (b.y < buffer->border.y)
    b.y = buffer->border.y;
  if (b.w > buffer->border.w + buffer->border.x - b.x)
    b.w = buffer->border.w + buffer->border.x - b.x;
  if (b.h > buffer->border.h + buffer->border.y - b.y)
    b.h = buffer->border.h + buffer->border.y - b.y;

  b.ex = b.x + b.w;
  b.ey = b.y + b.h;

  MakiseBufferBorder l = buffer->border;

  buffer->border = b;

  return (MakiseBufferBorderData){b, l};
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	75	0.11625108867883682
openastroproject-openastro-ec7e71c/ext/ffmpeg/libavformat/utils.c	Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet().	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= FFMIN(s->max_streams, INT_MAX / sizeof(*streams))) {
    if (s->max_streams < INT_MAX / sizeof(*streams))
      av_log(s, AV_LOG_ERROR,
             ""Number of streams exceeds max_streams parameter (%d), see the ""
             ""documentation if you wish to increase it\n"",
             s->max_streams);
    return NULL;
  }
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	10	0.01312221772968769
dakami-autoclave-84ab84b/old_but_working_qemu/block/io.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  enum BdrvTrackedRequestType type) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .type = type,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.033133797347545624
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Write settings INI file via TinyFrame	2	"bool GEX_IniWrite(GexClient *gex, const char *buffer) {
  uint8_t buf[8];
  PayloadBuilder pb = pb_start(buf, 8, NULL);
  pb_u32(&pb, (uint32_t)strlen(buffer));

  GexBulk bw = (GexBulk){
      .buffer = (uint8_t *)buffer,
      .len = (uint32_t)strlen(buffer),
      .req_cmd = MSG_INI_WRITE,
      .req_data = buf,
      .req_len = (uint32_t)pb_length(&pb),
  };

  return GEX_BulkWrite(GEX_SysUnit(gex), &bw);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.16650959849357605
rexmac-pebble-chronocode-5a85c4a/src/chronocode.c	Initialize the app	2	"static void init(void) {

  SettingsStoreObject stored_settings;

  if (persist_exists(STORAGE_SETTINGS_KEY)) {
    persist_read_data(STORAGE_SETTINGS_KEY, &stored_settings,
                      sizeof(stored_settings));
    settings = stored_settings.flags;
    language_setting = stored_settings.language;
  } else {
    settings = 0;
    language_setting = LANG_EN_US;
  }

  window = window_create();
  window_set_background_color(
      window, (settings & SETTING_INVERTED) > 0 ? GColorWhite : GColorBlack);
  window_set_window_handlers(
      window, (WindowHandlers){.load = window_load, .unload = window_unload});
  window_stack_push(window, true);

  time_t now = time(NULL);
  struct tm *t = localtime(&now);
  update_time(t);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);

  Tuplet initial_settings[] = {
      TupletInteger(SETTING_SYNC_KEY_ALL_CAPS, (settings & SETTING_ALL_CAPS)),
      TupletInteger(SETTING_SYNC_KEY_INVERTED, (settings & SETTING_INVERTED)),
      TupletInteger(SETTING_SYNC_KEY_LANGUAGE, language_setting),
      TupletInteger(SETTING_SYNC_KEY_TWO_MIN_DOTS,
                    (settings & SETTING_TWO_MIN_DOTS))};
  app_sync_init(
      &settings_sync, settings_sync_buffer, sizeof(settings_sync_buffer),
      initial_settings, ARRAY_LENGTH(initial_settings),
      settings_sync_tuple_changed_callback, settings_sync_error_callback, NULL);
  app_message_open(64, 64);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11199266463518143
freeciv-freeciv-e4ead30/client/gui-sdl2/spaceshipdlg.c	Popup (or raise) the spaceship dialog for the given player.	2	"void popup_spaceship_dialog(struct player *pPlayer) {
  struct SMALL_DLG *pSpaceShp;

  if (!(pSpaceShp = get_spaceship_dialog(pPlayer))) {
    struct widget *pBuf, *pWindow;
    utf8_str *pstr;
    char cbuf[128];
    SDL_Rect area;

    pSpaceShp = fc_calloc(1, sizeof(struct SMALL_DLG));

    fc_snprintf(cbuf, sizeof(cbuf), _(""The %s Spaceship""),
                nation_adjective_for_player(pPlayer));
    pstr = create_utf8_from_char(cbuf, adj_font(12));
    pstr->style |= TTF_STYLE_BOLD;

    pWindow = create_window_skeleton(NULL, pstr, 0);

    pWindow->action = space_dialog_window_callback;
    set_wstate(pWindow, FC_WS_NORMAL);
    pWindow->data.player = pPlayer;
    pWindow->private_data.small_dlg = pSpaceShp;
    add_to_gui_list(ID_WINDOW, pWindow);
    pSpaceShp->pEndWidgetList = pWindow;

    area = pWindow->area;

    pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                            WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
    pBuf->info_label =
        create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
    pBuf->data.player = pPlayer;
    pBuf->action = exit_space_dialog_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->key = SDLK_ESCAPE;
    area.w = MAX(area.w, (pBuf->size.w + adj_size(10)));

    add_to_gui_list(ID_BUTTON, pBuf);

    pBuf = create_themeicon_button_from_chars(
        current_theme->OK_Icon, pWindow->dst, _(""Launch""), adj_font(12), 0);

    pBuf->action = launch_spaceship_callback;
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_BUTTON, pBuf);

    pstr = create_utf8_from_char(get_spaceship_descr(NULL), adj_font(12));
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_LABEL, pBuf);

    pSpaceShp->pBeginWidgetList = pBuf;

    area.w = MAX(area.w, adj_size(300) - (pWindow->size.w - pWindow->area.w));

    resize_window(pWindow, NULL, NULL,
                  (pWindow->size.w - pWindow->area.w) + area.w,
                  (pWindow->size.h - pWindow->area.h) + area.h);

    area = pWindow->area;

    widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                        (main_window_height() - pWindow->size.h) / 2);

    pBuf = pWindow->prev;
    pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
    pBuf->size.y = pWindow->size.y + adj_size(2);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + area.h - pBuf->size.h - adj_size(7);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + adj_size(7);

    dialog_list_prepend(dialog_list, pSpaceShp);

    refresh_spaceship_dialog(pPlayer);
  } else {
    if (select_window_group_dialog(pSpaceShp->pBeginWidgetList,
                                   pSpaceShp->pEndWidgetList)) {
      widget_flush(pSpaceShp->pEndWidgetList);
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.17300699651241302
particle-iot-device-os-7fbf145/wiring/inc/spark_wiring_mesh.h	Determines if the given handler exists.	2	"#include ""scope_guard.h""
#include <memory>

#include ""spark_wiring_thread.h""

namespace spark {

class MeshSignal : public particle::Signal {
public:
  int rssi = 2;
  int qual = 0;

  MeshSignal() {}
  virtual ~MeshSignal(){};

  operator int8_t() const { return 2; }

  virtual hal_net_access_tech_t getAccessTechnology() const {
    return NET_ACCESS_TECHNOLOGY_IEEE802154;
  }

  virtual float getStrength() const { return 0.0f; }"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.08919545263051987
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the aggregated slab journal statistics for the slabs in this allocator.	2	"SlabJournalStatistics
getSlabJournalStatistics(const BlockAllocator *allocator) {
  const AtomicSlabJournalStatistics *atoms = &allocator->slabJournalStatistics;
  return (SlabJournalStatistics){
      .diskFullCount = atomicLoad64(&atoms->diskFullCount),
      .flushCount = atomicLoad64(&atoms->flushCount),
      .blockedCount = atomicLoad64(&atoms->blockedCount),
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
      .tailBusyCount = atomicLoad64(&atoms->tailBusyCount),
  };
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.03570139408111572
opalenzuela-opendomo-1adadbd/src/odbase/src/script.c	Process a comments line and format the output in HTML or XML.	2	"script_process_comments(const char *buf) {
  char tipname[50];
  char *classname = NULL;
  char *contents = NULL;

  if (strlen(buf) < 3)
    return;

  if (gui == html) {
    if ((buf[0] == '-') && (buf[1] == '-')) {
      printf(""\t<hr/>\n"");
    } else if (SPELL3(buf, 'E', 'R', 'R')) {
      printf(""\t<p class='error'>%s</p>\n"", T(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R')) {
      printf(""\t<p class='warning'>%s</p>\n"", T(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F')) {
      printf(""\t<p class='info'>%s</p>\n"", T(buf += 5));
    } else if (SPELL3(buf, 'T', 'I', 'P')) {
      printf(""\t<p class='tooltip tip'>%s</p>\n"", T(buf += 4));
    } else if (SPELL3(buf, 'L', 'O', 'A')) {

      printf(""\t<p class='loading'>%s</p>\n"", T(buf += 8));

      printf(""<script type='text/Javascript'>\n""
             ""$(function($){\n""
             ""	$('p.loading').hide() ;\n""
             ""});\n""
             ""</script>\n"");
    } else if (SPELL3(buf, 'U', 'R', 'L')) {
      printf(""\t<p class='link'>""
             ""<a href='%s' target='_blank'>%s</a></p>\n"",
             buf += 4, buf);
    } else if (buf[0] == '>') {
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    } else {

      if (buf[0] == ' ') {
        printf(""\t<p class='comments'>%s</p>\n"", T(buf += 1));
      } else {
        classname = strtok(buf, "" "");
        contents = strtok(NULL, ""\n"");

        printf(""\t<p class='%s'>%s</p>\n"", classname, T(contents));
      }
    }
  } else {
    if (SPELL3(buf, 'E', 'R', 'R') || SPELL3(buf, 'e', 'r', 'r')) {
      printf(""\t<error description='%s'/>\n"", CT(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R') || SPELL3(buf, 'w', 'a', 'r')) {
      printf(""\t<warning description='%s'/>\n"", CT(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F') || SPELL3(buf, 'i', 'n', 'f'))
      printf(""\t<info description='%s'/>\n"", CT(buf += 5));
    else if (buf[0] == '>')
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    else
      printf(""\t<message description='%s'/>\n"", CT(buf += 1));
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.14048773050308228
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.06865318864583969
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/handler/mimemap.c	returns the default mime attributes given a mime type	2	"void h2o_mimemap_get_default_attributes(const char *_mime,
                                        h2o_mime_attributes_t *attr) {
  char *mime = alloca(strlen(_mime) + 1);
  strcpy(mime, _mime);

  const char *type_end_at;

  if ((type_end_at = strchr(mime, ';')) == NULL)
    type_end_at = mime + strlen(mime);

  *attr = (h2o_mime_attributes_t){0};

  if (h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/css"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/javascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/javascript""))) {
    attr->is_compressible = 1;
    attr->priority = H2O_MIME_ATTRIBUTE_PRIORITY_HIGHEST;
  } else if (h2o_memis(mime, type_end_at - mime,
                       H2O_STRLIT(""application/json"")) ||
             strncmp(mime, ""text/"", 5) == 0 ||
             h2o_strstr(mime, type_end_at - mime, H2O_STRLIT(""+xml"")) !=
                 SIZE_MAX) {
    attr->is_compressible = 1;
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.008285759016871452
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/KeyboardHost/KeyboardHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs.	1	"void Keyboard_HID_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    ReadNextReport();

    break;
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	50	0.14126905798912048
HiPhish-XeenTools-ee7c26c/Source/cpp/cpp_tool.c	Read a copy-protection entry from file.	2	"int xeen_read_copy_protection(FILE *fp, long o, int index,
                              XeenCopyProtection *prot) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
    INVALID_DATA,
  } error = SUCCESS;

  uint8_t bytes[LENGTH];

  uint8_t counter = (index * 16);

  if (!fp || !prot) {
    error = INVALID_ARGS;
    goto end;
  } else if (prot->line != 0 || prot->page != 0 || prot->word != 0 ||
             prot->string[0] != '\0') {
    error = INVALID_ARGS;
    goto end;
  }

  if (fseek(fp, o + LENGTH * index, SEEK_SET)) {
    error = FREAD_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), LENGTH, fp) != sizeof(uint8_t) * LENGTH) {
    error = FREAD_FAIL;
    goto end;
  }

  for (int i = 0; i < LENGTH; ++i) {
    bytes[i] ^= (counter++);
  }

  if (bytes[LENGTH - 1] != '\0') {
    error = INVALID_DATA;
    goto end;
  }

  *prot = (XeenCopyProtection){
      .page = bytes[0],
      .line = bytes[1],
      .word = bytes[2],
  };

  for (int i = 0; i < XEEN_CPP_LENGTH; ++i) {
    prot->string[i] = bytes[3 + i];
  }

end:
  return error;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.04294116422533989
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Core/HostStandardReq.c	Selects a given alternative setting for the specified interface, via a SET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_SetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        const uint8_t AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_SetInterface,
      .wValue = AltSetting,
      .wIndex = InterfaceIndex,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.037594836205244064
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Constructs a quaternion from a four-element vector. Note that the imaginary (vector) part of the quaternion comes from lanes 0, 1, and 2 of the vector, and the real (scalar) part comes from lane 3.	2	"static inline SIMD_CFUNC simd_quatd simd_quaternion(simd_double4 xyzr) {
  return (simd_quatd){xyzr};
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.018986806273460388
freeciv-freeciv-e4ead30/client/gui-sdl2/repodlgs.c	Popup (or raise) the economy report (F5). It may or may not be modal.	2	"void economy_report_dialog_popup(bool make_modal) {
  SDL_Color bg_color = {255, 255, 255, 128};
  SDL_Color bg_color2 = {255, 255, 255, 136};
  SDL_Color bg_color3 = {255, 255, 255, 64};
  struct widget *pBuf;
  struct widget *pWindow, *pLast;
  utf8_str *pstr, *pstr2;
  SDL_Surface *pSurf, *pText_Name, *pText, *pZoom;
  SDL_Surface *pBackground;
  int i, count, h = 0;
  int w = 0;
  int w2 = 0;
  int w3 = 0;
  int tax, total, entries_used = 0;
  char cbuf[128];
  struct improvement_entry entries[B_LAST];
  SDL_Rect dst;
  SDL_Rect area;
  struct government *pGov = government_of_player(client.conn.playing);
  SDL_Surface *pTreasuryText;
  SDL_Surface *pTaxRateText;
  SDL_Surface *pTotalIncomeText;
  SDL_Surface *pTotalCostText;
  SDL_Surface *pNetIncomeText;
  SDL_Surface *pMaxRateText;

  if (pEconomyDlg) {
    return;
  }

  pBuf = get_tax_rates_widget();
  set_wstate(pBuf, FC_WS_DISABLED);
  widget_redraw(pBuf);
  widget_mark_dirty(pBuf);

  pEconomyDlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  get_economy_report_data(entries, &entries_used, &total, &tax);

  pstr = create_utf8_from_char(_(""Economy Report""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);
  pEconomyDlg->pEndWidgetList = pWindow;
  set_wstate(pWindow, FC_WS_NORMAL);
  pWindow->action = economy_dialog_callback;

  add_to_gui_list(ID_ECONOMY_DIALOG_WINDOW, pWindow);

  area = pWindow->area;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Treasury: ""));
  pstr2 = create_utf8_from_char(cbuf, adj_font(12));
  pstr2->style |= TTF_STYLE_BOLD;
  pTreasuryText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTreasuryText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", client.conn.playing->economic.gold);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(pIcons->pBIG_Coin, pWindow->dst, pstr,
                          (WF_RESTORE_BACKGROUND | WF_ICON_CENTER_RIGHT));

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Tax Rate: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTaxRateText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTaxRateText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "", client.conn.playing->economic.tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w + pBuf->next->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTotalIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Cost: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalCostText = create_text_surf_from_utf8(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Net Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pNetIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pNetIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax - total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  if (tax - total < 0) {
    pstr->fgcol = *get_theme_color(COLOR_THEME_ECONOMYDLG_NEG_TEXT);
  }

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""%s max rate : %d%%""),
              government_name_translation(pGov),
              get_player_bonus(client.conn.playing, EFT_MAX_RATES));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pMaxRateText = create_text_surf_from_utf8(pstr2);

  FREEUTF8STR(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_LUX_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);
  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);
  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_BLOCK_CHECKBOX, pBuf);

  w2 = adj_size(10) + pBuf->size.w;

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.luxury;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_SCROLLBAR, pBuf);

  w2 += adj_size(184);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.luxury);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Luxury, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);
  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_LABEL, pBuf);

  w2 += (adj_size(5) + pBuf->size.w + adj_size(10));

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_SCI_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);

  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);

  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_BLOCK_CHECKBOX, pBuf);

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.science;

  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_SCROLLBAR, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.science);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Colb, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_LABEL, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Update""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon_button(current_theme->Small_OK_Icon, pWindow->dst,
                                 pstr, 0);
  pBuf->action = apply_taxrates_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_OK_BUTTON, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Close Dialog (Esc)""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label = pstr;
  pBuf->action = exit_economy_dialog_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_CANCEL_BUTTON, pBuf);

  h += adj_size(5);

  pLast = pBuf;
  if (entries_used > 0) {

    pBackground = create_surf(adj_size(116), adj_size(116), SDL_SWSURFACE);

    SDL_FillRect(pBackground, NULL, map_rgba(pBackground->format, bg_color));

    create_frame(pBackground, 0, 0, pBackground->w - 1, pBackground->h - 1,
                 get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (SF_CENTER | TTF_STYLE_BOLD);
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};

    for (i = 0; i < entries_used; i++) {
      struct improvement_entry *p = &entries[i];
      struct impr_type *pImprove = p->type;

      pSurf = crop_rect_from_surface(pBackground, NULL);

      fc_snprintf(cbuf, sizeof(cbuf), ""%s"",
                  improvement_name_translation(pImprove));

      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style |= TTF_STYLE_BOLD;
      pText_Name =
          create_text_surf_smaller_than_w(pstr, pSurf->w - adj_size(4));

      fc_snprintf(cbuf, sizeof(cbuf), ""%s %d\n%s %d"", _(""Built""), p->count,
                  _(""U Total""), p->total_cost);
      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style &= ~TTF_STYLE_BOLD;

      pText = create_text_surf_from_utf8(pstr);

      pZoom = get_building_surface(pImprove);
      pZoom = zoomSurface(pZoom, DEFAULT_ZOOM * ((float)54 / pZoom->w),
                          DEFAULT_ZOOM * ((float)54 / pZoom->w), 1);

      dst.x = (pSurf->w - pZoom->w) / 2;
      dst.y = (pSurf->h / 2 - pZoom->h) / 2;
      alphablit(pZoom, NULL, pSurf, &dst, 255);
      dst.y += pZoom->h;
      FREESURFACE(pZoom);

      dst.x = (pSurf->w - pText_Name->w) / 2;
      dst.y += ((pSurf->h - dst.y) -
                (pText_Name->h + (pIcons->pBIG_Coin->h + 2) + pText->h)) /
               2;
      alphablit(pText_Name, NULL, pSurf, &dst, 255);

      dst.y += pText_Name->h;
      if (p->cost) {
        dst.x = (pSurf->w - p->cost * (pIcons->pBIG_Coin->w + 1)) / 2;
        for (count = 0; count < p->cost; count++) {
          alphablit(pIcons->pBIG_Coin, NULL, pSurf, &dst, 255);
          dst.x += pIcons->pBIG_Coin->w + 1;
        }
      } else {

        if (!is_wonder(pImprove)) {
          copy_chars_to_utf8_str(pstr, _(""Nation""));
        } else {
          copy_chars_to_utf8_str(pstr, _(""Wonder""));
        }

        pZoom = create_text_surf_from_utf8(pstr);

        dst.x = (pSurf->w - pZoom->w) / 2;
        alphablit(pZoom, NULL, pSurf, &dst, 255);
        FREESURFACE(pZoom);
      }

      dst.y += (pIcons->pBIG_Coin->h + adj_size(2));
      dst.x = (pSurf->w - pText->w) / 2;
      alphablit(pText, NULL, pSurf, &dst, 255);

      FREESURFACE(pText);
      FREESURFACE(pText_Name);

      pBuf =
          create_icon2(pSurf, pWindow->dst,
                       (WF_RESTORE_BACKGROUND | WF_FREE_THEME | WF_FREE_DATA));

      set_wstate(pBuf, FC_WS_NORMAL);

      pBuf->data.cont = fc_calloc(1, sizeof(struct CONTAINER));
      pBuf->data.cont->id0 = improvement_number(p->type);
      pBuf->data.cont->id1 = p->count;
      pBuf->action = popup_sell_impr_callback;

      add_to_gui_list(MAX_ID - i, pBuf);

      if (i > (TARGETS_ROW * TARGETS_COL - 1)) {
        set_wflag(pBuf, WF_HIDDEN);
      }
    }

    FREEUTF8STR(pstr);
    FREESURFACE(pBackground);

    pEconomyDlg->pEndActiveWidgetList = pLast->prev;
    pEconomyDlg->pBeginWidgetList = pBuf;
    pEconomyDlg->pBeginActiveWidgetList = pEconomyDlg->pBeginWidgetList;

    if (entries_used > (TARGETS_ROW * TARGETS_COL)) {
      pEconomyDlg->pActiveWidgetList = pEconomyDlg->pEndActiveWidgetList;
      count = create_vertical_scrollbar(pEconomyDlg, TARGETS_COL, TARGETS_ROW,
                                        TRUE, TRUE);
      h += (TARGETS_ROW * pBuf->size.h + adj_size(10));
    } else {
      count = 0;
      if (entries_used > TARGETS_COL) {
        h += pBuf->size.h;
      }
      h += (adj_size(10) + pBuf->size.h);
    }
    count = TARGETS_COL * pBuf->size.w + count;
  } else {
    pEconomyDlg->pBeginWidgetList = pBuf;
    h += adj_size(10);
    count = 0;
  }

  area.w = MAX(area.w, MAX(adj_size(10) + w3 + w + w2, count));
  area.h = h;

  pBackground = theme_get_background(theme, BACKGROUND_ECONOMYDLG);
  if (resize_window(pWindow, pBackground, NULL,
                    (pWindow->size.w - pWindow->area.w) + area.w,
                    (pWindow->size.h - pWindow->area.h) + area.h)) {
    FREESURFACE(pBackground);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + adj_size(10) + pTreasuryText->w;
  pBuf->size.y = area.y + adj_size(5);

  w = pTreasuryText->w + pBuf->size.w;
  h = pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTaxRateText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTaxRateText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalCostText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalCostText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pNetIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pNetIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  dst.x = area.x;
  dst.y = area.y;
  dst.w = area.w;
  dst.h = h + adj_size(15);
  h = dst.h;

  fill_rect_alpha(pWindow->theme, &dst, &bg_color2);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  dst.x = area.x + adj_size(10);
  dst.y = area.y + adj_size(5);

  alphablit(pTreasuryText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTreasuryText->h;
  FREESURFACE(pTreasuryText);

  alphablit(pTaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTaxRateText->h;
  FREESURFACE(pTaxRateText);

  alphablit(pTotalIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalIncomeText->h;
  FREESURFACE(pTotalIncomeText);

  alphablit(pTotalCostText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalCostText->h;
  FREESURFACE(pTotalCostText);

  alphablit(pNetIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pNetIncomeText->h;
  FREESURFACE(pNetIncomeText);

  dst.x = area.x + adj_size(10) + w +
          ((area.w - (w + adj_size(10)) - pMaxRateText->w) / 2);
  dst.y = area.y + adj_size(5);

  alphablit(pMaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += (pMaxRateText->h + 1);
  FREESURFACE(pMaxRateText);

  dst.x = area.x + adj_size(10) + w +
          (area.w - (w + adj_size(10)) - adj_size(184)) / 2;
  dst.w = adj_size(184);
  dst.h = current_theme->Horiz->h - adj_size(2);

  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.luxury * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  dst.y += current_theme->Horiz->h + 1;
  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.science * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + (dst.w - pBuf->size.w) / 2;
  pBuf->size.y = dst.y + dst.h + adj_size(3);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  if (entries_used > 0) {
    setup_vertical_widgets_position(TARGETS_COL, area.x, area.y + h, 0, 0,
                                    pEconomyDlg->pBeginActiveWidgetList,
                                    pEconomyDlg->pEndActiveWidgetList);
    if (pEconomyDlg->pScroll) {
      setup_vertical_scrollbar_area(pEconomyDlg->pScroll, area.x + area.w - 1,
                                    area.y + h, area.h - h - 1, TRUE);
    }
  }

  redraw_group(pEconomyDlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);
  flush_dirty();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	50	0.15855494141578674
darktable-org-darktable-32fab21/src/iop/flip.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_flip_params_t p = (dt_iop_flip_params_t){ORIENTATION_NONE};
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  p.orientation = ORIENTATION_NULL;
  dt_gui_presets_add_generic(_(""autodetect""), self->op, self->version(), &p,
                             sizeof(p), 1);
  dt_gui_presets_update_autoapply(_(""autodetect""), self->op, self->version(),
                                  1);

  p.orientation = ORIENTATION_NONE;
  dt_gui_presets_add_generic(_(""no rotation""), self->op, self->version(), &p,
                             sizeof(p), 1);

  p.orientation = ORIENTATION_FLIP_HORIZONTALLY;
  dt_gui_presets_add_generic(_(""flip horizontally""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_FLIP_VERTICALLY;
  dt_gui_presets_add_generic(_(""flip vertically""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by -90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CCW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by  90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_180_DEG;
  dt_gui_presets_add_generic(_(""rotate by 180 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.0652509331703186
DelusionalLogic-NeoComp-271e784/src/compton.c	Do the actual work.	2	"void session_run(session_t *ps) {
#ifdef DEBUG_PROFILE
  struct ProfilerWriterSession profSess;
  profilerWriter_init(&profSess);
#endif

  paint_preprocess(ps);

  timestamp lastTime;
  if (!getTime(&lastTime)) {
    printf_errf(""Failed getting time"");
    session_destroy(ps);
    exit(1);
  }

  assign_depth(&ps->win_list, &ps->order);

  ps->idling = false;

  while (!ps->reset) {

    zone_start(&ZONE_global);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    zone_enter(&ZONE_input);

    while (mainloop(ps))
      ;

    Swiss *em = &ps->win_list;

    for_components(it, em, COMPONENT_PHYSICAL, COMPONENT_TRACKS_WINDOW,
                   COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct TracksWindowComponent *window =
          swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);

      XWindowAttributes attribs;
      if (!XGetWindowAttributes(ps->xcontext.display, window->id, &attribs)) {
        printf_errf(""Failed getting window attributes while mapping"");
        swiss_removeComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
        continue;
      }

      Vector2 extents = {{attribs.width + attribs.border_width * 2,
                          attribs.height + attribs.border_width * 2}};

      Vector2 offset = {{-attribs.border_width, -attribs.border_width}};

      XserverRegion window_region = XFixesCreateRegionFromWindow(
          ps->xcontext.display, window->id, ShapeBounding);

      XRectangle default_clip = {.x = offset.x,
                                 .y = offset.y,
                                 .width = extents.x,
                                 .height = extents.y};
      XserverRegion default_clip_region =
          XFixesCreateRegion(ps->xcontext.display, &default_clip, 1);
      XFixesIntersectRegion(ps->xcontext.display, window_region, window_region,
                            default_clip_region);

      int rect_count;
      XRectangle *rects =
          XFixesFetchRegion(ps->xcontext.display, window_region, &rect_count);

      XFixesDestroyRegion(ps->xcontext.display, window_region);

      vector_init(&shapeDamaged->rects, sizeof(struct Rect), rect_count);

      convert_xrects_to_relative_rect(rects, rect_count, &extents, &offset,
                                      &shapeDamaged->rects);
    }

    zone_leave(&ZONE_input);

    timestamp currentTime;
    if (!getTime(&currentTime)) {
      printf_errf(""Failed getting time"");
      exit(1);
    }

    double dt = timeDiff(&lastTime, &currentTime);

    ps->skip_poll = false;

    if (ps->o.benchmark) {
      if (ps->o.benchmark_wid) {
        win *w = find_win(ps, ps->o.benchmark_wid);
        if (!w) {
          printf_errf(""(): Couldn't find specified benchmark window."");
          session_destroy(ps);
          exit(1);
        }
      }
    }

    ps->idling = true;

    zone_enter(&ZONE_preprocess);

    paint_preprocess(ps);

    zone_leave(&ZONE_preprocess);

    zone_enter(&ZONE_update);

    zone_enter(&ZONE_update_z);
    assign_depth(&ps->win_list, &ps->order);
    zone_leave(&ZONE_update_z);

    zone_enter(&ZONE_update_wintype);

    for_components(it, em, COMPONENT_MAP, CQ_END) {
      swiss_addComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
    }

    fill_wintype_changes(&ps->win_list, ps);

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      swiss_ensureComponent(em, COMPONENT_FOCUS_CHANGE, it.id);
    }

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      struct WintypeChangedComponent *wintypeChanged =
          swiss_getComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
      struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

      w->window_type = wintypeChanged->newType;
    }
    zone_leave(&ZONE_update_wintype);

    if (ps->o.shadow_blacklist) {
      zone_enter(&ZONE_update_shadow_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->shadow = (ps->o.wintype_shadow[w->window_type] &&
                       !win_match(ps, w, ps->o.shadow_blacklist) &&
                       !(ps->o.respect_prop_shadow));
        }
      }
      zone_leave(&ZONE_update_shadow_blacklist);
    }

    if (ps->o.fade_blacklist) {
      zone_enter(&ZONE_update_fade_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

        if (win_mapped(em, it.id)) {

          if (win_match(ps, w, ps->o.fade_blacklist)) {
            w->fade = false;
          } else {
            w->fade = ps->o.wintype_fade[w->window_type];
          }
        }
      }
      zone_leave(&ZONE_update_fade_blacklist);
    }

    if (ps->o.blur_background_blacklist) {
      zone_enter(&ZONE_update_blur_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          bool blur_background_new =
              ps->o.blur_background &&
              !win_match(ps, w, ps->o.blur_background_blacklist);

          win_set_blur_background(ps, w, blur_background_new);
        }
      }
      zone_leave(&ZONE_update_blur_blacklist);
    }

    if (ps->o.paint_blacklist) {
      zone_enter(&ZONE_update_paint_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->paint_excluded = win_match(ps, w, ps->o.paint_blacklist);
        }
      }
      zone_leave(&ZONE_update_paint_blacklist);
    }

    zone_enter(&ZONE_input_react);
    commit_destroy(&ps->win_list);
    commit_map(&ps->win_list, &ps->atoms, &ps->xcontext);
    commit_unmap(&ps->win_list, &ps->xcontext);
    commit_opacity_change(&ps->win_list, ps->o.opacity_fade_time,
                          ps->o.bg_opacity_fade_time);
    commit_move(&ps->win_list, &ps->order);
    commit_resize(&ps->win_list, &ps->order);
    commit_reshape(&ps->win_list, &ps->xcontext);
    zone_leave(&ZONE_input_react);

    zone_enter(&ZONE_make_cutout);
    {
      XserverRegion newShape = XFixesCreateRegion(ps->dpy, NULL, 0);
      for_components(it, em, COMPONENT_MUD, COMPONENT_TRACKS_WINDOW,
                     COMPONENT_PHYSICAL, CQ_NOT, COMPONENT_REDIRECTED, CQ_END) {
        struct TracksWindowComponent *tracksWindow =
            swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
        struct PhysicalComponent *physical =
            swiss_getComponent(em, COMPONENT_PHYSICAL, it.id);

        if (win_mapped(em, it.id)) {
          XserverRegion windowRegion = XFixesCreateRegionFromWindow(
              ps->xcontext.display, tracksWindow->id, ShapeBounding);
          XFixesTranslateRegion(ps->dpy, windowRegion, physical->position.x + 1,
                                physical->position.y + 1);
          XFixesUnionRegion(ps->xcontext.display, newShape, newShape,
                            windowRegion);
          XFixesDestroyRegion(ps->xcontext.display, windowRegion);
        }
      }
      XFixesInvertRegion(ps->dpy, newShape,
                         &(XRectangle){0, 0, ps->root_size.x, ps->root_size.y},
                         newShape);
      XFixesSetWindowShapeRegion(ps->dpy, ps->overlay, ShapeBounding, 0, 0,
                                 newShape);
      XFixesDestroyRegion(ps->xcontext.display, newShape);
    }
    zone_leave(&ZONE_make_cutout);

    zone_enter(&ZONE_prop_blur_damage);
    damage_blur_over_damaged(&ps->win_list, &ps->order);
    zone_leave(&ZONE_prop_blur_damage);

    zone_enter(&ZONE_update_textures);
    update_window_textures(&ps->win_list, &ps->xcontext,
                           &ps->psglx->shared_fbo);
    zone_leave(&ZONE_update_textures);

    update_focused_state(&ps->win_list, ps);
    calculate_window_opacity(ps, &ps->win_list);
    start_focus_fade(&ps->win_list, ps->o.opacity_fade_time,
                     ps->o.bg_opacity_fade_time, ps->o.dim_fade_time);

    zone_enter(&ZONE_update_fade);

    damage_blur_over_fade(&ps->win_list);
    syncronize_fade_opacity(&ps->win_list);
    if (do_win_fade(&ps->curve, dt, &ps->win_list)) {
      ps->skip_poll = true;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      t->time += dt;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      if (t->time >= t->duration)
        swiss_removeComponent(em, COMPONENT_TRANSITIONING, it.id);
    }

    zone_leave(&ZONE_update_fade);

    transition_faded_entities(&ps->win_list);
    remove_texture_invis_windows(&ps->win_list);
    finish_destroyed_windows(&ps->win_list, ps);
    zone_leave(&ZONE_update);

    Vector opaque;
    vector_init(&opaque, sizeof(win_id), ps->order.size);
    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED, CQ_NOT,
                   COMPONENT_BGOPACITY, COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&opaque, &it.id);
    }
    vector_qsort(&opaque, window_zcmp, &ps->win_list);
    Vector transparent;
    vector_init(&transparent, sizeof(win_id), ps->order.size);

    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED,
                   COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&transparent, &it.id);
    }
    vector_qsort(&transparent, window_zcmp, &ps->win_list);

    Vector opaque_shadow;
    vector_init(&opaque_shadow, sizeof(win_id), ps->order.size);
    fetchSortedWindowsWith(&ps->win_list, &opaque_shadow, COMPONENT_MUD,
                           COMPONENT_Z, COMPONENT_PHYSICAL, CQ_NOT,
                           COMPONENT_OPACITY, COMPONENT_SHADOW, CQ_END);

    zone_enter(&ZONE_effect_textures);

    zone_enter(&ZONE_update_shadow);
    windowlist_updateShadow(ps, &transparent);
    zone_leave(&ZONE_update_shadow);

    if (ps->o.blur_background)
      windowlist_updateBlur(ps);

    zone_leave(&ZONE_effect_textures);

    {
      static int paint = 0;

      zone_enter(&ZONE_paint);

      glDepthMask(GL_TRUE);
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      static const GLenum DRAWBUFS[2] = {GL_BACK_LEFT};
      glDrawBuffers(1, DRAWBUFS);
      glViewport(0, 0, ps->root_size.x, ps->root_size.y);

      glClearDepth(1.0);
      glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
      glDepthFunc(GL_LESS);

      windowlist_drawBackground(ps, &opaque);
      windowlist_drawTint(ps);
      windowlist_draw(ps, &opaque);

      paint_root(ps);

      windowlist_drawTransparent(ps, &transparent);

#ifdef DEBUG_WINDOWS

      draw_component_debug(&ps->win_list, &ps->root_size);
#endif

      vector_kill(&opaque_shadow);
      vector_kill(&transparent);
      vector_kill(&opaque);

      zone_leave(&ZONE_paint);

      paint++;
      if (ps->o.benchmark && paint >= ps->o.benchmark) {
#ifdef DEBUG_PROFILE
        profilerWriter_kill(&profSess);
#endif
        session_destroy(ps);
        exit(0);
      }
    }

    zone_enter(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_MAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_UNMAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_MOVE);
    swiss_removeComponentWhere(
        &ps->win_list, COMPONENT_RESIZE,
        (enum ComponentType[]){COMPONENT_PHYSICAL, CQ_END});

    swiss_resetComponent(em, COMPONENT_WINTYPE_CHANGE);

    swiss_resetComponent(&ps->win_list, COMPONENT_FOCUS_CHANGE);

    for_components(it, em, COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
      if (shapeDamaged->rects.elementSize != 0) {
        vector_kill(&shapeDamaged->rects);
      }
    }
    swiss_resetComponent(&ps->win_list, COMPONENT_SHAPE_DAMAGED);

    zone_leave(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_CONTENTS_DAMAGED);

#ifdef FRAMERATE_DISPLAY
    update_debug_graph(&ps->debug_graph, currentTime);
    draw_debug_graph(&ps->debug_graph, &(Vector2){{10, ps->root_size.y - 10}});
#endif

    struct ZoneEventStream *event_stream = zone_package(&ZONE_global);
#ifdef DEBUG_PROFILE

    profilerWriter_emitFrame(&profSess, event_stream);
#endif

    glXSwapBuffers(ps->dpy, get_tgt_window(ps));
    glFinish();

    lastTime = currentTime;
  }

#ifdef DEBUG_PROFILE
  profilerWriter_kill(&profSess);
#endif
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11606746166944504
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t),
                           NO_STREAM_CALLBACK);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
      NO_STREAM_CALLBACK);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1318480670452118
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities.	1	"uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
                          SCSI_Inquiry_Response_t *const InquiryPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, InquiryPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.14311006665229797
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Publishes the message to the current process and frees the strings.	2	"static void fio_publish2process(fio_msg_internal_s *m) {
  fio_msg_internal_finalize(m);
  channel_s *ch;
  if (m->filter) {
    ch = fio_filter_find_dup(m->filter);
    if (!ch) {
      goto finish;
    }
  } else {
    ch = fio_channel_find_dup(m->channel);
  }

  if (ch) {
    fio_defer_push_urgent(fio_publish2channel_task, ch,
                          fio_msg_internal_dup(m));
  }
  if (m->filter == 0) {

    fio_lock(&fio_postoffice.patterns.lock);
    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {
      if (!p->hash) {
        continue;
      }

      if (p->obj->match(
              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},
              m->channel)) {
        fio_channel_dup(p->obj);
        fio_defer_push_urgent(fio_publish2channel_task, p->obj,
                              fio_msg_internal_dup(m));
      }
    }
    fio_unlock(&fio_postoffice.patterns.lock);
  }
finish:
  fio_msg_internal_free(m);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.22175849974155426
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/macsub.c	Returns a macro substitution result wrapping a silent error as produced by ava_macsub_silent_error().	2	"ava_macro_subst_result
ava_macsub_silent_error_result(const ava_compile_location *location) {
  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = ava_macsub_silent_error(location)};
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	None_output	0.08828341215848923
opticron-libuweave-2e5e385/src/ble_transport.c	Initializes a BLE transport service to handle BLE input and registers it in the runloop.	0	"bool uw_ble_transport_init(UwBleTransport *transport, UwDevice *device) {
  assert(transport != NULL && device != NULL);

  memset(transport, 0, sizeof(UwBleTransport));
  transport->device = device;

  uw_buffer_init(&transport->read_buffer, transport->read_data,
                 sizeof(transport->read_data));

  uw_buffer_init(&transport->write_buffer, transport->write_data,
                 sizeof(transport->write_data));

  uw_session_init_(&transport->session, device);

  uw_device_channel_init_(
      &transport->device_channel,
      (UwDeviceChannelHandshakeConfig){.handler = handshake_exchange_handler_,
                                       .data = (void *)transport},
      (UwDeviceChannelConnectionResetConfig){
          .handler = connection_reset_handler_, .data = (void *)transport},
      &transport->read_buffer, &transport->write_buffer, UW_BLE_PACKET_SIZE);

  uw_service_init_(&transport->service, service_start_handler_,
                   service_event_handler_, service_stop_handler_, transport);

  uw_device_register_service_(transport->device, &transport->service);

  UwSettings *settings = uw_device_get_settings(transport->device);
  settings->supports_ble_40 = true;

  return true;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11496470123529434
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command.	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11281387507915497
graphitemaster-redroid-9cdd940/string.c	Constructs an empty managed string object.	2	"string_t *string_construct(void) {
  string_t *string =
      memcpy(malloc(sizeof(string_t)),
             &(string_t){.buffer = malloc(8), .allocated = 8, .length = 0},
             sizeof(string_t));
  *string->buffer = '\0';
  return string;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.12414924800395966
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/MassStorageHost.c	Task to set the configuration of the attached device after it has been enumerated, and to read in blocks from the device and print them to the serial port.	1	"TASK(USB_MassStore_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Mass Storage Disk Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    UpdateStatus(Status_Busy);

    if ((ErrorCode = MassStore_GetMaxLUN(&MassStore_MaxLUNIndex)) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Get Max LUN""), false, ErrorCode);
      break;
    }

    printf_P(PSTR(""Total LUNs: %d.\r\n""), (MassStore_MaxLUNIndex + 1));

    if ((ErrorCode = MassStore_MassStorageReset()) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Mass Storage Reset""), false, ErrorCode);
      break;
    }

    SCSI_Request_Sense_Response_t SenseData;
    if (((ErrorCode = MassStore_RequestSense(0, &SenseData)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Request Sense""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    if (((ErrorCode = MassStore_PreventAllowMediumRemoval(0, true)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Prevent/Allow Medium Removal""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""Waiting until ready..""));

    do {
      Serial_TxByte('.');

      if ((ErrorCode = MassStore_TestUnitReady(0)) != 0) {
        ShowDiskReadError(PSTR(""Test Unit Ready""), false, ErrorCode);
        break;
      }
    } while ((SCSICommandStatus.Status != Command_Pass) && USB_IsConnected);

    if (!(USB_IsConnected))
      break;

    puts_P(PSTR(""\r\nRetrieving Capacity... ""));

    SCSI_Capacity_t DiskCapacity;

    if (((ErrorCode = MassStore_ReadCapacity(0, &DiskCapacity)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Capacity""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    printf_P(PSTR(""%lu blocks of %lu bytes.\r\n""), DiskCapacity.Blocks,
             DiskCapacity.BlockSize);

    uint8_t BlockBuffer[DiskCapacity.BlockSize];

    if (((ErrorCode = MassStore_ReadDeviceBlock(
              0, 0x00000000, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Device Block""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""\r\nContents of first block:\r\n""));

    for (uint16_t Chunk = 0; Chunk < (DiskCapacity.BlockSize >> 4); Chunk++) {

      uint8_t *ChunkPtr = &BlockBuffer[Chunk << 4];

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        printf_P(PSTR(""%.2X ""), CurrByte);
      }

      puts_P(PSTR(""    ""));

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      puts_P(PSTR(""\r\n""));
    }

    puts_P(PSTR(""\r\n\r\nPress board button to read entire ASCII contents of ""
                ""disk...\r\n\r\n""));

    while (!(Buttons_GetStatus() & BUTTONS_BUTTON1)) {

      if (!(USB_IsConnected))
        break;
    }

    for (uint32_t CurrBlock = 0; CurrBlock < DiskCapacity.Blocks; CurrBlock++) {

      if (((ErrorCode = MassStore_ReadDeviceBlock(
                0, CurrBlock, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
          (SCSICommandStatus.Status != Command_Pass)) {
        ShowDiskReadError(PSTR(""Read Device Block""),
                          (SCSICommandStatus.Status != Command_Pass),
                          ErrorCode);
        break;
      }

      for (uint16_t Byte = 0; Byte < DiskCapacity.BlockSize; Byte++) {
        char CurrByte = BlockBuffer[Byte];

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      if (!(USB_IsConnected))
        break;
    }

    UpdateStatus(Status_USBReady);

    while (USB_IsConnected)
      ;

    break;
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1259002536535263
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_ps(float __a, float __b, float __c, float __d, float __e, float __f,
               float __g, float __h) {
  return (__m256){__a, __b, __c, __d, __e, __f, __g, __h};
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.21590682864189148
pgrawehr-golgotha-5d70da4/string/string.h	Attempts to convert the string to a number.	2	"i4_str *read_string();

w32 read_ascii(char *buffer, w32 buffer_size);

sw32 read_number(i4_bool throwexception = i4_F);

double read_float(i4_bool throwexception = i4_F);
}
;

virtual ~i4_const_str(){};

const iterator end() const { return ptr + len; }
iterator end() { return ptr + len; }

const iterator begin() const { return ptr; }
iterator begin() { return ptr; }

w32 length() const { return len; }"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1778942495584488
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Close a stream	2	"void stream_close(pony_ctx_t **ctx, stream_t *s) {
  struct scons *scons = scons_mk(*ctx, NULL);
  scons->eos = true;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.17239636182785034
HarveyHunt-howm-81b1d82/src/monitor.c	Create a single monitor for use with default X11.	2	"static void scan_x11_monitor(void) {
  monitor_t *m =
      create_monitor((xcb_rectangle_t){0, 0, screen_width, screen_height});

  add_ws(m);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.0037217475473880768
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, BlockBuffer);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.08239628374576569
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/CDC.c	Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.	2	"uint8_t CDC_Host_SendBreak(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo,
                           const uint8_t Duration) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SendBreak,
      .wValue = Duration,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.2133704125881195
ikeydoherty-ui-tests-41140ce/src/popover.c	Work out the geometry for the relative_to widget in absolute coordinates on the screen.	2	"static void budgie_popover_compute_widget_geometry(GtkWidget *parent_widget,
                                                   GdkRectangle *target) {
  GtkAllocation alloc = {0};
  GtkWidget *toplevel = NULL;
  GdkWindow *toplevel_window = NULL;
  gint rx, ry = 0;
  gint x, y = 0;

  if (!parent_widget) {
    g_warning(""compute_widget_geometry(): missing relative_widget"");
    return;
  }

  toplevel = gtk_widget_get_toplevel(parent_widget);
  toplevel_window = gtk_widget_get_window(toplevel);
  gdk_window_get_position(toplevel_window, &x, &y);
  gtk_widget_translate_coordinates(parent_widget, toplevel, x, y, &rx, &ry);
  gtk_widget_get_allocation(parent_widget, &alloc);

  *target = (GdkRectangle){
      .x = rx, .y = ry, .width = alloc.width, .height = alloc.height};
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.023544427007436752
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/hash-map-impl.c	Builds a new hash table for the given hash map. A call to ava_hash_map_vacuum() is implied.	2	"static size_t ava_hash_map_rehash(ava_hash_map *restrict map,
                                  size_t num_elements, ava_bool permit_ascii9) {
  size_t i, orig_num_elements;
  size_t new_size AVA_UNUSED;
  ava_list_value keys;
  ava_hash_map_hash_function preferred_hash_function;
  ava_bool vacuumed;
  const ava_hash_map_index *restrict old_index = map->index;

  orig_num_elements = num_elements;
  num_elements = ava_hash_map_vacuum(map, num_elements);
  vacuumed = orig_num_elements != num_elements;

  keys = (ava_list_value){ava_value_with_ulong(map->keys, num_elements)};

  if (NULL != map->index || num_elements > ASCII9_SIZE_THRESH) {
    preferred_hash_function = map->index->hash_function;
  } else {
    preferred_hash_function = ava_hmhf_ascii9;
    for (i = 0; i < num_elements && preferred_hash_function != ava_hmhf_value;
         ++i) {
      if (!is_ascii9_string(map->esba_trait->index(keys, i))) {
        preferred_hash_function = ava_hmhf_value;
      }
    }
  }

  map->index = ava_hash_map_index_new(desired_capacity(num_elements));
  map->index->num_elements = 0;
  map->index->hash_function =
      permit_ascii9 ? preferred_hash_function : ava_hmhf_value;
  memset(map->index->indices, -1, sizeof(TYPE) * (map->index->mask + 1));

  if (old_index && !vacuumed &&
      map->index->hash_function == old_index->hash_function) {

    for (i = 0; i < num_elements; ++i) {
      map->index->hash_cache[i] = old_index->hash_cache[i];
      ava_hash_map_put_direct(map, i, old_index->hash_cache[i]);
    }
    map->index->num_elements = num_elements;
  } else {
    for (i = 0; i < num_elements; ++i) {
      new_size = ava_hash_map_put(map, i, map->esba_trait->index(keys, i));
      assert(i + 1 == new_size);
      ++map->index->num_elements;
    }
  }

  return num_elements;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.05516025424003601
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer.	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.09929417073726654
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_rate_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  uint32_t *clock_rate;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int error_code;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_rate_get, clock_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
        clock_protocol_data.num_clocks;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
          clock_id;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      clock_rate =
          &(received.payload[OFFSET_RET(struct arm_scmi_clock_rate_get, rate)]);
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.lower,
          clock_rate[0], ""CLOCK RATE LOWER"");
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.upper,
          clock_rate[1], ""CLOCK RATE UPPER"");
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.0922601968050003
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/maps.c	Create a new definite map	2	"cbor_item_t *cbor_new_definite_map(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = size,
                                    .type = _CBOR_METADATA_DEFINITE,
                                    .end_ptr = 0}},
      .data = _cbor_alloc_multiple(sizeof(struct cbor_pair), size)};
  if (item->data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }
  return item;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.020232463255524635
PJK-libcbor-87f977e/src/cbor/arrays.c	Create new indefinite array	2	"cbor_item_t *cbor_new_indefinite_array() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                      .allocated = 0,
                                      .end_ptr = 0}},
      .data = NULL};
  return item;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.012446623295545578
freeciv-freeciv-e4ead30/client/gui-sdl2/plrdlg.c	Popup (or raise) the player list dialog.	2	"void popup_players_dialog(bool raise) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL, *pZoomed = NULL;
  utf8_str *pstr;
  SDL_Rect dst;
  int i, n, h;
  double a, b, r;
  SDL_Rect area;

  if (pPlayers_Dlg) {
    return;
  }

  n = 0;
  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }
    n++;
  }
  players_iterate_end;

  if (n < 2) {
    return;
  }

  pPlayers_Dlg = fc_calloc(1, sizeof(struct SMALL_DLG));

  pstr = create_utf8_from_char(Q_(""?header:Players""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = players_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_WINDOW, pWindow);
  pPlayers_Dlg->pEndWidgetList = pWindow;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  pBuf->action = exit_players_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_BUTTON, pBuf);

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_NEUTRAL_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_neutral_status_callback;
      pBuf->key = SDLK_n;
      break;
    case DS_WAR:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_WAR_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_war_status_callback;
      pBuf->key = SDLK_w;
      break;
    case DS_CEASEFIRE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_CEASEFIRE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_ceasefire_status_callback;
      pBuf->key = SDLK_c;
      break;
    case DS_PEACE:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_PEACE_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_peace_status_callback;
      pBuf->key = SDLK_p;
      break;
    case DS_ALLIANCE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_ALLIANCE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_alliance_status_callback;
      pBuf->key = SDLK_a;
      break;
    default:

      continue;
      break;
    }
    set_wstate(pBuf, FC_WS_NORMAL);
    add_to_gui_list(ID_CHECKBOX, pBuf);
  }

  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

    pLogo = get_nation_flag_surface(nation_of_player(pPlayer));
    {

      double zoom = DEFAULT_ZOOM * (60.0 - n) / pLogo->h;

      pZoomed = zoomSurface(pLogo, zoom, zoom, 1);
    }

    pBuf = create_icon2(pZoomed, pWindow->dst,
                        WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                            WF_FREE_THEME);
    pBuf->info_label = pstr;

    if (!pPlayer->is_alive) {
      pstr = create_utf8_from_char(_(""R.I.P.""), adj_font(10));
      pstr->style |= TTF_STYLE_BOLD;
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_TEXT);
      pLogo = create_text_surf_from_utf8(pstr);
      FREEUTF8STR(pstr);

      dst.x = (pZoomed->w - pLogo->w) / 2;
      dst.y = (pZoomed->h - pLogo->h) / 2;
      alphablit(pLogo, NULL, pZoomed, &dst, 255);
      FREESURFACE(pLogo);
    }

    if (pPlayer->is_alive) {
      set_wstate(pBuf, FC_WS_NORMAL);
    }

    pBuf->data.player = pPlayer;

    pBuf->action = player_callback;

    add_to_gui_list(ID_LABEL, pBuf);
  }
  players_iterate_end;

  pPlayers_Dlg->pBeginWidgetList = pBuf;

  resize_window(pWindow, NULL, NULL, adj_size(500), adj_size(400));

  area = pWindow->area;

  r = MIN(area.w, area.h);
  r -= ((MAX(pBuf->size.w, pBuf->size.h) * 2));
  r /= 2;
  a = (2.0 * M_PI) / n;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  n = area.y;
  pstr = create_utf8_str(NULL, 0, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ARMISTICE);
      break;
    case DS_WAR:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_WAR);
      break;
    case DS_CEASEFIRE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_CEASEFIRE);
      break;
    case DS_PEACE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_PEACE);
      break;
    case DS_ALLIANCE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ALLIANCE);
      break;
    default:

      continue;
      break;
    }

    copy_chars_to_utf8_str(pstr, diplstate_type_translated_name(i));
    pLogo = create_text_surf_from_utf8(pstr);

    pBuf = pBuf->prev;
    h = MAX(pBuf->size.h, pLogo->h);
    pBuf->size.x = area.x + adj_size(5);
    pBuf->size.y = n + (h - pBuf->size.h) / 2;

    dst.x = adj_size(5) + pBuf->size.w + adj_size(6);
    dst.y = n + (h - pLogo->h) / 2;
    alphablit(pLogo, NULL, pWindow->theme, &dst, 255);
    n += h;
    FREESURFACE(pLogo);
  }
  FREEUTF8STR(pstr);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 - pBuf->size.w / 2;
  pBuf->size.y = area.y + area.h / 2 - r - pBuf->size.h / 2;

  n = 1;
  if (pBuf != pPlayers_Dlg->pBeginWidgetList) {
    do {
      pBuf = pBuf->prev;
      b = M_PI_2 + n * a;
      pBuf->size.x = area.x + area.w / 2 - r * cos(b) - pBuf->size.w / 2;
      pBuf->size.y = area.y + area.h / 2 - r * sin(b) - pBuf->size.h / 2;
      n++;
    } while (pBuf != pPlayers_Dlg->pBeginWidgetList);
  }

  players_dialog_update();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.10448208451271057
darktable-org-darktable-32fab21/src/iop/borders.c	this is the chance to update default parameters, after the full raw is loaded.	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_borders_params_t tmp =
      (dt_iop_borders_params_t){{1.0f, 1.0f, 1.0f},
                                DT_IOP_BORDERS_ASPECT_CONSTANT_VALUE,
                                ""constant border"",
                                0,
                                0.1f,
                                0.5f,
                                ""1/2"",
                                0.5f,
                                ""1/2"",
                                0.0f,
                                0.5f,
                                {0.0f, 0.0f, 0.0f},
                                TRUE};
  memcpy(self->params, &tmp, sizeof(dt_iop_borders_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_borders_params_t));
  self->default_enabled = 0;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.13370418548583984
xipengwang-FLAG-cd1815e/april2/src/vx/vxo_sphere.c	In this implementation, the only data passed to the shader are the texture coordinates. These texture coordinates can be trivially converted into latitude and longitude, but are adjusted so that the triangles render textures properly across the longitude=PI boundary. The shader computes lat/lon from the shader coordinates, then computes xyz.	2	"vx_object_t *vxo_sphere_textured(vx_resource_t *texture_resource) {
  static vx_resource_t *program_resource = NULL;
  static vx_resource_t *sts_resource = NULL;
  static vx_resource_t *tris_resource = NULL;
  static int nvertices = 0, napositions = 0;

  vx_lock();

  if (program_resource == NULL) {

    zarray_t *vertex_datas = zarray_create(sizeof(struct vertex_data));
    zarray_t *tris = zarray_create(sizeof(uint16_t[3]));

    const double v = sqrt(3) / 3;
    double *xyza = (double[]){v, v, v};
    double *xyzb = (double[]){-v, -v, v};
    double *xyzc = (double[]){-v, v, -v};
    double *xyzd = (double[]){v, -v, -v};

    int depth = 4;

    recurse(vertex_datas, tris, xyza, xyzc, xyzb, depth);
    recurse(vertex_datas, tris, xyza, xyzb, xyzd, depth);
    recurse(vertex_datas, tris, xyza, xyzd, xyzc, depth);
    recurse(vertex_datas, tris, xyzb, xyzc, xyzd, depth);

    zarray_t *sts = zarray_create(sizeof(float[2]));

    for (int i = 0; i < zarray_size(vertex_datas); i++) {
      struct vertex_data *vd;
      zarray_get_volatile(vertex_datas, i, &vd);

      float *st = (float[]){vd->st[0], vd->st[1]};

      zarray_add(sts, st);
    }

    nvertices = zarray_size(tris) * 3;

    char vertex_shader_src[] =
        ""#define PI 3.14159265358979323846264338\n""
        ""attribute vec2 st; \n""
        ""varying vec2 vtexcoord; \n""
        ""uniform mat4 VX_P;\n""
        ""uniform mat4 VX_V;\n""
        ""uniform mat4 VX_M;\n""
        ""void main(void) {\n""
        ""  float lat = (PI / 2.0) - PI * st.y; \n ""
        ""  float lon = 2.0 * PI * st.x; \n ""
        ""  vtexcoord = st.xy; \n""
        ""  float r = cos(lat); \n ""
        ""  vec3 xyz = vec3(r*cos(lon), r*sin(lon), sin(lat)); \n ""
        ""  gl_Position = VX_P * VX_V * VX_M * vec4(xyz, 1.0);\n""
        ""}"";

    char fragment_shader_src[] = ""precision mediump float; \n""
                                 ""varying vec2 vtexcoord; \n""
                                 ""uniform sampler2D texture; \n""
                                 ""void main(void) {\n""
                                 ""  vec4 c = texture2D(texture, vtexcoord);\n""
                                 ""  gl_FragColor = vec4(c.r, c.g, c.b, 1);\n""
                                 ""}\n"";

    program_resource =
        vx_resource_make_program(vertex_shader_src, fragment_shader_src);
    program_resource->incref(program_resource);

    sts_resource = vx_resource_make_attr_f32_copy((float *)sts->data,
                                                  zarray_size(sts) * 2, 2);
    sts_resource->incref(sts_resource);

    tris_resource =
        vx_resource_make_idx_u16_copy((uint16_t *)tris->data, nvertices);
    tris_resource->incref(tris_resource);
  }

  vx_unlock();

  return vxo_generic_create(
      program_resource, (struct vxo_generic_uniformf[]){{.name = NULL}},
      (struct vxo_generic_attribute[]){{.name = ""st"", .resource = sts_resource},
                                       {.name = NULL}},
      (struct vxo_generic_texture[]){
          {.name = ""texture"", .resource = texture_resource}, {.name = NULL}},
      (struct vxo_generic_draw[]){
          {.command = VX_GL_TRIANGLES,
           .first = 0,
           .count = nvertices,
           .indices_resource = tris_resource},
          {.count = 0},
      });
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.007177297025918961
AsydSolutions-monit-9e43388/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVh"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""id"", no_argument, NULL, 'i'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""version"", no_argument, NULL, 'V'},
                              {""help"", no_argument, NULL, 'h'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.controlfile = Str_dup(f);
      break;
    }
    case 'd': {
      Run.isdaemon = true;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.logfile = Str_dup(optarg);
      if (IS(Run.logfile, ""syslog""))
        Run.use_syslog = true;
      Run.dolog = true;
      break;
    }
    case 'p': {
      Run.pidfile = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.statefile = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.init = true;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.idfile);
      Util_monitId(Run.idfile);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.04537227004766464
braice-MuMuDVB-745259a/src/sap.c	Initialize sap variables	2	"void init_sap_v(sap_p_t *sap_p) {
  *sap_p = (sap_p_t){
      .sap_messages4 = NULL,
      .sap_messages6 = NULL,
      .sap = OPTION_UNDEFINED,
      .sap_interval = SAP_DEFAULT_INTERVAL,
      .sap_sending_ip4 = ""0.0.0.0"",
      .sap_sending_ip6 = ""::"",
      .sap_default_group = """",
      .sap_organisation = ""MuMuDVB"",
      .sap_uri = ""\0"",
      .sap_ttl = SAP_DEFAULT_TTL,
  };
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.0040854718536138535
RfidResearchGroup-proxmark3-1650889/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLogEx(WARNING, ""missing addr"");
    return 0;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    req[reqlen++] = iso15cmd;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    if (!getUID(uid)) {
      PrintAndLogEx(WARNING, ""No tag found"");
      return 0;
    }
    memcpy(&req[reqlen], uid, sizeof(uid));
    PrintAndLogEx(NORMAL, ""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += sizeof(uid);
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLogEx(NORMAL, ""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], uid, sizeof(uid));
    reqlen += sizeof(uid);
    break;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.035944223403930664
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c	Clears a stall condition on the given pipe, via a CLEAR FEATURE standard request to the attached device.	1	"uint8_t USB_Host_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_SEL_EndpointHalt,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.14246013760566711
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/pub.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){pub,
                  'p',
                  ""pub"",
                  ""extract the public key from a private key/certificate"",
                  {""[--in file|--keyid hex] [--type rsa|ecdsa|pkcs10|x509]"",
                   ""[--outform der|pem|pgp]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""keyid"", 'x', 1, ""keyid on smartcard of private key""},
                      {""type"", 't', 1, ""type of credential, default: rsa""},
                      {""outform"", 'f', 1, ""encoding of extracted public key""},
                  }});
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11535636335611343
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to zero.	2	_mm256_setzero_pd(void) { return __extension__(__m256d){0, 0, 0, 0}; }	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.07625481486320496
vm6502q-qrack-df6132d/include/qinterface.hpp	"Quantum analog of classical ""XOR"" gate. Takes one qubit input and one classical bit input. Measures the outputBit, then overwrites it with result."	2	"}

virtual ~QInterface(){};

int GetQubitCount() { return qubitCount; }"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.061610110104084015
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Retrieves the device sense data, indicating the current device state and error codes for the previously issued command.	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Request_Sense_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, SenseData);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1645185351371765
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the list parser state struct with data to be parsed.	2	"psyc_parse_list_buffer_set(PsycParseListState *state, const char *buffer,
                           size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.024464575573801994
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the update modifier parser state struct with data to be parsed.	2	"psyc_parse_update_buffer_set(PsycParseUpdateState *state, const char *buffer,
                             size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.04516363888978958
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Construct the metric terms (and optionally the jacobian determinant) terms at the nodes of input type for the volume under consideration.	2	"static void
constructor_volume_metric_terms_T(const char node_type,
                                  struct Solver_Volume_T *const s_vol) {

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Geometry_Element *g_e =
      &((struct Solver_Element *)vol->element)->g_e;

  const int p = s_vol->p_ref;
  const bool curved = vol->curved;
  const int p_g = (curved ? p : 1);

  struct Container {
    struct Multiarray_Operator *cv1_vg_vX;
    const struct Operator *vv0_vm_vX;
    struct Multiarray_T *metrics_vX;
    struct Multiarray_T *jacobian_det_vX;
  } con;
  struct Multiarray_Operator cv1_vg_vm =
      set_MO_from_MO(g_e->cv1_vg_vm[curved], 1, (ptrdiff_t[]){0, 0, p_g, p_g});
  struct Multiarray_Operator cv1_vg_vc =
      set_MO_from_MO(g_e->cv1_vg_vc[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});
  struct Multiarray_Operator cv1_vg_vs =
      set_MO_from_MO(g_e->cv1_vg_vs[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});

  switch (node_type) {
  case 'm':
    con.cv1_vg_vX = &cv1_vg_vm;
    con.vv0_vm_vX = NULL;
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vm;
    con.jacobian_det_vX = NULL;
    break;
  case 'c':
    con.cv1_vg_vX = &cv1_vg_vc;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vc[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vc;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vc;
    break;
  case 's':
    con.cv1_vg_vX = &cv1_vg_vs;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vs[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vs;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vs;
    break;
  default:
    EXIT_ERROR(""Unsupported: %c\n"", node_type);
    break;
  }
  const ptrdiff_t n_vX = con.cv1_vg_vX->data[0]->op_std->ext_0;
  struct Multiarray_T *const jacobian_vX =
      constructor_empty_Multiarray_T('C', 3, (ptrdiff_t[]){n_vX, DIM, DIM});

  const char op_format = get_set_op_format(0);
  const struct const_Multiarray_T *const geom_coef = s_vol->geom_coef;
  for (ptrdiff_t row = 0; row < DIM; ++row)
    mm_NN1C_Operator_Multiarray_T(con.cv1_vg_vX->data[row], geom_coef,
                                  jacobian_vX, op_format, 2, NULL, &row);

  if (node_type == 'm') {
    compute_cofactors_T((struct const_Multiarray_T *)jacobian_vX,
                        con.metrics_vX);
  } else {
    assert(compute_size(s_vol->metrics_vm->order, s_vol->metrics_vm->extents) >
           0);
    const struct const_Multiarray_T *const met_vm = s_vol->metrics_vm;
    resize_Multiarray_T(con.metrics_vX, 3, (ptrdiff_t[]){n_vX, DIM, DIM});
    mm_NN1C_Operator_Multiarray_T(con.vv0_vm_vX, met_vm, con.metrics_vX,
                                  op_format, met_vm->order, NULL, NULL);
  }

  if (con.jacobian_det_vX) {
    const ptrdiff_t *const perm = set_jacobian_permutation(DIM);
    permute_Multiarray_T(jacobian_vX, perm, jacobian_vX->layout);

    compute_detJV_T((struct const_Multiarray_T *)jacobian_vX,
                    con.jacobian_det_vX);
  }
  destructor_Multiarray_T(jacobian_vX);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.013385971076786518
freeciv-freeciv-e4ead30/client/gui-sdl2/mapview.c	Typically an info box is provided to tell the player about the state of their civilization. This function is called when the label is changed.	2	"void update_info_label(void) {
  SDL_Color bg_color = {0, 0, 0, 80};
  SDL_Surface *pTmp = NULL;
  char buffer[512];
#ifdef SMALL_SCREEN
  SDL_Rect area = {0, 0, 0, 0};
#else
  SDL_Rect area = {0, 3, 0, 0};
#endif
  struct utf8_str *ptext;

  if (get_current_client_page() != PAGE_GAME) {
    return;
  }

#ifdef SMALL_SCREEN
  ptext = create_utf8_str(NULL, 0, 8);
#else
  ptext = create_utf8_str(NULL, 0, 10);
#endif

  ptext->style |= TTF_STYLE_BOLD;
  ptext->fgcol = *get_theme_color(COLOR_THEME_MAPVIEW_INFO_TEXT);
  ptext->bgcol = (SDL_Color){0, 0, 0, 0};

  if (NULL != client.conn.playing) {
#ifdef SMALL_SCREEN
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold);
#else
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d Tax: %d Lux: %d Sci: %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold,
                client.conn.playing->economic.tax,
                client.conn.playing->economic.luxury,
                client.conn.playing->economic.science);
#endif

    copy_chars_to_utf8_str(ptext, buffer);
    pTmp = create_text_surf_from_utf8(ptext);

    area.x = (main_window_width() - pTmp->w) / 2 - adj_size(5);
    area.w = pTmp->w + adj_size(8);
    area.h = pTmp->h + adj_size(4);

    SDL_FillRect(Main.gui->surface, &area,
                 map_rgba(Main.gui->surface->format, bg_color));

    create_line(Main.gui->surface, area.x + 1, area.y, area.x + area.w - 2,
                area.y, get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x + 1, area.y + area.h - 1,
                area.x + area.w - 2, area.y + area.h - 1,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    create_line(Main.gui->surface, area.x + area.w - 1, area.y + 1,
                area.x + area.w - 1, area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x, area.y + 1, area.x,
                area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    blit_entire_src(pTmp, Main.gui->surface, area.x + adj_size(5),
                    area.y + adj_size(2));

    dirty_sdl_rect(&area);

    FREESURFACE(pTmp);
  }

  set_indicator_icons(client_research_sprite(), client_warming_sprite(),
                      client_cooling_sprite(), client_government_sprite());

  update_timeout_label();

  FREEUTF8STR(ptext);

  queue_flush();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.09818900376558304
darktable-org-darktable-32fab21/src/iop/lowpass.c	this initializes static, hardcoded presets for this module and is called only once per run of dt.	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""local contrast mask""), self->op, self->version(),
      &(dt_iop_lowpass_params_t){0, 50.0f, -1.0f, 0.0f, 0.0f,
                                 LOWPASS_ALGO_GAUSSIAN, 1},
      sizeof(dt_iop_lowpass_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.0652509331703186
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance limits set command and testing the received values.	3	"void arm_scmi_custom_test_performance_limits_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 3;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_max)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MAX - 1];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_min)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MIN + 1];
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_max)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX] + 1;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_min)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN] - 1;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX - 1];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN + 1];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_SUCCESS
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        ptr_data->domain_runtime_values[domain_id].range_min =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_min)];
        ptr_data->domain_runtime_values[domain_id].range_max =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_max)];
      }
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11823242902755737
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host.	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t));

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;

      FrameIN.FrameInBuffer = true;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t));

      Endpoint_Write_Stream_LE(FrameOUT.FrameData,
                               RNDISPacketHeader.DataLength);

      Endpoint_ClearIN();

      FrameOUT.FrameInBuffer = false;
    }
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.14796647429466248
dm-vdo-kvdo-8df6805/vdo/base/slab.c	Measure and initialize the configuration to use for each slab.	2	"int configureSlab(BlockCount slabSize, BlockCount slabJournalBlocks,
                  SlabConfig *slabConfig) {
  if (slabJournalBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount refBlocks =
      getSavedReferenceCountSize(slabSize - slabJournalBlocks);
  BlockCount metaBlocks = (refBlocks + slabJournalBlocks);

  if (metaBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount dataBlocks = slabSize - metaBlocks;
  if ((slabSize < 1024) && !isPowerOfTwo(dataBlocks)) {
    dataBlocks = ((BlockCount)1 << logBaseTwo(dataBlocks));
  }

  BlockCount flushingThreshold = ((slabJournalBlocks * 3) + 3) / 4;

  BlockCount remaining = slabJournalBlocks - flushingThreshold;
  BlockCount blockingThreshold = flushingThreshold + ((remaining * 5) / 7);

  BlockCount minimalExtraSpace =
      1 + (MAXIMUM_USER_VIOS / SLAB_JOURNAL_FULL_ENTRIES_PER_BLOCK);
  BlockCount scrubbingThreshold = blockingThreshold;
  if (slabJournalBlocks > minimalExtraSpace) {
    scrubbingThreshold = slabJournalBlocks - minimalExtraSpace;
  }
  if (blockingThreshold > scrubbingThreshold) {
    blockingThreshold = scrubbingThreshold;
  }

  *slabConfig =
      (SlabConfig){.slabBlocks = slabSize,
                   .dataBlocks = dataBlocks,
                   .referenceCountBlocks = refBlocks,
                   .slabJournalBlocks = slabJournalBlocks,
                   .slabJournalFlushingThreshold = flushingThreshold,
                   .slabJournalBlockingThreshold = blockingThreshold,
                   .slabJournalScrubbingThreshold = scrubbingThreshold};
  return VDO_SUCCESS;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	-0.0747705027461052
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	Paint menubar.	2	"virtual ~Font(){};

virtual int getHeight() const = 0;

virtual int getAscent() const = 0;

template <typename STR>
int getWidth(const STR s, Size start = 0, Size len = (Size)-1) const {
  return this->getWidth(String(s), start, len);
}

virtual int getWidth(Char c = 'M') const = 0;

virtual int getWidth(const String &s, Size start = 0,
                     Size len = (Size)-1) const {
  int width = 0;
  if (start + len > s.size())
    len = (Size)(s.size() - start);
  while (len--)
    width += getWidth(s[start++]);
  return width;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.08949661254882812
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	Retrieves the current alternative setting for the specified interface, via a GET INTERFACE standard request to the attached device.	1	"uint8_t USB_Host_GetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        uint8_t *const AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetInterface,
      .wValue = 0,
      .wIndex = InterfaceIndex,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(AltSetting);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.03410949185490608
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Device/CDC.c	Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host.	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = CPU_TO_LE16(0),
      .wIndex = CPU_TO_LE16(0),
      .wLength = CPU_TO_LE16(
          sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost)),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.1318480670452118
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/verify.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      verify,
      'v',
      ""verify"",
      ""verify a certificate using the CA certificate"",
      {""[--in file] [--ca file]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""X.509 certificate to verify, default: stdin""},
          {""cacert"", 'c', 1, ""CA certificate, default: verify self signed""},
      }});
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.11535636335611343
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float2() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_16}}};
  return item;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.05060971900820732
phase4ground-joco-2018-badge-782fd35/firmware/manbearpig/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    mbp_tooth_eye_stop();
    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
  mbp_tooth_eye_start();
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.07892192155122757
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	The firmware version is the SHA256 hash.	1	"arm_uc_error_t ARM_UC_ControlCenter_ReportVersion(uint64_t version) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportVersion: %"" PRIu64, version);

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct) {
    arm_uc_monitor_struct->SendVersion(version);
    result.code = ERR_NONE;
  }

  return result;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.21111613512039185
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;
  }

  return ErrorCode;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.03469272702932358
boazsegev-iodine-b6bdf50/ext/iodine/http1.c	Creates an HTTP1 protocol object and handles any unread data in the buffer (if any).	2	"fio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,
                          void *unread_data, size_t unread_length) {
  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)
    return NULL;
  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);

  FIO_ASSERT_ALLOC(p);
  *p = (http1pr_s){
      .p.protocol =
          {
              .on_data = http1_on_data_first_time,
              .on_close = http1_on_close,
              .on_ready = http1_on_ready,
          },
      .p.uuid = uuid,
      .p.settings = settings,
      .max_header_size = settings->max_header_size,
      .is_client = settings->is_client,
  };
  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    memcpy(p->buf, unread_data, unread_length);
    p->buf_len = unread_length;
  }
  fio_attach(uuid, &p->p.protocol);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  return &p->p.protocol;
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.2002801150083542
Decawave-mynewt-dw1000-apps-be5c28a/apps/listener/src/bleprph.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"bleprph_advertise(void) {
  uint8_t own_addr_type;
  struct ble_gap_adv_params adv_params;
  struct ble_hs_adv_fields fields;
  const char *name;
  int rc;

  rc = ble_hs_id_infer_auto(0, &own_addr_type);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error determining address type; rc=%d\n"", rc);
    return;
  }

  memset(&fields, 0, sizeof fields);

  fields.flags = BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP;

  fields.tx_pwr_lvl_is_present = 1;
  fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

  name = ble_svc_gap_device_name();
  fields.name = (uint8_t *)name;
  fields.name_len = strlen(name);
  fields.name_is_complete = 1;

  fields.uuids16 = (ble_uuid16_t[]){BLE_UUID16_INIT(GATT_SVR_SVC_ALERT_UUID)};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  memset(&adv_params, 0, sizeof adv_params);
  adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
  adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
  rc = ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params,
                         bleprph_gap_event, NULL);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	0	0.15265533328056335
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabKey request. Creates a grab for the client's keyboard and adds it to the list of passive grabs.	2	"ProcGrabKey(ClientPtr client) {
  WindowPtr pWin;

  REQUEST(xGrabKeyReq);
  GrabPtr grab;
  DeviceIntPtr keybd = PickKeyboard(client);
  int rc;
  GrabParameters param;
  GrabMask mask;

  REQUEST_SIZE_MATCH(xGrabKeyReq);

  param = (GrabParameters){.grabtype = CORE,
                           .ownerEvents = stuff->ownerEvents,
                           .this_device_mode = stuff->keyboardMode,
                           .other_devices_mode = stuff->pointerMode,
                           .modifiers = stuff->modifiers};

  rc = CheckGrabValues(client, &param);
  if (rc != Success)
    return rc;

  if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
       (stuff->key < keybd->key->xkbInfo->desc->min_key_code)) &&
      (stuff->key != AnyKey)) {
    client->errorValue = stuff->key;
    return BadValue;
  }
  rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
  if (rc != Success)
    return rc;

  mask.core = (KeyPressMask | KeyReleaseMask);

  grab = CreateGrab(client->index, keybd, keybd, pWin, CORE, &mask, &param,
                    KeyPress, stuff->key, NullWindow, NullCursor);
  if (!grab)
    return BadAlloc;
  return AddPassiveGrabToList(client, grab);
}"	claude-3-5-sonnet-20241022	None_output	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	50	0.1922275722026825
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/AndroidAccessoryClassHost.c	Starts Accessory Mode in the attached Android device. This function will validate the device's Android Open Accessory protocol version, send the configured property strings, and request a switch to Android Open Accessory mode.	1	"uint8_t
AOA_Host_StartAccessoryMode(USB_ClassInfo_AOA_Host_t *const AOAInterfaceInfo) {
  uint8_t ErrorCode;

  uint16_t AccessoryProtocol;
  if ((ErrorCode = AOA_Host_GetAccessoryProtocol(&AccessoryProtocol)) !=
      HOST_WAITERROR_Successful)
    return ErrorCode;

  if (AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV1))
    return AOA_ERROR_LOGICAL_CMD_FAILED;

  for (uint8_t PropertyIndex = 0; PropertyIndex < AOA_STRING_TOTAL_STRINGS;
       PropertyIndex++) {
    if ((ErrorCode = AOA_Host_SendPropertyString(
             AOAInterfaceInfo, PropertyIndex)) != HOST_WAITERROR_Successful)
      return ErrorCode;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE),
      .bRequest = AOA_REQ_StartAccessoryMode,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	This function initiates Android Open Accessory mode by checking protocol compatibility, sending property strings, and configuring the device to start accessory mode through USB control requests.	2	1	0.47057108307676476	0.12208587447991638	{'f': 0.5098039165705499, 'p': 0.5, 'r': 0.52}	{'f': 0.21818181322314062, 'p': 0.2, 'r': 0.24}	{'f': 0.4313725440215302, 'p': 0.4230769230769231, 'r': 0.44}	95	0.8939993977546692
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	_mm_set1_epi64(__m64 __q) { return (__m128i){(long long)__q, (long long)__q}; }	claude-3-5-sonnet-20241022	This function creates a 128-bit vector by duplicating a 64-bit value into both the lower and upper halves of the resulting vector.	2	1	0.16891891891891894	0.012990806323574158	{'f': 0.2499999951757813, 'p': 0.3076923076923077, 'r': 0.21052631578947367}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.18749999517578136, 'p': 0.23076923076923078, 'r': 0.15789473684210525}	10	0.2896113395690918
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/fifo.c	Move data pointers and pts offset samples forward.	2	"static void buffer_offset(AVFilterLink *link, AVFrame *frame, int offset) {
  int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
  int planar = av_sample_fmt_is_planar(link->format);
  int planes = planar ? nb_channels : 1;
  int block_align =
      av_get_bytes_per_sample(link->format) * (planar ? 1 : nb_channels);
  int i;

  av_assert0(frame->nb_samples > offset);

  for (i = 0; i < planes; i++)
    frame->extended_data[i] += block_align * offset;
  if (frame->data != frame->extended_data)
    memcpy(frame->data, frame->extended_data,
           FFMIN(planes, FF_ARRAY_ELEMS(frame->data)) * sizeof(*frame->data));
  frame->linesize[0] -= block_align * offset;
  frame->nb_samples -= offset;

  if (frame->pts != AV_NOPTS_VALUE) {
    frame->pts += av_rescale_q(offset, (AVRational){1, link->sample_rate},
                               link->time_base);
  }
}"	claude-3-5-sonnet-20241022	This function adjusts audio frame data by offsetting the buffer pointer, updating sample count, and adjusting timestamps based on the specified offset value.	2	1	0.2631578947368421	0.010900096978029118	{'f': 0.19999999608888894, 'p': 0.375, 'r': 0.13636363636363635}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.19999999608888894, 'p': 0.375, 'r': 0.13636363636363635}	75	0.4434305429458618
vasyutin-qnetmap-3e0b0a1/lib/src/qnetmap_label.h	draw the geometry	2	"virtual ~TLabel(){};

virtual void drawGeometry(QPainter *Painter_, const QRect &Viewport_,
                          const QPoint Offset_ = QPoint());

virtual const QString &text(void) const { return m_Text; }

virtual void setText(QString &Text_) {
  m_Text = Text_;
  calculateBoundingBox();
}"	claude-3-5-sonnet-20241022	These functions define a virtual destructor and methods for a label class to manage text display, including drawing geometry, getting/setting text content, and updating the bounding box.	2	1	0.27777777777777785	0.008301095462822575	{'f': 0.1481481461728395, 'p': 0.6666666666666666, 'r': 0.08333333333333333}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.07407407209876549, 'p': 0.3333333333333333, 'r': 0.041666666666666664}	50	0.3672400712966919
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/integration/test_integration.c	Adapt the initial mesh if a adaptation parameters are provided in the input file.	2	"void adapt_initial_mesh_if_required(struct Simulation *const sim) {
  const int *count_to_find = (int[]){2, 3};
  int count_found = 0;

  struct Adaptation_Data adapt_data = {
      .adapt_h =
          {
              0,
              0,
          },
      .xyz_ve_refine = NULL,
      .xyz_ve_ml = NULL,
      .xyz_ve_p = NULL,
  };

  char line[STRLEN_MAX];
  FILE *input_file = fopen_input('t', NULL, NULL);
  while (fgets(line, sizeof(line), input_file)) {
    read_skip_name_i(""n_adapt_h_refine"", line, &adapt_data.adapt_h[0]);
    if (strstr(line, ""xyz_ve_refine"")) {
      ++count_found;
      adapt_data.xyz_ve_refine =
          constructor_file_const_Multiarray_d(input_file, true);
    }
    if (strstr(line, ""xyz_ve_mesh_level"")) {
      ++count_found;
      adapt_data.xyz_ve_ml = constructor_file_const_Vector_i(input_file, true);
    }
    if (strstr(line, ""xyz_ve_polynomial_order"")) {
      ++count_found;
      adapt_data.xyz_ve_p = constructor_file_const_Vector_i(input_file, true);
    }
  }
  fclose(input_file);

  if (adapt_data.xyz_ve_refine == NULL) {
    assert(adapt_data.xyz_ve_ml == NULL || adapt_data.xyz_ve_p == NULL);
    return;
  }

  if (count_found < count_to_find[0] || count_found > count_to_find[1])
    EXIT_ERROR(
        ""Did not find the required number of variables (Found: %d/[%d,%d]).\n"",
        count_found, count_to_find[0], count_to_find[1]);

  adapt_hp(sim, ADAPT_S_XYZ_VE, &adapt_data);
  for (int i = 0; i < adapt_data.adapt_h[0]; ++i)
    adapt_hp(sim, ADAPT_S_H_REFINE, NULL);
  for (int i = 0; i < adapt_data.adapt_h[1]; ++i)
    adapt_hp(sim, ADAPT_S_H_COARSE, NULL);

  destructor_const_Multiarray_d(adapt_data.xyz_ve_refine);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_ml);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_p);
}"	claude-3-5-sonnet-20241022	This function reads mesh adaptation parameters from an input file and applies the specified refinement or coarsening operations to modify the simulation mesh accordingly.	2	1	0.38163265306122446	0.027219913803267486	{'f': 0.3428571381877551, 'p': 0.46153846153846156, 'r': 0.2727272727272727}	{'f': 0.11111110649691378, 'p': 0.15384615384615385, 'r': 0.08695652173913043}	{'f': 0.285714281044898, 'p': 0.38461538461538464, 'r': 0.22727272727272727}	85	0.6226552724838257
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/AudioInputHost/AudioInputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Could not set requested Audio sample rate.\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  DDRC |= (1 << 6);

  TCCR3A = ((1 << WGM30) | (1 << COM3A1) | (1 << COM3A0));
  TCCR3B = ((1 << WGM32) | (1 << CS30));

  puts_P(PSTR(""Microphone Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"	claude-3-5-sonnet-20241022	This function handles USB device enumeration for a microphone, configuring settings like sample rate and interface parameters, and sets up timers for audio processing once the device is successfully connected.	2	1	0.1773049645390071	0.010501763523707873	{'f': 0.30769230269970416, 'p': 0.32, 'r': 0.2962962962962963}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15384614885355044, 'p': 0.16, 'r': 0.14814814814814814}	75	0.5237478613853455
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Read the settings INI file via TinyFrame	2	"uint32_t GEX_IniRead(GexClient *gex, char *buffer, uint32_t maxlen) {
  GexBulk br = (GexBulk){
      .buffer = (uint8_t *)buffer, .capacity = maxlen, .req_cmd = MSG_INI_READ};

  uint32_t actuallyRead = GEX_BulkRead(GEX_SysUnit(gex), &br);

  if (actuallyRead == maxlen) {
    actuallyRead--;
  }

  buffer[actuallyRead] = 0;
  return actuallyRead;
}"	claude-3-5-sonnet-20241022	This function reads data from a GEX system into a provided buffer, ensuring it's null-terminated, and returns the number of bytes read while preventing buffer overflow.	2	1	0.11235955056179776	0.0072658577559704465	{'f': 0.0645161255359003, 'p': 0.14285714285714285, 'r': 0.041666666666666664}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0645161255359003, 'p': 0.14285714285714285, 'r': 0.041666666666666664}	20	0.1259644329547882
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	Wraps a packet like commonSetup, but will do the whole packet including headers not just the message body. This is used by the PacketEncoder tests.	2	"testrigencoder_CommonSetupWholePacket(uint8_t *packet, size_t length,
                                      TruthTableEntry *truthTable) {
  TestData *data = parcMemory_AllocateAndClear(sizeof(TestData));
  assertNotNull(data, ""parcMemory_AllocateAndClear(%zu) returned NULL"",
                sizeof(TestData));

  data->memoryRegion = parcBuffer_Wrap(packet, length, 0, length);
  data->encoder = ccnxCodecTlvEncoder_Create();

  data->dictionary = ccnxTlvDictionary_Create(
      CCNxCodecSchemaV1TlvDictionary_MessageFastArray_END,
      CCNxCodecSchemaV1TlvDictionary_Lists_END);

  data->packet = packet;
  data->packetLength = length;
  data->truthTable = truthTable;

  buildPacketDictionary(data, data->dictionary, (TlvExtent){0, length});

  return data;
}"	claude-3-5-sonnet-20241022	This function initializes test data by creating a new TestData structure, wrapping a packet buffer, setting up encoders and dictionaries, and building a packet dictionary for testing purposes.	2	1	0.17786561264822134	0.017860092878992276	{'f': 0.1739130384877128, 'p': 0.18181818181818182, 'r': 0.16666666666666666}	{'f': 0.039999995008000624, 'p': 0.041666666666666664, 'r': 0.038461538461538464}	{'f': 0.08695651674858251, 'p': 0.09090909090909091, 'r': 0.08333333333333333}	65	0.5364558696746826
ryankurte-micro-gui-1e3ce05/source/graphics.c	This performs bounds checking and translation based on the graphics context	2	"static void plot(ugui_graphics_t *graphics, uint32_t x, uint32_t y) {

  uint32_t new_x = x + graphics->offset_x;
  uint32_t new_y = y + graphics->offset_y;

  if ((new_x < graphics->w) && (x < graphics->limit_w) &&
      (new_y < graphics->h) && (y < graphics->limit_h)) {
    _ugui_buffer_set(graphics->buffer, &(ugui_point_t){.x = new_x, .y = new_y},
                     1);
  }
}"	claude-3-5-sonnet-20241022	This function plots a single pixel at coordinates (x, y) on a graphics buffer, considering offset and boundary limits, only if the point falls within valid display dimensions.	2	1	0.23622047244094488	0.010043468297595231	{'f': 0.2631578906232687, 'p': 0.45454545454545453, 'r': 0.18518518518518517}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.15789473272853197, 'p': 0.2727272727272727, 'r': 0.1111111111111111}	75	0.5257033109664917
darktable-org-darktable-32fab21/src/iop/borders.c	callback methods for gui. synch gtk interface with gui params, if necessary. gui callbacks, these are needed.	2	"void gui_update(struct dt_iop_module_t *self) {
  dt_iop_borders_gui_data_t *g = (dt_iop_borders_gui_data_t *)self->gui_data;
  dt_iop_borders_params_t *p = (dt_iop_borders_params_t *)self->params;
  dt_bauhaus_slider_set(g->size, p->size * 100.0f);

  int k = 0;
  for (; k < DT_IOP_BORDERS_ASPECT_COUNT; k++) {
    if (fabsf(p->aspect - g->aspect_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->aspect, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_ASPECT_COUNT) {
    dt_bauhaus_combobox_set_text(g->aspect, p->aspect_text);
    dt_bauhaus_combobox_set(g->aspect, -1);
  }

  dt_bauhaus_combobox_set(g->aspect_orient, p->aspect_orient);

  for (k = 0; k < DT_IOP_BORDERS_POSITION_H_COUNT; k++) {
    if (fabsf(p->pos_h - g->pos_h_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_h, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_H_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_h, p->pos_h_text);
    dt_bauhaus_combobox_set(g->pos_h, -1);
  }

  for (k = 0; k < DT_IOP_BORDERS_POSITION_V_COUNT; k++) {
    if (fabsf(p->pos_v - g->pos_v_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_v, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_V_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_v, p->pos_v_text);
    dt_bauhaus_combobox_set(g->pos_v, -1);
  }

  dt_bauhaus_slider_set(g->frame_size, p->frame_size * 100.0f);
  dt_bauhaus_slider_set(g->frame_offset, p->frame_offset * 100.0f);

  GdkRGBA c = (GdkRGBA){.red = p->color[0],
                        .green = p->color[1],
                        .blue = p->color[2],
                        .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->colorpick), &c);

  GdkRGBA fc = (GdkRGBA){.red = p->frame_color[0],
                         .green = p->frame_color[1],
                         .blue = p->frame_color[2],
                         .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->frame_colorpick), &fc);
}"	claude-3-5-sonnet-20241022	This function updates the GUI elements (sliders, comboboxes, color pickers) in the borders module of darktable to reflect the current parameter values stored in the module's data structure.	2	1	0.027624309392265196	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	75	0.3165806531906128
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavutil/rational.c	Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign.	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (fabs(d) > INT_MAX + 3LL)
    return (AVRational){d < 0 ? -1 : 1, 0};
  frexp(d, &exponent);
  exponent = FFMAX(exponent - 1, 0);
  den = 1LL << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"	claude-3-5-sonnet-20241022	This function converts a double-precision floating-point number to a rational fraction (numerator/denominator) with specified maximum values, ensuring the best possible approximation within given constraints.	2	1	0.31570374628724734	0.1090009697802911	{'f': 0.23809523314058967, 'p': 0.2631578947368421, 'r': 0.21739130434782608}	{'f': 0.13953487874526788, 'p': 0.15, 'r': 0.13043478260869565}	{'f': 0.23809523314058967, 'p': 0.2631578947368421, 'r': 0.21739130434782608}	85	0.6514219641685486
ThierryNg-pokecopy-57caaae/Pokecopy.spritebuilder/Source/libs/cocos2d-iphone/cocos2d/ccTypes.h	helper that creates a ccColor4f type	2	"static inline ccColor4F ccc4f(const GLfloat r, const GLfloat g, const GLfloat b,
                              const GLfloat a) {
  return (ccColor4F){r, g, b, a};
}"	claude-3-5-sonnet-20241022	This function creates and returns a color structure (ccColor4F) with four float components (red, green, blue, alpha) for representing colors in OpenGL.	2	1	0.19736842105263155	0.010331208012220438	{'f': 0.14285713948979603, 'p': 0.3333333333333333, 'r': 0.09090909090909091}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.14285713948979603, 'p': 0.3333333333333333, 'r': 0.09090909090909091}	85	0.5504484176635742
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/LowLevel/Host.c	Clears a stall condition on the given pipe, via a ClearFeature request to the attached device.	2	"uint8_t USB_Host_ClearPipeStall(uint8_t EndpointNum) {
  if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    EndpointNum |= ENDPOINT_DESCRIPTOR_DIR_IN;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"	claude-3-5-sonnet-20241022	The function sends a USB control request to clear a stall condition on a specific endpoint, allowing data transfer to resume on that endpoint.	2	1	0.45634920634920634	0.12173115521158184	{'f': 0.3636363587511479, 'p': 0.42857142857142855, 'r': 0.3157894736842105}	{'f': 0.21052631101108046, 'p': 0.26666666666666666, 'r': 0.17391304347826086}	{'f': 0.30303029814508725, 'p': 0.35714285714285715, 'r': 0.2631578947368421}	95	0.6013031601905823
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties.	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"	claude-3-5-sonnet-20241022	This function sends a SCSI INQUIRY command to a specified Logical Unit Number (LUN) on a USB Mass Storage device to retrieve device information and stores it in the provided InquiryData structure.	2	1	0.40216216216216216	0.01687589360987099	{'f': 0.32558139080584103, 'p': 0.4666666666666667, 'r': 0.25}	{'f': 0.0425531869986424, 'p': 0.0625, 'r': 0.03225806451612903}	{'f': 0.18604650708491086, 'p': 0.26666666666666666, 'r': 0.14285714285714285}	90	0.7055879235267639
varunjampani-video_prop_networks-4f4a398/lib/caffe/include/caffe/malabar_layers.hpp	Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true.	2	"template <typename Dtype> class MatMulLayer : public Layer<Dtype> {
public:
  explicit MatMulLayer(const LayerParameter &param) : Layer<Dtype>(param) {
    LayerParameter tmp_param;
    tmp_param.mutable_concat_param()->set_concat_dim(3);
    concat_layer_.reset(new ConcatLayer<Dtype>(tmp_param));
  }
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul""; }
  virtual inline int MinNumBottomBlobs() const { return 2; }
  virtual inline int ExactNumTopBlobs() const { return 1; }

protected:
  virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Forward_gpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  virtual void Backward_gpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  Blob<Dtype> tmp_k_;
  boost::shared_ptr<ConcatLayer<Dtype>> concat_layer_;
};

template <typename Dtype> class MatMul2Layer : public Layer<Dtype> {
public:
  explicit MatMul2Layer(const LayerParameter &param) : Layer<Dtype>(param){};
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul2""; }"	claude-3-5-sonnet-20241022	These classes (MatMulLayer and MatMul2Layer) implement matrix multiplication operations in a neural network framework, with support for both CPU and GPU computations.	2	1	0.10362694300518135	0.011433361115787456	{'f': 0.16216215725346983, 'p': 0.1875, 'r': 0.14285714285714285}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.10810810319941586, 'p': 0.125, 'r': 0.09523809523809523}	50	0.37701520323753357
moehriegitt-hob3l-40cfda8/src/csg3.c	From an array of points in the rough shape of a tower, make a polyhedron. 'Tower' means the shape consists of layers of polygon points stack on each other. This function also handles the case of the top collapsing into a single point. So this shape works for (polyhedronized) cylinders, cones, spheres, cubes, and linear_extrudes. If the connecting quads are not planar, then tri_side can be set to non-false to split them into triangles. This shape is probably not nice, but correct in that the faces are planar, since every triangle is trivially planar). The top and bottom faces must be planar. rev^(m->d < 0) inverts face vertex order to allow managing mirroring and negative determinants. This also gives some freedom for the construction: if top and bottom are swapped (i.e., the points 0..fn-1 are the top, not the bottom), then rev be passed as non-false. This also runs xform and minmax, but not make_edges.	2	"static bool faces_n_edges_from_tower(cp_csg3_poly_t *o, ctxt_t *c,
                                     cp_mat3wi_t const *m, cp_loc_t loc,
                                     size_t fn, size_t fnz, bool rev,
                                     unsigned tri_side, bool may_need_tri) {

  unsigned orient = 0;
  bool need_tri = false;
  if (may_need_tri) {
    for (cp_size_each(i, fn)) {
      size_t j = cp_wrap_add1(i, fn);
      size_t k = cp_wrap_add1(j, fn);
      orient |=
          1U << (1 + cp_vec2_right_normal3_z(&cp_v_nth(&o->point, i).coord.b,
                                             &cp_v_nth(&o->point, j).coord.b,
                                             &cp_v_nth(&o->point, k).coord.b));
      if ((orient & 5) == 5) {
        need_tri = true;
        break;
      }
    }
  }

  cp_v_size3_t tri = {0};
  if (need_tri) {
    cp_vec2_arr_ref_t a2;
    cp_vec2_arr_ref_from_a_vec3_loc_xy(&a2, &o->point);
    if (!cp_csg2_tri_vec2_arr_ref(&tri, c->tmp, c->err, loc, &a2, fn)) {
      return false;
    }
  }

  if (m->d < 0) {
    rev = !rev;
  }

  for (cp_v_each(i, &o->point)) {
    cp_vec3w_xform(&cp_v_nth(&o->point, i).coord, &m->n,
                   &cp_v_nth(&o->point, i).coord);
  }

  bool has_top = (o->point.size == fn * fnz);
  assert(has_top || (o->point.size == 1 + (fn * (fnz - 1))));

  size_t k = 0;
  size_t bt_cnt = tri.size ? tri.size : 1U;
  cp_v_init0(&o->face, (bt_cnt * (1U + !!has_top)) +
                           ((fnz - 2) * fn * (1U + !!tri_side)) +
                           (fn * (1U + !!(tri_side && has_top))));

  face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, false);

  if (has_top) {
    face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, true);
  }

  cp_v_fini(&tri);

  cp_csg3_face_t *f;
  for (cp_size_each(i, fnz, 1, !has_top)) {
    size_t k1 = i * fn;
    size_t k0 = k1 - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      switch (tri_side) {
      case TRI_LEFT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j0},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j1},
                                 3, !rev, loc);
        break;
      case TRI_RIGHT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j0},
                                 3, !rev, loc);
        break;
      case TRI_NONE:
        face_init_from_point_ref(
            f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1, k1 + j0}, 4, !rev,
            loc);
        break;
      default:
        assert(0);
      }
    }
  }

  if (!has_top) {

    size_t kw = o->point.size - 1;
    size_t kv = kw - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      face_init_from_point_ref(f, o, (size_t[4]){kv + j0, kv + j1, kw}, 3, !rev,
                               loc);
    }
  }

  assert(o->face.size == k);
  return poly_make_edges(o, c);
}"	claude-3-5-sonnet-20241022	This function creates faces and edges for a 3D tower-like structure in computer graphics, handling both triangular and rectangular faces while considering orientation and transformation parameters.	2	1	0.042492917847025496	0.00016719440870755262	{'f': 0.11475409530099444, 'p': 0.0707070707070707, 'r': 0.30434782608695654}	{'f': 0.011494250412868804, 'p': 0.006711409395973154, 'r': 0.04}	{'f': 0.09836065267804363, 'p': 0.06060606060606061, 'r': 0.2608695652173913}	75	0.658218502998352
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	Parse a packet, add all split parts to parse_queue.	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->buf && out_pkt.data == pkt->data) {

      out_pkt.buf = av_buffer_ref(pkt->buf);
      if (!out_pkt.buf) {
        ret = AVERROR(ENOMEM);
        goto fail;
      }
    } else {
      ret = av_packet_make_refcounted(&out_pkt);
      if (ret < 0)
        goto fail;
    }

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;
    out_pkt.flags |= pkt->flags & AV_PKT_FLAG_DISCARD;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = ff_packet_list_put(&s->internal->parse_queue,
                             &s->internal->parse_queue_end, &out_pkt, 0);
    if (ret < 0) {
      av_packet_unref(&out_pkt);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"	claude-3-5-sonnet-20241022	This function parses input packets into smaller units, processes timing information, handles audio/video frame properties, and manages packet queuing within the FFmpeg framework.	2	1	0.14423076923076925	0.008282282660969604	{'f': 0.06249999595703151, 'p': 0.1111111111111111, 'r': 0.043478260869565216}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06249999595703151, 'p': 0.1111111111111111, 'r': 0.043478260869565216}	65	0.32316678762435913
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices.	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"	claude-3-5-sonnet-20241022	This function sets a HID device to use the Boot Protocol mode, sending a control request to switch protocols and updating interface state information accordingly.	2	1	0.3866694409765571	0.020144990145560468	{'f': 0.27027026556610667, 'p': 0.35714285714285715, 'r': 0.21739130434782608}	{'f': 0.049999995200000466, 'p': 0.0625, 'r': 0.041666666666666664}	{'f': 0.27027026556610667, 'p': 0.35714285714285715, 'r': 0.21739130434782608}	85	0.7188987731933594
opticron-libuweave-2e5e385/src/macaroon_helpers.c	Mint an initial server authentication token (SAT).	2	"bool uw_macaroon_mint_server_authentication_token_(
    const uint8_t *root_key, size_t root_key_len, const uint8_t *token_str,
    size_t token_str_len,
    const uint8_t nonce[UW_MACAROON_INIT_DELEGATION_NONCE_SIZE],
    uint8_t *buffer, size_t buffer_size, UwMacaroon *new_macaroon) {
  if (root_key == NULL || root_key_len == 0 || nonce == NULL ||
      buffer == NULL || buffer_size == 0 || new_macaroon == NULL) {
    return false;
  }
  if (token_str == NULL && token_str_len != 0) {
    return false;
  }

  *new_macaroon = (UwMacaroon){};

  const size_t num_caveats = 2;
  UwMacaroonCaveat **caveat_list =
      allocate_caveat_list_(num_caveats, &buffer, &buffer_size);
  if (caveat_list == NULL) {
    return false;
  }

  size_t needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeServerAuthenticationTokenV1, token_str_len);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_server_authentication_token_(
          token_str, token_str_len, buffer, needed_buffer_size,
          caveat_list[0])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeNonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_nonce_(
          nonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE, buffer,
          needed_buffer_size, caveat_list[1])) {
    return false;
  }

  UwMacaroonContext context = {};
  return uw_macaroon_create_from_root_key_(
      new_macaroon, root_key, root_key_len, &context,
      (const UwMacaroonCaveat *const *)caveat_list, num_caveats);
}"	claude-3-5-sonnet-20241022	This function creates a new macaroon with server authentication token and nonce caveats using a root key, validating inputs and allocating memory for the required components.	2	1	0.3308364544319601	0.0359604157411963	{'f': 0.19354838360041626, 'p': 0.42857142857142855, 'r': 0.125}	{'f': 0.12903225494276802, 'p': 0.3333333333333333, 'r': 0.08}	{'f': 0.19354838360041626, 'p': 0.42857142857142855, 'r': 0.125}	45	0.395365834236145
vsfteam-vsf-c4a58f3/release/kernel/beta/example/usrapp/template/main_fsm_simple.c	You cannot ignore fsm_initialiser at any time	4	"fsm_initialiser(user_task_b_t, args(vsf_sem_t *ptSEM))
    init_body(this.psem = ptSEM;)

        implement_fsm(user_task_b_t) def_states(PRINT, DELAY);

    body(
        on_start(
            update_state_to(PRINT);
        )
        
        state(PRINT){
  printf(""hello world! \r\n"");
  update_state_to(DELAY);                                              
        }"	claude-3-5-sonnet-20241022	"The function initializes a finite state machine with two states (PRINT and DELAY) that prints ""hello world!"" and transitions between states using a semaphore."	2	1	0.0	0.0	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	50	0.21319495141506195
kernkonzept-l4re-core-0dd677e/l4sys/include/types.h	Create a message tag from the specified values.	2	"l4_msgtag_t l4_msgtag(long label, unsigned words, unsigned items,
                      unsigned flags) L4_NOTHROW {
  return (l4_msgtag_t){
      (l4_mword_t)((l4_umword_t)label << 16) | (l4_mword_t)(words & 0x3f) |
      (l4_mword_t)((items & 0x3f) << 6) | (l4_mword_t)(flags & 0xf000)};
}"	claude-3-5-sonnet-20241022	This function constructs an L4 message tag by combining a label, word count, item count, and flags into a single packed structure used for Inter-Process Communication (IPC) in L4 microkernel systems.	2	1	0.24811218985976266	0.014117915208981237	{'f': 0.1666666632098766, 'p': 0.375, 'r': 0.10714285714285714}	{'f': 0.054054050986121434, 'p': 0.14285714285714285, 'r': 0.03333333333333333}	{'f': 0.1111111076543211, 'p': 0.25, 'r': 0.07142857142857142}	75	0.3779679834842682
cascadeo-monit-8857544/src/status.c	Show all services in the service list.	2	"boolean_t status(const char *level, const char *group, const char *service) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    Socket_print(S, ""GET /_status?format=text&level=%s"", level);
    if (group) {
      char *_group = Util_urlEncode((char *)group);
      Socket_print(S, ""&group=%s"", _group);
      FREE(_group);
    }
    if (service) {
      char *_service = Util_urlEncode((char *)service);
      Socket_print(S, ""&service=%s"", _service);
      FREE(_service);
    }
    char *_auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, "" HTTP/1.0\r\n%s\r\n"", _auth ? _auth : """");
    FREE(_auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"	claude-3-5-sonnet-20241022	This function checks the status of a Monit daemon by connecting to its HTTP interface, sending a status request with optional filters (level, group, service), and returning the status information.	2	1	0.10752688172043011	0.007425868202031369	{'f': 0.12121211786960524, 'p': 0.2857142857142857, 'r': 0.07692307692307693}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.12121211786960524, 'p': 0.2857142857142857, 'r': 0.07692307692307693}	10	0.1914132535457611
boazsegev-iodine-b6bdf50/ext/iodine/fio_tls_missing.c	Schedules the ALPN protocol callback.	2	"FIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,
                                 void *udata_connection) {
  if (!alpn || !alpn->on_selected)
    return;
  alpn_task_s *t = fio_malloc(sizeof(*t));
  *t = (alpn_task_s){
      .alpn = *alpn,
      .uuid = uuid,
      .udata_connection = udata_connection,
  };

  fio_defer(alpn_select___task, t, NULL);
}"	claude-3-5-sonnet-20241022	This function creates and schedules a deferred task for ALPN (Application-Layer Protocol Negotiation) selection by allocating memory for the task structure and initializing it with provided parameters.	2	1	0.2777777777777778	0.008301095462822575	{'f': 0.13793103162901313, 'p': 0.4, 'r': 0.08333333333333333}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.06896551438763389, 'p': 0.2, 'r': 0.041666666666666664}	75	0.6891247630119324
rockchip-linux-coreboot-adde3ea/src/cpu/intel/speedstep/speedstep.c	This is generic code and should work at least for Merom and Penryn processors. It is used to generate acpi tables and configure EMTTM.	4	"void speedstep_gen_pstates(sst_table_t *const table) {
  sst_params_t params;

  speedstep_get_limits(&params);

  const int power_diff2 = (params.max.power - params.min.power) * 2;
  const int vid_diff2 = (params.max.vid - params.min.vid) * 2;
  const int max_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.max);
  const int min_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.min);
  const int ratio_diff2 = max_ratio2 - min_ratio2;

  int states, step2 = 0;
  do {
    step2 += 2 * 2;
    states = ratio_diff2 / step2 + 1;
  } while (states > SPEEDSTEP_MAX_NORMAL_STATES);
  if (step2 > 4)
    printk(BIOS_INFO,
           ""Enhanced Speedstep processor with ""
           ""more than %d possible p-states.\n"",
           SPEEDSTEP_MAX_NORMAL_STATES);
  if (states < 2)
    states = 2;

  table->num_states = 0;

  if (params.turbo.is_turbo)
    table->states[table->num_states++] = params.turbo;

  table->states[table->num_states] = params.max;

  if ((params.max.dynfsb == params.min.dynfsb) &&
      (params.max.nonint == params.min.nonint) &&
      (params.max.ratio == params.min.ratio))
    table->states[table->num_states].vid = params.min.vid;
  ++table->num_states;
  --states;

  const int power_step = (power_diff2 / states) / 2;
  const int vid_step = (vid_diff2 / states) / 2;
  const int ratio_step = step2 / 2;
  int power = params.min.power + (states - 1) * power_step;
  int vid = params.min.vid + (states - 1) * vid_step;
  int ratio = params.min.ratio + (states - 1) * ratio_step;
  for (; states > 0; --states) {
    table->states[table->num_states++] =
        (sst_state_t){0, 0, ratio, vid, 0, 0, power};
    power -= power_step;
    vid -= vid_step;
    ratio -= ratio_step;
  }

  if (params.slfm.is_slfm)
    table->states[table->num_states++] = params.slfm;
}"	claude-3-5-sonnet-20241022	This function generates a table of P-states (performance states) for Intel SpeedStep technology by calculating power, voltage ID, and frequency ratio steps between minimum and maximum operating parameters.	2	1	0.1434426229508197	0.009498525867740094	{'f': 0.12499999507812519, 'p': 0.14285714285714285, 'r': 0.1111111111111111}	{'f': 0.0, 'p': 0.0, 'r': 0.0}	{'f': 0.12499999507812519, 'p': 0.14285714285714285, 'r': 0.1111111111111111}	30	0.4239516854286194
