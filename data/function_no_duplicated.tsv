filename	comment	preds	stripped_code
BRAINSia-BRAINSTools-11a70b1/ARCHIVE/BRAINSSurfaceTools/BRAINSSurfaceCommon/itkMeshToMeshRegistrationMethod.h	Method invoked by the pipeline in order to trigger the computation of the registration.	2	"using Superclass::MakeOutput;

virtual DataObjectPointer MakeOutput(size_t idx) override;

unsigned long GetMTime() const override;

protected:
MeshToMeshRegistrationMethod();
virtual ~MeshToMeshRegistrationMethod(){};
void PrintSelf(std::ostream &os, Indent indent) const override;

void GenerateData() override;

private:
MetricPointer m_Metric;
OptimizerType::Pointer m_Optimizer;

MovingMeshConstPointer m_MovingMesh;
FixedMeshConstPointer m_FixedMesh;

TransformPointer m_Transform;
InterpolatorPointer m_Interpolator;

ParametersType m_InitialTransformParameters;
ParametersType m_LastTransformParameters;
}
;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal simplex basis functions.	2	"static void
test_unit_basis_simplex_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_SI_Ortho *b_data_a = constructor_Basis_Data_SI_Ortho('a'),
                             *b_data_c = constructor_Basis_Data_SI_Ortho('c');

  tol = (double[]){
      10 * EPS,
      20 * EPS,
      10 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]),
      diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[1]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      20 * EPS,
      30 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]),
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[1]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      9 * EPS,
      8e4 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_25, b_data_c->grad_coef_25,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_37, b_data_c->grad_coef_37,
                              tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_25,
                                    b_data_c->grad_coef_25, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_37,
                                    b_data_c->grad_coef_37, tol[1]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_SI_Ortho(b_data_a);
  destructor_Basis_Data_SI_Ortho(b_data_c);

  assert_condition(pass);
}"
MightyPork-avr-projects-1c993f8/projects/color-memory-game/main.c	Randomly place pairs of cards on the board	2	"void deal_cards() {

  for (uint8_t i = 0; i < CARD_COUNT; ++i) {
    board[i] = (tile_t){.color = 0, .state = GONE};
  }

  const uint8_t dealt_cards =
      get_pin(FLAG_SMALL) ? CARD_COUNT : CARD_COUNT_SMALL;

  for (uint8_t i = 0; i < (dealt_cards / 2); ++i) {

    for (uint8_t j = 0; j < 2; j++) {

      while (1) {
        const uint8_t pos = rand() % dealt_cards;

        if (board[pos].state == GONE) {
          board[pos] = (tile_t){.color = i, .state = SECRET};
          break;
        }
      }
    }
  }
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties."	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Inquiry_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
multitheftauto-mtasa-blue-1f5e9f8/vendor/ehs/ehs.h	adds new data to psBuffer	2	"NetworkAbstraction *GetNetworkAbstraction();

int TrySend(const char *ipMessage, size_t inLength, int inFlags = 0);
}
;

class EHSServer;

class EHS {

protected:
  EHSMap oEHSMap;

  EHS *poParent;

  std::string sRegisteredAs;

  EHSServer *poEHSServer;

  EHS *m_poSourceEHS;

public:
  EHS(EHS *ipoParent = NULL, std::string isRegisteredAs = """");

  virtual ~EHS();

  void SetCertificateFile(std::string &irsCertificateFile);

  void SetCertificatePassphrase(std::string &irsCertificatePassphrase);

  void SetPassphraseCallback(int (*m_ipfOverridePassphraseCallback)(char *, int,
                                                                    int,
                                                                    void *));

  void SetParent(EHS *ipoParent, std::string isRegisteredAs);

  enum RegisterEHSResult {
    REGISTEREHSINTERFACE_INVALID = 0,
    REGISTEREHSINTERFACE_ALREADYEXISTS,
    REGISTEREHSINTERFACE_SUCCESS
  };

  RegisterEHSResult RegisterEHS(EHS *ipoEHS, const char *ipsRegisterPath);

  enum UnregisterEHSResult {
    UNREGISTEREHSINTERFACE_INVALID = 0,
    UNREGISTEREHSINTERFACE_NOTREGISTERED,
    UNREGISTEREHSINTERFACE_SUCCESS
  };

  UnregisterEHSResult UnregisterEHS(const char *ipsRegisterPath);

  virtual HttpResponse *RouteRequest(HttpRequest *ipoHttpRequest);

  virtual ResponseCode HandleRequest(HttpRequest *ipoHttpRequest,
                                     HttpResponse *ipoHttpResponse);

  virtual void HttpPulse(void){};

  virtual bool ShouldAllowConnection(const char *szAddress) { return true; }"
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power domain attributes command and testing the received values.	3	"void arm_scmi_custom_test_power_domain_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t attributes;
  uint32_t protocol_mask = expected_flags_mask;
  uint32_t rcv_u, exp_u;
  char *domain_name;
  char *rcv_s, *exp_s;
  struct arm_scmi_protocol_execution_context *prot = protocol_execution_context;
  enum test_status res;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_domain_attributes,
                           domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_domain_attributes,
                                       domain_id)] =
        power_protocol_data.num_power_domains + 1;
    error_code =
        arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_power_domain_attributes, domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tPOWER DOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&prot->test_stats, description);
      error_code =
          arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        break;
      attributes = RETURN_VAL(received, struct arm_scmi_power_domain_attributes,
                              attributes);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_HIGH,
                                     POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_LOW);
      snprintf(name, NUM_ELEMS(name),
               ""POWER STATE CHANGE NOTIFICATIONS SUPPORT"");
      if ((power_expected->power_state_notification_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_STATE_NOTIFICATION_SUPPORT))) {
        exp_u = power_expected->power_state_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_ASYNC_HIGH,
                                     POWER_DOMAIN_ATTR_ASYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER ASYNCHRONOUS SUPPORT"");
      if ((power_expected->power_asynchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_ASYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_asynchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_SYNC_HIGH,
                                     POWER_DOMAIN_ATTR_SYNC_LOW);
      snprintf(name, NUM_ELEMS(name), ""POWER SYNCHRONOUS SUPPORT"");
      if ((power_expected->power_synchronous_support != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_SYNCHRONOUS_SUPPORT))) {
        exp_u = power_expected->power_synchronous_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      arm_scmi_check_and_report_dec(
          &prot->test_stats, ALL_BITS_SET, CHECK, RESERVED,
          arm_scmi_get_norm_bits(attributes, POWER_DOMAIN_ATTR_RESERVED_HIGH,
                                 POWER_DOMAIN_ATTR_RESERVED_LOW),
          ""RESERVED"");

      power_protocol_data.attributes[domain_id] = attributes;

      res = INFO;
      domain_name =
          RETURN_STR(received, struct arm_scmi_power_domain_attributes, name);
      rcv_s = domain_name;
      snprintf(name, NUM_ELEMS(name), ""DOMAIN NAME"");
      if ((power_expected->power_domain_names != NULL) &&
          (protocol_mask & LEFT_SHIFT(POWER_DOMAIN_NAMES))) {
        exp_s = power_expected->power_domain_names[domain_id];
        res = (strcmp(rcv_s, exp_s) == 0) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", exp_s, rcv_s);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", rcv_s);
      }
      arm_scmi_log_test_result(&prot->test_stats, INFO, name, description);
    }
  }
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	"Soft-resets the attached printer, readying it for new commands."	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock describe rates command and testing the received values.	3	"void arm_scmi_custom_tester_clock_describe_rates(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint8_t clock_id;
  uint32_t num_rates_flags;
  uint8_t num_rates = 0;
  uint32_t rcv_u, exp_u;
  uint32_t rate_index = 0;
  uint32_t remaining_rates;
  struct arm_scmi_clock_rate *rcv_rates, *rates;
  size_t nr;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  uint64_t op1, step_size;
  struct arm_scmi_clock_rate **discrete;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_describe_rates, clock_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       clock_id)] =
        clock_protocol_data.num_clocks;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                       rate_index)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                         clock_id)] = clock_id;
      rate_index = 0;

      rates = clock_protocol_data.clocks[clock_id].rates;
      do {

        test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_describe_rates,
                                           rate_index)] = rate_index;
        error_code = arm_scmi_execute_and_assert_test_case(
            protocol_execution_context, test_case, &received);
        if (arm_scmi_skip_return_values(error_code, received.status))
          break;

        num_rates_flags = RETURN_VAL(
            received, struct arm_scmi_clock_describe_rates, num_rates_flags);

        remaining_rates = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_NUM_RATES_REMAINING_HIGH,
            CLK_DESCRATE_NUM_RATES_REMAINING_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      remaining_rates,
                                      ""NUMBER OF REMAINING RATES"");

        rcv_u =
            arm_scmi_get_norm_bits(num_rates_flags, CLK_DESCRATE_RESERVED_HIGH,
                                   CLK_DESCRATE_RESERVED_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                      rcv_u, ""RESERVED"");

        uint32_t format = arm_scmi_get_norm_bits(
            num_rates_flags, CLK_DESCRATE_RETURN_FORMAT_HIGH,
            CLK_DESCRATE_RETURN_FORMAT_LOW);
        clock_protocol_data.format = format;
        if (clock_expected->rate_format_supported) {
          arm_scmi_check_and_report_dec(
              test_stats, expected_flags_mask,
              LEFT_SHIFT(RATE_FORMAT_SUPPORTED),
              clock_expected->rate_format_supported[clock_id], format,
              ""FORMAT"");
        } else {
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(RATE_FORMAT_SUPPORTED), 0,
                                        format, ""FORMAT"");
        }

        num_rates = arm_scmi_get_norm_bits(num_rates_flags,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_HIGH,
                                           CLK_DESCRATE_NUM_RATES_RETURNED_LOW);
        exp_u = clock_expected->num_rates == NULL
                    ? 0
                    : clock_expected->num_rates[clock_id];
        arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                      LEFT_SHIFT(CLOCK_NUM_RATES), exp_u,
                                      num_rates, ""NUMBER OF RATES"");

        rcv_rates = (struct arm_scmi_clock_rate *)&received.payload[OFFSET_RET(
            struct arm_scmi_clock_describe_rates, rates)];
        if (format == THREE_TUPLE_RATE_FORMAT) {

          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].lower,
                                        ""LOWEST RATE {LOWER}"");
          exp_u = clock_expected->low_clock_rate == NULL
                      ? 0
                      : clock_expected->low_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[LOWEST_RATE].upper,
                                        ""LOWEST RATE {UPPER}"");

          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].lower,
                                        ""HIGHEST RATE {LOWER}"");
          exp_u = clock_expected->high_clock_rate == NULL
                      ? 0
                      : clock_expected->high_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[HIGHEST_RATE].upper,
                                        ""HIGHEST RATE {UPPER}"");

          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].lower;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].lower,
                                        ""STEP SIZE {LOWER}"");
          exp_u = clock_expected->step_clock_rate == NULL
                      ? 0
                      : clock_expected->step_clock_rate[clock_id].upper;
          arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                        LEFT_SHIFT(THREE_TUPLE_CLOCK_RATES),
                                        exp_u, rcv_rates[STEP_SIZE].upper,
                                        ""STEP SIZE {UPPER}"");

          rates[MIN_CLOCK] = rcv_rates[LOWEST_RATE];
          op1 = (((uint64_t)rcv_rates[LOWEST_RATE].upper) << 32) |
                rcv_rates[LOWEST_RATE].lower;
          step_size = (((uint64_t)rcv_rates[STEP_SIZE].upper) << 32) |
                      rcv_rates[STEP_SIZE].lower;
          op1 += step_size;
          rates[MIN_CLOCK + 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          op1 = (((uint64_t)rcv_rates[HIGHEST_RATE].upper) << 32) |
                rcv_rates[HIGHEST_RATE].lower;
          op1 -= step_size;
          rates[MAX_CLOCK - 1] = (struct arm_scmi_clock_rate){
              (uint32_t)op1, (uint32_t)(op1 >> 32)};
          rates[MAX_CLOCK] = rcv_rates[HIGHEST_RATE];

        } else {

          discrete = clock_expected->discrete_clock_rates;
          for (nr = 0; nr < num_rates; ++nr) {
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].lower;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->lower,
                                          ""LOWER WORD"");
            exp_u = clock_expected->discrete_clock_rates == NULL
                        ? 0
                        : discrete[clock_id][nr + rate_index].upper;
            arm_scmi_check_and_report_dec(test_stats, expected_flags_mask,
                                          LEFT_SHIFT(DISCRETE_CLOCK_RATES),
                                          exp_u, rcv_rates->upper,
                                          ""UPPER WORD"");

            if ((rate_index + nr) == 0) {
              rates[MIN_CLOCK] = rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] =
                  rates[MAX_CLOCK] = *rcv_rates;
            } else if ((rate_index + nr) == 1) {
              rates[MIN_CLOCK + 1] = rates[MAX_CLOCK - 1] = rates[MAX_CLOCK] =
                  *rcv_rates;
            }
            rates[MAX_CLOCK - 1] = rates[MAX_CLOCK];
            rates[MAX_CLOCK] = *rcv_rates;
            rcv_rates += 1;
          }
        }
        rate_index += num_rates;
      } while (remaining_rates > 0);
    }
  }
}"
SL-RU-MakiseGUI-971c7c7/MakiseGUI/makise.c	set new border. This region must be smaller then previous. It will be cropped. Borders need for drawing GUI. For gui elements do not leave their & their parent's borders. After setting border & drawing it you need to call makise_rem_border.	2	"MakiseBufferBorderData makise_add_border(MakiseBuffer *buffer,
                                         MakiseBufferBorder b) {
  if (buffer == 0)
    return (MakiseBufferBorderData){0};

  if (b.x < buffer->border.x)
    b.x = buffer->border.x;
  if (b.y < buffer->border.y)
    b.y = buffer->border.y;
  if (b.w > buffer->border.w + buffer->border.x - b.x)
    b.w = buffer->border.w + buffer->border.x - b.x;
  if (b.h > buffer->border.h + buffer->border.y - b.y)
    b.h = buffer->border.h + buffer->border.y - b.y;

  b.ex = b.x + b.w;
  b.ey = b.y + b.h;

  MakiseBufferBorder l = buffer->border;

  buffer->border = b;

  return (MakiseBufferBorderData){b, l};
}"
openastroproject-openastro-ec7e71c/ext/ffmpeg/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= FFMIN(s->max_streams, INT_MAX / sizeof(*streams))) {
    if (s->max_streams < INT_MAX / sizeof(*streams))
      av_log(s, AV_LOG_ERROR,
             ""Number of streams exceeds max_streams parameter (%d), see the ""
             ""documentation if you wish to increase it\n"",
             s->max_streams);
    return NULL;
  }
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"
dakami-autoclave-84ab84b/old_but_working_qemu/block/io.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  enum BdrvTrackedRequestType type) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .type = type,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Write settings INI file via TinyFrame	2	"bool GEX_IniWrite(GexClient *gex, const char *buffer) {
  uint8_t buf[8];
  PayloadBuilder pb = pb_start(buf, 8, NULL);
  pb_u32(&pb, (uint32_t)strlen(buffer));

  GexBulk bw = (GexBulk){
      .buffer = (uint8_t *)buffer,
      .len = (uint32_t)strlen(buffer),
      .req_cmd = MSG_INI_WRITE,
      .req_data = buf,
      .req_len = (uint32_t)pb_length(&pb),
  };

  return GEX_BulkWrite(GEX_SysUnit(gex), &bw);
}"
rexmac-pebble-chronocode-5a85c4a/src/chronocode.c	Initialize the app	2	"static void init(void) {

  SettingsStoreObject stored_settings;

  if (persist_exists(STORAGE_SETTINGS_KEY)) {
    persist_read_data(STORAGE_SETTINGS_KEY, &stored_settings,
                      sizeof(stored_settings));
    settings = stored_settings.flags;
    language_setting = stored_settings.language;
  } else {
    settings = 0;
    language_setting = LANG_EN_US;
  }

  window = window_create();
  window_set_background_color(
      window, (settings & SETTING_INVERTED) > 0 ? GColorWhite : GColorBlack);
  window_set_window_handlers(
      window, (WindowHandlers){.load = window_load, .unload = window_unload});
  window_stack_push(window, true);

  time_t now = time(NULL);
  struct tm *t = localtime(&now);
  update_time(t);

  tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);

  Tuplet initial_settings[] = {
      TupletInteger(SETTING_SYNC_KEY_ALL_CAPS, (settings & SETTING_ALL_CAPS)),
      TupletInteger(SETTING_SYNC_KEY_INVERTED, (settings & SETTING_INVERTED)),
      TupletInteger(SETTING_SYNC_KEY_LANGUAGE, language_setting),
      TupletInteger(SETTING_SYNC_KEY_TWO_MIN_DOTS,
                    (settings & SETTING_TWO_MIN_DOTS))};
  app_sync_init(
      &settings_sync, settings_sync_buffer, sizeof(settings_sync_buffer),
      initial_settings, ARRAY_LENGTH(initial_settings),
      settings_sync_tuple_changed_callback, settings_sync_error_callback, NULL);
  app_message_open(64, 64);
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/spaceshipdlg.c	Popup (or raise) the spaceship dialog for the given player.	2	"void popup_spaceship_dialog(struct player *pPlayer) {
  struct SMALL_DLG *pSpaceShp;

  if (!(pSpaceShp = get_spaceship_dialog(pPlayer))) {
    struct widget *pBuf, *pWindow;
    utf8_str *pstr;
    char cbuf[128];
    SDL_Rect area;

    pSpaceShp = fc_calloc(1, sizeof(struct SMALL_DLG));

    fc_snprintf(cbuf, sizeof(cbuf), _(""The %s Spaceship""),
                nation_adjective_for_player(pPlayer));
    pstr = create_utf8_from_char(cbuf, adj_font(12));
    pstr->style |= TTF_STYLE_BOLD;

    pWindow = create_window_skeleton(NULL, pstr, 0);

    pWindow->action = space_dialog_window_callback;
    set_wstate(pWindow, FC_WS_NORMAL);
    pWindow->data.player = pPlayer;
    pWindow->private_data.small_dlg = pSpaceShp;
    add_to_gui_list(ID_WINDOW, pWindow);
    pSpaceShp->pEndWidgetList = pWindow;

    area = pWindow->area;

    pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                            WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
    pBuf->info_label =
        create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
    pBuf->data.player = pPlayer;
    pBuf->action = exit_space_dialog_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->key = SDLK_ESCAPE;
    area.w = MAX(area.w, (pBuf->size.w + adj_size(10)));

    add_to_gui_list(ID_BUTTON, pBuf);

    pBuf = create_themeicon_button_from_chars(
        current_theme->OK_Icon, pWindow->dst, _(""Launch""), adj_font(12), 0);

    pBuf->action = launch_spaceship_callback;
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_BUTTON, pBuf);

    pstr = create_utf8_from_char(get_spaceship_descr(NULL), adj_font(12));
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);
    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h + adj_size(20);
    add_to_gui_list(ID_LABEL, pBuf);

    pSpaceShp->pBeginWidgetList = pBuf;

    area.w = MAX(area.w, adj_size(300) - (pWindow->size.w - pWindow->area.w));

    resize_window(pWindow, NULL, NULL,
                  (pWindow->size.w - pWindow->area.w) + area.w,
                  (pWindow->size.h - pWindow->area.h) + area.h);

    area = pWindow->area;

    widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                        (main_window_height() - pWindow->size.h) / 2);

    pBuf = pWindow->prev;
    pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
    pBuf->size.y = pWindow->size.y + adj_size(2);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + area.h - pBuf->size.h - adj_size(7);

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + (area.w - pBuf->size.w) / 2;
    pBuf->size.y = area.y + adj_size(7);

    dialog_list_prepend(dialog_list, pSpaceShp);

    refresh_spaceship_dialog(pPlayer);
  } else {
    if (select_window_group_dialog(pSpaceShp->pBeginWidgetList,
                                   pSpaceShp->pEndWidgetList)) {
      widget_flush(pSpaceShp->pEndWidgetList);
    }
  }
}"
particle-iot-device-os-7fbf145/wiring/inc/spark_wiring_mesh.h	Determines if the given handler exists.	2	"#include ""scope_guard.h""
#include <memory>

#include ""spark_wiring_thread.h""

namespace spark {

class MeshSignal : public particle::Signal {
public:
  int rssi = 2;
  int qual = 0;

  MeshSignal() {}
  virtual ~MeshSignal(){};

  operator int8_t() const { return 2; }

  virtual hal_net_access_tech_t getAccessTechnology() const {
    return NET_ACCESS_TECHNOLOGY_IEEE802154;
  }

  virtual float getStrength() const { return 0.0f; }"
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the aggregated slab journal statistics for the slabs in this allocator.	2	"SlabJournalStatistics
getSlabJournalStatistics(const BlockAllocator *allocator) {
  const AtomicSlabJournalStatistics *atoms = &allocator->slabJournalStatistics;
  return (SlabJournalStatistics){
      .diskFullCount = atomicLoad64(&atoms->diskFullCount),
      .flushCount = atomicLoad64(&atoms->flushCount),
      .blockedCount = atomicLoad64(&atoms->blockedCount),
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
      .tailBusyCount = atomicLoad64(&atoms->tailBusyCount),
  };
}"
opalenzuela-opendomo-1adadbd/src/odbase/src/script.c	Process a comments line and format the output in HTML or XML.	2	"script_process_comments(const char *buf) {
  char tipname[50];
  char *classname = NULL;
  char *contents = NULL;

  if (strlen(buf) < 3)
    return;

  if (gui == html) {
    if ((buf[0] == '-') && (buf[1] == '-')) {
      printf(""\t<hr/>\n"");
    } else if (SPELL3(buf, 'E', 'R', 'R')) {
      printf(""\t<p class='error'>%s</p>\n"", T(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R')) {
      printf(""\t<p class='warning'>%s</p>\n"", T(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F')) {
      printf(""\t<p class='info'>%s</p>\n"", T(buf += 5));
    } else if (SPELL3(buf, 'T', 'I', 'P')) {
      printf(""\t<p class='tooltip tip'>%s</p>\n"", T(buf += 4));
    } else if (SPELL3(buf, 'L', 'O', 'A')) {

      printf(""\t<p class='loading'>%s</p>\n"", T(buf += 8));

      printf(""<script type='text/Javascript'>\n""
             ""$(function($){\n""
             ""	$('p.loading').hide() ;\n""
             ""});\n""
             ""</script>\n"");
    } else if (SPELL3(buf, 'U', 'R', 'L')) {
      printf(""\t<p class='link'>""
             ""<a href='%s' target='_blank'>%s</a></p>\n"",
             buf += 4, buf);
    } else if (buf[0] == '>') {
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    } else {

      if (buf[0] == ' ') {
        printf(""\t<p class='comments'>%s</p>\n"", T(buf += 1));
      } else {
        classname = strtok(buf, "" "");
        contents = strtok(NULL, ""\n"");

        printf(""\t<p class='%s'>%s</p>\n"", classname, T(contents));
      }
    }
  } else {
    if (SPELL3(buf, 'E', 'R', 'R') || SPELL3(buf, 'e', 'r', 'r')) {
      printf(""\t<error description='%s'/>\n"", CT(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R') || SPELL3(buf, 'w', 'a', 'r')) {
      printf(""\t<warning description='%s'/>\n"", CT(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F') || SPELL3(buf, 'i', 'n', 'f'))
      printf(""\t<info description='%s'/>\n"", CT(buf += 5));
    else if (buf[0] == '>')
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    else
      printf(""\t<message description='%s'/>\n"", CT(buf += 1));
  }
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties."	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/handler/mimemap.c	returns the default mime attributes given a mime type	2	"void h2o_mimemap_get_default_attributes(const char *_mime,
                                        h2o_mime_attributes_t *attr) {
  char *mime = alloca(strlen(_mime) + 1);
  strcpy(mime, _mime);

  const char *type_end_at;

  if ((type_end_at = strchr(mime, ';')) == NULL)
    type_end_at = mime + strlen(mime);

  *attr = (h2o_mime_attributes_t){0};

  if (h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/css"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime,
                H2O_STRLIT(""application/javascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/ecmascript"")) ||
      h2o_memis(mime, type_end_at - mime, H2O_STRLIT(""text/javascript""))) {
    attr->is_compressible = 1;
    attr->priority = H2O_MIME_ATTRIBUTE_PRIORITY_HIGHEST;
  } else if (h2o_memis(mime, type_end_at - mime,
                       H2O_STRLIT(""application/json"")) ||
             strncmp(mime, ""text/"", 5) == 0 ||
             h2o_strstr(mime, type_end_at - mime, H2O_STRLIT(""+xml"")) !=
                 SIZE_MAX) {
    attr->is_compressible = 1;
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/KeyboardHost/KeyboardHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs."	1	"void Keyboard_HID_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    ReadNextReport();

    break;
  }
}"
HiPhish-XeenTools-ee7c26c/Source/cpp/cpp_tool.c	Read a copy-protection entry from file.	2	"int xeen_read_copy_protection(FILE *fp, long o, int index,
                              XeenCopyProtection *prot) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
    INVALID_DATA,
  } error = SUCCESS;

  uint8_t bytes[LENGTH];

  uint8_t counter = (index * 16);

  if (!fp || !prot) {
    error = INVALID_ARGS;
    goto end;
  } else if (prot->line != 0 || prot->page != 0 || prot->word != 0 ||
             prot->string[0] != '\0') {
    error = INVALID_ARGS;
    goto end;
  }

  if (fseek(fp, o + LENGTH * index, SEEK_SET)) {
    error = FREAD_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), LENGTH, fp) != sizeof(uint8_t) * LENGTH) {
    error = FREAD_FAIL;
    goto end;
  }

  for (int i = 0; i < LENGTH; ++i) {
    bytes[i] ^= (counter++);
  }

  if (bytes[LENGTH - 1] != '\0') {
    error = INVALID_DATA;
    goto end;
  }

  *prot = (XeenCopyProtection){
      .page = bytes[0],
      .line = bytes[1],
      .word = bytes[2],
  };

  for (int i = 0; i < XEEN_CPP_LENGTH; ++i) {
    prot->string[i] = bytes[3 + i];
  }

end:
  return error;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Core/HostStandardReq.c	"Selects a given alternative setting for the specified interface, via a SET INTERFACE standard request to the attached device."	1	"uint8_t USB_Host_SetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        const uint8_t AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_SetInterface,
      .wValue = AltSetting,
      .wIndex = InterfaceIndex,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	"Constructs a quaternion from a four-element vector. Note that the imaginary (vector) part of the quaternion comes from lanes 0, 1, and 2 of the vector, and the real (scalar) part comes from lane 3."	2	"static inline SIMD_CFUNC simd_quatd simd_quaternion(simd_double4 xyzr) {
  return (simd_quatd){xyzr};
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/repodlgs.c	Popup (or raise) the economy report (F5). It may or may not be modal.	2	"void economy_report_dialog_popup(bool make_modal) {
  SDL_Color bg_color = {255, 255, 255, 128};
  SDL_Color bg_color2 = {255, 255, 255, 136};
  SDL_Color bg_color3 = {255, 255, 255, 64};
  struct widget *pBuf;
  struct widget *pWindow, *pLast;
  utf8_str *pstr, *pstr2;
  SDL_Surface *pSurf, *pText_Name, *pText, *pZoom;
  SDL_Surface *pBackground;
  int i, count, h = 0;
  int w = 0;
  int w2 = 0;
  int w3 = 0;
  int tax, total, entries_used = 0;
  char cbuf[128];
  struct improvement_entry entries[B_LAST];
  SDL_Rect dst;
  SDL_Rect area;
  struct government *pGov = government_of_player(client.conn.playing);
  SDL_Surface *pTreasuryText;
  SDL_Surface *pTaxRateText;
  SDL_Surface *pTotalIncomeText;
  SDL_Surface *pTotalCostText;
  SDL_Surface *pNetIncomeText;
  SDL_Surface *pMaxRateText;

  if (pEconomyDlg) {
    return;
  }

  pBuf = get_tax_rates_widget();
  set_wstate(pBuf, FC_WS_DISABLED);
  widget_redraw(pBuf);
  widget_mark_dirty(pBuf);

  pEconomyDlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  get_economy_report_data(entries, &entries_used, &total, &tax);

  pstr = create_utf8_from_char(_(""Economy Report""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);
  pEconomyDlg->pEndWidgetList = pWindow;
  set_wstate(pWindow, FC_WS_NORMAL);
  pWindow->action = economy_dialog_callback;

  add_to_gui_list(ID_ECONOMY_DIALOG_WINDOW, pWindow);

  area = pWindow->area;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Treasury: ""));
  pstr2 = create_utf8_from_char(cbuf, adj_font(12));
  pstr2->style |= TTF_STYLE_BOLD;
  pTreasuryText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTreasuryText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", client.conn.playing->economic.gold);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(pIcons->pBIG_Coin, pWindow->dst, pstr,
                          (WF_RESTORE_BACKGROUND | WF_ICON_CENTER_RIGHT));

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Tax Rate: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTaxRateText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTaxRateText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "", client.conn.playing->economic.tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w + pBuf->next->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pTotalIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Total Cost: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pTotalCostText = create_text_surf_from_utf8(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""Net Income: ""));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pNetIncomeText = create_text_surf_from_utf8(pstr2);
  w3 = MAX(w3, pNetIncomeText->w);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d"", tax - total);
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

  if (tax - total < 0) {
    pstr->fgcol = *get_theme_color(COLOR_THEME_ECONOMYDLG_NEG_TEXT);
  }

  pBuf = create_iconlabel(NULL, pWindow->dst, pstr, WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_LABEL, pBuf);

  w = MAX(w, pBuf->size.w);
  h += pBuf->size.h;

  fc_snprintf(cbuf, sizeof(cbuf), _(""%s max rate : %d%%""),
              government_name_translation(pGov),
              get_player_bonus(client.conn.playing, EFT_MAX_RATES));
  copy_chars_to_utf8_str(pstr2, cbuf);
  pMaxRateText = create_text_surf_from_utf8(pstr2);

  FREEUTF8STR(pstr2);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_LUX_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);
  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);
  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_BLOCK_CHECKBOX, pBuf);

  w2 = adj_size(10) + pBuf->size.w;

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.luxury;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_SCROLLBAR, pBuf);

  w2 += adj_size(184);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.luxury);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Luxury, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);
  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_LUX_LABEL, pBuf);

  w2 += (adj_size(5) + pBuf->size.w + adj_size(10));

  fc_snprintf(cbuf, sizeof(cbuf), _(""Lock""));
  pstr = create_utf8_from_char(cbuf, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_checkbox(pWindow->dst,
                         SDL_Client_Flags & CF_CHANGE_TAXRATE_SCI_BLOCK,
                         WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL);

  set_new_checkbox_theme(pBuf, current_theme->LOCK_Icon,
                         current_theme->UNLOCK_Icon);

  pBuf->info_label = pstr;
  pBuf->action = toggle_block_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_BLOCK_CHECKBOX, pBuf);

  pBuf = create_horizontal(current_theme->Horiz, pWindow->dst, adj_size(30),
                           (WF_FREE_DATA | WF_RESTORE_BACKGROUND));

  pBuf->action = horiz_taxrate_callback;
  pBuf->data.ptr = fc_calloc(1, sizeof(int));
  *(int *)pBuf->data.ptr = client.conn.playing->economic.science;

  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_SCROLLBAR, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), ""%d%% "",
              client.conn.playing->economic.science);
  pstr = create_utf8_from_char(cbuf, adj_font(11));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(pIcons->pBIG_Colb, pWindow->dst, pstr,
                          WF_RESTORE_BACKGROUND);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_SCI_LABEL, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Update""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon_button(current_theme->Small_OK_Icon, pWindow->dst,
                                 pstr, 0);
  pBuf->action = apply_taxrates_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_OK_BUTTON, pBuf);

  fc_snprintf(cbuf, sizeof(cbuf), _(""Close Dialog (Esc)""));
  pstr = create_utf8_from_char(cbuf, adj_font(12));
  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label = pstr;
  pBuf->action = exit_economy_dialog_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_CHANGE_TAXRATE_DLG_CANCEL_BUTTON, pBuf);

  h += adj_size(5);

  pLast = pBuf;
  if (entries_used > 0) {

    pBackground = create_surf(adj_size(116), adj_size(116), SDL_SWSURFACE);

    SDL_FillRect(pBackground, NULL, map_rgba(pBackground->format, bg_color));

    create_frame(pBackground, 0, 0, pBackground->w - 1, pBackground->h - 1,
                 get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (SF_CENTER | TTF_STYLE_BOLD);
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};

    for (i = 0; i < entries_used; i++) {
      struct improvement_entry *p = &entries[i];
      struct impr_type *pImprove = p->type;

      pSurf = crop_rect_from_surface(pBackground, NULL);

      fc_snprintf(cbuf, sizeof(cbuf), ""%s"",
                  improvement_name_translation(pImprove));

      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style |= TTF_STYLE_BOLD;
      pText_Name =
          create_text_surf_smaller_than_w(pstr, pSurf->w - adj_size(4));

      fc_snprintf(cbuf, sizeof(cbuf), ""%s %d\n%s %d"", _(""Built""), p->count,
                  _(""U Total""), p->total_cost);
      copy_chars_to_utf8_str(pstr, cbuf);
      pstr->style &= ~TTF_STYLE_BOLD;

      pText = create_text_surf_from_utf8(pstr);

      pZoom = get_building_surface(pImprove);
      pZoom = zoomSurface(pZoom, DEFAULT_ZOOM * ((float)54 / pZoom->w),
                          DEFAULT_ZOOM * ((float)54 / pZoom->w), 1);

      dst.x = (pSurf->w - pZoom->w) / 2;
      dst.y = (pSurf->h / 2 - pZoom->h) / 2;
      alphablit(pZoom, NULL, pSurf, &dst, 255);
      dst.y += pZoom->h;
      FREESURFACE(pZoom);

      dst.x = (pSurf->w - pText_Name->w) / 2;
      dst.y += ((pSurf->h - dst.y) -
                (pText_Name->h + (pIcons->pBIG_Coin->h + 2) + pText->h)) /
               2;
      alphablit(pText_Name, NULL, pSurf, &dst, 255);

      dst.y += pText_Name->h;
      if (p->cost) {
        dst.x = (pSurf->w - p->cost * (pIcons->pBIG_Coin->w + 1)) / 2;
        for (count = 0; count < p->cost; count++) {
          alphablit(pIcons->pBIG_Coin, NULL, pSurf, &dst, 255);
          dst.x += pIcons->pBIG_Coin->w + 1;
        }
      } else {

        if (!is_wonder(pImprove)) {
          copy_chars_to_utf8_str(pstr, _(""Nation""));
        } else {
          copy_chars_to_utf8_str(pstr, _(""Wonder""));
        }

        pZoom = create_text_surf_from_utf8(pstr);

        dst.x = (pSurf->w - pZoom->w) / 2;
        alphablit(pZoom, NULL, pSurf, &dst, 255);
        FREESURFACE(pZoom);
      }

      dst.y += (pIcons->pBIG_Coin->h + adj_size(2));
      dst.x = (pSurf->w - pText->w) / 2;
      alphablit(pText, NULL, pSurf, &dst, 255);

      FREESURFACE(pText);
      FREESURFACE(pText_Name);

      pBuf =
          create_icon2(pSurf, pWindow->dst,
                       (WF_RESTORE_BACKGROUND | WF_FREE_THEME | WF_FREE_DATA));

      set_wstate(pBuf, FC_WS_NORMAL);

      pBuf->data.cont = fc_calloc(1, sizeof(struct CONTAINER));
      pBuf->data.cont->id0 = improvement_number(p->type);
      pBuf->data.cont->id1 = p->count;
      pBuf->action = popup_sell_impr_callback;

      add_to_gui_list(MAX_ID - i, pBuf);

      if (i > (TARGETS_ROW * TARGETS_COL - 1)) {
        set_wflag(pBuf, WF_HIDDEN);
      }
    }

    FREEUTF8STR(pstr);
    FREESURFACE(pBackground);

    pEconomyDlg->pEndActiveWidgetList = pLast->prev;
    pEconomyDlg->pBeginWidgetList = pBuf;
    pEconomyDlg->pBeginActiveWidgetList = pEconomyDlg->pBeginWidgetList;

    if (entries_used > (TARGETS_ROW * TARGETS_COL)) {
      pEconomyDlg->pActiveWidgetList = pEconomyDlg->pEndActiveWidgetList;
      count = create_vertical_scrollbar(pEconomyDlg, TARGETS_COL, TARGETS_ROW,
                                        TRUE, TRUE);
      h += (TARGETS_ROW * pBuf->size.h + adj_size(10));
    } else {
      count = 0;
      if (entries_used > TARGETS_COL) {
        h += pBuf->size.h;
      }
      h += (adj_size(10) + pBuf->size.h);
    }
    count = TARGETS_COL * pBuf->size.w + count;
  } else {
    pEconomyDlg->pBeginWidgetList = pBuf;
    h += adj_size(10);
    count = 0;
  }

  area.w = MAX(area.w, MAX(adj_size(10) + w3 + w + w2, count));
  area.h = h;

  pBackground = theme_get_background(theme, BACKGROUND_ECONOMYDLG);
  if (resize_window(pWindow, pBackground, NULL,
                    (pWindow->size.w - pWindow->area.w) + area.w,
                    (pWindow->size.h - pWindow->area.h) + area.h)) {
    FREESURFACE(pBackground);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + adj_size(10) + pTreasuryText->w;
  pBuf->size.y = area.y + adj_size(5);

  w = pTreasuryText->w + pBuf->size.w;
  h = pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTaxRateText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTaxRateText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pTotalCostText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pTotalCostText->w + pBuf->size.w);
  h += pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10) + pNetIncomeText->w;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

  w = MAX(w, pNetIncomeText->w + pBuf->size.w);
  h += pBuf->size.h;

  dst.x = area.x;
  dst.y = area.y;
  dst.w = area.w;
  dst.h = h + adj_size(15);
  h = dst.h;

  fill_rect_alpha(pWindow->theme, &dst, &bg_color2);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  dst.x = area.x + adj_size(10);
  dst.y = area.y + adj_size(5);

  alphablit(pTreasuryText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTreasuryText->h;
  FREESURFACE(pTreasuryText);

  alphablit(pTaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTaxRateText->h;
  FREESURFACE(pTaxRateText);

  alphablit(pTotalIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalIncomeText->h;
  FREESURFACE(pTotalIncomeText);

  alphablit(pTotalCostText, NULL, pWindow->theme, &dst, 255);
  dst.y += pTotalCostText->h;
  FREESURFACE(pTotalCostText);

  alphablit(pNetIncomeText, NULL, pWindow->theme, &dst, 255);
  dst.y += pNetIncomeText->h;
  FREESURFACE(pNetIncomeText);

  dst.x = area.x + adj_size(10) + w +
          ((area.w - (w + adj_size(10)) - pMaxRateText->w) / 2);
  dst.y = area.y + adj_size(5);

  alphablit(pMaxRateText, NULL, pWindow->theme, &dst, 255);
  dst.y += (pMaxRateText->h + 1);
  FREESURFACE(pMaxRateText);

  dst.x = area.x + adj_size(10) + w +
          (area.w - (w + adj_size(10)) - adj_size(184)) / 2;
  dst.w = adj_size(184);
  dst.h = current_theme->Horiz->h - adj_size(2);

  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.luxury * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  dst.y += current_theme->Horiz->h + 1;
  fill_rect_alpha(pWindow->theme, &dst, &bg_color3);

  create_frame(pWindow->theme, dst.x, dst.y, dst.w - 1, dst.h - 1,
               get_theme_color(COLOR_THEME_ECONOMYDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x - pBuf->size.w;
  pBuf->size.y = dst.y - adj_size(2);

  pBuf = pBuf->prev;
  pBuf->size.x =
      dst.x + adj_size(2) + (client.conn.playing->economic.science * 3) / 2;
  pBuf->size.y = dst.y - 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + dst.w + adj_size(5);
  pBuf->size.y = dst.y + 1;

  pBuf = pBuf->prev;
  pBuf->size.x = dst.x + (dst.w - pBuf->size.w) / 2;
  pBuf->size.y = dst.y + dst.h + adj_size(3);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  if (entries_used > 0) {
    setup_vertical_widgets_position(TARGETS_COL, area.x, area.y + h, 0, 0,
                                    pEconomyDlg->pBeginActiveWidgetList,
                                    pEconomyDlg->pEndActiveWidgetList);
    if (pEconomyDlg->pScroll) {
      setup_vertical_scrollbar_area(pEconomyDlg->pScroll, area.x + area.w - 1,
                                    area.y + h, area.h - h - 1, TRUE);
    }
  }

  redraw_group(pEconomyDlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);
  flush_dirty();
}"
darktable-org-darktable-32fab21/src/iop/flip.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_flip_params_t p = (dt_iop_flip_params_t){ORIENTATION_NONE};
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  p.orientation = ORIENTATION_NULL;
  dt_gui_presets_add_generic(_(""autodetect""), self->op, self->version(), &p,
                             sizeof(p), 1);
  dt_gui_presets_update_autoapply(_(""autodetect""), self->op, self->version(),
                                  1);

  p.orientation = ORIENTATION_NONE;
  dt_gui_presets_add_generic(_(""no rotation""), self->op, self->version(), &p,
                             sizeof(p), 1);

  p.orientation = ORIENTATION_FLIP_HORIZONTALLY;
  dt_gui_presets_add_generic(_(""flip horizontally""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_FLIP_VERTICALLY;
  dt_gui_presets_add_generic(_(""flip vertically""), self->op, self->version(),
                             &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by -90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_CCW_90_DEG;
  dt_gui_presets_add_generic(_(""rotate by  90 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.orientation = ORIENTATION_ROTATE_180_DEG;
  dt_gui_presets_add_generic(_(""rotate by 180 degrees""), self->op,
                             self->version(), &p, sizeof(p), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
DelusionalLogic-NeoComp-271e784/src/compton.c	Do the actual work.	2	"void session_run(session_t *ps) {
#ifdef DEBUG_PROFILE
  struct ProfilerWriterSession profSess;
  profilerWriter_init(&profSess);
#endif

  paint_preprocess(ps);

  timestamp lastTime;
  if (!getTime(&lastTime)) {
    printf_errf(""Failed getting time"");
    session_destroy(ps);
    exit(1);
  }

  assign_depth(&ps->win_list, &ps->order);

  ps->idling = false;

  while (!ps->reset) {

    zone_start(&ZONE_global);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

    zone_enter(&ZONE_input);

    while (mainloop(ps))
      ;

    Swiss *em = &ps->win_list;

    for_components(it, em, COMPONENT_PHYSICAL, COMPONENT_TRACKS_WINDOW,
                   COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct TracksWindowComponent *window =
          swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);

      XWindowAttributes attribs;
      if (!XGetWindowAttributes(ps->xcontext.display, window->id, &attribs)) {
        printf_errf(""Failed getting window attributes while mapping"");
        swiss_removeComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
        continue;
      }

      Vector2 extents = {{attribs.width + attribs.border_width * 2,
                          attribs.height + attribs.border_width * 2}};

      Vector2 offset = {{-attribs.border_width, -attribs.border_width}};

      XserverRegion window_region = XFixesCreateRegionFromWindow(
          ps->xcontext.display, window->id, ShapeBounding);

      XRectangle default_clip = {.x = offset.x,
                                 .y = offset.y,
                                 .width = extents.x,
                                 .height = extents.y};
      XserverRegion default_clip_region =
          XFixesCreateRegion(ps->xcontext.display, &default_clip, 1);
      XFixesIntersectRegion(ps->xcontext.display, window_region, window_region,
                            default_clip_region);

      int rect_count;
      XRectangle *rects =
          XFixesFetchRegion(ps->xcontext.display, window_region, &rect_count);

      XFixesDestroyRegion(ps->xcontext.display, window_region);

      vector_init(&shapeDamaged->rects, sizeof(struct Rect), rect_count);

      convert_xrects_to_relative_rect(rects, rect_count, &extents, &offset,
                                      &shapeDamaged->rects);
    }

    zone_leave(&ZONE_input);

    timestamp currentTime;
    if (!getTime(&currentTime)) {
      printf_errf(""Failed getting time"");
      exit(1);
    }

    double dt = timeDiff(&lastTime, &currentTime);

    ps->skip_poll = false;

    if (ps->o.benchmark) {
      if (ps->o.benchmark_wid) {
        win *w = find_win(ps, ps->o.benchmark_wid);
        if (!w) {
          printf_errf(""(): Couldn't find specified benchmark window."");
          session_destroy(ps);
          exit(1);
        }
      }
    }

    ps->idling = true;

    zone_enter(&ZONE_preprocess);

    paint_preprocess(ps);

    zone_leave(&ZONE_preprocess);

    zone_enter(&ZONE_update);

    zone_enter(&ZONE_update_z);
    assign_depth(&ps->win_list, &ps->order);
    zone_leave(&ZONE_update_z);

    zone_enter(&ZONE_update_wintype);

    for_components(it, em, COMPONENT_MAP, CQ_END) {
      swiss_addComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
    }

    fill_wintype_changes(&ps->win_list, ps);

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      swiss_ensureComponent(em, COMPONENT_FOCUS_CHANGE, it.id);
    }

    for_components(it, em, COMPONENT_WINTYPE_CHANGE, CQ_END) {
      struct WintypeChangedComponent *wintypeChanged =
          swiss_getComponent(em, COMPONENT_WINTYPE_CHANGE, it.id);
      struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

      w->window_type = wintypeChanged->newType;
    }
    zone_leave(&ZONE_update_wintype);

    if (ps->o.shadow_blacklist) {
      zone_enter(&ZONE_update_shadow_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->shadow = (ps->o.wintype_shadow[w->window_type] &&
                       !win_match(ps, w, ps->o.shadow_blacklist) &&
                       !(ps->o.respect_prop_shadow));
        }
      }
      zone_leave(&ZONE_update_shadow_blacklist);
    }

    if (ps->o.fade_blacklist) {
      zone_enter(&ZONE_update_fade_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);

        if (win_mapped(em, it.id)) {

          if (win_match(ps, w, ps->o.fade_blacklist)) {
            w->fade = false;
          } else {
            w->fade = ps->o.wintype_fade[w->window_type];
          }
        }
      }
      zone_leave(&ZONE_update_fade_blacklist);
    }

    if (ps->o.blur_background_blacklist) {
      zone_enter(&ZONE_update_blur_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          bool blur_background_new =
              ps->o.blur_background &&
              !win_match(ps, w, ps->o.blur_background_blacklist);

          win_set_blur_background(ps, w, blur_background_new);
        }
      }
      zone_leave(&ZONE_update_blur_blacklist);
    }

    if (ps->o.paint_blacklist) {
      zone_enter(&ZONE_update_paint_blacklist);
      for_components(it, em, COMPONENT_MUD, CQ_END) {
        struct _win *w = swiss_getComponent(em, COMPONENT_MUD, it.id);
        if (win_mapped(em, it.id)) {
          w->paint_excluded = win_match(ps, w, ps->o.paint_blacklist);
        }
      }
      zone_leave(&ZONE_update_paint_blacklist);
    }

    zone_enter(&ZONE_input_react);
    commit_destroy(&ps->win_list);
    commit_map(&ps->win_list, &ps->atoms, &ps->xcontext);
    commit_unmap(&ps->win_list, &ps->xcontext);
    commit_opacity_change(&ps->win_list, ps->o.opacity_fade_time,
                          ps->o.bg_opacity_fade_time);
    commit_move(&ps->win_list, &ps->order);
    commit_resize(&ps->win_list, &ps->order);
    commit_reshape(&ps->win_list, &ps->xcontext);
    zone_leave(&ZONE_input_react);

    zone_enter(&ZONE_make_cutout);
    {
      XserverRegion newShape = XFixesCreateRegion(ps->dpy, NULL, 0);
      for_components(it, em, COMPONENT_MUD, COMPONENT_TRACKS_WINDOW,
                     COMPONENT_PHYSICAL, CQ_NOT, COMPONENT_REDIRECTED, CQ_END) {
        struct TracksWindowComponent *tracksWindow =
            swiss_getComponent(em, COMPONENT_TRACKS_WINDOW, it.id);
        struct PhysicalComponent *physical =
            swiss_getComponent(em, COMPONENT_PHYSICAL, it.id);

        if (win_mapped(em, it.id)) {
          XserverRegion windowRegion = XFixesCreateRegionFromWindow(
              ps->xcontext.display, tracksWindow->id, ShapeBounding);
          XFixesTranslateRegion(ps->dpy, windowRegion, physical->position.x + 1,
                                physical->position.y + 1);
          XFixesUnionRegion(ps->xcontext.display, newShape, newShape,
                            windowRegion);
          XFixesDestroyRegion(ps->xcontext.display, windowRegion);
        }
      }
      XFixesInvertRegion(ps->dpy, newShape,
                         &(XRectangle){0, 0, ps->root_size.x, ps->root_size.y},
                         newShape);
      XFixesSetWindowShapeRegion(ps->dpy, ps->overlay, ShapeBounding, 0, 0,
                                 newShape);
      XFixesDestroyRegion(ps->xcontext.display, newShape);
    }
    zone_leave(&ZONE_make_cutout);

    zone_enter(&ZONE_prop_blur_damage);
    damage_blur_over_damaged(&ps->win_list, &ps->order);
    zone_leave(&ZONE_prop_blur_damage);

    zone_enter(&ZONE_update_textures);
    update_window_textures(&ps->win_list, &ps->xcontext,
                           &ps->psglx->shared_fbo);
    zone_leave(&ZONE_update_textures);

    update_focused_state(&ps->win_list, ps);
    calculate_window_opacity(ps, &ps->win_list);
    start_focus_fade(&ps->win_list, ps->o.opacity_fade_time,
                     ps->o.bg_opacity_fade_time, ps->o.dim_fade_time);

    zone_enter(&ZONE_update_fade);

    damage_blur_over_fade(&ps->win_list);
    syncronize_fade_opacity(&ps->win_list);
    if (do_win_fade(&ps->curve, dt, &ps->win_list)) {
      ps->skip_poll = true;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      t->time += dt;
    }

    for_components(it, em, COMPONENT_TRANSITIONING, CQ_END) {
      struct TransitioningComponent *t =
          swiss_getComponent(em, COMPONENT_TRANSITIONING, it.id);
      if (t->time >= t->duration)
        swiss_removeComponent(em, COMPONENT_TRANSITIONING, it.id);
    }

    zone_leave(&ZONE_update_fade);

    transition_faded_entities(&ps->win_list);
    remove_texture_invis_windows(&ps->win_list);
    finish_destroyed_windows(&ps->win_list, ps);
    zone_leave(&ZONE_update);

    Vector opaque;
    vector_init(&opaque, sizeof(win_id), ps->order.size);
    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED, CQ_NOT,
                   COMPONENT_BGOPACITY, COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&opaque, &it.id);
    }
    vector_qsort(&opaque, window_zcmp, &ps->win_list);
    Vector transparent;
    vector_init(&transparent, sizeof(win_id), ps->order.size);

    for_components(it, &ps->win_list, COMPONENT_MUD, COMPONENT_TEXTURED,
                   COMPONENT_PHYSICAL, CQ_END) {
      vector_putBack(&transparent, &it.id);
    }
    vector_qsort(&transparent, window_zcmp, &ps->win_list);

    Vector opaque_shadow;
    vector_init(&opaque_shadow, sizeof(win_id), ps->order.size);
    fetchSortedWindowsWith(&ps->win_list, &opaque_shadow, COMPONENT_MUD,
                           COMPONENT_Z, COMPONENT_PHYSICAL, CQ_NOT,
                           COMPONENT_OPACITY, COMPONENT_SHADOW, CQ_END);

    zone_enter(&ZONE_effect_textures);

    zone_enter(&ZONE_update_shadow);
    windowlist_updateShadow(ps, &transparent);
    zone_leave(&ZONE_update_shadow);

    if (ps->o.blur_background)
      windowlist_updateBlur(ps);

    zone_leave(&ZONE_effect_textures);

    {
      static int paint = 0;

      zone_enter(&ZONE_paint);

      glDepthMask(GL_TRUE);
      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      static const GLenum DRAWBUFS[2] = {GL_BACK_LEFT};
      glDrawBuffers(1, DRAWBUFS);
      glViewport(0, 0, ps->root_size.x, ps->root_size.y);

      glClearDepth(1.0);
      glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
      glDepthFunc(GL_LESS);

      windowlist_drawBackground(ps, &opaque);
      windowlist_drawTint(ps);
      windowlist_draw(ps, &opaque);

      paint_root(ps);

      windowlist_drawTransparent(ps, &transparent);

#ifdef DEBUG_WINDOWS

      draw_component_debug(&ps->win_list, &ps->root_size);
#endif

      vector_kill(&opaque_shadow);
      vector_kill(&transparent);
      vector_kill(&opaque);

      zone_leave(&ZONE_paint);

      paint++;
      if (ps->o.benchmark && paint >= ps->o.benchmark) {
#ifdef DEBUG_PROFILE
        profilerWriter_kill(&profSess);
#endif
        session_destroy(ps);
        exit(0);
      }
    }

    zone_enter(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_MAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_UNMAP);
    swiss_resetComponent(&ps->win_list, COMPONENT_MOVE);
    swiss_removeComponentWhere(
        &ps->win_list, COMPONENT_RESIZE,
        (enum ComponentType[]){COMPONENT_PHYSICAL, CQ_END});

    swiss_resetComponent(em, COMPONENT_WINTYPE_CHANGE);

    swiss_resetComponent(&ps->win_list, COMPONENT_FOCUS_CHANGE);

    for_components(it, em, COMPONENT_SHAPE_DAMAGED, CQ_END) {
      struct ShapeDamagedEvent *shapeDamaged =
          swiss_getComponent(em, COMPONENT_SHAPE_DAMAGED, it.id);
      if (shapeDamaged->rects.elementSize != 0) {
        vector_kill(&shapeDamaged->rects);
      }
    }
    swiss_resetComponent(&ps->win_list, COMPONENT_SHAPE_DAMAGED);

    zone_leave(&ZONE_remove_input);

    swiss_resetComponent(&ps->win_list, COMPONENT_CONTENTS_DAMAGED);

#ifdef FRAMERATE_DISPLAY
    update_debug_graph(&ps->debug_graph, currentTime);
    draw_debug_graph(&ps->debug_graph, &(Vector2){{10, ps->root_size.y - 10}});
#endif

    struct ZoneEventStream *event_stream = zone_package(&ZONE_global);
#ifdef DEBUG_PROFILE

    profilerWriter_emitFrame(&profSess, event_stream);
#endif

    glXSwapBuffers(ps->dpy, get_tgt_window(ps));
    glFinish();

    lastTime = currentTime;
  }

#ifdef DEBUG_PROFILE
  profilerWriter_kill(&profSess);
#endif
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Device/CDC.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t),
                           NO_STREAM_CALLBACK);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
      NO_STREAM_CALLBACK);
  Endpoint_ClearIN();
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities."	1	"uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
                          SCSI_Inquiry_Response_t *const InquiryPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, InquiryPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Publishes the message to the current process and frees the strings.	2	"static void fio_publish2process(fio_msg_internal_s *m) {
  fio_msg_internal_finalize(m);
  channel_s *ch;
  if (m->filter) {
    ch = fio_filter_find_dup(m->filter);
    if (!ch) {
      goto finish;
    }
  } else {
    ch = fio_channel_find_dup(m->channel);
  }

  if (ch) {
    fio_defer_push_urgent(fio_publish2channel_task, ch,
                          fio_msg_internal_dup(m));
  }
  if (m->filter == 0) {

    fio_lock(&fio_postoffice.patterns.lock);
    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {
      if (!p->hash) {
        continue;
      }

      if (p->obj->match(
              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},
              m->channel)) {
        fio_channel_dup(p->obj);
        fio_defer_push_urgent(fio_publish2channel_task, p->obj,
                              fio_msg_internal_dup(m));
      }
    }
    fio_unlock(&fio_postoffice.patterns.lock);
  }
finish:
  fio_msg_internal_free(m);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/macsub.c	Returns a macro substitution result wrapping a silent error as produced by ava_macsub_silent_error().	2	"ava_macro_subst_result
ava_macsub_silent_error_result(const ava_compile_location *location) {
  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = ava_macsub_silent_error(location)};
}"
opticron-libuweave-2e5e385/src/ble_transport.c	Initializes a BLE transport service to handle BLE input and registers it in the runloop.	0	"bool uw_ble_transport_init(UwBleTransport *transport, UwDevice *device) {
  assert(transport != NULL && device != NULL);

  memset(transport, 0, sizeof(UwBleTransport));
  transport->device = device;

  uw_buffer_init(&transport->read_buffer, transport->read_data,
                 sizeof(transport->read_data));

  uw_buffer_init(&transport->write_buffer, transport->write_data,
                 sizeof(transport->write_data));

  uw_session_init_(&transport->session, device);

  uw_device_channel_init_(
      &transport->device_channel,
      (UwDeviceChannelHandshakeConfig){.handler = handshake_exchange_handler_,
                                       .data = (void *)transport},
      (UwDeviceChannelConnectionResetConfig){
          .handler = connection_reset_handler_, .data = (void *)transport},
      &transport->read_buffer, &transport->write_buffer, UW_BLE_PACKET_SIZE);

  uw_service_init_(&transport->service, service_start_handler_,
                   service_event_handler_, service_stop_handler_, transport);

  uw_device_register_service_(transport->device, &transport->service);

  UwSettings *settings = uw_device_get_settings(transport->device);
  settings->supports_ble_40 = true;

  return true;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command."	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
graphitemaster-redroid-9cdd940/string.c	Constructs an empty managed string object.	2	"string_t *string_construct(void) {
  string_t *string =
      memcpy(malloc(sizeof(string_t)),
             &(string_t){.buffer = malloc(8), .allocated = 8, .length = 0},
             sizeof(string_t));
  *string->buffer = '\0';
  return string;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/MassStorageHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read in blocks from the device and print them to the serial port."	1	"TASK(USB_MassStore_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Mass Storage Disk Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    UpdateStatus(Status_Busy);

    if ((ErrorCode = MassStore_GetMaxLUN(&MassStore_MaxLUNIndex)) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Get Max LUN""), false, ErrorCode);
      break;
    }

    printf_P(PSTR(""Total LUNs: %d.\r\n""), (MassStore_MaxLUNIndex + 1));

    if ((ErrorCode = MassStore_MassStorageReset()) !=
        HOST_SENDCONTROL_Successful) {
      ShowDiskReadError(PSTR(""Mass Storage Reset""), false, ErrorCode);
      break;
    }

    SCSI_Request_Sense_Response_t SenseData;
    if (((ErrorCode = MassStore_RequestSense(0, &SenseData)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Request Sense""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    if (((ErrorCode = MassStore_PreventAllowMediumRemoval(0, true)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Prevent/Allow Medium Removal""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""Waiting until ready..""));

    do {
      Serial_TxByte('.');

      if ((ErrorCode = MassStore_TestUnitReady(0)) != 0) {
        ShowDiskReadError(PSTR(""Test Unit Ready""), false, ErrorCode);
        break;
      }
    } while ((SCSICommandStatus.Status != Command_Pass) && USB_IsConnected);

    if (!(USB_IsConnected))
      break;

    puts_P(PSTR(""\r\nRetrieving Capacity... ""));

    SCSI_Capacity_t DiskCapacity;

    if (((ErrorCode = MassStore_ReadCapacity(0, &DiskCapacity)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Capacity""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    printf_P(PSTR(""%lu blocks of %lu bytes.\r\n""), DiskCapacity.Blocks,
             DiskCapacity.BlockSize);

    uint8_t BlockBuffer[DiskCapacity.BlockSize];

    if (((ErrorCode = MassStore_ReadDeviceBlock(
              0, 0x00000000, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
        (SCSICommandStatus.Status != Command_Pass)) {
      ShowDiskReadError(PSTR(""Read Device Block""),
                        (SCSICommandStatus.Status != Command_Pass), ErrorCode);
      break;
    }

    puts_P(PSTR(""\r\nContents of first block:\r\n""));

    for (uint16_t Chunk = 0; Chunk < (DiskCapacity.BlockSize >> 4); Chunk++) {

      uint8_t *ChunkPtr = &BlockBuffer[Chunk << 4];

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        printf_P(PSTR(""%.2X ""), CurrByte);
      }

      puts_P(PSTR(""    ""));

      for (uint8_t ByteOffset = 0; ByteOffset < (1 << 4); ByteOffset++) {
        char CurrByte = *(ChunkPtr + ByteOffset);

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      puts_P(PSTR(""\r\n""));
    }

    puts_P(PSTR(""\r\n\r\nPress board button to read entire ASCII contents of ""
                ""disk...\r\n\r\n""));

    while (!(Buttons_GetStatus() & BUTTONS_BUTTON1)) {

      if (!(USB_IsConnected))
        break;
    }

    for (uint32_t CurrBlock = 0; CurrBlock < DiskCapacity.Blocks; CurrBlock++) {

      if (((ErrorCode = MassStore_ReadDeviceBlock(
                0, CurrBlock, 1, DiskCapacity.BlockSize, BlockBuffer)) != 0) ||
          (SCSICommandStatus.Status != Command_Pass)) {
        ShowDiskReadError(PSTR(""Read Device Block""),
                          (SCSICommandStatus.Status != Command_Pass),
                          ErrorCode);
        break;
      }

      for (uint16_t Byte = 0; Byte < DiskCapacity.BlockSize; Byte++) {
        char CurrByte = BlockBuffer[Byte];

        putchar(isprint(CurrByte) ? CurrByte : '.');
      }

      if (!(USB_IsConnected))
        break;
    }

    UpdateStatus(Status_USBReady);

    while (USB_IsConnected)
      ;

    break;
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_ps(float __a, float __b, float __c, float __d, float __e, float __f,
               float __g, float __h) {
  return (__m256){__a, __b, __c, __d, __e, __f, __g, __h};
}"
pgrawehr-golgotha-5d70da4/string/string.h	Attempts to convert the string to a number.	2	"i4_str *read_string();

w32 read_ascii(char *buffer, w32 buffer_size);

sw32 read_number(i4_bool throwexception = i4_F);

double read_float(i4_bool throwexception = i4_F);
}
;

virtual ~i4_const_str(){};

const iterator end() const { return ptr + len; }
iterator end() { return ptr + len; }

const iterator begin() const { return ptr; }
iterator begin() { return ptr; }

w32 length() const { return len; }"
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Close a stream	2	"void stream_close(pony_ctx_t **ctx, stream_t *s) {
  struct scons *scons = scons_mk(*ctx, NULL);
  scons->eos = true;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
}"
HarveyHunt-howm-81b1d82/src/monitor.c	Create a single monitor for use with default X11.	2	"static void scan_x11_monitor(void) {
  monitor_t *m =
      create_monitor((xcb_rectangle_t){0, 0, screen_width, screen_height});

  add_ws(m);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, BlockBuffer);
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/CDC.c	Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.	2	"uint8_t CDC_Host_SendBreak(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo,
                           const uint8_t Duration) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SendBreak,
      .wValue = Duration,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
ikeydoherty-ui-tests-41140ce/src/popover.c	Work out the geometry for the relative_to widget in absolute coordinates on the screen.	2	"static void budgie_popover_compute_widget_geometry(GtkWidget *parent_widget,
                                                   GdkRectangle *target) {
  GtkAllocation alloc = {0};
  GtkWidget *toplevel = NULL;
  GdkWindow *toplevel_window = NULL;
  gint rx, ry = 0;
  gint x, y = 0;

  if (!parent_widget) {
    g_warning(""compute_widget_geometry(): missing relative_widget"");
    return;
  }

  toplevel = gtk_widget_get_toplevel(parent_widget);
  toplevel_window = gtk_widget_get_window(toplevel);
  gdk_window_get_position(toplevel_window, &x, &y);
  gtk_widget_translate_coordinates(parent_widget, toplevel, x, y, &rx, &ry);
  gtk_widget_get_allocation(parent_widget, &alloc);

  *target = (GdkRectangle){
      .x = rx, .y = ry, .width = alloc.width, .height = alloc.height};
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/hash-map-impl.c	Builds a new hash table for the given hash map. A call to ava_hash_map_vacuum() is implied.	2	"static size_t ava_hash_map_rehash(ava_hash_map *restrict map,
                                  size_t num_elements, ava_bool permit_ascii9) {
  size_t i, orig_num_elements;
  size_t new_size AVA_UNUSED;
  ava_list_value keys;
  ava_hash_map_hash_function preferred_hash_function;
  ava_bool vacuumed;
  const ava_hash_map_index *restrict old_index = map->index;

  orig_num_elements = num_elements;
  num_elements = ava_hash_map_vacuum(map, num_elements);
  vacuumed = orig_num_elements != num_elements;

  keys = (ava_list_value){ava_value_with_ulong(map->keys, num_elements)};

  if (NULL != map->index || num_elements > ASCII9_SIZE_THRESH) {
    preferred_hash_function = map->index->hash_function;
  } else {
    preferred_hash_function = ava_hmhf_ascii9;
    for (i = 0; i < num_elements && preferred_hash_function != ava_hmhf_value;
         ++i) {
      if (!is_ascii9_string(map->esba_trait->index(keys, i))) {
        preferred_hash_function = ava_hmhf_value;
      }
    }
  }

  map->index = ava_hash_map_index_new(desired_capacity(num_elements));
  map->index->num_elements = 0;
  map->index->hash_function =
      permit_ascii9 ? preferred_hash_function : ava_hmhf_value;
  memset(map->index->indices, -1, sizeof(TYPE) * (map->index->mask + 1));

  if (old_index && !vacuumed &&
      map->index->hash_function == old_index->hash_function) {

    for (i = 0; i < num_elements; ++i) {
      map->index->hash_cache[i] = old_index->hash_cache[i];
      ava_hash_map_put_direct(map, i, old_index->hash_cache[i]);
    }
    map->index->num_elements = num_elements;
  } else {
    for (i = 0; i < num_elements; ++i) {
      new_size = ava_hash_map_put(map, i, map->esba_trait->index(keys, i));
      assert(i + 1 == new_size);
      ++map->index->num_elements;
    }
  }

  return num_elements;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer."	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_rate_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  uint32_t *clock_rate;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int error_code;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_rate_get, clock_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
        clock_protocol_data.num_clocks;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(test_stats, description);
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_get, clock_id)] =
          clock_id;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      clock_rate =
          &(received.payload[OFFSET_RET(struct arm_scmi_clock_rate_get, rate)]);
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.lower,
          clock_rate[0], ""CLOCK RATE LOWER"");
      arm_scmi_check_and_report_hex(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          clock_protocol_data.clocks[clock_id].current_rate.upper,
          clock_rate[1], ""CLOCK RATE UPPER"");
    }
  }
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/maps.c	Create a new definite map	2	"cbor_item_t *cbor_new_definite_map(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = size,
                                    .type = _CBOR_METADATA_DEFINITE,
                                    .end_ptr = 0}},
      .data = _cbor_alloc_multiple(sizeof(struct cbor_pair), size)};
  if (item->data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }
  return item;
}"
PJK-libcbor-87f977e/src/cbor/arrays.c	Create new indefinite array	2	"cbor_item_t *cbor_new_indefinite_array() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                      .allocated = 0,
                                      .end_ptr = 0}},
      .data = NULL};
  return item;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/plrdlg.c	Popup (or raise) the player list dialog.	2	"void popup_players_dialog(bool raise) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL, *pZoomed = NULL;
  utf8_str *pstr;
  SDL_Rect dst;
  int i, n, h;
  double a, b, r;
  SDL_Rect area;

  if (pPlayers_Dlg) {
    return;
  }

  n = 0;
  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }
    n++;
  }
  players_iterate_end;

  if (n < 2) {
    return;
  }

  pPlayers_Dlg = fc_calloc(1, sizeof(struct SMALL_DLG));

  pstr = create_utf8_from_char(Q_(""?header:Players""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = players_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_WINDOW, pWindow);
  pPlayers_Dlg->pEndWidgetList = pWindow;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  pBuf->action = exit_players_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_BUTTON, pBuf);

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_NEUTRAL_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_neutral_status_callback;
      pBuf->key = SDLK_n;
      break;
    case DS_WAR:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_WAR_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_war_status_callback;
      pBuf->key = SDLK_w;
      break;
    case DS_CEASEFIRE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_CEASEFIRE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_ceasefire_status_callback;
      pBuf->key = SDLK_c;
      break;
    case DS_PEACE:
      pBuf = create_checkbox(pWindow->dst,
                             (SDL_Client_Flags & CF_DRAW_PLAYERS_PEACE_STATUS),
                             WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_peace_status_callback;
      pBuf->key = SDLK_p;
      break;
    case DS_ALLIANCE:
      pBuf = create_checkbox(
          pWindow->dst, (SDL_Client_Flags & CF_DRAW_PLAYERS_ALLIANCE_STATUS),
          WF_RESTORE_BACKGROUND);
      pBuf->action = toggle_draw_alliance_status_callback;
      pBuf->key = SDLK_a;
      break;
    default:

      continue;
      break;
    }
    set_wstate(pBuf, FC_WS_NORMAL);
    add_to_gui_list(ID_CHECKBOX, pBuf);
  }

  players_iterate(pPlayer) {
    if (is_barbarian(pPlayer)) {
      continue;
    }

    pstr = create_utf8_str(NULL, 0, adj_font(10));
    pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

    pLogo = get_nation_flag_surface(nation_of_player(pPlayer));
    {

      double zoom = DEFAULT_ZOOM * (60.0 - n) / pLogo->h;

      pZoomed = zoomSurface(pLogo, zoom, zoom, 1);
    }

    pBuf = create_icon2(pZoomed, pWindow->dst,
                        WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                            WF_FREE_THEME);
    pBuf->info_label = pstr;

    if (!pPlayer->is_alive) {
      pstr = create_utf8_from_char(_(""R.I.P.""), adj_font(10));
      pstr->style |= TTF_STYLE_BOLD;
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_TEXT);
      pLogo = create_text_surf_from_utf8(pstr);
      FREEUTF8STR(pstr);

      dst.x = (pZoomed->w - pLogo->w) / 2;
      dst.y = (pZoomed->h - pLogo->h) / 2;
      alphablit(pLogo, NULL, pZoomed, &dst, 255);
      FREESURFACE(pLogo);
    }

    if (pPlayer->is_alive) {
      set_wstate(pBuf, FC_WS_NORMAL);
    }

    pBuf->data.player = pPlayer;

    pBuf->action = player_callback;

    add_to_gui_list(ID_LABEL, pBuf);
  }
  players_iterate_end;

  pPlayers_Dlg->pBeginWidgetList = pBuf;

  resize_window(pWindow, NULL, NULL, adj_size(500), adj_size(400));

  area = pWindow->area;

  r = MIN(area.w, area.h);
  r -= ((MAX(pBuf->size.w, pBuf->size.h) * 2));
  r /= 2;
  a = (2.0 * M_PI) / n;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  n = area.y;
  pstr = create_utf8_str(NULL, 0, adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  for (i = 0; i < DS_LAST; i++) {
    switch (i) {
    case DS_ARMISTICE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ARMISTICE);
      break;
    case DS_WAR:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_WAR);
      break;
    case DS_CEASEFIRE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_CEASEFIRE);
      break;
    case DS_PEACE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_PEACE);
      break;
    case DS_ALLIANCE:
      pstr->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_ALLIANCE);
      break;
    default:

      continue;
      break;
    }

    copy_chars_to_utf8_str(pstr, diplstate_type_translated_name(i));
    pLogo = create_text_surf_from_utf8(pstr);

    pBuf = pBuf->prev;
    h = MAX(pBuf->size.h, pLogo->h);
    pBuf->size.x = area.x + adj_size(5);
    pBuf->size.y = n + (h - pBuf->size.h) / 2;

    dst.x = adj_size(5) + pBuf->size.w + adj_size(6);
    dst.y = n + (h - pLogo->h) / 2;
    alphablit(pLogo, NULL, pWindow->theme, &dst, 255);
    n += h;
    FREESURFACE(pLogo);
  }
  FREEUTF8STR(pstr);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 - pBuf->size.w / 2;
  pBuf->size.y = area.y + area.h / 2 - r - pBuf->size.h / 2;

  n = 1;
  if (pBuf != pPlayers_Dlg->pBeginWidgetList) {
    do {
      pBuf = pBuf->prev;
      b = M_PI_2 + n * a;
      pBuf->size.x = area.x + area.w / 2 - r * cos(b) - pBuf->size.w / 2;
      pBuf->size.y = area.y + area.h / 2 - r * sin(b) - pBuf->size.h / 2;
      n++;
    } while (pBuf != pPlayers_Dlg->pBeginWidgetList);
  }

  players_dialog_update();
}"
darktable-org-darktable-32fab21/src/iop/borders.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_borders_params_t tmp =
      (dt_iop_borders_params_t){{1.0f, 1.0f, 1.0f},
                                DT_IOP_BORDERS_ASPECT_CONSTANT_VALUE,
                                ""constant border"",
                                0,
                                0.1f,
                                0.5f,
                                ""1/2"",
                                0.5f,
                                ""1/2"",
                                0.0f,
                                0.5f,
                                {0.0f, 0.0f, 0.0f},
                                TRUE};
  memcpy(self->params, &tmp, sizeof(dt_iop_borders_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_borders_params_t));
  self->default_enabled = 0;
}"
xipengwang-FLAG-cd1815e/april2/src/vx/vxo_sphere.c	"In this implementation, the only data passed to the shader are the texture coordinates. These texture coordinates can be trivially converted into latitude and longitude, but are adjusted so that the triangles render textures properly across the longitude=PI boundary. The shader computes lat/lon from the shader coordinates, then computes xyz."	2	"vx_object_t *vxo_sphere_textured(vx_resource_t *texture_resource) {
  static vx_resource_t *program_resource = NULL;
  static vx_resource_t *sts_resource = NULL;
  static vx_resource_t *tris_resource = NULL;
  static int nvertices = 0, napositions = 0;

  vx_lock();

  if (program_resource == NULL) {

    zarray_t *vertex_datas = zarray_create(sizeof(struct vertex_data));
    zarray_t *tris = zarray_create(sizeof(uint16_t[3]));

    const double v = sqrt(3) / 3;
    double *xyza = (double[]){v, v, v};
    double *xyzb = (double[]){-v, -v, v};
    double *xyzc = (double[]){-v, v, -v};
    double *xyzd = (double[]){v, -v, -v};

    int depth = 4;

    recurse(vertex_datas, tris, xyza, xyzc, xyzb, depth);
    recurse(vertex_datas, tris, xyza, xyzb, xyzd, depth);
    recurse(vertex_datas, tris, xyza, xyzd, xyzc, depth);
    recurse(vertex_datas, tris, xyzb, xyzc, xyzd, depth);

    zarray_t *sts = zarray_create(sizeof(float[2]));

    for (int i = 0; i < zarray_size(vertex_datas); i++) {
      struct vertex_data *vd;
      zarray_get_volatile(vertex_datas, i, &vd);

      float *st = (float[]){vd->st[0], vd->st[1]};

      zarray_add(sts, st);
    }

    nvertices = zarray_size(tris) * 3;

    char vertex_shader_src[] =
        ""#define PI 3.14159265358979323846264338\n""
        ""attribute vec2 st; \n""
        ""varying vec2 vtexcoord; \n""
        ""uniform mat4 VX_P;\n""
        ""uniform mat4 VX_V;\n""
        ""uniform mat4 VX_M;\n""
        ""void main(void) {\n""
        ""  float lat = (PI / 2.0) - PI * st.y; \n ""
        ""  float lon = 2.0 * PI * st.x; \n ""
        ""  vtexcoord = st.xy; \n""
        ""  float r = cos(lat); \n ""
        ""  vec3 xyz = vec3(r*cos(lon), r*sin(lon), sin(lat)); \n ""
        ""  gl_Position = VX_P * VX_V * VX_M * vec4(xyz, 1.0);\n""
        ""}"";

    char fragment_shader_src[] = ""precision mediump float; \n""
                                 ""varying vec2 vtexcoord; \n""
                                 ""uniform sampler2D texture; \n""
                                 ""void main(void) {\n""
                                 ""  vec4 c = texture2D(texture, vtexcoord);\n""
                                 ""  gl_FragColor = vec4(c.r, c.g, c.b, 1);\n""
                                 ""}\n"";

    program_resource =
        vx_resource_make_program(vertex_shader_src, fragment_shader_src);
    program_resource->incref(program_resource);

    sts_resource = vx_resource_make_attr_f32_copy((float *)sts->data,
                                                  zarray_size(sts) * 2, 2);
    sts_resource->incref(sts_resource);

    tris_resource =
        vx_resource_make_idx_u16_copy((uint16_t *)tris->data, nvertices);
    tris_resource->incref(tris_resource);
  }

  vx_unlock();

  return vxo_generic_create(
      program_resource, (struct vxo_generic_uniformf[]){{.name = NULL}},
      (struct vxo_generic_attribute[]){{.name = ""st"", .resource = sts_resource},
                                       {.name = NULL}},
      (struct vxo_generic_texture[]){
          {.name = ""texture"", .resource = texture_resource}, {.name = NULL}},
      (struct vxo_generic_draw[]){
          {.command = VX_GL_TRIANGLES,
           .first = 0,
           .count = nvertices,
           .indices_resource = tris_resource},
          {.count = 0},
      });
}"
AsydSolutions-monit-9e43388/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVh"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""id"", no_argument, NULL, 'i'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""version"", no_argument, NULL, 'V'},
                              {""help"", no_argument, NULL, 'h'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.controlfile = Str_dup(f);
      break;
    }
    case 'd': {
      Run.isdaemon = true;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.logfile = Str_dup(optarg);
      if (IS(Run.logfile, ""syslog""))
        Run.use_syslog = true;
      Run.dolog = true;
      break;
    }
    case 'p': {
      Run.pidfile = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.statefile = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.init = true;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.idfile);
      Util_monitId(Run.idfile);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"
braice-MuMuDVB-745259a/src/sap.c	Initialize sap variables	2	"void init_sap_v(sap_p_t *sap_p) {
  *sap_p = (sap_p_t){
      .sap_messages4 = NULL,
      .sap_messages6 = NULL,
      .sap = OPTION_UNDEFINED,
      .sap_interval = SAP_DEFAULT_INTERVAL,
      .sap_sending_ip4 = ""0.0.0.0"",
      .sap_sending_ip6 = ""::"",
      .sap_default_group = """",
      .sap_organisation = ""MuMuDVB"",
      .sap_uri = ""\0"",
      .sap_ttl = SAP_DEFAULT_TTL,
  };
}"
RfidResearchGroup-proxmark3-1650889/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLogEx(WARNING, ""missing addr"");
    return 0;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    req[reqlen++] = iso15cmd;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    if (!getUID(uid)) {
      PrintAndLogEx(WARNING, ""No tag found"");
      return 0;
    }
    memcpy(&req[reqlen], uid, sizeof(uid));
    PrintAndLogEx(NORMAL, ""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += sizeof(uid);
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    req[reqlen++] = iso15cmd;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLogEx(NORMAL, ""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], uid, sizeof(uid));
    reqlen += sizeof(uid);
    break;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c	"Clears a stall condition on the given pipe, via a CLEAR FEATURE standard request to the attached device."	1	"uint8_t USB_Host_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_SEL_EndpointHalt,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/pub.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){pub,
                  'p',
                  ""pub"",
                  ""extract the public key from a private key/certificate"",
                  {""[--in file|--keyid hex] [--type rsa|ecdsa|pkcs10|x509]"",
                   ""[--outform der|pem|pgp]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""keyid"", 'x', 1, ""keyid on smartcard of private key""},
                      {""type"", 't', 1, ""type of credential, default: rsa""},
                      {""outform"", 'f', 1, ""encoding of extracted public key""},
                  }});
}"
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to zero.	2	"_mm256_setzero_pd(void) { return __extension__(__m256d){0, 0, 0, 0}; }"
vm6502q-qrack-df6132d/include/qinterface.hpp	"Quantum analog of classical ""XOR"" gate. Takes one qubit input and one classical bit input. Measures the outputBit, then overwrites it with result."	2	"}

virtual ~QInterface(){};

int GetQubitCount() { return qubitCount; }"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Retrieves the device sense data, indicating the current device state and error codes for the previously issued command."	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Request_Sense_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, SenseData);
}"
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the list parser state struct with data to be parsed.	2	"psyc_parse_list_buffer_set(PsycParseListState *state, const char *buffer,
                           size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the update modifier parser state struct with data to be parsed.	2	"psyc_parse_update_buffer_set(PsycParseUpdateState *state, const char *buffer,
                             size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Construct the metric terms (and optionally the jacobian determinant) terms at the nodes of input type for the volume under consideration.	2	"static void
constructor_volume_metric_terms_T(const char node_type,
                                  struct Solver_Volume_T *const s_vol) {

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Geometry_Element *g_e =
      &((struct Solver_Element *)vol->element)->g_e;

  const int p = s_vol->p_ref;
  const bool curved = vol->curved;
  const int p_g = (curved ? p : 1);

  struct Container {
    struct Multiarray_Operator *cv1_vg_vX;
    const struct Operator *vv0_vm_vX;
    struct Multiarray_T *metrics_vX;
    struct Multiarray_T *jacobian_det_vX;
  } con;
  struct Multiarray_Operator cv1_vg_vm =
      set_MO_from_MO(g_e->cv1_vg_vm[curved], 1, (ptrdiff_t[]){0, 0, p_g, p_g});
  struct Multiarray_Operator cv1_vg_vc =
      set_MO_from_MO(g_e->cv1_vg_vc[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});
  struct Multiarray_Operator cv1_vg_vs =
      set_MO_from_MO(g_e->cv1_vg_vs[curved], 1, (ptrdiff_t[]){0, 0, p, p_g});

  switch (node_type) {
  case 'm':
    con.cv1_vg_vX = &cv1_vg_vm;
    con.vv0_vm_vX = NULL;
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vm;
    con.jacobian_det_vX = NULL;
    break;
  case 'c':
    con.cv1_vg_vX = &cv1_vg_vc;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vc[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vc;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vc;
    break;
  case 's':
    con.cv1_vg_vX = &cv1_vg_vs;
    con.vv0_vm_vX = get_Multiarray_Operator(g_e->vv0_vm_vs[curved],
                                            (ptrdiff_t[]){0, 0, p, p_g});
    con.metrics_vX = (struct Multiarray_T *)s_vol->metrics_vs;
    con.jacobian_det_vX = (struct Multiarray_T *)s_vol->jacobian_det_vs;
    break;
  default:
    EXIT_ERROR(""Unsupported: %c\n"", node_type);
    break;
  }
  const ptrdiff_t n_vX = con.cv1_vg_vX->data[0]->op_std->ext_0;
  struct Multiarray_T *const jacobian_vX =
      constructor_empty_Multiarray_T('C', 3, (ptrdiff_t[]){n_vX, DIM, DIM});

  const char op_format = get_set_op_format(0);
  const struct const_Multiarray_T *const geom_coef = s_vol->geom_coef;
  for (ptrdiff_t row = 0; row < DIM; ++row)
    mm_NN1C_Operator_Multiarray_T(con.cv1_vg_vX->data[row], geom_coef,
                                  jacobian_vX, op_format, 2, NULL, &row);

  if (node_type == 'm') {
    compute_cofactors_T((struct const_Multiarray_T *)jacobian_vX,
                        con.metrics_vX);
  } else {
    assert(compute_size(s_vol->metrics_vm->order, s_vol->metrics_vm->extents) >
           0);
    const struct const_Multiarray_T *const met_vm = s_vol->metrics_vm;
    resize_Multiarray_T(con.metrics_vX, 3, (ptrdiff_t[]){n_vX, DIM, DIM});
    mm_NN1C_Operator_Multiarray_T(con.vv0_vm_vX, met_vm, con.metrics_vX,
                                  op_format, met_vm->order, NULL, NULL);
  }

  if (con.jacobian_det_vX) {
    const ptrdiff_t *const perm = set_jacobian_permutation(DIM);
    permute_Multiarray_T(jacobian_vX, perm, jacobian_vX->layout);

    compute_detJV_T((struct const_Multiarray_T *)jacobian_vX,
                    con.jacobian_det_vX);
  }
  destructor_Multiarray_T(jacobian_vX);
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/mapview.c	Typically an info box is provided to tell the player about the state of their civilization. This function is called when the label is changed.	2	"void update_info_label(void) {
  SDL_Color bg_color = {0, 0, 0, 80};
  SDL_Surface *pTmp = NULL;
  char buffer[512];
#ifdef SMALL_SCREEN
  SDL_Rect area = {0, 0, 0, 0};
#else
  SDL_Rect area = {0, 3, 0, 0};
#endif
  struct utf8_str *ptext;

  if (get_current_client_page() != PAGE_GAME) {
    return;
  }

#ifdef SMALL_SCREEN
  ptext = create_utf8_str(NULL, 0, 8);
#else
  ptext = create_utf8_str(NULL, 0, 10);
#endif

  ptext->style |= TTF_STYLE_BOLD;
  ptext->fgcol = *get_theme_color(COLOR_THEME_MAPVIEW_INFO_TEXT);
  ptext->bgcol = (SDL_Color){0, 0, 0, 0};

  if (NULL != client.conn.playing) {
#ifdef SMALL_SCREEN
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold);
#else
    fc_snprintf(buffer, sizeof(buffer),
                _(""%s Population: %s  Year: %s  ""
                  ""Gold %d Tax: %d Lux: %d Sci: %d ""),
                nation_adjective_for_player(client.conn.playing),
                population_to_text(civ_population(client.conn.playing)),
                calendar_text(), client.conn.playing->economic.gold,
                client.conn.playing->economic.tax,
                client.conn.playing->economic.luxury,
                client.conn.playing->economic.science);
#endif

    copy_chars_to_utf8_str(ptext, buffer);
    pTmp = create_text_surf_from_utf8(ptext);

    area.x = (main_window_width() - pTmp->w) / 2 - adj_size(5);
    area.w = pTmp->w + adj_size(8);
    area.h = pTmp->h + adj_size(4);

    SDL_FillRect(Main.gui->surface, &area,
                 map_rgba(Main.gui->surface->format, bg_color));

    create_line(Main.gui->surface, area.x + 1, area.y, area.x + area.w - 2,
                area.y, get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x + 1, area.y + area.h - 1,
                area.x + area.w - 2, area.y + area.h - 1,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    create_line(Main.gui->surface, area.x + area.w - 1, area.y + 1,
                area.x + area.w - 1, area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));
    create_line(Main.gui->surface, area.x, area.y + 1, area.x,
                area.y + area.h - 2,
                get_theme_color(COLOR_THEME_MAPVIEW_INFO_FRAME));

    blit_entire_src(pTmp, Main.gui->surface, area.x + adj_size(5),
                    area.y + adj_size(2));

    dirty_sdl_rect(&area);

    FREESURFACE(pTmp);
  }

  set_indicator_icons(client_research_sprite(), client_warming_sprite(),
                      client_cooling_sprite(), client_government_sprite());

  update_timeout_label();

  FREEUTF8STR(ptext);

  queue_flush();
}"
darktable-org-darktable-32fab21/src/iop/lowpass.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""local contrast mask""), self->op, self->version(),
      &(dt_iop_lowpass_params_t){0, 50.0f, -1.0f, 0.0f, 0.0f,
                                 LOWPASS_ALGO_GAUSSIAN, 1},
      sizeof(dt_iop_lowpass_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance limits set command and testing the received values.	3	"void arm_scmi_custom_test_performance_limits_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 3;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_max)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MAX - 1];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                       range_min)] =
        ptr_data->domain_runtime_values[0].levels[PERF_MIN + 1];
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_max)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX] + 1;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_set,
                                  range_min)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN] - 1;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_max)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MAX - 1];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_set,
                                         range_min)] =
          ptr_data->domain_runtime_values[domain_id].levels[PERF_MIN + 1];
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
              PERFORMANCE_DOMAIN_ATTR_LIMIT_SET) == 1
              ? SCMI_STATUS_SUCCESS
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        ptr_data->domain_runtime_values[domain_id].range_min =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_min)];
        ptr_data->domain_runtime_values[domain_id].range_max =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_limits_set, range_max)];
      }
    }
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	"Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host."	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t));

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;

      FrameIN.FrameInBuffer = true;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t));

      Endpoint_Write_Stream_LE(FrameOUT.FrameData,
                               RNDISPacketHeader.DataLength);

      Endpoint_ClearIN();

      FrameOUT.FrameInBuffer = false;
    }
  }
}"
dm-vdo-kvdo-8df6805/vdo/base/slab.c	Measure and initialize the configuration to use for each slab.	2	"int configureSlab(BlockCount slabSize, BlockCount slabJournalBlocks,
                  SlabConfig *slabConfig) {
  if (slabJournalBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount refBlocks =
      getSavedReferenceCountSize(slabSize - slabJournalBlocks);
  BlockCount metaBlocks = (refBlocks + slabJournalBlocks);

  if (metaBlocks >= slabSize) {
    return VDO_BAD_CONFIGURATION;
  }

  BlockCount dataBlocks = slabSize - metaBlocks;
  if ((slabSize < 1024) && !isPowerOfTwo(dataBlocks)) {
    dataBlocks = ((BlockCount)1 << logBaseTwo(dataBlocks));
  }

  BlockCount flushingThreshold = ((slabJournalBlocks * 3) + 3) / 4;

  BlockCount remaining = slabJournalBlocks - flushingThreshold;
  BlockCount blockingThreshold = flushingThreshold + ((remaining * 5) / 7);

  BlockCount minimalExtraSpace =
      1 + (MAXIMUM_USER_VIOS / SLAB_JOURNAL_FULL_ENTRIES_PER_BLOCK);
  BlockCount scrubbingThreshold = blockingThreshold;
  if (slabJournalBlocks > minimalExtraSpace) {
    scrubbingThreshold = slabJournalBlocks - minimalExtraSpace;
  }
  if (blockingThreshold > scrubbingThreshold) {
    blockingThreshold = scrubbingThreshold;
  }

  *slabConfig =
      (SlabConfig){.slabBlocks = slabSize,
                   .dataBlocks = dataBlocks,
                   .referenceCountBlocks = refBlocks,
                   .slabJournalBlocks = slabJournalBlocks,
                   .slabJournalFlushingThreshold = flushingThreshold,
                   .slabJournalBlockingThreshold = blockingThreshold,
                   .slabJournalScrubbingThreshold = scrubbingThreshold};
  return VDO_SUCCESS;
}"
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	Paint menubar.	2	"virtual ~Font(){};

virtual int getHeight() const = 0;

virtual int getAscent() const = 0;

template <typename STR>
int getWidth(const STR s, Size start = 0, Size len = (Size)-1) const {
  return this->getWidth(String(s), start, len);
}

virtual int getWidth(Char c = 'M') const = 0;

virtual int getWidth(const String &s, Size start = 0,
                     Size len = (Size)-1) const {
  int width = 0;
  if (start + len > s.size())
    len = (Size)(s.size() - start);
  while (len--)
    width += getWidth(s[start++]);
  return width;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	"Retrieves the current alternative setting for the specified interface, via a GET INTERFACE standard request to the attached device."	1	"uint8_t USB_Host_GetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        uint8_t *const AltSetting) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetInterface,
      .wValue = 0,
      .wIndex = InterfaceIndex,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(AltSetting);
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Device/CDC.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = CPU_TO_LE16(0),
      .wIndex = CPU_TO_LE16(0),
      .wLength = CPU_TO_LE16(
          sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost)),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/verify.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      verify,
      'v',
      ""verify"",
      ""verify a certificate using the CA certificate"",
      {""[--in file] [--ca file]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""X.509 certificate to verify, default: stdin""},
          {""cacert"", 'c', 1, ""CA certificate, default: verify self signed""},
      }});
}"
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float2() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_16}}};
  return item;
}"
phase4ground-joco-2018-badge-782fd35/firmware/manbearpig/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    mbp_tooth_eye_stop();
    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
  mbp_tooth_eye_start();
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	The firmware version is the SHA256 hash.	1	"arm_uc_error_t ARM_UC_ControlCenter_ReportVersion(uint64_t version) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportVersion: %"" PRIu64, version);

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct) {
    arm_uc_monitor_struct->SendVersion(version);
    result.code = ERR_NONE;
  }

  return result;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;
  }

  return ErrorCode;
}"
boazsegev-iodine-b6bdf50/ext/iodine/http1.c	Creates an HTTP1 protocol object and handles any unread data in the buffer (if any).	2	"fio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,
                          void *unread_data, size_t unread_length) {
  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)
    return NULL;
  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);

  FIO_ASSERT_ALLOC(p);
  *p = (http1pr_s){
      .p.protocol =
          {
              .on_data = http1_on_data_first_time,
              .on_close = http1_on_close,
              .on_ready = http1_on_ready,
          },
      .p.uuid = uuid,
      .p.settings = settings,
      .max_header_size = settings->max_header_size,
      .is_client = settings->is_client,
  };
  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    memcpy(p->buf, unread_data, unread_length);
    p->buf_len = unread_length;
  }
  fio_attach(uuid, &p->p.protocol);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  return &p->p.protocol;
}"
Decawave-mynewt-dw1000-apps-be5c28a/apps/listener/src/bleprph.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"bleprph_advertise(void) {
  uint8_t own_addr_type;
  struct ble_gap_adv_params adv_params;
  struct ble_hs_adv_fields fields;
  const char *name;
  int rc;

  rc = ble_hs_id_infer_auto(0, &own_addr_type);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error determining address type; rc=%d\n"", rc);
    return;
  }

  memset(&fields, 0, sizeof fields);

  fields.flags = BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP;

  fields.tx_pwr_lvl_is_present = 1;
  fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

  name = ble_svc_gap_device_name();
  fields.name = (uint8_t *)name;
  fields.name_len = strlen(name);
  fields.name_is_complete = 1;

  fields.uuids16 = (ble_uuid16_t[]){BLE_UUID16_INIT(GATT_SVR_SVC_ALERT_UUID)};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  memset(&adv_params, 0, sizeof adv_params);
  adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
  adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
  rc = ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params,
                         bleprph_gap_event, NULL);
  if (rc != 0) {
    BLEPRPH_LOG(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabKey request. Creates a grab for the client's keyboard and adds it to the list of passive grabs.	2	"ProcGrabKey(ClientPtr client) {
  WindowPtr pWin;

  REQUEST(xGrabKeyReq);
  GrabPtr grab;
  DeviceIntPtr keybd = PickKeyboard(client);
  int rc;
  GrabParameters param;
  GrabMask mask;

  REQUEST_SIZE_MATCH(xGrabKeyReq);

  param = (GrabParameters){.grabtype = CORE,
                           .ownerEvents = stuff->ownerEvents,
                           .this_device_mode = stuff->keyboardMode,
                           .other_devices_mode = stuff->pointerMode,
                           .modifiers = stuff->modifiers};

  rc = CheckGrabValues(client, &param);
  if (rc != Success)
    return rc;

  if (((stuff->key > keybd->key->xkbInfo->desc->max_key_code) ||
       (stuff->key < keybd->key->xkbInfo->desc->min_key_code)) &&
      (stuff->key != AnyKey)) {
    client->errorValue = stuff->key;
    return BadValue;
  }
  rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
  if (rc != Success)
    return rc;

  mask.core = (KeyPressMask | KeyReleaseMask);

  grab = CreateGrab(client->index, keybd, keybd, pWin, CORE, &mask, &param,
                    KeyPress, stuff->key, NullWindow, NullCursor);
  if (!grab)
    return BadAlloc;
  return AddPassiveGrabToList(client, grab);
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/AndroidAccessoryClassHost.c	"Starts Accessory Mode in the attached Android device. This function will validate the device's Android Open Accessory protocol version, send the configured property strings, and request a switch to Android Open Accessory mode."	1	"uint8_t
AOA_Host_StartAccessoryMode(USB_ClassInfo_AOA_Host_t *const AOAInterfaceInfo) {
  uint8_t ErrorCode;

  uint16_t AccessoryProtocol;
  if ((ErrorCode = AOA_Host_GetAccessoryProtocol(&AccessoryProtocol)) !=
      HOST_WAITERROR_Successful)
    return ErrorCode;

  if (AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV1))
    return AOA_ERROR_LOGICAL_CMD_FAILED;

  for (uint8_t PropertyIndex = 0; PropertyIndex < AOA_STRING_TOTAL_STRINGS;
       PropertyIndex++) {
    if ((ErrorCode = AOA_Host_SendPropertyString(
             AOAInterfaceInfo, PropertyIndex)) != HOST_WAITERROR_Successful)
      return ErrorCode;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE),
      .bRequest = AOA_REQ_StartAccessoryMode,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set1_epi64(__m64 __q) { return (__m128i){(long long)__q, (long long)__q}; }"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/fifo.c	Move data pointers and pts offset samples forward.	2	"static void buffer_offset(AVFilterLink *link, AVFrame *frame, int offset) {
  int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
  int planar = av_sample_fmt_is_planar(link->format);
  int planes = planar ? nb_channels : 1;
  int block_align =
      av_get_bytes_per_sample(link->format) * (planar ? 1 : nb_channels);
  int i;

  av_assert0(frame->nb_samples > offset);

  for (i = 0; i < planes; i++)
    frame->extended_data[i] += block_align * offset;
  if (frame->data != frame->extended_data)
    memcpy(frame->data, frame->extended_data,
           FFMIN(planes, FF_ARRAY_ELEMS(frame->data)) * sizeof(*frame->data));
  frame->linesize[0] -= block_align * offset;
  frame->nb_samples -= offset;

  if (frame->pts != AV_NOPTS_VALUE) {
    frame->pts += av_rescale_q(offset, (AVRational){1, link->sample_rate},
                               link->time_base);
  }
}"
vasyutin-qnetmap-3e0b0a1/lib/src/qnetmap_label.h	draw the geometry	2	"virtual ~TLabel(){};

virtual void drawGeometry(QPainter *Painter_, const QRect &Viewport_,
                          const QPoint Offset_ = QPoint());

virtual const QString &text(void) const { return m_Text; }

virtual void setText(QString &Text_) {
  m_Text = Text_;
  calculateBoundingBox();
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/integration/test_integration.c	Adapt the initial mesh if a adaptation parameters are provided in the input file.	2	"void adapt_initial_mesh_if_required(struct Simulation *const sim) {
  const int *count_to_find = (int[]){2, 3};
  int count_found = 0;

  struct Adaptation_Data adapt_data = {
      .adapt_h =
          {
              0,
              0,
          },
      .xyz_ve_refine = NULL,
      .xyz_ve_ml = NULL,
      .xyz_ve_p = NULL,
  };

  char line[STRLEN_MAX];
  FILE *input_file = fopen_input('t', NULL, NULL);
  while (fgets(line, sizeof(line), input_file)) {
    read_skip_name_i(""n_adapt_h_refine"", line, &adapt_data.adapt_h[0]);
    if (strstr(line, ""xyz_ve_refine"")) {
      ++count_found;
      adapt_data.xyz_ve_refine =
          constructor_file_const_Multiarray_d(input_file, true);
    }
    if (strstr(line, ""xyz_ve_mesh_level"")) {
      ++count_found;
      adapt_data.xyz_ve_ml = constructor_file_const_Vector_i(input_file, true);
    }
    if (strstr(line, ""xyz_ve_polynomial_order"")) {
      ++count_found;
      adapt_data.xyz_ve_p = constructor_file_const_Vector_i(input_file, true);
    }
  }
  fclose(input_file);

  if (adapt_data.xyz_ve_refine == NULL) {
    assert(adapt_data.xyz_ve_ml == NULL || adapt_data.xyz_ve_p == NULL);
    return;
  }

  if (count_found < count_to_find[0] || count_found > count_to_find[1])
    EXIT_ERROR(
        ""Did not find the required number of variables (Found: %d/[%d,%d]).\n"",
        count_found, count_to_find[0], count_to_find[1]);

  adapt_hp(sim, ADAPT_S_XYZ_VE, &adapt_data);
  for (int i = 0; i < adapt_data.adapt_h[0]; ++i)
    adapt_hp(sim, ADAPT_S_H_REFINE, NULL);
  for (int i = 0; i < adapt_data.adapt_h[1]; ++i)
    adapt_hp(sim, ADAPT_S_H_COARSE, NULL);

  destructor_const_Multiarray_d(adapt_data.xyz_ve_refine);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_ml);
  destructor_conditional_const_Vector_i(adapt_data.xyz_ve_p);
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/AudioInputHost/AudioInputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Could not set requested Audio sample rate.\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  DDRC |= (1 << 6);

  TCCR3A = ((1 << WGM30) | (1 << COM3A1) | (1 << COM3A0));
  TCCR3B = ((1 << WGM32) | (1 << CS30));

  puts_P(PSTR(""Microphone Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
gexpander-gex-client-c-9f870ec/gex/gex_settings.c	Read the settings INI file via TinyFrame	2	"uint32_t GEX_IniRead(GexClient *gex, char *buffer, uint32_t maxlen) {
  GexBulk br = (GexBulk){
      .buffer = (uint8_t *)buffer, .capacity = maxlen, .req_cmd = MSG_INI_READ};

  uint32_t actuallyRead = GEX_BulkRead(GEX_SysUnit(gex), &br);

  if (actuallyRead == maxlen) {
    actuallyRead--;
  }

  buffer[actuallyRead] = 0;
  return actuallyRead;
}"
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	"Wraps a packet like commonSetup, but will do the whole packet including headers not just the message body. This is used by the PacketEncoder tests."	2	"testrigencoder_CommonSetupWholePacket(uint8_t *packet, size_t length,
                                      TruthTableEntry *truthTable) {
  TestData *data = parcMemory_AllocateAndClear(sizeof(TestData));
  assertNotNull(data, ""parcMemory_AllocateAndClear(%zu) returned NULL"",
                sizeof(TestData));

  data->memoryRegion = parcBuffer_Wrap(packet, length, 0, length);
  data->encoder = ccnxCodecTlvEncoder_Create();

  data->dictionary = ccnxTlvDictionary_Create(
      CCNxCodecSchemaV1TlvDictionary_MessageFastArray_END,
      CCNxCodecSchemaV1TlvDictionary_Lists_END);

  data->packet = packet;
  data->packetLength = length;
  data->truthTable = truthTable;

  buildPacketDictionary(data, data->dictionary, (TlvExtent){0, length});

  return data;
}"
ryankurte-micro-gui-1e3ce05/source/graphics.c	This performs bounds checking and translation based on the graphics context	2	"static void plot(ugui_graphics_t *graphics, uint32_t x, uint32_t y) {

  uint32_t new_x = x + graphics->offset_x;
  uint32_t new_y = y + graphics->offset_y;

  if ((new_x < graphics->w) && (x < graphics->limit_w) &&
      (new_y < graphics->h) && (y < graphics->limit_h)) {
    _ugui_buffer_set(graphics->buffer, &(ugui_point_t){.x = new_x, .y = new_y},
                     1);
  }
}"
darktable-org-darktable-32fab21/src/iop/borders.c	"callback methods for gui. synch gtk interface with gui params, if necessary. gui callbacks, these are needed."	2	"void gui_update(struct dt_iop_module_t *self) {
  dt_iop_borders_gui_data_t *g = (dt_iop_borders_gui_data_t *)self->gui_data;
  dt_iop_borders_params_t *p = (dt_iop_borders_params_t *)self->params;
  dt_bauhaus_slider_set(g->size, p->size * 100.0f);

  int k = 0;
  for (; k < DT_IOP_BORDERS_ASPECT_COUNT; k++) {
    if (fabsf(p->aspect - g->aspect_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->aspect, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_ASPECT_COUNT) {
    dt_bauhaus_combobox_set_text(g->aspect, p->aspect_text);
    dt_bauhaus_combobox_set(g->aspect, -1);
  }

  dt_bauhaus_combobox_set(g->aspect_orient, p->aspect_orient);

  for (k = 0; k < DT_IOP_BORDERS_POSITION_H_COUNT; k++) {
    if (fabsf(p->pos_h - g->pos_h_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_h, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_H_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_h, p->pos_h_text);
    dt_bauhaus_combobox_set(g->pos_h, -1);
  }

  for (k = 0; k < DT_IOP_BORDERS_POSITION_V_COUNT; k++) {
    if (fabsf(p->pos_v - g->pos_v_ratios[k]) < 0.0001f) {
      dt_bauhaus_combobox_set(g->pos_v, k);
      break;
    }
  }
  if (k == DT_IOP_BORDERS_POSITION_V_COUNT) {
    dt_bauhaus_combobox_set_text(g->pos_v, p->pos_v_text);
    dt_bauhaus_combobox_set(g->pos_v, -1);
  }

  dt_bauhaus_slider_set(g->frame_size, p->frame_size * 100.0f);
  dt_bauhaus_slider_set(g->frame_offset, p->frame_offset * 100.0f);

  GdkRGBA c = (GdkRGBA){.red = p->color[0],
                        .green = p->color[1],
                        .blue = p->color[2],
                        .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->colorpick), &c);

  GdkRGBA fc = (GdkRGBA){.red = p->frame_color[0],
                         .green = p->frame_color[1],
                         .blue = p->frame_color[2],
                         .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->frame_colorpick), &fc);
}"
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (fabs(d) > INT_MAX + 3LL)
    return (AVRational){d < 0 ? -1 : 1, 0};
  frexp(d, &exponent);
  exponent = FFMAX(exponent - 1, 0);
  den = 1LL << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"
ThierryNg-pokecopy-57caaae/Pokecopy.spritebuilder/Source/libs/cocos2d-iphone/cocos2d/ccTypes.h	helper that creates a ccColor4f type	2	"static inline ccColor4F ccc4f(const GLfloat r, const GLfloat g, const GLfloat b,
                              const GLfloat a) {
  return (ccColor4F){r, g, b, a};
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/LowLevel/Host.c	"Clears a stall condition on the given pipe, via a ClearFeature request to the attached device."	2	"uint8_t USB_Host_ClearPipeStall(uint8_t EndpointNum) {
  if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    EndpointNum |= ENDPOINT_DESCRIPTOR_DIR_IN;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties."	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
varunjampani-video_prop_networks-4f4a398/lib/caffe/include/caffe/malabar_layers.hpp	"Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true."	2	"template <typename Dtype> class MatMulLayer : public Layer<Dtype> {
public:
  explicit MatMulLayer(const LayerParameter &param) : Layer<Dtype>(param) {
    LayerParameter tmp_param;
    tmp_param.mutable_concat_param()->set_concat_dim(3);
    concat_layer_.reset(new ConcatLayer<Dtype>(tmp_param));
  }
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul""; }
  virtual inline int MinNumBottomBlobs() const { return 2; }
  virtual inline int ExactNumTopBlobs() const { return 1; }

protected:
  virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Forward_gpu(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top);
  virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  virtual void Backward_gpu(const vector<Blob<Dtype> *> &top,
                            const vector<bool> &propagate_down,
                            const vector<Blob<Dtype> *> &bottom);
  Blob<Dtype> tmp_k_;
  boost::shared_ptr<ConcatLayer<Dtype>> concat_layer_;
};

template <typename Dtype> class MatMul2Layer : public Layer<Dtype> {
public:
  explicit MatMul2Layer(const LayerParameter &param) : Layer<Dtype>(param){};
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul2""; }"
moehriegitt-hob3l-40cfda8/src/csg3.c	"From an array of points in the rough shape of a tower, make a polyhedron. 'Tower' means the shape consists of layers of polygon points stack on each other. This function also handles the case of the top collapsing into a single point. So this shape works for (polyhedronized) cylinders, cones, spheres, cubes, and linear_extrudes. If the connecting quads are not planar, then tri_side can be set to non-false to split them into triangles. This shape is probably not nice, but correct in that the faces are planar, since every triangle is trivially planar). The top and bottom faces must be planar. rev^(m->d < 0) inverts face vertex order to allow managing mirroring and negative determinants. This also gives some freedom for the construction: if top and bottom are swapped (i.e., the points 0..fn-1 are the top, not the bottom), then rev be passed as non-false. This also runs xform and minmax, but not make_edges."	2	"static bool faces_n_edges_from_tower(cp_csg3_poly_t *o, ctxt_t *c,
                                     cp_mat3wi_t const *m, cp_loc_t loc,
                                     size_t fn, size_t fnz, bool rev,
                                     unsigned tri_side, bool may_need_tri) {

  unsigned orient = 0;
  bool need_tri = false;
  if (may_need_tri) {
    for (cp_size_each(i, fn)) {
      size_t j = cp_wrap_add1(i, fn);
      size_t k = cp_wrap_add1(j, fn);
      orient |=
          1U << (1 + cp_vec2_right_normal3_z(&cp_v_nth(&o->point, i).coord.b,
                                             &cp_v_nth(&o->point, j).coord.b,
                                             &cp_v_nth(&o->point, k).coord.b));
      if ((orient & 5) == 5) {
        need_tri = true;
        break;
      }
    }
  }

  cp_v_size3_t tri = {0};
  if (need_tri) {
    cp_vec2_arr_ref_t a2;
    cp_vec2_arr_ref_from_a_vec3_loc_xy(&a2, &o->point);
    if (!cp_csg2_tri_vec2_arr_ref(&tri, c->tmp, c->err, loc, &a2, fn)) {
      return false;
    }
  }

  if (m->d < 0) {
    rev = !rev;
  }

  for (cp_v_each(i, &o->point)) {
    cp_vec3w_xform(&cp_v_nth(&o->point, i).coord, &m->n,
                   &cp_v_nth(&o->point, i).coord);
  }

  bool has_top = (o->point.size == fn * fnz);
  assert(has_top || (o->point.size == 1 + (fn * (fnz - 1))));

  size_t k = 0;
  size_t bt_cnt = tri.size ? tri.size : 1U;
  cp_v_init0(&o->face, (bt_cnt * (1U + !!has_top)) +
                           ((fnz - 2) * fn * (1U + !!tri_side)) +
                           (fn * (1U + !!(tri_side && has_top))));

  face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, false);

  if (has_top) {
    face_from_tri_or_poly(&k, o, &tri, loc, fn, rev, true);
  }

  cp_v_fini(&tri);

  cp_csg3_face_t *f;
  for (cp_size_each(i, fnz, 1, !has_top)) {
    size_t k1 = i * fn;
    size_t k0 = k1 - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      switch (tri_side) {
      case TRI_LEFT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j0},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j1},
                                 3, !rev, loc);
        break;
      case TRI_RIGHT:
        face_init_from_point_ref(f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1},
                                 3, !rev, loc);
        f = &cp_v_nth(&o->face, k++);
        face_init_from_point_ref(f, o, (size_t[4]){k1 + j1, k1 + j0, k0 + j0},
                                 3, !rev, loc);
        break;
      case TRI_NONE:
        face_init_from_point_ref(
            f, o, (size_t[4]){k0 + j0, k0 + j1, k1 + j1, k1 + j0}, 4, !rev,
            loc);
        break;
      default:
        assert(0);
      }
    }
  }

  if (!has_top) {

    size_t kw = o->point.size - 1;
    size_t kv = kw - fn;
    for (cp_size_each(j0, fn)) {
      size_t j1 = cp_wrap_add1(j0, fn);
      f = &cp_v_nth(&o->face, k++);
      face_init_from_point_ref(f, o, (size_t[4]){kv + j0, kv + j1, kw}, 3, !rev,
                               loc);
    }
  }

  assert(o->face.size == k);
  return poly_make_edges(o, c);
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->buf && out_pkt.data == pkt->data) {

      out_pkt.buf = av_buffer_ref(pkt->buf);
      if (!out_pkt.buf) {
        ret = AVERROR(ENOMEM);
        goto fail;
      }
    } else {
      ret = av_packet_make_refcounted(&out_pkt);
      if (ret < 0)
        goto fail;
    }

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;
    out_pkt.flags |= pkt->flags & AV_PKT_FLAG_DISCARD;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = ff_packet_list_put(&s->internal->parse_queue,
                             &s->internal->parse_queue_end, &out_pkt, 0);
    if (ret < 0) {
      av_packet_unref(&out_pkt);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	"Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices."	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"
opticron-libuweave-2e5e385/src/macaroon_helpers.c	Mint an initial server authentication token (SAT).	2	"bool uw_macaroon_mint_server_authentication_token_(
    const uint8_t *root_key, size_t root_key_len, const uint8_t *token_str,
    size_t token_str_len,
    const uint8_t nonce[UW_MACAROON_INIT_DELEGATION_NONCE_SIZE],
    uint8_t *buffer, size_t buffer_size, UwMacaroon *new_macaroon) {
  if (root_key == NULL || root_key_len == 0 || nonce == NULL ||
      buffer == NULL || buffer_size == 0 || new_macaroon == NULL) {
    return false;
  }
  if (token_str == NULL && token_str_len != 0) {
    return false;
  }

  *new_macaroon = (UwMacaroon){};

  const size_t num_caveats = 2;
  UwMacaroonCaveat **caveat_list =
      allocate_caveat_list_(num_caveats, &buffer, &buffer_size);
  if (caveat_list == NULL) {
    return false;
  }

  size_t needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeServerAuthenticationTokenV1, token_str_len);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_server_authentication_token_(
          token_str, token_str_len, buffer, needed_buffer_size,
          caveat_list[0])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeNonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_nonce_(
          nonce, UW_MACAROON_INIT_DELEGATION_NONCE_SIZE, buffer,
          needed_buffer_size, caveat_list[1])) {
    return false;
  }

  UwMacaroonContext context = {};
  return uw_macaroon_create_from_root_key_(
      new_macaroon, root_key, root_key_len, &context,
      (const UwMacaroonCaveat *const *)caveat_list, num_caveats);
}"
vsfteam-vsf-c4a58f3/release/kernel/beta/example/usrapp/template/main_fsm_simple.c	You cannot ignore fsm_initialiser at any time	4	"fsm_initialiser(user_task_b_t, args(vsf_sem_t *ptSEM))
    init_body(this.psem = ptSEM;)

        implement_fsm(user_task_b_t) def_states(PRINT, DELAY);

    body(
        on_start(
            update_state_to(PRINT);
        )
        
        state(PRINT){
  printf(""hello world! \r\n"");
  update_state_to(DELAY);                                              
        }"
kernkonzept-l4re-core-0dd677e/l4sys/include/types.h	Create a message tag from the specified values.	2	"l4_msgtag_t l4_msgtag(long label, unsigned words, unsigned items,
                      unsigned flags) L4_NOTHROW {
  return (l4_msgtag_t){
      (l4_mword_t)((l4_umword_t)label << 16) | (l4_mword_t)(words & 0x3f) |
      (l4_mword_t)((items & 0x3f) << 6) | (l4_mword_t)(flags & 0xf000)};
}"
cascadeo-monit-8857544/src/status.c	Show all services in the service list.	2	"boolean_t status(const char *level, const char *group, const char *service) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    Socket_print(S, ""GET /_status?format=text&level=%s"", level);
    if (group) {
      char *_group = Util_urlEncode((char *)group);
      Socket_print(S, ""&group=%s"", _group);
      FREE(_group);
    }
    if (service) {
      char *_service = Util_urlEncode((char *)service);
      Socket_print(S, ""&service=%s"", _service);
      FREE(_service);
    }
    char *_auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, "" HTTP/1.0\r\n%s\r\n"", _auth ? _auth : """");
    FREE(_auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio_tls_missing.c	Schedules the ALPN protocol callback.	2	"FIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,
                                 void *udata_connection) {
  if (!alpn || !alpn->on_selected)
    return;
  alpn_task_s *t = fio_malloc(sizeof(*t));
  *t = (alpn_task_s){
      .alpn = *alpn,
      .uuid = uuid,
      .udata_connection = udata_connection,
  };

  fio_defer(alpn_select___task, t, NULL);
}"
rockchip-linux-coreboot-adde3ea/src/cpu/intel/speedstep/speedstep.c	This is generic code and should work at least for Merom and Penryn processors. It is used to generate acpi tables and configure EMTTM.	4	"void speedstep_gen_pstates(sst_table_t *const table) {
  sst_params_t params;

  speedstep_get_limits(&params);

  const int power_diff2 = (params.max.power - params.min.power) * 2;
  const int vid_diff2 = (params.max.vid - params.min.vid) * 2;
  const int max_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.max);
  const int min_ratio2 = SPEEDSTEP_DOUBLE_RATIO(params.min);
  const int ratio_diff2 = max_ratio2 - min_ratio2;

  int states, step2 = 0;
  do {
    step2 += 2 * 2;
    states = ratio_diff2 / step2 + 1;
  } while (states > SPEEDSTEP_MAX_NORMAL_STATES);
  if (step2 > 4)
    printk(BIOS_INFO,
           ""Enhanced Speedstep processor with ""
           ""more than %d possible p-states.\n"",
           SPEEDSTEP_MAX_NORMAL_STATES);
  if (states < 2)
    states = 2;

  table->num_states = 0;

  if (params.turbo.is_turbo)
    table->states[table->num_states++] = params.turbo;

  table->states[table->num_states] = params.max;

  if ((params.max.dynfsb == params.min.dynfsb) &&
      (params.max.nonint == params.min.nonint) &&
      (params.max.ratio == params.min.ratio))
    table->states[table->num_states].vid = params.min.vid;
  ++table->num_states;
  --states;

  const int power_step = (power_diff2 / states) / 2;
  const int vid_step = (vid_diff2 / states) / 2;
  const int ratio_step = step2 / 2;
  int power = params.min.power + (states - 1) * power_step;
  int vid = params.min.vid + (states - 1) * vid_step;
  int ratio = params.min.ratio + (states - 1) * ratio_step;
  for (; states > 0; --states) {
    table->states[table->num_states++] =
        (sst_state_t){0, 0, ratio, vid, 0, 0, power};
    power -= power_step;
    vid -= vid_step;
    ratio -= ratio_step;
  }

  if (params.slfm.is_slfm)
    table->states[table->num_states++] = params.slfm;
}"
gmarco-mlt-orig-57ec61f/src/modules/avformat/consumer_avformat.c	Add an audio output stream	2	"static AVStream *add_audio_stream(mlt_consumer consumer, AVFormatContext *oc,
                                  AVCodec *codec, int channels) {

  mlt_properties properties = MLT_CONSUMER_PROPERTIES(consumer);

#if LIBAVFORMAT_VERSION_INT >= ((53 << 16) + (10 << 8) + 0)
  AVStream *st = avformat_new_stream(oc, codec);
#else
  AVStream *st = av_new_stream(oc, oc->nb_streams);
#endif

  if (st != NULL) {
    AVCodecContext *c = st->codec;

#if LIBAVCODEC_VERSION_MAJOR >= 53
    avcodec_get_context_defaults3(c, codec);
#else
    avcodec_get_context_defaults2(c, CODEC_TYPE_AUDIO);
#endif

    c->codec_id = codec->id;
    c->codec_type = CODEC_TYPE_AUDIO;
    c->sample_fmt = pick_sample_fmt(properties, codec);

#if 0  
		 
		int thread_count = mlt_properties_get_int( properties, ""threads"" );
		if ( thread_count == 0 && getenv( ""MLT_AVFORMAT_THREADS"" ) )
			thread_count = atoi( getenv( ""MLT_AVFORMAT_THREADS"" ) );
		if ( thread_count > 1 )
			c->thread_count = thread_count;
#endif

    if (oc->oformat->flags & AVFMT_GLOBALHEADER)
      c->flags |= CODEC_FLAG_GLOBAL_HEADER;

    if (mlt_properties_get(properties, ""atag"")) {
      char *tail = NULL;
      char *arg = mlt_properties_get(properties, ""atag"");
      int tag = strtol(arg, &tail, 0);
      if (!tail || *tail)
        tag = arg[0] + (arg[1] << 8) + (arg[2] << 16) + (arg[3] << 24);
      c->codec_tag = tag;
    }

    char *apre = mlt_properties_get(properties, ""apre"");
    if (apre) {
      mlt_properties p = mlt_properties_load(apre);
      apply_properties(c, p,
                       AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM);
      mlt_properties_close(p);
    }
    apply_properties(c, properties,
                     AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM);

    int audio_qscale = mlt_properties_get_int(properties, ""aq"");
    if (audio_qscale > QSCALE_NONE) {
      c->flags |= CODEC_FLAG_QSCALE;
      c->global_quality = FF_QP2LAMBDA * audio_qscale;
#if LIBAVFORMAT_VERSION_MAJOR < 53
      st->quality = c->global_quality;
#endif
    }

    c->sample_rate = mlt_properties_get_int(properties, ""frequency"");
    c->time_base = (AVRational){1, c->sample_rate};
    c->channels = channels;

    if (mlt_properties_get(properties, ""alang"") != NULL)
#if LIBAVFORMAT_VERSION_INT >= ((52 << 16) + (43 << 8) + 0)
#if LIBAVUTIL_VERSION_INT >= ((51 << 16) + (8 << 8) + 0)
      av_dict_set(&oc->metadata, ""language"",
                  mlt_properties_get(properties, ""alang""), 0);
#else
      av_metadata_set2(&oc->metadata, ""language"",
                       mlt_properties_get(properties, ""alang""), 0);
#endif
#else

      strncpy(st->language, mlt_properties_get(properties, ""alang""),
              sizeof(st->language));
#endif
  } else {
    mlt_log_error(MLT_CONSUMER_SERVICE(consumer),
                  ""Could not allocate a stream for audio\n"");
  }

  return st;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Prevent/Allow Medium Removal command to the attached device, to lock the physical media from being removed. This is a legacy command for SCSI disks with removable storage (such as ZIP disks), but should still be issued before the first read or write command is sent."	1	"uint8_t MassStore_PreventAllowMediumRemoval(const uint8_t LUNIndex,
                                            const bool PreventRemoval) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, NULL);
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavcodec/golomb.h	write unsigned exp golomb code.	2	"static inline void set_ue_golomb(PutBitContext *pb, int i) {
  int e;

  av_assert2(i >= 0);

#if 0
    if(i=0){
        put_bits(pb, 1, 1);
        return;
    }
#endif
  if (i < 256)
    put_bits(pb, ff_ue_golomb_len[i], i + 1);
  else {
    e = av_log2(i + 1);

    put_bits(pb, 2 * e + 1, i + 1);
  }
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/source-http/source/arm_uc_source_http.c	The default manifest is polled regularly and generates a notification upon change. The URI struct and the content pointer to must be valid throughout the lifetime of the application.	2	"arm_uc_error_t ARM_UCS_Http_SetDefaultManifestURL(arm_uc_uri_t *uri) {
  UC_SRCE_TRACE_ENTRY("">> %s"", __func__);

  if ((uri == NULL) || (uri->scheme != URI_SCHEME_HTTP)) {
    ARM_UCS_Http_SetError((arm_uc_error_t){SRCE_ERR_INVALID_PARAMETER});
    return ARM_UC_ERROR(SRCE_ERR_INVALID_PARAMETER);
  } else {

    default_config.manifest = *uri;
    return ARM_UC_ERROR(ERR_NONE);
  }
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	Writes blocks of data to the attached Mass Storage device's medium.	1	"uint8_t
MS_Host_WriteDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          const uint8_t LUNIndex, const uint32_t BlockAddress,
                          const uint8_t Blocks, const uint16_t BlockSize,
                          const void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
renesugar-FileConvert-1f304e1/ThirdParty/librdkafka/src-cpp/rdkafkacpp_int.h	Any previous subscription will be unassigned and unsubscribed first.	2	"~EventImpl(){};

EventImpl(Type type, ErrorCode err, Severity severity, const char *fac,
          const char *str)
    : type_(type), err_(err), severity_(severity), fac_(fac ? fac : """"),
      str_(str), id_(0), throttle_time_(0){};

EventImpl(Type type)
    : type_(type), err_(ERR_NO_ERROR), severity_(EVENT_SEVERITY_EMERG),
      fac_(""""), str_(""""), id_(0), throttle_time_(0){};

Type type() const { return type_; }
ErrorCode err() const { return err_; }
Severity severity() const { return severity_; }
std::string fac() const { return fac_; }
std::string str() const { return str_; }"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/AudioClassHost.c	Gets or sets the specified property of a streaming audio class endpoint that is bound to a pipe in the given class instance.	2	"uint8_t Audio_Host_GetSetEndpointProperty(
    USB_ClassInfo_Audio_Host_t *const AudioInterfaceInfo,
    const uint8_t DataPipeIndex, const uint8_t EndpointProperty,
    const uint8_t EndpointControl, const uint16_t DataLength,
    void *const Data) {
  if (!(AudioInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t RequestType;
  uint8_t EndpointAddress;

  if (EndpointProperty & 0x80)
    RequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_ENDPOINT);
  else
    RequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT);

  Pipe_SelectPipe(DataPipeIndex);
  EndpointAddress = Pipe_GetBoundEndpointAddress();

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = RequestType,
      .bRequest = EndpointProperty,
      .wValue = ((uint16_t)EndpointControl << 8),
      .wIndex = EndpointAddress,
      .wLength = DataLength,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Data);
}"
argvk-ffmpeg-examples-29dccee/dshow_capture_video.c	captures from dshow input and writes to out.webm captures just the video	2	"int main(int argc, char **argv) {

  av_register_all();
  avcodec_register_all();
  avdevice_register_all();
  avfilter_register_all();

  AVCodec *pCodecOut;
  AVCodec *pCodecInCam;

  AVCodecContext *pCodecCtxOut = NULL;
  AVCodecContext *pCodecCtxInCam = NULL;

  char args_cam[512];

  int i, ret, got_output, video_stream_idx_cam;

  AVFrame *cam_frame, *outFrame, *filt_frame;
  AVPacket packet;

  const char *filename = ""out.webm"";

  AVOutputFormat *pOfmtOut = NULL;
  AVStream *strmVdoOut = NULL;

  AVInputFormat *inFrmt = av_find_input_format(""dshow"");

  AVDictionary *inOptions = NULL;

  AVFormatContext *pFormatCtxOut;
  AVFormatContext *pFormatCtxInCam;

  AVFilter *buffersrc_cam = avfilter_get_by_name(""buffer"");
  AVFilter *buffersink = avfilter_get_by_name(""buffersink"");

  AVFilterInOut *outputs = avfilter_inout_alloc();
  AVFilterInOut *inputs = avfilter_inout_alloc();

  AVFilterContext *buffersink_ctx;
  AVFilterContext *buffersrc_ctx_cam;
  AVFilterGraph *filter_graph;

  AVBufferSinkParams *buffersink_params;

  const char *filter_str = ""scale='w=-1:h=480',format='yuv420p'"";

  pFormatCtxInCam = avformat_alloc_context();

  av_dict_set(&inOptions, ""video_size"", ""640x480"", 0);
  av_dict_set(&inOptions, ""r"", ""25"", 0);

  ret = avformat_open_input(&pFormatCtxInCam, ""video=ManyCam Virtual Webcam"",
                            inFrmt, &inOptions);

  if (avformat_find_stream_info(pFormatCtxInCam, NULL) < 0)
    return -1;

  video_stream_idx_cam = -1;

  for (i = 0; i < pFormatCtxInCam->nb_streams; i++)
    if (pFormatCtxInCam->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
      video_stream_idx_cam = i;

  if (video_stream_idx_cam == -1)
    return -1;

  pCodecCtxInCam = pFormatCtxInCam->streams[video_stream_idx_cam]->codec;

  pCodecInCam = avcodec_find_decoder(pCodecCtxInCam->codec_id);

  if (pCodecInCam == NULL) {
    fprintf(stderr, ""decoder not fiund"");
    exit(1);
  }

  if (avcodec_open2(pCodecCtxInCam, pCodecInCam, NULL) < 0) {
    av_log(NULL, AV_LOG_ERROR, ""Cannot open video decoder for webcam\n"");
    exit(1);
  }

  pOfmtOut = av_guess_format(NULL, filename, NULL);

  pFormatCtxOut = avformat_alloc_context();

  pOfmtOut->video_codec = AV_CODEC_ID_VP8;

  pFormatCtxOut->oformat = pOfmtOut;

  snprintf(pFormatCtxOut->filename, sizeof(pFormatCtxOut->filename), ""%s"",
           filename);

  strmVdoOut = avformat_new_stream(pFormatCtxOut, NULL);
  if (!strmVdoOut) {
    fprintf(stderr, ""Could not alloc stream\n"");
    exit(1);
  }

  pCodecCtxOut = strmVdoOut->codec;
  if (!pCodecCtxOut) {
    fprintf(stderr, ""Could not allocate video codec context\n"");
    exit(1);
  }

  pCodecCtxOut->codec_id = pOfmtOut->video_codec;
  pCodecCtxOut->codec_type = AVMEDIA_TYPE_VIDEO;

  pCodecCtxOut->bit_rate = 1200000;
  pCodecCtxOut->pix_fmt = AV_PIX_FMT_YUV420P;
  pCodecCtxOut->width = 640;
  pCodecCtxOut->height = 480;
  pCodecCtxOut->time_base = (AVRational){1, 25};

  if (pFormatCtxOut->oformat->flags & AVFMT_GLOBALHEADER)
    pCodecCtxOut->flags |= CODEC_FLAG_GLOBAL_HEADER;

  pCodecOut = avcodec_find_encoder(pCodecCtxOut->codec_id);
  if (!pCodecOut) {
    fprintf(stderr, ""Codec not found\n"");
    exit(1);
  }

  if (avcodec_open2(pCodecCtxOut, pCodecOut, NULL) < 0) {
    fprintf(stderr, ""Could not open codec\n"");
    exit(1);
  }

  if (avio_open(&pFormatCtxOut->pb, filename, AVIO_FLAG_WRITE) < 0) {
    fprintf(stderr, ""Could not open '%s'\n"", filename);
    exit(1);
  }

  ret = avformat_write_header(pFormatCtxOut, NULL);
  if (ret < 0) {
    fprintf(stderr, ""Could not write header '%d'\n"", ret);
    exit(1);
  }

  cam_frame = av_frame_alloc();
  outFrame = av_frame_alloc();
  filt_frame = av_frame_alloc();

  if (!cam_frame || !outFrame || !filt_frame) {
    fprintf(stderr, ""Could not allocate video frame\n"");
    exit(1);
  }

  enum AVPixelFormat pix_fmts[] = {pCodecCtxInCam->pix_fmt, AV_PIX_FMT_NONE};

  filter_graph = avfilter_graph_alloc();

  snprintf(args_cam, sizeof(args_cam),
           ""video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:pixel_aspect=%d/%d"",
           pCodecCtxInCam->width, pCodecCtxInCam->height,
           pCodecCtxInCam->pix_fmt, pCodecCtxInCam->time_base.num,
           pCodecCtxInCam->time_base.den,
           pCodecCtxInCam->sample_aspect_ratio.num,
           pCodecCtxInCam->sample_aspect_ratio.den);

  ret = avfilter_graph_create_filter(&buffersrc_ctx_cam, buffersrc_cam, ""in"",
                                     args_cam, NULL, filter_graph);
  if (ret < 0) {
    av_log(NULL, AV_LOG_ERROR, ""Cannot create buffer source\n"");
    exit(ret);
  }

  buffersink_params = av_buffersink_params_alloc();
  buffersink_params->pixel_fmts = pix_fmts;

  ret = avfilter_graph_create_filter(&buffersink_ctx, buffersink, ""out"", NULL,
                                     buffersink_params, filter_graph);
  av_free(buffersink_params);
  if (ret < 0) {
    av_log(NULL, AV_LOG_ERROR, ""Cannot create buffer sink\n"");
    exit(ret);
  }

  outputs->name = av_strdup(""in"");
  outputs->filter_ctx = buffersrc_ctx_cam;
  outputs->pad_idx = 0;
  outputs->next = NULL;

  inputs->name = av_strdup(""out"");
  inputs->filter_ctx = buffersink_ctx;
  inputs->pad_idx = 0;
  inputs->next = NULL;

  if ((ret = avfilter_graph_parse_ptr(filter_graph, filter_str, &inputs,
                                      &outputs, NULL)) < 0) {
    printf(""error in graph parse"");
    exit(ret);
  }

  if ((ret = avfilter_graph_config(filter_graph, NULL)) < 0) {
    printf(""error in graph config"");
    exit(ret);
  }

  av_dump_format(pFormatCtxInCam, 0, ""cam"", 0);
  av_dump_format(pFormatCtxOut, 0, filename, 1);

  for (i = 0; i < 300; i++) {
    av_init_packet(&packet);

    ret = av_read_frame(pFormatCtxInCam, &packet);

    if (ret < 0) {
      fprintf(stderr, ""Error reading frame\n"");
      break;
    }

    if (packet.stream_index == video_stream_idx_cam) {

      packet.dts = av_rescale_q_rnd(
          packet.dts, pFormatCtxInCam->streams[video_stream_idx_cam]->time_base,
          pFormatCtxInCam->streams[video_stream_idx_cam]->codec->time_base,
          AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);
      packet.pts = av_rescale_q_rnd(
          packet.pts, pFormatCtxInCam->streams[video_stream_idx_cam]->time_base,
          pFormatCtxInCam->streams[video_stream_idx_cam]->codec->time_base,
          AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);

      ret = avcodec_decode_video2(pCodecCtxInCam, cam_frame, &got_output,
                                  &packet);

      cam_frame->pts = av_frame_get_best_effort_timestamp(cam_frame);

      if (got_output) {

        av_free_packet(&packet);
        av_init_packet(&packet);

        ret = av_buffersrc_add_frame_flags(buffersrc_ctx_cam, cam_frame, 0);

        while (1) {
          filt_frame = av_frame_alloc();
          if (ret < 0) {
            av_log(NULL, AV_LOG_ERROR, ""Error while feeding the filtergraph\n"");
            break;
          }

          ret = av_buffersink_get_frame(buffersink_ctx, filt_frame);
          if (ret < 0) {

            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
              ret = 0;
            av_frame_free(&filt_frame);
            break;
          }

          outFrame = filt_frame;

          ret = avcodec_encode_video2(pCodecCtxOut, &packet, outFrame,
                                      &got_output);
          if (got_output) {

            packet.dts = av_rescale_q_rnd(
                packet.dts,
                pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
                pFormatCtxOut->streams[video_stream_idx_cam]->time_base,
                AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);

            packet.pts = av_rescale_q_rnd(
                packet.pts,
                pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
                pFormatCtxOut->streams[video_stream_idx_cam]->time_base,
                AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);

            packet.duration = av_rescale_q(
                packet.duration,
                pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
                pFormatCtxOut->streams[video_stream_idx_cam]->time_base);

            if (av_interleaved_write_frame(pFormatCtxOut, &packet) < 0) {
              fprintf(stderr, ""error writing frame"");
              exit(1);
            }
          }
          if (ret < 0) {
            av_frame_free(&filt_frame);
            break;
          }
        }
      }
    }

    av_free_packet(&packet);
  }

  for (got_output = 1; got_output; i++) {
    ret = avcodec_encode_video2(pCodecCtxOut, &packet, NULL, &got_output);
    if (ret < 0) {
      fprintf(stderr, ""Error encoding frame\n"");
      exit(1);
    }

    if (got_output) {
      packet.dts = av_rescale_q_rnd(
          packet.dts,
          pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
          pFormatCtxOut->streams[video_stream_idx_cam]->time_base,
          AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);

      packet.pts = av_rescale_q_rnd(
          packet.pts,
          pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
          pFormatCtxOut->streams[video_stream_idx_cam]->time_base,
          AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);

      packet.duration = av_rescale_q(
          packet.duration,
          pFormatCtxOut->streams[video_stream_idx_cam]->codec->time_base,
          pFormatCtxOut->streams[video_stream_idx_cam]->time_base);

      if (pCodecCtxOut->coded_frame->key_frame)
        packet.flags |= AV_PKT_FLAG_KEY;

      ret = av_interleaved_write_frame(pFormatCtxOut, &packet);
      if (ret < 0) {
        exit(1);
      }
      av_free_packet(&packet);
    }
  }

  ret = av_write_trailer(pFormatCtxOut);
  if (ret < 0) {
    exit(1);
  }

  avcodec_close(strmVdoOut->codec);
  avcodec_close(pCodecCtxInCam);
  avcodec_close(pCodecCtxOut);
  for (i = 0; i < pFormatCtxOut->nb_streams; i++) {
    av_freep(&pFormatCtxOut->streams[i]->codec);
    av_freep(&pFormatCtxOut->streams[i]);
  }
  avio_close(pFormatCtxOut->pb);
  av_free(pFormatCtxOut);
  av_free(pFormatCtxInCam);
  av_dict_free(&inOptions);

  return 0;
}"
tempesta-tech-tempesta-9bbfee9/tempesta_fw/http.c	"Copy  content to allocated memory as compound of `Content-length' header, crlfcrlf and message body. Memory is allocated via __get_free_pages(), thus free_pages() must be used on cleanup;  - total length of body data including headers."	2	"tfw_http_msg_body_dup(const char *filename, size_t *len) {
  TfwStr c_len_hdr = {
      .chunks =
          (TfwStr[]){
              {.data = S_F_CONTENT_LENGTH, .len = SLEN(S_F_CONTENT_LENGTH)},
              {.data = NULL, .len = 0},
              {.data = S_CRLFCRLF, .len = SLEN(S_CRLFCRLF)},
          },
      .len = SLEN(S_F_CONTENT_LENGTH S_CRLFCRLF),
      .nchunks = 3};
  size_t b_off;

  return __tfw_http_msg_body_dup(filename, &c_len_hdr, len, &b_off);
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Test Unit Ready command to the attached device, to determine if the device is ready to accept other commands."	1	"uint8_t MassStore_TestUnitReady(const uint8_t LUNIndex) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, NULL)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/Printer.c	"Soft-resets the attached printer, readying it for new commands."	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/GenericHIDHost/GenericHIDHost.c	Writes a report to the attached device.	1	"void WriteNextReport(uint8_t *ReportOUTData, const uint8_t ReportIndex,
                     const uint8_t ReportType, uint16_t ReportLength) {

  Pipe_SelectPipe(HID_DATA_OUT_PIPE);

  if (Pipe_IsConfigured() && (ReportType == REPORT_TYPE_OUT)) {
    Pipe_Unfreeze();

    if (!(Pipe_IsOUTReady())) {

      Pipe_Freeze();

      return;
    }

    if (ReportIndex)
      Pipe_Write_Byte(ReportIndex);

    Pipe_Write_Stream_LE(ReportOUTData, ReportLength);

    Pipe_ClearOUT();

    Pipe_Freeze();
  } else {

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetReport,
        .wValue = ((ReportType << 8) | ReportIndex),
        .wIndex = 0,
        .wLength = ReportLength,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    USB_Host_SendControlRequest(ReportOUTData);
  }
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the vector portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_float qvectorf(const quaternion_float num) {
  const quaternion_float conj_num =
      (quaternion_float){num.R, num.i * -1.0F, num.j * -1.0F, num.k * -1.0F};
  return (quaternion_float){
      (num.R - conj_num.R) * 0.5F, (num.i - conj_num.i) * 0.5F,
      (num.j - conj_num.j) * 0.5F, (num.k - conj_num.k) * 0.5F};
}"
ging-isabel-1ec0172/lib/ffmpeg/Win32/src/ffmpeg/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
#define LOG2 0.69314718055994530941723212145817656807550013436025
  int exponent;
  int64_t den;
  if (isnan(d))
#if __STDC_VERSION >= 199901L
    return (AVRational){0, 0};
#else
  {
    AVRational retVal = {0, 0};
    return retVal;
  }
#endif
  if (isinf(d))
#if __STDC_VERSION >= 199901L
    return (AVRational){d < 0 ? -1 : 1, 0};
#else
  {
    AVRational retVal = {d < 0 ? -1 : 1, 0};
    return retVal;
  }
#endif
  exponent = FFMAX((int)(log(fabs(d) + 1e-20) / LOG2), 0);
  den = 1LL << (61 - exponent);
  av_reduce(&a.num, &a.den, (int64_t)(d * den + 0.5), den, max);

  return a;
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
#define LOG2 0.69314718055994530941723212145817656807550013436025
  int exponent;
  int64_t den;
  if (isnan(d)) {
    return (AVRational){0, 0};
  }
  if (fabs(d) > INT_MAX + LLN(3)) {
    return (AVRational){d < 0 ? -1 : 1, 0};
  }
  exponent = FFMAX((int)(log(fabs(d) + 1e-20) / LOG2), 0);
  den = LLN(1) << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"
strk-gnash-f6a0b38/gui/gui.h	Default constructor. Initialises members to safe defaults.	2	"public:
virtual ~Gui();

virtual bool init(int argc, char **argv[]) = 0;

virtual void setInterval(unsigned int interval) { _interval = interval; }

virtual VirtualClock &getClock() { return _virtualClock; }

virtual void setTimeout(unsigned int timeout) = 0;

void setScreenShotter(std::unique_ptr<ScreenShotter> ss);

virtual bool createWindow(const char *title, int width, int height,
                          int xPosition = 0, int yPosition = 0) = 0;

virtual void resizeWindow(int width, int height);

virtual bool run() = 0;

void quit();

virtual void renderBuffer() = 0;

virtual void setInvalidatedRegion(const SWFRect &bounds);
virtual void setInvalidatedRegions(const InvalidatedRanges &ranges);

virtual void beforeRendering(){};

virtual bool want_multiple_regions() { return false; }

virtual bool want_redraw();

virtual void setCursor(gnash_cursor_type newcursor);

virtual void setClipboard(const std::string &copy);

virtual double getPixelAspectRatio() const { return 0; }"
tumi8-vermont-32e684a/src/modules/packet/filter/PacketFilterCfg.h	returns an instance of the module which the config element describes	2	"virtual bool deriveFrom(PacketStringFilterCfg *old);

protected:
PacketStringFilterCfg(XMLElement *e)
    : PacketFilterHelperCfg(e), instance(NULL) {}

private:
StringFilter *instance;
}
;

class PacketRegexFilterCfg : public PacketFilterHelperCfg {
public:
  friend class PacketFilterCfg;

  virtual PacketFilterCfg *create(XMLElement *e) { return NULL; };

  virtual ~PacketRegexFilterCfg(){};

  virtual std::string getName() { return ""regexBased""; }"
Happy-Ferret-Monit-33780b3/src/status.c	Show all services in the service list.	2	"int status(char *level) {

#define LINE 1024

  int status = FALSE;
  Socket_T S = NULL;
  char buf[LINE];
  char *auth = NULL;

  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  S = socket_create_t(
      Run.bind_addr ? Run.bind_addr : ""localhost"", Run.httpdport, SOCKET_TCP,
      (Ssl_T){.use_ssl = Run.httpdssl, .clientpemfile = Run.httpsslclientpem},
      NET_TIMEOUT);
  if (!S) {
    LogError(""Error connecting to the monit daemon\n"");
    return status;
  }

  auth = Util_getBasicAuthHeaderMonit();
  socket_print(S, ""GET /_status?format=text&level=%s HTTP/1.0\r\n%s\r\n"", level,
               auth ? auth : """");
  FREE(auth);

  while (socket_readln(S, buf, LINE)) {
    if (*buf == '\n' || *buf == '\r')
      break;
    if (Str_startsWith(buf, ""HTTP/1.0 200""))
      status = TRUE;
  }

  if (!status) {
    LogError(""Cannot read status from the monit daemon\n"");
  } else {
    while (socket_readln(S, buf, LINE)) {
      printf(""%s"", buf);
    }
  }
  socket_free(&S);

  return status;
}"
tartanguru-alexa-assistant-f2eedf1/lib/node_modules/grpc/src/core/ext/client_channel/subchannel.c	create a subchannel given a connector	2	"grpc_subchannel *grpc_subchannel_create(grpc_exec_ctx *exec_ctx,
                                        grpc_connector *connector,
                                        const grpc_subchannel_args *args) {
  grpc_subchannel_key *key = grpc_subchannel_key_create(connector, args);
  grpc_subchannel *c = grpc_subchannel_index_find(exec_ctx, key);
  if (c) {
    grpc_subchannel_key_destroy(exec_ctx, key);
    return c;
  }

  c = gpr_malloc(sizeof(*c));
  memset(c, 0, sizeof(*c));
  c->key = key;
  gpr_atm_no_barrier_store(&c->ref_pair, 1 << INTERNAL_REF_BITS);
  c->connector = connector;
  grpc_connector_ref(c->connector);
  c->num_filters = args->filter_count;
  if (c->num_filters > 0) {
    c->filters = gpr_malloc(sizeof(grpc_channel_filter *) * c->num_filters);
    memcpy((void *)c->filters, args->filters,
           sizeof(grpc_channel_filter *) * c->num_filters);
  } else {
    c->filters = NULL;
  }
  c->pollset_set = grpc_pollset_set_create();
  grpc_resolved_address *addr = gpr_malloc(sizeof(*addr));
  grpc_get_subchannel_address_arg(args->args, addr);
  grpc_set_initial_connect_string(&addr, &c->initial_connect_string);
  static const char *keys_to_remove[] = {GRPC_ARG_SUBCHANNEL_ADDRESS};
  grpc_arg new_arg = grpc_create_subchannel_address_arg(addr);
  gpr_free(addr);
  c->args = grpc_channel_args_copy_and_add_and_remove(
      args->args, keys_to_remove, GPR_ARRAY_SIZE(keys_to_remove), &new_arg, 1);
  gpr_free(new_arg.value.string);

  c->root_external_state_watcher.next = c->root_external_state_watcher.prev =
      &c->root_external_state_watcher;
  grpc_closure_init(&c->connected, subchannel_connected, c,
                    grpc_schedule_on_exec_ctx);
  grpc_connectivity_state_init(&c->state_tracker, GRPC_CHANNEL_IDLE,
                               ""subchannel"");
  int initial_backoff_ms =
      GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS * 1000;
  int max_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS * 1000;
  int min_backoff_ms = GRPC_SUBCHANNEL_MIN_CONNECT_TIMEOUT_SECONDS * 1000;
  bool fixed_reconnect_backoff = false;
  if (c->args) {
    for (size_t i = 0; i < c->args->num_args; i++) {
      if (0 == strcmp(c->args->args[i].key,
                      ""grpc.testing.fixed_reconnect_backoff_ms"")) {
        GPR_ASSERT(c->args->args[i].type == GRPC_ARG_INTEGER);
        fixed_reconnect_backoff = true;
        initial_backoff_ms = min_backoff_ms = max_backoff_ms =
            grpc_channel_arg_get_integer(
                &c->args->args[i],
                (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        max_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){max_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        initial_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      }
    }
  }
  gpr_backoff_init(
      &c->backoff_state, initial_backoff_ms,
      fixed_reconnect_backoff ? 1.0
                              : GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER,
      fixed_reconnect_backoff ? 0.0 : GRPC_SUBCHANNEL_RECONNECT_JITTER,
      min_backoff_ms, max_backoff_ms);
  gpr_mu_init(&c->mu);

  return grpc_subchannel_index_register(exec_ctx, key, c);
}"
CZ-NIC-knot-resolver-3775bbc/lib/generic/trie.c	Make the root node empty (debug-only).	2	"static inline void empty_root(node_t *root) {
#ifndef NDEBUG
  *root =
      (node_t){.branch = {.flags = 3, .bitmap = 0, .index = -1, .twigs = NULL}};
#endif
}"
hhirsch-armagetron-ea92d13/src/tron/cockpit/cWidgetBase.h	This function will parse Size and Position nodes.	2	"bool m_RenderDefault;
bool m_Sticky;
cCockpit *m_Cockpit;

public:
Base()
    : m_ParsingTemplate(false), m_Render(true), m_RenderDefault(true),
      m_Sticky(true) {}
virtual ~Base() {}
virtual void Render() = 0;
virtual void PostParsingProcess(){};
virtual void BeforeRoundProcess(){};
virtual void AfterRoundProcess(){};
void SetCam(int Cam);

int GetCam(void) { return m_Cam; }
virtual bool Process(tXmlParser::node cur);
void SetDefaultState(bool state) { m_Render = m_RenderDefault = state; }
void SetCockpit(cCockpit *cockpit) { m_Cockpit = cockpit; }
void SetSticky(bool sticky) { m_Sticky = sticky; }
bool Active() { return m_Render; }"
mrirecon-bart-47fce6b/src/num/flpmath.c	"Elementwise maximum of input and scalar (with strides) optr = max(val, iptr)"	2	"void md_smax2(unsigned int D, const long dim[D], const long ostr[D],
              float *optr, const long istr[D], const float *iptr, float val) {
#if 0

#if 0
	float* tmp = md_alloc_sameplace(D, dim, FL_SIZE, iptr);
	md_sgreatequal2(D, dim, ostr, tmp, istr, iptr, val);
	md_mul2(D, dim, ostr, optr, istr, iptr, istr, tmp);
	md_free(tmp);
#else
	make_3op_scalar(md_max2, D, dim, ostr, optr, istr, iptr, val);
#endif
#else
  (void)0;

  NESTED(void, nary_smax, (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->smax(data->size, ptr[0], ptr[1], val);
  };

  optimized_twoop_oi(D, dim, ostr, optr, istr, iptr,
                     (size_t[2]){FL_SIZE, FL_SIZE}, nary_smax);
#endif
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a Mass Storage class specific request to reset the attached device's Mass Storage interface, readying the device for the next CBW."	1	"uint8_t MassStore_MassStorageReset(void) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a Mass Storage class specific request to reset the attached device's Mass Storage interface, readying the device for the next CBW. The Data endpoints are cleared of any STALL condition once this command completes sucessfuly."	1	"uint8_t MassStore_MassStorageReset(void) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MASS_STORE_DATA_IN_PIPE);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MASS_STORE_DATA_OUT_PIPE);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  return HOST_SENDCONTROL_Successful;
}"
Inifield-waad-98aaebf/src/ascent-world/Object.h	"This includes any nested objects we have, inventory for example."	2	"bool deleted;

ProcFnc() : m_creator(NULL), m_base(NULL), m_data(NULL), deleted(false) {}
}
;

enum PHASEMODE {
  ALL_PHASES = -1,
  GHOST_PHASING = 0,
  NORMAL_PHASING = 1,
  PHASE_2,
  PHASE_3,
  PHASE_4,
  PHASE_5,

  PHASE_6,
  PHASE_7,
  PHASE_8,
  PHASE_9,
  PHASE_10,
  MAX_PHASEMODE

};

class WorldPacket;
class ByteBuffer;
class WorldSession;
class Player;
class MapCell;
class MapMgr;
class Vehicle;

class SERVER_DECL Object : public EventableObject {
public:
  typedef std::set<Object *> InRangeSet;
  typedef std::map<string, void *> ExtensionSet;

  virtual void Init();
  virtual ~Object();

  virtual void OnPositionChange(){};

  uint32 m_Phase;
  const uint32 GetPhase() { return m_Phase; }
  void SetPhase(uint32 Phase);
  void EnablePhase(uint32 Phase);
  void DisablePhase(uint32 Phase);

  bool CanActivateCell();
  virtual void Update(uint32 time) {}

  void KillSelf();

  void DeleteOperator();
  void HandleDeath(Unit *pVictim, uint32 damage, uint32 targetEvent,
                   uint32 unitEvent, uint32 spellId, bool no_remove_auras,
                   Player *plr, bool isCritter);

  ASCENT_INLINE bool IsInWorld() { return m_mapMgr != NULL; }
  virtual void AddToWorld();
  virtual void AddToWorld(MapMgr *pMapMgr);
  void PushToWorld(MapMgr *);
  virtual void OnPushToWorld() {}
  virtual void OnPrePushToWorld() {}
  virtual void RemoveFromWorld(bool free_guid);

#ifndef USING_BIG_ENDIAN
  ASCENT_INLINE const uint64 &GetGUID() const {
    return *((uint64 *)m_uint32Values);
  }
#else
  ASCENT_INLINE const uint64 GetGUID() const { return GetUInt64Value(0); }
#endif

  ASCENT_INLINE const WoWGuid &GetNewGUID() const { return m_wowGuid; }
  ASCENT_INLINE uint32 GetEntry() { return m_uint32Values[3]; }

  ASCENT_INLINE void ObjLock() { m_objlock.Acquire(); }
  ASCENT_INLINE void ObjUnlock() { m_objlock.Release(); }

  ASCENT_INLINE const uint32 GetEntryFromGUID() const {

    return uint32((*(uint64 *)m_uint32Values >> 24) & 0xFFFFFFFF);
  }

  ASCENT_INLINE const uint32 GetTypeFromGUID() const {
    return (m_uint32Values[1] & HIGHGUID_TYPE_MASK);
  }
  ASCENT_INLINE const uint32 GetUIdFromGUID() const {
    return (m_uint32Values[0] & LOWGUID_ENTRY_MASK);
  }
  ASCENT_INLINE const uint32 GetLowGUID() const { return (m_uint32Values[0]); }
  ASCENT_INLINE const uint32 GetHighGUID() const { return (m_uint32Values[1]); }

  ASCENT_INLINE const uint8 &GetTypeId() const { return m_objectTypeId; }
  ASCENT_INLINE bool IsUnit() {
    return ((m_objectTypeId == TYPEID_UNIT) ||
            (m_objectTypeId == TYPEID_PLAYER));
  }
  ASCENT_INLINE bool IsPlayer() { return m_objectTypeId == TYPEID_PLAYER; }"
DNPA-OcfaLib-79e68c1/inc/misc/OcfaLogger.hpp	Retreive a pointer to the logger singleton	2	"virtual void baptize(ModuleInstance *modinstance) = 0;

virtual void setLevel(std::string level) = 0;

virtual void setcontext(std::string context) = 0;
virtual void clearcontext() = 0;

virtual void setLevel(std::string level, std::string prefix) = 0;

virtual std::ostream &syslog(syslog_level level, const OcfaObject *object) = 0;
virtual std::ostream &syslog(syslog_level level, std::string prefix = """") = 0;
virtual bool needsStdIO() = 0;
virtual ~OcfaLogger(){};

protected:
OcfaLogger();

private:
static OcfaLogger *_instance;
}
;
}
}"
google-graphd-e994e88/libgdp/gdp-input.c	Initialize input as a chain of buffers.	2	"int gdp_input_init_chain(gdp_input *in, srv_buffer *chain, cm_handle *cm,
                         cl_handle *cl) {
  srv_buffer *b;

  gdp_assert(cl, chain);
  for (b = chain; b->b_next; b = b->b_next)
    ;

  *in = (gdp_input){
      .in_queue =
          (gdp_input_queue){
              .iq_curr = chain,
              .iq_curr_i = 0,
              .iq_tail = b,
              .iq_tail_n = b->b_n,
          },
      .in_cm = cm,
      .in_cl = cl,
      .in_row = 1,
      .in_col = 1,
  };

  return 0;
}"
bus1-dbus-broker-b41db8a/src/util/user.c	user_charge_init() - initialize charge object : charge object to initialize This initializes a new charge object.	0	void user_charge_init(UserCharge *charge) { *charge = (UserCharge){}; }
HiPhish-XeenTools-ee7c26c/Source/cfg/cfg_tool.c	Read configuration information form a CFG file.	2	"int xeen_read_cfg(FILE *fp, XeenCfg *cfg) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
  } error = SUCCESS;
  uint8_t bytes[28];

  if (!fp || !cfg) {
    error = INVALID_ARGS;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), 28, fp) != 28 * sizeof(uint8_t)) {
    error = FREAD_FAIL;
    goto end;
  }

  *cfg = (XeenCfg){
      .sound_card = bytes_to_uint16(bytes[0x00], bytes[0x01]),
      .sound_address = bytes_to_uint16(bytes[0x02], bytes[0x03]),

      .music_card = bytes_to_uint16(bytes[0x04], bytes[0x05]),
      .music_address = bytes_to_uint16(bytes[0x06], bytes[0x07]),

      .irq = bytes_to_uint16(bytes[0x08], bytes[0x09]),

      .ereiamjh =
          {
              bytes[0x0A + 0x00],
              bytes[0x0A + 0x01],
              bytes[0x0A + 0x02],
              bytes[0x0A + 0x03],
              bytes[0x0A + 0x04],
              bytes[0x0A + 0x05],
              bytes[0x0A + 0x06],
              bytes[0x0A + 0x07],
          },

      .has_386 = bytes_to_uint16(bytes[0x12], bytes[0x13]),

      .volume_set = bytes_to_uint16(bytes[0x14], bytes[0x15]),

      .won_darkside = bytes[0x16],
      .won_third = bytes[0x17],

      .sound_dma = bytes_to_uint16(bytes[0x18], bytes[0x19]),

      .saw_dark_intro = bytes_to_uint16(bytes[0x1a], bytes[0x1b]),
  };

end:
  return error;
}"
GargoyleSoftware-voip-client-ios-134091a/submodules/externals/ffmpeg/libavformat/utils.c	"Add a new stream to a media file. Can only be called in the read_header() function. If the flag AVFMTCTX_NOHEADER is in the format context, then new streams can be added in read_packet too."	2	"AVStream *av_new_stream(AVFormatContext *s, int id) {
  AVStream *st;
  int i;

#if FF_API_MAX_STREAMS
  if (s->nb_streams >= MAX_STREAMS) {
    av_log(s, AV_LOG_ERROR, ""Too many streams\n"");
    return NULL;
  }
#else
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;
#endif

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }

  st->codec = avcodec_alloc_context();
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->id = id;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  av_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  s->streams[s->nb_streams++] = st;
  return st;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_epi32(int __i3, int __i2, int __i1, int __i0) {
  return (__m128i)(__v4si){__i0, __i1, __i2, __i3};
}"
darktable-org-darktable-32fab21/src/iop/splittoning.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""authentic sepia""), self->op, self->version(),
      &(dt_iop_splittoning_params_t){26.0 / 360.0, 92.0 / 100.0, 40.0 / 360.0,
                                     92.0 / 100.0, 0.63, 0.0},
      sizeof(dt_iop_splittoning_params_t), 1);

  dt_gui_presets_add_generic(
      _(""authentic cyanotype""), self->op, self->version(),
      &(dt_iop_splittoning_params_t){220.0 / 360.0, 64.0 / 100.0, 220.0 / 360.0,
                                     64.0 / 100.0, 0.0, 5.22},
      sizeof(dt_iop_splittoning_params_t), 1);

  dt_gui_presets_add_generic(
      _(""authentic platinotype""), self->op, self->version(),
      &(dt_iop_splittoning_params_t){13.0 / 360.0, 42.0 / 100.0, 13.0 / 360.0,
                                     42.0 / 100.0, 100.0, 0.0},
      sizeof(dt_iop_splittoning_params_t), 1);

  dt_gui_presets_add_generic(
      _(""chocolate brown""), self->op, self->version(),
      &(dt_iop_splittoning_params_t){28.0 / 360.0, 39.0 / 100.0, 28.0 / 360.0,
                                     8.0 / 100.0, 0.60, 0.0},
      sizeof(dt_iop_splittoning_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
ADLINK-IST-opensplice-f7cff58/src/tools/idlpp/code/idl_genCorbaCCopyin.c	"The function generates for the provided basic type a copyIn statement. The identification of the source and destination elements must be provided by the caller. Basic type elements, apart from string types, are assigned immediately. Strings are duplicated calling c_stringNew."	2	"idl_basicCaseType(idl_scope scope, const char *name, idl_typeBasic typeBasic,
                  const char *from_id, const char *to_id) {
  c_char *cid;
  c_ulong maxlen;

  cid = idl_cId(name);

  switch (idl_typeBasicType(typeBasic)) {
  case idl_short:
  case idl_ushort:
  case idl_long:
  case idl_ulong:
  case idl_longlong:
  case idl_ulonglong:
  case idl_char:
  case idl_boolean:
  case idl_float:
  case idl_double:
  case idl_octet:
    DEBUG_INFO;
    fileOut(file, ""        %s%s = (%s)%s%s;\n"", to_id, cid,
            idl_typeFromTypeSpec(idl_typeSpec(typeBasic)), from_id, cid);
    break;
  case idl_string:
    maxlen = idl_typeBasicMaxlen(typeBasic);

    DEBUG_INFO;
    fileOut(file, ""#ifdef %s\n"", BOUNDSCHECK);
    fileOut(file, ""    if(%s%s){\n"", from_id, cid);

    if (maxlen != 0) {
      DEBUG_INFO;
      fileOut(file, ""        if(strlen(%s%s) <= %u){\n"", from_id, cid, maxlen);
      fileOut(file, ""            %s%s = c_stringNew_s(base, %s%s);\n"", to_id,
              cid, from_id, cid);
      fileOut(file, ""            if (%s%s == NULL) {\n"", to_id, cid);
      fileOut(file,
              ""                result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 4);
      fileOut(file, ""            }\n"");
      fileOut(file, ""        } else {\n"");
      fileOut(file, ""            "");
      idl_boundsCheckFail(CASE, scope, (idl_typeSpec)typeBasic, name);
      fileOut(file, ""            result = V_COPYIN_RESULT_INVALID;\n"");
      fileOut(file, ""        }\n"");
    } else {
      DEBUG_INFO;
      fileOut(file, ""        %s%s = c_stringNew_s(base, %s%s);\n"", to_id, cid,
              from_id, cid);
      fileOut(file, ""        if (%s%s == NULL) {\n"", to_id, cid);
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 3);
      fileOut(file, ""            result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      fileOut(file, ""        }\n"");
    }
    fileOut(file, ""    } else {\n"");
    fileOut(file, ""        "");
    idl_boundsCheckFailNull(CASE, scope, (idl_typeSpec)typeBasic, name);
    fileOut(file, ""        result = V_COPYIN_RESULT_INVALID;\n"");
    fileOut(file, ""    }\n"");
    fileOut(file, ""#else\n"");
    fileOut(file, ""    %s%s = c_stringNew_s(base, %s%s);\n"", to_id, cid,
            from_id, cid);
    fileOut(file, ""    if ((%s%s != NULL) && (%s%s == NULL)) {\n"", to_id, cid,
            to_id, cid);
    idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 2);
    fileOut(file, ""        result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
    fileOut(file, ""    }\n"");
    fileOut(file, ""#endif\n"");
    break;
  default:
    printf(""idl_basicCaseType: Unexpected basic type\n"");
    break;
  }
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/print.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){print,
                  'a',
                  ""print"",
                  ""print a credential in a human readable form"",
                  {""[--in file] [--type rsa-priv|ecdsa-priv|pub|x509|crl]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""type"", 't', 1, ""type of credential, default: x509""},
                  }});
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/AndroidAccessoryClassHost.c	"Starts Accessory Mode in the attached Android device. This function will validate the device's Android Open Accessory protocol version, send the configured property strings, and request a switch to Android Open Accessory mode."	1	"uint8_t
AOA_Host_StartAccessoryMode(USB_ClassInfo_AOA_Host_t *const AOAInterfaceInfo) {
  uint8_t ErrorCode;

  uint16_t AccessoryProtocol;
  if ((ErrorCode = AOA_Host_GetAccessoryProtocol(&AccessoryProtocol)) !=
      HOST_WAITERROR_Successful)
    return ErrorCode;

  if ((AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV1)) &&
      (AccessoryProtocol != CPU_TO_LE16(AOA_PROTOCOL_AccessoryV2)))
    return AOA_ERROR_LOGICAL_CMD_FAILED;

  for (uint8_t PropertyIndex = 0; PropertyIndex < AOA_STRING_TOTAL_STRINGS;
       PropertyIndex++) {
    if ((ErrorCode = AOA_Host_SendPropertyString(
             AOAInterfaceInfo, PropertyIndex)) != HOST_WAITERROR_Successful)
      return ErrorCode;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_VENDOR | REQREC_DEVICE),
      .bRequest = AOA_REQ_StartAccessoryMode,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MIDIHost/MIDIHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read in note on/off messages from the attached MIDI device and print it to the serial port. When the board joystick or buttons are pressed, note on/off messages are sent to the attached device."	1	"void MIDI_Host_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""MIDI Device Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    Pipe_SelectPipe(MIDI_DATA_IN_PIPE);

    if (Pipe_IsINReceived()) {
      MIDI_EventPacket_t MIDIEvent;

      Pipe_Read_Stream_LE(&MIDIEvent, sizeof(MIDIEvent));

      bool NoteOnEvent =
          ((MIDIEvent.Command & 0x0F) == (MIDI_COMMAND_NOTE_ON >> 4));
      bool NoteOffEvent =
          ((MIDIEvent.Command & 0x0F) == (MIDI_COMMAND_NOTE_OFF >> 4));

      if (NoteOnEvent || NoteOffEvent) {
        printf_P(PSTR(""MIDI Note %s - Channel %d, Pitch %d, Velocity %d\r\n""),
                 NoteOnEvent ? ""On"" : ""Off"", ((MIDIEvent.Data1 & 0x0F) + 1),
                 MIDIEvent.Data2, MIDIEvent.Data3);
      }

      if (!(Pipe_BytesInPipe()))
        Pipe_ClearIN();
    }

    Pipe_SelectPipe(MIDI_DATA_OUT_PIPE);

    if (Pipe_IsOUTReady()) {
      uint8_t MIDICommand = 0;
      uint8_t MIDIPitch;

      static uint8_t PrevJoystickStatus;
      uint8_t JoystickStatus = Joystick_GetStatus();
      uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

      uint8_t Channel =
          ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                   : MIDI_CHANNEL(1));

      if (JoystickChanges & JOY_LEFT) {
        MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                                   : MIDI_COMMAND_NOTE_OFF);
        MIDIPitch = 0x3C;
      }

      if (JoystickChanges & JOY_UP) {
        MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
        MIDIPitch = 0x3D;
      }

      if (JoystickChanges & JOY_RIGHT) {
        MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                    : MIDI_COMMAND_NOTE_OFF);
        MIDIPitch = 0x3E;
      }

      if (JoystickChanges & JOY_DOWN) {
        MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                                   : MIDI_COMMAND_NOTE_OFF);
        MIDIPitch = 0x3F;
      }

      if (JoystickChanges & JOY_PRESS) {
        MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                    : MIDI_COMMAND_NOTE_OFF);
        MIDIPitch = 0x3B;
      }

      if (MIDICommand) {
        MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
            .CableNumber = 0,
            .Command = (MIDICommand >> 4),

            .Data1 = MIDICommand | Channel,
            .Data2 = MIDIPitch,
            .Data3 = MIDI_STANDARD_VELOCITY,
        };

        Pipe_Write_Stream_LE(&MIDIEvent, sizeof(MIDIEvent));

        Pipe_ClearOUT();
      }

      PrevJoystickStatus = JoystickStatus;
    }

    break;
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11,
             char __b10, char __b9, char __b8, char __b7, char __b6, char __b5,
             char __b4, char __b3, char __b2, char __b1, char __b0) {
  return (__m128i)(__v16qi){__b0,  __b1,  __b2,  __b3, __b4,  __b5,
                            __b6,  __b7,  __b8,  __b9, __b10, __b11,
                            __b12, __b13, __b14, __b15};
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavutil/mathematics.c	Add a value to a timestamp. This function gurantees that when the same value is repeatly added that no accumulation of rounding errors occurs.	2	"int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb,
                      int64_t inc) {
  int64_t m, d;

  if (inc != 1)
    inc_tb = av_mul_q(inc_tb, (AVRational){inc, 1});

  m = inc_tb.num * (int64_t)ts_tb.den;
  d = inc_tb.den * (int64_t)ts_tb.num;

  if (m % d == 0)
    return ts + m / d;
  if (m < d)
    return ts;

  {
    int64_t old = av_rescale_q(ts, ts_tb, inc_tb);
    int64_t old_ts = av_rescale_q(old, inc_tb, ts_tb);
    return av_rescale_q(old + 1, inc_tb, ts_tb) + (ts - old_ts);
  }
}"
fanglingsu-vimb-beba6b1/src/ex.c	Called when the command mode is left.	2	"void ex_leave(Client *c) {
  completion_clean(c);
  hints_clear(c);
  if (c->config.incsearch) {
    command_search(c, &((Arg){0, NULL}), FALSE);
  }
}"
boazsegev-iodine-b6bdf50/ext/iodine/iodine_connection.c	Creates a new connection object.	2	"VALUE iodine_connection_new(iodine_connection_s args) {
  VALUE connection = IodineCaller.call(ConnectionKlass, new_id);
  if (connection == Qnil) {
    return Qnil;
  }
  IodineStore.add(connection);
  iodine_connection_data_s *data = iodine_connection_ruby2C(connection);
  if (data == NULL) {
    FIO_LOG_ERROR(""(iodine) internal error, connection object has no C data!"");
    return Qnil;
  }
  *data = (iodine_connection_data_s){
      .info = args,
      .subscriptions = FIO_SET_INIT,
      .ref = 1,
      .answers_on_open = (rb_respond_to(args.handler, on_open_id) != 0),
      .answers_on_message = (rb_respond_to(args.handler, on_message_id) != 0),
      .answers_ping = (rb_respond_to(args.handler, ping_id) != 0),
      .answers_on_drained = (rb_respond_to(args.handler, on_drained_id) != 0),
      .answers_on_shutdown = (rb_respond_to(args.handler, on_shutdown_id) != 0),
      .answers_on_close = (rb_respond_to(args.handler, on_close_id) != 0),
      .lock = FIO_LOCK_INIT,
  };
  return connection;
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavcodec/tiffenc.c	Put n values to buffer	2	"static void tnput(uint8_t **p, int n, const uint8_t *val, enum TiffTypes type,
                  int flip) {
  int i;
#if HAVE_BIGENDIAN
  flip ^= ((int[]){0, 0, 0, 1, 3, 3})[type];
#endif
  for (i = 0; i < n * type_sizes2[type]; i++)
    *(*p)++ = val[i ^ flip];
}"
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	Finds a row in the truthtable where bodyManifest is TRUE and the indexOrKey equals 'key'.	2	"getTruthTableExtent(TruthTableEntry *ttentry, int key) {
  for (int i = 0; ttentry[i].indexOrKey != T_INVALID; i++) {
    if (ttentry[i].bodyManifest && ttentry[i].indexOrKey == key) {
      return ttentry[i].extent;
    }
  }
  return (TlvExtent){0, 0};
}"
cisco-system-traffic-generator-trex-core-d48fc67/src/dpdk/drivers/net/mlx5/mlx5_rxtx_vec_neon.h	Send multi-segmented packets until it encounters a single segment packet in the pkts list.	2	"txq_scatter_v(struct mlx5_txq_data *txq, struct rte_mbuf **pkts,
              uint16_t pkts_n) {
  uint16_t elts_head = txq->elts_head;
  const uint16_t elts_n = 1 << txq->elts_n;
  const uint16_t elts_m = elts_n - 1;
  const uint16_t wq_n = 1 << txq->wqe_n;
  const uint16_t wq_mask = wq_n - 1;
  const unsigned int nb_dword_per_wqebb = MLX5_WQE_SIZE / MLX5_WQE_DWORD_SIZE;
  const unsigned int nb_dword_in_hdr =
      sizeof(struct mlx5_wqe) / MLX5_WQE_DWORD_SIZE;
  unsigned int n;
  volatile struct mlx5_wqe *wqe = NULL;

  assert(elts_n > pkts_n);
  mlx5_tx_complete(txq);
  if (unlikely(!pkts_n))
    return 0;
  for (n = 0; n < pkts_n; ++n) {
    struct rte_mbuf *buf = pkts[n];
    unsigned int segs_n = buf->nb_segs;
    unsigned int ds = nb_dword_in_hdr;
    unsigned int len = PKT_LEN(buf);
    uint16_t wqe_ci = txq->wqe_ci;
    const uint8x16_t ctrl_shuf_m = {3,  2,  1, 0, 7,  6,  5,  4,
                                    11, 10, 9, 8, 12, 13, 14, 15};
    uint8_t cs_flags;
    uint16_t max_elts;
    uint16_t max_wqe;
    uint8x16_t *t_wqe;
    uint8_t *dseg;
    uint8x16_t ctrl;

    assert(segs_n);
    max_elts = elts_n - (elts_head - txq->elts_tail);
    max_wqe = wq_n - (txq->wqe_ci - txq->wqe_pi);

    if (segs_n == 1 || max_elts < segs_n || max_wqe < 2)
      break;
    wqe = &((volatile struct mlx5_wqe64 *)txq->wqes)[wqe_ci & wq_mask].hdr;
    cs_flags = txq_ol_cksum_to_cs(buf);

    t_wqe = (uint8x16_t *)wqe;
    dseg = (uint8_t *)(wqe + 1);
    do {
      if (!(ds++ % nb_dword_per_wqebb)) {
        dseg = (uint8_t *)&(
            (volatile struct mlx5_wqe64 *)txq->wqes)[++wqe_ci & wq_mask];
      }
      txq_wr_dseg_v(txq, dseg, &buf, 1);
      dseg += MLX5_WQE_DWORD_SIZE;
      (*txq->elts)[elts_head++ & elts_m] = buf;
      buf = buf->next;
    } while (--segs_n);
    ++wqe_ci;

    ctrl = vreinterpretq_u8_u32((uint32x4_t){
        MLX5_OPC_MOD_MPW << 24 | txq->wqe_ci << 8 | MLX5_OPCODE_TSO,
        txq->qp_num_8s | ds, 0, 0});
    ctrl = vqtbl1q_u8(ctrl, ctrl_shuf_m);
    vst1q_u8((void *)t_wqe, ctrl);

    vst1q_u16(
        (void *)(t_wqe + 1),
        ((uint16x8_t){0, 0, cs_flags, rte_cpu_to_be_16(len), 0, 0, 0, 0}));
    txq->wqe_ci = wqe_ci;
  }
  if (!n)
    return 0;
  txq->elts_comp += (uint16_t)(elts_head - txq->elts_head);
  txq->elts_head = elts_head;
  if (txq->elts_comp >= MLX5_TX_COMP_THRESH) {

    assert((1u << txq->cqe_n) - (txq->cq_pi++ - txq->cq_ci));
    wqe->ctrl[2] = rte_cpu_to_be_32(8);
    wqe->ctrl[3] = txq->elts_head;
    txq->elts_comp = 0;
  }
#ifdef MLX5_PMD_SOFT_COUNTERS
  txq->stats.opackets += n;
#endif
  mlx5_tx_dbrec(txq, wqe);
  return n;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/LowLevel/Host.c	"Convenience function. This routine sends a SetConfiguration standard request to the attached device, with the given configuration index. This can be used to easily set the device configuration without creating and sending the request manually."	2	"uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_SetConfiguration,
      .wValue = ConfigNumber,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command."	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MSInterfaceInfo->Config.DataINPipeNumber);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MSInterfaceInfo->Config.DataOUTPipeNumber);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  return HOST_SENDCONTROL_Successful;
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavcodec/utils.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  AVPacket *pkt = avctx->internal->pkt;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
      {AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
       AV_FRAME_DATA_MASTERING_DISPLAY_METADATA},
  };

  if (pkt) {
    frame->pts = pkt->pts;
#if FF_API_PKT_PTS
    FF_DISABLE_DEPRECATION_WARNINGS
    frame->pkt_pts = pkt->pts;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif
    av_frame_set_pkt_pos(frame, pkt->pos);
    av_frame_set_pkt_duration(frame, pkt->duration);
    av_frame_set_pkt_size(frame, pkt->size);

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
    add_metadata_from_side_data(pkt, frame);

    if (pkt->flags & AV_PKT_FLAG_DISCARD) {
      frame->flags |= AV_FRAME_FLAG_DISCARD;
    } else {
      frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
    }
  } else {
    frame->pts = AV_NOPTS_VALUE;
#if FF_API_PKT_PTS
    FF_DISABLE_DEPRECATION_WARNINGS
    frame->pkt_pts = AV_NOPTS_VALUE;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif
    av_frame_set_pkt_pos(frame, -1);
    av_frame_set_pkt_duration(frame, 0);
    av_frame_set_pkt_size(frame, -1);
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
    av_frame_set_colorspace(frame, avctx->colorspace);
  if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
    av_frame_set_color_range(frame, avctx->color_range);
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    av_frame_set_channels(frame, avctx->channels);
    break;
  }
  return 0;
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabButton request. Creates a grab for the client's ClientPointer and adds it as a passive grab to the list.	2	"ProcGrabButton(ClientPtr client) {
  WindowPtr pWin, confineTo;

  REQUEST(xGrabButtonReq);
  CursorPtr cursor;
  GrabPtr grab;
  DeviceIntPtr ptr, modifierDevice;
  Mask access_mode = DixGrabAccess;
  GrabMask mask;
  GrabParameters param;
  int rc;

  REQUEST_SIZE_MATCH(xGrabButtonReq);
  UpdateCurrentTime();
  if ((stuff->pointerMode != GrabModeSync) &&
      (stuff->pointerMode != GrabModeAsync)) {
    client->errorValue = stuff->pointerMode;
    return BadValue;
  }
  if ((stuff->keyboardMode != GrabModeSync) &&
      (stuff->keyboardMode != GrabModeAsync)) {
    client->errorValue = stuff->keyboardMode;
    return BadValue;
  }
  if ((stuff->modifiers != AnyModifier) &&
      (stuff->modifiers & ~AllModifiersMask)) {
    client->errorValue = stuff->modifiers;
    return BadValue;
  }
  if ((stuff->ownerEvents != xFalse) && (stuff->ownerEvents != xTrue)) {
    client->errorValue = stuff->ownerEvents;
    return BadValue;
  }
  if (stuff->eventMask & ~PointerGrabMask) {
    client->errorValue = stuff->eventMask;
    return BadValue;
  }
  rc = dixLookupWindow(&pWin, stuff->grabWindow, client, DixSetAttrAccess);
  if (rc != Success)
    return rc;
  if (stuff->confineTo == None)
    confineTo = NullWindow;
  else {
    rc =
        dixLookupWindow(&confineTo, stuff->confineTo, client, DixSetAttrAccess);
    if (rc != Success)
      return rc;
  }
  if (stuff->cursor == None)
    cursor = NullCursor;
  else {
    rc = dixLookupResourceByType((void **)&cursor, stuff->cursor, RT_CURSOR,
                                 client, DixUseAccess);
    if (rc != Success) {
      client->errorValue = stuff->cursor;
      return rc;
    }
    access_mode |= DixForceAccess;
  }

  ptr = PickPointer(client);
  modifierDevice = GetMaster(ptr, MASTER_KEYBOARD);
  if (stuff->pointerMode == GrabModeSync || stuff->keyboardMode == GrabModeSync)
    access_mode |= DixFreezeAccess;
  rc = XaceHook(XACE_DEVICE_ACCESS, client, ptr, access_mode);
  if (rc != Success)
    return rc;

  param = (GrabParameters){.grabtype = CORE,
                           .ownerEvents = stuff->ownerEvents,
                           .this_device_mode = stuff->keyboardMode,
                           .other_devices_mode = stuff->pointerMode,
                           .modifiers = stuff->modifiers};

  mask.core = stuff->eventMask;

  grab = CreateGrab(client->index, ptr, modifierDevice, pWin, CORE, &mask,
                    &param, ButtonPress, stuff->button, confineTo, cursor);
  if (!grab)
    return BadAlloc;
  return AddPassiveGrabToList(client, grab);
}"
Benoit37000-proxmark3-iceman-91c7a7c/client/cmdhf15.c	"Commandline handling: HF15 CMD WRITE Writes a single Block - might run into timeout, even when successful"	2	"int CmdHF15CmdWrite(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum, temp;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char *cmd2;

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(
        ""Usage:  hf 15 cmd write    [options] <uid|s|u|*> <page#> <hexdata>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""               -o        set OPTION Flag (needed for TI)"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           page#:        page number 0-255"");
    PrintAndLog(""           hexdata:      data to be written eg AA BB CC DD"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15_CMD_WRITE}, 1);
  reqlen = c.arg[0];

  cmd2 = cmd;
  while (*cmd2 != ' ' && *cmd2 != '\t' && *cmd2)
    cmd2++;
  *cmd2 = 0;
  cmd2++;

  pagenum = strtol(cmd, NULL, 0);

  req[reqlen++] = (uint8_t)pagenum;

  while (cmd2[0] && cmd2[1]) {
    if (*cmd2 == ' ') {
      cmd2++;
      continue;
    }
    sscanf((char[]){cmd2[0], cmd2[1], 0}, ""%X"", &temp);
    req[reqlen++] = temp & 0xff;
    cmd2 += 2;
  }

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 2000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15_RES_ERROR)) {
        PrintAndLog(""OK"");
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[1], TagErrorStr(recv[1]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""timeout: no answer - data may be written anyway"");
  }

  return 0;
}"
bskari-sqlassie-8e80323/src/tests/testMySqlConstants.cpp	Tests that my function to convert MySQL regular expressions into Perl regular expressions that I can use with Boost's regular expression library works.	2	"void testConvertRegex() {
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""abc_de"") == ""^abc.de$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""%ab_a"") == ""^.*ab.a$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""abc_de"") == ""^abc.de$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""_%%__"") == ""^..*.*..$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""%\\_%"") == ""^.*_.*$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""\\%_\\%"") == ""^%.%$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex("".*"") == ""^\\.\\*$"");
  BOOST_CHECK(MySqlConstants::mySqlRegexToPerlRegex(""%\\%%.%*%"") ==
              ""^.*%.*\\..*\\*.*$"");
  BOOST_CHECK(
      MySqlConstants::mySqlRegexToPerlRegex(""(a[^b]){2,3}|(c|d|[^e]+)*"") ==
      ""^\\(a\\[\\^b\\]\\)\\{2\\,3\\}\\|\\(c\\|d\\|\\[\\^e\\]\\+\\)\\*$"");
  BOOST_CHECK(
      MySqlConstants::mySqlRegexToPerlRegex(""ab_cd\\_sf.e?kl%l(k|)f*j%e\\%"") ==
      ""^ab.cd_sf\\.e\\?kl.*l\\(k\\|\\)f\\*j.*e%$"");
}"
TheRyuu-ffdshow-a648046/src/ffmpeg/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
#define LOG2 0.69314718055994530941723212145817656807550013436025
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (isinf(d))
    return (AVRational){d < 0 ? -1 : 1, 0};
  exponent = FFMAX((int)(log(fabs(d) + 1e-20) / LOG2), 0);
  den = 1LL << (61 - exponent);
  av_reduce(&a.num, &a.den, (int64_t)(d * den + 0.5), den, max);

  return a;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	"Sets the idle period for the attached HID device to the specified interval. The HID idle period determines the rate at which the device should send a report, when no state changes have occurred; i.e. on HID keyboards, this sets the hardware key repeat interval."	2	"uint8_t HID_Host_SetIdlePeriod(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo,
                               const uint16_t MS) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetIdle,
      .wValue = ((MS << 6) & 0xFF00),
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a GET MAX LUN control request to the attached device, retrieving the index of the highest LUN (Logical UNit, a logical drive) in the device. This value can then be used in the other functions of the Mass Storage Host mode Class driver to address a specific LUN within the device."	1	"uint8_t MS_Host_GetMaxLUN(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {
    *MaxLUNIndex = 0;
    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/finddlg.c	Popup a dialog to ask for a city to find.	2	"void popup_find_dialog(void) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL;
  utf8_str *pstr;
  char cBuf[128];
  int h = 0, n = 0, w = 0, units_h = 0;
  struct player *owner = NULL;
  struct tile *original;
  int window_x = 0, window_y = 0;
  bool mouse = (Main.event.type == SDL_MOUSEBUTTONDOWN);
  SDL_Rect area;

  players_iterate(pplayer) {
    h = city_list_size(pplayer->cities);
    if (h > 0) {
      break;
    }
  }
  players_iterate_end;

  if (pFind_City_Dlg && !h) {
    return;
  }

  original = canvas_pos_to_tile(Main.map->w / 2, Main.map->h / 2);

  pFind_City_Dlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pstr = create_utf8_from_char(_(""Find City""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = find_city_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_TERRAIN_ADV_DLG_WINDOW, pWindow);
  pFind_City_Dlg->pEndWidgetList = pWindow;

  area = pWindow->area;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND |
                              WF_FREE_DATA);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  area.w = MAX(area.w, pBuf->size.w + adj_size(10));
  pBuf->action = exit_find_city_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;
  pBuf->data.cont = fc_calloc(1, sizeof(struct CONTAINER));
  pBuf->data.cont->id0 = index_to_map_pos_x(tile_index(original));
  pBuf->data.cont->id1 = index_to_map_pos_y(tile_index(original));

  add_to_gui_list(ID_TERRAIN_ADV_DLG_EXIT_BUTTON, pBuf);

  players_iterate(pPlayer) {
    city_list_iterate(pPlayer->cities, pCity) {
      fc_snprintf(cBuf, sizeof(cBuf), ""%s (%d)"", city_name_get(pCity),
                  city_size_get(pCity));

      pstr = create_utf8_from_char(cBuf, adj_font(10));
      pstr->style |= (TTF_STYLE_BOLD | SF_CENTER);

      if (!player_owns_city(owner, pCity)) {
        pLogo = get_nation_flag_surface(nation_of_player(city_owner(pCity)));
        pLogo = crop_visible_part_from_surface(pLogo);
      }

      pBuf = create_iconlabel(
          pLogo, pWindow->dst, pstr,
          (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));

      if (!player_owns_city(owner, pCity)) {
        set_wflag(pBuf, WF_FREE_THEME);
        owner = city_owner(pCity);
      }

      pBuf->string_utf8->style &= ~SF_CENTER;
      pBuf->string_utf8->fgcol =
          *(get_player_color(tileset, city_owner(pCity))->color);
      pBuf->string_utf8->bgcol = (SDL_Color){0, 0, 0, 0};

      pBuf->data.city = pCity;

      pBuf->action = find_city_callback;
      set_wstate(pBuf, FC_WS_NORMAL);

      add_to_gui_list(ID_LABEL, pBuf);

      area.w = MAX(area.w, pBuf->size.w);
      area.h += pBuf->size.h;

      if (n > 19) {
        set_wflag(pBuf, WF_HIDDEN);
      }

      n++;
    }
    city_list_iterate_end;
  }
  players_iterate_end;

  pFind_City_Dlg->pBeginWidgetList = pBuf;
  pFind_City_Dlg->pBeginActiveWidgetList = pFind_City_Dlg->pBeginWidgetList;
  pFind_City_Dlg->pEndActiveWidgetList = pWindow->prev->prev;
  pFind_City_Dlg->pActiveWidgetList = pFind_City_Dlg->pEndActiveWidgetList;

  if (n > 20) {
    units_h = create_vertical_scrollbar(pFind_City_Dlg, 1, 20, TRUE, TRUE);
    pFind_City_Dlg->pScroll->count = n;

    n = units_h;
    area.w += n;

    units_h = 20 * pBuf->size.h + adj_size(2);

  } else {
    units_h = area.h;
  }

  area.h = units_h;

  resize_window(pWindow, NULL, NULL,
                (pWindow->size.w - pWindow->area.w) + area.w,
                (pWindow->size.h - pWindow->area.h) + area.h);

  area = pWindow->area;

  if (!mouse) {
    window_x = adj_size(10);
    window_y = (main_window_height() - pWindow->size.h) / 2;
  } else {
    window_x = (Main.event.motion.x + pWindow->size.w + adj_size(10) <
                main_window_width())
                   ? (Main.event.motion.x + adj_size(10))
                   : (main_window_width() - pWindow->size.w - adj_size(10));
    window_y = (Main.event.motion.y - adj_size(2) + pWindow->size.h <
                main_window_height())
                   ? (Main.event.motion.y - adj_size(2))
                   : (main_window_height() - pWindow->size.h - adj_size(10));
  }

  widget_set_position(pWindow, window_x, window_y);

  w = area.w;

  if (pFind_City_Dlg->pScroll) {
    w -= n;
  }

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  pBuf = pBuf->prev;
  setup_vertical_widgets_position(1, area.x, area.y, w, 0,
                                  pFind_City_Dlg->pBeginActiveWidgetList, pBuf);

  if (pFind_City_Dlg->pScroll) {
    setup_vertical_scrollbar_area(pFind_City_Dlg->pScroll, area.x + area.w,
                                  area.y, area.h, TRUE);
  }

  redraw_group(pFind_City_Dlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);

  flush_dirty();
}"
levex-kernel-qemu-pci-31fc935/qemu/block.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  bool is_write) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .is_write = is_write,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server ready for SNI, and the client sends a known name. The SNI callback should respond with the matching credential. The client inquires the peer name and verifies it matches the desired credential."	3	"init_sni1(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;

  major_status = gss_set_sec_context_option(&minor_status, &accept_context,
                                            GSS_SNI_CREDENTIALS,
                                            &(gss_buffer_desc){
                                                .value = creds,
                                                .length = sizeof(creds),
                                            });
  if (major_status != GSS_S_COMPLETE) {
    result = false;

    goto fail;
  }

  major_status =
      gss_import_name(&minor_status,
                      &(gss_buffer_desc){
                          .value = ""dns1.example.globus.org"",
                          .length = strlen(""dns1.example.globus.org""),
                      },
                      GLOBUS_GSS_C_NT_HOST_IP, &target_name);

  if (major_status != GSS_S_COMPLETE) {
    result = false;
    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    major_status =
        gss_inquire_context(&minor_status, init_context, NULL, &peer_name, NULL,
                            NULL, NULL, NULL, NULL);
    if (major_status != GSS_S_COMPLETE) {
      result = false;

      goto fail;
    }

    major_status =
        gss_compare_name(&minor_status, target_name, peer_name, &name_equal);

    if (major_status != GSS_S_COMPLETE) {
      result = false;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/ClassDriver/MIDIHost/MIDIHost.c	"Checks for changes in the position of the board joystick, sending strings to the host upon each change through the first of the CDC interfaces. Checks for changes in the position of the board joystick, sending MIDI events to the host upon each change. Checks for changes in the position of the board joystick, sending strings to the host upon each change."	0	"void CheckJoystickMovement(void) {
  static uint8_t PrevJoystickStatus;

  uint8_t MIDICommand = 0;
  uint8_t MIDIPitch;

  uint8_t JoystickStatus = Joystick_GetStatus();
  uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

  uint8_t Channel = ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                             : MIDI_CHANNEL(1));

  if (JoystickChanges & JOY_LEFT) {
    MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3C;
  }

  if (JoystickChanges & JOY_UP) {
    MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                             : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3D;
  }

  if (JoystickChanges & JOY_RIGHT) {
    MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3E;
  }

  if (JoystickChanges & JOY_DOWN) {
    MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3F;
  }

  if (JoystickChanges & JOY_PRESS) {
    MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3B;
  }

  if (MIDICommand) {
    MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
        .CableNumber = 0,
        .Command = (MIDICommand >> 4),

        .Data1 = MIDICommand | Channel,
        .Data2 = MIDIPitch,
        .Data3 = MIDI_STANDARD_VELOCITY,
    };

    MIDI_Host_SendEventPacket(&Keyboard_MIDI_Interface, &MIDIEvent);
    MIDI_Host_Flush(&Keyboard_MIDI_Interface);
  }

  PrevJoystickStatus = JoystickStatus;
}"
ventanium-ventanium-e769f5e/src/vtm/sys/unix/net/socket_listener_epoll.c	Interrupts the listener if he is blocked in waiting for events.	2	"int vtm_socket_listener_interrupt(vtm_socket_listener *li) {
  write(li->cfd, (uint64_t[]){1}, sizeof(uint64_t));
  return VTM_OK;
}"
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the cumulative RefCounts statistics for the slabs in this allocator.	2	"RefCountsStatistics getRefCountsStatistics(const BlockAllocator *allocator) {
  const AtomicRefCountStatistics *atoms = &allocator->refCountStatistics;
  return (RefCountsStatistics){
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
  };
}"
yagu0-cgds-71e16e3/src/Heap.c	Copy constructor (works well if items do not have allocated sub-pointers).	2	"Heap *heap_copy(Heap *heap) {
  Heap *heapCopy = _heap_new(heap->dataSize, heap->hType, heap->arity);

  heapCopy->array->size = heap->array->size;
  heapCopy->array->capacity = heap->array->capacity;
  heapCopy->array->datas =
      (void **)safe_malloc(heap->array->capacity * sizeof(void *));
  for (UInt i = 0; i < heap->array->size; i++) {
    heapCopy->array->datas[i] = safe_malloc(sizeof(ItemValue));
    ItemValue itemValueCopy =
        (ItemValue){.item = safe_malloc(heap->dataSize),
                    .value = ((ItemValue *)(heap->array->datas[i]))->value};
    memcpy(itemValueCopy.item, ((ItemValue *)(heap->array->datas[i]))->item,
           heap->dataSize);
    memcpy(heapCopy->array->datas[i], &itemValueCopy, sizeof(ItemValue));
  }
  return heapCopy;
}"
dm-vdo-kvdo-8df6805/uds/bufferedWriter.c	Make a new buffered writer.	2	"int makeBufferedWriter(IORegion *region, size_t bufSize,
                       BufferedWriter **writerPtr) {
  int result = UDS_SUCCESS;

  if (bufSize == 0) {
    result = getRegionBestBufferSize(region, &bufSize);
    if (result != UDS_SUCCESS) {
      return result;
    }
  } else {
    size_t blockSize;
    result = getRegionBlockSize(region, &blockSize);
    if (result != UDS_SUCCESS) {
      return result;
    }
    if (bufSize % blockSize != 0) {
      return logErrorWithStringError(UDS_INVALID_ARGUMENT,
                                     ""buffer size must be a multiple of %zu"",
                                     blockSize);
    }
  }

  BufferedWriter *writer;
  result = ALLOCATE(1, BufferedWriter, ""buffered writer"", &writer);
  if (result != UDS_SUCCESS) {
    return result;
  }

  *writer = (BufferedWriter){
      .bw_region = region,
      .bw_size = bufSize,
      .bw_pos = 0,
      .bw_err = UDS_SUCCESS,
      .bw_used = false,
      .bw_close = false,
  };

  result = ALLOCATE_IO_ALIGNED(bufSize, char, ""buffer writer buffer"",
                               &writer->bw_buf);
  if (result != UDS_SUCCESS) {
    FREE(writer);
    return result;
  }

  writer->bw_ptr = writer->bw_buf;
  *writerPtr = writer;
  return UDS_SUCCESS;
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/ffplay.c	"Decode one audio frame and return its uncompressed size. The processed audio frame is decoded, converted if required, and stored in is->audio_buf, with size in bytes given by the return value."	2	"static int audio_decode_frame(VideoState *is) {
  AVPacket *pkt_temp = &is->audio_pkt_temp;
  AVPacket *pkt = &is->audio_pkt;
  AVCodecContext *dec = is->audio_st->codec;
  int len1, data_size, resampled_data_size;
  int64_t dec_channel_layout;
  int got_frame;
  av_unused double audio_clock0;
  int wanted_nb_samples;
  AVRational tb;
  int ret;
  int reconfigure;

  for (;;) {

    while (pkt_temp->stream_index != -1 || is->audio_buf_frames_pending) {
      if (!is->frame) {
        if (!(is->frame = av_frame_alloc()))
          return AVERROR(ENOMEM);
      } else {
        av_frame_unref(is->frame);
      }

      if (is->audioq.serial != is->audio_pkt_temp_serial)
        break;

      if (is->paused)
        return -1;

      if (!is->audio_buf_frames_pending) {
        len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);
        if (len1 < 0) {

          pkt_temp->size = 0;
          break;
        }

        pkt_temp->dts = pkt_temp->pts = AV_NOPTS_VALUE;
        pkt_temp->data += len1;
        pkt_temp->size -= len1;
        if (pkt_temp->data && pkt_temp->size <= 0 ||
            !pkt_temp->data && !got_frame)
          pkt_temp->stream_index = -1;
        if (!pkt_temp->data && !got_frame)
          is->audio_finished = is->audio_pkt_temp_serial;

        if (!got_frame)
          continue;

        tb = (AVRational){1, is->frame->sample_rate};
        if (is->frame->pts != AV_NOPTS_VALUE)
          is->frame->pts = av_rescale_q(is->frame->pts, dec->time_base, tb);
        else if (is->frame->pkt_pts != AV_NOPTS_VALUE)
          is->frame->pts =
              av_rescale_q(is->frame->pkt_pts, is->audio_st->time_base, tb);
        else if (is->audio_frame_next_pts != AV_NOPTS_VALUE)
#if CONFIG_AVFILTER
          is->frame->pts =
              av_rescale_q(is->audio_frame_next_pts,
                           (AVRational){1, is->audio_filter_src.freq}, tb);
#else
          is->frame->pts =
              av_rescale_q(is->audio_frame_next_pts,
                           (AVRational){1, is->audio_src.freq}, tb);
#endif

        if (is->frame->pts != AV_NOPTS_VALUE)
          is->audio_frame_next_pts = is->frame->pts + is->frame->nb_samples;

#if CONFIG_AVFILTER
        dec_channel_layout = get_valid_channel_layout(
            is->frame->channel_layout, av_frame_get_channels(is->frame));

        reconfigure =
            cmp_audio_fmts(is->audio_filter_src.fmt,
                           is->audio_filter_src.channels, is->frame->format,
                           av_frame_get_channels(is->frame)) ||
            is->audio_filter_src.channel_layout != dec_channel_layout ||
            is->audio_filter_src.freq != is->frame->sample_rate ||
            is->audio_pkt_temp_serial != is->audio_last_serial;

        if (reconfigure) {
          char buf1[1024], buf2[1024];
          av_get_channel_layout_string(buf1, sizeof(buf1), -1,
                                       is->audio_filter_src.channel_layout);
          av_get_channel_layout_string(buf2, sizeof(buf2), -1,
                                       dec_channel_layout);
          av_log(NULL, AV_LOG_DEBUG,
                 ""Audio frame changed from rate:%d ch:%d fmt:%s layout:%s ""
                 ""serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n"",
                 is->audio_filter_src.freq, is->audio_filter_src.channels,
                 av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1,
                 is->audio_last_serial, is->frame->sample_rate,
                 av_frame_get_channels(is->frame),
                 av_get_sample_fmt_name(is->frame->format), buf2,
                 is->audio_pkt_temp_serial);

          is->audio_filter_src.fmt = is->frame->format;
          is->audio_filter_src.channels = av_frame_get_channels(is->frame);
          is->audio_filter_src.channel_layout = dec_channel_layout;
          is->audio_filter_src.freq = is->frame->sample_rate;
          is->audio_last_serial = is->audio_pkt_temp_serial;

          if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
            return ret;
        }

        if ((ret = av_buffersrc_add_frame(is->in_audio_filter, is->frame)) < 0)
          return ret;
#endif
      }
#if CONFIG_AVFILTER
      if ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, is->frame,
                                               0)) < 0) {
        if (ret == AVERROR(EAGAIN)) {
          is->audio_buf_frames_pending = 0;
          continue;
        }
        if (ret == AVERROR_EOF)
          is->audio_finished = is->audio_pkt_temp_serial;
        return ret;
      }
      is->audio_buf_frames_pending = 1;
      tb = is->out_audio_filter->inputs[0]->time_base;
#endif

      data_size = av_samples_get_buffer_size(
          NULL, av_frame_get_channels(is->frame), is->frame->nb_samples,
          is->frame->format, 1);

      dec_channel_layout =
          (is->frame->channel_layout &&
           av_frame_get_channels(is->frame) ==
               av_get_channel_layout_nb_channels(is->frame->channel_layout))
              ? is->frame->channel_layout
              : av_get_default_channel_layout(av_frame_get_channels(is->frame));
      wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);

      if (is->frame->format != is->audio_src.fmt ||
          dec_channel_layout != is->audio_src.channel_layout ||
          is->frame->sample_rate != is->audio_src.freq ||
          (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {
        swr_free(&is->swr_ctx);
        is->swr_ctx = swr_alloc_set_opts(NULL, is->audio_tgt.channel_layout,
                                         is->audio_tgt.fmt, is->audio_tgt.freq,
                                         dec_channel_layout, is->frame->format,
                                         is->frame->sample_rate, 0, NULL);
        if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {
          av_log(NULL, AV_LOG_ERROR,
                 ""Cannot create sample rate converter for conversion of %d Hz ""
                 ""%s %d channels to %d Hz %s %d channels!\n"",
                 is->frame->sample_rate,
                 av_get_sample_fmt_name(is->frame->format),
                 av_frame_get_channels(is->frame), is->audio_tgt.freq,
                 av_get_sample_fmt_name(is->audio_tgt.fmt),
                 is->audio_tgt.channels);
          break;
        }
        is->audio_src.channel_layout = dec_channel_layout;
        is->audio_src.channels = av_frame_get_channels(is->frame);
        is->audio_src.freq = is->frame->sample_rate;
        is->audio_src.fmt = is->frame->format;
      }

      if (is->swr_ctx) {
        const uint8_t **in = (const uint8_t **)is->frame->extended_data;
        uint8_t **out = &is->audio_buf1;
        int out_count = (int64_t)wanted_nb_samples * is->audio_tgt.freq /
                            is->frame->sample_rate +
                        256;
        int out_size = av_samples_get_buffer_size(
            NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
        int len2;
        if (out_size < 0) {
          av_log(NULL, AV_LOG_ERROR, ""av_samples_get_buffer_size() failed\n"");
          break;
        }
        if (wanted_nb_samples != is->frame->nb_samples) {
          if (swr_set_compensation(is->swr_ctx,
                                   (wanted_nb_samples - is->frame->nb_samples) *
                                       is->audio_tgt.freq /
                                       is->frame->sample_rate,
                                   wanted_nb_samples * is->audio_tgt.freq /
                                       is->frame->sample_rate) < 0) {
            av_log(NULL, AV_LOG_ERROR, ""swr_set_compensation() failed\n"");
            break;
          }
        }
        av_fast_malloc(&is->audio_buf1, &is->audio_buf1_size, out_size);
        if (!is->audio_buf1)
          return AVERROR(ENOMEM);
        len2 =
            swr_convert(is->swr_ctx, out, out_count, in, is->frame->nb_samples);
        if (len2 < 0) {
          av_log(NULL, AV_LOG_ERROR, ""swr_convert() failed\n"");
          break;
        }
        if (len2 == out_count) {
          av_log(NULL, AV_LOG_WARNING, ""audio buffer is probably too small\n"");
          swr_init(is->swr_ctx);
        }
        is->audio_buf = is->audio_buf1;
        resampled_data_size = len2 * is->audio_tgt.channels *
                              av_get_bytes_per_sample(is->audio_tgt.fmt);
      } else {
        is->audio_buf = is->frame->data[0];
        resampled_data_size = data_size;
      }

      audio_clock0 = is->audio_clock;

      if (is->frame->pts != AV_NOPTS_VALUE)
        is->audio_clock =
            is->frame->pts * av_q2d(tb) +
            (double)is->frame->nb_samples / is->frame->sample_rate;
      else
        is->audio_clock = NAN;
      is->audio_clock_serial = is->audio_pkt_temp_serial;
#ifdef DEBUG
      {
        static double last_clock;
        printf(""audio: delay=%0.3f clock=%0.3f clock0=%0.3f\n"",
               is->audio_clock - last_clock, is->audio_clock, audio_clock0);
        last_clock = is->audio_clock;
      }
#endif
      return resampled_data_size;
    }

    if (pkt->data)
      av_free_packet(pkt);
    memset(pkt_temp, 0, sizeof(*pkt_temp));
    pkt_temp->stream_index = -1;

    if (is->audioq.abort_request) {
      return -1;
    }

    if (is->audioq.nb_packets == 0)
      SDL_CondSignal(is->continue_read_thread);

    if ((packet_queue_get(&is->audioq, pkt, 1, &is->audio_pkt_temp_serial)) < 0)
      return -1;

    if (pkt->data == flush_pkt.data) {
      avcodec_flush_buffers(dec);
      is->audio_buf_frames_pending = 0;
      is->audio_frame_next_pts = AV_NOPTS_VALUE;
      if ((is->ic->iformat->flags &
           (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &&
          !is->ic->iformat->read_seek)
        is->audio_frame_next_pts = is->audio_st->start_time;
    }

    *pkt_temp = *pkt;
  }
}"
jts-nanopolish-8ec778d/src/thirdparty/scrappie/scrappie_common.c	Simple segmentation of a raw read by thresholding the MAD The MAD of the raw signal is calculated for non-overlapping chunks and then thresholded to find regions at the beginning and end of the signal that have unusually low variation (generally a stall or open pore). The threshhold is derived from the distribution of the calaculated MADs. The threshold is chosen to be high since a single chunk above it will trigger the end of the trimming: the threshhold is chosen so it is unlikely to be exceeded in the leader but commonly exceeded in the main read.	2	"raw_table trim_raw_by_mad(raw_table rt, int chunk_size, float perc) {
  assert(chunk_size > 1);
  assert(perc >= 0.0 && perc <= 1.0);

  const size_t nsample = rt.end - rt.start;
  const size_t nchunk = nsample / chunk_size;

  rt.end = nchunk * chunk_size;

  float *madarr = malloc(nchunk * sizeof(float));
  RETURN_NULL_IF(NULL == madarr, (raw_table){0});
  for (size_t i = 0; i < nchunk; i++) {
    madarr[i] = madf(rt.raw + rt.start + i * chunk_size, chunk_size, NULL);
  }
  quantilef(madarr, nchunk, &perc, 1);

  const float thresh = perc;
  for (size_t i = 0; i < nchunk; i++) {
    if (madarr[i] > thresh) {
      break;
    }
    rt.start += chunk_size;
  }
  for (size_t i = nchunk; i > 0; i--) {
    if (madarr[i - 1] > thresh) {
      break;
    }
    rt.end -= chunk_size;
  }
  assert(rt.end > rt.start);

  free(madarr);

  return rt;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_epi64x(long long __q1, long long __q0) { return (__m128i){__q0, __q1}; }"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/eh.c	"The #throw# intrinsic macro. Syntax: ""#throw#"" type value type is a bareword, one of ""user"", ""error"", ""format"", or ""undefined-behaviour"". value is evaluated as an expression. Semantics: An exception of the given type and value is thrown. This is a very low-level macro. The core library provides a friendlier front-end to throwing exceptions."	2	"ava_macro_subst_result ava_intr_throw_subst(
    const struct ava_symbol_s *self, ava_macsub_context *context,
    const ava_parse_statement *statement, const ava_parse_unit *provoker,
    ava_bool *consumed_other_statements) {
  AVA_STATIC_STRING(undefined_behaviour_str, ""undefined-behaviour"");
  const ava_string user_str = AVA_ASCII9_STRING(""user"");
  const ava_string error_str = AVA_ASCII9_STRING(""error"");
  const ava_string format_str = AVA_ASCII9_STRING(""format"");
  AVA_STATIC_STRING(types, ""user, error, format, or undefined-behaviour"");

  const ava_parse_unit *type_unit = NULL, *value_unit = NULL;
  ava_string type_str = AVA_EMPTY_STRING;
  ava_intr_throw *this;

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN {
      AVA_MACRO_ARG_CURRENT_UNIT(type_unit, ""type"");
      AVA_MACRO_ARG_BAREWORD(type_str, ""type"");
      AVA_MACRO_ARG_UNIT(value_unit, ""value"");
    }
  }

  this = AVA_NEW(ava_intr_throw);
  this->header.context = context;
  this->header.location = provoker->location;
  this->header.v = &ava_intr_throw_vtable;

  if (ava_string_equal(user_str, type_str))
    this->type = ava_pet_user_exception;
  else if (ava_string_equal(error_str, type_str))
    this->type = ava_pet_error_exception;
  else if (ava_string_equal(format_str, type_str))
    this->type = ava_pet_format_exception;
  else if (ava_string_equal(undefined_behaviour_str, type_str))
    this->type = ava_pet_undefined_behaviour_exception;
  else
    return ava_macsub_error_result(
        context, ava_error_bad_macro_keyword(&type_unit->location,
                                             self->full_name, type_str, types));

  this->value = ava_macsub_run_units(context, value_unit, value_unit);

  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v = {.node = (ava_ast_node *)this},
  };
}"
xipengwang-FLAG-cd1815e/april2/src/vx/vxo_sphere.c	"In this implementation, the only data passed to the shader are the texture coordinates. These texture coordinates can be trivially converted into latitude and longitude, but are adjusted so that the triangles render textures properly across the longitude=PI boundary. The shader computes lat/lon from the shader coordinates, then computes xyz."	2	"vx_object_t *vxo_sphere_solid(float rgba[]) {
  static vx_resource_t *program_resource = NULL;
  static vx_resource_t *sts_resource = NULL;
  static vx_resource_t *tris_resource = NULL;
  static int nvertices = 0, napositions = 0;

  vx_lock();

  if (program_resource == NULL) {

    zarray_t *vertex_datas = zarray_create(sizeof(struct vertex_data));
    zarray_t *tris = zarray_create(sizeof(uint16_t[3]));

    const double v = sqrt(3) / 3;
    double *xyza = (double[]){v, v, v};
    double *xyzb = (double[]){-v, -v, v};
    double *xyzc = (double[]){-v, v, -v};
    double *xyzd = (double[]){v, -v, -v};

    int depth = 4;

    recurse(vertex_datas, tris, xyza, xyzc, xyzb, depth);
    recurse(vertex_datas, tris, xyza, xyzb, xyzd, depth);
    recurse(vertex_datas, tris, xyza, xyzd, xyzc, depth);
    recurse(vertex_datas, tris, xyzb, xyzc, xyzd, depth);

    zarray_t *sts = zarray_create(sizeof(float[2]));

    for (int i = 0; i < zarray_size(vertex_datas); i++) {
      struct vertex_data *vd;
      zarray_get_volatile(vertex_datas, i, &vd);

      float *st = (float[]){vd->st[0], vd->st[1]};

      zarray_add(sts, st);
    }

    nvertices = zarray_size(tris) * 3;

    char vertex_shader_src[] =
        ""#define PI 3.14159265358979323846264338\n""
        ""precision mediump float; \n""
        ""attribute vec2 st; \n""
        ""uniform mat4 VX_P;\n""
        ""uniform mat4 VX_V;\n""
        ""uniform mat4 VX_M;\n""
        ""varying vec3 e_xyz;\n""
        ""varying vec3 e_normal;\n""
        ""\n""
        ""void main(void) {\n""
        ""  float lat = (PI / 2.0) - PI * st.y; \n ""
        ""  float lon = 2.0 * PI * st.x; \n ""
        ""  float r = cos(lat); \n ""
        ""  vec3  m_xyz = vec3(r*cos(lon), r*sin(lon), sin(lat)); \n ""
        ""  vec3  m_normal = m_xyz;\n""
        ""\n""
        "" // generic code below\n""
        ""  mat4  VX_VM = VX_V*VX_M;\n""
        ""  mat3  VX_VM_R = mat3(VX_VM[0][0], VX_VM[0][1], VX_VM[0][2],\n""
        ""                       VX_VM[1][0], VX_VM[1][1], VX_VM[1][2],\n""
        ""                       VX_VM[2][0], VX_VM[2][1], VX_VM[2][2]);\n""
        ""  e_xyz = (VX_VM*vec4(m_xyz, 1.0)).xyz;\n""
        ""  e_normal = normalize(VX_VM_R*m_normal);\n""
        ""  gl_Position = VX_P * vec4(e_xyz, 1.0);\n""
        ""}"";

    char fragment_shader_src[] =
        ""precision mediump float; \n""
        ""uniform mat4 VX_V;\n""
        ""varying vec3 e_xyz;\n""
        ""varying vec3 e_normal;\n""
        ""uniform vec4 rgba;\n""
        ""uniform float shininess;\n""
        ""vec3 scale(float alpha, vec3 v) {\n""
        "" return vec3(alpha*v.x, alpha*v.y, alpha*v.z);\n""
        ""}\n""
        ""\n""
        ""vec3 do_lighting(vec3 e_light_pos, vec3 light_diff_rgb, vec3 ""
        ""light_spec_rgb, vec3 e_xyz, vec3 e_normal) {\n""
        ""  vec3 rgb = vec3(0.0, 0.0, 0.0);\n""
        ""  vec3 e_light_dir = normalize(e_light_pos - e_xyz);\n""
        ""  vec3 e_eye_dir = normalize(-e_xyz); \n""
        ""  vec3 e_reflect = -reflect(e_light_dir, e_normal);\n""
        ""\n""
        ""  float alpha = clamp(dot(e_light_dir, e_normal), 0.0, 1.0);\n""
        ""  rgb += scale(alpha, light_diff_rgb);\n""
        ""\n""
        ""  float beta = clamp(dot(e_reflect, e_eye_dir), 0.0, 1.0);\n""
        ""  beta = pow(beta, shininess);\n""
        ""  rgb += scale(beta, light_spec_rgb);\n""
        ""\n""
        ""  return rgb;\n""
        ""}\n""
        ""\n""
        ""void main(void) {\n""
        ""  vec3 w_light_pos = vec3(15, 0, 15);\n""
        ""  vec3 light_diff_rgb = vec3(0.0, 0.5, 0.0);\n""
        ""  vec3 light_spec_rgb = vec3(0.0, 0.0, 1.0);\n""
        ""  vec4 out_rgba = rgba;\n""
        ""\n""
        ""  vec3 e_light_pos = (VX_V * vec4(w_light_pos, 1.0)).xyz;\n""
        ""  out_rgba.xyz += do_lighting(e_light_pos, light_diff_rgb, ""
        ""light_spec_rgb, e_xyz, e_normal);\n""
        ""  gl_FragColor = out_rgba;\n""
        ""}\n"";

    program_resource =
        vx_resource_make_program(vertex_shader_src, fragment_shader_src);
    program_resource->incref(program_resource);

    sts_resource = vx_resource_make_attr_f32_copy((float *)sts->data,
                                                  zarray_size(sts) * 2, 2);
    sts_resource->incref(sts_resource);

    tris_resource =
        vx_resource_make_idx_u16_copy((uint16_t *)tris->data, nvertices);
    tris_resource->incref(tris_resource);
  }

  vx_unlock();

  return vxo_generic_create(
      program_resource,
      (struct vxo_generic_uniformf[]){
          {.name = ""rgba"", .nrows = 4, .ncols = 1, .data = rgba},
          {.name = ""shininess"",
           .nrows = 1,
           .ncols = 1,
           .data = (float[]){20.0}},
          {.name = NULL}},
      (struct vxo_generic_attribute[]){{.name = ""st"", .resource = sts_resource},
                                       {.name = NULL}},
      (struct vxo_generic_texture[]){{.name = NULL}},
      (struct vxo_generic_draw[]){
          {.command = VX_GL_TRIANGLES,
           .first = 0,
           .count = nvertices,
           .indices_resource = tris_resource},
          {.count = 0},
      });
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den) {
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;
        }
        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den) {
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};
        }
        if (inlink && !link->frame_rate.num && !link->frame_rate.den)
          link->frame_rate = inlink->frame_rate;

        if (inlink) {
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den) {
          link->time_base = (AVRational){1, link->sample_rate};
        }
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
flowgrind-flowgrind-3fc0269/src/flowgrind.c	"The main commandline argument parsing function. Defines the cmdline options and distinguishes option types (flow, general, ...) and tokenizes flow options which can have several endpoints."	2	"static void parse_cmdline(int argc, char *argv[]) {
  int rc = 0;
  int cur_num_flows = 0;
  int current_flow_ids[MAX_FLOWS_CONTROLLER];
  int max_flow_specifier = 0;
  int optint = 0;

  const struct ap_Option options[] = {
      {'c', ""show-colon"", ap_yes, OPT_CONTROLLER, 0},
#ifdef DEBUG
      {'d', ""debug"", ap_no, OPT_CONTROLLER, 0},
#endif
      {'e', ""dump-prefix"", ap_yes, OPT_CONTROLLER, 0},
      {'h', ""help"", ap_maybe, OPT_CONTROLLER, 0},
      {'i', ""report-interval"", ap_yes, OPT_CONTROLLER, 0},
      {LOG_FILE_OPTION, ""log-file"", ap_maybe, OPT_CONTROLLER, 0},
      {'m', 0, ap_no, OPT_CONTROLLER, 0},
      {'n', ""flows"", ap_yes, OPT_CONTROLLER, 0},
      {'o', 0, ap_no, OPT_CONTROLLER, 0},
      {'p', 0, ap_no, OPT_CONTROLLER, 0},
      {'q', ""quiet"", ap_no, OPT_CONTROLLER, 0},
      {'s', ""tcp-stack"", ap_yes, OPT_CONTROLLER, 0},
      {'v', ""version"", ap_no, OPT_CONTROLLER, 0},
      {'w', 0, ap_no, OPT_CONTROLLER, 0},
      {'A', 0, ap_yes, OPT_FLOW_ENDPOINT, (int[]){1, 0}},
      {'B', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'C', 0, ap_no, OPT_FLOW_ENDPOINT, 0},
      {'D', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'E', 0, ap_no, OPT_FLOW, 0},
      {'F', 0, ap_yes, OPT_SELECTOR, 0},
      {'G', 0, ap_yes, OPT_FLOW_ENDPOINT, (int[]){1, 2, 3, 0}},
      {'H', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'I', 0, ap_no, OPT_FLOW, 0},
      {'J', 0, ap_yes, OPT_FLOW, 0},
      {'L', 0, ap_no, OPT_FLOW, 0},
      {'M', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'N', 0, ap_no, OPT_FLOW, 0},
      {'O', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'P', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'Q', 0, ap_no, OPT_FLOW, 0},
      {'R', 0, ap_yes, OPT_FLOW_ENDPOINT, (int[]){2, 0}},
      {'S', 0, ap_yes, OPT_FLOW_ENDPOINT, (int[]){3, 0}},
      {'T', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'U', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'W', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {'Y', 0, ap_yes, OPT_FLOW_ENDPOINT, 0},
      {0, 0, ap_no, 0, 0}};

  if (!ap_init(&parser, argc, (const char *const *)argv, options, 0))
    critx(""could not allocate memory for option parser"");
  if (ap_error(&parser))
    PARSE_ERR(""%s"", ap_error(&parser));

  struct ap_Mutex_state ms[4];
  foreach (int *i, MUTEX_CONTEXT_CONTROLLER, MUTEX_CONTEXT_TWO_SIDED,
           MUTEX_CONTEXT_TWO_SIDED, MUTEX_CONTEXT_DESTINATION)
    ap_init_mutex_state(&parser, &ms[*i]);

  for (int i = 0; i < MAX_FLOWS_CONTROLLER; i++)
    current_flow_ids[i] = i;
  cur_num_flows = MAX_FLOWS_CONTROLLER;

  for (int argind = 0; argind < ap_arguments(&parser); argind++) {
    const int code = ap_code(&parser, argind);
    const char *arg = ap_argument(&parser, argind);
    const char *opt_string = ap_opt_string(&parser, argind);
    int tag = ap_option(&parser, argind)->tag;

    switch (tag) {
    case OPT_CONTROLLER:
      check_mutex(ms, MUTEX_CONTEXT_CONTROLLER, argind, 0);
      parse_general_option(code, arg, opt_string);
      break;
    case OPT_SELECTOR:
      cur_num_flows = 0;
      char *argcpy = strdup(arg);
      for (char *token = strtok(argcpy, "",""); token;
           token = strtok(NULL, "","")) {
        rc = sscanf(token, ""%d"", &optint);
        if (rc != 1)
          PARSE_ERR(""%s"", ""Malformed flow specifier"");

        if (optint == -1) {
          for (int i = 0; i < MAX_FLOWS_CONTROLLER; i++)
            current_flow_ids[i] = i;
          cur_num_flows = MAX_FLOWS_CONTROLLER;
          break;
        }

        current_flow_ids[cur_num_flows++] = optint;
        ASSIGN_MAX(max_flow_specifier, optint);
      }
      free(argcpy);

      foreach (int *i, MUTEX_CONTEXT_SOURCE, MUTEX_CONTEXT_DESTINATION,
               MUTEX_CONTEXT_TWO_SIDED)
        ap_reset_mutex(&ms[*i]);
      break;
    case OPT_FLOW:
      check_mutex(ms, MUTEX_CONTEXT_TWO_SIDED, argind, current_flow_ids[0]);
      for (int i = 0; i < cur_num_flows; i++)
        parse_flow_option(code, arg, opt_string, current_flow_ids[i]);
      break;
    case OPT_FLOW_ENDPOINT:
      for (int i = 0; i < cur_num_flows; i++)
        parse_multi_endpoint_option(code, arg, opt_string, ms, argind,
                                    current_flow_ids[i]);
      break;
    default:
      PARSE_ERR(""%s"", ""uncaught option tag!"");
      break;
    }
  }

  if (copt.num_flows <= max_flow_specifier)
    PARSE_ERR(""%s"", ""must not specify option for non-existing flow"");

#if 0
	 
	{
		assert(cflow[0].settings[SOURCE].num_extra_socket_options < MAX_EXTRA_SOCKET_OPTIONS);
		struct extra_socket_options *option = &cflow[0].settings[SOURCE].extra_socket_options[cflow[0].settings[SOURCE].num_extra_socket_options++];
		int v;

		 
		option->optname = TCP_NODELAY;  

		option->level = level_ipproto_tcp;  

		 
		assert(sizeof(v) < MAX_EXTRA_SOCKET_OPTION_VALUE_LENGTH);
		option->optlen = sizeof(v);
		memcpy(option->optval, &v, sizeof(v));
	}
#endif

  for (unsigned short id = 0; id < copt.num_flows; id++) {
    cflow[id].settings[SOURCE].duration[READ] =
        cflow[id].settings[DESTINATION].duration[WRITE];
    cflow[id].settings[DESTINATION].duration[READ] =
        cflow[id].settings[SOURCE].duration[WRITE];
    cflow[id].settings[SOURCE].delay[READ] =
        cflow[id].settings[DESTINATION].delay[WRITE];
    cflow[id].settings[DESTINATION].delay[READ] =
        cflow[id].settings[SOURCE].delay[WRITE];

    foreach (int *i, SOURCE, DESTINATION) {

      if (!cflow[id].endpoint[*i].rpc_info) {
        cflow[id].endpoint[*i].rpc_info = set_rpc_info(
            ""http://localhost:5999/RPC2"", ""localhost"", DEFAULT_LISTEN_PORT);
      }
    }
  }

  foreach (int *i, MUTEX_CONTEXT_CONTROLLER, MUTEX_CONTEXT_TWO_SIDED,
           MUTEX_CONTEXT_TWO_SIDED, MUTEX_CONTEXT_DESTINATION)
    ap_free_mutex_state(&ms[*i]);
}"
caspervranken-BachelorThesis_Pirotte_Vranken-c207e8b/materials/CMaterial.h	This method creates a copy of itself.	2	"public:
cMaterial();

virtual ~cMaterial(){};

static cMaterialPtr create() { return (std::make_shared<cMaterial>()); }

public:
cMaterialPtr copy();

void setModificationFlags(const bool a_value);

void copyTo(cMaterialPtr a_material);

public:
void setShininess(const GLuint a_shininess);

GLuint getShininess() const { return (m_shininess); }"
etri-cicn-nrs-440d6a7/sb-forwarder/metis/ccnx/forwarder/metis/core/metis_ThreadedForwarder.c	"metisThreadedForwarder_Create  Creates a threaded forwarder in the stopped state  IMPORTANT: The logger is called from the Metis thread, so it is up to the user to implement any necessary thread saftey in the logger. There is only a single metis thread, so it does not need to be re-enterent."	2	"metisThreadedForwarder_Create(MetisLogger *logger) {
  struct sigaction ignore_action;
  ignore_action.sa_handler = SIG_IGN;
  sigemptyset(&ignore_action.sa_mask);
  ignore_action.sa_flags = 0;

  sigaction(SIGPIPE, &ignore_action, NULL);

  MetisThreadedForwarder *threadedMetis =
      parcMemory_AllocateAndClear(sizeof(MetisThreadedForwarder));
  assertNotNull(threadedMetis, ""parcMemory_AllocateAndClear(%zu) returned NULL"",
                sizeof(MetisThreadedForwarder));
  threadedMetis->logger = metisLogger_Acquire(logger);
  threadedMetis->forwarder = metisForwarder_Create(logger);

  pthread_mutex_init(&threadedMetis->state_mutex, NULL);
  pthread_cond_init(&threadedMetis->state_cond, NULL);

  threadedMetis->thread = (pthread_t){0};
  threadedMetis->cli = NULL;
  threadedMetis->running = false;
  return threadedMetis;
}"
espressif-esp-idf-a121847/components/driver/sdspi_host.c	"These steps can be done separately, but that leads to a less than optimal performance on large transfers because of delays between each step. For example, if steps 3 and 4 are separate SPI transactions queued one after another, there will be ~16 microseconds of dead time between end of step 3 and the beginning of step 4. A delay between two blocking SPI transactions in step 2 is even higher (~60 microseconds). With this approach the delay between blocks of a multi-block transfer is ~95 microseconds, out of which 35 microseconds are spend doing the CRC check. Further speedup is possible by pipelining transfers and CRC checks, at an expense of one extra temporary buffer."	2	"static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
                                           uint8_t *data, uint32_t rx_length) {
  bool need_stop_command = rx_length > SDSPI_MAX_DATA_LEN;
  spi_transaction_t *t_command = get_transaction(slot);
  *t_command = (spi_transaction_t){
      .length = (SDSPI_CMD_R1_SIZE + SDSPI_RESPONSE_MAX_DELAY) * 8,
      .tx_buffer = cmd,
      .rx_buffer = cmd,
  };
  esp_err_t ret = spi_device_transmit(spi_handle(slot), t_command);
  if (ret != ESP_OK) {
    return ret;
  }
  release_transaction(slot);

  uint8_t *cmd_u8 = (uint8_t *)cmd;
  size_t pre_scan_data_size = SDSPI_RESPONSE_MAX_DELAY;
  uint8_t *pre_scan_data_ptr = cmd_u8 + SDSPI_CMD_R1_SIZE;

  while ((cmd->r1 & SD_SPI_R1_NO_RESPONSE) != 0 && pre_scan_data_size > 0) {
    cmd->r1 = *pre_scan_data_ptr;
    ++pre_scan_data_ptr;
    --pre_scan_data_size;
  }
  if (cmd->r1 & SD_SPI_R1_NO_RESPONSE) {
    ESP_LOGD(TAG, ""no response token found"");
    return ESP_ERR_TIMEOUT;
  }

  while (rx_length > 0) {
    size_t extra_data_size = 0;
    const uint8_t *extra_data_ptr = NULL;
    bool need_poll = true;

    for (int i = 0; i < pre_scan_data_size; ++i) {
      if (pre_scan_data_ptr[i] == TOKEN_BLOCK_START) {
        extra_data_size = pre_scan_data_size - i - 1;
        extra_data_ptr = pre_scan_data_ptr + i + 1;
        need_poll = false;
        break;
      }
    }

    if (need_poll) {

      spi_transaction_t *t_poll = get_transaction(slot);
      ret = poll_data_token(slot, t_poll, cmd_u8 + SDSPI_CMD_R1_SIZE,
                            &extra_data_size, cmd->timeout_ms);
      release_transaction(slot);
      if (ret != ESP_OK) {
        return ret;
      }
      if (extra_data_size) {
        extra_data_ptr = cmd_u8 + SDSPI_CMD_R1_SIZE;
      }
    }

    size_t will_receive = MIN(rx_length, SDSPI_MAX_DATA_LEN) - extra_data_size;
    uint8_t *rx_data;
    ret = get_block_buf(slot, &rx_data);
    if (ret != ESP_OK) {
      return ret;
    }

    const size_t receive_extra_bytes = (rx_length > SDSPI_MAX_DATA_LEN) ? 4 : 2;
    memset(rx_data, 0xff, will_receive + receive_extra_bytes);
    spi_transaction_t *t_data = get_transaction(slot);
    *t_data =
        (spi_transaction_t){.length = (will_receive + receive_extra_bytes) * 8,
                            .rx_buffer = rx_data,
                            .tx_buffer = rx_data};

    ret = spi_device_transmit(spi_handle(slot), t_data);
    if (ret != ESP_OK) {
      return ret;
    }
    release_transaction(slot);

    uint16_t crc = UINT16_MAX;
    memcpy(&crc, rx_data + will_receive, sizeof(crc));

    pre_scan_data_size = receive_extra_bytes - sizeof(crc);
    pre_scan_data_ptr = rx_data + will_receive + sizeof(crc);

    memcpy(data + extra_data_size, rx_data, will_receive);
    if (extra_data_size) {
      memcpy(data, extra_data_ptr, extra_data_size);
    }

    uint16_t crc_of_data = 0;
    if (data_crc_enabled(slot)) {
      crc_of_data = sdspi_crc16(data, will_receive + extra_data_size);
      if (crc_of_data != crc) {
        ESP_LOGE(TAG, ""data CRC failed, got=0x%04x expected=0x%04x"",
                 crc_of_data, crc);
        esp_log_buffer_hex(TAG, data, 16);
        return ESP_ERR_INVALID_CRC;
      }
    }

    data += will_receive + extra_data_size;
    rx_length -= will_receive + extra_data_size;
    extra_data_size = 0;
    extra_data_ptr = NULL;
  }

  if (need_stop_command) {

    sdspi_hw_cmd_t stop_cmd;
    make_hw_cmd(MMC_STOP_TRANSMISSION, 0, cmd->timeout_ms, &stop_cmd);
    ret = start_command_default(slot, SDSPI_CMD_FLAG_RSP_R1, &stop_cmd);
    if (ret != ESP_OK) {
      return ret;
    }
    if (stop_cmd.r1 != 0) {
      ESP_LOGD(TAG, ""%s: STOP_TRANSMISSION response 0x%02x"", __func__,
               stop_cmd.r1);
    }
    spi_transaction_t *t_poll = get_transaction(slot);
    ret = poll_busy(slot, t_poll, cmd->timeout_ms);
    release_transaction(slot);
    if (ret != ESP_OK) {
      return ret;
    }
  }
  return ESP_OK;
}"
PJK-libcbor-87f977e/src/cbor/bytestrings.c	Creates a new indefinite byte string	2	"cbor_item_t *cbor_new_indefinite_bytestring() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_BYTESTRING,
      .metadata = {.bytestring_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                           .length = 0}},
      .data = _CBOR_MALLOC(sizeof(struct cbor_indefinite_string_data))};
  _CBOR_DEPENDENT_NOTNULL(item, item->data);
  *((struct cbor_indefinite_string_data *)item->data) =
      (struct cbor_indefinite_string_data){
          .chunk_count = 0,
          .chunk_capacity = 0,
          .chunks = NULL,
      };
  return item;
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server ready for SNI, and the client sends a name that only matches the wildcard name. The SNI callback should respond with the wildcard credential. The server inquires context to discover which name the client provided."	3	"init_sni_inquire_servername(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  OM_uint32 ignore_minor_status = 0;
  char wildcard_name[] = ""wildcard.example.globus.org"";
  gss_buffer_set_t data_set = NULL;

  major_status = gss_set_sec_context_option(&minor_status, &accept_context,
                                            GSS_SNI_CREDENTIALS,
                                            &(gss_buffer_desc){
                                                .value = creds,
                                                .length = sizeof(creds),
                                            });
  if (major_status != GSS_S_COMPLETE) {
    result = false;

    goto fail;
  }

  major_status = gss_import_name(&minor_status,
                                 &(gss_buffer_desc){
                                     .value = wildcard_name,
                                     .length = strlen(wildcard_name),
                                 },
                                 GLOBUS_GSS_C_NT_HOST_IP, &target_name);

  if (major_status != GSS_S_COMPLETE) {
    result = false;
    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    major_status = gss_inquire_sec_context_by_oid(&minor_status, accept_context,
                                                  &gss_ext_server_name_oid_desc,
                                                  &data_set);
    if (major_status != GSS_S_COMPLETE) {
      result = false;

      goto fail;
    }

    if (data_set->count != 1) {
      result = false;
      goto fail;
    }

    if (strncmp(data_set->elements[0].value, wildcard_name,
                data_set->elements[0].length) != 0) {
      result = false;
      goto fail;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  if (data_set != NULL) {
    gss_release_buffer_set(&minor_status, &data_set);
  }

  return result;
}"
openbabel-openbabel-8cd1e97/include/openbabel/generic.h	sorts atoms in angle by order of indices	2	"_alphaHOMO(0), _betaHOMO(0), _openShell(false){};
virtual ~OBOrbitalData() {}
virtual OBGenericData *Clone(OBBase *) const {
  return new OBOrbitalData(*this);
}

OBOrbitalData &operator=(const OBOrbitalData &);

void SetAlphaOrbitals(std::vector<OBOrbital> orbitalList) {
  _alphaOrbitals = orbitalList;
}
void SetBetaOrbitals(std::vector<OBOrbital> orbitalList) {
  _betaOrbitals = orbitalList;
}"
krmarien-Proxmark-b16dac4/client/cmdhf15.c	Commandline handling: HF15 CMD SYSINFO get system information from tag/VICC	1	"int CmdHF15CmdSysinfo(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[2048] = """";
  int i;

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 1) {
    PrintAndLog(""Usage:  hf 15 cmd sysinfo    [options] <uid|s|u|*>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           start#:       page number to start 0-255"");
    PrintAndLog(""           count#:       number of pages"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15_CMD_SYSINFO}, 1);
  reqlen = c.arg[0];

  reqlen = AddCrc(req, reqlen);
  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15_RES_ERROR)) {
        *output = 0;
        for (i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%02X "", recv[i]);
        }
        strcat(output, ""\n\r"");
        strcat(output, ""UID = "");
        strcat(output, sprintUID(NULL, recv + 2));
        strcat(output, ""\n\r"");
        strcat(output, getTagInfo(recv + 2));
        strcat(output, ""\n\r"");
        i = 10;
        if (recv[1] & 0x01)
          sprintf(output + strlen(output), ""DSFID supported, set to %02X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""DSFID not supported\n\r"");
        if (recv[1] & 0x02)
          sprintf(output + strlen(output), ""AFI supported, set to %03X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""AFI not supported\n\r"");
        if (recv[1] & 0x04) {
          strcat(output,
                 ""Tag provides info on memory layout (vendor dependent)\n\r"");
          sprintf(output + strlen(output),
                  "" %i (or %i) bytes/page x %i pages \n\r"",
                  (recv[i + 1] & 0x1F) + 1, (recv[i + 1] & 0x1F), recv[i] + 1);
          i += 2;
        } else
          strcat(output,
                 ""Tag does not provide information on memory layout\n\r"");
        if (recv[1] & 0x08)
          sprintf(output + strlen(output), ""IC reference given: %02X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""IC reference not given\n\r"");

        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[0], TagErrorStr(recv[0]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""timeout: no answer"");
  }

  return 0;
}"
AlloSphere-Research-Group-AlloSystem-e51da8e/allocore/examples/graphics/shaderSprites.cpp	Called upon creation of a window.	2	"void onCreate(const ViewpointWindow &w) {

  shader.setGeometryInputPrimitive(Graphics::POINTS);
  shader.setGeometryOutputPrimitive(Graphics::TRIANGLE_STRIP);
  shader.setGeometryOutputVertices(4);

  shader.compile(
      R""(
			void main(){
				gl_FrontColor = gl_Color;
				gl_Position = gl_Vertex;
			}
		)"",
      R""(
			uniform sampler2D texSampler0;
			void main(){
				gl_FragColor = texture2D(texSampler0, gl_TexCoord[0].xy) * gl_Color;
			}
		)"",
      R""(
			#version 120
			#extension GL_EXT_geometry_shader4 : enable

			uniform float spriteRadius;
			void main(){
				//screen-aligned axes
				vec3 axis1 = vec3(	gl_ModelViewMatrix[0][0],
									gl_ModelViewMatrix[1][0],
									gl_ModelViewMatrix[2][0]) * spriteRadius;

				vec3 axis2 = vec3(	gl_ModelViewMatrix[0][1],
									gl_ModelViewMatrix[1][1],
									gl_ModelViewMatrix[2][1]) * spriteRadius;

				vec4 pxy = gl_ModelViewProjectionMatrix * vec4(-axis1 - axis2, 0.5);
				vec4 pXy = gl_ModelViewProjectionMatrix * vec4( axis1 - axis2, 0.5);
				vec4 pxY = gl_ModelViewProjectionMatrix * vec4(-axis1 + axis2, 0.5);
				vec4 pXY = gl_ModelViewProjectionMatrix * vec4( axis1 + axis2, 0.5);

				for(int i = 0; i < gl_VerticesIn; ++i){
					// copy color
					gl_FrontColor = gl_FrontColorIn[i];

					vec4 p = gl_ModelViewProjectionMatrix * vec4(gl_PositionIn[i].xyz, 0.5);

					gl_TexCoord[0] = vec4(0, 0, 0, 1);
					gl_Position =  p + pxy;
					EmitVertex();

					gl_TexCoord[0] = vec4(1, 0, 0, 1);
					gl_Position =  p + pXy;
					EmitVertex();

					gl_TexCoord[0] = vec4(0, 1, 0, 1);
					gl_Position =  p + pxY;
					EmitVertex();

					gl_TexCoord[0] = vec4(1, 1, 0, 1);
					gl_Position =  p + pXY;
					EmitVertex();

					EndPrimitive();
				}

				//EndPrimitive();
				gl_Position = gl_PositionIn[0];
			}
		)"");
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_setr_epi32(int __i0, int __i1, int __i2, int __i3) {
  return (__m128i)(__v4si){__i0, __i1, __i2, __i3};
}"
anarsoul-libffplay-402aced/libffplay.c	"Decode one audio frame and return its uncompressed size. The processed audio frame is decoded, converted if required, and stored in is->audio_buf, with size in bytes given by the return value."	2	"static int audio_decode_frame(VideoState *is) {
  AVPacket *pkt_temp = &is->audio_pkt_temp;
  AVPacket *pkt = &is->audio_pkt;
  AVCodecContext *dec = is->audio_st->codec;
  int len1, data_size, resampled_data_size;
  int64_t dec_channel_layout;
  int got_frame;
  av_unused double audio_clock0;
  int wanted_nb_samples;
  AVRational tb;
  int ret;
  int reconfigure;

  for (;;) {

    while (pkt_temp->stream_index != -1 || is->audio_buf_frames_pending) {
      if (!is->frame) {
        if (!(is->frame = av_frame_alloc()))
          return AVERROR(ENOMEM);
      } else {
        av_frame_unref(is->frame);
      }

      if (is->audioq.serial != is->audio_pkt_temp_serial)
        break;

      if (is->paused)
        return -1;

      if (!is->audio_buf_frames_pending) {
        len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);
        if (len1 < 0) {

          pkt_temp->size = 0;
          break;
        }

        pkt_temp->dts = pkt_temp->pts = AV_NOPTS_VALUE;
        pkt_temp->data += len1;
        pkt_temp->size -= len1;
        if ((pkt_temp->data && pkt_temp->size <= 0) ||
            (!pkt_temp->data && !got_frame))
          pkt_temp->stream_index = -1;
        if (!pkt_temp->data && !got_frame)
          is->audio_finished = is->audio_pkt_temp_serial;

        if (!got_frame)
          continue;

        tb = (AVRational){1, is->frame->sample_rate};
        if (is->frame->pts != AV_NOPTS_VALUE)
          is->frame->pts = av_rescale_q(is->frame->pts, dec->time_base, tb);
        else if (is->frame->pkt_pts != AV_NOPTS_VALUE)
          is->frame->pts =
              av_rescale_q(is->frame->pkt_pts, is->audio_st->time_base, tb);
        else if (is->audio_frame_next_pts != AV_NOPTS_VALUE)
          is->frame->pts =
              av_rescale_q(is->audio_frame_next_pts,
                           (AVRational){1, is->audio_filter_src.freq}, tb);

        if (is->frame->pts != AV_NOPTS_VALUE)
          is->audio_frame_next_pts = is->frame->pts + is->frame->nb_samples;

        dec_channel_layout = get_valid_channel_layout(
            is->frame->channel_layout, av_frame_get_channels(is->frame));

        reconfigure =
            cmp_audio_fmts(is->audio_filter_src.fmt,
                           is->audio_filter_src.channels, is->frame->format,
                           av_frame_get_channels(is->frame)) ||
            is->audio_filter_src.channel_layout != dec_channel_layout ||
            is->audio_filter_src.freq != is->frame->sample_rate ||
            is->audio_pkt_temp_serial != is->audio_last_serial;

        if (reconfigure) {
          char buf1[1024], buf2[1024];
          av_get_channel_layout_string(buf1, sizeof(buf1), -1,
                                       is->audio_filter_src.channel_layout);
          av_get_channel_layout_string(buf2, sizeof(buf2), -1,
                                       dec_channel_layout);
          av_log(NULL, AV_LOG_DEBUG,
                 ""Audio frame changed from rate:%d ch:%d fmt:%s layout:%s ""
                 ""serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n"",
                 is->audio_filter_src.freq, is->audio_filter_src.channels,
                 av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1,
                 is->audio_last_serial, is->frame->sample_rate,
                 av_frame_get_channels(is->frame),
                 av_get_sample_fmt_name(is->frame->format), buf2,
                 is->audio_pkt_temp_serial);

          is->audio_filter_src.fmt = is->frame->format;
          is->audio_filter_src.channels = av_frame_get_channels(is->frame);
          is->audio_filter_src.channel_layout = dec_channel_layout;
          is->audio_filter_src.freq = is->frame->sample_rate;
          is->audio_last_serial = is->audio_pkt_temp_serial;

          if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
            return ret;
        }

        if ((ret = av_buffersrc_add_frame(is->in_audio_filter, is->frame)) < 0)
          return ret;
      }
      if ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, is->frame,
                                               0)) < 0) {
        if (ret == AVERROR(EAGAIN)) {
          is->audio_buf_frames_pending = 0;
          continue;
        }
        if (ret == AVERROR_EOF)
          is->audio_finished = is->audio_pkt_temp_serial;
        return ret;
      }
      is->audio_buf_frames_pending = 1;
      tb = is->out_audio_filter->inputs[0]->time_base;

      data_size = av_samples_get_buffer_size(
          NULL, av_frame_get_channels(is->frame), is->frame->nb_samples,
          is->frame->format, 1);

      dec_channel_layout =
          (is->frame->channel_layout &&
           av_frame_get_channels(is->frame) ==
               av_get_channel_layout_nb_channels(is->frame->channel_layout))
              ? is->frame->channel_layout
              : av_get_default_channel_layout(av_frame_get_channels(is->frame));
      wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);

      if (is->frame->format != is->audio_src.fmt ||
          dec_channel_layout != is->audio_src.channel_layout ||
          is->frame->sample_rate != is->audio_src.freq ||
          (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {
        swr_free(&is->swr_ctx);
        is->swr_ctx = swr_alloc_set_opts(NULL, is->audio_tgt.channel_layout,
                                         is->audio_tgt.fmt, is->audio_tgt.freq,
                                         dec_channel_layout, is->frame->format,
                                         is->frame->sample_rate, 0, NULL);
        if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {
          av_log(NULL, AV_LOG_ERROR,
                 ""Cannot create sample rate converter for conversion of %d Hz ""
                 ""%s %d channels to %d Hz %s %d channels!\n"",
                 is->frame->sample_rate,
                 av_get_sample_fmt_name(is->frame->format),
                 av_frame_get_channels(is->frame), is->audio_tgt.freq,
                 av_get_sample_fmt_name(is->audio_tgt.fmt),
                 is->audio_tgt.channels);
          break;
        }
        is->audio_src.channel_layout = dec_channel_layout;
        is->audio_src.channels = av_frame_get_channels(is->frame);
        is->audio_src.freq = is->frame->sample_rate;
        is->audio_src.fmt = is->frame->format;
      }

      if (is->swr_ctx) {
        const uint8_t **in = (const uint8_t **)is->frame->extended_data;
        uint8_t **out = &is->audio_buf1;
        int out_count = (int64_t)wanted_nb_samples * is->audio_tgt.freq /
                            is->frame->sample_rate +
                        256;
        int out_size = av_samples_get_buffer_size(
            NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
        int len2;
        if (out_size < 0) {
          av_log(NULL, AV_LOG_ERROR, ""av_samples_get_buffer_size() failed\n"");
          break;
        }
        if (wanted_nb_samples != is->frame->nb_samples) {
          if (swr_set_compensation(is->swr_ctx,
                                   (wanted_nb_samples - is->frame->nb_samples) *
                                       is->audio_tgt.freq /
                                       is->frame->sample_rate,
                                   wanted_nb_samples * is->audio_tgt.freq /
                                       is->frame->sample_rate) < 0) {
            av_log(NULL, AV_LOG_ERROR, ""swr_set_compensation() failed\n"");
            break;
          }
        }
        av_fast_malloc(&is->audio_buf1, &is->audio_buf1_size, out_size);
        if (!is->audio_buf1)
          return AVERROR(ENOMEM);
        len2 =
            swr_convert(is->swr_ctx, out, out_count, in, is->frame->nb_samples);
        if (len2 < 0) {
          av_log(NULL, AV_LOG_ERROR, ""swr_convert() failed\n"");
          break;
        }
        if (len2 == out_count) {
          av_log(NULL, AV_LOG_WARNING, ""audio buffer is probably too small\n"");
          swr_init(is->swr_ctx);
        }
        is->audio_buf = is->audio_buf1;
        resampled_data_size = len2 * is->audio_tgt.channels *
                              av_get_bytes_per_sample(is->audio_tgt.fmt);
      } else {
        is->audio_buf = is->frame->data[0];
        resampled_data_size = data_size;
      }

      audio_clock0 = is->audio_clock;

      if (is->frame->pts != AV_NOPTS_VALUE)
        is->audio_clock =
            is->frame->pts * av_q2d(tb) +
            (double)is->frame->nb_samples / is->frame->sample_rate;
      else
        is->audio_clock = NAN;
      is->audio_clock_serial = is->audio_pkt_temp_serial;
#ifdef DEBUG
      {
        static double last_clock;
        printf(""audio: delay=%0.3f clock=%0.3f clock0=%0.3f\n"",
               is->audio_clock - last_clock, is->audio_clock, audio_clock0);
        last_clock = is->audio_clock;
      }
#endif
      return resampled_data_size;
    }

    if (pkt->data)
      av_free_packet(pkt);
    memset(pkt_temp, 0, sizeof(*pkt_temp));
    pkt_temp->stream_index = -1;

    if (is->audioq.abort_request) {
      return -1;
    }

    if (is->audioq.nb_packets == 0)
      pthread_cond_signal(&is->continue_read_thread);

    if ((packet_queue_get(&is->audioq, pkt, 1, &is->audio_pkt_temp_serial)) < 0)
      return -1;

    if (pkt->data == NULL && pkt->size == 0 && !is->eof_event_sent) {
      is->eof_event_sent = 1;
      is->eventmgr->send_event(is->eventmgr, LFP_EVENT_EOF, NULL);
    }

    if (pkt->data == flush_pkt.data) {
      avcodec_flush_buffers(dec);
      is->audio_buf_frames_pending = 0;
      is->audio_frame_next_pts = AV_NOPTS_VALUE;
      if ((is->ic->iformat->flags &
           (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &&
          !is->ic->iformat->read_seek)
        is->audio_frame_next_pts = is->audio_st->start_time;
    }

    *pkt_temp = *pkt;
  }
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/compute_error/compute_error.c	Add the computed and exact specified variable to the solution data Multiarrays.	2	"void add_rhs_Error_CE_Data(struct Error_CE_Data *const e_ce_d,
                           const struct Simulation *const sim) {
  struct Test_Case *const test_case = (struct Test_Case *)sim->test_case_rc->tc;
  assert(test_case->copy_initial_rhs == true);

  const int n_var = test_case->n_var;

  const ptrdiff_t ext_0 = e_ce_d->sol[0]->extents[0];
  for (int i = 0; i < 2; ++i) {
    struct Multiarray_d *const sol = e_ce_d->sol[i];

    const ptrdiff_t ext_1_old = sol->extents[1];
    const ptrdiff_t ext_1_new = ext_1_old + n_var;
    resize_Multiarray_d(sol, sol->order, (ptrdiff_t[]){ext_0, ext_1_new});

    const ptrdiff_t exts_rhs[] = {
        sol->extents[0],
        n_var,
    };
    double *const rhs_ptr = get_col_Multiarray_d(ext_1_old, sol);
    struct Multiarray_d *const sol_rhs = constructor_move_Multiarray_d_d(
        'C', sol->order, exts_rhs, true, rhs_ptr);

    copy_into_Multiarray_d(sol_rhs,
                           (struct const_Multiarray_d *)e_ce_d->rhs[i]);
    sol_rhs->owns_data = false;
    destructor_Multiarray_d(sol_rhs);

    sol->extents[1] = ext_1_new;
  }
}"
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Put a value in a stream	2	"stream_t *stream_put(pony_ctx_t **ctx, stream_t *s, encore_arg_t value,
                     pony_type_t *type) {
  future_t *fut = future_mk(ctx, &scons_type);
  struct scons *scons = scons_mk(*ctx, type);
  scons->element = value;
  scons->next = fut;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
  return fut;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/AudioOutputHost/AudioOutputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  puts_P(PSTR(""Speaker Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Initialize/reset the SHA-2 object. SHA-2 is actually a family of functions with different variants. When initializing the SHA-2 container, you must select the variant you intend to apply. The following are valid options (see the fio_sha2_variant_e enum):"	2	"fio_sha2_s fio_sha2_init(fio_sha2_variant_e variant) {
  if (variant == SHA_256) {
    return (fio_sha2_s){
        .type = SHA_256,
        .digest.i32[0] = 0x6a09e667,
        .digest.i32[1] = 0xbb67ae85,
        .digest.i32[2] = 0x3c6ef372,
        .digest.i32[3] = 0xa54ff53a,
        .digest.i32[4] = 0x510e527f,
        .digest.i32[5] = 0x9b05688c,
        .digest.i32[6] = 0x1f83d9ab,
        .digest.i32[7] = 0x5be0cd19,
    };
  } else if (variant == SHA_384) {
    return (fio_sha2_s){
        .type = SHA_384,
        .digest.i64[0] = 0xcbbb9d5dc1059ed8,
        .digest.i64[1] = 0x629a292a367cd507,
        .digest.i64[2] = 0x9159015a3070dd17,
        .digest.i64[3] = 0x152fecd8f70e5939,
        .digest.i64[4] = 0x67332667ffc00b31,
        .digest.i64[5] = 0x8eb44a8768581511,
        .digest.i64[6] = 0xdb0c2e0d64f98fa7,
        .digest.i64[7] = 0x47b5481dbefa4fa4,
    };
  } else if (variant == SHA_512) {
    return (fio_sha2_s){
        .type = SHA_512,
        .digest.i64[0] = 0x6a09e667f3bcc908,
        .digest.i64[1] = 0xbb67ae8584caa73b,
        .digest.i64[2] = 0x3c6ef372fe94f82b,
        .digest.i64[3] = 0xa54ff53a5f1d36f1,
        .digest.i64[4] = 0x510e527fade682d1,
        .digest.i64[5] = 0x9b05688c2b3e6c1f,
        .digest.i64[6] = 0x1f83d9abfb41bd6b,
        .digest.i64[7] = 0x5be0cd19137e2179,
    };
  } else if (variant == SHA_224) {
    return (fio_sha2_s){
        .type = SHA_224,
        .digest.i32[0] = 0xc1059ed8,
        .digest.i32[1] = 0x367cd507,
        .digest.i32[2] = 0x3070dd17,
        .digest.i32[3] = 0xf70e5939,
        .digest.i32[4] = 0xffc00b31,
        .digest.i32[5] = 0x68581511,
        .digest.i32[6] = 0x64f98fa7,
        .digest.i32[7] = 0xbefa4fa4,
    };
  } else if (variant == SHA_512_224) {
    return (fio_sha2_s){
        .type = SHA_512_224,
        .digest.i64[0] = 0x8c3d37c819544da2,
        .digest.i64[1] = 0x73e1996689dcd4d6,
        .digest.i64[2] = 0x1dfab7ae32ff9c82,
        .digest.i64[3] = 0x679dd514582f9fcf,
        .digest.i64[4] = 0x0f6d2b697bd44da8,
        .digest.i64[5] = 0x77e36f7304c48942,
        .digest.i64[6] = 0x3f9d85a86a1d36c8,
        .digest.i64[7] = 0x1112e6ad91d692a1,
    };
  } else if (variant == SHA_512_256) {
    return (fio_sha2_s){
        .type = SHA_512_256,
        .digest.i64[0] = 0x22312194fc2bf72c,
        .digest.i64[1] = 0x9f555fa3c84c64c2,
        .digest.i64[2] = 0x2393b86b6f53b151,
        .digest.i64[3] = 0x963877195940eabd,
        .digest.i64[4] = 0x96283ee2a88effe3,
        .digest.i64[5] = 0xbe5e1e2553863992,
        .digest.i64[6] = 0x2b0199fc2c85b8aa,
        .digest.i64[7] = 0x0eb72ddc81c52ca2,
    };
  }
  FIO_LOG_FATAL(""SHA-2 ERROR - variant unknown"");
  exit(2);
}"
tempesta-tech-tempesta-9bbfee9/tempesta_fw/http.c	"The response redirects the client to the same URI as the original request, but it includes 'Set-Cookie:' header field that sets Tempesta sticky cookie. If JS challenge is enabled, then body contained JS challenge is provided. Body string contains the 'Content-Legth' header, CRLF and body itself."	2	"tfw_http_prep_redirect(TfwHttpMsg *resp, unsigned short status, TfwStr *rmark,
                       TfwStr *cookie, TfwStr *body) {
  TfwHttpReq *req = resp->req;
  size_t data_len;
  int ret = 0;
  TfwMsgIter it;
  static TfwStr rh_302 = {.data = S_REDIR_302, .len = SLEN(S_REDIR_302)};
  static TfwStr rh_503 = {.data = S_REDIR_503, .len = SLEN(S_REDIR_503)};
  TfwStr rh_gen = {
      .chunks = (TfwStr[]){{.data = S_0, .len = SLEN(S_0)},
                           {.data = (*this_cpu_ptr(&g_buf) + RESP_BUF_LEN / 2),
                            .len = 3},
                           {.data = S_REDIR_GEN, .len = SLEN(S_REDIR_GEN)}},
      .len = SLEN(S_0 S_REDIR_GEN) + 3,
      .nchunks = 3};
  TfwStr h_common_1 = {
      .chunks =
          (TfwStr[]){{.data = S_REDIR_P_01, .len = SLEN(S_REDIR_P_01)},
                     {.data = *this_cpu_ptr(&g_buf), .len = SLEN(S_V_DATE)},
                     {.data = S_REDIR_P_02, .len = SLEN(S_REDIR_P_02)}},
      .len = SLEN(S_REDIR_P_01 S_V_DATE S_REDIR_P_02),
      .nchunks = 3};
  static TfwStr h_common_2 = {.data = S_REDIR_P_03, .len = SLEN(S_REDIR_P_03)};
  static TfwStr crlf = {.data = S_CRLF, .len = SLEN(S_CRLF)};
  static TfwStr crlf_keep = {.data = S_REDIR_KEEP, .len = SLEN(S_REDIR_KEEP)};
  static TfwStr crlf_close = {.data = S_REDIR_CLOSE,
                              .len = SLEN(S_REDIR_CLOSE)};
  static TfwStr c_len_crlf = {.data = S_REDIR_C_LEN,
                              .len = SLEN(S_REDIR_C_LEN)};
  static TfwStr protos[] = {
      {.data = S_HTTP, .len = SLEN(S_HTTP)},
      {.data = S_HTTPS, .len = SLEN(S_HTTPS)},
  };
  TfwStr *proto = &protos[TFW_CONN_PROTO(req->conn) == TFW_FSM_HTTPS];
  TfwStr host, *rh, *cookie_crlf = &crlf, *r_end;

  if (status == 302) {
    rh = &rh_302;
  } else if (status == 503) {
    rh = &rh_503;
  } else {
    tfw_ultoa(status, __TFW_STR_CH(&rh_gen, 1)->data, 3);
    rh = &rh_gen;
  }
  if (body)
    r_end = body;
  else
    r_end = &c_len_crlf;

  if (req->host.len)
    host = req->host;
  else
    tfw_http_msg_clnthdr_val(&req->h_tbl->tbl[TFW_HTTP_HDR_HOST],
                             TFW_HTTP_HDR_HOST, &host);

  if (test_bit(TFW_HTTP_B_CONN_CLOSE, req->flags))
    cookie_crlf = &crlf_close;
  else if (test_bit(TFW_HTTP_B_CONN_KA, req->flags))
    cookie_crlf = &crlf_keep;

  data_len = rh->len + h_common_1.len;
  data_len += host.len ? host.len + proto->len : 0;
  data_len += rmark->len;
  data_len += req->uri_path.len + h_common_2.len + cookie->len;
  data_len += cookie_crlf->len + r_end->len;

  if (tfw_http_msg_setup(resp, &it, data_len))
    return TFW_BLOCK;

  tfw_http_prep_date(__TFW_STR_CH(&h_common_1, 1)->data);

  ret = tfw_msg_write(&it, rh);
  ret |= tfw_msg_write(&it, &h_common_1);

  if (host.len) {
    ret |= tfw_msg_write(&it, proto);
    ret |= tfw_msg_write(&it, &host);
  }

  if (rmark->len)
    ret |= tfw_msg_write(&it, rmark);

  ret |= tfw_msg_write(&it, &req->uri_path);
  ret |= tfw_msg_write(&it, &h_common_2);
  ret |= tfw_msg_write(&it, cookie);
  ret |= tfw_msg_write(&it, cookie_crlf);
  ret |= tfw_msg_write(&it, r_end);

  return ret;
}"
Proxmark-proxmark3-fdd9395/client/cmdhf15.c	"Commandline handling: HF15 CMD WRITE Writes a single Block - might run into timeout, even when successful"	2	"int CmdHF15CmdWrite(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum, temp;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char *cmd2;

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(
        ""Usage:  hf 15 cmd write    [options] <uid|s|u|*> <page#> <hexdata>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""               -o        set OPTION Flag (needed for TI)"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           page#:        page number 0-255"");
    PrintAndLog(""           hexdata:      data to be written eg AA BB CC DD"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15693_WRITEBLOCK}, 1);
  reqlen = c.arg[0];

  cmd2 = cmd;
  while (*cmd2 != ' ' && *cmd2 != '\t' && *cmd2)
    cmd2++;
  *cmd2 = 0;
  cmd2++;

  pagenum = strtol(cmd, NULL, 0);

  req[reqlen++] = (uint8_t)pagenum;

  while (cmd2[0] && cmd2[1]) {
    if (*cmd2 == ' ') {
      cmd2++;
      continue;
    }
    sscanf((char[]){cmd2[0], cmd2[1], 0}, ""%X"", &temp);
    req[reqlen++] = temp & 0xff;
    cmd2 += 2;
  }

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 2000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15693_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15693_RES_ERROR)) {
        PrintAndLog(""OK"");
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[1], TagErrorStr(recv[1]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""timeout: no answer - data may be written anyway"");
  }

  return 0;
}"
tsani-tetrefis-02d47ef/basic_types.c	Rotates the given vector 90 degrees counterclockwise.	2	"vec2 rotate_90_degrees(vec2 p) { return (vec2){-p.y, p.x}; }"
scylladb-seastar-05efbce/include/seastar/net/api.hh	Sets the TCP_NODELAY option (disabling Nagle's algorithm)	2	"udp_datagram(std::unique_ptr<udp_datagram_impl> &&impl)
    : _impl(std::move(impl)){};
socket_address get_src() { return _impl->get_src(); }
socket_address get_dst() { return _impl->get_dst(); }"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Device/LowLevel/MIDI/MIDI.c	"Task to handle the generation of MIDI note change events in response to presses of the board joystick, and send them to the host."	0	"void MIDI_Task(void) {
  static uint8_t PrevJoystickStatus;

  if (USB_DeviceState != DEVICE_STATE_Configured)
    return;

  Endpoint_SelectEndpoint(MIDI_STREAM_IN_EPNUM);

  if (Endpoint_IsINReady()) {
    uint8_t MIDICommand = 0;
    uint8_t MIDIPitch;

    uint8_t JoystickStatus = Joystick_GetStatus();
    uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

    uint8_t Channel =
        ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                 : MIDI_CHANNEL(1));

    if (JoystickChanges & JOY_LEFT) {
      MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3C;
    }

    if (JoystickChanges & JOY_UP) {
      MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3D;
    }

    if (JoystickChanges & JOY_RIGHT) {
      MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3E;
    }

    if (JoystickChanges & JOY_DOWN) {
      MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3F;
    }

    if (JoystickChanges & JOY_PRESS) {
      MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3B;
    }

    if (MIDICommand) {
      MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
          .CableNumber = 0,
          .Command = (MIDICommand >> 4),

          .Data1 = MIDICommand | Channel,
          .Data2 = MIDIPitch,
          .Data3 = MIDI_STANDARD_VELOCITY,
      };

      Endpoint_Write_Stream_LE(&MIDIEvent, sizeof(MIDIEvent), NULL);

      Endpoint_ClearIN();
    }

    PrevJoystickStatus = JoystickStatus;
  }

  Endpoint_SelectEndpoint(MIDI_STREAM_OUT_EPNUM);

  if (Endpoint_IsOUTReceived()) {
    MIDI_EventPacket_t MIDIEvent;

    Endpoint_Read_Stream_LE(&MIDIEvent, sizeof(MIDIEvent), NULL);

    if ((MIDIEvent.Command == (MIDI_COMMAND_NOTE_ON >> 4)) &&
        (MIDIEvent.Data3 > 0)) {

      LEDs_SetAllLEDs(MIDIEvent.Data2 > 64 ? LEDS_LED1 : LEDS_LED2);
    } else {

      LEDs_SetAllLEDs(LEDS_NO_LEDS);
    }

    if (!(Endpoint_BytesInEndpoint())) {

      Endpoint_ClearOUT();
    }
  }
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/source/update_client_hub.c	Start the initialization of the hub.	2	"arm_uc_error_t ARM_UC_HUB_Initialize(void (*init_cb)(uintptr_t)) {
  arm_uc_error_t retval;

  if (ARM_UC_HUB_getState() != ARM_UC_HUB_STATE_UNINITIALIZED) {
    UC_HUB_ERR_MSG(""Already Initialized/Initializing"");
    return (arm_uc_error_t){ERR_INVALID_STATE};
  }
  ARM_UC_HUB_setState(ARM_UC_HUB_STATE_INITIALIZING);

  ARM_UC_SchedulerInit();
  ARM_UC_HUB_setInitializationCallback(init_cb);
  ARM_UC_SetSchedulerErrorHandler(UC_HUB_scheduler_error_handler);

  retval =
      ARM_UC_ControlCenter_Initialize(ARM_UC_HUB_ControlCenterEventHandler);
  HANDLE_INIT_ERROR(retval, ""Control Center init failed"")

  retval =
      ARM_UC_FirmwareManager.Initialize(ARM_UC_HUB_FirmwareManagerEventHandler);
  HANDLE_INIT_ERROR(retval, ""Firmware Manager init failed"")

  retval =
      ARM_UC_SourceManager.Initialize(ARM_UC_HUB_SourceManagerEventHandler);
  HANDLE_INIT_ERROR(retval, ""Source Manager init failed"")

  for (uint8_t index = 0; index < arm_uc_sources_size; index++) {
    ARM_UC_SourceManager.AddSource(arm_uc_sources[index]);
  }

  retval = ARM_UC_mmInit(&pManifestManagerContext,
                         ARM_UC_HUB_ManifestManagerEventHandler, NULL);
  HANDLE_INIT_ERROR(retval, ""Manifest manager init failed"")

  return (arm_uc_error_t){ERR_NONE};
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/HID.c	"Switches the attached HID device's reporting protocol over to the standard Report protocol mode. This also retrieves and parses the device's HID report descriptor, so that the size of each report can be determined in advance."	1	"uint8_t
HID_Host_SetReportProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  uint8_t HIDReportData[HIDInterfaceInfo->State.HIDReportSize];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (HID_DTYPE_Report << 8),
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = HIDInterfaceInfo->State.HIDReportSize,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(HIDReportData)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (HIDInterfaceInfo->State.UsingBootProtocol) {
    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 1,
        .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
        .wLength = 0,
    };

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful)
      return ErrorCode;

    HIDInterfaceInfo->State.UsingBootProtocol = false;
  }

  if (HIDInterfaceInfo->Config.HIDParserData == NULL)
    return HID_ERROR_LOGICAL;

  if ((ErrorCode = USB_ProcessHIDReport(
           HIDReportData, HIDInterfaceInfo->State.HIDReportSize,
           HIDInterfaceInfo->Config.HIDParserData)) != HID_PARSE_Successful) {
    return HID_ERROR_LOGICAL | ErrorCode;
  }

  uint8_t LargestReportSizeBits =
      HIDInterfaceInfo->Config.HIDParserData->LargestReportSizeBits;
  HIDInterfaceInfo->State.LargestReportSize =
      (LargestReportSizeBits >> 3) + ((LargestReportSizeBits & 0x07) != 0);

  return 0;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	Writes blocks of data to the attached Mass Storage device's medium.	1	"uint8_t
MS_Host_WriteDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          const uint8_t LUNIndex, const uint32_t BlockAddress,
                          const uint8_t Blocks, const uint16_t BlockSize,
                          const void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, BlockBuffer);
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabPointer request. Sets an active grab on the client's ClientPointer and returns success status to client.	2	"ProcGrabPointer(ClientPtr client) {
  xGrabPointerReply rep;
  DeviceIntPtr device = PickPointer(client);
  GrabPtr grab;
  GrabMask mask;
  WindowPtr confineTo;
  BYTE status;

  REQUEST(xGrabPointerReq);
  int rc;

  REQUEST_SIZE_MATCH(xGrabPointerReq);
  UpdateCurrentTime();

  if (stuff->eventMask & ~PointerGrabMask) {
    client->errorValue = stuff->eventMask;
    return BadValue;
  }

  if (stuff->confineTo == None)
    confineTo = NullWindow;
  else {
    rc =
        dixLookupWindow(&confineTo, stuff->confineTo, client, DixSetAttrAccess);
    if (rc != Success)
      return rc;
  }

  grab = device->deviceGrab.grab;

  if (grab && grab->confineTo && !confineTo)
    ConfineCursorToWindow(device, GetCurrentRootWindow(device), FALSE, FALSE);

  mask.core = stuff->eventMask;

  rc = GrabDevice(client, device, stuff->pointerMode, stuff->keyboardMode,
                  stuff->grabWindow, stuff->ownerEvents, stuff->time, &mask,
                  CORE, stuff->cursor, stuff->confineTo, &status);
  if (rc != Success)
    return rc;

  rep = (xGrabPointerReply){.type = X_Reply,
                            .status = status,
                            .sequenceNumber = client->sequence,
                            .length = 0};
  WriteReplyToClient(client, sizeof(xGrabPointerReply), &rep);
  return Success;
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavcodec/utils.c	"Decode the audio frame of size avpkt->size from avpkt->data into frame. Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no samples will be returned. Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no samples will be returned."	2	"int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx,
                                              AVFrame *frame,
                                              int *got_frame_ptr,
                                              const AVPacket *avpkt) {
  AVCodecInternal *avci = avctx->internal;
  int ret = 0;

  *got_frame_ptr = 0;

  if (!avpkt->data && avpkt->size) {
    av_log(avctx, AV_LOG_ERROR, ""invalid packet: NULL data, size != 0\n"");
    return AVERROR(EINVAL);
  }
  if (!avctx->codec)
    return AVERROR(EINVAL);
  if (avctx->codec->type != AVMEDIA_TYPE_AUDIO) {
    av_log(avctx, AV_LOG_ERROR, ""Invalid media type for audio\n"");
    return AVERROR(EINVAL);
  }

  av_frame_unref(frame);

  if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size ||
      (avctx->active_thread_type & FF_THREAD_FRAME)) {
    uint8_t *side;
    int side_size;
    uint32_t discard_padding = 0;
    uint8_t skip_reason = 0;
    uint8_t discard_reason = 0;

    AVPacket tmp = *avpkt;
    int did_split = av_packet_split_side_data(&tmp);
    ret = apply_param_change(avctx, &tmp);
    if (ret < 0) {
      av_log(avctx, AV_LOG_ERROR, ""Error applying parameter changes.\n"");
      if (avctx->err_recognition & AV_EF_EXPLODE)
        goto fail;
    }

    avctx->internal->pkt = &tmp;
    if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
      ret = ff_thread_decode_frame(avctx, frame, got_frame_ptr, &tmp);
    else {
      ret = avctx->codec->decode(avctx, frame, got_frame_ptr, &tmp);
      frame->pkt_dts = avpkt->dts;
    }
    if (ret >= 0 && *got_frame_ptr) {
      add_metadata_from_side_data(avctx, frame);
      avctx->frame_number++;
      av_frame_set_best_effort_timestamp(
          frame, guess_correct_pts(avctx, frame->pkt_pts, frame->pkt_dts));
      if (frame->format == AV_SAMPLE_FMT_NONE)
        frame->format = avctx->sample_fmt;
      if (!frame->channel_layout)
        frame->channel_layout = avctx->channel_layout;
      if (!av_frame_get_channels(frame))
        av_frame_set_channels(frame, avctx->channels);
      if (!frame->sample_rate)
        frame->sample_rate = avctx->sample_rate;
    }

    side = av_packet_get_side_data(avctx->internal->pkt,
                                   AV_PKT_DATA_SKIP_SAMPLES, &side_size);
    if (side && side_size >= 10) {
      avctx->internal->skip_samples = AV_RL32(side);
      av_log(avctx, AV_LOG_DEBUG, ""skip %d samples due to side data\n"",
             avctx->internal->skip_samples);
      discard_padding = AV_RL32(side + 4);
      skip_reason = AV_RL8(side + 8);
      discard_reason = AV_RL8(side + 9);
    }
    if (avctx->internal->skip_samples && *got_frame_ptr &&
        !(avctx->flags2 & CODEC_FLAG2_SKIP_MANUAL)) {
      if (frame->nb_samples <= avctx->internal->skip_samples) {
        *got_frame_ptr = 0;
        avctx->internal->skip_samples -= frame->nb_samples;
        av_log(avctx, AV_LOG_DEBUG, ""skip whole frame, skip left: %d\n"",
               avctx->internal->skip_samples);
      } else {
        av_samples_copy(frame->extended_data, frame->extended_data, 0,
                        avctx->internal->skip_samples,
                        frame->nb_samples - avctx->internal->skip_samples,
                        avctx->channels, frame->format);
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(avctx->internal->skip_samples,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (frame->pkt_pts != AV_NOPTS_VALUE)
            frame->pkt_pts += diff_ts;
          if (frame->pkt_dts != AV_NOPTS_VALUE)
            frame->pkt_dts += diff_ts;
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for skipped samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""skip %d/%d samples\n"",
               avctx->internal->skip_samples, frame->nb_samples);
        frame->nb_samples -= avctx->internal->skip_samples;
        avctx->internal->skip_samples = 0;
      }
    }

    if (discard_padding > 0 && discard_padding <= frame->nb_samples &&
        *got_frame_ptr && !(avctx->flags2 & CODEC_FLAG2_SKIP_MANUAL)) {
      if (discard_padding == frame->nb_samples) {
        *got_frame_ptr = 0;
      } else {
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for discarded samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""discard %d/%d samples\n"", discard_padding,
               frame->nb_samples);
        frame->nb_samples -= discard_padding;
      }
    }

    if ((avctx->flags2 & CODEC_FLAG2_SKIP_MANUAL) && *got_frame_ptr) {
      AVFrameSideData *fside =
          av_frame_new_side_data(frame, AV_FRAME_DATA_SKIP_SAMPLES, 10);
      if (fside) {
        AV_WL32(fside->data, avctx->internal->skip_samples);
        AV_WL32(fside->data + 4, discard_padding);
        AV_WL8(fside->data + 8, skip_reason);
        AV_WL8(fside->data + 9, discard_reason);
        avctx->internal->skip_samples = 0;
      }
    }
  fail:
    avctx->internal->pkt = NULL;
    if (did_split) {
      av_packet_free_side_data(&tmp);
      if (ret == tmp.size)
        ret = avpkt->size;
    }

    if (ret >= 0 && *got_frame_ptr) {
      if (!avctx->refcounted_frames) {
        int err = unrefcount_frame(avci, frame);
        if (err < 0)
          return err;
      }
    } else
      av_frame_unref(frame);
  }

  return ret;
}"
cmassiot-vlc-broadcast-de11815/libs/srtp/srtp.c	Message Authentication and Integrity for RTP	2	"rtp_digest(srtp_session_t *s, const uint8_t *data, size_t len, uint32_t roc) {
  const gcry_md_hd_t md = s->rtp.mac;

  gcry_md_reset(md);
  gcry_md_write(md, data, len);
  gcry_md_write(md, &(uint32_t){htonl(roc)}, 4);
  return gcry_md_read(md, 0);
}"
darktable-org-darktable-32fab21/src/iop/watermark.c	"callback methods for gui. synch gtk interface with gui params, if necessary. gui callbacks, these are needed."	2	"void gui_update(struct dt_iop_module_t *self) {
  dt_iop_module_t *module = (dt_iop_module_t *)self;
  dt_iop_watermark_gui_data_t *g =
      (dt_iop_watermark_gui_data_t *)self->gui_data;
  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)module->params;
  dt_bauhaus_slider_set(g->opacity, p->opacity);
  dt_bauhaus_slider_set_soft(g->scale, p->scale);
  dt_bauhaus_slider_set(g->rotate, p->rotate);
  dt_bauhaus_slider_set(g->x_offset, p->xoffset);
  dt_bauhaus_slider_set(g->y_offset, p->yoffset);
  for (int i = 0; i < 9; i++) {
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->align[i]), FALSE);
  }
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->align[p->alignment]), TRUE);
  _combo_box_set_active_text(g, p->filename);
  dt_bauhaus_combobox_set(g->sizeto, p->sizeto);
  gtk_entry_set_text(GTK_ENTRY(g->text), p->text);
  GdkRGBA color = (GdkRGBA){.red = p->color[0],
                            .green = p->color[1],
                            .blue = p->color[2],
                            .alpha = 1.0};
  gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(g->colorpick), &color);
  gtk_font_button_set_font_name(GTK_FONT_BUTTON(g->fontsel), p->font);
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/CDC.c	Sets the line encoding for the attached device's virtual serial port. This should be called when the LineEncoding values of the interface have been changed to push the new settings to the USB device.	2	"uint8_t
CDC_Host_SetLineEncoding(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SetLineEncoding,
      .wValue = 0,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = sizeof(CDCInterfaceInfo->State.LineEncoding),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(&CDCInterfaceInfo->State.LineEncoding);
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/http2/casper.c	creates an object with provided parameters	2	"h2o_http2_casper_t *h2o_http2_casper_create(unsigned capacity_bits,
                                            unsigned remainder_bits) {
  h2o_http2_casper_t *casper = h2o_mem_alloc(sizeof(*casper));

  memset(&casper->keys, 0, sizeof(casper->keys));
  casper->capacity_bits = capacity_bits;
  casper->remainder_bits = remainder_bits;
  casper->cookie_cache = (h2o_iovec_t){NULL};

  return casper;
}"
tsani-tetrefis-02d47ef/text.c	"Renders a string to the screen, left-aligned to the given position."	2	"bt_render_string(LFB *const dest, bt_renderer_info const *const renderer_info,
                 vec2 const origin, char const *const str, UINT32 length) {

  UINT32 x0 = origin.x;

  Print(L""DEBUG: bt_draw_string '%s' at (%d, %d)\n"", str, origin.x, origin.y);

  for (int i = 0; i < length; i++) {
    char c = str[i];
    Print(L""DEBUG: drawing character '%c'\n"", c);
    bt_char const *const btc = renderer_info->font->characters[(int)c];
    if (NULL == btc) {
      Print(L""ERROR: unknown character '%c'\n"", c);
      continue;
    }

    Print(L""DEBUG: found bt_char for '%c'\n"", c);

    draw_character(dest, btc, (vec2){x0, origin.y - btc->baseline},
                   renderer_info->color);

    x0 += btc->width + renderer_info->char_skip;
  }
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/PrinterClassHost.c	"Soft-resets the attached printer, readying it for new commands."	2	"uint8_t
PRNT_Host_SoftReset(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(NULL);
}"
intel-iot-devkit-zmraa-f8c045d/source/pwm.c	"Initialise pwm_context, uses board mapping"	2	"mraa_pwm_init(int pin) {
  mraa_board_t *board = plat;
  if (board == NULL) {
    return NULL;
  }

  if (pin < 0 || pin >= board->phy_pin_count) {
    return NULL;
  }

#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
  d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  if (pin == 6) {
    pinmux_pin_set(d2k_pinmux_dev, 19, PINMUX_FUNC_C);
    mraa_set_pininfo(board, 6, 0, ""IO6"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  } else if (pin == 9) {
    pinmux_pin_set(d2k_pinmux_dev, 24, PINMUX_FUNC_C);
    mraa_set_pininfo(board, 9, 1, ""IO9"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  }
#endif
#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_ARDUINO_101)
  struct device *pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  if (pinmux_dev == NULL) {
    printf(""Failed to get binding for pinmux\n"");
    return NULL;
  }

  if (pin == 3) {
    pinmux_pin_set(pinmux_dev, 63, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 3, 0, ""IO3"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  } else if (pin == 5) {
    pinmux_pin_set(pinmux_dev, 64, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 5, 1, ""IO5"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  } else if (pin == 6) {
    pinmux_pin_set(pinmux_dev, 65, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 6, 2, ""IO6"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  } else if (pin == 9) {
    pinmux_pin_set(pinmux_dev, 66, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 9, 3, ""IO9"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
  } else {
    printf(""Pin %d not enabled/Can't be enabled\n"", pin);
    return NULL;
  }
#endif

  if (board->pins[pin].capabilites.pwm != 1) {
    return NULL;
  }

  mraa_pwm_context dev = (mraa_pwm_context)malloc(sizeof(struct _pwm));
  dev->pin = pin;
  dev->phy_pin = board->pins[pin].pwm.pinmap;

#if defined(CONFIG_BOARD_NUCLEO_L476RG)
  struct pin_config pinconf[] = {
      {board->pins[pin].pinID, STM32_PINMUX_FUNC_ALT_1}};
  stm32_setup_pins(pinconf, ARRAY_SIZE(pinconf));

  int pwm_port = 0;

  switch (pin) {
  case 16:
  case 13:
    dev->phy_pin = 1;
    pwm_port = 2;
    break;
  case 17:
  case 3:
    dev->phy_pin = 2;
    pwm_port = 2;
    break;
  case 6:
  case 1:
    dev->phy_pin = 3;
    pwm_port = 2;
    break;
  case 0:
    dev->phy_pin = 4;
    pwm_port = 2;
    break;
  case 8:
    dev->phy_pin = 2;
    pwm_port = 1;
    break;
  case 7:
    dev->phy_pin = 1;
    pwm_port = 1;
    break;
  case 2:
    dev->phy_pin = 3;
    pwm_port = 1;
    break;
  default:
    printf(""Pin can't be configured as PWM as of now\n"");
    return NULL;
  }

  if (pwm_port == 1)
    dev->zdev = device_get_binding(""PWM_1"");
  else if (pwm_port == 2)
    dev->zdev = device_get_binding(""PWM_2"");
  else if (pwm_port == 3)
    dev->zdev = device_get_binding(""PWM_3"");

  if (dev->zdev == NULL) {
    printf(""Unable to get PWM binding\n"");
    return NULL;
  }
#else
  dev->zdev = device_get_binding(""PWM_0"");
  if (dev->zdev == NULL)
    return NULL;
#endif
  dev->period = MAX_PERIOD;
  dev->duty_percentage = DEFAULT_DUTY_CYCLE;

  return dev;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/LowLevel/Host.c	"Convenience function. This routine sends a GetDescriptor standard request to the attached device, requesting the device descriptor. This can be used to easily retrieve information about the device such as its VID, PID and power requirements."	1	"uint8_t USB_Host_GetDeviceDescriptor(void *const DeviceDescriptorPtr) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (DTYPE_Device << 8),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Device_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(DeviceDescriptorPtr);
}"
utwente-fmt-ltsmin-014b6c4/src/spg-lib/spg-strategy.c	Randomly play on game g according to the strategy in result.	2	"bool random_strategy_play(const parity_game *g,
                          const recursive_result *strategy, const int player) {
  treedbs_t tree = TreeDBScreate(g->state_length);
  int initial_state = TreeFold(tree, g->src);
  int priority = get_priority(g, g->src);
  int src[g->state_length];
  int dst[g->state_length];

  int s = initial_state;
  int t = s;

  int l = 0;
  dfs_stack_t states = dfs_stack_create(1);
  dfs_stack_t priorities = dfs_stack_create(1);
  dfs_stack_push(states, (int[]){s});
  dfs_stack_push(priorities, (int[]){priority});

  int current_player;
  bool strategy_play;
  bool deadlock = false;
  bool cycle = false;
  bool result;
  size_t cycle_begin = 0;

  srand(time(NULL));

  while (!(cycle || deadlock)) {
    TreeUnfold(tree, s, src);

    choose_strategy_move(g, strategy, player, src, &current_player,
                         &strategy_play, &result, &deadlock, dst);

    if (!deadlock) {
      t = TreeFold(tree, dst);
      priority = get_priority(g, dst);

      if (log_active(infoLong)) {
        FILE *f = stderr;
        print_vector(f, src, g->state_length);
        fprintf(f, "" (%3d) --> "", s);
        print_vector(f, dst, g->state_length);
        fprintf(f, "" (%3d)"", t);
        fprintf(f, "" <priority=%d, player=%d, %s>\n"", priority, current_player,
                (strategy_play ? ""strategy"" : ""random""));
      }

      for (size_t i = 0; i < dfs_stack_size(states); i++) {
        int *e = dfs_stack_peek(states, i);
        if (e[0] == t) {
          cycle = true;
          cycle_begin = i;
          break;
        }
      }

      if (!cycle) {
        dfs_stack_push(states, (int[]){t});
        dfs_stack_push(priorities, (int[]){priority});
        s = t;
      }
    }
    l++;
  }
  if (cycle) {
    Print(infoLong, ""Cycle found!"");

    int min_priority = g->max_priority;
    for (size_t i = cycle_begin; i < dfs_stack_size(priorities); i++) {
      int *e = dfs_stack_peek(priorities, i);
      if (e[0] < min_priority) {
        min_priority = e[0];
      }
    }

    result = (min_priority % 2 == player);
    Print(infoLong, ""min priority is %d, player %s has won, result is %s."",
          min_priority,
          (min_priority % 2 == 0) ? ""0 (even / or)"" : ""1 (odd / and)"",
          result ? ""true"" : ""false"");
  }
  return result;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_numbers.c	"Converts a float to a temporary, thread safe, C string object"	2	"fio_str_info_s fio_ftocstr(double f) {
  return (fio_str_info_s){.data = num_buffer,
                          .len = fio_ftoa(num_buffer, f, 10)};
}"
seanofw-smile-2696573/smilelib/src/parsing/parser/parsercore.c	"Join all of the messages in the provided list, starting at 'start', up to and including 'end'."	2	"String Parser_JoinMessages(SmileList start, SmileList end) {
  ParseMessage parseMessage;
  String str;
  DECLARE_INLINE_STRINGBUILDER(stringBuilder, 256);

  INIT_INLINE_STRINGBUILDER(stringBuilder);

  for (; SMILE_KIND(start) == SMILE_KIND_LIST; start = (SmileList)start->d) {
    if (SMILE_KIND(start->a) == SMILE_KIND_PARSEMESSAGE) {
      parseMessage = (ParseMessage)start->a;
      str = SMILE_VCALL1(parseMessage, toString, (SmileUnboxedData){0});
      StringBuilder_AppendString(stringBuilder, str);
      StringBuilder_AppendByte(stringBuilder, '\n');
    }

    if (start == end)
      break;
  }

  return StringBuilder_ToString(stringBuilder);
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Print the data other than that of the solution of an euler piece to the file.	2	"(FILE *file, const char sp_type, const struct const_Multiarray_d *const data,
 const char *const data_name) {
  if (data == NULL)
    return;

  char name[STRLEN_MIN];
  if (sp_type == 'p') {
    sprintf(name, ""%s%s"", data_name, ""_rho"");
    fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 's');
    sprintf(name, ""%s%s"", data_name, ""_velocity"");
    fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 'v');
    sprintf(name, ""%s%s"", data_name, ""_E"");
    fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 's');
  } else if (sp_type == 's') {
    const ptrdiff_t ext_0 = data->extents[0], n_var = data->extents[1];

    struct Multiarray_d *var = constructor_move_Multiarray_d_d(
        'C', 2, (ptrdiff_t[]){ext_0, 1}, false, NULL);

    var->extents[1] = 1;
    var->data = (double *)get_col_const_Multiarray_d(0, data);
    sprintf(name, ""%s%s"", data_name, ""_rho"");
    fprint_vtk_DataArray_d(file, sp_type, name,
                           (struct const_Multiarray_d *)var, false, 's');

    var->extents[1] = n_var - 2;
    var->data = (double *)get_col_const_Multiarray_d(1, data);
    sprintf(name, ""%s%s"", data_name, ""_velocity"");
    fprint_vtk_DataArray_d(file, sp_type, name,
                           (struct const_Multiarray_d *)var, false, 'v');

    var->extents[1] = 1;
    var->data = (double *)get_col_const_Multiarray_d(n_var - 1, data);
    sprintf(name, ""%s%s"", data_name, ""_E"");
    fprint_vtk_DataArray_d(file, sp_type, name,
                           (struct const_Multiarray_d *)var, false, 's');

    destructor_Multiarray_d(var);
  } else {
    EXIT_ERROR(""Unsupported: %c\n"", sp_type);
  }
}"
n3f4s-PolyBackgamon-Drunken-Computing-Machine-5217a5c/strategy/src/possibilities.c	"Toutes les combinaisons de mouvement retournes sont garanties d'tre valides, ce qui inclut d'utiliser un maximum de ds. Il peut y avoir des doublons ou des quivalences dans les mouvements retourns."	2	"ArrayList *retrieveEveryPossibility(CompactGameState game, CompactPlayer player,
                                    const unsigned char dices[2]) {

  if (player == CBLACK) {

    game = reverse_game(game);
  }

  ArrayList *list = list_new();
  size_t max_nb_dices_used = 0;

  if (dices[0] == dices[1]) {

    uc dices_tmp[4] = {dices[0], dices[0], dices[0], dices[0]};
    max_nb_dices_used =
        insert_all_dices(game, player, max_nb_dices_used, 0, 4, dices_tmp, list,
                         (AIListMoves){.nombre_mouvements = 0});
  } else {

    uc dices_tmp[2] = {dices[0], dices[1]};
    max_nb_dices_used =
        insert_all_dices(game, player, max_nb_dices_used, 0, 2, dices_tmp, list,
                         (AIListMoves){.nombre_mouvements = 0});
    dices_tmp[0] = dices[1];
    dices_tmp[1] = dices[0];
    max_nb_dices_used =
        insert_all_dices(game, player, max_nb_dices_used, 0, 2, dices_tmp, list,
                         (AIListMoves){.nombre_mouvements = 0});
  }

  {

    size_t i = 0;
    AIListMoves moves;
    for (; list_get(list, i, &moves) &&
           moves.nombre_mouvements < max_nb_dices_used;
         i++)
      ;

    list_splice(list, 0, i);
  }

  if (player == CBLACK) {
    list_foreach(list, reverse_moves);
  }
  return list;
}"
tumi8-vermont-32e684a/src/modules/packet/filter/PacketFilterCfg.h	returns an instance of the module which the config element describes	2	"{
public:
  friend class PacketFilterCfg;

  virtual PacketFilterCfg *create(XMLElement * e) { return NULL; };

  virtual ~PacketStateConnectionFilterCfg(){};

  virtual std::string getName() { return ""stateConnectionBased""; }"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set1_epi16(short __w) {
  return (__m128i)(__v8hi){__w, __w, __w, __w, __w, __w, __w, __w};
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	"Configures the printer to enable Bidirectional mode, if it is not already in this mode. This should be called once the connected device's configuration has been set, to ensure the printer is ready to accept commands."	2	"uint8_t PRNT_Host_SetBidirectionalMode(
    USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo) {
  if (PRNTInterfaceInfo->State.AlternateSetting) {
    uint8_t ErrorCode;

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
        .bRequest = REQ_SetInterface,
        .wValue = PRNTInterfaceInfo->State.AlternateSetting,
        .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful)
      return ErrorCode;
  }

  return HOST_SENDCONTROL_Successful;
}"
bullno1-lip-89bb88c/src/core/vm.c	Create a string value by copying.	2	"lip_make_string_copy(lip_vm_t *vm, lip_string_ref_t str) {
  size_t size = sizeof(lip_string_t) + str.length + 1;
  lip_string_t *string = vm->rt->malloc(vm->rt, LIP_VAL_STRING, size);
  string->length = str.length;
  memcpy(string->ptr, str.ptr, str.length);
  string->ptr[str.length] = '\0';
  return (lip_value_t){.type = LIP_VAL_STRING, .data = {.reference = string}};
}"
psyc-libpsyc-d16deca/src/packet.c	Initialize a dict.	2	"psyc_dict_init(PsycDict *dict, PsycDictElem *elems, size_t num_elems) {
  *dict = (PsycDict){
      .num_elems = num_elems,
      .elems = elems,
  };
  psyc_dict_length_set(dict);
}"
latchset-luksmeta-fe3e941/libluksmeta.c	Initializes metadata storage on a LUKSv1 device	2	"luksmeta_init(struct crypt_device *cd) {
  uint32_t length = 0;
  int fd = -1;
  int r = 0;

  r = luksmeta_test(cd);
  if (r == 0)
    return -EALREADY;
  else if (r != -ENOENT && r != -EINVAL)
    return r;

  fd = open_hole(cd, O_RDWR | O_SYNC, &length);
  if (fd < 0)
    return fd;

  if (length < ALIGN(sizeof(lm_t), true)) {
    close(fd);
    return -ENOSPC;
  }

  r = write_header(fd, (lm_t){});
  close(fd);
  return r > 0 ? 0 : r;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	"Receives a HID IN report from the attached device, by the report ID."	0	"uint8_t
HID_Host_ReceiveReportByID(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo,
                           const uint8_t ReportID, void *Buffer) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetReport,
      .wValue = ((HID_REPORT_ITEM_In + 1) << 8) | ReportID,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = USB_GetHIDReportSize(HIDInterfaceInfo->Config.HIDParserData,
                                      ReportID, HID_REPORT_ITEM_In),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
braice-MuMuDVB-745259a/src/multicast.c	Initialize multicast variables	2	"void init_multicast_v(multi_p_t *multi_p) {
  memset(multi_p, 0, sizeof(multi_p_t));
  *multi_p = (multi_p_t){
      .multicast = 1,
      .multicast_ipv6 = 0,
      .multicast_ipv4 = 1,
      .ttl = DEFAULT_TTL,
      .common_port = 1234,
      .auto_join = 0,
      .rtp_header = 0,
      .iface4 = ""\0"",
      .iface6 = ""\0"",
  };
}"
dm-vdo-kvdo-8df6805/vdo/base/blockMap.c	Make the pending action the current action.	2	"static BlockMapAction advanceActions(BlockMap *map) {
  BlockMapAction completed = map->currentAction;
  map->currentAction = map->nextAction;
  map->nextAction =
      (BlockMapAction){.action = BLOCK_MAP_ACTION_NONE, .parent = NULL};
  return completed;
}"
iut-ibk-DynaMind-ToolBox-5066ce4/DynaMind/src/core/dmmodule.h	sets the parameter via string value As seperator for STRING_LIST *|* is used and for maps also *||* 1*|*2*|*3*|4*||* 5*|*6*|*7*|*8*||*	2	"virtual void preRun();

virtual void afterRun();

virtual ~Module();

virtual void init(){};

virtual void run() = 0;

virtual const char *getClassName() const = 0;

virtual const char *getDisplayName() const = 0;

virtual std::string getHelpUrl() { return """"; };

virtual bool createInputDialog() { return false; }"
dm-vdo-kvdo-8df6805/vdo/base/refCounts.c	"Create a reference counting object. A reference counting object can keep a reference count for every physical block in the VDO configuration. Since we expect the vast majority of the blocks to have 0 or 1 reference counts, the structure is optimized for that situation."	2	"int makeRefCounts(PhysicalLayer *layer, BlockCount blockCount, Slab *slab,
                  PhysicalBlockNumber origin,
                  ReadOnlyModeContext *readOnlyContext,
                  RefCounts **refCountsPtr) {
  BlockCount refBlockCount = getSavedReferenceCountSize(blockCount);
  RefCounts *refCounts;
  int result = ALLOCATE_EXTENDED(RefCounts, refBlockCount, ReferenceBlock,
                                 ""ref counts structure"", &refCounts);
  if (result != UDS_SUCCESS) {
    return result;
  }

  size_t bytes = ((refBlockCount * COUNTS_PER_BLOCK) + (2 * BYTES_PER_WORD));
  result =
      ALLOCATE(bytes, ReferenceCount, ""ref counts array"", &refCounts->counters);
  if (result != UDS_SUCCESS) {
    freeRefCounts(&refCounts);
    return result;
  }

  result = initializeEnqueueableCompletion(&refCounts->completion,
                                           REFERENCE_COUNTS_COMPLETION, layer);
  if (result != VDO_SUCCESS) {
    freeRefCounts(&refCounts);
    return result;
  }

  refCounts->slab = slab;
  refCounts->blockCount = blockCount;
  refCounts->freeBlocks = blockCount;
  refCounts->origin = origin;
  refCounts->referenceBlockCount = refBlockCount;
  refCounts->readOnlyContext = readOnlyContext;
  refCounts->statistics = &slab->allocator->refCountStatistics;
  refCounts->searchCursor.firstBlock = &refCounts->blocks[0];
  refCounts->searchCursor.lastBlock = &refCounts->blocks[refBlockCount - 1];
  resetSearchCursor(refCounts);

  for (size_t index = 0; index < refBlockCount; index++) {
    refCounts->blocks[index] = (ReferenceBlock){
        .refCounts = refCounts,
    };
  }

  *refCountsPtr = refCounts;
  return VDO_SUCCESS;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/block.c	"The block-void, block-last, and block-only control macros. Syntax: ""block-void"" block ""block-last"" block ""block-only"" block block must be a Block. The macro expands to a sequence containing the contents of block. The return policy is found by dereferencing the macro userdata. The main purpose of this macro family is for user macros which need to have more than one statement. One might expect lone braces to be usable for this purpose, eg with the syntax { ; do stuff } The explicit head also allows specifying the return policy. Note that while block-last allows more than one statement, its contents are never considered a void context since that would mean that control macros behave inconsistently within."	4	"ava_macro_subst_result ava_intr_block_subst(
    const struct ava_symbol_s *self, ava_macsub_context *context,
    const ava_parse_statement *statement, const ava_parse_unit *provoker,
    ava_bool *consumed_other_statements) {
  const ava_intr_seq_return_policy *return_policy = self->v.macro.userdata;
  const ava_parse_unit *body = NULL;
  ava_ast_node *result;

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN { AVA_MACRO_ARG_BLOCK(body, ""block""); }
  }

  result = ava_macsub_run(context, &provoker->location,
                          (ava_parse_statement_list *)&body->v.statements,
                          *return_policy);

  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v.node = result,
  };
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Core/HostStandardReq.c	"Sends a GET DESCRIPTOR standard request to the attached device, requesting the descriptor of the specified type and index."	0	"uint8_t USB_Host_GetDescriptor(const uint8_t Type, const uint8_t Index,
                               void *const Buffer, const uint8_t BufferLength) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (((uint16_t)Type << 8) | Index),
      .wIndex = 0,
      .wLength = BufferLength,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/LUFA/Drivers/USB/HighLevel/ConfigDescriptor.c	Retrieves the configuration descriptor data or size from an attached device via a standard request.	0	"uint8_t USB_GetDeviceConfigDescriptor(uint16_t *const ConfigSizePtr,
                                      void *BufferPtr) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (DTYPE_Configuration << 8),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Configuration_Header_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if (BufferPtr == NULL) {
    uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

    ErrorCode = USB_Host_SendControlRequest(ConfigHeader);

#if defined(USE_NONSTANDARD_DESCRIPTOR_NAMES)
    *ConfigSizePtr =
        DESCRIPTOR_CAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
            .TotalConfigurationSize;
#else
    *ConfigSizePtr =
        DESCRIPTOR_CAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
            .wTotalLength;
#endif
  } else {
    USB_ControlRequest.wLength = *ConfigSizePtr;

    ErrorCode = USB_Host_SendControlRequest(BufferPtr);
  }

  return ErrorCode;
}"
jpmorganchase-zsl-q-b2860cf/zsl-golang/zsl/snark/libsnark/src/gadgetlib2/variable.hpp	"Helper method. When doing arithmetic between a constant and a field specific element we want to ""promote"" the constant to the same field. This function changes the unique_ptr to point to a field specific element with the same value as the constant which it held."	2	"virtual FElemInterfacePtr inverse() const = 0;
virtual long asLong() const = 0;
virtual int getBit(unsigned int i) const = 0;
virtual FElemInterface &power(long exponent) = 0;
virtual ~FElemInterface(){};
}
;

inline bool operator==(const long first, const FElemInterface &second) {
  return second == first;
}"
darktable-org-darktable-32fab21/src/iop/nlmeans.c	this will be called to init new defaults if a new image is loaded from film strip mode.	2	"void reload_defaults(dt_iop_module_t *module) {

  module->default_enabled = 0;

  dt_iop_nlmeans_params_t tmp =
      (dt_iop_nlmeans_params_t){2.0f, 50.0f, 0.5f, 1.0f};
  memcpy(module->params, &tmp, sizeof(dt_iop_nlmeans_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_nlmeans_params_t));
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float2() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_16}}};
  return item;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a double-precision value into the low-order bits of a 128-bit vector of [2 x double]. The high-order bits are copied from the high-order bits of the first operand.	2	"_mm_loadl_pd(__m128d __a, double const *__dp) {
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __a[1]};
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	Writes blocks of data to the attached Mass Storage device's medium.	1	"uint8_t
MS_Host_WriteDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          const uint8_t LUNIndex, const uint32_t BlockAddress,
                          const uint8_t Blocks, const uint16_t BlockSize,
                          const void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = COMMAND_DIRECTION_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Write command to the attached device, to write one or more data blocks to the storage medium from a buffer."	0	"uint8_t MassStore_WriteDeviceBlock(const uint8_t LUNIndex,
                                   const uint32_t BlockAddress,
                                   const uint8_t Blocks,
                                   const uint16_t BlockSize, void *BufferPtr) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, BufferPtr);
}"
simondlevy-ARDroneAutoPylot-7ca39e9/ARDroneLib/FFMPEG/ffmpeg/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
#define LOG2 0.69314718055994530941723212145817656807550013436025
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (isinf(d))
    return (AVRational){d < 0 ? -1 : 1, 0};
  if (0.0 == d)
    return (AVRational){0, 0};
  exponent = FFMAX((int)(log(fabs(d) + 1e-20) / LOG2), 0);
  den = 1LL << (61 - exponent);
  av_reduce(&a.num, &a.den, (int64_t)(d * den + 0.5), den, max);

  return a;
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Liefert fr jedes Element von value den Wert a, wenn value grer als reference ist, und b sonst."	2	"static inline vec_float4 simd_select_gt(vec_float4 value, vec_float4 reference,
                                        vec_float4 a, vec_float4 b) {
#if defined(__SSE__)
  vec_float4 mask = _mm_cmpgt_ps(value, reference);
  return _mm_or_ps(_mm_and_ps(mask, a), _mm_andnot_ps(mask, b));
#elif defined(__VEC__)
  vector bool mask = vec_cmpgt(value, reference);
  return (vector float)vec_sel(mask, a, b);
#elif defined(__NEON__)
  uint32x4_t mask = vcgtq_f32(value, reference);
  return (vec_float4)vbslq_f32(mask, a, b);
#else
  const float *valueF = (const float *)&value;
  const float *referenceF = (const float *)&reference;
  const float *aF = (const float *)&a;
  const float *bF = (const float *)&b;
  return (vec_float4){valueF[0] > referenceF[0] ? aF[0] : bF[0],
                      valueF[1] > referenceF[1] ? aF[1] : bF[1],
                      valueF[2] > referenceF[2] ? aF[2] : bF[2],
                      valueF[3] > referenceF[3] ? aF[3] : bF[3]};
#endif
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavutil/rational.c	Reduce a fraction. This is useful for framerate calculations.	2	"int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den,
              int64_t max) {
  AVRational a0 = {0, 1}, a1 = {1, 0};
  int sign = (num < 0) ^ (den < 0);
  int64_t gcd = av_gcd(FFABS(num), FFABS(den));

  if (gcd) {
    num = FFABS(num) / gcd;
    den = FFABS(den) / gcd;
  }
  if (num <= max && den <= max) {
    a1 = (AVRational){num, den};
    den = 0;
  }

  while (den) {
    uint64_t x = num / den;
    int64_t next_den = num - den * x;
    int64_t a2n = x * a1.num + a0.num;
    int64_t a2d = x * a1.den + a0.den;

    if (a2n > max || a2d > max) {
      if (a1.num)
        x = (max - a0.num) / a1.num;
      if (a1.den)
        x = FFMIN(x, (max - a0.den) / a1.den);

      if (den * (2 * x * a1.den + a0.den) > num * a1.den)
        a1 = (AVRational){x * a1.num + a0.num, x * a1.den + a0.den};
      break;
    }

    a0 = a1;
    a1 = (AVRational){a2n, a2d};
    num = den;
    den = next_den;
  }
  av_assert2(av_gcd(a1.num, a1.den) <= 1U);
  av_assert2(a1.num <= max && a1.den <= max);

  *dst_num = sign ? -a1.num : a1.num;
  *dst_den = a1.den;

  return den == 0;
}"
apache-incubator-singa-9c6bd09/include/singa/model/loss.h	"Compute the gradients of the loss values w.r.t. the prediction, which is (prediction-target)/batchsize"	2	"Setup(loss);
}
virtual ~Loss(){};
virtual void ToDevice(std::shared_ptr<Device> device) {}"
Pbdas-epa-ng-9b444f4/libs/genesis/lib/genesis/placement/function/cog.cpp	It is thus like calculating masses and torques on a lever in order to find their physical center of mass/gravity.	2	"std::pair<PlacementTreeEdge const *, double>
center_of_gravity(Sample const &smp, bool const with_pendant_length) {

  struct Fulcrum {
    Fulcrum() : mass(0.0), torque(0.0) {}

    double mass;
    double torque;
  };

  LOG_SCOPE_LEVEL(utils::Logging::kInfo)

  std::unordered_map<PlacementTreeLink const *, Fulcrum> balance;

  auto place_map = placements_per_edge(smp);

  for (auto it : postorder(smp.tree())) {

    if (it.is_last_iteration()) {
      continue;
    }

    Fulcrum curr_fulcrum;

    PlacementTreeLink const *link = &it.link().next();
    while (link != &it.link()) {

      assert(balance.count(link));

      auto const &edge_data = it.edge().data<PlacementEdgeData>();
      curr_fulcrum.mass += balance[link].mass;
      curr_fulcrum.torque += balance[link].mass * edge_data.branch_length;
      curr_fulcrum.torque += balance[link].torque;
      link = &link->next();
    }

    for (PqueryPlacement const *place : place_map[it.edge().index()]) {
      double place_dist = place->proximal_length;
      if (with_pendant_length) {
        place_dist += place->pendant_length;
      }
      curr_fulcrum.mass += place->like_weight_ratio;
      curr_fulcrum.torque += place->like_weight_ratio * place_dist;
    }

    assert(balance.count(&it.link().outer()) == 0);
    balance[&it.link().outer()] = curr_fulcrum;
  }

  PlacementTreeLink const *curr_link = &smp.tree().root_link();
  PlacementTreeLink const *prev_link = nullptr;

  size_t num_iterations = 0;
  auto depth_vector = node_path_length_vector(smp.tree());
  size_t max_iterations = 1 + static_cast<size_t>(*std::max_element(
                                  depth_vector.begin(), depth_vector.end()));

  LOG_DBG << ""max it "" << max_iterations;

  while (true) {
    assert(num_iterations <= max_iterations);
    ++num_iterations;

    LOG_DBG << ""iteration "" << num_iterations;
    LOG_DBG1 << ""find max at ""
             << curr_link->node().data<PlacementNodeData>().name;

    PlacementTreeLink const *max_link = nullptr;
    double max_torque = -1.0;
    Fulcrum sum;

    for (auto it_l : node_links(curr_link->node())) {

      assert(balance.count(&it_l.link()) > 0);

      LOG_DBG2 << ""at ""
               << it_l.link().outer().node().data<PlacementNodeData>().name
               << "" with mass "" << balance[&it_l.link()].mass << "" and torque ""
               << balance[&it_l.link()].torque;
      if (balance[&it_l.link()].torque > max_torque) {
        max_link = &it_l.link();
        max_torque = balance[&it_l.link()].torque;
      }
      sum.mass += balance[&it_l.link()].mass;
      sum.torque += balance[&it_l.link()].torque;
    }
    assert(max_link);

    LOG_DBG1 << ""moving to ""
             << max_link->outer().node().data<PlacementNodeData>().name;
    if (&max_link->outer() == prev_link) {
      LOG_DBG << ""found between ""
              << curr_link->node().data<PlacementNodeData>().name << "" and ""
              << prev_link->node().data<PlacementNodeData>().name;
      break;
    }

    prev_link = max_link;
    curr_link = &max_link->outer();

    LOG_DBG1 << ""mass sum "" << sum.mass << "", torque sum "" << sum.torque;

    auto const &max_edge_data = max_link->edge().data<PlacementEdgeData>();
    sum.mass -= balance[max_link].mass;
    sum.torque -= balance[max_link].torque;
    sum.torque += sum.mass * max_edge_data.branch_length;

    for (PqueryPlacement const *place : place_map[max_link->edge().index()]) {
      double p_dist = max_edge_data.branch_length - place->proximal_length;
      if (with_pendant_length) {
        p_dist += place->pendant_length;
      }
      sum.mass += place->like_weight_ratio;
      sum.torque += place->like_weight_ratio * p_dist;
    }

    balance[curr_link] = sum;
    LOG_DBG1 << ""stored mass "" << sum.mass << "" and torque "" << sum.torque
             << "" at ""
             << max_link->outer().node().data<PlacementNodeData>().name;

    LOG_DBG << ""end of iteration "" << num_iterations << ""\n"";
  }

  assert(&curr_link->edge() == &prev_link->edge());
  assert(&prev_link->node() == &prev_link->edge().primary_node());
  assert(&curr_link->node() == &curr_link->edge().secondary_node());

  LOG_DBG << ""cur  "" << curr_link->node().data<PlacementNodeData>().name
          << "" with mass "" << balance[curr_link].mass << "" and torque ""
          << balance[curr_link].torque;
  LOG_DBG << ""prev "" << prev_link->node().data<PlacementNodeData>().name
          << "" with mass "" << balance[prev_link].mass << "" and torque ""
          << balance[prev_link].torque;

  PlacementTreeEdge const *const central_edge = &curr_link->edge();

  Fulcrum prox_fulcrum;
  Fulcrum dist_fulcrum;

  assert(balance.count(curr_link) > 0);
  assert(balance.count(prev_link) > 0);

  PlacementTreeLink const *link;
  link = &prev_link->next();
  while (link != prev_link) {
    assert(balance.count(link));
    prox_fulcrum.mass += balance[link].mass;
    prox_fulcrum.torque += balance[link].torque;
    link = &link->next();
  }

  link = &curr_link->next();
  while (link != curr_link) {
    assert(balance.count(link));
    dist_fulcrum.mass += balance[link].mass;
    dist_fulcrum.torque += balance[link].torque;
    link = &link->next();
  }

  LOG_DBG << ""prox_mass "" << prox_fulcrum.mass << "", prox_torque ""
          << prox_fulcrum.torque;
  LOG_DBG << ""dist_mass "" << dist_fulcrum.mass << "", dist_torque ""
          << dist_fulcrum.torque;

  double approx_proximal_length;
  auto const &central_edge_data = central_edge->data<PlacementEdgeData>();
  if (prox_fulcrum.mass == 0.0 || dist_fulcrum.mass == 0.0) {
    approx_proximal_length = central_edge_data.branch_length / 2.0;
  } else {
    approx_proximal_length =
        (dist_fulcrum.torque - prox_fulcrum.torque +
         (dist_fulcrum.mass * central_edge_data.branch_length)) /
        (dist_fulcrum.mass + prox_fulcrum.mass);
  }

  LOG_DBG << ""approx_proximal_length "" << approx_proximal_length;

  Fulcrum prox_sum = prox_fulcrum;
  Fulcrum dist_sum = balance[prev_link];

  LOG_DBG << ""prox_sum mass "" << prox_sum.mass << "", prox_sum torque ""
          << prox_sum.torque;
  LOG_DBG << ""dist_sum mass "" << dist_sum.mass << "", dist_sum torque ""
          << dist_sum.torque;

  LOG_DBG1 << ""assert "" << dist_sum.torque << "">="" << prox_sum.torque;

  struct BalancePoint {
    BalancePoint() : proximal_length(0.0), mass(0.0), pendant_torque(0.0){};
    BalancePoint(double prox_len)
        : proximal_length(prox_len), mass(0.0), pendant_torque(0.0){};

    double proximal_length;
    double mass;
    double pendant_torque;
  };

  std::vector<BalancePoint> edge_balance;
  edge_balance.reserve(place_map[central_edge->index()].size() + 2);
  edge_balance.push_back(BalancePoint(0.0));

  double tqs = 0.0;
  double mss = 0.0;

  auto sort_by_pos = [](PqueryPlacement const *lhs,
                        PqueryPlacement const *rhs) {
    return lhs->proximal_length < rhs->proximal_length;
  };
  std::sort(place_map[central_edge->index()].begin(),
            place_map[central_edge->index()].end(), sort_by_pos);

  for (PqueryPlacement const *place : place_map[central_edge->index()]) {
    double place_prox = place->proximal_length;

    if (place_prox > central_edge_data.branch_length) {
      LOG_WARN << ""Placement found that has proximal_length > branch_length."";
      place_prox = central_edge_data.branch_length;
    }
    if (place_prox < 0.0) {
      LOG_WARN << ""Placement found that has proximal_length < 0.0."";
      place_prox = 0.0;
    }

    double place_pendant_torque = 0.0;
    if (with_pendant_length) {
      place_pendant_torque = place->like_weight_ratio * place->pendant_length;
    }

    tqs += place_prox * place->like_weight_ratio;
    mss += place->like_weight_ratio;

    BalancePoint place_balance;
    place_balance.proximal_length = place_prox;
    place_balance.mass = place->like_weight_ratio;
    place_balance.pendant_torque = place_pendant_torque;

    edge_balance.push_back(place_balance);
  }

  tqs += dist_fulcrum.torque - prox_fulcrum.torque +
         (dist_fulcrum.mass * central_edge_data.branch_length);
  mss += dist_fulcrum.mass + prox_fulcrum.mass;
  double solution_without_pendant_length = tqs / mss;
  LOG_DBG << ""tqs "" << tqs << "", mss "" << mss;
  LOG_DBG << ""solution_without_pendant_length ""
          << solution_without_pendant_length;

  return std::make_pair(central_edge, solution_without_pendant_length);

  edge_balance.push_back(BalancePoint(central_edge_data.branch_length));

  LOG_DBG << ""edge_balance:"";
  for (auto &e : edge_balance) {
    LOG_DBG1 << ""at "" << e.proximal_length << "" with mass "" << e.mass
             << "" and pen torque "" << e.pendant_torque;
  }

  LOG_DBG << ""prox_sum mass "" << prox_sum.mass << "", prox_sum torque ""
          << prox_sum.torque;
  LOG_DBG << ""dist_sum mass "" << dist_sum.mass << "", dist_sum torque ""
          << dist_sum.torque;

  size_t pos = 1;
  double dist_diff = 0.0;
  for (; pos < edge_balance.size(); ++pos) {
    auto &curr_point = edge_balance[pos];

    dist_diff =
        curr_point.proximal_length - edge_balance[pos - 1].proximal_length;

    LOG_DBG1 << ""iteration "" << pos;

    LOG_DBG1 << ""at "" << curr_point.proximal_length << "" with mass ""
             << curr_point.mass << "" and pen torque ""
             << curr_point.pendant_torque;

    LOG_DBG2 << ""dist diff "" << dist_diff;

    LOG_DBG2 << ""prox_sum mass "" << prox_sum.mass << "", prox_sum torque ""
             << prox_sum.torque;
    LOG_DBG2 << ""dist_sum mass "" << dist_sum.mass << "", dist_sum torque ""
             << dist_sum.torque;

    if (prox_sum.torque + prox_sum.mass * dist_diff >=
        dist_sum.torque - dist_sum.mass * dist_diff) {
      break;
    }

    prox_sum.torque += prox_sum.mass * dist_diff + curr_point.pendant_torque;
    dist_sum.torque -= dist_sum.mass * dist_diff + curr_point.pendant_torque;

    prox_sum.mass += curr_point.mass;
    dist_sum.mass -= curr_point.mass;

    LOG_DBG2 << ""new prox_sum mass "" << prox_sum.mass << "", prox_sum torque ""
             << prox_sum.torque;
    LOG_DBG2 << ""new dist_sum mass "" << dist_sum.mass << "", dist_sum torque ""
             << dist_sum.torque;
  }

  LOG_DBG << ""final prox_sum mass "" << prox_sum.mass << "", prox_sum torque ""
          << prox_sum.torque;
  LOG_DBG << ""final dist_sum mass "" << dist_sum.mass << "", dist_sum torque ""
          << dist_sum.torque;

  LOG_DBG << ""pos "" << pos << "" size "" << edge_balance.size();

  assert(pos < edge_balance.size());

  dist_sum.torque -= dist_sum.mass * dist_diff;
  double result_proximal_length =
      (dist_sum.torque - prox_sum.torque + (dist_sum.mass * dist_diff)) /
      (dist_sum.mass + prox_sum.mass);
  LOG_DBG << ""result_proximal_length "" << result_proximal_length;
  result_proximal_length += edge_balance[pos - 1].proximal_length;
  LOG_DBG << ""result_proximal_length "" << result_proximal_length;

  return std::make_pair(central_edge, result_proximal_length);
}"
tg1716-SLAM-b8583fb/libs/gui/include/mrpt/otherlibs/mathplot/mathplot.h	"Set view to fit a given bounding box and refresh display. The X/Y scale aspect lock is taken into account. If provided, the parameters printSizeX and printSizeY are taken as the DC size, and the pixel scales are computed accordingly. Also, in this case the passed borders are not saved as the ""desired borders"", since this use will be invoked only when printing."	2	"mpPolygon(const wxString &layerName = wxT("""")) {
  m_continuous = true;
  m_name = layerName;
}

virtual ~mpPolygon() {}

void setPoints(const std::vector<double> &points_xs,
               const std::vector<double> &points_ys, bool closedShape = true);

void setPoints(const std::vector<float> &points_xs,
               const std::vector<float> &points_ys, bool closedShape = true);
}
;

class WXDLLIMPEXP_MATHPLOT mpBitmapLayer : public mpLayer {
public:
  mpBitmapLayer() {
    m_min_x = m_max_x = m_min_y = m_max_y = 0;
    m_validImg = false;
    m_type = mpLAYER_BITMAP;
  }

  virtual ~mpBitmapLayer(){};

  void GetBitmapCopy(wxImage &outBmp) const;

  void SetBitmap(const wxImage &inBmp, double x, double y, double lx,
                 double ly);

  virtual bool HasBBox() { return true; }

  virtual double GetMinX() { return m_min_x; }"
googlei18n-noto-emoji-6a609ec/third_party/pngquant/lib/mediancut.c	Weighted per-channel variance of the box. It's used to decide which channel to split by	2	"static f_pixel box_variance(const hist_item achv[], const struct box *box) {
  f_pixel mean = box->color;
  double variancea = 0, variancer = 0, varianceg = 0, varianceb = 0;

  for (unsigned int i = 0; i < box->colors; ++i) {
    f_pixel px = achv[box->ind + i].acolor;
    double weight = achv[box->ind + i].adjusted_weight;
    variancea += variance_diff(mean.a - px.a, 2.0 / 256.0) * weight;
    variancer += variance_diff(mean.r - px.r, 1.0 / 256.0) * weight;
    varianceg += variance_diff(mean.g - px.g, 1.0 / 256.0) * weight;
    varianceb += variance_diff(mean.b - px.b, 1.0 / 256.0) * weight;
  }

  return (f_pixel){
      .a = variancea * (4.0 / 16.0),
      .r = variancer * (7.0 / 16.0),
      .g = varianceg * (9.0 / 16.0),
      .b = varianceb * (5.0 / 16.0),
  };
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_epi8(char __b31, char __b30, char __b29, char __b28, char __b27,
                 char __b26, char __b25, char __b24, char __b23, char __b22,
                 char __b21, char __b20, char __b19, char __b18, char __b17,
                 char __b16, char __b15, char __b14, char __b13, char __b12,
                 char __b11, char __b10, char __b09, char __b08, char __b07,
                 char __b06, char __b05, char __b04, char __b03, char __b02,
                 char __b01, char __b00) {
  return (__m256i)(__v32qi){__b31, __b30, __b29, __b28, __b27, __b26, __b25,
                            __b24, __b23, __b22, __b21, __b20, __b19, __b18,
                            __b17, __b16, __b15, __b14, __b13, __b12, __b11,
                            __b10, __b09, __b08, __b07, __b06, __b05, __b04,
                            __b03, __b02, __b01, __b00};
}"
UniStuttgart-VISUS-megamol-1d960a6/plugins/OSPRay_plugin/src/Pkd.h	build particle tree over given model. WILL REORDER THE MODEL'S ELEMENTS	2	"maxInLevel = other.maxInLevel;
current = other.current;
return *this;
}
}
;

struct PKDBuildJob {
  const PkdBuilder *const pkd;
  const size_t nodeID;
  const ospcommon::box3f bounds;
  const size_t depth;
  __forceinline PKDBuildJob(const PkdBuilder *pkd, size_t nodeID,
                            ospcommon::box3f bounds, size_t depth)
      : pkd(pkd), nodeID(nodeID), bounds(bounds), depth(depth){};
};

static void pkdBuildThread(void *arg) {
  PKDBuildJob *job = (PKDBuildJob *)arg;
  job->pkd->buildRec(job->nodeID, job->bounds, job->depth);
  delete job;
}
}
}"
Proxmark-proxmark3-fdd9395/client/cmdhf15.c	Commandline handling: HF15 CMD SYSINFO get system information from tag/VICC	1	"int CmdHF15CmdSysinfo(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[2048] = """";
  int i;

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 1) {
    PrintAndLog(""Usage:  hf 15 cmd sysinfo    [options] <uid|s|u|*>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           start#:       page number to start 0-255"");
    PrintAndLog(""           count#:       number of pages"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15693_GET_SYSTEM_INFO}, 1);
  reqlen = c.arg[0];

  reqlen = AddCrc(req, reqlen);
  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15693_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15693_RES_ERROR)) {
        *output = 0;
        PrintAndLog(""UID:               %s"", sprintUID(NULL, recv + 2));
        PrintAndLog(""Manufacturer byte: %02X, %s"", recv[8],
                    getManufacturerName(recv[8]));
        PrintAndLog(""Chip ID:           %02X, %s"", recv[7],
                    getChipInfo(recv[8], recv[7]));
        i = 10;
        if (recv[1] & 0x01)
          sprintf(output + strlen(output), ""DSFID supported, set to %02X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""DSFID not supported\n\r"");
        if (recv[1] & 0x02)
          sprintf(output + strlen(output), ""AFI supported, set to %03X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""AFI not supported\n\r"");
        if (recv[1] & 0x04) {
          strcat(output,
                 ""Tag provides info on memory layout (vendor dependent)\n\r"");
          sprintf(output + strlen(output),
                  "" %i (or %i) bytes/page x %i pages \n\r"",
                  (recv[i + 1] & 0x1F) + 1, (recv[i + 1] & 0x1F), recv[i] + 1);
          i += 2;
        } else
          strcat(output,
                 ""Tag does not provide information on memory layout\n\r"");
        if (recv[1] & 0x08)
          sprintf(output + strlen(output), ""IC reference given: %02X\n\r"",
                  recv[i++]);
        else
          strcat(output, ""IC reference not given\n\r"");

        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[0], TagErrorStr(recv[0]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""timeout: no answer"");
  }

  return 0;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/test_case_T.c	Set pde related parameters.	2	"static void set_pde_related(struct Test_Case_T *test_case,
                            const struct Simulation *sim) {
  switch (test_case->pde_index) {
  case PDE_ADVECTION:
    const_cast_b(&test_case->is_linear, true);
    const_cast_i(&test_case->n_var, 1);
    const_cast_i(&test_case->n_eq, 1);
    const_cast_b(&test_case->has_1st_order, true);
    const_cast_b(&test_case->has_2nd_order, false);
    break;
  case PDE_DIFFUSION:
    const_cast_b(&test_case->is_linear, true);
    const_cast_i(&test_case->n_var, 1);
    const_cast_i(&test_case->n_eq, 1);
    const_cast_b(&test_case->has_1st_order, false);
    const_cast_b(&test_case->has_2nd_order, true);
    break;
  case PDE_EULER:
    const_cast_b(&test_case->is_linear, false);
    const_cast_i(&test_case->n_var, DIM + 2);
    const_cast_i(&test_case->n_eq, DIM + 2);
    const_cast_b(&test_case->has_1st_order, true);
    const_cast_b(&test_case->has_2nd_order, false);
    break;
  case PDE_NAVIER_STOKES:
    const_cast_b(&test_case->is_linear, false);
    const_cast_i(&test_case->n_var, DIM + 2);
    const_cast_i(&test_case->n_eq, DIM + 2);
    const_cast_b(&test_case->has_1st_order, true);
    const_cast_b(&test_case->has_2nd_order, true);
    break;
  case PDE_BURGERS_INVISCID:
    const_cast_b(&test_case->is_linear, false);
    const_cast_i(&test_case->n_var, DIM);
    const_cast_i(&test_case->n_eq, DIM);
    const_cast_b(&test_case->has_1st_order, true);
    const_cast_b(&test_case->has_2nd_order, false);
    break;
  default:
    EXIT_ERROR(""Unsupported: %d\n"", test_case->pde_index);
    break;
  }
  get_set_n_var_eq((int[]){test_case->n_var, test_case->n_eq});
  get_set_has_1st_2nd_order(
      (bool[]){test_case->has_1st_order, test_case->has_2nd_order});

  const bool *flux_comp_mem_e =
                 get_compute_member_Flux_Input('e', test_case, sim),
             *flux_comp_mem_i =
                 get_compute_member_Flux_Input('i', test_case, sim);
  for (int i = 0; i < MAX_FLUX_OUT; ++i) {
    const_cast_b(&test_case->flux_comp_mem_e[i], flux_comp_mem_e[i]);
    const_cast_b(&test_case->flux_comp_mem_i[i], flux_comp_mem_i[i]);
  }

  const bool *boundary_value_comp_mem_e =
                 get_compute_member_Boundary_Value_Input('e', test_case, sim),
             *boundary_value_comp_mem_i =
                 get_compute_member_Boundary_Value_Input('i', test_case, sim);
  for (int i = 0; i < MAX_BV_OUT; ++i) {
    const_cast_b(&test_case->boundary_value_comp_mem_e[i],
                 boundary_value_comp_mem_e[i]);
    const_cast_b(&test_case->boundary_value_comp_mem_i[i],
                 boundary_value_comp_mem_i[i]);
  }
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/user-macro.c	"Syntax: macro name type [precedence] ... The rest of the arguments form the macro definition, which behave as documented in the Syntax III section of the spec. The visibility of the resulting symbol is intrinsic to the macro, derived from *(ava_visibility*)userdata on the self symbol."	2	"ava_macro_subst_result
ava_intr_user_macro_subst(const ava_symbol *self, ava_macsub_context *context,
                          const ava_parse_statement *statement,
                          const ava_parse_unit *provoker,
                          ava_bool *consumed_other_statements) {
  AVA_STATIC_STRING(out_of_range, ""Out of legal range."");
  ava_exception ex;
  const ava_parse_unit *name_unit = NULL, *type_unit, *precedence_unit;
  const ava_parse_unit *definition_begin = NULL;
  ava_string name, type_str, precedence_str;
  ava_symbol_type type = -1;
  ava_integer precedence = -1;
  ava_pcode_macro_list *body;
  ava_ast_node *this;
  ava_visibility visibility;

  visibility = *(const ava_visibility *)self->v.macro.userdata;

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN {
      AVA_MACRO_ARG_CURRENT_UNIT(name_unit, ""name"");
      AVA_MACRO_ARG_BAREWORD(name, ""name"");
      AVA_MACRO_ARG_CURRENT_UNIT(type_unit, ""type"");
      AVA_MACRO_ARG_BAREWORD(type_str, ""type"");

      switch (ava_string_to_ascii9(type_str)) {
      case AVA_ASCII9('e', 'x', 'p', 'a', 'n', 'd'):
        type = ava_st_expander_macro;
        break;

      case AVA_ASCII9('c', 'o', 'n', 't', 'r', 'o', 'l'):
        type = ava_st_control_macro;
        break;

      case AVA_ASCII9('o', 'p'):
        type = ava_st_operator_macro;
        break;

      case AVA_ASCII9('f', 'u', 'n'):
        type = ava_st_function_macro;
        break;

      default:
        return ava_macsub_error_result(
            context, ava_error_bad_macro_type(&type_unit->location, type_str));
      }

      if (ava_st_operator_macro == type) {
        ava_intr_user_macro_cvt_prec_data data;
        AVA_MACRO_ARG_CURRENT_UNIT(precedence_unit, ""precedence"");
        AVA_MACRO_ARG_BAREWORD(precedence_str, ""precedence"");

        data.str = precedence_str;
        if (ava_catch(&ex, ava_intr_user_macro_cvt_prec, &data)) {
          if (&ava_format_exception == ex.type) {
            return ava_macsub_error_result(
                context, ava_error_bad_macro_precedence(
                             &precedence_unit->location, precedence_str,
                             ava_to_string(ava_exception_get_value(&ex))));
          } else {
            ava_rethrow(ex);
          }
        }
        precedence = data.ret;

        if (precedence < 1 || precedence > AVA_MAX_OPERATOR_MACRO_PRECEDENCE)
          return ava_macsub_error_result(
              context,
              ava_error_bad_macro_precedence(&precedence_unit->location,
                                             precedence_str, out_of_range));
      } else {
        precedence = 0;
      }

      AVA_MACRO_ARG_UNIT(definition_begin, ""macro definition"");
      AVA_MACRO_ARG_FOR_REST { AVA_MACRO_ARG_CONSUME(); }
    }
  }

  assert(-1 != precedence);
  assert(-1 != (signed)type);
  assert(definition_begin);
  assert(name_unit);

  body = ava_intr_user_macro_make_body(context, definition_begin, visibility);
  this =
      ava_intr_user_macro_put(context, type, visibility, name, precedence, body,
                              &provoker->location, &name_unit->location);

  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v = {.node = this},
  };
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"This helper returns a temporary String with the subscription's channel (or a string representing the filter). To keep the string beyond the lifetime of the subscription, copy the string."	2	"fio_str_info_s fio_subscription_channel(subscription_s *subscription) {
  return (fio_str_info_s){.data = subscription->parent->name,
                          .len = subscription->parent->name_len};
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer."	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, BufferPtr);
}"
boazsegev-iodine-b6bdf50/ext/iodine/http.c	Sends the response headers and the specified file (the response's body). Returns -1 eton error and 0 on success.	2	"int http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,
                   const char *encoded, size_t encoded_len) {
  if (HTTP_INVALID_HANDLE(h))
    return -1;
  struct stat file_data = {.st_size = 0};
  static uint64_t accept_enc_hash = 0;
  if (!accept_enc_hash)
    accept_enc_hash = fiobj_hash_string(""accept-encoding"", 15);
  static uint64_t range_hash = 0;
  if (!range_hash)
    range_hash = fiobj_hash_string(""range"", 5);

  FIOBJ filename = fiobj_str_tmp();
  if (prefix && prefix_len) {

    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')
      --prefix_len;
    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);
    fiobj_str_write(filename, prefix, prefix_len);
  }
  {

    fio_str_info_s tmp = fiobj_obj2cstr(filename);
    if (encoded) {
      char *pos = (char *)encoded;
      const char *end = encoded + encoded_len;
      while (pos < end) {

        if (*pos == '/' && (pos[1] == '/' ||
                            (((uintptr_t)end - (uintptr_t)pos >= 4) &&
                             pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))
          return -1;
        if (*pos == '%') {

          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))
            return -1;
          tmp.len++;
          pos += 3;
        } else
          tmp.data[tmp.len++] = *(pos++);
      }
      tmp.data[tmp.len] = 0;
      fiobj_str_resize(filename, tmp.len);
    }
    if (tmp.data[tmp.len - 1] == '/')
      fiobj_str_write(filename, ""index.html"", 10);
  }

  int file = -1;
  uint8_t is_gz = 0;

  fio_str_info_s s = fiobj_obj2cstr(filename);
  {
    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);
    if (!tmp)
      goto no_gzip_support;
    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);
    if (!ac_str.data || !strstr(ac_str.data, ""gzip""))
      goto no_gzip_support;
    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||
        s.data[s.len - 1] != 'z') {
      fiobj_str_write(filename, "".gz"", 3);
      s = fiobj_obj2cstr(filename);
      if (!stat(s.data, &file_data) &&
          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {
        is_gz = 1;
        goto found_file;
      }
      fiobj_str_resize(filename, s.len - 3);
    }
  }
no_gzip_support:
  if (stat(s.data, &file_data) ||
      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))
    return -1;
found_file :

{
  FIOBJ tmp = fiobj_str_buf(32);
  fiobj_str_resize(tmp,
                   http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));
  http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);
}

  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));

  uint64_t etag = (uint64_t)file_data.st_size;
  etag ^= (uint64_t)file_data.st_mtime;
  etag = fiobj_hash_string(&etag, sizeof(uint64_t));
  FIOBJ etag_str = fiobj_str_buf(32);
  fiobj_str_resize(etag_str,
                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,
                                     (void *)&etag, sizeof(uint64_t)));

  http_set_header(h, HTTP_HEADER_ETAG, etag_str);

  {
    static uint64_t none_match_hash = 0;
    if (!none_match_hash)
      none_match_hash = fiobj_hash_string(""if-none-match"", 13);
    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);
    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {
      h->status = 304;
      http_finish(h);
      return 0;
    }
  }

  int64_t offset = 0;
  int64_t length = file_data.st_size;
  {
    static uint64_t ifrange_hash = 0;
    if (!ifrange_hash)
      ifrange_hash = fiobj_hash_string(""if-range"", 8);
    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);
    if (tmp && fiobj_iseq(tmp, etag_str)) {
      fiobj_hash_delete2(h->headers, range_hash);
    } else {
      tmp = fiobj_hash_get2(h->headers, range_hash);
      if (tmp) {

        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))
          tmp = fiobj_ary_index(tmp, 0);
        fio_str_info_s range = fiobj_obj2cstr(tmp);
        if (!range.data || memcmp(""bytes="", range.data, 6))
          goto open_file;
        char *pos = range.data + 6;
        int64_t start_at = 0, end_at = 0;
        start_at = fio_atol(&pos);
        if (start_at >= file_data.st_size)
          goto open_file;
        if (start_at >= 0) {
          pos++;
          end_at = fio_atol(&pos);
          if (end_at <= 0)
            goto open_file;
        }

        if (start_at < 0) {
          if (0 - start_at < file_data.st_size) {
            offset = file_data.st_size - start_at;
            length = 0 - start_at;
          }
        } else if (end_at) {
          offset = start_at;
          length = end_at - start_at + 1;
          if (length + start_at > file_data.st_size || length <= 0)
            length = length - start_at;
        } else {
          offset = start_at;
          length = length - start_at;
        }
        h->status = 206;

        {
          FIOBJ cranges = fiobj_str_buf(1);
          fiobj_str_printf(cranges, ""bytes %lu-%lu/%lu"",
                           (unsigned long)start_at,
                           (unsigned long)(start_at + length - 1),
                           (unsigned long)file_data.st_size);
          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);
        }
        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,
                        fiobj_dup(HTTP_HVALUE_BYTES));
      }
    }
  }

  s = fiobj_obj2cstr(h->method);
  switch (s.len) {
  case 7:
    if (!strncasecmp(""options"", s.data, 7)) {
      http_set_header2(h, (fio_str_info_s){.data = (char *)""allow"", .len = 5},
                       (fio_str_info_s){.data = (char *)""GET, HEAD"", .len = 9});
      h->status = 200;
      http_finish(h);
      return 0;
    }
    break;
  case 3:
    if (!strncasecmp(""get"", s.data, 3))
      goto open_file;
    break;
  case 4:
    if (!strncasecmp(""head"", s.data, 4)) {
      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));
      http_finish(h);
      return 0;
    }
    break;
  }
  http_send_error(h, 403);
  return 0;
open_file:
  s = fiobj_obj2cstr(filename);
  file = open(s.data, O_RDONLY);
  if (file == -1) {
    FIO_LOG_ERROR(""(HTTP) couldn't open file %s!\n"", s.data);
    perror(""     "");
    http_send_error(h, 500);
    return 0;
  }
  {
    FIOBJ tmp = 0;
    uintptr_t pos = 0;
    if (is_gz) {
      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,
                      fiobj_dup(HTTP_HVALUE_GZIP));

      pos = s.len - 4;
      while (pos && s.data[pos] != '.')
        pos--;
      pos++;
      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);

    } else {
      pos = s.len - 1;
      while (pos && s.data[pos] != '.')
        pos--;
      pos++;
      tmp = http_mimetype_find(s.data + pos, s.len - pos);
    }
    if (tmp)
      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);
  }
  http_sendfile(h, file, length, offset);
  return 0;
}"
nanoporetech-scrappie-4b52d12/src/scrappie_common.c	Simple segmentation of a raw read by thresholding the MAD The MAD of the raw signal is calculated for non-overlapping chunks and then thresholded to find regions at the beginning and end of the signal that have unusually low variation (generally a stall or open pore). The threshhold is derived from the distribution of the calaculated MADs. The threshold is chosen to be high since a single chunk above it will trigger the end of the trimming: the threshhold is chosen so it is unlikely to be exceeded in the leader but commonly exceeded in the main read.	2	"raw_table trim_raw_by_mad(raw_table rt, size_t chunk_size, float perc) {
  assert(chunk_size > 1);
  assert(perc >= 0.0 && perc <= 1.0);

  const size_t nsample = rt.end - rt.start;
  const size_t nchunk = nsample / chunk_size;

  rt.end = nchunk * chunk_size;

  float *madarr = malloc(nchunk * sizeof(float));
  RETURN_NULL_IF(NULL == madarr, (raw_table){0});
  for (size_t i = 0; i < nchunk; i++) {
    madarr[i] = madf(rt.raw + rt.start + i * chunk_size, chunk_size, NULL);
  }
  quantilef(madarr, nchunk, &perc, 1);

  const float thresh = perc;
  for (size_t i = 0; i < nchunk; i++) {
    if (madarr[i] > thresh) {
      break;
    }
    rt.start += chunk_size;
  }
  for (size_t i = nchunk; i > 0; i--) {
    if (madarr[i - 1] > thresh) {
      break;
    }
    rt.end -= chunk_size;
  }
  assert(rt.end > rt.start);

  free(madarr);

  return rt;
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  MPADecodeHeader c;
  int vbrtag_size = 0;
  MP3DecContext *mp3 = s->priv_data;

  ffio_init_checksum(s->pb, ff_crcA001_update, 0);

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (avpriv_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  mp3->frames = 0;
  mp3->header_filesize = 0;

  mp3_parse_info_tag(s, st, &c, spf);
  mp3_parse_vbri_tag(s, st, base);

  if (!mp3->frames && !mp3->header_filesize)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (mp3->frames)
    st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                st->time_base);
  if (mp3->header_filesize && mp3->frames && !mp3->is_cbr)
    st->codec->bit_rate = av_rescale(mp3->header_filesize, 8 * c.sample_rate,
                                     mp3->frames * (int64_t)spf);

  return 0;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	"Constructs a 128-bit floating-point vector of [2 x double], with each of the two double-precision floating-point vector elements set to the specified double-precision floating-point value."	2	"_mm_set1_pd(double __w) { return __extension__(__m128d){__w, __w}; }"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command."	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3,
              short __w2, short __w1, short __w0) {
  return (__m128i)(__v8hi){__w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7};
}"
espressif-esp-idf-a121847/components/driver/spi_master.c	"This initializes the internal structures for a device, plus allocates a CS pin on the indicated SPI master peripheral and routes it to the indicated GPIO. All SPI master devices have three CS pins and can thus control up to three devices."	0	"esp_err_t spi_bus_add_device(spi_host_device_t host,
                             const spi_device_interface_config_t *dev_config,
                             spi_device_handle_t *handle) {
  int freecs;
  int apbclk = APB_CLK_FREQ;
  int eff_clk;
  int duty_cycle;
  int dummy_required;
  int miso_delay;

  spi_clock_reg_t clk_reg;
  SPI_CHECK(host >= SPI_HOST && host <= VSPI_HOST, ""invalid host"",
            ESP_ERR_INVALID_ARG);
  SPI_CHECK(spihost[host] != NULL, ""host not initialized"",
            ESP_ERR_INVALID_STATE);
  SPI_CHECK(dev_config->spics_io_num < 0 ||
                GPIO_IS_VALID_OUTPUT_GPIO(dev_config->spics_io_num),
            ""spics pin invalid"", ESP_ERR_INVALID_ARG);
  SPI_CHECK(dev_config->clock_speed_hz > 0, ""invalid sclk speed"",
            ESP_ERR_INVALID_ARG);
  for (freecs = 0; freecs < NO_CS; freecs++) {

    void *null = NULL;
    if (atomic_compare_exchange_strong(&spihost[host]->device[freecs], &null,
                                       (spi_device_t *)1))
      break;
  }
  SPI_CHECK(freecs != NO_CS, ""no free cs pins for host"", ESP_ERR_NOT_FOUND);

  SPI_CHECK(
      dev_config->cs_ena_pretrans <= 1 ||
          (dev_config->address_bits == 0 && dev_config->command_bits == 0) ||
          (dev_config->flags & SPI_DEVICE_HALFDUPLEX),
      ""In full-duplex mode, only support cs pretrans delay = 1 and without ""
      ""address_bits and command_bits"",
      ESP_ERR_INVALID_ARG);

  duty_cycle =
      (dev_config->duty_cycle_pos == 0) ? 128 : dev_config->duty_cycle_pos;
  eff_clk = spi_cal_clock(apbclk, dev_config->clock_speed_hz, duty_cycle,
                          (uint32_t *)&clk_reg);
  int freq_limit = spi_get_freq_limit(
      !(spihost[host]->flags & SPICOMMON_BUSFLAG_NATIVE_PINS),
      dev_config->input_delay_ns);

  spi_get_timing(!(spihost[host]->flags & SPICOMMON_BUSFLAG_NATIVE_PINS),
                 dev_config->input_delay_ns, eff_clk, &dummy_required,
                 &miso_delay);
  SPI_CHECK(
      dev_config->flags & SPI_DEVICE_HALFDUPLEX || dummy_required == 0 ||
          dev_config->flags & SPI_DEVICE_NO_DUMMY,
      ""When work in full-duplex mode at frequency > %.1fMHz, device cannot read correct data.\n\
Try to use IOMUX pins to increase the frequency limit, or use the half duplex mode.\n\
Please note the SPI master can only work at divisors of 80MHz, and the driver always tries to find the closest frequency to your configuration.\n\
Specify ``SPI_DEVICE_NO_DUMMY`` to ignore this checking. Then you can output data at higher speed, or read data at your own risk."",
      ESP_ERR_INVALID_ARG, freq_limit / 1000. / 1000);

  spi_device_t *dev = malloc(sizeof(spi_device_t));
  if (dev == NULL)
    goto nomem;
  memset(dev, 0, sizeof(spi_device_t));
  atomic_store(&spihost[host]->device[freecs], dev);
  dev->id = freecs;
  dev->waiting = false;

  dev->trans_queue =
      xQueueCreate(dev_config->queue_size, sizeof(spi_trans_priv_t));
  dev->ret_queue =
      xQueueCreate(dev_config->queue_size, sizeof(spi_trans_priv_t));
  dev->semphr_polling = xSemaphoreCreateBinary();
  if (!dev->trans_queue || !dev->ret_queue || !dev->semphr_polling) {
    goto nomem;
  }
  dev->host = spihost[host];

  memcpy(&dev->cfg, dev_config, sizeof(spi_device_interface_config_t));
  dev->cfg.duty_cycle_pos = duty_cycle;

  dev->clk_cfg = (clock_config_t){
      .eff_clk = eff_clk,
      .dummy_num = dummy_required,
      .reg = clk_reg,
      .miso_delay = miso_delay,
  };

  if (dev_config->spics_io_num >= 0) {
    spicommon_cs_initialize(
        host, dev_config->spics_io_num, freecs,
        !(spihost[host]->flags & SPICOMMON_BUSFLAG_NATIVE_PINS));
  }
  if (dev_config->flags & SPI_DEVICE_CLK_AS_CS) {
    spihost[host]->hw->pin.master_ck_sel |= (1 << freecs);
  } else {
    spihost[host]->hw->pin.master_ck_sel &= (1 << freecs);
  }
  if (dev_config->flags & SPI_DEVICE_POSITIVE_CS) {
    spihost[host]->hw->pin.master_cs_pol |= (1 << freecs);
  } else {
    spihost[host]->hw->pin.master_cs_pol &= (1 << freecs);
  }
  spihost[host]->hw->ctrl2.mosi_delay_mode = 0;
  spihost[host]->hw->ctrl2.mosi_delay_num = 0;
  *handle = dev;
  ESP_LOGD(SPI_TAG, ""SPI%d: New device added to CS%d, effective clock: %dkHz"",
           host + 1, freecs, dev->clk_cfg.eff_clk / 1000);
  return ESP_OK;

nomem:
  if (dev) {
    if (dev->trans_queue)
      vQueueDelete(dev->trans_queue);
    if (dev->ret_queue)
      vQueueDelete(dev->ret_queue);
    if (dev->semphr_polling)
      vSemaphoreDelete(dev->semphr_polling);
  }
  free(dev);
  return ESP_ERR_NO_MEM;
}"
Legacy-Xperia-android_device_sony_kumquat-ace181e/hardware/media/libomxil-bellagio/extern_components/ffmpeg-dist/src/omx_videoenc_component.c	"It initializates the FFmpeg framework, and opens an FFmpeg videoencoder of type specified by IL client"	2	"OMX_ERRORTYPE omx_videoenc_component_ffmpegLibInit(
    omx_videoenc_component_PrivateType *omx_videoenc_component_Private) {

  omx_base_video_PortType *inPort =
      (omx_base_video_PortType *)omx_videoenc_component_Private
          ->ports[OMX_BASE_FILTER_INPUTPORT_INDEX];
  OMX_U32 target_coencID;
  avcodec_init();
  av_register_all();

  DEBUG(DEB_LEV_SIMPLE_SEQ, ""FFmpeg library/encoder initialized\n"");

  switch (omx_videoenc_component_Private->video_encoding_type) {
  case OMX_VIDEO_CodingMPEG4:
    target_coencID = CODEC_ID_MPEG4;
    break;
  default:
    DEBUG(DEB_LEV_ERR, ""\n encoders other than MPEG-4 are not supported -- ""
                       ""encoder not found\n"");
    return OMX_ErrorComponentNotFound;
  }

  omx_videoenc_component_Private->avCodec =
      avcodec_find_encoder(target_coencID);
  if (omx_videoenc_component_Private->avCodec == NULL) {
    DEBUG(DEB_LEV_ERR, ""Encoder Not found\n"");
    return OMX_ErrorInsufficientResources;
  }

  omx_videoenc_component_Private->avCodecContext = avcodec_alloc_context();
  omx_videoenc_component_Private->picture = avcodec_alloc_frame();

  omx_videoenc_component_Private->avCodecContext->bit_rate = 200000;
  omx_videoenc_component_Private->avCodecContext->bit_rate_tolerance = 4000000;
  omx_videoenc_component_Private->avCodecContext->width =
      inPort->sPortParam.format.video.nFrameWidth;
  omx_videoenc_component_Private->avCodecContext->height =
      inPort->sPortParam.format.video.nFrameHeight;

  DEBUG(DEB_LEV_SIMPLE_SEQ, ""Frame Rate=%d\n"",
        (int)inPort->sPortParam.format.video.xFramerate);
  omx_videoenc_component_Private->avCodecContext->time_base =
      (AVRational){1, inPort->sPortParam.format.video.xFramerate};
  omx_videoenc_component_Private->avCodecContext->gop_size =
      omx_videoenc_component_Private->pVideoMpeg4.nPFrames + 1;
  omx_videoenc_component_Private->avCodecContext->pix_fmt = PIX_FMT_YUV420P;
  omx_videoenc_component_Private->avCodecContext->strict_std_compliance =
      FF_COMPLIANCE_NORMAL;
  omx_videoenc_component_Private->avCodecContext->sample_fmt = SAMPLE_FMT_S16;
  omx_videoenc_component_Private->avCodecContext->qmin = 2;
  omx_videoenc_component_Private->avCodecContext->qmax = 31;
  omx_videoenc_component_Private->avCodecContext->workaround_bugs |=
      FF_BUG_AUTODETECT;

  if (omx_videoenc_component_Private->pVideoMpeg4.eProfile ==
      OMX_VIDEO_MPEG4ProfileAdvancedScalable) {
    omx_videoenc_component_Private->avCodecContext->max_b_frames =
        omx_videoenc_component_Private->pVideoMpeg4.nBFrames;
  }

  if (omx_videoenc_component_Private->pVideoMpeg4.bACPred == OMX_TRUE) {
    omx_videoenc_component_Private->avCodecContext->flags |= CODEC_FLAG_AC_PRED;
  }

#if 0  
  switch(omx_videoenc_component_Private->pVideoMpeg4.eLevel) {
  case OMX_VIDEO_MPEG4Level0:                    
  case OMX_VIDEO_MPEG4Level0b:                   
  case OMX_VIDEO_MPEG4Level1:                    
  case OMX_VIDEO_MPEG4Level2:                    
  case OMX_VIDEO_MPEG4Level3:                    
  case OMX_VIDEO_MPEG4Level4:                    
  case OMX_VIDEO_MPEG4Level4a:                   
  case OMX_VIDEO_MPEG4Level5:                    
  case default:
    break;
  }
#endif
  if (avcodec_open(omx_videoenc_component_Private->avCodecContext,
                   omx_videoenc_component_Private->avCodec) < 0) {
    DEBUG(DEB_LEV_ERR, ""Could not open encoder\n"");
    return OMX_ErrorInsufficientResources;
  }
  DEBUG(DEB_LEV_SIMPLE_SEQ, ""done\n"");

  return OMX_ErrorNone;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;

    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
GargoyleSoftware-voip-client-ios-134091a/submodules/externals/ffmpeg/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->input_count; i++) {
    AVFilterLink *link = filter->inputs[i];

    if (!link)
      continue;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props))
        config_link = avfilter_default_config_output_link;
      if ((ret = config_link(link)) < 0)
        return ret;

      if (link->time_base.num == 0 && link->time_base.den == 0)
        link->time_base = link->src && link->src->input_count
                              ? link->src->inputs[0]->time_base
                              : AV_TIME_BASE_Q;

      if (link->sample_aspect_ratio.num == 0 &&
          link->sample_aspect_ratio.den == 0)
        link->sample_aspect_ratio =
            link->src->input_count ? link->src->inputs[0]->sample_aspect_ratio
                                   : (AVRational){1, 1};

      if (link->sample_rate == 0 && link->src && link->src->input_count)
        link->sample_rate = link->src->inputs[0]->sample_rate;

      if (link->channel_layout == 0 && link->src && link->src->input_count)
        link->channel_layout = link->src->inputs[0]->channel_layout;

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0)
          return ret;

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/v0.1/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/PrinterClassHost.c	"Retrieves the attached printer device's ID string, formatted according to IEEE 1284. This string is sent as a Unicode string from the device and is automatically converted to an ASCII encoded C string by this function, thus the maximum reportable string length is two less than the size given (to accommodate the Unicode string length bytes which are removed). This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device."	0	"uint8_t
PRNT_Host_GetDeviceID(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                      char *const DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = be16_to_cpu(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
Naios-continuable-67d7780/include/continuable/detail/core/base.hpp	Returns the next hint when the callback is invoked with the given hint.	2	"next_hint_of(std::integral_constant<handle_results, handle_results::yes>,
             identity<T>, identity<Args...>) {

  using Result = decltype(decoration::invoke_callback(std::declval<T>(),
                                                      std::declval<Args>()...));

  return decltype(decoration::invoker_of(identify<Result>{}).hint()){};
}"
ADLINK-IST-opensplice-f7cff58/src/tools/idlpp/code/idl_genCorbaCCopyin.c	Generate the body for copying an array element.	2	"idl_arrayLoopCopyBody(idl_typeArray typeArray, idl_typeSpec typeSpec,
                      const char *from, const char *to, c_long indent,
                      idl_scope scope, const char *name,
                      os_boolean stacRequested, os_boolean catsRequested,
                      os_boolean noTypeCaching) {
  idl_typeSpec nextType;
  c_char source[256];
  c_char destin[256];
  c_char *typeName;
  c_char *scopedName;
  c_long total_indent;
  c_ulong maxlen;

  loopIndent++;
  switch (idl_typeSpecType(typeSpec)) {
  case idl_tstruct:
  case idl_tunion:
    scopedName = idl_scopedTypeName(typeSpec);

    DEBUG_INFO;
    idl_printIndent(loopIndent + indent);
    varIndex = 0;
    fileOut(file, ""if (V_COPYIN_RESULT_IS_OK(result)) {\n"");
    idl_printIndent(loopIndent + indent);
    fileOut(file,
            ""    extern v_copyin_result __%s__copyIn(c_base, const void *, ""
            ""void *);\n"",
            scopedName);
    idl_printIndent(loopIndent + indent);
    fileOut(file, ""    result = __%s__copyIn(base, (%s *)&(%s)"", scopedName,
            idl_corbaCTypeFromTypeSpec(typeSpec), from);
    idl_arrayLoopCopyIndex(typeArray);
    fileOut(file, "", (%s *)&(*%s)"", idl_scopedSplTypeName(typeSpec), to);
    idl_arrayLoopCopyIndex(typeArray);
    fileOut(file, "");\n"");
    idl_printIndent(loopIndent + indent);
    fileOut(file, ""}\n"");
    break;
  case idl_ttypedef:
    if (stacRequested) {

      if (idl_typeSpecType(idl_typeDefActual(idl_typeDef(typeSpec))) ==
          idl_tarray) {

        idl_arrayElements(
            scope, name,
            idl_typeArray(idl_typeDefActual(idl_typeDef(typeSpec))), from, to,
            indent, stacRequested, catsRequested, noTypeCaching);
      } else {
        idl_arrayLoopCopyBody(
            typeArray, idl_typeDefActual(idl_typeDef(typeSpec)), from, to,
            indent, scope, name, stacRequested, catsRequested, noTypeCaching);
      }
    } else {
      switch (idl_typeSpecType(idl_typeDefActual(idl_typeDef(typeSpec)))) {
      case idl_tstruct:
      case idl_tunion:
      case idl_tarray:
      case idl_tseq:
        scopedName = idl_scopedTypeName(typeSpec);

        DEBUG_INFO;
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""if(V_COPYIN_RESULT_IS_OK(result)){\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file,
                ""    extern v_copyin_result __%s__copyIn(c_base, const void *, ""
                ""void *);\n"",
                scopedName);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""    result = __%s__copyIn(base, (%s *)&(%s)"", scopedName,
                idl_corbaCTypeFromTypeSpec(typeSpec), from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "", (%s *)&(*%s)"", idl_scopedSplTypeName(typeSpec), to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "");\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""}\n"");
        break;
      case idl_tbasic:
        if (idl_typeBasicType(idl_typeBasic(
                idl_typeDefActual(idl_typeDef(typeSpec)))) == idl_string) {
          maxlen = idl_typeBasicMaxlen(
              idl_typeBasic(idl_typeDefActual(idl_typeDef(typeSpec))));

          DEBUG_INFO;
          fileOut(file, ""#ifdef %s\n"", BOUNDSCHECK);
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""if(V_COPYIN_RESULT_IS_OK(result)){\n"");
          indent++;
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""if((%s)"", from);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, ""){\n"");
          idl_printIndent(loopIndent + indent);
          if (maxlen != 0) {
            DEBUG_INFO;
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    if(((unsigned int)strlen((%s)"", from);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "")) <= %u){\n"", maxlen);
            idl_printIndent(loopIndent + indent);
            if (stacRequested) {
              fileOut(file, ""        strncpy(((*%s)"", to);
              idl_arrayLoopCopyIndex(typeArray);
              fileOut(file, ""), ((%s)"", from);
              idl_arrayLoopCopyIndex(typeArray);
              fileOut(file, ""), %u);\n"", (maxlen + 1));
            } else {
              fileOut(file, ""        (*%s)"", to);
              idl_arrayLoopCopyIndex(typeArray);
              fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
              idl_arrayLoopCopyIndex(typeArray);
              fileOut(file, "");\n"");
              idl_printIndent(loopIndent + indent);
              fileOut(file, ""        if ((*%s)"", to);
              idl_arrayLoopCopyIndex(typeArray);
              fileOut(file, "" == NULL) {\n"");
              idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                                    loopIndent + indent + 1);
              idl_printIndent(loopIndent + indent);
              fileOut(file,
                      ""            result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
              idl_printIndent(loopIndent + indent);
              fileOut(file, ""        }\n"");
            }
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    } else {\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""        "");
            idl_boundsCheckFail(ELEMENT, scope, (idl_typeSpec)typeSpec, name);
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""        result = V_COPYIN_RESULT_INVALID;\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    }\n"");
          } else {
            DEBUG_INFO;
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    (*%s)"", to);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "");\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""if ((*%s)"", to);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "" == NULL) {\n"");
            idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                                  loopIndent + indent + 1);
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""}\n"");
          }
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""} else {\n"");
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""    "");
          idl_boundsCheckFailNull(ELEMENT, scope, (idl_typeSpec)typeSpec, name);
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""    result = V_COPYIN_RESULT_INVALID;\n"");
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""}\n"");
          indent--;
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""}\n"");
          fileOut(file, ""#else\n"");
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""if(V_COPYIN_RESULT_IS_OK(result)){\n"");
          idl_printIndent(loopIndent + indent);
          if (stacRequested) {
            fileOut(file, ""    strncpy(((*%s)"", to);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, ""), ((%s)"", from);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, ""), %u);\n"", (maxlen + 1));
          } else {
            fileOut(file, ""    (*%s)"", to);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "");\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    if (((%s)"", from);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "" != NULL) && ((*%s)"", to);
            idl_arrayLoopCopyIndex(typeArray);
            fileOut(file, "" == NULL)) {\n"");
            idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                                  loopIndent + indent + 1);
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""        result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
            idl_printIndent(loopIndent + indent);
            fileOut(file, ""    }\n"");
          }
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""}\n"");
          fileOut(file, ""#endif\n"");
        } else {
          DEBUG_INFO;
          idl_printIndent(loopIndent + indent);
          fileOut(file, ""    (*%s)"", to);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "" = (%s)"", from);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "";\n"");
        }
        break;
      case idl_tenum:
        maxlen = idl_typeEnumNoElements(
            idl_typeEnum(idl_typeDefActual(idl_typeDef(typeSpec))));

        DEBUG_INFO;
        fileOut(file, ""#ifdef %s\n"", BOUNDSCHECK);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""    if((unsigned)%s < %u)){\n"", from, maxlen);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""        %s = %s;\n"", to, from);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""    } else {\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""        "");
        idl_boundsCheckFail(MEMBER, scope, (idl_typeSpec)typeSpec, name);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""        result = V_COPYIN_RESULT_INVALID;\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""    }\n"");
        fileOut(file, ""#else\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""        %s = %s;\n"", to, from);
        fileOut(file, ""#endif\n"");
        break;
      default:
        printf(""idl_loopCopyBody: Unexpected type\n"");

        assert(0);
        break;
      }
    }
    break;
  case idl_tbasic:

    if (idl_typeBasicType(idl_typeBasic(typeSpec)) == idl_string) {
      maxlen = idl_typeBasicMaxlen(idl_typeBasic(typeSpec));

      DEBUG_INFO;
      fileOut(file, ""#ifdef %s\n"", BOUNDSCHECK);
      idl_printIndent(loopIndent + indent);
      fileOut(file, ""if((%s)"", from);
      idl_arrayLoopCopyIndex(typeArray);
      fileOut(file, ""){\n"");
      if (maxlen != 0) {
        DEBUG_INFO;
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""if(strlen((%s)"", from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "") <= %u){\n"", maxlen);
        idl_printIndent(loopIndent + indent + 2);
        if (stacRequested) {
          fileOut(file, ""strncpy((*%s)"", to);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "", (%s)"", from);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "", %u);\n"", (maxlen + 1));
        } else {
          fileOut(file, ""(*%s)"", to);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "");\n"");
          idl_printIndent(loopIndent + indent + 2);
          fileOut(file, ""if ((*%s)"", to);
          idl_arrayLoopCopyIndex(typeArray);
          fileOut(file, "" == NULL) {\n"");
          idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                                loopIndent + indent + 3);
          idl_printIndent(loopIndent + indent + 2);
          fileOut(file, ""    result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
          idl_printIndent(loopIndent + indent + 2);
          fileOut(file, ""}\n"");
        }
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""} else {\n"");
        idl_printIndent(loopIndent + indent + 2);
        idl_boundsCheckFail(MEMBER, scope, (idl_typeSpec)typeSpec, name);
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""    result = V_COPYIN_RESULT_INVALID;\n"");
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""}\n"");
      } else {
        DEBUG_INFO;
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""(*%s)"", to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "");\n"");
        fileOut(file, ""if ((*%s)"", to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "" == NULL) {\n"");
        idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                              loopIndent + indent + 2);
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""    result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
        idl_printIndent(loopIndent + indent + 1);
        fileOut(file, ""}\n"");
      }
      idl_printIndent(loopIndent + indent);
      fileOut(file, ""} else {\n"");
      idl_printIndent(loopIndent + indent + 1);
      idl_boundsCheckFailNull(MEMBER, scope, (idl_typeSpec)typeSpec, name);
      idl_printIndent(loopIndent + indent + 1);
      fileOut(file, ""result = V_COPYIN_RESULT_INVALID;\n"");
      idl_printIndent(loopIndent + indent);
      fileOut(file, ""}\n"");
      fileOut(file, ""#else\n"");
      idl_printIndent(loopIndent + indent);
      if (stacRequested) {
        fileOut(file, ""strncpy((*%s)"", to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "", (%s)"", from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "", %u);\n"", (maxlen + 1));
      } else {
        fileOut(file, ""(*%s)"", to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "" = c_stringNew_s(base, (%s)"", from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "");\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""if (((%s)"", from);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "" != NULL) && ((*%s)"", to);
        idl_arrayLoopCopyIndex(typeArray);
        fileOut(file, "" == NULL)) {\n"");
        idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name, 1);
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""    result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
        idl_printIndent(loopIndent + indent);
        fileOut(file, ""}\n"");
      }
      fileOut(file, ""#endif\n"");

    } else {

      assert(0);
    }
    break;
  case idl_tseq:
    nextType = idl_typeSeqType(idl_typeSeq(typeSpec));
    scopedName = idl_scopedSplTypeName(nextType);

    if (idl_typeSpecType(nextType) == idl_tbasic) {
      if (idl_typeBasicMaxlen(idl_typeBasic(nextType)) > 0) {
        typeName = idl_scopeStack(idl_typeUserScope(idl_typeUser(nextType)),
                                  ""::"", idl_typeSpecName(nextType));
      } else {
        typeName = idl_typeSpecName(nextType);
      }
    } else {
      typeName = idl_scopeStack(idl_typeUserScope(idl_typeUser(nextType)),
                                ""::"", idl_typeSpecName(nextType));
    }

    maxlen = idl_typeSeqMaxSize(idl_typeSeq(typeSpec));
    total_indent = indent + idl_indexSize(typeArray);
    snprintf(source, sizeof(source), ""(%s)"", from);
    snprintf(destin, sizeof(destin), ""(*%s)"", to);
    idl_arrayLoopCopyIndexString(source, typeArray);
    idl_arrayLoopCopyIndexString(destin, typeArray);

    DEBUG_INFO;
    idl_printIndent(total_indent);
    fileOut(file, ""    %sc_type type0 = NULL;\n"",
            (!noTypeCaching) ? ""static "" : """");
    idl_printIndent(total_indent);
    fileOut(file, ""    c_type subtype0;\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""    c_ulong length0;\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""    const %s *src0 = &%s;\n"",
            idl_sequenceIdent(idl_typeSeq(typeSpec)), source);
    idl_printIndent(total_indent);
    fileOut(file, ""    %s *dst0;\n\n"", idl_scopedSplTypeName(nextType));
    idl_printIndent(total_indent);

    fileOut(file, ""    if (type0 == NULL) {\n"");
    idl_printIndent(total_indent);
    fileOut(file,
            ""        subtype0 = c_type(c_metaResolve(c_metaObject(base), ""
            ""\""%s\""));\n"",
            typeName);
    idl_printIndent(total_indent);
    if (maxlen > 0) {
      fileOut(file,
              ""        type0 = ""
              ""c_metaSequenceTypeNew(c_metaObject(base),\""C_SEQUENCE<%s,%u>\"",""
              ""subtype0,%u);\n"",
              typeName, maxlen, maxlen);
    } else {
      fileOut(file,
              ""        type0 = ""
              ""c_metaSequenceTypeNew(c_metaObject(base),\""C_SEQUENCE<%s>\"",""
              ""subtype0,0);\n"",
              typeName);
    }
    idl_printIndent(total_indent);
    fileOut(file, ""        c_free(subtype0);\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""    }\n"");

    fileOut(file, ""#ifdef %s\n"", BOUNDSCHECK);
    idl_printIndent(total_indent);
    fileOut(file, ""    if(src0 != NULL){\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""        length0 = (*src0)._length;\n"");

    if (maxlen) {
      DEBUG_INFO;
      fileOut(file, ""        if(length0 > %u){\n"", maxlen);
      idl_printIndent(total_indent);
      fileOut(file, ""            "");
      idl_boundsCheckFail(ELEMENT, scope, (idl_typeSpec)typeSpec, name);
      idl_printIndent(total_indent);
      fileOut(file, ""            result = V_COPYIN_RESULT_INVALID;\n"");
      idl_printIndent(total_indent);
      fileOut(file, ""        } else {\n"");
      idl_printIndent(total_indent);
      fileOut(file,
              ""            dst0 = (%s ""
              ""*)c_newSequence_s(c_collectionType(type0), length0);\n"",
              scopedName);
      idl_printIndent(total_indent);
      fileOut(file, ""            if (dst0 != NULL) {\n"");
      idl_seqLoopCopy(nextType, ""*src"", ""dst0"", 1, total_indent + 4, scope,
                      name, noTypeCaching);
      idl_printIndent(total_indent);
      fileOut(file, ""                %s = (c_sequence)dst0;\n"", destin);
      idl_printIndent(total_indent);
      fileOut(file, ""            } else {\n"");
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                            total_indent + 4);
      idl_printIndent(total_indent);
      fileOut(file,
              ""                result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      idl_printIndent(total_indent);
      fileOut(file, ""            }\n"");
      idl_printIndent(total_indent);
      fileOut(file, ""        }\n"");
    } else {
      DEBUG_INFO;
      idl_printIndent(total_indent);
      fileOut(file,
              ""        dst0 = (%s *)c_newSequence_s(c_collectionType(type0), ""
              ""length0);\n"",
              scopedName);
      idl_printIndent(total_indent);
      fileOut(file, ""        if (dst0 != NULL) {\n"");
      idl_seqLoopCopy(nextType, ""*src"", ""dst0"", 1, total_indent + 3, scope,
                      name, noTypeCaching);
      idl_printIndent(total_indent);
      fileOut(file, ""            %s = (c_sequence)dst0;\n"", destin);
      idl_printIndent(total_indent);
      fileOut(file, ""        } else {\n"");
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                            total_indent + 3);
      idl_printIndent(total_indent);
      fileOut(file, ""            result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      idl_printIndent(total_indent);
      fileOut(file, ""        }\n"");
    }
    idl_printIndent(total_indent);
    fileOut(file, ""    } else {\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""        "");
    idl_boundsCheckFailNull(ELEMENT, scope, (idl_typeSpec)typeSpec, name);
    idl_printIndent(total_indent);
    fileOut(file, ""        result = V_COPYIN_RESULT_INVALID;\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""    }\n"");
    fileOut(file, ""#else\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""        length0 = (c_long)(*src0)._length;\n"");
    idl_printIndent(total_indent);
    fileOut(file,
            ""        dst0 = (%s *)c_newSequence_s(c_collectionType(type0), ""
            ""length0);\n"",
            scopedName);
    idl_printIndent(total_indent);
    fileOut(file, ""        if (dst0 != NULL) {\n"");
    idl_seqLoopCopy(nextType, ""*src"", ""dst0"", 1, total_indent + 3, scope, name,
                    noTypeCaching);
    idl_printIndent(total_indent);
    fileOut(file, ""            %s = (c_sequence)dst0;\n"", destin);
    idl_printIndent(total_indent);
    fileOut(file, ""        } else {\n"");
    idl_memoryAllocFailed(scope, (idl_typeSpec)typeSpec, name,
                          total_indent + 3);
    idl_printIndent(total_indent);
    fileOut(file, ""            result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
    idl_printIndent(total_indent);
    fileOut(file, ""        }\n"");
    fileOut(file, ""#endif\n"");
    if (noTypeCaching) {
      idl_printIndent(total_indent);
      idl_fileOutPrintf(file, ""    c_free(type0);\n"");
    }
    break;
  default:

    assert(0);
    break;
  }
  loopIndent--;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Host/LowLevel/StillImageHost/StillImageHost.c	"Task to print device information through the serial port, and open/close a test PIMA session with the attached Still Image device."	1	"void StillImageHost_Task(void) {
  if (USB_HostState != HOST_STATE_Configured)
    return;

  uint8_t ErrorCode;

  LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

  puts_P(PSTR(""Retrieving Device Info...\r\n""));

  PIMA_SendBlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(0),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = PIMA_OPERATION_GETDEVICEINFO,
      .TransactionID = 0x00000000,
      .Params = {},
  };

  SImage_SendBlockHeader();

  if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
    ShowCommandError(ErrorCode, false);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  uint16_t DeviceInfoSize =
      (PIMA_ReceivedBlock.DataLength - PIMA_COMMAND_SIZE(0));

  uint8_t DeviceInfo[DeviceInfoSize];

  SImage_ReadData(DeviceInfo, DeviceInfoSize);

  Pipe_ClearIN();

  uint8_t *DeviceInfoPos = DeviceInfo;

  DeviceInfoPos += 8;
  DeviceInfoPos += (1 + UNICODE_STRING_LENGTH(*DeviceInfoPos));
  DeviceInfoPos += 2;
  DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
  DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
  DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
  DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
  DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));

  char Manufacturer[*DeviceInfoPos];
  UnicodeToASCII(DeviceInfoPos, Manufacturer);
  printf_P(PSTR(""   Manufacturer: %s\r\n""), Manufacturer);

  DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);

  char Model[*DeviceInfoPos];
  UnicodeToASCII(DeviceInfoPos, Model);
  printf_P(PSTR(""   Model: %s\r\n""), Model);

  DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);

  char DeviceVersion[*DeviceInfoPos];
  UnicodeToASCII(DeviceInfoPos, DeviceVersion);
  printf_P(PSTR(""   Device Version: %s\r\n""), DeviceVersion);

  if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
    ShowCommandError(ErrorCode, false);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
    ShowCommandError(PIMA_ReceivedBlock.Code, true);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  puts_P(PSTR(""Opening Session...\r\n""));

  PIMA_SendBlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = PIMA_OPERATION_OPENSESSION,
      .TransactionID = 0x00000000,
      .Params = {0x00000001},
  };

  SImage_SendBlockHeader();

  if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
    ShowCommandError(ErrorCode, false);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
    ShowCommandError(PIMA_ReceivedBlock.Code, true);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  puts_P(PSTR(""Closing Session...\r\n""));

  PIMA_SendBlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = PIMA_OPERATION_CLOSESESSION,
      .TransactionID = 0x00000001,
      .Params = {0x00000001},
  };

  SImage_SendBlockHeader();

  if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
    ShowCommandError(ErrorCode, false);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
    ShowCommandError(PIMA_ReceivedBlock.Code, true);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  puts_P(PSTR(""Done.\r\n""));

  LEDs_SetAllLEDs(LEDMASK_USB_READY);
  USB_Host_SetDeviceConfiguration(0);
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the bezier tensor-product basis functions.	2	"static void
test_unit_basis_tensor_product_bezier(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_TP_Bezier *b_data_a = constructor_Basis_Data_TP_Bezier('a'),
                              *b_data_c = constructor_Basis_Data_TP_Bezier('c');

  tol = (double[]){
      2 * EPS,
      2 * EPS,
      3 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi13, b_data_c->phi13, tol[0]),
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi13, b_data_c->phi13, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      EPS,
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi13, b_data_c->grad_phi13,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[1]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi13,
                                           b_data_c->grad_phi13, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[1]);
    if (differences[2])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[2]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      EPS,
      EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Vector_d(b_data_a->p_14, b_data_c->p_14, tol[0]),
      diff_const_Vector_d(b_data_a->p_24, b_data_c->p_24, tol[1]),
      diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Vector_d(b_data_a->p_14, b_data_c->p_14, tol[0]);
    if (differences[1])
      print_diff_const_Vector_d(b_data_a->p_24, b_data_c->p_24, tol[1]);
    if (differences[2])
      print_diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[2]);
  }
  expect_condition(pass, ""partition of unity"");

  tol = (double[]){
      EPS,
      20 * EPS,
      5 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_13, b_data_c->grad_coef_13,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_23, b_data_c->grad_coef_23,
                              tol[1]),
      diff_const_Multiarray_d(b_data_a->grad_coef_33, b_data_c->grad_coef_33,
                              tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_13,
                                    b_data_c->grad_coef_13, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_23,
                                    b_data_c->grad_coef_23, tol[1]);
    if (differences[2])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_33,
                                    b_data_c->grad_coef_33, tol[2]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_TP_Bezier(b_data_a);
  destructor_Basis_Data_TP_Bezier(b_data_c);

  assert_condition(pass);
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavutil/rational.c	"Convert a double precision floating point number to a rational. inf is expressed as {1,0} or {-1,0} depending on the sign."	2	"AVRational av_d2q(double d, int max) {
  AVRational a;
#define LOG2 0.69314718055994530941723212145817656807550013436025
  int exponent;
  int64_t den;
  if (isnan(d))
    return (AVRational){0, 0};
  if (fabs(d) > INT_MAX + 3LL)
    return (AVRational){d < 0 ? -1 : 1, 0};
  exponent = FFMAX((int)(log(fabs(d) + 1e-20) / LOG2), 0);
  den = 1LL << (61 - exponent);

  av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
  if ((!a.num || !a.den) && d && max > 0 && max < INT_MAX)
    av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, INT_MAX);

  return a;
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m1/amffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);

    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open(st->codec, codec);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;

      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))
      try_decode_frame(st, pkt);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }
  ret = av_estimate_timings(ic, old_offset);
  if (ret < 0)
    goto find_stream_info_err;

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float8() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 8);
  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_64}}};
  return item;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	"Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host."	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t), NULL);

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength,
                              NULL);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameLength) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t), NULL);

      Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength,
                               NULL);

      Endpoint_ClearIN();

      FrameOUT.FrameLength = 0;
    }
  }
}"
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock attributes command and testing the received values.	3	"void arm_scmi_custom_tester_clock_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  uint32_t rcv_u;
  char *clock_name_rcv;
  char *clock_name_exp;
  uint32_t attributes;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_attributes, clock_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_attributes, clock_id)] =
        clock_protocol_data.num_clocks;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_attributes,
                                         clock_id)] = clock_id;
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;
      attributes =
          RETURN_VAL(received, struct arm_scmi_clock_attributes, attributes);

      rcv_u = arm_scmi_get_norm_bits(attributes, CLK_ATTRIBUTES_RESERVED_HIGH,
                                     CLK_ATTRIBUTES_RESERVED_LOW);
      arm_scmi_check_and_report_dec(&protocol_execution_context->test_stats,
                                    ALL_BITS_SET, CHECK, RESERVED, rcv_u,
                                    ""RESERVED"");

      rcv_u = arm_scmi_get_norm_bits(attributes, CLK_ATTRIBUTES_ENABLED,
                                     CLK_ATTRIBUTES_ENABLED);
      arm_scmi_check_and_report_dec(
          &protocol_execution_context->test_stats, ALL_BITS_SET,
          clock_protocol_data.clocks[clock_id].enabled_set ? CHECK : PRINT,
          clock_protocol_data.clocks[clock_id].enabled, rcv_u,
          ""ENABLED/DISABLED"");

      clock_name_rcv =
          RETURN_STR(received, struct arm_scmi_clock_attributes, clock_name);
      clock_name_exp = (clock_expected->clock_name == NULL)
                           ? NULL
                           : (char *)clock_expected->clock_name[clock_id];
      arm_scmi_check_and_report_str(&protocol_execution_context->test_stats,
                                    expected_flags_mask,
                                    LEFT_SHIFT(CLOCK_NAMES), clock_name_exp,
                                    clock_name_rcv, ""CLOCK NAME"");
    }
  }
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavutil/mathematics.c	Add a value to a timestamp. This function guarantees that when the same value is repeatly added that no accumulation of rounding errors occurs.	2	"int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb,
                      int64_t inc) {
  int64_t m, d;

  if (inc != 1) {
    inc_tb = av_mul_q(inc_tb, (AVRational){inc, 1});
  }
  m = inc_tb.num * (int64_t)ts_tb.den;
  d = inc_tb.den * (int64_t)ts_tb.num;

  if (m % d == 0)
    return ts + m / d;
  if (m < d)
    return ts;

  {
    int64_t old = av_rescale_q(ts, ts_tb, inc_tb);
    int64_t old_ts = av_rescale_q(old, inc_tb, ts_tb);
    return av_rescale_q(old + 1, inc_tb, ts_tb) + (ts - old_ts);
  }
}"
mato-docker-unikernel-runner-4ddadd3/src/ptrvec.c	"If the supplied ptrvec has any storage allocated, return it to the heap. The ptrvec itself is not freed. Whereas pvdel() is useful for entirely heap-based objects (typically obtained from pvnew()), pvclear() is useful at tne end of functions that use a stack-based ptrvec object."	4	"pvclear(ptrvec *pv) {
  if (!pv)
    return 0;
  if (pv->p)
    free(pv->p);
  *pv = (ptrvec){0};
  return pv;
}"
Metaswitch-clearwater-monit-043c17f/src/validate.c	Test the connection and protocol	2	"static State_Type _checkConnection(Service_T s, Port_T p) {
  ASSERT(s);
  ASSERT(p);
  volatile int retry_count = p->retry;
  volatile State_Type rv = State_Succeeded;
  char buf[STRLEN];
  char report[STRLEN] = {};
retry:
  TRY {
    Socket_test(p);
    rv = State_Succeeded;
    DEBUG(""'%s' succeeded testing protocol [%s] at %s [response time %s]\n"",
          s->name, p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
          Str_milliToTime(p->response, (char[23]){}));
  }
  ELSE {
    rv = State_Failed;
    snprintf(report, STRLEN, ""failed protocol test [%s] at %s -- %s"",
             p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
             Exception_frame.message);
  }
  END_TRY;
  if (rv == State_Failed) {
    if (retry_count-- > 1) {
      DEBUG(""'%s' %s (attempt %d/%d)\n"", s->name, report,
            p->retry - retry_count, p->retry);
      goto retry;
    }
    Event_post(s, Event_Connection, State_Failed, p->action, ""%s"", report);
  } else {
    Event_post(s, Event_Connection, State_Succeeded, p->action,
               ""connection succeeded to %s"",
               Util_portDescription(p, buf, sizeof(buf)));
  }
  return rv;
}"
NTAP-warpcore-a3ebacd/lib/src/backend_sock.c	Bind a warpcore socket-backend socket. Calls the underlying Socket API.	2	"int backend_bind(struct w_sock *const s, const struct w_sockopt *const opt) {
  s->fd = socket(AF_INET, SOCK_DGRAM | SOCK_CLOEXEC, 0);
  if (unlikely(s->fd < 0))
    return errno;

  struct sockaddr_in addr = {.sin_family = AF_INET,
                             .sin_port = s->tup.sport,
                             .sin_addr = {.s_addr = s->tup.sip}};
  if (unlikely(bind(s->fd, (struct sockaddr *)&addr, sizeof(addr)) != 0)) {
    warn(ERR, ""bind failed on %s:%u"", inet_ntoa(addr.sin_addr),
         ntohs(s->tup.sport));
    return errno;
  }

  ensure(setsockopt(s->fd, IPPROTO_IP, IP_RECVTOS, &(int){1}, sizeof(int)) >= 0,
         ""cannot setsockopt IP_RECVTOS"");

  if (opt)
    w_set_sockopt(s, opt);

  if (s->tup.sport == 0) {
    socklen_t len = sizeof(addr);
    ensure(getsockname(s->fd, (struct sockaddr *)&addr, &len) >= 0,
           ""getsockname"");
    s->tup.sport = addr.sin_port;
  }

#if defined(HAVE_KQUEUE)
  struct kevent ev;
  EV_SET(&ev, s->fd, EVFILT_READ, EV_ADD, 0, 0, s);
  ensure(kevent(s->w->b->kq, &ev, 1, 0, 0, 0) != -1, ""kevent"");
#elif defined(HAVE_EPOLL)
  struct epoll_event ev = {.events = EPOLLIN, .data.ptr = s};
  ensure(epoll_ctl(s->w->b->ep, EPOLL_CTL_ADD, s->fd, &ev) != -1, ""epoll_ctl"");
#endif

  return 0;
}"
google-graphd-e994e88/libgdp/gdp-input.c	Initialize input as a partial chain of buffers.	2	"int gdp_input_init_chain_part(gdp_input *in, srv_buffer *first,
                              size_t first_offs, srv_buffer *last,
                              size_t last_n, cm_handle *cm, cl_handle *cl) {
  *in = (gdp_input){
      .in_queue =
          (gdp_input_queue){
              .iq_curr = first,
              .iq_curr_i = first_offs,
              .iq_tail = last,
              .iq_tail_n = last_n,
          },
      .in_cm = cm,
      .in_cl = cl,
      .in_row = 1,
      .in_col = 1,
  };

  return 0;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Write command to the attached device, to write one or more data blocks to the storage medium from a buffer."	0	"uint8_t MassStore_WriteDeviceBlock(const uint8_t LUNIndex,
                                   const uint32_t BlockAddress,
                                   const uint8_t Blocks,
                                   const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
NVIDIA-AI-IOT-deepstream_reference_apps-3a8957b/yolo/plugins/gst-yoloplugin-tegra/gstyoloplugin.cpp	Scale the entire frame to the processing resolution maintaining aspect ratio. Or crop and scale objects to the processing resolution maintaining the aspect ratio. Remove the padding requried by hardware and convert from RGBA to RGB using openCV. These steps can be skipped if the algorithm can work with padded data and/or can work with RGBA.	2	"get_converted_mat(GstYoloPlugin *yoloplugin, int in_dmabuf_fd,
                  NvOSD_RectParams *crop_rect_params, cv::Mat &out_mat,
                  gdouble &ratio) {
  NvBufferParams buf_params;
  NvBufferCompositeParams composite_params = {0};
  gpointer mapped_ptr = NULL;
  GstFlowReturn flow_ret = GST_FLOW_OK;
  cv::Mat in_mat;

  if (NvBufferGetParams(in_dmabuf_fd, &buf_params) != 0) {
    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  ratio = MIN(1.0 * yoloplugin->processing_width /
                  GST_ROUND_DOWN_2(crop_rect_params->width),
              1.0 * yoloplugin->processing_height /
                  GST_ROUND_DOWN_2(crop_rect_params->height));

  if (ratio < 1.0 / 16 || ratio > 16.0) {

    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  memset(&composite_params, 0, sizeof(composite_params));

  composite_params.composite_bgcolor = (NvBufferCompositeBackground){0, 0, 0};

  composite_params.input_buf_count = 1;
  composite_params.src_comp_rect[0].left =
      GST_ROUND_UP_2(crop_rect_params->left);
  composite_params.src_comp_rect[0].top = GST_ROUND_UP_2(crop_rect_params->top);
  composite_params.src_comp_rect[0].width =
      GST_ROUND_DOWN_2(crop_rect_params->width);
  composite_params.src_comp_rect[0].height =
      GST_ROUND_DOWN_2(crop_rect_params->height);

  composite_params.dst_comp_rect[0].left = 0;
  composite_params.dst_comp_rect[0].top = 0;
  composite_params.dst_comp_rect[0].width =
      GST_ROUND_DOWN_2((gint)(ratio * composite_params.src_comp_rect[0].width));
  composite_params.dst_comp_rect[0].height = GST_ROUND_DOWN_2(
      (gint)(ratio * composite_params.src_comp_rect[0].height));
  composite_params.composite_flag = NVBUFFER_COMPOSITE;

  if (NvBufferComposite(&in_dmabuf_fd, yoloplugin->conv_dmabuf_fd,
                        &composite_params)) {
    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  if (NvBufferGetParams(yoloplugin->conv_dmabuf_fd, &buf_params) != 0) {
    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  if (NvBufferMemMap(yoloplugin->conv_dmabuf_fd, 0, NvBufferMem_Read,
                     &mapped_ptr) != 0) {
    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  if (NvBufferMemSyncForCpu(yoloplugin->conv_dmabuf_fd, 0, &mapped_ptr) != 0) {
    flow_ret = GST_FLOW_ERROR;
    goto done;
  }

  in_mat = cv::Mat(yoloplugin->processing_height, yoloplugin->processing_width,
                   CV_8UC4, mapped_ptr, buf_params.pitch[0]);
  cv::cvtColor(in_mat, out_mat, CV_BGRA2BGR);

done:
  if (mapped_ptr)
    NvBufferMemUnMap(yoloplugin->conv_dmabuf_fd, 0, &mapped_ptr);
  return flow_ret;
}"
dm-vdo-kvdo-8df6805/vdo/base/dataVIO.c	Set a DataVIO's mapped field to the physical location recorded in the block map for the logical block in the VIO.	2	"int setMappedLocation(DataVIO *dataVIO, PhysicalBlockNumber pbn,
                      BlockMappingState state) {
  PhysicalZone *zone;
  int result = getPhysicalZone(getVDOFromDataVIO(dataVIO), pbn, &zone);
  if (result != VDO_SUCCESS) {
    return result;
  }

  dataVIO->mapped = (ZonedPBN){
      .pbn = pbn,
      .state = state,
      .zone = zone,
  };
  return VDO_SUCCESS;
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/ui.c	Simply draw a title bar on the screen	2	"static void __draw_title_bar() {
  cursor_coord_t cursor = (cursor_coord_t){0, 1};
  gfx_font_set(font_small);
  gfx_cursor_set(cursor);
  gfx_color_set(UI_MENU_TITLE_BAR_COLOR);

  botnet_state_t *p_botnet_state = state_botnet_get();

  char name[STATE_NAME_LENGTH + 1];
  state_name_get(name);

  char text[80];
  sprintf(text, ""%s[%04X] - L%d - %2.1fv"", name, p_botnet_state->botnet_id,
          p_botnet_state->level, battery_voltage());
  gfx_print(text);

  gfx_draw_line(0, UI_MENU_TITLE_BAR_HEIGHT, LCD_WIDTH,
                UI_MENU_TITLE_BAR_HEIGHT, UI_MENU_TITLE_BAR_COLOR);
}"
ImpulseAdventure-GUIslice-4bd031f/src/GUIslice.c	Draw a framed circle	2	"void gslc_DrawFrameCircle(gslc_tsGui *pGui, int16_t nMidX, int16_t nMidY,
                          uint16_t nRadius, gslc_tsColor nCol) {

#if (DRV_HAS_DRAW_CIRCLE_FRAME)

  gslc_DrvDrawFrameCircle(pGui, nMidX, nMidY, nRadius, nCol);
#else

  int16_t nX = nRadius;
  int16_t nY = 0;
  int16_t nErr = 0;

#if (DRV_HAS_DRAW_POINTS)
  gslc_tsPt asPt[8];
  while (nX >= nY) {
    asPt[0] = (gslc_tsPt){nMidX + nX, nMidY + nY};
    asPt[1] = (gslc_tsPt){nMidX + nY, nMidY + nX};
    asPt[2] = (gslc_tsPt){nMidX - nY, nMidY + nX};
    asPt[3] = (gslc_tsPt){nMidX - nX, nMidY + nY};
    asPt[4] = (gslc_tsPt){nMidX - nX, nMidY - nY};
    asPt[5] = (gslc_tsPt){nMidX - nY, nMidY - nX};
    asPt[6] = (gslc_tsPt){nMidX + nY, nMidY - nX};
    asPt[7] = (gslc_tsPt){nMidX + nX, nMidY - nY};
    gslc_DrvDrawPoints(pGui, asPt, 8, nCol);

    nY += 1;
    nErr += 1 + 2 * nY;
    if (2 * (nErr - nX) + 1 > 0) {
      nX -= 1;
      nErr += 1 - 2 * nX;
    }
  }

#elif (DRV_HAS_DRAW_POINT)
  while (nX >= nY) {
    gslc_DrvDrawPoint(pGui, nMidX + nX, nMidY + nY, nCol);
    gslc_DrvDrawPoint(pGui, nMidX + nY, nMidY + nX, nCol);
    gslc_DrvDrawPoint(pGui, nMidX - nY, nMidY + nX, nCol);
    gslc_DrvDrawPoint(pGui, nMidX - nX, nMidY + nY, nCol);
    gslc_DrvDrawPoint(pGui, nMidX - nX, nMidY - nY, nCol);
    gslc_DrvDrawPoint(pGui, nMidX - nY, nMidY - nX, nCol);
    gslc_DrvDrawPoint(pGui, nMidX + nY, nMidY - nX, nCol);
    gslc_DrvDrawPoint(pGui, nMidX + nX, nMidY - nY, nCol);

    nY += 1;
    nErr += 1 + 2 * nY;
    if (2 * (nErr - nX) + 1 > 0) {
      nX -= 1;
      nErr += 1 - 2 * nX;
    }
  }

#else

#endif

#endif

  gslc_PageFlipSet(pGui, true);
}"
intel-iot-devkit-zmraa-f8c045d/source/gpio.c	Initialise a gpio	2	"mraa_gpio_init(int pin) {
  mraa_board_t *board = plat;
  if (board == NULL) {
    printf(""gpio: platform not initialised\n"");
    return NULL;
  }

  if (pin < 0 || pin >= board->phy_pin_count) {
    printf(""gpio: pin %i beyond platform definition\n"", pin);
    return NULL;
  }

#if defined(CONFIG_BOARD_QUARK_D2000_CRB) ||                                   \
    defined(CONFIG_BOARD_ARDUINO_101) ||                                       \
    defined(CONFIG_BOARD_ARDUINO_101_SSS) ||                                   \
    defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD) ||                           \
    defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
  struct device *pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  if (pinmux_dev == NULL) {
    printf(""Failed to get binding for pinmux\n"");
    return NULL;
  }
#elif defined(CONFIG_BOARD_NUCLEO_L476RG)

#endif

#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
  d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  switch (pin) {
  case 14:
    pinmux_pin_set(d2k_pinmux_dev, 3, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 14, 3, ""A0"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 15:
    pinmux_pin_set(d2k_pinmux_dev, 4, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 15, 4, ""A1"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 16:
    pinmux_pin_set(d2k_pinmux_dev, 14, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 16, 14, ""A2"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 17:
    pinmux_pin_set(d2k_pinmux_dev, 15, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 17, 15, ""A3"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 18:
    pinmux_pin_set(d2k_pinmux_dev, 7, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 18, 7, ""A4"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 1, 0, 0});
    break;
  case 19:
    pinmux_pin_set(d2k_pinmux_dev, 6, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 19, 6, ""A5"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 1, 0, 0});
    break;
  default:;
  }
#endif
#if defined(CONFIG_BOARD_ARDUINO_101)
  switch (pin) {
  case 3:
    pinmux_pin_set(pinmux_dev, 63, PINMUX_FUNC_C);
    mraa_set_pininfo(board, 3, 17, ""IO3"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
    break;
  case 5:
    pinmux_pin_set(pinmux_dev, 64, PINMUX_FUNC_C);
    mraa_set_pininfo(board, 5, 15, ""IO5"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
    break;
  case 10:
    pinmux_pin_set(pinmux_dev, 0, PINMUX_FUNC_A);
    break;
  case 11:
    pinmux_pin_set(pinmux_dev, 3, PINMUX_FUNC_A);
    break;
  case 12:
    pinmux_pin_set(pinmux_dev, 1, PINMUX_FUNC_A);
    break;
  case 13:
    pinmux_pin_set(pinmux_dev, 2, PINMUX_FUNC_A);
    break;
  case 6:
  case 9:
  case 14:
  case 15:
  case 16:
  case 17:
  case 18:
  case 19:
    printf(""Pin %d not enabled/Can't be enabled\n"", pin);
    return NULL;
  default:;
  }
#endif
#if defined(CONFIG_BOARD_ARDUINO_101_SSS)
  switch (pin) {
  case 14:
    pinmux_pin_set(pinmux_dev, 10, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 14, 2, ""A0  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 15:
    pinmux_pin_set(pinmux_dev, 11, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 15, 3, ""A1  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 16:
    pinmux_pin_set(pinmux_dev, 12, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 16, 4, ""A2  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 17:
    pinmux_pin_set(pinmux_dev, 13, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 17, 5, ""A3  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 18:
    pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 19, 1, ""A5  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 1, 1, 0});
    break;
  case 19:
    pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_A);
    mraa_set_pininfo(board, 19, 1, ""A5  "",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 1, 1, 0});
    break;
  default:;
  }
#endif

  if (board->pins[pin].capabilites.gpio != 1) {
    printf(""gpio: pin %i not capable of gpio\n"", pin);
    return NULL;
  }
  if (board->pins[pin].gpio.mux_total > 0) {
    if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
      return NULL;
    }
  }

#if defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
  if (board->pins[pin].gpio.pinmap >= 0 && board->pins[pin].gpio.pinmap <= 28)
    pinmux_pin_pullup(pinmux_dev, board->pins[pin].gpio.pinmap, PINMUX_FUNC_A);
  else if (board->pins[pin].gpio.pinmap >= 29 &&
           board->pins[pin].gpio.pinmap <= 31)
    pinmux_pin_pullup(pinmux_dev, board->pins[pin].gpio.pinmap, PINMUX_FUNC_B);
#endif

#if defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
  switch (pin) {
  case 14:
    mraa_set_pininfo(board, 14, 2, ""14"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 16:
    mraa_set_pininfo(board, 16, 3, ""16"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 18:
    mraa_set_pininfo(board, 18, 4, ""18"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 20:
    mraa_set_pininfo(board, 20, 5, ""20"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 22:
    mraa_set_pininfo(board, 22, 6, ""22"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 24:
    mraa_set_pininfo(board, 24, 7, ""24"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
    break;
  case 25:
    mraa_set_pininfo(board, 25, 10, ""25"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
    break;
  case 27:
    mraa_set_pininfo(board, 27, 11, ""27"",
                     (mraa_pincapabilities_t){1, 1, 1, 0, 0, 0, 0, 0});
    break;
  default:;
  }
#endif

#if defined(CONFIG_BOARD_NUCLEO_L476RG)
  if ((pin >= 0 && pin <= 2) || (pin >= 7 && pin <= 8) ||
      (pin >= 11 && pin <= 13) || (pin >= 16 && pin <= 18)) {
    memcpy(stm32_drv, ""GPIOA"", sizeof(""GPIOA""));
  } else if ((pin >= 3 && pin <= 6) || (pin == 10) ||
             (pin >= 14 && pin <= 15) || (pin == 19)) {
    memcpy(stm32_drv, ""GPIOB"", sizeof(""GPIOB""));
  } else if ((pin == 9) || (pin >= 20 && pin <= 21)) {
    memcpy(stm32_drv, ""GPIOC"", sizeof(""GPIOC""));
  }
#endif

  mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
  if (dev) {
    dev->pin = pin;
  }
  return dev;
}"
RfidResearchGroup-proxmark3-1650889/client/cmdhf15.c	"Commandline handling: HF15 CMD WRITE Writes a single Block - might run into timeout, even when successful"	2	"int CmdHF15Write(const char *Cmd) {

  char cmdp = param_getchar(Cmd, 0);
  if (strlen(Cmd) < 3 || cmdp == 'h' || cmdp == 'H')
    return usage_15_write();

  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum, temp;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char *cmd2;

  strncpy(cmd, Cmd, 99);

  if (!prepareHF15Cmd(&cmd, &c, ISO15_CMD_WRITE))
    return 0;

  reqlen = c.arg[0];

  cmd2 = cmd;
  while (*cmd2 != ' ' && *cmd2 != '\t' && *cmd2)
    cmd2++;
  *cmd2 = 0;
  cmd2++;

  pagenum = strtol(cmd, NULL, 0);

  req[reqlen++] = (uint8_t)pagenum;

  while (cmd2[0] && cmd2[1]) {
    if (*cmd2 == ' ') {
      cmd2++;
      continue;
    }
    sscanf((char[]){cmd2[0], cmd2[1], 0}, ""%X"", &temp);
    req[reqlen++] = temp & 0xff;
    cmd2 += 2;
  }
  AddCrc(req, reqlen);
  c.arg[0] = reqlen + 2;

  PrintAndLogEx(NORMAL, ""iso15693 writing to page %02d (0x%02X) | data "",
                pagenum, pagenum);

  clearCommandBuffer();
  SendCommand(&c);

  if (!WaitForResponseTimeout(CMD_ACK, &resp, 2000)) {
    PrintAndLogEx(FAILED, ""iso15693 card timeout, data may be written anyway"");
    return 1;
  }

  uint32_t status = resp.arg[0];
  if (status < 2) {
    PrintAndLogEx(FAILED, ""iso15693 card select failed"");
    return 1;
  }

  recv = resp.d.asBytes;

  if (!CheckCrc(recv, status)) {
    PrintAndLogEx(FAILED, ""CRC failed"");
    return 2;
  }

  if (recv[0] & ISO15_RES_ERROR) {
    PrintAndLogEx(NORMAL, ""iso15693 card returned error %i: %s"", recv[0],
                  TagErrorStr(recv[0]));
    return 3;
  }

  PrintAndLogEx(NORMAL, ""OK"");
  return 0;
}"
ARM-software-scmi-tests-24dd373/protocols/base/base_exe.c	The function is called by the test engine just before sending the command and testing the received data.	2	"void arm_scmi_custom_tester_base_disco_agent_msg(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t agent_id;
  int error_code;
  enum test_status res;
  char *agent_rcv, *agent_exp;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_base_discover_agent, agent_id)) {

    test_case->parameter_count = 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_base_discover_agent,
                                       agent_id)] =
        arm_scmi_base_protocol_data.num_agents + 1;
    error_code = arm_scmi_execute_and_assert_test_case(
        protocol_execution_context, test_case, &received);
  } else if (!test_case->parameter_discovery_driven) {

    test_case->parameter_count = 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_base_discover_agent,
                                       agent_id)] = 0;
    error_code = arm_scmi_execute_and_assert_test_case(
        protocol_execution_context, test_case, &received);
    if ((error_code != NO_ERROR) || (received.status < 0))
      return;
    res = check_agent_name_starts(
        ""platform"",
        RETURN_STR(received, struct arm_scmi_base_discover_agent, name));
    snprintf(
        description, NUM_ELEMS(description), ""%s"",
        ((res == PASSED)
             ? RETURN_STR(received, struct arm_scmi_base_discover_agent, name)
             : ""Agent name does not start with 'platform'""));
    arm_scmi_log_test_result(&protocol_execution_context->test_stats, res,
                             ""AGENT NAME"", description);
  } else {

    test_case->parameter_count = 1;
    for (agent_id = 1; agent_id <= arm_scmi_base_protocol_data.num_agents;
         ++agent_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_base_discover_agent,
                                         agent_id)] = agent_id;
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);

      if ((error_code != NO_ERROR) || (received.status < 0))
        continue;
      agent_rcv =
          RETURN_STR(received, struct arm_scmi_base_discover_agent, name);
      res = INFO;
      if ((LEFT_SHIFT(AGENT_NAMES) & expected_flags_mask)) {
        agent_exp = base_expected->agent_names[agent_id - 1];
        res = (strcmp(agent_rcv, agent_exp) == 0) ? PASSED : FAILED;
      }
      if (res == FAILED) {
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", agent_exp, agent_rcv);
      } else if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", agent_rcv);
      }
      snprintf(name, NUM_ELEMS(name), ""AGENT NAME"");
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, res,
                               name, description);
    }
  }
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/alpn-test.c	"In this test case, establish a security context, with server ready for ALPN, and the client sends a protocol that doesn't match any known to the server. The client can detect that alpn was not used."	3	"init_alpn_nomatch(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = false;
  OM_uint32 ignore_minor_status = 0;
  const char *why = """";

  unsigned char server_alpn[] = {
      3,
      'g',
      's',
      's',
  };
  unsigned char client_alpn[] = {
      3,
      'g',
      's',
      'i',
  };

  major_status =
      gss_set_sec_context_option(&minor_status, &init_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = client_alpn,
                                     .length = sizeof(client_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }

  major_status =
      gss_set_sec_context_option(&minor_status, &accept_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = server_alpn,
                                     .length = sizeof(server_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
        break;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, accept_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);

    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    result = true;
  }
fail:
  if (major_status != GSS_S_COMPLETE &&
      strcmp(why, ""accept_sec_context"") == 0) {
    result = true;
  } else if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/GenericHIDHost/GenericHIDHost.c	Writes a report to the attached device.	1	"void WriteNextReport(uint8_t *ReportOUTData, const uint8_t ReportIndex,
                     const uint8_t ReportType, uint16_t ReportLength) {
  if (USB_HostState != HOST_STATE_Configured)
    return;

  Pipe_SelectPipe(HID_DATA_OUT_PIPE);

  if (Pipe_IsConfigured() && (ReportType == REPORT_TYPE_OUT)) {
    Pipe_Unfreeze();

    if (!(Pipe_IsOUTReady())) {

      Pipe_Freeze();

      return;
    }

    if (ReportIndex)
      Pipe_Write_8(ReportIndex);

    Pipe_Write_Stream_LE(ReportOUTData, ReportLength, NULL);

    Pipe_ClearOUT();

    Pipe_Freeze();
  } else {

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetReport,
        .wValue = ((ReportType << 8) | ReportIndex),
        .wIndex = 0,
        .wLength = ReportLength,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    USB_Host_SendControlRequest(ReportOUTData);
  }
}"
darktable-org-darktable-32fab21/src/iop/rotatepixels.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_rotatepixels_params_t tmp = {0};

  if (!self->dev)
    goto end;

  const dt_image_t *const image = &(self->dev->image_storage);

  tmp = (dt_iop_rotatepixels_params_t){
      .rx = 0u, .ry = image->fuji_rotation_pos, .angle = -45.0f};

  self->default_enabled = ((tmp.rx != 0u) || (tmp.ry != 0u));

  self->hide_enable_button = !self->default_enabled;

end:
  memcpy(self->params, &tmp, sizeof(dt_iop_rotatepixels_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_rotatepixels_params_t));
}"
Speedy37-QtUpdateSystem-9a3aea9/deps/xz/src/xz/file_io.c	Open the source file.	2	"io_open_src(const char *src_name) {
  if (is_empty_filename(src_name))
    return NULL;

  static file_pair pair;

  pair = (file_pair){
      .src_name = src_name,
      .dest_name = NULL,
      .src_fd = -1,
      .dest_fd = -1,
      .src_eof = false,
      .dest_try_sparse = false,
      .dest_pending_sparse = 0,
  };

  signals_block();
  const bool error = io_open_src_real(&pair);
  signals_unblock();

#ifdef ENABLE_SANDBOX
  if (!error)
    io_sandbox_enter(pair.src_fd);
#endif

  return error ? NULL : &pair;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/StillImageClassHost.c	Opens a new PIMA session with the attached device. This should be used before any session-orientated PIMA commands are issued to the device. Only one session can be open at the one time.	2	"uint8_t SI_Host_OpenSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  SIInterfaceInfo->State.TransactionID = 0;
  SIInterfaceInfo->State.IsSessionOpen = false;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = CPU_TO_LE32(PIMA_COMMAND_SIZE(1)),
      .Type = CPU_TO_LE16(PIMA_CONTAINER_CommandBlock),
      .Code = CPU_TO_LE16(0x1002),
      .Params = {CPU_TO_LE32(1)},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((PIMABlock.Type != CPU_TO_LE16(PIMA_CONTAINER_ResponseBlock)) ||
      (PIMABlock.Code != CPU_TO_LE16(0x2001)))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  SIInterfaceInfo->State.IsSessionOpen = true;

  return PIPE_RWSTREAM_NoError;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands."	1	"uint8_t MS_Host_TestUnitReady(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                              const uint8_t LUNIndex) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(0),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, NULL);
}"
darktable-org-darktable-32fab21/src/iop/retouch.c	construct widget.	2	"void gui_init(dt_iop_module_t *self) {
  const int bs = DT_PIXEL_APPLY_DPI(14);

  self->gui_data = malloc(sizeof(dt_iop_retouch_gui_data_t));
  dt_iop_retouch_gui_data_t *g = (dt_iop_retouch_gui_data_t *)self->gui_data;
  dt_iop_retouch_params_t *p = (dt_iop_retouch_params_t *)self->params;

  dt_pthread_mutex_init(&g->lock, NULL);
  change_image(self);

  self->widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
  dt_gui_add_help_link(self->widget, dt_get_help_url(self->op));

  GtkWidget *hbox_shapes = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

  GtkWidget *label = gtk_label_new(_(""# shapes:""));
  gtk_box_pack_start(GTK_BOX(hbox_shapes), label, FALSE, TRUE, 0);
  g->label_form = GTK_LABEL(gtk_label_new(""-1""));
  g_object_set(G_OBJECT(hbox_shapes), ""tooltip-text"",
               _(""to add a shape select an algorithm and a shape type and ""
                 ""click on the image.\n""
                 ""shapes are added to the current scale""),
               (char *)NULL);

  g->bt_edit_masks =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_eye,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_signal_connect(G_OBJECT(g->bt_edit_masks), ""button-press-event"",
                   G_CALLBACK(rt_edit_masks_callback), self);
  g_object_set(G_OBJECT(g->bt_edit_masks), ""tooltip-text"",
               _(""show and edit shapes on the current scale""), (char *)NULL);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_edit_masks), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_edit_masks), bs, bs);
  gtk_box_pack_end(GTK_BOX(hbox_shapes), g->bt_edit_masks, FALSE, FALSE, 0);

  g->bt_brush =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_brush,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_signal_connect(G_OBJECT(g->bt_brush), ""button-press-event"",
                   G_CALLBACK(rt_add_shape_callback), self);
  g_object_set(G_OBJECT(g->bt_brush), ""tooltip-text"", _(""add brush""),
               (char *)NULL);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_brush), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_brush), bs, bs);
  gtk_box_pack_end(GTK_BOX(hbox_shapes), g->bt_brush, FALSE, FALSE, 0);

  g->bt_path =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_path,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_signal_connect(G_OBJECT(g->bt_path), ""button-press-event"",
                   G_CALLBACK(rt_add_shape_callback), self);
  g_object_set(G_OBJECT(g->bt_path), ""tooltip-text"", _(""add path""),
               (char *)NULL);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_path), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_path), bs, bs);
  gtk_box_pack_end(GTK_BOX(hbox_shapes), g->bt_path, FALSE, FALSE, 0);

  g->bt_ellipse =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_ellipse,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_signal_connect(G_OBJECT(g->bt_ellipse), ""button-press-event"",
                   G_CALLBACK(rt_add_shape_callback), self);
  g_object_set(G_OBJECT(g->bt_ellipse), ""tooltip-text"", _(""add ellipse""),
               (char *)NULL);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_ellipse), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_ellipse), bs, bs);
  gtk_box_pack_end(GTK_BOX(hbox_shapes), g->bt_ellipse, FALSE, FALSE, 0);

  g->bt_circle =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_circle,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_signal_connect(G_OBJECT(g->bt_circle), ""button-press-event"",
                   G_CALLBACK(rt_add_shape_callback), self);
  g_object_set(G_OBJECT(g->bt_circle), ""tooltip-text"", _(""add circle""),
               (char *)NULL);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_circle), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_circle), bs, bs);
  gtk_box_pack_end(GTK_BOX(hbox_shapes), g->bt_circle, FALSE, FALSE, 0);

  gtk_box_pack_start(GTK_BOX(hbox_shapes), GTK_WIDGET(g->label_form), FALSE,
                     TRUE, 0);

  GtkWidget *hbox_algo = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

  GtkWidget *label2 = gtk_label_new(_(""algorithms:""));
  gtk_box_pack_start(GTK_BOX(hbox_algo), label2, FALSE, TRUE, 0);

  g->bt_fill =
      dtgtk_togglebutton_new(_retouch_cairo_paint_tool_fill,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_fill), ""tooltip-text"", _(""activates fill tool""),
               (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_fill), ""toggled"",
                   G_CALLBACK(rt_select_algorithm_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_fill), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_fill), FALSE);

  g->bt_blur =
      dtgtk_togglebutton_new(_retouch_cairo_paint_tool_blur,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_blur), ""tooltip-text"", _(""activates blur tool""),
               (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_blur), ""toggled"",
                   G_CALLBACK(rt_select_algorithm_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_blur), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_blur), FALSE);

  g->bt_heal =
      dtgtk_togglebutton_new(_retouch_cairo_paint_tool_heal,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_heal), ""tooltip-text"",
               _(""activates healing tool""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_heal), ""toggled"",
                   G_CALLBACK(rt_select_algorithm_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_heal), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_heal), FALSE);

  g->bt_clone =
      dtgtk_togglebutton_new(_retouch_cairo_paint_tool_clone,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_clone), ""tooltip-text"",
               _(""activates cloning tool""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_clone), ""toggled"",
                   G_CALLBACK(rt_select_algorithm_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_clone), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_clone), FALSE);

  gtk_box_pack_end(GTK_BOX(hbox_algo), g->bt_blur, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hbox_algo), g->bt_fill, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hbox_algo), g->bt_clone, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hbox_algo), g->bt_heal, FALSE, FALSE, 0);

  GtkWidget *hbox_wd_labels = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

  GtkWidget *lbl_num_scales = gtk_label_new(_(""# scales:""));
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels), GTK_WIDGET(lbl_num_scales), FALSE,
                     FALSE, 0);

  g->lbl_num_scales = GTK_LABEL(gtk_label_new(NULL));
  gtk_label_set_width_chars(g->lbl_num_scales, 2);
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels), GTK_WIDGET(g->lbl_num_scales),
                     FALSE, FALSE, 0);

  GtkWidget *lbl_curr_scale = gtk_label_new(_(""current:""));
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels), GTK_WIDGET(lbl_curr_scale), FALSE,
                     FALSE, 0);

  g->lbl_curr_scale = GTK_LABEL(gtk_label_new(NULL));
  gtk_label_set_width_chars(g->lbl_curr_scale, 2);
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels), GTK_WIDGET(g->lbl_curr_scale),
                     FALSE, FALSE, 0);

  GtkWidget *lbl_merge_from_scale = gtk_label_new(_(""merge from:""));
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels), GTK_WIDGET(lbl_merge_from_scale),
                     FALSE, FALSE, 0);

  g->lbl_merge_from_scale = GTK_LABEL(gtk_label_new(NULL));
  gtk_label_set_width_chars(g->lbl_merge_from_scale, 2);
  gtk_box_pack_start(GTK_BOX(hbox_wd_labels),
                     GTK_WIDGET(g->lbl_merge_from_scale), FALSE, FALSE, 0);

  g->wd_bar = gtk_drawing_area_new();

  gtk_widget_set_tooltip_text(
      g->wd_bar, _(""top slider adjusts where the merge scales start\n""
                   ""bottom slider adjusts the number of scales\n""
                   ""red box indicates the current scale\n""
                   ""green line indicates that the scale has shapes on it""));
  g_signal_connect(G_OBJECT(g->wd_bar), ""draw"", G_CALLBACK(rt_wdbar_draw),
                   self);
  g_signal_connect(G_OBJECT(g->wd_bar), ""motion-notify-event"",
                   G_CALLBACK(rt_wdbar_motion_notify), self);
  g_signal_connect(G_OBJECT(g->wd_bar), ""leave-notify-event"",
                   G_CALLBACK(rt_wdbar_leave_notify), self);
  g_signal_connect(G_OBJECT(g->wd_bar), ""button-press-event"",
                   G_CALLBACK(rt_wdbar_button_press), self);
  g_signal_connect(G_OBJECT(g->wd_bar), ""button-release-event"",
                   G_CALLBACK(rt_wdbar_button_release), self);
  g_signal_connect(G_OBJECT(g->wd_bar), ""scroll-event"",
                   G_CALLBACK(rt_wdbar_scrolled), self);
  gtk_widget_add_events(GTK_WIDGET(g->wd_bar),
                        GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
                            GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
                            GDK_LEAVE_NOTIFY_MASK | GDK_SCROLL_MASK |
                            GDK_SMOOTH_SCROLL_MASK);
  gtk_widget_set_size_request(g->wd_bar, -1, DT_PIXEL_APPLY_DPI(40));

  GtkWidget *hbox_scale = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

  g->bt_showmask = dtgtk_togglebutton_new(
      dtgtk_cairo_paint_showmask, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_showmask), ""tooltip-text"", _(""display masks""),
               (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_showmask), ""toggled"",
                   G_CALLBACK(rt_showmask_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_showmask), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_showmask), FALSE);

  g->bt_suppress =
      dtgtk_togglebutton_new(dtgtk_cairo_paint_eye_toggle,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_suppress), ""tooltip-text"",
               _(""temporarily switch off shapes""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_suppress), ""toggled"",
                   G_CALLBACK(rt_suppress_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_suppress), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_suppress), FALSE);

  g->bt_display_wavelet_scale =
      dtgtk_togglebutton_new(_retouch_cairo_paint_display_wavelet_scale,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_display_wavelet_scale), ""tooltip-text"",
               _(""display wavelet scale""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_display_wavelet_scale), ""toggled"",
                   G_CALLBACK(rt_display_wavelet_scale_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_display_wavelet_scale), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_display_wavelet_scale),
                               FALSE);

  g->bt_copy_scale =
      dtgtk_togglebutton_new(_retouch_cairo_paint_cut_forms,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_copy_scale), ""tooltip-text"",
               _(""cut shapes from current scale""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_copy_scale), ""toggled"",
                   G_CALLBACK(rt_copypaste_scale_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_copy_scale), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_copy_scale), FALSE);

  g->bt_paste_scale =
      dtgtk_togglebutton_new(_retouch_cairo_paint_paste_forms,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_paste_scale), ""tooltip-text"",
               _(""paste cut shapes to current scale""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_paste_scale), ""toggled"",
                   G_CALLBACK(rt_copypaste_scale_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_paste_scale), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_paste_scale), FALSE);

  gtk_box_pack_end(GTK_BOX(hbox_scale), g->bt_showmask, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hbox_scale), g->bt_suppress, FALSE, FALSE, 0);

  GtkWidget *lbl_scale_sep = gtk_label_new(NULL);
  gtk_label_set_width_chars(GTK_LABEL(lbl_scale_sep), 1);
  gtk_box_pack_end(GTK_BOX(hbox_scale), GTK_WIDGET(lbl_scale_sep), FALSE, FALSE,
                   0);

  gtk_box_pack_end(GTK_BOX(hbox_scale), g->bt_paste_scale, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hbox_scale), g->bt_copy_scale, FALSE, FALSE, 0);

  GtkWidget *lbl_scale_sep1 = gtk_label_new(NULL);
  gtk_label_set_width_chars(GTK_LABEL(lbl_scale_sep1), 1);
  gtk_box_pack_end(GTK_BOX(hbox_scale), GTK_WIDGET(lbl_scale_sep1), FALSE,
                   FALSE, 0);

  gtk_box_pack_end(GTK_BOX(hbox_scale), g->bt_display_wavelet_scale, FALSE,
                   FALSE, 0);

  g->vbox_preview_scale = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);

  GtkWidget *lbl_psc = dt_ui_section_label_new(_(""preview single scale""));
  gtk_box_pack_start(GTK_BOX(g->vbox_preview_scale), lbl_psc, FALSE, TRUE, 0);

  GtkWidget *prev_lvl = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

  g->preview_levels_bar = gtk_drawing_area_new();

  gtk_widget_set_tooltip_text(g->preview_levels_bar,
                              _(""adjust preview levels""));
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""draw"",
                   G_CALLBACK(rt_levelsbar_draw), self);
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""motion-notify-event"",
                   G_CALLBACK(rt_levelsbar_motion_notify), self);
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""leave-notify-event"",
                   G_CALLBACK(rt_levelsbar_leave_notify), self);
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""button-press-event"",
                   G_CALLBACK(rt_levelsbar_button_press), self);
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""button-release-event"",
                   G_CALLBACK(rt_levelsbar_button_release), self);
  g_signal_connect(G_OBJECT(g->preview_levels_bar), ""scroll-event"",
                   G_CALLBACK(rt_levelsbar_scrolled), self);
  gtk_widget_add_events(GTK_WIDGET(g->preview_levels_bar),
                        GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
                            GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
                            GDK_LEAVE_NOTIFY_MASK | GDK_SCROLL_MASK |
                            GDK_SMOOTH_SCROLL_MASK);
  gtk_widget_set_size_request(g->preview_levels_bar, -1, DT_PIXEL_APPLY_DPI(5));

  g->bt_auto_levels =
      dtgtk_togglebutton_new(_retouch_cairo_paint_auto_levels,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  g_object_set(G_OBJECT(g->bt_auto_levels), ""tooltip-text"", _(""auto levels""),
               (char *)NULL);
  g_signal_connect(G_OBJECT(g->bt_auto_levels), ""toggled"",
                   G_CALLBACK(rt_auto_levels_callback), self);
  gtk_widget_set_size_request(GTK_WIDGET(g->bt_auto_levels), bs, bs);
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->bt_auto_levels), FALSE);

  gtk_box_pack_end(GTK_BOX(prev_lvl), g->bt_auto_levels, FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(prev_lvl), GTK_WIDGET(g->preview_levels_bar), TRUE,
                     TRUE, 0);

  gtk_box_pack_start(GTK_BOX(g->vbox_preview_scale), prev_lvl, TRUE, TRUE, 0);

  GtkWidget *hbox_shape_sel = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
  GtkWidget *label1 = gtk_label_new(_(""shape selected:""));
  gtk_box_pack_start(GTK_BOX(hbox_shape_sel), label1, FALSE, TRUE, 0);
  g->label_form_selected = GTK_LABEL(gtk_label_new(""-1""));
  g_object_set(
      G_OBJECT(hbox_shape_sel), ""tooltip-text"",
      _(""click on a shape to select it,\nto unselect click on an empty space""),
      (char *)NULL);
  gtk_box_pack_start(GTK_BOX(hbox_shape_sel),
                     GTK_WIDGET(g->label_form_selected), FALSE, TRUE, 0);

  g->vbox_fill = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);

  g->cmb_fill_mode = dt_bauhaus_combobox_new(self);
  dt_bauhaus_widget_set_label(g->cmb_fill_mode, NULL, _(""fill mode""));
  dt_bauhaus_combobox_add(g->cmb_fill_mode, _(""erase""));
  dt_bauhaus_combobox_add(g->cmb_fill_mode, _(""color""));
  g_object_set(g->cmb_fill_mode, ""tooltip-text"",
               _(""erase the detail or fills with chosen color""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->cmb_fill_mode), ""value-changed"",
                   G_CALLBACK(rt_fill_mode_callback), self);

  GdkRGBA color = (GdkRGBA){.red = p->fill_color[0],
                            .green = p->fill_color[1],
                            .blue = p->fill_color[2],
                            .alpha = 1.0};

  g->hbox_color_pick = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);

  g->colorpick = gtk_color_button_new_with_rgba(&color);
  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g->colorpick), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->colorpick), bs, bs);
  gtk_color_button_set_title(GTK_COLOR_BUTTON(g->colorpick),
                             _(""select fill color""));
  g_object_set(G_OBJECT(g->colorpick), ""tooltip-text"", _(""select fill color""),
               (char *)NULL);

  g_signal_connect(G_OBJECT(g->colorpick), ""color-set"",
                   G_CALLBACK(rt_colorpick_color_set_callback), self);

  g->colorpicker = GTK_TOGGLE_BUTTON(
      dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker,
                             CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));
  g_object_set(G_OBJECT(g->colorpicker), ""tooltip-text"",
               _(""pick fill color from image""), (char *)NULL);
  gtk_widget_set_size_request(GTK_WIDGET(g->colorpicker), bs, bs);
  g_signal_connect(G_OBJECT(g->colorpicker), ""toggled"",
                   G_CALLBACK(dt_iop_color_picker_callback), &g->color_picker);

  GtkWidget *lbl_fill_color = gtk_label_new(_(""fill color: ""));

  g->sl_fill_brightness =
      dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, .0005, .0, 4);
  dt_bauhaus_widget_set_label(g->sl_fill_brightness, _(""brightness""),
                              _(""brightness""));
  g_object_set(
      g->sl_fill_brightness, ""tooltip-text"",
      _(""adjusts color brightness to fine-tune it. works with erase as well""),
      (char *)NULL);
  g_signal_connect(G_OBJECT(g->sl_fill_brightness), ""value-changed"",
                   G_CALLBACK(rt_fill_brightness_callback), self);

  gtk_box_pack_end(GTK_BOX(g->hbox_color_pick), GTK_WIDGET(g->colorpicker),
                   FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(g->hbox_color_pick), GTK_WIDGET(g->colorpick), FALSE,
                   TRUE, 0);
  gtk_box_pack_start(GTK_BOX(g->hbox_color_pick), lbl_fill_color, FALSE, TRUE,
                     0);
  gtk_box_pack_start(GTK_BOX(g->vbox_fill), GTK_WIDGET(g->cmb_fill_mode), TRUE,
                     TRUE, 0);
  gtk_box_pack_start(GTK_BOX(g->vbox_fill), g->hbox_color_pick, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(g->vbox_fill), g->sl_fill_brightness, TRUE, TRUE,
                     0);

  g->vbox_blur = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);

  g->cmb_blur_type = dt_bauhaus_combobox_new(self);
  dt_bauhaus_widget_set_label(g->cmb_blur_type, NULL, _(""blur type""));
  dt_bauhaus_combobox_add(g->cmb_blur_type, _(""gaussian""));
  dt_bauhaus_combobox_add(g->cmb_blur_type, _(""bilateral""));
  g_object_set(g->cmb_blur_type, ""tooltip-text"",
               _(""type for the blur algorithm""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->cmb_blur_type), ""value-changed"",
                   G_CALLBACK(rt_blur_type_callback), self);

  gtk_box_pack_start(GTK_BOX(g->vbox_blur), g->cmb_blur_type, TRUE, TRUE, 0);

  g->sl_blur_radius =
      dt_bauhaus_slider_new_with_range(self, 0.1, 200.0, 0.1, 10., 2);
  dt_bauhaus_widget_set_label(g->sl_blur_radius, _(""blur radius""),
                              _(""blur radius""));
  g_object_set(g->sl_blur_radius, ""tooltip-text"",
               _(""radius of the selected blur type""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->sl_blur_radius), ""value-changed"",
                   G_CALLBACK(rt_blur_radius_callback), self);

  gtk_box_pack_start(GTK_BOX(g->vbox_blur), g->sl_blur_radius, TRUE, TRUE, 0);

  g->sl_mask_opacity =
      dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.05, 1., 3);
  dt_bauhaus_widget_set_label(g->sl_mask_opacity, _(""mask opacity""),
                              _(""mask opacity""));
  g_object_set(g->sl_mask_opacity, ""tooltip-text"",
               _(""set the opacity on the selected shape""), (char *)NULL);
  g_signal_connect(G_OBJECT(g->sl_mask_opacity), ""value-changed"",
                   G_CALLBACK(rt_mask_opacity_callback), self);

  GtkWidget *lbl_rt_tools = dt_ui_section_label_new(_(""retouch tools""));
  gtk_box_pack_start(GTK_BOX(self->widget), lbl_rt_tools, FALSE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), hbox_shapes, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), hbox_algo, TRUE, TRUE, 0);

  GtkWidget *lbl_wd = dt_ui_section_label_new(_(""wavelet decompose""));
  gtk_box_pack_start(GTK_BOX(self->widget), lbl_wd, FALSE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), hbox_wd_labels, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(self->widget), g->wd_bar, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), hbox_scale, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), g->vbox_preview_scale, TRUE, TRUE,
                     0);

  GtkWidget *lbl_shapes = dt_ui_section_label_new(_(""shapes""));
  gtk_box_pack_start(GTK_BOX(self->widget), lbl_shapes, FALSE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), hbox_shape_sel, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), g->vbox_blur, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), g->vbox_fill, TRUE, TRUE, 0);

  gtk_box_pack_start(GTK_BOX(self->widget), g->sl_mask_opacity, TRUE, TRUE, 0);

  dt_control_signal_connect(
      darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,
      G_CALLBACK(rt_develop_ui_pipe_finished_callback), self);

  gtk_widget_show_all(g->vbox_blur);
  gtk_widget_set_no_show_all(g->vbox_blur, TRUE);

  gtk_widget_show_all(g->vbox_fill);
  gtk_widget_set_no_show_all(g->vbox_fill, TRUE);

  gtk_widget_show_all(g->vbox_preview_scale);
  gtk_widget_set_no_show_all(g->vbox_preview_scale, TRUE);

  rt_show_hide_controls(self, g, p, g);

  dt_iop_init_single_picker(&g->color_picker, self, GTK_WIDGET(g->colorpicker),
                            DT_COLOR_PICKER_POINT, _iop_color_picker_apply);
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered."	2	"uint8_t MS_Host_PreventAllowMediumRemoval(
    USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex,
    const bool PreventRemoval) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(0),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3, int __i4, int __i5,
                 int __i6, int __i7) {
  return (__m256i)(__v8si){__i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0};
}"
fanglingsu-vimb-beba6b1/src/ex.c	Handles the keypress events from webview and inputbox.	2	"VbResult ex_keypress(Client *c, int key) {
  GtkTextIter start, end;
  gboolean check_empty = FALSE;
  GtkTextBuffer *buffer = c->buffer;
  GtkTextMark *mark;
  VbResult res;
  const char *text;

  if (key == CTRL('C')) {
    vb_enter(c, 'n');
    return RESULT_COMPLETE;
  }

  if (c->mode->flags & FLAG_HINTING &&
      RESULT_COMPLETE == hints_keypress(c, key)) {

    return RESULT_COMPLETE;
  }

  if (info.phase == PHASE_REG) {
    info.reg = (char)key;
    info.phase = PHASE_REG;

    text = vb_register_get(c, (char)key);
    if (text) {
      gtk_text_buffer_insert_at_cursor(buffer, text, strlen(text));
    }

    res = RESULT_COMPLETE;
  } else {
    res = RESULT_COMPLETE;
    switch (key) {
    case KEY_TAB:
      complete(c, 1);
      break;

    case KEY_SHIFT_TAB:
      complete(c, -1);
      break;

    case KEY_UP:
    case CTRL('P'):
      history(c, TRUE);
      break;

    case KEY_DOWN:
    case CTRL('N'):
      history(c, FALSE);
      break;

    case KEY_CR:
      input_activate(c);
      break;

    case CTRL('['):
      vb_enter(c, 'n');
      vb_input_set_text(c, """");
      break;

    case CTRL('H'):

      mark = gtk_text_buffer_get_insert(buffer);
      gtk_text_buffer_get_iter_at_mark(buffer, &start, mark);
      gtk_text_buffer_backspace(buffer, &start, TRUE, TRUE);
      check_empty = TRUE;
      break;

    case CTRL('W'):

      mark = gtk_text_buffer_get_insert(buffer);
      gtk_text_buffer_get_iter_at_mark(buffer, &end, mark);

      start = end;

      if (gtk_text_iter_backward_word_start(&start)) {
        gtk_text_buffer_delete(buffer, &start, &end);
      }
      check_empty = TRUE;
      break;

    case CTRL('B'):

      gtk_text_buffer_get_iter_at_offset(buffer, &start,
                                         strlen(c->state.prompt));
      gtk_text_buffer_place_cursor(buffer, &start);
      break;

    case CTRL('E'):

      gtk_text_buffer_get_end_iter(buffer, &start);
      gtk_text_buffer_place_cursor(buffer, &start);
      break;

    case CTRL('U'):

      mark = gtk_text_buffer_get_insert(buffer);
      gtk_text_buffer_get_iter_at_mark(buffer, &end, mark);
      gtk_text_buffer_get_iter_at_offset(buffer, &start,
                                         strlen(c->state.prompt));
      gtk_text_buffer_delete(buffer, &start, &end);
      break;

    case CTRL('R'):
      info.phase = PHASE_REG;
      c->mode->flags |= FLAG_NOMAP;
      res = RESULT_MORE;
      break;

    default:

      if (key >= 0x20 && key <= 0x7e) {
        gtk_text_buffer_insert_at_cursor(buffer, (char[2]){key, 0}, 1);
      } else {
        c->state.processed_key = FALSE;
      }
    }
  }

  if (check_empty) {
    gtk_text_buffer_get_bounds(buffer, &start, &end);
    if (gtk_text_iter_equal(&start, &end)) {
      vb_enter(c, 'n');
      vb_input_set_text(c, """");
    }
  }

  if (res == RESULT_COMPLETE) {
    info.reg = 0;
    info.phase = PHASE_START;
  }

  return res;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/Incomplete/BluetoothHost/Lib/RFCOMM.c	"Sends an RFCOMM notification to the remote device that the local terminal control signals (located in the ""Local"" structure of the RFCOMM channel) have changed, pushing the new signals to the remote device."	2	"void RFCOMM_SendChannelSignals(const RFCOMM_Channel_t *const RFCOMMChannel,
                               Bluetooth_Channel_t *const ACLChannel) {
  BT_RFCOMM_DEBUG(1, "">> MSC Command"");
  BT_RFCOMM_DEBUG(2, ""-- DLCI 0x%02X"", RFCOMMChannel->DLCI);

  struct {
    RFCOMM_Command_t CommandHeader;
    uint8_t Length;
    RFCOMM_MSC_Parameters_t Params;
  } MSCommand;

  MSCommand.CommandHeader = (RFCOMM_Command_t){
      .Command = RFCOMM_Control_ModemStatus, .EA = true, .CR = true};
  MSCommand.Length = (sizeof(MSCommand.Params) << 1) | 0x01;
  MSCommand.Params.Channel =
      (RFCOMM_Address_t){.DLCI = RFCOMMChannel->DLCI, .EA = true, .CR = true};
  MSCommand.Params.Signals = RFCOMMChannel->Local.Signals;
  MSCommand.Params.BreakSignal = RFCOMMChannel->Local.BreakSignal;

  RFCOMM_SendFrame(RFCOMM_CONTROL_DLCI, true, RFCOMM_Frame_UIH,
                   sizeof(MSCommand), &MSCommand, ACLChannel);
}"
ging-isabel-1ec0172/lib/ffmpeg/Win32/src/ffmpeg/libavformat/utils.c	"Add a new stream to a media file. Can only be called in the read_header() function. If the flag AVFMTCTX_NOHEADER is in the format context, then new streams can be added in read_packet too."	2	"AVStream *av_new_stream(AVFormatContext *s, int id) {
  AVStream *st;
  int i;

#if FF_API_MAX_STREAMS
  if (s->nb_streams >= MAX_STREAMS) {
    av_log(s, AV_LOG_ERROR, ""Too many streams\n"");
    return NULL;
  }
#else
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;
#endif

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }

  st->codec = avcodec_alloc_context();
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->id = id;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  av_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

#if __STDC_VERSION >= 199901L
  st->sample_aspect_ratio = (AVRational){0, 1};
#else
  {
    static AVRational __sar = {0, 1};
    st->sample_aspect_ratio = __sar;
  }
#endif

  s->streams[s->nb_streams++] = st;
  return st;
}"
NVIDIA-AI-IOT-deepstream_reference_apps-3a8957b/yolo/plugins/gst-yoloplugin-tegra/gstyoloplugin.cpp	Only update string label in an existing object metadata. No bounding boxes. We assume only one label per object is generated	2	"attach_metadata_object(GstYoloPlugin *yoloplugin, NvDsObjectParams *obj_param,
                       YoloPluginOutput *output) {
  if (output->numObjects == 0)
    return;

  NvOSD_TextParams &text_params = obj_param->text_params;
  NvOSD_RectParams &rect_params = obj_param->rect_params;

  obj_param->has_new_info = TRUE;

  strcpy(obj_param->attr_info[yoloplugin->unique_id].attr_label,
         output->object[0].label);

  obj_param->attr_info[yoloplugin->unique_id].is_attr_label = 1;

  if (text_params.display_text) {
    gchar *conc_string = g_strconcat(text_params.display_text, "" "",
                                     output->object[0].label, NULL);
    g_free(text_params.display_text);
    text_params.display_text = conc_string;
  } else {

    text_params.x_offset = rect_params.left;
    text_params.y_offset = rect_params.top - 10;
    text_params.display_text = g_strdup(output->object[0].label);

    text_params.font_params.font_name = (char *)""Arial"";
    text_params.font_params.font_size = 11;
    text_params.font_params.font_color = (NvOSD_ColorParams){1, 1, 1, 1};

    text_params.set_bg_clr = 1;
    text_params.text_bg_clr = (NvOSD_ColorParams){0, 0, 0, 1};
  }
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/AVR8/Host_AVR8.c	"Convenience function. This routine sends a GET DESCRIPTOR standard request to the attached device, requesting the string descriptor of the specified index. This can be used to easily retrieve string descriptors from the device by index, after the index is obtained from the Device or Configuration descriptors."	0	"uint8_t USB_Host_GetDeviceStringDescriptor(const uint8_t Index,
                                           void *const Buffer,
                                           const uint8_t BufferLength) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (DTYPE_String << 8) | Index,
      .wIndex = 0,
      .wLength = BufferLength,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance levels get command and testing the received values.	3	"void arm_scmi_custom_test_performance_levels_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t rcv_u;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_levels_get, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_get,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(test_stats, SKIP, ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_get,
                                         domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      rcv_u = RETURN_VAL(received, struct arm_scmi_performance_levels_get,
                         performance_level);
      arm_scmi_check_and_report_dec(
          test_stats, ALL_BITS_SET, check_or_print,
          ptr_data->domain_runtime_values[domain_id].current_level, rcv_u,
          ""PERFORMANCE LEVEL"");
    }
  }
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/ints.c	Allocates new integer with 8B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int64() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 8);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_64}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
NVIDIA-AI-IOT-deepstream_reference_apps-3a8957b/yolo/plugins/gst-yoloplugin-tesla/gstyoloplugin.cpp	Only update string label in an existing object metadata. No bounding boxes. We assume only one label per object is generated	2	"attach_metadata_object(GstYoloPlugin *yoloplugin, NvDsObjectParams *obj_param,
                       YoloPluginOutput *output) {
  if (output->numObjects == 0)
    return;
  NvOSD_TextParams &text_params = obj_param->text_params;
  NvOSD_RectParams &rect_params = obj_param->rect_params;

  obj_param->has_new_info = TRUE;

  strcpy(obj_param->attr_info[yoloplugin->unique_id].attr_label,
         output->object[0].label);

  obj_param->attr_info[yoloplugin->unique_id].is_attr_label = 1;

  if (text_params.display_text) {
    gchar *conc_string = g_strconcat(text_params.display_text, "" "",
                                     output->object[0].label, NULL);
    g_free(text_params.display_text);
    text_params.display_text = conc_string;
  } else {

    text_params.x_offset = rect_params.left;
    text_params.y_offset = rect_params.top - 10;
    text_params.display_text = g_strdup(output->object[0].label);

    text_params.font_params.font_name = ""Arial"";
    text_params.font_params.font_size = 11;
    text_params.font_params.font_color = (NvOSD_ColorParams){1, 1, 1, 1};

    text_params.set_bg_clr = 1;
    text_params.text_bg_clr = (NvOSD_ColorParams){0, 0, 0, 1};
  }
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the device sense data, indicating the current device state and error codes for the previously issued command."	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       SenseData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
squidfunk-protobluff-f6ee42c/src/util/chunk_allocator.c	Create a chunk allocator with a minimum capacity.	2	"pb_chunk_allocator_create_with_capacity(size_t capacity) {
  assert(capacity);
  pb_allocator_t allocator = {.proc = {.allocate = allocator_allocate,
                                       .resize = allocator_resize,
                                       .free = allocator_free},
                              .data = NULL};
  pb_chunk_allocator_t *base = malloc(sizeof(pb_chunk_allocator_t));
  if (base) {
    *base = (pb_chunk_allocator_t){.next = NULL, .capacity = capacity};
    allocator.data = base;
  }
  return allocator;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;
    if (!link->src || !link->dst) {
      av_log(filter, AV_LOG_ERROR,
             ""Not all input and output are properly linked (%d).\n"", i);
      return AVERROR(EINVAL);
    }

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = link->current_pts_us = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink) {
          if (!link->frame_rate.num && !link->frame_rate.den)
            link->frame_rate = inlink->frame_rate;
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if (link->src->nb_inputs && link->src->inputs[0]->hw_frames_ctx &&
          !(link->src->filter->flags_internal & FF_FILTER_FLAG_HWFRAME_AWARE)) {
        av_assert0(!link->hw_frames_ctx &&
                   ""should not be set by non-hwframe-aware filter"");
        link->hw_frames_ctx =
            av_buffer_ref(link->src->inputs[0]->hw_frames_ctx);
        if (!link->hw_frames_ctx)
          return AVERROR(ENOMEM);
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
dm-vdo-kvdo-8df6805/vdo/base/vdoRecovery.c	"Create an array of all valid journal entries, in order, and store it in the recovery completion."	2	"static int extractJournalEntries(RecoveryCompletion *recovery) {

  int result = ALLOCATE(recovery->increfCount, NumberedBlockMapping, __func__,
                        &recovery->entries);
  if (result != VDO_SUCCESS) {
    return result;
  }

  RecoveryPoint recoveryPoint = {
      .sequenceNumber = recovery->blockMapHead,
      .sectorCount = 1,
      .entryCount = 0,
  };
  while (beforeRecoveryPoint(&recoveryPoint, &recovery->tailRecoveryPoint)) {
    RecoveryJournalEntry entry = getEntry(recovery, &recoveryPoint);
    result = validateRecoveryJournalEntry(recovery->vdo, &entry);
    if (result != VDO_SUCCESS) {
      enterReadOnlyMode(&recovery->vdo->readOnlyContext, result);
      return result;
    }

    if (isIncrementOperation(entry.operation)) {
      recovery->entries[recovery->entryCount] = (NumberedBlockMapping){
          .blockMapSlot = entry.slot,
          .blockMapEntry = packPBN(entry.mapping.pbn, entry.mapping.state),
          .number = recovery->entryCount,
      };
      recovery->entryCount++;
    }

    incrementRecoveryPoint(&recoveryPoint);
  }

  result = ASSERT((recovery->entryCount <= recovery->increfCount),
                  ""approximate incref count is an upper bound"");
  if (result != VDO_SUCCESS) {
    enterReadOnlyMode(&recovery->vdo->readOnlyContext, result);
  }

  return result;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/chatline.c	Open connection list dialog	2	"static void popup_conn_list_dialog(void) {
  SDL_Color window_bg_color = {255, 255, 255, 96};

  struct widget *pWindow = NULL, *pBuf = NULL, *pLabel = NULL;
  struct widget *pBackButton = NULL;
  struct widget *pStartGameButton = NULL;
  struct widget *pSelectNationButton = NULL;

  utf8_str *pstr = NULL;
  int n;
  SDL_Rect area;
  SDL_Surface *pSurf;

  if (pConnDlg || !client.conn.established) {
    return;
  }

  meswin_dialog_popdown();

  pConnDlg = fc_calloc(1, sizeof(struct CONNLIST));

  pWindow = create_window_skeleton(NULL, NULL, 0);
  pWindow->action = conn_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);
  clear_wflag(pWindow, WF_DRAW_FRAME_AROUND_WIDGET);

  pConnDlg->pEndWidgetList = pWindow;
  add_to_gui_list(ID_WINDOW, pWindow);

  widget_set_position(pWindow, 0, 0);

  pSurf = theme_get_background(theme, BACKGROUND_CONNLISTDLG);
  if (resize_window(pWindow, pSurf, NULL, main_window_width(),
                    main_window_height())) {
    FREESURFACE(pSurf);
  }

  pConnDlg->text_width =
      pWindow->size.w - adj_size(130) - adj_size(20) - adj_size(20);

  area.x = adj_size(10);
  area.y = adj_size(14);
  area.w = pConnDlg->text_width + adj_size(20);
  area.h = pWindow->size.h - adj_size(44) - adj_size(40);
  fill_rect_alpha(pWindow->theme, &area, &window_bg_color);

  create_frame(pWindow->theme, area.x - 1, area.y - 1, area.w + 1, area.h + 1,
               get_theme_color(COLOR_THEME_CONNLISTDLG_FRAME));

  area.x = pWindow->size.w - adj_size(130);
  area.y = adj_size(14);
  area.w = adj_size(120);
  area.h = pWindow->size.h - adj_size(44) - adj_size(40);
  fill_rect_alpha(pWindow->theme, &area, &window_bg_color);

  create_frame(pWindow->theme, area.x - 1, area.y - 1, area.w + 1, area.h + 1,
               get_theme_color(COLOR_THEME_CONNLISTDLG_FRAME));

  draw_frame(pWindow->theme, 0, 0, pWindow->theme->w, pWindow->theme->h);

  pConnDlg->pChat_Dlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  n = conn_list_size(game.est_connections);

  {
    char cbuf[256];

    fc_snprintf(cbuf, sizeof(cbuf), _(""Total users logged in : %d""), n);
    pstr = create_utf8_from_char(cbuf, adj_font(12));
  }

  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  pLabel = create_themelabel2(
      NULL, pWindow->dst, pstr, pConnDlg->text_width, 0,
      (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));

  widget_set_position(pLabel, adj_size(10), adj_size(14));

  add_to_gui_list(ID_LABEL, pLabel);

  pConnDlg->pChat_Dlg->pBeginWidgetList = pLabel;
  pConnDlg->pChat_Dlg->pEndWidgetList = pLabel;
  pConnDlg->pChat_Dlg->pBeginActiveWidgetList =
      pConnDlg->pChat_Dlg->pBeginWidgetList;
  pConnDlg->pChat_Dlg->pEndActiveWidgetList =
      pConnDlg->pChat_Dlg->pEndWidgetList;

  n = (pWindow->size.h - adj_size(44) - adj_size(40)) / pLabel->size.h;
  pConnDlg->active = n;

  create_vertical_scrollbar(pConnDlg->pChat_Dlg, 1, pConnDlg->active, TRUE,
                            TRUE);

  setup_vertical_scrollbar_area(
      pConnDlg->pChat_Dlg->pScroll, adj_size(10) + pConnDlg->text_width + 1,
      adj_size(14), pWindow->size.h - adj_size(44) - adj_size(40), FALSE);
  hide_scrollbar(pConnDlg->pChat_Dlg->pScroll);

  pBuf = create_edit_from_chars(NULL, pWindow->dst, """", adj_font(12),
                                pWindow->size.w - adj_size(10) - adj_size(10),
                                (WF_RESTORE_BACKGROUND | WF_EDIT_LOOP));

  pBuf->size.x = adj_size(10);
  pBuf->size.y = pWindow->size.h - adj_size(40) - adj_size(5) - pBuf->size.h;
  pBuf->action = input_edit_conn_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pConnDlg->pEdit = pBuf;
  add_to_gui_list(ID_EDIT, pBuf);

  pBuf = create_themeicon_button_from_chars(
      current_theme->BACK_Icon, pWindow->dst, _(""Back""), adj_font(12), 0);
  pBuf->size.x = adj_size(10);
  pBuf->size.y = pWindow->size.h - adj_size(10) - pBuf->size.h;
  pConnDlg->pBackButton = pBuf;
  pBuf->action = disconnect_conn_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;
  add_to_gui_list(ID_BUTTON, pBuf);
  pBackButton = pBuf;

  pBuf = create_themeicon_button_from_chars(
      current_theme->OK_Icon, pWindow->dst, _(""Start""), adj_font(12), 0);
  pBuf->size.x = pWindow->size.w - adj_size(10) - pBuf->size.w;
  pBuf->size.y = pBackButton->size.y;
  pConnDlg->pStartButton = pBuf;
  pBuf->action = start_game_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  add_to_gui_list(ID_BUTTON, pBuf);
  pStartGameButton = pBuf;

  pBuf = create_themeicon_button_from_chars(NULL, pWindow->dst,
                                            _(""Pick Nation""), adj_font(12), 0);
  pBuf->size.h = pStartGameButton->size.h;
  pBuf->size.x = pStartGameButton->size.x - adj_size(10) - pBuf->size.w;
  pBuf->size.y = pStartGameButton->size.y;
  pConnDlg->pSelectNationButton = pBuf;
  pBuf->action = select_nation_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  add_to_gui_list(ID_BUTTON, pBuf);
  pSelectNationButton = pBuf;

  pBuf = create_themeicon_button_from_chars(NULL, pWindow->dst, _(""Load Game""),
                                            adj_font(12), 0);
  pBuf->size.h = pSelectNationButton->size.h;
  pBuf->size.x = pSelectNationButton->size.x - adj_size(10) - pBuf->size.w;
  pBuf->size.y = pSelectNationButton->size.y;
  pConnDlg->pLoadGameButton = pBuf;
  pBuf->action = load_game_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  add_to_gui_list(ID_BUTTON, pBuf);

#if 0
  pBuf = create_themeicon_button_from_chars(NULL, pWindow->dst,
                                            _(""Server Settings""),
                                            adj_font(12), 0);
  pBuf->size.h = pSelectNationButton->size.h;
  pBuf->size.x = pSelectNationButton->size.x - adj_size(10) - pBuf->size.w;
  pBuf->size.y = pSelectNationButton->size.y;
  pConnDlg->pConfigure = pBuf;
  pBuf->action = server_config_callback;
  set_wstate(pBuf, FC_WS_DISABLED);
  add_to_gui_list(ID_BUTTON, pBuf);
  pServerSettingsButton = pBuf;
#endif

#if 0
  pBuf = create_themeicon_button_from_chars(NULL, pWindow->dst->surface,
                                            ""?"", adj_font(12), 0);
  pBuf->size.y = pWindow->size.y + pWindow->size.h - (pBuf->size.h + 7);
  pBuf->size.x = pWindow->size.x + pWindow->size.w - (pBuf->size.w + 10) - 5;

  pBuf->action = client_config_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  add_to_gui_list(ID_BUTTON, pBuf);
#endif

  pConnDlg->pBeginWidgetList = pBuf;

  conn_list_dialog_update();
}"
phase4ground-trans-ionospheric-f4aac83/firmware/src/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    mbp_background_led_stop();
    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
  mbp_background_led_start();
}"
longluo-FFMpeg-bc33159/jni/libffmpeg/libavcodec/ituh263enc.c	Returns the 4 bit value that specifies the given aspect ratio. This may be one of the standard aspect ratios or it specifies that the aspect will be stored explicitly later.	2	"av_const int ff_h263_aspect_to_info(AVRational aspect) {
  int i;

  if (aspect.num == 0)
    aspect = (AVRational){1, 1};

  for (i = 1; i < 6; i++) {
    if (av_cmp_q(ff_h263_pixel_aspect[i], aspect) == 0) {
      return i;
    }
  }

  return FF_ASPECT_EXTENDED;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/HID.c	"Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices."	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/RNDISEthernetHost/Lib/RNDISCommands.c	Function to send the given encapsulated RNDIS command to the device.	0	"uint8_t RNDIS_SendEncapsulatedCommand(void *const Buffer,
                                      const uint16_t Length) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = RNDIS_REQ_SendEncapsulatedCommand,
      .wValue = 0,
      .wIndex = 0,
      .wLength = Length,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
boazsegev-iodine-b6bdf50/ext/iodine/http_mime_parser.h	Takes the HTTP Content-Type header and initializes the parser data. Note: the Content-Type header should persist in memory while the parser is in use. takes the HTTP Content-Type header and initializes the parser data.	0	"static int http_mime_parser_init(http_mime_parser_s *parser, char *content_type,
                                 size_t len) {
  *parser = (http_mime_parser_s){.done = 0};
  if (len < 14 || strncasecmp(""multipart/form"", content_type, 14))
    return -1;
  char *cut = memchr(content_type, ';', len);
  while (cut) {
    ++cut;
    len -= (size_t)(cut - content_type);
    while (len && cut[0] == ' ') {
      --len;
      ++cut;
    }
    if (len <= 9)
      return -1;
    if (strncasecmp(""boundary="", cut, 9)) {
      content_type = cut;
      cut = memchr(cut, ';', len);
      continue;
    }
    cut += 9;
    len -= 9;
    content_type = cut;
    parser->boundary = content_type;
    if ((cut = memchr(content_type, ';', len)))
      parser->boundary_len = (size_t)(cut - content_type);
    else
      parser->boundary_len = len;
    return 0;
  }
  return -1;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/xmmintrin.h	Constructs a 128-bit floating-point vector of [4 x float] initialized with the specified single-precision floating-point values. This intrinsic is a utility function and does not correspond to a specific instruction.	2	"_mm_set_ps(float __z, float __y, float __x, float __w) {
  return __extension__(__m128){__w, __x, __y, __z};
}"
dm-vdo-kvdo-8df6805/vdo/base/vdoRecovery.c	Find the contiguous range of journal blocks.	2	"static bool findContiguousRange(RecoveryCompletion *recovery) {
  RecoveryJournal *journal = recovery->vdo->recoveryJournal;
  SequenceNumber head =
      minSequenceNumber(recovery->blockMapHead, recovery->slabJournalHead);

  bool foundEntries = false;
  for (SequenceNumber i = head; i <= recovery->highestTail; i++) {
    recovery->tail = i;
    recovery->tailRecoveryPoint = (RecoveryPoint){
        .sequenceNumber = i,
        .sectorCount = 0,
        .entryCount = 0,
    };

    PackedJournalHeader *packedHeader =
        getJournalBlockHeader(journal, recovery->journalData, i);
    RecoveryBlockHeader header;
    unpackRecoveryBlockHeader(packedHeader, &header);

    if (!isExactRecoveryJournalBlock(journal, &header, i) ||
        (header.entryCount > journal->entriesPerBlock)) {

      break;
    }

    JournalEntryCount blockEntries = header.entryCount;

    for (uint8_t j = 1; j < SECTORS_PER_BLOCK; j++) {
      PackedJournalSector *sector = getJournalBlockSector(packedHeader, j);

      if (!isValidRecoveryJournalSector(&header, sector)) {
        break;
      }

      JournalEntryCount sectorEntries =
          minBlock(sector->entryCount, blockEntries);
      if (sectorEntries > 0) {
        foundEntries = true;
        recovery->tailRecoveryPoint.sectorCount++;
        recovery->tailRecoveryPoint.entryCount = sectorEntries;
        blockEntries -= sectorEntries;
      }

      if ((sectorEntries < RECOVERY_JOURNAL_ENTRIES_PER_SECTOR) ||
          (blockEntries == 0)) {
        break;
      }
    }

    if ((header.entryCount != journal->entriesPerBlock) || (blockEntries > 0)) {
      break;
    }
  }

  if (foundEntries && (recovery->tailRecoveryPoint.sectorCount == 0)) {
    recovery->tail--;
  }

  return foundEntries;
}"
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance domain attributes command and testing the received values.	2	"void arm_scmi_custom_test_performance_domain_attributes(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t attributes;
  uint32_t protocol_mask = expected_flags_mask;
  uint32_t rcv_u, exp_u;
  uint32_t rate_limit;
  char *domain_name;
  bool domain_expected;
  char *rcv_s, *exp_s;
  struct arm_scmi_protocol_execution_context *prot = protocol_execution_context;
  struct arm_scmi_performance_expected *pe = performance_expected;
  enum test_status res;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_domain_attributes,
                           domain_id)) {

    test_case->parameters[OFFSET_PARAM(
        struct arm_scmi_performance_domain_attributes, domain_id)] =
        performance_protocol_data.num_performance_domains + 1;
    error_code =
        arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0;
         domain_id < performance_protocol_data.num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_performance_domain_attributes, domain_id)] =
          domain_id;
      snprintf(description, NUM_ELEMS(description),
               ""\n\t\tPERFORMANCE DOMAIN ID %d"", domain_id);
      arm_scmi_log(&prot->test_stats, description);
      error_code =
          arm_scmi_execute_and_assert_test_case(prot, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;
      attributes = RETURN_VAL(
          received, struct arm_scmi_performance_domain_attributes, attributes);
      domain_expected =
          ((pe != NULL) && (domain_id < pe->num_performance_domains));

      res = INFO;
      rcv_u =
          arm_scmi_get_norm_bits(attributes, PERFORMANCE_DOMAIN_ATTR_LIMIT_SET,
                                 PERFORMANCE_DOMAIN_ATTR_LIMIT_SET);
      snprintf(name, NUM_ELEMS(name), ""PERFORMANCE SET LIMITS"");
      if ((pe->set_limit_capable != NULL) &&
          (protocol_mask & LEFT_SHIFT(PERFORMANCE_SET_LIMIT_CAPABLE))) {
        exp_u = pe->set_limit_capable[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u =
          arm_scmi_get_norm_bits(attributes, PERFORMANCE_DOMAIN_ATTR_LEVEL_SET,
                                 PERFORMANCE_DOMAIN_ATTR_LEVEL_SET);
      snprintf(name, NUM_ELEMS(name), ""PERFORMANCE SET LEVEL"");
      if ((pe->set_performance_level_capable != NULL) &&
          (protocol_mask &
           LEFT_SHIFT(PERFORMANCE_SET_PERFORMANCE_LEVEL_CAPABLE)) &&
          domain_expected) {
        exp_u = pe->set_performance_level_capable[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     PERFORMANCE_DOMAIN_ATTR_LIMIT_NOTIFY,
                                     PERFORMANCE_DOMAIN_ATTR_LIMIT_NOTIFY);
      snprintf(name, NUM_ELEMS(name), ""PERFORMANCE LIMITS CHANGE NOTIFICATION"");
      if ((pe->performance_limit_notification_support != NULL) &&
          (protocol_mask &
           LEFT_SHIFT(PERFORMANCE_LIMIT_NOTIFICATION_SUPPORT)) &&
          domain_expected) {
        exp_u = pe->performance_limit_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(attributes,
                                     PERFORMANCE_DOMAIN_ATTR_LEVEL_NOTIFY,
                                     PERFORMANCE_DOMAIN_ATTR_LEVEL_NOTIFY);
      snprintf(name, NUM_ELEMS(name), ""PERFORMANCE LEVEL CHANGE NOTIFICATION"");
      if ((pe->performance_level_notification_support != NULL) &&
          (protocol_mask &
           LEFT_SHIFT(PERFORMANCE_LEVEL_NOTIFICATION_SUPPORT)) &&
          domain_expected) {
        exp_u = pe->performance_level_notification_support[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      arm_scmi_check_and_report_dec(
          &prot->test_stats, ALL_BITS_SET, CHECK, RESERVED,
          arm_scmi_get_norm_bits(attributes,
                                 PERFORMANCE_DOMAIN_ATTR_RESERVED_HIGH,
                                 PERFORMANCE_DOMAIN_ATTR_RESERVED_LOW),
          ""RESERVED"");

      performance_protocol_data.domain_runtime_values[domain_id].attributes =
          attributes;

      rate_limit = RETURN_VAL(
          received, struct arm_scmi_performance_domain_attributes, rate_limit);

      rcv_u = arm_scmi_get_norm_bits(rate_limit,
                                     PERFORMANCE_DOMAIN_ATTR_RATE_RESERVED_HIGH,
                                     PERFORMANCE_DOMAIN_ATTR_RATE_RESERVED_LOW);
      arm_scmi_check_and_report_dec(&prot->test_stats, ALL_BITS_SET, CHECK,
                                    RESERVED, rcv_u, ""RESERVED/RATE LIMIT"");

      res = INFO;
      rcv_u = arm_scmi_get_norm_bits(rate_limit,
                                     PERFORMANCE_DOMAIN_ATTR_RATE_LIMIT_HIGH,
                                     PERFORMANCE_DOMAIN_ATTR_RATE_LIMIT_LOW);
      snprintf(name, NUM_ELEMS(name), ""RATE LIMIT(microseconds)"");
      if ((pe->performance_rate_limit != NULL) &&
          (protocol_mask & LEFT_SHIFT(PERFORMANCE_RATE_LIMIT)) &&
          domain_expected) {
        exp_u = pe->performance_rate_limit[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u =
          RETURN_VAL(received, struct arm_scmi_performance_domain_attributes,
                     sustained_freq);
      snprintf(name, NUM_ELEMS(name), ""SUSTAINED FREQUENCY(kHz)"");
      if ((pe->performance_sustained_freq != NULL) &&
          (protocol_mask & LEFT_SHIFT(PERFORMANCE_SUSTAINED_FREQ)) &&
          domain_expected) {
        exp_u = pe->performance_sustained_freq[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      rcv_u =
          RETURN_VAL(received, struct arm_scmi_performance_domain_attributes,
                     sustained_perf_level);
      snprintf(name, NUM_ELEMS(name), ""SUSTAINED LEVEL"");
      if ((pe->performance_sustained_level != NULL) &&
          (protocol_mask & LEFT_SHIFT(PERFORMANCE_SUSTAINED_LEVEL)) &&
          domain_expected) {
        exp_u = pe->performance_sustained_level[domain_id];
        res = (exp_u == rcv_u) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"", exp_u, rcv_u);
      }
      if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);

      res = INFO;
      domain_name = RETURN_STR(
          received, struct arm_scmi_performance_domain_attributes, name);
      rcv_s = domain_name;
      snprintf(name, NUM_ELEMS(name), ""DOMAIN NAME"");
      if ((pe->performance_domain_names != NULL) &&
          (protocol_mask & LEFT_SHIFT(PERFORMANCE_DOMAIN_NAMES)) &&
          domain_expected) {
        exp_s = pe->performance_domain_names[domain_id];
        res = (strcmp(rcv_s, exp_s) == 0) ? PASSED : FAILED;
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %s, Received: %s"", exp_s, rcv_s);
      }
      if ((res == INFO) || (res == PASSED)) {
        snprintf(description, NUM_ELEMS(description), ""'%s'"", rcv_s);
      }
      arm_scmi_log_test_result(&prot->test_stats, res, name, description);
    }
  }
}"
gexpander-gex-client-c-9f870ec/gex/gex_client.c	Create a instance and connect	2	"GexClient *GEX_Init(const char *device, uint32_t timeout_ms) {
  assert(device != NULL);

  GexClient *gex = calloc(1, sizeof(GexClient));
  assert(gex != NULL);

  gex->system_unit = (GexUnit){.name = ""SYSTEM"",
                               .type = ""SYSTEM"",
                               .callsign = 0,
                               .gex = gex,
                               .next = NULL,
                               .report_handler = NULL};

  gex->acm_device = device;
  gex->ser_timeout = timeout_ms;
  gex->acm_fd = serial_open(device);
  if (gex->acm_fd == -1) {
    free(gex);
    fprintf(stderr, ""FAILED TO CONNECT TO %s!\n"", device);
    return NULL;
  }

  gex->tf = TF_Init(TF_MASTER);
  gex->tf->userdata = gex;

  TF_QuerySimple(gex->tf, MSG_PING, NULL, 0, connectivity_check_lst, 0);
  GEX_Poll(gex, &gex->connected);

  if (!gex->connected) {
    fprintf(stderr, ""GEX doesn't respond to ping!\n"");
    GEX_DeInit(gex);
    return NULL;
  }

  fprintf(stderr, ""Loading available units info...\n"");
  TF_QuerySimple(gex->tf, MSG_LIST_UNITS, NULL, 0, list_units_lst, 0);
  GEX_Poll(gex, &gex->units_loaded);

  TF_AddTypeListener(gex->tf, MSG_UNIT_REPORT, unit_report_lst);

  TF_AddGenericListener(GEX_GetTF(gex), hdl_default);

  return gex;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/list-map.c	"Constructs a new list-map atop the given list. The list MUST have an even number of elements, and SHOULD be less than or equal to 2*AVA_LIST_MAP_THRESH in length."	2	"ava_map_value ava_list_map_of_list(ava_list_value list) {
  const ava_list_trait *restrict trait =
      ava_get_attribute(list.v, &ava_list_trait_tag);
  ava_list_map *this;

  assert(0 == ava_list_length(list) % 2);
  assert(trait);

  this = AVA_NEW(ava_list_map);
  this->header.tag = &ava_list_map_tag;
  this->header.next = (const ava_attribute *)&ava_list_map_map_impl;
  this->list_attr = ava_value_attr(list.v);
  this->v = trait;

  return (ava_map_value){ava_value_with_ulong(this, ava_value_ulong(list.v))};
}"
USGS-Astrogeology-ISIS3-056be1c/isis/src/base/objs/PhotoModel/PhotoModel.h	Obtain topographic derivative of an arbitrary photometric function	2	"public:
PhotoModel(Pvl &pvl);
virtual ~PhotoModel(){};

inline QString AlgorithmName() const { return p_photoAlgorithmName; }

virtual void SetStandardConditions(bool standard);

bool StandardConditions() const { return p_standardConditions; }

double PhtTopder(double phase, double incidence, double emission);

static double PhtAcos(double cosang);

double CalcSurfAlbedo(double pha, double inc, double ema);

virtual void SetPhotoL(const double l) { p_photoL = l; }

inline double PhotoL() const { return p_photoL; }

virtual void SetPhotoK(const double k) { p_photoK = k; }

inline double PhotoK() const { return p_photoK; }

virtual void SetPhotoHg1(const double hg1) { p_photoHg1 = hg1; }

inline double PhotoHg1() const { return p_photoHg1; }

virtual void SetPhotoHg2(const double hg2) { p_photoHg2 = hg2; }

inline double PhotoHg2() const { return p_photoHg2; }

virtual void SetPhotoBh(const double bh) { p_photoBh = bh; }

inline double PhotoBh() const { return p_photoBh; }

virtual void SetPhotoCh(const double ch) { p_photoCh = ch; }"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/http2/scheduler.c	opens a reference with given parent as its dependency	2	"void h2o_http2_scheduler_open(h2o_http2_scheduler_openref_t *ref,
                              h2o_http2_scheduler_node_t *parent,
                              uint16_t weight, int exclusive) {
  init_node(&ref->node, parent);
  ref->weight = weight;
  ref->_all_link = (h2o_linklist_t){NULL};
  ref->_active_cnt = 0;
  ref->_self_is_active = 0;
  ref->_queue_node = (h2o_http2_scheduler_queue_node_t){{NULL}};

  h2o_linklist_insert(&parent->_all_refs, &ref->_all_link);

  if (exclusive)
    convert_to_exclusive(parent, ref);
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Liefert Elemente entsprechend einer Maske zurck.  0 -> a, 1 -> b"	2	"static inline vec_float4 simd_select(const vec_float4 a, const vec_float4 b,
                                     const vec_uint4 mask) {
#if defined(__SSE__)
  return _mm_or_ps(_mm_andnot_ps((vec_float4)mask, a),
                   _mm_and_ps((vec_float4)mask, b));
#elif defined(__VEC__)
  return vec_sel(a, b, mask);
#elif defined(__NEON__)
  return vbslq_f32(mask, a, b);
#else
  const unsigned *restrict maskU = (const unsigned *)&mask;
  vec_uint4 aInt = (vec_uint4)a;
  vec_uint4 bInt = (vec_uint4)b;
  const unsigned *restrict aU = (const unsigned *)&aInt;
  const unsigned *restrict bU = (const unsigned *)&bInt;
  return (vec_float4)((vec_uint4){(aU[0] & ~maskU[0]) | (bU[0] & maskU[0]),
                                  (aU[1] & ~maskU[1]) | (bU[1] & maskU[1]),
                                  (aU[2] & ~maskU[2]) | (bU[2] & maskU[2]),
                                  (aU[3] & ~maskU[3]) | (bU[0] & maskU[3])});
#endif
}"
tsani-tetrefis-02d47ef/basic_types.c	Negates a vector.	2	"vec2 vec2_flip(vec2 p) { return (vec2){-p.x, -p.y}; }"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	"Constructs a quaternion from an array of four scalars. Note that the imaginary part of the quaternion comes from array elements 0, 1, and 2, and the real part comes from element 3."	2	"static inline SIMD_NONCONST simd_quatf simd_quaternion(const float xyzr[4]) {
  return (simd_quatf){*(const simd_packed_float4 *)xyzr};
}"
daos-stack-daos-956b717/src/tests/daosctl/io-cmds.c	Process a write command.	2	"cmd_write_pattern(int argc, const char **argv, void *ctx) {
  int rc = -ENXIO;
  daos_obj_id_t oid;
  struct ioreq req;
  const char dkey[] = ""test_update dkey"";
  const char akey[] = ""test_update akey"";

  const unsigned char *rec = PATTERN_1;

  struct container_info cinfo;

  struct argp_option options[] = {
      {""server-group"", 's', ""SERVER-GROUP"", 0,
       ""ID of the server group that owns the pool""},
      {""servers"", 'l', ""server rank-list"", 0,
       ""Pool service ranks, comma separated, no spaces e.g. -l 1,2""},
      {""p-uuid"", 'i', ""UUID"", 0, ""ID of the pool where data is to be written.""},
      {""c-uuid"", 'c', ""UUID"", 0,
       ""ID of the container where data is to be written.""},
      {""size"", 'z', ""size"", 0,
       ""How much to write in bytes or with k/m/g (e.g. 10g)""},
      {""pattern"", 'p', ""pattern"", 0,
       ""Data pattern to be written, one of: [0, 1]""},
      {0}};
  struct argp argp = {options, parse_cont_args_cb};

  struct io_cmd_options io_options = {""daos_server"", NULL,       NULL, NULL, 0,
                                      NULL,          ""all_zeros""};

  cinfo.server_group = io_options.server_group;
  cinfo.pool_service_list = (d_rank_list_t){NULL, 0};

  cinfo.server_group = io_options.server_group;
  cinfo.pool_service_list = (d_rank_list_t){NULL, 0};

  argv++;
  argc--;

  argp_parse(&argp, argc, (char **restrict)argv, 0, 0, &io_options);

  if (io_options.pool_uuid == NULL)
    return -EINVAL;
  rc = uuid_parse(io_options.pool_uuid, cinfo.pool_uuid);
  if (io_options.cont_uuid == NULL)
    return -EINVAL;
  rc = uuid_parse(io_options.cont_uuid, cinfo.cont_uuid);

  rc = parse_rank_list(io_options.server_list, &cinfo.pool_service_list);
  if (rc < 0) {
    D_PRINT(""Rank list parameter parsing failed with %i\n"", rc);
    return rc;
  }

  rc = open_container(&cinfo);

  oid = dts_oid_gen(dts_obj_class, 0, 0);

  if (!strncmp(""all_zeros"", io_options.pattern, 3))
    rec = PATTERN_0;
  else if (!strncmp(""sequential"", io_options.pattern, 3))
    rec = PATTERN_1;

  ioreq_init(&req, cinfo.coh, oid, DAOS_IOD_SINGLE);

  insert_single(dkey, akey, 0, (void *)rec, 64, DAOS_TX_NONE, &req);

  daos_cont_close(cinfo.coh, NULL);
  printf(""%"" PRIu64 ""-%"" PRIu64 ""\n"", oid.hi, oid.lo);

  if (cinfo.poh.cookie != 0)
    daos_pool_disconnect(cinfo.poh, NULL);
  return rc;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/HighLevel/ConfigDescriptor.c	"Retrieves the configuration descriptor data from an attached device via a standard request into a buffer, including validity and size checking to prevent a buffer overflow."	0	"uint8_t USB_Host_GetDeviceConfigDescriptor(uint8_t ConfigNumber,
                                           uint16_t *const ConfigSizePtr,
                                           void *BufferPtr,
                                           uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Configuration_Header_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  *ConfigSizePtr =
      DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
          ->TotalConfigurationSize;

  if (*ConfigSizePtr > BufferSize)
    return HOST_GETCONFIG_BuffOverflow;

  USB_ControlRequest.wLength = *ConfigSizePtr;

  if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    return HOST_GETCONFIG_InvalidData;

  return HOST_GETCONFIG_Successful;
}"
bus1-dbus-broker-b41db8a/src/dbus/sasl.c	sasl_client_deinit() - deinitialize SASL client : the client to operate on This deinitializes the SASL client object . It is safe to call deinit several times.	2	void sasl_client_deinit(SASLClient *sasl) { *sasl = (SASLClient){}; }
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance describe levels command and testing the received values.	2	"void arm_scmi_custom_test_performance_describe_levels(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  enum test_status res;
  uint32_t num_levels;
  uint32_t num_perf_levels, num_rem_perf_levels;
  uint32_t level_index = 0, n;
  uint32_t rcv_u, exp_u;
  struct arm_scmi_perf_levels *perf_levels;
  uint32_t rcv_num_levels;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  struct arm_scmi_performance_expected *pe = performance_expected;
  bool domain_expected;
  bool level_expected;
  uint32_t *levels;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_describe_levels,
                           domain_id)) {

    test_case->parameter_count = 2;
    test_case->parameters[OFFSET_PARAM(
        struct arm_scmi_performance_describe_levels, domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(
        struct arm_scmi_performance_describe_levels, level_index)] = 0;
    error_code = arm_scmi_execute_and_assert_test_case(
        protocol_execution_context, test_case, &received);
  } else {
    test_case->parameter_count = 2;

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {

      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_performance_describe_levels, domain_id)] = domain_id;
      rcv_num_levels = 0;
      level_index = 0;

      do {
        test_case->parameters[OFFSET_PARAM(
            struct arm_scmi_performance_describe_levels, level_index)] =
            level_index;
        snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
                 domain_id);
        arm_scmi_log(&protocol_execution_context->test_stats, description);
        error_code = arm_scmi_execute_and_assert_test_case(
            protocol_execution_context, test_case, &received);
        if ((error_code != NO_ERROR) ||
            (received.status != SCMI_STATUS_SUCCESS))
          break;
        domain_expected =
            ((pe != NULL) && (domain_id < pe->num_performance_domains));

        num_levels = RETURN_VAL(
            received, struct arm_scmi_performance_describe_levels, num_levels);
        num_rem_perf_levels = arm_scmi_get_norm_bits(
            num_levels, PERFORMANCE_DESC_LEVELS_NUM_LEVELS_REMAINING_HIGH,
            PERFORMANCE_DESC_LEVELS_NUM_LEVELS_REMAINING_LOW);
        num_perf_levels = arm_scmi_get_norm_bits(
            num_levels, PERFORMANCE_DESC_LEVELS_NUM_LEVELS_HIGH,
            PERFORMANCE_DESC_LEVELS_NUM_LEVELS_LOW);

        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      num_rem_perf_levels,
                                      ""NUMBER OF REMAINING PERFORMANCE LEVELS"");

        rcv_u = arm_scmi_get_norm_bits(
            num_levels, PERFORMANCE_DESC_LEVELS_ATTR_RESERVED_HIGH,
            PERFORMANCE_DESC_LEVELS_ATTR_RESERVED_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                      rcv_u, ""RESERVED"");

        rcv_u = num_perf_levels;
        rcv_num_levels += num_perf_levels;
        ptr_data->domain_runtime_values[domain_id].number_levels =
            rcv_num_levels;
        res = INFO;
        snprintf(name, NUM_ELEMS(name), ""NUMBER OF PERFORMANCE LEVELS"");
        if ((expected_flags_mask &
             LEFT_SHIFT(PERFORMANCE_NUM_PERFORMANCE_LEVELS)) &&
            (num_rem_perf_levels == 0) && domain_expected) {
          exp_u = pe->num_performance_levels[domain_id];
          res = rcv_u == exp_u ? PASSED : FAILED;
          snprintf(description, NUM_ELEMS(description),
                   ""Expected: %d, Received: %d"", exp_u, rcv_u);
        }
        if ((res == PASSED) || (res == INFO)) {
          snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
        }
        arm_scmi_log_test_result(test_stats, res, name, description);

        perf_levels =
            (struct arm_scmi_perf_levels *)(&received.payload[OFFSET_RET(
                struct arm_scmi_performance_describe_levels, perf_levels)]);
        levels = ptr_data->domain_runtime_values[domain_id].levels;
        for (n = 0; n < num_perf_levels; ++n) {
          snprintf(description, NUM_ELEMS(description),
                   ""\n\t\tDOMAIN ID %d, LEVEL %d"", domain_id, n);
          arm_scmi_log(test_stats, description);
          level_expected =
              (domain_expected && (pe->num_performance_levels != NULL) &&
               ((level_index + n) < pe->num_performance_levels[domain_id]));
          rcv_u = perf_levels[n].performance_level_value;

          if ((level_index + n) == 0) {
            levels[PERF_MIN] = levels[PERF_MIN + 1] = levels[PERF_MAX - 1] =
                levels[PERF_MAX] = rcv_u;
          } else if ((level_index + n) == 1) {
            levels[PERF_MIN + 1] = levels[PERF_MAX] = rcv_u;
          }
          levels[PERF_MAX - 1] = levels[PERF_MAX];
          levels[PERF_MAX] = rcv_u;

          res = INFO;
          snprintf(name, NUM_ELEMS(name), ""PERFORMANCE LEVEL VALUE"");
          if ((pe->performance_level_value != NULL) &&
              (expected_flags_mask & LEFT_SHIFT(PERFORMANCE_LEVEL_VALUE)) &&
              level_expected) {
            exp_u = pe->performance_level_value[domain_id][level_index + n];
            res = rcv_u == exp_u ? PASSED : FAILED;
            snprintf(description, NUM_ELEMS(description),
                     ""Expected: %d, Received: %d"", exp_u, rcv_u);
          }
          if ((res == PASSED) || (res == INFO)) {
            snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
          }
          arm_scmi_log_test_result(test_stats, res, name, description);

          res = INFO;
          snprintf(name, NUM_ELEMS(name), ""PERFORMANCE LEVEL POWER COST"");
          rcv_u = perf_levels[n].power_cost;
          if ((pe->performance_level_power_cost != NULL) &&
              (expected_flags_mask &
               LEFT_SHIFT(PERFORMANCE_LEVEL_POWER_COST)) &&
              level_expected) {
            exp_u =
                pe->performance_level_power_cost[domain_id][level_index + n];
            res = rcv_u == exp_u ? PASSED : FAILED;
            snprintf(description, NUM_ELEMS(description),
                     ""Expected: %d, Received: %d"", exp_u, rcv_u);
          }
          if ((res == PASSED) || (res == INFO)) {
            snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
          }
          arm_scmi_log_test_result(test_stats, res, name, description);

          rcv_u = arm_scmi_get_norm_bits(
              perf_levels[n].attributtes,
              PERFORMANCE_DESC_LEVELS_NUM_LEVELS_RESERVED_HIGH,
              PERFORMANCE_DESC_LEVELS_NUM_LEVELS_RESERVED_LOW);
          arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK,
                                        RESERVED, rcv_u, ""LEVEL RESERVED"");

          res = INFO;
          snprintf(name, NUM_ELEMS(name), ""WORST-CASE LATENCY(microseconds)"");
          rcv_u = arm_scmi_get_norm_bits(
              perf_levels[n].attributtes,
              PERFORMANCE_DESC_LEVELS_ATTR_TRANSITION_HIGH,
              PERFORMANCE_DESC_LEVELS_ATTR_TRANSITION_LOW);
          if ((pe->performance_level_worst_latency != NULL) &&
              (expected_flags_mask &
               LEFT_SHIFT(PERFORMANCE_LEVEL_WORST_LATENCY)) &&
              level_expected) {
            exp_u =
                pe->performance_level_worst_latency[domain_id][level_index + n];
            res = rcv_u == exp_u ? PASSED : FAILED;
            snprintf(description, NUM_ELEMS(description),
                     ""Expected: %d, Received: %d"", exp_u, rcv_u);
          }
          if ((res == PASSED) || (res == INFO)) {
            snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
          }
          arm_scmi_log_test_result(test_stats, res, name, description);
        }
        level_index += num_perf_levels;
      } while (num_rem_perf_levels);
    }
  }
}"
drchenmath-geometry-aefc9cc/src/utils/polygon.h	Add a 'polygon' consisting of two points	2	"void addLine(const Point from, const Point to) {
  paths.emplace_back((std::initializer_list<Point>){from, to});
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	"Clears a stall condition on the given pipe, via a CLEAR FEATURE standard request to the attached device."	1	"uint8_t USB_Host_ClearEndpointStall(const uint8_t EndpointAddress) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_SEL_EndpointHalt,
      .wIndex = EndpointAddress,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
jkkj93-FREYA-LIVE-LIBRARY-OPTIMIZER-FOR-ANDROID-082e851/ffmpeg/libavcodec/utils.c	"Decode the audio frame of size avpkt->size from avpkt->data into frame. Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with AV_CODEC_CAP_DELAY, then no samples will be returned."	2	"int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx,
                                              AVFrame *frame,
                                              int *got_frame_ptr,
                                              const AVPacket *avpkt) {
  AVCodecInternal *avci = avctx->internal;
  int ret = 0;

  *got_frame_ptr = 0;

  if (!avctx->codec)
    return AVERROR(EINVAL);

  if (!avctx->codec->decode) {
    av_log(avctx, AV_LOG_ERROR,
           ""This decoder requires using the avcodec_send_packet() API.\n"");
    return AVERROR(ENOSYS);
  }

  if (!avpkt->data && avpkt->size) {
    av_log(avctx, AV_LOG_ERROR, ""invalid packet: NULL data, size != 0\n"");
    return AVERROR(EINVAL);
  }
  if (avctx->codec->type != AVMEDIA_TYPE_AUDIO) {
    av_log(avctx, AV_LOG_ERROR, ""Invalid media type for audio\n"");
    return AVERROR(EINVAL);
  }

  av_frame_unref(frame);

  if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size ||
      (avctx->active_thread_type & FF_THREAD_FRAME)) {
    uint8_t *side;
    int side_size;
    uint32_t discard_padding = 0;
    uint8_t skip_reason = 0;
    uint8_t discard_reason = 0;

    AVPacket tmp = *avpkt;
    int did_split = av_packet_split_side_data(&tmp);
    ret = apply_param_change(avctx, &tmp);
    if (ret < 0)
      goto fail;

    avctx->internal->pkt = &tmp;
    if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
      ret = ff_thread_decode_frame(avctx, frame, got_frame_ptr, &tmp);
    else {
      ret = avctx->codec->decode(avctx, frame, got_frame_ptr, &tmp);
      av_assert0(ret <= tmp.size);
      frame->pkt_dts = avpkt->dts;
    }
    if (ret >= 0 && *got_frame_ptr) {
      avctx->frame_number++;
      av_frame_set_best_effort_timestamp(
          frame, guess_correct_pts(avctx, frame->pts, frame->pkt_dts));
      if (frame->format == AV_SAMPLE_FMT_NONE)
        frame->format = avctx->sample_fmt;
      if (!frame->channel_layout)
        frame->channel_layout = avctx->channel_layout;
      if (!av_frame_get_channels(frame))
        av_frame_set_channels(frame, avctx->channels);
      if (!frame->sample_rate)
        frame->sample_rate = avctx->sample_rate;
    }

    side = av_packet_get_side_data(avctx->internal->pkt,
                                   AV_PKT_DATA_SKIP_SAMPLES, &side_size);
    if (side && side_size >= 10) {
      avctx->internal->skip_samples = AV_RL32(side);
      discard_padding = AV_RL32(side + 4);
      av_log(avctx, AV_LOG_DEBUG,
             ""skip %d / discard %d samples due to side data\n"",
             avctx->internal->skip_samples, (int)discard_padding);
      skip_reason = AV_RL8(side + 8);
      discard_reason = AV_RL8(side + 9);
    }

    if ((frame->flags & AV_FRAME_FLAG_DISCARD) && *got_frame_ptr &&
        !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      avctx->internal->skip_samples -= frame->nb_samples;
      *got_frame_ptr = 0;
    }

    if (avctx->internal->skip_samples > 0 && *got_frame_ptr &&
        !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (frame->nb_samples <= avctx->internal->skip_samples) {
        *got_frame_ptr = 0;
        avctx->internal->skip_samples -= frame->nb_samples;
        av_log(avctx, AV_LOG_DEBUG, ""skip whole frame, skip left: %d\n"",
               avctx->internal->skip_samples);
      } else {
        av_samples_copy(frame->extended_data, frame->extended_data, 0,
                        avctx->internal->skip_samples,
                        frame->nb_samples - avctx->internal->skip_samples,
                        avctx->channels, frame->format);
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(avctx->internal->skip_samples,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (frame->pts != AV_NOPTS_VALUE)
            frame->pts += diff_ts;
#if FF_API_PKT_PTS
          FF_DISABLE_DEPRECATION_WARNINGS
          if (frame->pkt_pts != AV_NOPTS_VALUE)
            frame->pkt_pts += diff_ts;
          FF_ENABLE_DEPRECATION_WARNINGS
#endif
          if (frame->pkt_dts != AV_NOPTS_VALUE)
            frame->pkt_dts += diff_ts;
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for skipped samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""skip %d/%d samples\n"",
               avctx->internal->skip_samples, frame->nb_samples);
        frame->nb_samples -= avctx->internal->skip_samples;
        avctx->internal->skip_samples = 0;
      }
    }

    if (discard_padding > 0 && discard_padding <= frame->nb_samples &&
        *got_frame_ptr && !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (discard_padding == frame->nb_samples) {
        *got_frame_ptr = 0;
      } else {
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          av_frame_set_pkt_duration(frame, diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for discarded samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""discard %d/%d samples\n"",
               (int)discard_padding, frame->nb_samples);
        frame->nb_samples -= discard_padding;
      }
    }

    if ((avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL) && *got_frame_ptr) {
      AVFrameSideData *fside =
          av_frame_new_side_data(frame, AV_FRAME_DATA_SKIP_SAMPLES, 10);
      if (fside) {
        AV_WL32(fside->data, avctx->internal->skip_samples);
        AV_WL32(fside->data + 4, discard_padding);
        AV_WL8(fside->data + 8, skip_reason);
        AV_WL8(fside->data + 9, discard_reason);
        avctx->internal->skip_samples = 0;
      }
    }
  fail:
    avctx->internal->pkt = NULL;
    if (did_split) {
      av_packet_free_side_data(&tmp);
      if (ret == tmp.size)
        ret = avpkt->size;
    }

    if (ret >= 0 && *got_frame_ptr) {
      if (!avctx->refcounted_frames) {
        int err = unrefcount_frame(avci, frame);
        if (err < 0)
          return err;
      }
    } else
      av_frame_unref(frame);
  }

  av_assert0(ret <= avpkt->size);

  if (!avci->showed_multi_packet_warning && ret >= 0 && ret != avpkt->size &&
      !(avctx->codec->capabilities & AV_CODEC_CAP_SUBFRAMES)) {
    av_log(avctx, AV_LOG_WARNING, ""Multiple frames in a packet.\n"");
    avci->showed_multi_packet_warning = 1;
  }

  return ret;
}"
longluo-FFMpeg-bc33159/jni/libffmpeg/libavformat/mp3.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  int frames = -1;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;

  v = get_be32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (ff_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  url_fseek(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1], SEEK_CUR);
  v = get_be32(s->pb);
  if (v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
    v = get_be32(s->pb);
    if (v & 0x1)
      frames = get_be32(s->pb);
  }

  url_fseek(s->pb, base + 4 + 32, SEEK_SET);
  v = get_be32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (get_be16(s->pb) == 1) {

      url_fseek(s->pb, 8, SEEK_CUR);
      frames = get_be32(s->pb);
    }
  }

  if (frames < 0)
    return -1;

  url_fseek(s->pb, base + vbrtag_size, SEEK_SET);

  spf = c.lsf ? 576 : 1152;
  st->duration =
      av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
  return 0;
}"
cmassiot-vlc-broadcast-de11815/modules/video_output/xcb/x11.c	Disconnect from the X server.	1	"static void Close(vlc_object_t *obj) {
  vout_display_t *vd = (vout_display_t *)obj;
  vout_display_sys_t *p_sys = vd->sys;

  ResetPictures(vd);

  xcb_change_window_attributes(p_sys->conn, p_sys->embed->handle.xid,
                               XCB_CW_CURSOR, &(uint32_t){XCB_CURSOR_NONE});
  xcb_flush(p_sys->conn);

  xcb_disconnect(p_sys->conn);
  vout_display_DeleteWindow(vd, p_sys->embed);
  free(p_sys);
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Prevent/Allow Medium Removal command to the attached device, to lock the physical media from being removed. This is a legacy command for SCSI disks with removable storage (such as ZIP disks), but should still be issued before the first read or write command is sent."	1	"uint8_t MassStore_PreventAllowMediumRemoval(const uint8_t LUNIndex,
                                            const bool PreventRemoval) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, NULL)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	Return the frame duration in seconds. Return 0 if not available.	2	"void ff_compute_frame_duration(AVFormatContext *s, int *pnum, int *pden,
                               AVStream *st, AVCodecParserContext *pc,
                               AVPacket *pkt) {
  AVRational codec_framerate =
      s->iformat
          ? st->internal->avctx->framerate
          : av_mul_q(av_inv_q(st->internal->avctx->time_base),
                     (AVRational){1, st->internal->avctx->ticks_per_frame});
  int frame_size, sample_rate;

#if FF_API_LAVF_AVCTX
  FF_DISABLE_DEPRECATION_WARNINGS
  if ((!codec_framerate.den || !codec_framerate.num) &&
      st->codec->time_base.den && st->codec->time_base.num)
    codec_framerate = av_mul_q(av_inv_q(st->codec->time_base),
                               (AVRational){1, st->codec->ticks_per_frame});
  FF_ENABLE_DEPRECATION_WARNINGS
#endif

  *pnum = 0;
  *pden = 0;
  switch (st->codecpar->codec_type) {
  case AVMEDIA_TYPE_VIDEO:
    if (st->r_frame_rate.num && !pc && s->iformat) {
      *pnum = st->r_frame_rate.den;
      *pden = st->r_frame_rate.num;
    } else if (st->time_base.num * 1000LL > st->time_base.den) {
      *pnum = st->time_base.num;
      *pden = st->time_base.den;
    } else if (codec_framerate.den * 1000LL > codec_framerate.num) {
      av_assert0(st->internal->avctx->ticks_per_frame);
      av_reduce(pnum, pden, codec_framerate.den,
                codec_framerate.num *
                    (int64_t)st->internal->avctx->ticks_per_frame,
                INT_MAX);

      if (pc && pc->repeat_pict) {
        av_assert0(s->iformat);
        av_reduce(pnum, pden, (*pnum) * (1LL + pc->repeat_pict), (*pden),
                  INT_MAX);
      }

      if (st->internal->avctx->ticks_per_frame > 1 && !pc)
        *pnum = *pden = 0;
    }
    break;
  case AVMEDIA_TYPE_AUDIO:
    if (st->internal->avctx_inited) {
      frame_size = av_get_audio_frame_duration(st->internal->avctx, pkt->size);
      sample_rate = st->internal->avctx->sample_rate;
    } else {
      frame_size = av_get_audio_frame_duration2(st->codecpar, pkt->size);
      sample_rate = st->codecpar->sample_rate;
    }
    if (frame_size <= 0 || sample_rate <= 0)
      break;
    *pnum = frame_size;
    *pden = sample_rate;
    break;
  default:
    break;
  }
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/chatline.c	Update the connected users list at pregame state.	2	"void real_conn_list_dialog_update(void *unused) {
  if (C_S_PREPARING == client_state()) {
    if (pConnDlg) {
      struct widget *pBuf = NULL, *pWindow = pConnDlg->pEndWidgetList;
      utf8_str *pstr = create_utf8_str(NULL, 0, adj_font(12));
      bool create;

      pstr->bgcol = (SDL_Color){0, 0, 0, 0};

      if (pConnDlg->pUsers_Dlg) {
        del_group(pConnDlg->pUsers_Dlg->pBeginActiveWidgetList,
                  pConnDlg->pUsers_Dlg->pEndActiveWidgetList);
        pConnDlg->pUsers_Dlg->pActiveWidgetList = NULL;
        pConnDlg->pUsers_Dlg->pBeginWidgetList =
            pConnDlg->pUsers_Dlg->pScroll->pScrollBar;
        pConnDlg->pUsers_Dlg->pScroll->count = 0;
      } else {
        pConnDlg->pUsers_Dlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));
        pConnDlg->pUsers_Dlg->pEndWidgetList = pConnDlg->pBeginWidgetList;
        pConnDlg->pUsers_Dlg->pBeginWidgetList = pConnDlg->pBeginWidgetList;

        create_vertical_scrollbar(pConnDlg->pUsers_Dlg, 1, pConnDlg->active,
                                  TRUE, TRUE);
        pConnDlg->pUsers_Dlg->pEndWidgetList =
            pConnDlg->pUsers_Dlg->pEndWidgetList->prev;
        setup_vertical_scrollbar_area(
            pConnDlg->pUsers_Dlg->pScroll,
            pWindow->size.x + pWindow->size.w - adj_size(30),
            pWindow->size.y + adj_size(14),
            pWindow->size.h - adj_size(44) - adj_size(40), FALSE);
      }

      hide_scrollbar(pConnDlg->pUsers_Dlg->pScroll);
      create = TRUE;
      conn_list_iterate(game.est_connections, pconn) {
        copy_chars_to_utf8_str(pstr, pconn->username);

        pBuf = create_themelabel2(
            NULL, pWindow->dst, pstr, adj_size(100), 0,
            (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));
        clear_wflag(pBuf, WF_FREE_STRING);

        pBuf->ID = ID_LABEL;

        if (create) {
          add_widget_to_vertical_scroll_widget_list(
              pConnDlg->pUsers_Dlg, pBuf,
              pConnDlg->pUsers_Dlg->pBeginWidgetList, FALSE,
              pWindow->area.x + pWindow->area.w - adj_size(130),
              pWindow->size.y + adj_size(14));
          create = FALSE;
        } else {
          add_widget_to_vertical_scroll_widget_list(
              pConnDlg->pUsers_Dlg, pBuf,
              pConnDlg->pUsers_Dlg->pBeginActiveWidgetList, FALSE,
              pWindow->area.x + pWindow->area.w - adj_size(130),
              pWindow->size.y + adj_size(14));
        }
      }
      conn_list_iterate_end;

      pConnDlg->pBeginWidgetList = pConnDlg->pUsers_Dlg->pBeginWidgetList;
      FREEUTF8STR(pstr);

#if 0
      if (ALLOW_CTRL == client.conn.access_level
          || ALLOW_HACK == client.conn.access_level) {
        set_wstate(pConnDlg->pConfigure, FC_WS_NORMAL);
      } else {
        set_wstate(pConnDlg->pConfigure, FC_WS_DISABLED);
      }
#endif

      redraw_group(pConnDlg->pBeginWidgetList, pConnDlg->pEndWidgetList, 0);

      widget_flush(pConnDlg->pEndWidgetList);
    } else {
      popup_conn_list_dialog();
    }

    if (get_client_page() == PAGE_LOAD) {
      popup_load_game_dialog();
    }
  } else {
    if (popdown_conn_list_dialog()) {
      flush_dirty();
    }
  }
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the scalar portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_float qscalarf(const quaternion_float num) {
  const quaternion_float conj_num =
      (quaternion_float){num.R, num.i * -1.0F, num.j * -1.0F, num.k * -1.0F};
  return (quaternion_float){
      (num.R + conj_num.R) * 0.5F, (num.i + conj_num.i) * 0.5F,
      (num.j + conj_num.j) * 0.5F, (num.k + conj_num.k) * 0.5F};
}"
hackingtype1-cgm-simple-spark-39f626d/src/pebble_chart.c	Creates a new ChartLayer on the heap and initializes it with the default values.	2	"ChartLayer *chart_layer_create(GRect frame) {

  ChartLayer *layer =
      (ChartLayer *)layer_create_with_data(frame, sizeof(ChartLayerData));
  if (!layer)
    return layer;

  ChartLayerData *data = get_chart_data(layer);
  data->pXOrigData = NULL;
  data->pYOrigData = NULL;
  data->iNumOrigPoints = 0;
  data->pXData = NULL;
  data->pYData = NULL;
  data->iNumPoints = 0;
  data->bLayoutDirty = false;
  data->typePlot = eLINE;
  data->clrPlot = GColorWhite;
  data->clrCanvas = GColorBlack;
  data->bShowPoints = false;
  data->iMargin = 5;
  data->fXMin = NOT_SET;
  data->fXMax = NOT_SET;
  data->fYMin = NOT_SET;
  data->fYMax = NOT_SET;
  data->fXYRange = 30.0;
  data->bShowFrame = false;
  data->bAnimate = true;
  data->iAnimationDuration = 1500;
  data->pAnimation = animation_create();
  data->pAnimationImpl = (struct AnimationImplementation *)malloc(
      sizeof(struct AnimationImplementation));
  data->iPointsToDraw = 0;

  animation_set_curve(data->pAnimation, AnimationCurveLinear);
  animation_set_handlers(
      data->pAnimation,
      ((AnimationHandlers){
          .started = (AnimationStartedHandler)animation_started,
          .stopped = (AnimationStoppedHandler)animation_stopped}),
      layer);

  data->pAnimationImpl->setup = NULL;
  data->pAnimationImpl->teardown = NULL;

  animation_set_implementation(data->pAnimation, data->pAnimationImpl);

  layer_set_update_proc(chart_layer_get_layer(layer), chart_layer_update_func);

  return layer;
}"
Naios-swy-c48f7eb/src/Support/Traits.hpp	Evaluates to the type that first matches the given predicate All arguments must be passed wrapped inside an identity. The function expects at least 1 argument to match the predicate.	2	"auto firstMatchOf(Predicate &&predicate, identity<FirstArg> firstArg,
                  Args &&...args) {
  auto result = decltype(predicate(std::declval<FirstArg>())){};
  static_assert(decltype(result)::value || (sizeof...(args) >= 1),
                ""No element matched the predicate!"");
  return traits_detail::firstMatchOfImpl(
      result, std::forward<Predicate>(predicate), std::move(firstArg),
      std::forward<Args>(args)...);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	User application call for setting callback handler. The callback function takes the progreess in percent as argument.	2	"arm_uc_error_t ARM_UC_ControlCenter_SetProgressHandler(
    void (*callback)(uint32_t progress, uint32_t total)) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_SetProgressHandler: %p"", callback);

  arm_uc_progress_callback = callback;

  return (arm_uc_error_t){ERR_NONE};
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Host/LowLevel/AudioInputHost/AudioInputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  DDRC |= (1 << 6);

  TCCR3A = ((1 << WGM30) | (1 << COM3A1) | (1 << COM3A0));
  TCCR3B = ((1 << WGM32) | (1 << CS30));

  puts_P(PSTR(""Microphone Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Vereint zwei 16-bit Vektoren auf einen mit 8  Verhalten fr Werte, die mit 8 Bit nicht dargestellt werden knnen, sind nicht definiert."	2	"static inline vec_uchar16 simd_conv16to8(const vec_ushort8 a,
                                         const vec_ushort8 b) {
#if defined(__SSE__)
  return (vec_uchar16)_mm_packs_epi16((__m128i)a, (__m128i)b);
#elif defined(__VEC__)
  return vec_packsu(a, b);
#elif defined(__NEON__)
  return vcombine_u8(vmovn_u16(a), vmovn_u16(b));
#else
  const unsigned short *aS = (const unsigned short *)&a;
  const unsigned short *bS = (const unsigned short *)&b;
  return (vec_uchar16){
      (unsigned char)aS[0], (unsigned char)aS[1], (unsigned char)aS[2],
      (unsigned char)aS[3], (unsigned char)aS[4], (unsigned char)aS[5],
      (unsigned char)aS[6], (unsigned char)aS[7], (unsigned char)bS[0],
      (unsigned char)bS[1], (unsigned char)bS[2], (unsigned char)bS[3],
      (unsigned char)bS[4], (unsigned char)bS[5], (unsigned char)bS[6],
      (unsigned char)bS[7]};
#endif
}"
feross-oculus-drone-fb22b6d/ffmpeg/ffplay.c	"Decode one audio frame and return its uncompressed size. The processed audio frame is decoded, converted if required, and stored in is->audio_buf, with size in bytes given by the return value."	2	"static int audio_decode_frame(VideoState *is) {
  AVPacket *pkt_temp = &is->audio_pkt_temp;
  AVPacket *pkt = &is->audio_pkt;
  AVCodecContext *dec = is->audio_st->codec;
  int len1, data_size, resampled_data_size;
  int64_t dec_channel_layout;
  int got_frame;
  av_unused double audio_clock0;
  int wanted_nb_samples;
  AVRational tb;
  int ret;
  int reconfigure;

  for (;;) {

    while (pkt_temp->stream_index != -1 || is->audio_buf_frames_pending) {
      if (!is->frame) {
        if (!(is->frame = avcodec_alloc_frame()))
          return AVERROR(ENOMEM);
      } else {
        av_frame_unref(is->frame);
        avcodec_get_frame_defaults(is->frame);
      }

      if (is->audioq.serial != is->audio_pkt_temp_serial)
        break;

      if (is->paused)
        return -1;

      if (!is->audio_buf_frames_pending) {
        len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);
        if (len1 < 0) {

          pkt_temp->size = 0;
          break;
        }

        pkt_temp->dts = pkt_temp->pts = AV_NOPTS_VALUE;
        pkt_temp->data += len1;
        pkt_temp->size -= len1;
        if (pkt_temp->data && pkt_temp->size <= 0 ||
            !pkt_temp->data && !got_frame)
          pkt_temp->stream_index = -1;

        if (!got_frame)
          continue;

        tb = (AVRational){1, is->frame->sample_rate};
        if (is->frame->pts != AV_NOPTS_VALUE)
          is->frame->pts = av_rescale_q(is->frame->pts, dec->time_base, tb);
        else if (is->frame->pkt_pts != AV_NOPTS_VALUE)
          is->frame->pts =
              av_rescale_q(is->frame->pkt_pts, is->audio_st->time_base, tb);
        else if (is->audio_frame_next_pts != AV_NOPTS_VALUE)
#if CONFIG_AVFILTER
          is->frame->pts =
              av_rescale_q(is->audio_frame_next_pts,
                           (AVRational){1, is->audio_filter_src.freq}, tb);
#else
          is->frame->pts =
              av_rescale_q(is->audio_frame_next_pts,
                           (AVRational){1, is->audio_src.freq}, tb);
#endif

        if (is->frame->pts != AV_NOPTS_VALUE)
          is->audio_frame_next_pts = is->frame->pts + is->frame->nb_samples;

#if CONFIG_AVFILTER
        dec_channel_layout = get_valid_channel_layout(
            is->frame->channel_layout, av_frame_get_channels(is->frame));

        reconfigure =
            cmp_audio_fmts(is->audio_filter_src.fmt,
                           is->audio_filter_src.channels, is->frame->format,
                           av_frame_get_channels(is->frame)) ||
            is->audio_filter_src.channel_layout != dec_channel_layout ||
            is->audio_filter_src.freq != is->frame->sample_rate ||
            is->audio_pkt_temp_serial != is->audio_last_serial;

        if (reconfigure) {
          char buf1[1024], buf2[1024];
          av_get_channel_layout_string(buf1, sizeof(buf1), -1,
                                       is->audio_filter_src.channel_layout);
          av_get_channel_layout_string(buf2, sizeof(buf2), -1,
                                       dec_channel_layout);
          av_log(NULL, AV_LOG_DEBUG,
                 ""Audio frame changed from rate:%d ch:%d fmt:%s layout:%s ""
                 ""serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n"",
                 is->audio_filter_src.freq, is->audio_filter_src.channels,
                 av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1,
                 is->audio_last_serial, is->frame->sample_rate,
                 av_frame_get_channels(is->frame),
                 av_get_sample_fmt_name(is->frame->format), buf2,
                 is->audio_pkt_temp_serial);

          is->audio_filter_src.fmt = is->frame->format;
          is->audio_filter_src.channels = av_frame_get_channels(is->frame);
          is->audio_filter_src.channel_layout = dec_channel_layout;
          is->audio_filter_src.freq = is->frame->sample_rate;
          is->audio_last_serial = is->audio_pkt_temp_serial;

          if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
            return ret;
        }

        if ((ret = av_buffersrc_add_frame(is->in_audio_filter, is->frame)) < 0)
          return ret;
        av_frame_unref(is->frame);
#endif
      }
#if CONFIG_AVFILTER
      if ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, is->frame,
                                               0)) < 0) {
        if (ret == AVERROR(EAGAIN)) {
          is->audio_buf_frames_pending = 0;
          continue;
        }
        return ret;
      }
      is->audio_buf_frames_pending = 1;
      tb = is->out_audio_filter->inputs[0]->time_base;
#endif

      data_size = av_samples_get_buffer_size(
          NULL, av_frame_get_channels(is->frame), is->frame->nb_samples,
          is->frame->format, 1);

      dec_channel_layout =
          (is->frame->channel_layout &&
           av_frame_get_channels(is->frame) ==
               av_get_channel_layout_nb_channels(is->frame->channel_layout))
              ? is->frame->channel_layout
              : av_get_default_channel_layout(av_frame_get_channels(is->frame));
      wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);

      if (is->frame->format != is->audio_src.fmt ||
          dec_channel_layout != is->audio_src.channel_layout ||
          is->frame->sample_rate != is->audio_src.freq ||
          (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {
        swr_free(&is->swr_ctx);
        is->swr_ctx = swr_alloc_set_opts(NULL, is->audio_tgt.channel_layout,
                                         is->audio_tgt.fmt, is->audio_tgt.freq,
                                         dec_channel_layout, is->frame->format,
                                         is->frame->sample_rate, 0, NULL);
        if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {
          av_log(NULL, AV_LOG_ERROR,
                 ""Cannot create sample rate converter for conversion of %d Hz ""
                 ""%s %d channels to %d Hz %s %d channels!\n"",
                 is->frame->sample_rate,
                 av_get_sample_fmt_name(is->frame->format),
                 av_frame_get_channels(is->frame), is->audio_tgt.freq,
                 av_get_sample_fmt_name(is->audio_tgt.fmt),
                 is->audio_tgt.channels);
          break;
        }
        is->audio_src.channel_layout = dec_channel_layout;
        is->audio_src.channels = av_frame_get_channels(is->frame);
        is->audio_src.freq = is->frame->sample_rate;
        is->audio_src.fmt = is->frame->format;
      }

      if (is->swr_ctx) {
        const uint8_t **in = (const uint8_t **)is->frame->extended_data;
        uint8_t **out = &is->audio_buf1;
        int out_count = (int64_t)wanted_nb_samples * is->audio_tgt.freq /
                            is->frame->sample_rate +
                        256;
        int out_size = av_samples_get_buffer_size(
            NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
        int len2;
        if (out_size < 0) {
          av_log(NULL, AV_LOG_ERROR, ""av_samples_get_buffer_size() failed\n"");
          break;
        }
        if (wanted_nb_samples != is->frame->nb_samples) {
          if (swr_set_compensation(is->swr_ctx,
                                   (wanted_nb_samples - is->frame->nb_samples) *
                                       is->audio_tgt.freq /
                                       is->frame->sample_rate,
                                   wanted_nb_samples * is->audio_tgt.freq /
                                       is->frame->sample_rate) < 0) {
            av_log(NULL, AV_LOG_ERROR, ""swr_set_compensation() failed\n"");
            break;
          }
        }
        av_fast_malloc(&is->audio_buf1, &is->audio_buf1_size, out_size);
        if (!is->audio_buf1)
          return AVERROR(ENOMEM);
        len2 =
            swr_convert(is->swr_ctx, out, out_count, in, is->frame->nb_samples);
        if (len2 < 0) {
          av_log(NULL, AV_LOG_ERROR, ""swr_convert() failed\n"");
          break;
        }
        if (len2 == out_count) {
          av_log(NULL, AV_LOG_WARNING, ""audio buffer is probably too small\n"");
          swr_init(is->swr_ctx);
        }
        is->audio_buf = is->audio_buf1;
        resampled_data_size = len2 * is->audio_tgt.channels *
                              av_get_bytes_per_sample(is->audio_tgt.fmt);
      } else {
        is->audio_buf = is->frame->data[0];
        resampled_data_size = data_size;
      }

      audio_clock0 = is->audio_clock;

      if (is->frame->pts != AV_NOPTS_VALUE)
        is->audio_clock =
            is->frame->pts * av_q2d(tb) +
            (double)is->frame->nb_samples / is->frame->sample_rate;
      else
        is->audio_clock = NAN;
      is->audio_clock_serial = is->audio_pkt_temp_serial;
#ifdef DEBUG
      {
        static double last_clock;
        printf(""audio: delay=%0.3f clock=%0.3f clock0=%0.3f\n"",
               is->audio_clock - last_clock, is->audio_clock, audio_clock0);
        last_clock = is->audio_clock;
      }
#endif
      return resampled_data_size;
    }

    if (pkt->data)
      av_free_packet(pkt);
    memset(pkt_temp, 0, sizeof(*pkt_temp));
    pkt_temp->stream_index = -1;

    if (is->audioq.abort_request) {
      return -1;
    }

    if (is->audioq.nb_packets == 0)
      SDL_CondSignal(is->continue_read_thread);

    if ((packet_queue_get(&is->audioq, pkt, 1, &is->audio_pkt_temp_serial)) < 0)
      return -1;

    if (pkt->data == flush_pkt.data) {
      avcodec_flush_buffers(dec);
      is->audio_buf_frames_pending = 0;
      is->audio_frame_next_pts = AV_NOPTS_VALUE;
      if ((is->ic->iformat->flags &
           (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &&
          !is->ic->iformat->read_seek)
        is->audio_frame_next_pts = is->audio_st->start_time;
    }

    *pkt_temp = *pkt;
  }
}"
fsavje-scclust-988f69b/src/digraph_core.c	"Generic constructor for digraphs. Initializes and allocates memory for specified digraph. The memory spaces (i.e., scc_Digraph::head and scc_Digraph::tail_ptr) are uninitialized, thus the produced digraph is in general invalid."	2	"scc_ErrorCode iscc_init_digraph(const size_t vertices, const uintmax_t max_arcs,
                                iscc_Digraph *const out_dg) {
  assert(vertices > 0);
  assert(vertices <= ISCC_POINTINDEX_MAX);
  assert(vertices < SIZE_MAX);
  assert(out_dg != NULL);
  if ((max_arcs > ISCC_ARCINDEX_MAX) || (max_arcs > SIZE_MAX)) {
    return iscc_make_error_msg(
        SCC_ER_TOO_LARGE_PROBLEM,
        ""Too many arcs in graph (adjust the `iscc_ArcIndex` type)."");
  }

  *out_dg = (iscc_Digraph){
      .vertices = vertices,
      .max_arcs = (size_t)max_arcs,
      .head = NULL,
      .tail_ptr = malloc(sizeof(iscc_ArcIndex[vertices + 1])),
  };
  if (out_dg->tail_ptr == NULL)
    return iscc_make_error(SCC_ER_NO_MEMORY);

  if (max_arcs > 0) {
    out_dg->head = malloc(sizeof(scc_PointIndex[max_arcs]));
    if (out_dg->head == NULL) {
      iscc_free_digraph(out_dg);
      return iscc_make_error(SCC_ER_NO_MEMORY);
    }
  }

  assert(iscc_digraph_is_initialized(out_dg));

  return iscc_no_error();
}"
opticron-libuweave-2e5e385/src/device_crypto.c	Initializes the device into the base state. Sets and saves the device authentication key if unset.	2	"UwStatus uw_device_crypto_init_(UwDeviceCrypto *device_crypto) {
  *device_crypto = (UwDeviceCrypto){};

  try_loading_keys_(device_crypto);

  bool do_save = false;

  if (!device_crypto->has_device_auth_key) {
    bool device_auth_success =
        uwp_crypto_getrandom(device_crypto->device_authentication_key,
                             sizeof(device_crypto->device_authentication_key));
    if (!device_auth_success) {
      return kUwStatusCryptoRandomNumberFailure;
    }
    device_crypto->has_device_auth_key = true;
    do_save = true;
  }

  if (!device_crypto->has_device_id) {
    bool device_id_success = uwp_crypto_getrandom(
        device_crypto->device_id, sizeof(device_crypto->device_id));
    if (!device_id_success) {
      return kUwStatusCryptoRandomNumberFailure;
    }
    device_crypto->has_device_id = true;
    do_save = true;
  }

  if (do_save) {
    UwStatus save_status = save_keys_(device_crypto);
    if (!uw_status_is_success(save_status)) {
      return save_status;
    }
  }

  return kUwStatusSuccess;
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;
    if (!link->src || !link->dst) {
      av_log(filter, AV_LOG_ERROR,
             ""Not all input and output are properly linked (%d).\n"", i);
      return AVERROR(EINVAL);
    }

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink && !link->frame_rate.num && !link->frame_rate.den)
          link->frame_rate = inlink->frame_rate;

        if (inlink) {
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/xmmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_ps(float __z, float __y, float __x, float __w) {
  return (__m128){__w, __x, __y, __z};
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/manifest-manager/source/manifest-manager-api.c	Validates and parses manifest. Event is generated when call is complete.	2	"arm_uc_error_t ARM_UC_mmInsert(arm_uc_mmContext_t **ctx,
                               arm_uc_buffer_t *buffer,
                               arm_uc_buffer_t *certificateStorage,
                               arm_uc_manifest_handle_t *ID) {
  if (ctx == NULL || *ctx == NULL || buffer == NULL) {
    return (arm_uc_error_t){MFST_ERR_NULL_PTR};
  }
  arm_uc_mmPersistentContext.ctx = ctx;

  arm_uc_error_t err = ARM_UC_mmSetState(ARM_UC_MM_STATE_INSERTING);
  if (err.code != ERR_NONE) {
    return err;
  }
  struct arm_uc_mmInsertContext_t *insertCtx =
      &(*arm_uc_mmPersistentContext.ctx)->insert;

  ARM_UC_buffer_shallow_copy(&insertCtx->manifest, buffer);
  insertCtx->state = ARM_UC_MM_INS_STATE_BEGIN;

  insertCtx->ID = ID;

  ARM_UC_buffer_shallow_copy(&insertCtx->certificateStorage,
                             certificateStorage);

  insertCtx->callbackStorage.lock = 0;

  ARM_UC_PostCallback(&insertCtx->callbackStorage, ARM_UC_mmCallbackFSMEntry,
                      ARM_UC_MM_EVENT_BEGIN);
  return (arm_uc_error_t){ERR_NONE};
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/arrays.c	Create new indefinite array	2	"cbor_item_t *cbor_new_indefinite_array() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL)
    return NULL;

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                      .allocated = 0,
                                      .end_ptr = 0}},
      .data = NULL};
  return item;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Request Sense command to the attached device, to determine the current SCSI sense information. This gives error codes for the last issued SCSI command to the device."	0	"uint8_t MassStore_RequestSense(const uint8_t LUNIndex,
                               SCSI_Request_Sense_Response_t *const SensePtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, SensePtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
gityf-img-video-d1ee85c/video/ffmpeg-h264-sdl-view/ffmpeg-src/libavcodec/utils.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  AVPacket *pkt = avctx->internal->pkt;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
      {AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
       AV_FRAME_DATA_MASTERING_DISPLAY_METADATA},
  };

  if (pkt) {
    frame->pkt_pts = pkt->pts;
    av_frame_set_pkt_pos(frame, pkt->pos);
    av_frame_set_pkt_duration(frame, pkt->duration);
    av_frame_set_pkt_size(frame, pkt->size);

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
    add_metadata_from_side_data(pkt, frame);
  } else {
    frame->pkt_pts = AV_NOPTS_VALUE;
    av_frame_set_pkt_pos(frame, -1);
    av_frame_set_pkt_duration(frame, 0);
    av_frame_set_pkt_size(frame, -1);
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
    av_frame_set_colorspace(frame, avctx->colorspace);
  if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
    av_frame_set_color_range(frame, avctx->color_range);
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    av_frame_set_channels(frame, avctx->channels);
    break;
  }
  return 0;
}"
freeciv-freeciv-e4ead30/ai/default/ailog.c	"Log message for bodyguards. They will appear like this 2: Polish Mech. Inf.[485] bodyguard (38,22){Riflemen:574@37,23} was ... note that these messages are likely to wrap if long."	2	"void real_bodyguard_log(struct ai_type *ait, const char *file,
                        const char *function, int line, enum log_level level,
                        bool send_notify, const struct unit *punit,
                        const char *msg, ...) {
  char buffer[500];
  char buffer2[500];
  va_list ap;
  const struct unit *pcharge;
  const struct city *pcity;
  int id = -1;
  int charge_x = -1;
  int charge_y = -1;
  const char *type = ""guard"";
  const char *s = ""none"";
  struct unit_ai *unit_data = def_ai_unit_data(punit, ait);

  pcity = game_city_by_number(unit_data->charge);
  pcharge = game_unit_by_number(unit_data->charge);
  if (pcharge) {
    index_to_map_pos(&charge_x, &charge_y, tile_index(unit_tile(pcharge)));
    id = pcharge->id;
    type = ""bodyguard"";
    s = unit_rule_name(pcharge);
  } else if (pcity) {
    index_to_map_pos(&charge_x, &charge_y, tile_index(city_tile(pcity)));
    id = pcity->id;
    type = ""cityguard"";
    s = city_name_get(pcity);
  }

  fc_snprintf(buffer, sizeof(buffer), ""%s %s[%d] %s (%d,%d){%s:%d@%d,%d} "",
              nation_rule_name(nation_of_unit(punit)), unit_rule_name(punit),
              punit->id, type, TILE_XY(unit_tile(punit)), s, id, charge_x,
              charge_y);

  va_start(ap, msg);
  fc_vsnprintf(buffer2, sizeof(buffer2), msg, ap);
  va_end(ap);

  cat_snprintf(buffer, sizeof(buffer), ""%s"", buffer2);
  if (send_notify) {
    notify_conn(NULL, NULL, E_AI_DEBUG, ftc_log, ""%s"", buffer);
  }
  do_log(file, function, line, FALSE, level, ""%s"", buffer);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
blstream-OpenVideoHub-7bb9abf/libav/libavcodec/h264.c	decodes a slice header. This will also call MPV_common_init() and frame_start() as needed.	2	"static int decode_slice_header(H264Context *h, H264Context *h0) {
  MpegEncContext *const s = &h->s;
  MpegEncContext *const s0 = &h0->s;
  unsigned int first_mb_in_slice;
  unsigned int pps_id;
  int num_ref_idx_active_override_flag;
  static const uint8_t slice_type_map[5] = {FF_P_TYPE, FF_B_TYPE, FF_I_TYPE,
                                            FF_SP_TYPE, FF_SI_TYPE};
  unsigned int slice_type, tmp, i, j;
  int default_ref_list_done = 0;
  int last_pic_structure;

  s->dropable = h->nal_ref_idc == 0;

  if ((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc) {
    s->me.qpel_put = s->dsp.put_2tap_qpel_pixels_tab;
    s->me.qpel_avg = s->dsp.avg_2tap_qpel_pixels_tab;
  } else {
    s->me.qpel_put = s->dsp.put_h264_qpel_pixels_tab;
    s->me.qpel_avg = s->dsp.avg_h264_qpel_pixels_tab;
  }

  first_mb_in_slice = get_ue_golomb(&s->gb);

  if ((s->flags2 & CODEC_FLAG2_CHUNKS) && first_mb_in_slice == 0) {
    h0->current_slice = 0;
    if (!s0->first_field)
      s->current_picture_ptr = NULL;
  }

  slice_type = get_ue_golomb(&s->gb);
  if (slice_type > 9) {
    av_log(h->s.avctx, AV_LOG_ERROR, ""slice type too large (%d) at %d %d\n"",
           h->slice_type, s->mb_x, s->mb_y);
    return -1;
  }
  if (slice_type > 4) {
    slice_type -= 5;
    h->slice_type_fixed = 1;
  } else
    h->slice_type_fixed = 0;

  slice_type = slice_type_map[slice_type];
  if (slice_type == FF_I_TYPE ||
      (h0->current_slice != 0 && slice_type == h0->last_slice_type)) {
    default_ref_list_done = 1;
  }
  h->slice_type = slice_type;
  h->slice_type_nos = slice_type & 3;

  s->pict_type = h->slice_type;
  if (s->pict_type == FF_B_TYPE && s0->last_picture_ptr == NULL) {
    av_log(h->s.avctx, AV_LOG_ERROR,
           ""B picture before any references, skipping\n"");
    return -1;
  }

  pps_id = get_ue_golomb(&s->gb);
  if (pps_id >= MAX_PPS_COUNT) {
    av_log(h->s.avctx, AV_LOG_ERROR, ""pps_id out of range\n"");
    return -1;
  }
  if (!h0->pps_buffers[pps_id]) {
    av_log(h->s.avctx, AV_LOG_ERROR, ""non-existing PPS referenced\n"");
    return -1;
  }
  h->pps = *h0->pps_buffers[pps_id];

  if (!h0->sps_buffers[h->pps.sps_id]) {
    av_log(h->s.avctx, AV_LOG_ERROR, ""non-existing SPS referenced\n"");
    return -1;
  }
  h->sps = *h0->sps_buffers[h->pps.sps_id];

  if (h == h0 && h->dequant_coeff_pps != pps_id) {
    h->dequant_coeff_pps = pps_id;
    init_dequant_tables(h);
  }

  s->mb_width = h->sps.mb_width;
  s->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);

  h->b_stride = s->mb_width * 4;
  h->b8_stride = s->mb_width * 2;

  s->width = 16 * s->mb_width - 2 * FFMIN(h->sps.crop_right, 7);
  if (h->sps.frame_mbs_only_flag)
    s->height = 16 * s->mb_height - 2 * FFMIN(h->sps.crop_bottom, 7);
  else
    s->height = 16 * s->mb_height - 4 * FFMIN(h->sps.crop_bottom, 3);

  if (s->context_initialized &&
      (s->width != s->avctx->width || s->height != s->avctx->height)) {
    if (h != h0)
      return -1;
    free_tables(h);
    MPV_common_end(s);
  }
  if (!s->context_initialized) {
    if (h != h0)
      return -1;
    if (MPV_common_init(s) < 0)
      return -1;
    s->first_field = 0;

    init_scan_tables(h);
    alloc_tables(h);

    for (i = 1; i < s->avctx->thread_count; i++) {
      H264Context *c;
      c = h->thread_context[i] = av_malloc(sizeof(H264Context));
      memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));
      memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));
      c->sps = h->sps;
      c->pps = h->pps;
      init_scan_tables(c);
      clone_tables(c, h);
    }

    for (i = 0; i < s->avctx->thread_count; i++)
      if (context_init(h->thread_context[i]) < 0)
        return -1;

    s->avctx->width = s->width;
    s->avctx->height = s->height;
    s->avctx->sample_aspect_ratio = h->sps.sar;
    if (!s->avctx->sample_aspect_ratio.den)
      s->avctx->sample_aspect_ratio.den = 1;

    if (h->sps.timing_info_present_flag) {
      s->avctx->time_base =
          (AVRational){h->sps.num_units_in_tick * 2, h->sps.time_scale};
      if (h->x264_build > 0 && h->x264_build < 44)
        s->avctx->time_base.den *= 2;
      av_reduce(&s->avctx->time_base.num, &s->avctx->time_base.den,
                s->avctx->time_base.num, s->avctx->time_base.den, 1 << 30);
    }
  }

  h->frame_num = get_bits(&s->gb, h->sps.log2_max_frame_num);

  h->mb_mbaff = 0;
  h->mb_aff_frame = 0;
  last_pic_structure = s0->picture_structure;
  if (h->sps.frame_mbs_only_flag) {
    s->picture_structure = PICT_FRAME;
  } else {
    if (get_bits1(&s->gb)) {
      s->picture_structure = PICT_TOP_FIELD + get_bits1(&s->gb);
    } else {
      s->picture_structure = PICT_FRAME;
      h->mb_aff_frame = h->sps.mb_aff;
    }
  }
  h->mb_field_decoding_flag = s->picture_structure != PICT_FRAME;

  if (h0->current_slice == 0) {
    while (h->frame_num != h->prev_frame_num &&
           h->frame_num !=
               (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {
      av_log(NULL, AV_LOG_DEBUG, ""Frame num gap %d %d\n"", h->frame_num,
             h->prev_frame_num);
      frame_start(h);
      h->prev_frame_num++;
      h->prev_frame_num %= 1 << h->sps.log2_max_frame_num;
      s->current_picture_ptr->frame_num = h->prev_frame_num;
      execute_ref_pic_marking(h, NULL, 0);
    }

    if (s0->first_field) {
      assert(s0->current_picture_ptr);
      assert(s0->current_picture_ptr->data[0]);
      assert(s0->current_picture_ptr->reference != DELAYED_PIC_REF);

      if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) {

        s0->current_picture_ptr = NULL;
        s0->first_field = FIELD_PICTURE;

      } else {
        if (h->nal_ref_idc && s0->current_picture_ptr->reference &&
            s0->current_picture_ptr->frame_num != h->frame_num) {

          s0->first_field = 1;
          s0->current_picture_ptr = NULL;

        } else {

          s0->first_field = 0;
        }
      }

    } else {

      assert(!s0->current_picture_ptr);
      s0->first_field = FIELD_PICTURE;
    }

    if ((!FIELD_PICTURE || s0->first_field) && frame_start(h) < 0) {
      s0->first_field = 0;
      return -1;
    }
  }
  if (h != h0)
    clone_slice(h, h0);

  s->current_picture_ptr->frame_num = h->frame_num;

  assert(s->mb_num == s->mb_width * s->mb_height);
  if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num ||
      first_mb_in_slice >= s->mb_num) {
    av_log(h->s.avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");
    return -1;
  }
  s->resync_mb_x = s->mb_x = first_mb_in_slice % s->mb_width;
  s->resync_mb_y = s->mb_y = (first_mb_in_slice / s->mb_width)
                             << FIELD_OR_MBAFF_PICTURE;
  if (s->picture_structure == PICT_BOTTOM_FIELD)
    s->resync_mb_y = s->mb_y = s->mb_y + 1;
  assert(s->mb_y < s->mb_height);

  if (s->picture_structure == PICT_FRAME) {
    h->curr_pic_num = h->frame_num;
    h->max_pic_num = 1 << h->sps.log2_max_frame_num;
  } else {
    h->curr_pic_num = 2 * h->frame_num + 1;
    h->max_pic_num = 1 << (h->sps.log2_max_frame_num + 1);
  }

  if (h->nal_unit_type == NAL_IDR_SLICE) {
    get_ue_golomb(&s->gb);
  }

  if (h->sps.poc_type == 0) {
    h->poc_lsb = get_bits(&s->gb, h->sps.log2_max_poc_lsb);

    if (h->pps.pic_order_present == 1 && s->picture_structure == PICT_FRAME) {
      h->delta_poc_bottom = get_se_golomb(&s->gb);
    }
  }

  if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {
    h->delta_poc[0] = get_se_golomb(&s->gb);

    if (h->pps.pic_order_present == 1 && s->picture_structure == PICT_FRAME)
      h->delta_poc[1] = get_se_golomb(&s->gb);
  }

  init_poc(h);

  if (h->pps.redundant_pic_cnt_present) {
    h->redundant_pic_count = get_ue_golomb(&s->gb);
  }

  h->ref_count[0] = h->pps.ref_count[0];
  h->ref_count[1] = h->pps.ref_count[1];

  if (h->slice_type_nos != FF_I_TYPE) {
    if (h->slice_type_nos == FF_B_TYPE) {
      h->direct_spatial_mv_pred = get_bits1(&s->gb);
    }
    num_ref_idx_active_override_flag = get_bits1(&s->gb);

    if (num_ref_idx_active_override_flag) {
      h->ref_count[0] = get_ue_golomb(&s->gb) + 1;
      if (h->slice_type_nos == FF_B_TYPE)
        h->ref_count[1] = get_ue_golomb(&s->gb) + 1;

      if (h->ref_count[0] - 1 > 32 - 1 || h->ref_count[1] - 1 > 32 - 1) {
        av_log(h->s.avctx, AV_LOG_ERROR, ""reference overflow\n"");
        h->ref_count[0] = h->ref_count[1] = 1;
        return -1;
      }
    }
    if (h->slice_type_nos == FF_B_TYPE)
      h->list_count = 2;
    else
      h->list_count = 1;
  } else
    h->list_count = 0;

  if (!default_ref_list_done) {
    fill_default_ref_list(h);
  }

  if (h->slice_type_nos != FF_I_TYPE && decode_ref_pic_list_reordering(h) < 0)
    return -1;

  if ((h->pps.weighted_pred && h->slice_type_nos == FF_P_TYPE) ||
      (h->pps.weighted_bipred_idc == 1 && h->slice_type_nos == FF_B_TYPE))
    pred_weight_table(h);
  else if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == FF_B_TYPE)
    implicit_weight_table(h);
  else
    h->use_weight = 0;

  if (h->nal_ref_idc)
    decode_ref_pic_marking(h0, &s->gb);

  if (FRAME_MBAFF)
    fill_mbaff_ref_list(h);

  if (h->slice_type_nos != FF_I_TYPE && h->pps.cabac) {
    tmp = get_ue_golomb(&s->gb);
    if (tmp > 2) {
      av_log(s->avctx, AV_LOG_ERROR, ""cabac_init_idc overflow\n"");
      return -1;
    }
    h->cabac_init_idc = tmp;
  }

  h->last_qscale_diff = 0;
  tmp = h->pps.init_qp + get_se_golomb(&s->gb);
  if (tmp > 51) {
    av_log(s->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);
    return -1;
  }
  s->qscale = tmp;
  h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);
  h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);

  if (h->slice_type == FF_SP_TYPE) {
    get_bits1(&s->gb);
  }
  if (h->slice_type == FF_SP_TYPE || h->slice_type == FF_SI_TYPE) {
    get_se_golomb(&s->gb);
  }

  h->deblocking_filter = 1;
  h->slice_alpha_c0_offset = 0;
  h->slice_beta_offset = 0;
  if (h->pps.deblocking_filter_parameters_present) {
    tmp = get_ue_golomb(&s->gb);
    if (tmp > 2) {
      av_log(s->avctx, AV_LOG_ERROR, ""deblocking_filter_idc %u out of range\n"",
             tmp);
      return -1;
    }
    h->deblocking_filter = tmp;
    if (h->deblocking_filter < 2)
      h->deblocking_filter ^= 1;

    if (h->deblocking_filter) {
      h->slice_alpha_c0_offset = get_se_golomb(&s->gb) << 1;
      h->slice_beta_offset = get_se_golomb(&s->gb) << 1;
    }
  }

  if (s->avctx->skip_loop_filter >= AVDISCARD_ALL ||
      (s->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&
       h->slice_type_nos != FF_I_TYPE) ||
      (s->avctx->skip_loop_filter >= AVDISCARD_BIDIR &&
       h->slice_type_nos == FF_B_TYPE) ||
      (s->avctx->skip_loop_filter >= AVDISCARD_NONREF && h->nal_ref_idc == 0))
    h->deblocking_filter = 0;

  if (h->deblocking_filter == 1 && h0->max_contexts > 1) {
    if (s->avctx->flags2 & CODEC_FLAG2_FAST) {

      h->deblocking_filter = 2;
    } else {
      h0->max_contexts = 1;
      if (!h0->single_decode_warning) {
        av_log(s->avctx, AV_LOG_INFO,
               ""Cannot parallelize deblocking type 1, decoding such frames in ""
               ""sequential order\n"");
        h0->single_decode_warning = 1;
      }
      if (h != h0)
        return 1;
    }
  }

#if 0  
    if( h->pps.num_slice_groups > 1  && h->pps.mb_slice_group_map_type >= 3 && h->pps.mb_slice_group_map_type <= 5)
        slice_group_change_cycle= get_bits(&s->gb, ?);
#endif

  h0->last_slice_type = slice_type;
  h->slice_num = ++h0->current_slice;

  for (j = 0; j < 2; j++) {
    int *ref2frm = h->ref2frm[h->slice_num & 15][j];
    ref2frm[0] = ref2frm[1] = -1;
    for (i = 0; i < 16; i++)
      ref2frm[i + 2] =
          4 * h->ref_list[j][i].frame_num + (h->ref_list[j][i].reference & 3);
    ref2frm[18 + 0] = ref2frm[18 + 1] = -1;
    for (i = 16; i < 48; i++)
      ref2frm[i + 4] =
          4 * h->ref_list[j][i].frame_num + (h->ref_list[j][i].reference & 3);
  }

  h->emu_edge_width = (s->flags & CODEC_FLAG_EMU_EDGE) ? 0 : 16;
  h->emu_edge_height = (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h->emu_edge_width;

  if (s->avctx->debug & FF_DEBUG_PICT_INFO) {
    av_log(h->s.avctx, AV_LOG_DEBUG,
           ""slice:%d %s mb:%d %c pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d ""
           ""loop:%d:%d:%d weight:%d%s %s\n"",
           h->slice_num,
           (s->picture_structure == PICT_FRAME       ? ""F""
            : s->picture_structure == PICT_TOP_FIELD ? ""T""
                                                     : ""B""),
           first_mb_in_slice, av_get_pict_type_char(h->slice_type), pps_id,
           h->frame_num, s->current_picture_ptr->field_poc[0],
           s->current_picture_ptr->field_poc[1], h->ref_count[0],
           h->ref_count[1], s->qscale, h->deblocking_filter,
           h->slice_alpha_c0_offset / 2, h->slice_beta_offset / 2,
           h->use_weight, h->use_weight == 1 && h->use_weight_chroma ? ""c"" : """",
           h->slice_type == FF_B_TYPE
               ? (h->direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"")
               : """");
  }

  return 0;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/mapview.c	Refresh (update) the viewrect on the overview. This is the rectangle showing the area covered by the mapview.	2	"void refresh_overview(void) {
  struct widget *pMMap;
  SDL_Rect overview_area;

  if (SDL_Client_Flags & CF_OVERVIEW_SHOWN) {
    pMMap = get_minimap_window_widget();

    overview_area = (SDL_Rect){
        pMMap->area.x + overview_start_x, pMMap->area.x + overview_start_y,
        overview_canvas->surf->w, overview_canvas->surf->h};

    alphablit(overview_canvas->surf, NULL, pMMap->dst->surface, &overview_area,
              255);

    widget_mark_dirty(pMMap);
  }
}"
Japh-FlipClock-df892d6/src/flipclock.c	Called when the window is pushed to the screen when it's not loaded. Create layout.	2	"static void window_load(Window *window) {
  APP_LOG(APP_LOG_LEVEL_DEBUG, ""window load"");
  Layer *window_layer = window_get_root_layer(window);
  GRect bounds = layer_get_bounds(window_layer);
  GRect image_frame = (GRect){.origin = GPoint(104, 85), .size = GSize(44, 42)};

  background_bitmap =
      gbitmap_create_with_resource(RESOURCE_ID_IMAGE_BACKGROUND);
  GRect bg_bounds =
      (GRect){.origin = GPoint(0, 0), .size = background_bitmap->bounds.size};

  if ((settings & SETTING_DATE_BELOW_TIME) > 0) {
    bg_bounds.origin.y = -84;
  } else if ((settings & SETTING_TIME_ONLY) > 0) {
    bg_bounds.origin.y = -216;
  }
  background_bitmap_layer = bitmap_layer_create(bg_bounds);
  bitmap_layer_set_bitmap(background_bitmap_layer, background_bitmap);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(background_bitmap_layer));

  if ((settings & SETTING_TIME_ONLY) > 0) {
    image_frame.origin.y = (bounds.size.h / 2) - 42;
  } else if ((settings & SETTING_DATE_BELOW_TIME) > 0) {
    image_frame.origin.y = 0;
  }
  digit_bitmap_layer[MINUTE_ONES_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_ONES_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_ONES_TOP],
                                    GCompOpOr);

  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[MINUTE_ONES_TOP]));

  digit_bitmap_layer[MINUTE_ONES_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_ONES_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_ONES_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[MINUTE_ONES_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[MINUTE_ONES_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_ONES_BOT], GAlignTop);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_ONES_BOT],
                                    GCompOpOr);

  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[MINUTE_ONES_BOT]));

  digit_bitmap_layer[MINUTE_ONES_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_ONES_BOT_ANIM],
                             GAlignTop);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_ONES_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[MINUTE_ONES_BOT_ANIM]));

  image_frame.origin.x = 69;
  image_frame.origin.y -= 42;
  digit_bitmap_layer[MINUTE_TENS_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_TENS_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_TENS_TOP],
                                    GCompOpOr);

  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[MINUTE_TENS_TOP]));

  digit_bitmap_layer[MINUTE_TENS_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_TENS_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_TENS_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[MINUTE_TENS_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[MINUTE_TENS_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_TENS_BOT], GAlignTop);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_TENS_BOT],
                                    GCompOpOr);

  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[MINUTE_TENS_BOT]));

  digit_bitmap_layer[MINUTE_TENS_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[MINUTE_TENS_BOT_ANIM],
                             GAlignTop);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[MINUTE_TENS_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[MINUTE_TENS_BOT_ANIM]));

  image_frame.origin.x = 31;
  image_frame.origin.y -= 42;
  digit_bitmap_layer[HOUR_ONES_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_ONES_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_ONES_TOP],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[HOUR_ONES_TOP]));

  digit_bitmap_layer[HOUR_ONES_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_ONES_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_ONES_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[HOUR_ONES_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[HOUR_ONES_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_ONES_BOT], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_ONES_BOT],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[HOUR_ONES_BOT]));

  digit_bitmap_layer[HOUR_ONES_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_ONES_BOT_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_ONES_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[HOUR_ONES_BOT_ANIM]));

  image_frame.origin.x = -4;
  image_frame.origin.y -= 42;
  digit_bitmap_layer[HOUR_TENS_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_TENS_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_TENS_TOP],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[HOUR_TENS_TOP]));

  digit_bitmap_layer[HOUR_TENS_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_TENS_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_TENS_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[HOUR_TENS_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[HOUR_TENS_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_TENS_BOT], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_TENS_BOT],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[HOUR_TENS_BOT]));

  digit_bitmap_layer[HOUR_TENS_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[HOUR_TENS_BOT_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[HOUR_TENS_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[HOUR_TENS_BOT_ANIM]));

  image_frame.origin.x = 31;
  image_frame.origin.y = 0;
  if ((settings & SETTING_DATE_BELOW_TIME) > 0) {
    image_frame.origin.y = 85;
  }
  digit_bitmap_layer[DAY_ONES_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_ONES_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_ONES_TOP],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_TOP]));

  digit_bitmap_layer[DAY_ONES_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_ONES_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_ONES_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[DAY_ONES_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[DAY_ONES_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_ONES_BOT], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_ONES_BOT],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_BOT]));

  digit_bitmap_layer[DAY_ONES_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_ONES_BOT_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_ONES_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[DAY_ONES_BOT_ANIM]));

  image_frame.origin.x = -4;
  image_frame.origin.y -= 42;
  digit_bitmap_layer[DAY_TENS_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_TENS_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_TENS_TOP],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_TOP]));

  digit_bitmap_layer[DAY_TENS_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_TENS_TOP_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_TENS_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[DAY_TENS_TOP_ANIM]));

  image_frame.origin.y += 42;
  digit_bitmap_layer[DAY_TENS_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_TENS_BOT], GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_TENS_BOT],
                                    GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_BOT]));

  digit_bitmap_layer[DAY_TENS_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(digit_bitmap_layer[DAY_TENS_BOT_ANIM],
                             GAlignBottom);
  bitmap_layer_set_compositing_mode(digit_bitmap_layer[DAY_TENS_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer, bitmap_layer_get_layer(
                                    digit_bitmap_layer[DAY_TENS_BOT_ANIM]));

  image_frame.origin.x = 65;
  image_frame.origin.y -= 42;
  month_bitmap_layer[MONTH_TOP] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(month_bitmap_layer[MONTH_TOP], GAlignBottom);
  bitmap_layer_set_compositing_mode(month_bitmap_layer[MONTH_TOP], GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(month_bitmap_layer[MONTH_TOP]));

  month_bitmap_layer[MONTH_TOP_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(month_bitmap_layer[MONTH_TOP_ANIM], GAlignBottom);
  bitmap_layer_set_compositing_mode(month_bitmap_layer[MONTH_TOP_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(month_bitmap_layer[MONTH_TOP_ANIM]));

  image_frame.origin.y += 42;
  month_bitmap_layer[MONTH_BOT] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(month_bitmap_layer[MONTH_TOP], GAlignTop);
  bitmap_layer_set_compositing_mode(month_bitmap_layer[MONTH_BOT], GCompOpOr);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(month_bitmap_layer[MONTH_BOT]));

  month_bitmap_layer[MONTH_BOT_ANIM] = bitmap_layer_create(image_frame);
  bitmap_layer_set_alignment(month_bitmap_layer[MONTH_BOT_ANIM], GAlignTop);
  bitmap_layer_set_compositing_mode(month_bitmap_layer[MONTH_BOT_ANIM],
                                    GCompOpAssign);
  layer_add_child(window_layer,
                  bitmap_layer_get_layer(month_bitmap_layer[MONTH_BOT_ANIM]));

  if ((settings & SETTING_TIME_ONLY) > 0) {

    layer_set_hidden(bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_TOP]),
                     true);
    layer_set_hidden(bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_BOT]),
                     true);
    layer_set_hidden(bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_TOP]),
                     true);
    layer_set_hidden(bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_BOT]),
                     true);
    layer_set_hidden(
        bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_TOP_ANIM]), true);
    layer_set_hidden(
        bitmap_layer_get_layer(digit_bitmap_layer[DAY_ONES_BOT_ANIM]), true);
    layer_set_hidden(
        bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_TOP_ANIM]), true);
    layer_set_hidden(
        bitmap_layer_get_layer(digit_bitmap_layer[DAY_TENS_BOT_ANIM]), true);
  }

  APP_LOG(APP_LOG_LEVEL_DEBUG, ""size of digit_bitmap_layer: %d"",
          sizeof(digit_bitmap_layer) / sizeof(*digit_bitmap_layer));

  const time_t now = time(NULL);
  const struct tm *ti = localtime(&now);
  timeinfo = malloc(sizeof(*ti));
  prev_timeinfo = malloc(sizeof(*ti));
  *timeinfo = *ti;
  *prev_timeinfo = *ti;

  const uint8_t month = timeinfo->tm_mon;
  const uint8_t day = timeinfo->tm_mday;
  uint8_t hour = timeinfo->tm_hour;

  if ((settings & SETTING_12H_TIME) > 0) {
    if (hour == 0) {
      hour = 12;
    } else if (hour > 12) {
      hour -= 12;
    }
  }
  const uint8_t min = timeinfo->tm_min;
  const uint8_t min_tens = min / 10;
  const uint8_t min_ones = min % 10;
  const uint8_t hour_tens = hour / 10;
  const uint8_t hour_ones = hour % 10;
  const uint8_t day_tens = day / 10;
  const uint8_t day_ones = day % 10;
  digit_bitmap[MINUTE_ONES_TOP] =
      gbitmap_create_with_resource(DIGITS[min_ones * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[MINUTE_ONES_BOT] = gbitmap_create_with_resource(
      DIGITS[min_ones * (ANIMATION_FRAMES + 1) + 4]);
  digit_bitmap[MINUTE_TENS_TOP] =
      gbitmap_create_with_resource(DIGITS[min_tens * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[MINUTE_TENS_BOT] = gbitmap_create_with_resource(
      DIGITS[min_tens * (ANIMATION_FRAMES + 1) + 4]);
  digit_bitmap[HOUR_ONES_TOP] =
      gbitmap_create_with_resource(DIGITS[hour_ones * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[HOUR_ONES_BOT] = gbitmap_create_with_resource(
      DIGITS[hour_ones * (ANIMATION_FRAMES + 1) + 4]);
  digit_bitmap[HOUR_TENS_TOP] =
      gbitmap_create_with_resource(DIGITS[hour_tens * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[HOUR_TENS_BOT] = gbitmap_create_with_resource(
      DIGITS[hour_tens * (ANIMATION_FRAMES + 1) + 4]);
  digit_bitmap[DAY_ONES_TOP] =
      gbitmap_create_with_resource(DIGITS[day_ones * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[DAY_ONES_BOT] = gbitmap_create_with_resource(
      DIGITS[day_ones * (ANIMATION_FRAMES + 1) + 4]);
  digit_bitmap[DAY_TENS_TOP] =
      gbitmap_create_with_resource(DIGITS[day_tens * (ANIMATION_FRAMES + 1)]);
  digit_bitmap[DAY_TENS_BOT] = gbitmap_create_with_resource(
      DIGITS[day_tens * (ANIMATION_FRAMES + 1) + 4]);

  bitmap_layer_set_bitmap(digit_bitmap_layer[MINUTE_ONES_TOP],
                          digit_bitmap[MINUTE_ONES_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[MINUTE_ONES_BOT],
                          digit_bitmap[MINUTE_ONES_BOT]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[MINUTE_TENS_TOP],
                          digit_bitmap[MINUTE_TENS_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[MINUTE_TENS_BOT],
                          digit_bitmap[MINUTE_TENS_BOT]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[HOUR_ONES_TOP],
                          digit_bitmap[HOUR_ONES_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[HOUR_ONES_BOT],
                          digit_bitmap[HOUR_ONES_BOT]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[HOUR_TENS_TOP],
                          digit_bitmap[HOUR_TENS_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[HOUR_TENS_BOT],
                          digit_bitmap[HOUR_TENS_BOT]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[DAY_ONES_TOP],
                          digit_bitmap[DAY_ONES_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[DAY_ONES_BOT],
                          digit_bitmap[DAY_ONES_BOT]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[DAY_TENS_TOP],
                          digit_bitmap[DAY_TENS_TOP]);
  bitmap_layer_set_bitmap(digit_bitmap_layer[DAY_TENS_BOT],
                          digit_bitmap[DAY_TENS_BOT]);

  inverter_layer =
      inverter_layer_create(GRect(0, 0, bounds.size.w, bounds.size.h));
  layer_add_child(window_layer, inverter_layer_get_layer(inverter_layer));
  layer_set_hidden(inverter_layer_get_layer(inverter_layer),
                   (settings & SETTING_INVERTED) == 0);

  animation_implementation =
      (AnimationImplementation){.setup = &setup_animation,
                                .teardown = &teardown_animation,
                                .update = &update_animation};

  uint8_t i = 0;
  for (; i < 4; i++) {
    animation[i] = animation_create();
    animation_set_duration(animation[i], 1000);
    animation_set_delay(animation[i], 2000);
    animation_set_implementation(animation[i], &animation_implementation);
  }
}"
asogaard-Wavenet-43bba39/include/Wavenet/Wavenet.h	Print the configuration of the wavenet object to stdout.	2	"m_lambda(lambda), m_alpha(alpha){};

Wavenet(const Wavenet &other)
    : m_lambda(other.m_lambda), m_alpha(other.m_alpha),
      m_inertia(other.m_inertia), m_inertiaTimeScale(other.m_inertiaTimeScale),
      m_filter(other.m_filter){};

~Wavenet(){};

inline double lambda() const { return m_lambda; }

inline double alpha() const { return m_alpha; }

inline double inertia() const { return m_inertia; }

inline double inertiaTimeScale() const { return m_inertiaTimeScale; }

inline arma::Col<double> filter() const { return m_filter; }

inline arma::Col<double> momentum() const { return m_momentum; }

inline int batchSize() const { return m_batchSize; }

inline bool wavelet() const { return m_wavelet; }

inline std::vector<arma::Col<double>> &filterLog() { return m_filterLog; }

inline void clearFilterLog() { return m_filterLog.clear(); }"
Benoit37000-proxmark3-iceman-91c7a7c/client/cmdhf15.c	Commandline handling: HF15 CMD READ Reads a single Block	2	"int CmdHF15CmdRead(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[100] = """";

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(""Usage:  hf 15 cmd read    [options] <uid|s|u|*> <page#>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           page#:        page number 0-255"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15_CMD_READ}, 1);
  reqlen = c.arg[0];

  pagenum = strtol(cmd, NULL, 0);

  req[reqlen++] = (uint8_t)pagenum;

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15_RES_ERROR)) {
        *output = 0;

        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%02X "", recv[i]);
        }
        strcat(output, ""   "");
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%c"",
                  recv[i] > 31 && recv[i] < 127 ? recv[i] : '.');
        }
        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[1], TagErrorStr(recv[1]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""no answer"");
  }

  return 0;
}"
openigtlink-OpenIGTLink-64ba851/Source/igtlMessageBase.h	Pack the meta data.	2	"unsigned char *m_MetaData;

unsigned char *m_MetaDataHeader;

igtlUint32 m_MessageId;

MetaDataMap m_MetaDataMap;

#endif
}
;

class IGTLCommon_EXPORT HeaderOnlyMessageBase : public MessageBase {
public:
  igtlTypeMacro(igtl::HeaderOnlyMessageBase, igtl::MessageBase);
  igtlNewMacro(igtl::HeaderOnlyMessageBase);

protected:
  HeaderOnlyMessageBase() { this->m_SendMessageType = """"; };
  ~HeaderOnlyMessageBase(){};

protected:
  virtual int CalculateContentBufferSize() { return 0; };
  virtual int PackContent() {
    AllocateBuffer();
    return 1;
  };
  virtual int UnpackContent() { return 1; };
};

#define igtlCreateDefaultQueryMessageClass(name, msgtype)                      \
  class IGTLCommon_EXPORT name : public HeaderOnlyMessageBase {                \
  public:                                                                      \
    igtlTypeMacro(igtl::name, igtl::HeaderOnlyMessageBase);                    \
    igtlNewMacro(igtl::name);                                                  \
                                                                               \
  protected:                                                                   \
    name() : HeaderOnlyMessageBase() { this->m_SendMessageType = msgtype; };   \
    ~name(){};                                                                 \
  };
}"
ging-isabel-1ec0172/lib/ffmpeg/Win32/src/ffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = url_ftell(ic->pb);

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);
    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open(st->codec, codec);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR(EINTR);
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < 20 &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      if (st->time_base.den > 0 &&
          av_rescale_q(st->info->codec_info_duration, st->time_base,
                       AV_TIME_BASE_Q) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING, ""max_analyze_duration reached\n"");
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))
      try_decode_frame(st, pkt);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample)
        st->codec->codec_tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd > 1 && !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);
    }
  }

  av_estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/CDC.c	Sends a Send Break request to the device. This is generally used to separate data data or to indicate a special condition to the receiving device.	2	"uint8_t CDC_Host_SendBreak(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo,
                           const uint8_t Duration) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SendBreak,
      .wValue = Duration,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
psyc-libpsyc-d16deca/include/psyc/text.h	Sets a new output buffer in the PSYC text state struct.	2	"psyc_text_buffer_set(PsycTextState *state, char *buffer, size_t length) {
  state->buffer = (PsycString){length, buffer};
  state->written = 0;
}"
lcdproc-lcdproc-e08546c/server/menu.c	"Updates the widgets of the selected menuitem DO NOT CALL THIS FUNCTION, CALL menuitem_update_screen INSTEAD !"	2	"void menu_update_screen(MenuItem *menu, Screen *s) {
  Widget *w;
  MenuItem *subitem;
  int itemnr;
  int hidden_count = 0;

  debug(RPT_DEBUG, ""%s(menu=[%s], screen=[%s])"", __FUNCTION__,
        ((menu != NULL) ? menu->id : ""(null)""),
        ((s != NULL) ? s->id : ""(null)""));

  if ((menu == NULL) || (s == NULL))
    return;

  w = screen_find_widget(s, ""title"");
  if (w == NULL)
    report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__, ""title"");
  w->y = 1 - menu->data.menu.scroll;

  w->type =
      ((w->y > 0) && (w->y <= display_props->height)) ? WID_TITLE : WID_NONE;

  for (subitem = LL_GetFirst(menu->data.menu.contents), itemnr = 0;
       subitem != NULL;
       subitem = LL_GetNext(menu->data.menu.contents), itemnr++) {
    char buf[LCD_MAX_WIDTH];
    char *p;
    int len = display_props->width - 1;

    if (subitem->is_hidden) {
      debug(RPT_DEBUG, ""%s: menu %s has hidden menu: %s"", __FUNCTION__,
            menu->id, subitem->id);
      hidden_count++;
      continue;
    }
    snprintf(buf, sizeof(buf) - 1, ""text%d"", itemnr);
    buf[sizeof(buf) - 1] = '\0';
    w = screen_find_widget(s, buf);
    if (w == NULL)
      report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__, buf);
    w->y = 2 + itemnr - hidden_count - menu->data.menu.scroll;

    w->type =
        ((w->y > 0) && (w->y <= display_props->height)) ? WID_STRING : WID_NONE;

    switch (subitem->type) {
    case MENUITEM_CHECKBOX:

      snprintf(buf, sizeof(buf) - 1, ""icon%d"", itemnr);
      buf[sizeof(buf) - 1] = '\0';
      w = screen_find_widget(s, buf);
      if (w == NULL)
        report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__, buf);
      w->y = 2 + itemnr - menu->data.menu.scroll;
      w->length = ((int[]){ICON_CHECKBOX_OFF, ICON_CHECKBOX_ON,
                           ICON_CHECKBOX_GRAY})[subitem->data.checkbox.value];

      w->type =
          ((w->y > 0) && (w->y <= display_props->height)) ? WID_ICON : WID_NONE;
      break;
    case MENUITEM_RING:
      p = LL_GetByIndex(subitem->data.ring.strings, subitem->data.ring.value);
      fill_labeled_value(w->text, len, subitem->text, p, LV_VALUE_ONLY);

      break;
    case MENUITEM_SLIDER:
      snprintf(buf, display_props->width, ""%d"", subitem->data.slider.value);
      buf[display_props->width - 1] = '\0';
      fill_labeled_value(w->text, len, subitem->text, buf, LV_LABEL_VALU);
      break;
    case MENUITEM_NUMERIC:
      snprintf(buf, display_props->width, ""%d"", subitem->data.numeric.value);
      buf[display_props->width - 1] = '\0';
      fill_labeled_value(w->text, len, subitem->text, buf, LV_LABEL_VALU);
      break;
    case MENUITEM_ALPHA:
      fill_labeled_value(w->text, len, subitem->text, subitem->data.alpha.value,
                         LV_LABEL_VALU);
      break;
    case MENUITEM_IP:
      fill_labeled_value(w->text, len, subitem->text, subitem->data.ip.value,
                         LV_LABEL_ALUE);
      break;
    default:
      break;
    }
  }

  w = screen_find_widget(s, ""selector"");
  if (w != NULL)
    w->y = 2 + menu->data.menu.selector_pos - menu->data.menu.scroll;
  else
    report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__, ""selector"");

  w = screen_find_widget(s, ""upscroller"");
  if (w != NULL)
    w->type = (menu->data.menu.scroll > 0) ? WID_ICON : WID_NONE;
  else
    report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__,
           ""upscroller"");

  w = screen_find_widget(s, ""downscroller"");
  if (w != NULL)
    w->type = (menu_visible_item_count(menu) >=
               menu->data.menu.scroll + display_props->height)
                  ? WID_ICON
                  : WID_NONE;
  else
    report(RPT_ERR, ""%s: could not find widget: %s"", __FUNCTION__,
           ""downscroller"");
}"
longluo-FFMpeg-bc33159/jni/libffmpeg/libavformat/utils.c	Reads packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t last_dts[MAX_STREAMS];
  int64_t duration_gcd[MAX_STREAMS] = {0};
  int duration_count[MAX_STREAMS] = {0};
  double(*duration_error)[MAX_STD_TIMEBASES];
  int64_t old_offset = url_ftell(ic->pb);
  int64_t codec_info_duration[MAX_STREAMS] = {0};

  duration_error = av_mallocz(MAX_STREAMS * sizeof(*duration_error));
  if (!duration_error)
    return AVERROR(ENOMEM);

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);

    if (!has_codec_parameters(st->codec)) {
      AVCodec *codec = avcodec_find_decoder(st->codec->codec_id);
      if (codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < MAX_STREAMS; i++) {
    last_dts[i] = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR(EINTR);
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          duration_count[i] < 20 && st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret == AVERROR(EAGAIN))
      continue;
    if (ret < 0) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if (av_dup_packet(pkt) < 0) {
      av_free(duration_error);
      return AVERROR(ENOMEM);
    }

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      if (st->time_base.den > 0 &&
          av_rescale_q(codec_info_duration[st->index], st->time_base,
                       AV_TIME_BASE_Q) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING, ""max_analyze_duration reached\n"");
        break;
      }
      codec_info_duration[st->index] += pkt->duration;
    }
    st->codec_info_nb_frames++;

    {
      int index = pkt->stream_index;
      int64_t last = last_dts[index];
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (duration_count[index] < 2)
          memset(duration_error[index], 0, sizeof(*duration_error));
        for (i = 1; i < MAX_STD_TIMEBASES; i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          duration_error[index][i] += error * error;
        }
        duration_count[index]++;

        if (duration_count[index] > 3)
          duration_gcd[index] = av_gcd(duration_gcd[index], duration);
      }
      if (last == AV_NOPTS_VALUE || duration_count[index] <= 1)
        last_dts[pkt->stream_index] = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec))
      try_decode_frame(st, pkt);

    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        codec_info_duration[i])
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                codec_info_duration[i] * (int64_t)st->time_base.num, 60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample)
        st->codec->codec_tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);

      if (tb_unreliable(st->codec) && duration_count[i] > 15 &&
          duration_gcd[i] > 1 && !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * duration_gcd[i],
                  INT_MAX);
      if (duration_count[i] && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * duration_count[i] * 1000 * 12 * 30;

        for (j = 1; j < MAX_STD_TIMEBASES; j++) {
          double error = duration_error[i][j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);
    }
  }

  av_estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

  av_free(duration_error);

  return ret;
}"
KjellKod-g3log-9c5e7f3/src/g3log/loglevels.hpp	print snapshot of system levels with their disabled or enabled status	2	"LoggingLevel() : status(false), level(INFO){};
LoggingLevel(const LoggingLevel &lvl) : status(lvl.status), level(lvl.level) {}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/maps.c	Create a new indefinite map	2	"cbor_item_t *cbor_new_indefinite_map() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL)
    return NULL;
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = 0,
                                    .type = _CBOR_METADATA_INDEFINITE,
                                    .end_ptr = 0}},
      .data = NULL};

  return item;
}"
cmassiot-vlc-broadcast-de11815/modules/video_output/xcb/glx.c	Disconnect from the X server.	1	"static void Close(vlc_object_t *obj) {
  vout_display_t *vd = (vout_display_t *)obj;
  vout_display_sys_t *sys = vd->sys;
  Display *dpy = sys->display;

  if (sys->gl.sys != NULL)
    vout_display_opengl_Clean(&sys->vgl);

  if (sys->ctx != NULL) {
    if (sys->v1_3)
      glXMakeContextCurrent(dpy, None, None, NULL);
    else
      glXMakeCurrent(dpy, None, NULL);
    glXDestroyContext(dpy, sys->ctx);
    if (sys->v1_3)
      glXDestroyWindow(dpy, sys->glwin);
  }

  xcb_change_window_attributes(XGetXCBConnection(sys->display),
                               sys->embed->handle.xid, XCB_CW_CURSOR,
                               &(uint32_t){XCB_CURSOR_NONE});
  xcb_flush(XGetXCBConnection(sys->display));

  XCloseDisplay(dpy);
  vout_display_DeleteWindow(vd, sys->embed);
  free(sys);
}"
darktable-org-darktable-32fab21/src/iop/colorcontrast.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {

  dt_iop_colorcontrast_params_t tmp =
      (dt_iop_colorcontrast_params_t){1.0, 0.0, 1.0, 0.0, 1};
  memcpy(module->params, &tmp, sizeof(dt_iop_colorcontrast_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_colorcontrast_params_t));
  module->default_enabled = 0;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavfilter/fifo.c	Move data pointers and pts offset samples forward.	2	"static void buffer_offset(AVFilterLink *link, AVFrame *frame, int offset) {
  int nb_channels = link->channels;
  int planar = av_sample_fmt_is_planar(link->format);
  int planes = planar ? nb_channels : 1;
  int block_align =
      av_get_bytes_per_sample(link->format) * (planar ? 1 : nb_channels);
  int i;

  av_assert0(frame->nb_samples > offset);

  for (i = 0; i < planes; i++)
    frame->extended_data[i] += block_align * offset;
  if (frame->data != frame->extended_data)
    memcpy(frame->data, frame->extended_data,
           FFMIN(planes, FF_ARRAY_ELEMS(frame->data)) * sizeof(*frame->data));
  frame->linesize[0] -= block_align * offset;
  frame->nb_samples -= offset;

  if (frame->pts != AV_NOPTS_VALUE) {
    frame->pts += av_rescale_q(offset, (AVRational){1, link->sample_rate},
                               link->time_base);
  }
}"
scottcgi-Mojoc-91c8c17/Engine/Application/Platform/Android/NativeGlue.c	Process the next input event	2	"static inline int32_t OnInputEvent(AInputEvent *event) {
  switch (AInputEvent_getType(event)) {
  case AINPUT_EVENT_TYPE_MOTION: {
    int32_t action = AMotionEvent_getAction(event);

    switch (action & AMOTION_EVENT_ACTION_MASK) {

    case AMOTION_EVENT_ACTION_DOWN: {
      AApplication->Touch(AArray_Make(
          InputTouch *, 1,
          AInput->SetTouch(AMotionEvent_getPointerId(event, 0),
                           AMotionEvent_getX(event, 0),
                           AMotionEvent_getY(event, 0), InputTouchType_Down)));

      break;
    }

    case AMOTION_EVENT_ACTION_POINTER_DOWN: {
      int indexDown = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >>
                      AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;

      AApplication->Touch(AArray_Make(
          InputTouch *, 1,
          AInput->SetTouch(AMotionEvent_getPointerId(event, indexDown),
                           AMotionEvent_getX(event, indexDown),
                           AMotionEvent_getY(event, indexDown),
                           InputTouchType_Down)));

      break;
    }

    case AMOTION_EVENT_ACTION_UP: {
      AApplication->Touch(AArray_Make(
          InputTouch *, 1,
          AInput->SetTouch(AMotionEvent_getPointerId(event, 0),
                           AMotionEvent_getX(event, 0),
                           AMotionEvent_getY(event, 0), InputTouchType_Up)));

      break;
    }

    case AMOTION_EVENT_ACTION_POINTER_UP: {
      int indexUp = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >>
                    AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;

      AApplication->Touch(AArray_Make(
          InputTouch *, 1,
          AInput->SetTouch(AMotionEvent_getPointerId(event, indexUp),
                           AMotionEvent_getX(event, indexUp),
                           AMotionEvent_getY(event, indexUp),
                           InputTouchType_Up)));

      break;
    }

    case AMOTION_EVENT_ACTION_MOVE: {
      int count = AMotionEvent_getPointerCount(event);
      InputTouch *touches[count];

      for (int i = 0; i < count; i++) {
        InputTouch *touch = AInput->SetTouch(
            AMotionEvent_getPointerId(event, i), AMotionEvent_getX(event, i),
            AMotionEvent_getY(event, i), InputTouchType_Move);

        touches[i] = touch;
      }

      AApplication->Touch((Array[]){touches, count});

      break;
    }

    case AMOTION_EVENT_ACTION_CANCEL: {
      int count = AMotionEvent_getPointerCount(event);
      InputTouch *touches[count];

      for (int i = 0; i < count; i++) {
        InputTouch *touch = AInput->SetTouch(
            AMotionEvent_getPointerId(event, i), AMotionEvent_getX(event, i),
            AMotionEvent_getY(event, i), InputTouchType_Cancel);

        touches[i] = touch;
      }

      AApplication->Touch((Array[]){touches, count});

      break;
    }

    default:
      return 0;
    }

    return 1;
  }

  case AINPUT_EVENT_TYPE_KEY:
    break;
  }

  return 0;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	"Compares the lower double-precision floating-point values in each of the two 128-bit floating-point vectors of [2 x double] to determine if the value in the first parameter is greater than or equal to the corresponding value in the second parameter. The comparison yields 0x0 for false, 0xFFFFFFFFFFFFFFFF for true."	2	"_mm_cmpge_sd(__m128d __a, __m128d __b) {
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}"
dm-vdo-kvdo-8df6805/vdo/base/slabSummary.c	Get the stored slab statuses for all slabs in a zone.	2	"void getSummarizedSlabStatuses(SlabSummaryZone *summaryZone,
                               SlabCount slabCount, SlabStatus *statuses) {
  for (SlabCount i = 0; i < slabCount; i++) {
    statuses[i] =
        (SlabStatus){.slabNumber = i,
                     .isClean = !summaryZone->entries[i].isDirty,
                     .emptiness = summaryZone->entries[i].fullnessHint};
  }
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Core/ConfigDescriptor.c	"Retrieves the configuration descriptor data from an attached device via a standard request into a buffer, including validity and size checking to prevent a buffer overflow."	0	"uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t *const ConfigSizePtr,
                                           void *const BufferPtr,
                                           const uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Configuration_Header_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  *ConfigSizePtr =
      DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
          ->TotalConfigurationSize;

  if (*ConfigSizePtr > BufferSize)
    return HOST_GETCONFIG_BuffOverflow;

  USB_ControlRequest.wLength = *ConfigSizePtr;

  if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    return HOST_GETCONFIG_InvalidData;

  return HOST_GETCONFIG_Successful;
}"
fanglingsu-vimb-beba6b1/src/normal.c	Called when the normal mode is left.	2	"void normal_leave(Client *c) { command_search(c, &((Arg){0, NULL}), FALSE); }"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Device/RNDISEthernet/RNDISEthernet.c	"Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host."	2	"TASK(RNDIS_Task) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Notification_t Notification = (USB_Notification_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bNotification = NOTIF_RESPONSE_AVAILABLE,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification));

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_PACKET_MSG_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameInBuffer)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_PACKET_MSG_t));

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;

      FrameIN.FrameInBuffer = true;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPNUM);

    if (Endpoint_IsINReady() && FrameOUT.FrameInBuffer) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_PACKET_MSG_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_PACKET_MSG_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_PACKET_MSG_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_PACKET_MSG_t));

      Endpoint_Write_Stream_LE(FrameOUT.FrameData,
                               RNDISPacketHeader.DataLength);

      Endpoint_ClearIN();

      FrameOUT.FrameInBuffer = false;
    }
  }
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/CDC.c	Sets the line encoding for the attached device's virtual serial port. This should be called when the LineEncoding values of the interface have been changed to push the new settings to the USB device.	2	"uint8_t
CDC_Host_SetLineEncoding(USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SetLineEncoding,
      .wValue = 0,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = sizeof(CDCInterfaceInfo->State.LineEncoding),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(&CDCInterfaceInfo->State.LineEncoding);
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavformat/mux.c	Chooses a timebase for muxing the specified stream. The choosen timebase allows sample accurate timestamps based on the framerate or sample rate for audio streams. It also is at least as precisse as 1/min_precission would be.	2	"AVRational ff_choose_timebase(AVFormatContext *s, AVStream *st,
                              int min_precission) {
  AVRational q;
  int j;

  if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
    q = (AVRational){1, st->codec->sample_rate};
  } else {
    q = st->codec->time_base;
  }
  for (j = 2; j < 14; j += 1 + (j > 2))
    while (q.den / q.num < min_precission && q.num % j == 0)
      q.num /= j;
  while (q.den / q.num < min_precission && q.den < (1 << 24))
    q.den <<= 1;

  return q;
}"
google-graphd-e994e88/libgdp/gdp-input.c	Initialize input as a plain buffer.	2	"int gdp_input_init_plain(gdp_input *in, char const *buf, size_t size,
                         cm_handle *cm, cl_handle *cl) {
  srv_buffer *b;

  if ((b = cm_malloc(cm, sizeof(srv_buffer))) == NULL)
    return ENOMEM;

  *b = (srv_buffer){
      .b_s = (char *)buf,
      .b_n = size,
  };

  *in = (gdp_input){
      .in_queue =
          (gdp_input_queue){
              .iq_curr = b,
              .iq_curr_i = 0,
              .iq_tail = b,
              .iq_tail_n = size,
          },
      .in_cm = cm,
      .in_cl = cl,
      .in_row = 1,
      .in_col = 1,
  };

  return 0;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Core/HostStandardReq.c	"Sends a SET CONFIGURATION standard request to the attached device, with the given configuration index."	3	"uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_SetConfiguration,
      .wValue = ConfigNumber,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) ==
      HOST_SENDCONTROL_Successful) {
    USB_Host_ConfigurationNumber = ConfigNumber;
    USB_HostState =
        (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
  }

  return ErrorCode;
}"
nutjunkie-IQmol-a8e3012/src/OpenMesh/src/OpenMesh/Tools/Subdivider/Uniform/Composite/CompositeT.hh	"Split Face, using Vertex information (1-3 split)"	2	"typedef RealType real_t;
typedef MeshType mesh_t;
typedef SubdividerT<mesh_t, real_t> parent_t;

public:
CompositeT(void) : parent_t(), p_mesh_(NULL) {}
CompositeT(MeshType &_mesh) : parent_t(_mesh), p_mesh_(NULL){};
virtual ~CompositeT() {}

public:
virtual const char *name(void) const = 0;

protected:
bool prepare(MeshType &_m);

bool subdivide(MeshType &_m, size_t _n, const bool _update_points = true) {
  assert(p_mesh_ == &_m);

  while (_n--) {
    apply_rules();
    commit(_m);
  }

  return true;
}

#ifdef NDEBUG
bool cleanup(MeshType &)
#else
bool cleanup(MeshType &_m)
#endif
{
  assert(p_mesh_ == &_m);
  p_mesh_ = NULL;
  return true;
}

protected:
virtual void apply_rules(void) = 0;

protected:
void commit(MeshType &_m) {
  typename MeshType::VertexIter v_it;

  for (v_it = _m.vertices_begin(); v_it != _m.vertices_end(); ++v_it)
    _m.set_point(*v_it, _m.data(*v_it).position());
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/issue.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      issue,
      'i',
      ""issue"",
      ""issue a certificate using a CA certificate and key"",
      {""[--in file] [--type pub|pkcs10] --cakey file | --cakeyid hex"",
       "" --cacert file [--dn subject-dn] [--san subjectAltName]+"",
       ""[--lifetime days] [--serial hex] [--crl uri [--crlissuer i] ]+ [--ocsp ""
       ""uri]+"",
       ""[--ca] [--pathlen len] [--flag ""
       ""serverAuth|clientAuth|crlSign|ocspSigning]+"",
       ""[--nc-permitted name] [--nc-excluded name]"",
       ""[--cert-policy oid [--cps-uri uri] [--user-notice text] ]+"",
       ""[--policy-map issuer-oid:subject-oid]"",
       ""[--policy-explicit len] [--policy-inhibit len] [--policy-any len]"",
       ""[--digest md5|sha1|sha224|sha256|sha384|sha512] [--outform der|pem]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""public key/request file to issue, default: stdin""},
          {""type"", 't', 1, ""type of input, default: pub""},
          {""cacert"", 'c', 1, ""CA certificate file""},
          {""cakey"", 'k', 1, ""CA private key file""},
          {""cakeyid"", 'x', 1, ""keyid on smartcard of CA private key""},
          {""dn"", 'd', 1, ""distinguished name to include as subject""},
          {""san"", 'a', 1, ""subjectAltName to include in certificate""},
          {""lifetime"", 'l', 1, ""days the certificate is valid, default: 1095""},
          {""serial"", 's', 1, ""serial number in hex, default: random""},
          {""ca"", 'b', 0, ""include CA basicConstraint, default: no""},
          {""pathlen"", 'p', 1, ""set path length constraint""},
          {""nc-permitted"", 'n', 1, ""add permitted NameConstraint""},
          {""nc-excluded"", 'N', 1, ""add excluded NameConstraint""},
          {""cert-policy"", 'P', 1, ""certificatePolicy OID to include""},
          {""cps-uri"", 'C', 1,
           ""Certification Practice statement URI for certificatePolicy""},
          {""user-notice"", 'U', 1, ""user notice for certificatePolicy""},
          {""policy-mapping"", 'M', 1,
           ""policyMapping from issuer to subject OID""},
          {""policy-explicit"", 'E', 1, ""requireExplicitPolicy constraint""},
          {""policy-inhibit"", 'H', 1, ""inhibitPolicyMapping constraint""},
          {""policy-any"", 'A', 1, ""inhibitAnyPolicy constraint""},
          {""flag"", 'e', 1, ""include extendedKeyUsage flag""},
          {""crl"", 'u', 1, ""CRL distribution point URI to include""},
          {""crlissuer"", 'I', 1, ""CRL Issuer for CRL at distribution point""},
          {""ocsp"", 'o', 1, ""OCSP AuthorityInfoAccess URI to include""},
          {""digest"", 'g', 1, ""digest for signature creation, default: sha1""},
          {""outform"", 'f', 1, ""encoding of generated cert, default: der""},
      }});
}"
ImpulseAdventure-GUIslice-4bd031f/src/GUIslice_drv_sdl.c	Draw a text string at the given coordinate	2	"bool gslc_DrvDrawTxt(gslc_tsGui *pGui, int16_t nTxtX, int16_t nTxtY,
                     gslc_tsFont *pFont, const char *pStr,
                     gslc_teTxtFlags eTxtFlags, gslc_tsColor colTxt,
                     gslc_tsColor colBg) {
  if ((pGui == NULL) || (pFont == NULL)) {
    GSLC_DEBUG_PRINT(""ERROR: DrvDrawTxt(%s) with NULL ptr\n"", """");
    return false;
  }
  if ((pStr == NULL) || (pStr[0] == '\0')) {
    return true;
  }

  gslc_tsDriver *pDriver = (gslc_tsDriver *)(pGui->pvDriver);
  SDL_Surface *pSurfTxt = NULL;
  TTF_Font *pDrvFont = (TTF_Font *)(pFont->pvFont);
  if ((eTxtFlags & GSLC_TXT_ENC) == GSLC_TXT_ENC_UTF8) {
    pSurfTxt =
        TTF_RenderUTF8_Blended(pDrvFont, pStr, gslc_DrvAdaptColor(colTxt));
  } else {
    pSurfTxt =
        TTF_RenderText_Blended(pDrvFont, pStr, gslc_DrvAdaptColor(colTxt));
  }
  if (pSurfTxt == NULL) {
    GSLC_DEBUG_PRINT(
        ""ERROR: DrvDrawTxt() failed in TTF_RenderText_Solid() (%s)\n"", pStr);
    return false;
  }

#if defined(DRV_DISP_SDL1)
  gslc_DrvPasteSurface(pGui, nTxtX, nTxtY, pSurfTxt, pDriver->pSurfScreen);
#endif
#if defined(DRV_DISP_SDL2)
  SDL_Rect rRect = (SDL_Rect){nTxtX, nTxtY, pSurfTxt->w, pSurfTxt->h};
  SDL_Renderer *pRender = pDriver->pRender;
  SDL_Texture *pTex = SDL_CreateTextureFromSurface(pRender, pSurfTxt);
  if (pTex == NULL) {
    GSLC_DEBUG_PRINT(
        ""ERROR: DrvDrawTxt() error in SDL_CreateTextureFromSurface(): %s\n"",
        SDL_GetError());
    return false;
  }
  SDL_RenderCopy(pRender, pTex, NULL, &rRect);

  SDL_DestroyTexture(pTex);
  pTex = NULL;
#endif

  if (pSurfTxt != NULL) {
    SDL_FreeSurface(pSurfTxt);
    pSurfTxt = NULL;
  }

  return true;
}"
Yeolar-coral-folly-01efac5/folly/futures/Future-inl.h	This function is thread-safe for Futures running on different threads.	4	"collectAny(InputIterator first, InputIterator last) {
  typedef
      typename std::iterator_traits<InputIterator>::value_type::value_type T;

  struct CollectAnyContext {
    CollectAnyContext(){};
    Promise<std::pair<size_t, Try<T>>> p;
    std::atomic<bool> done{false};
  };

  auto ctx = std::make_shared<CollectAnyContext>();
  mapSetCallback<T>(first, last, [ctx](size_t i, Try<T> &&t) {
    if (!ctx->done.exchange(true)) {
      ctx->p.setValue(std::make_pair(i, std::move(t)));
    }
  });
  return ctx->p.getFuture();
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/HID.c	"Switches the attached HID device's reporting protocol over to the standard Report protocol mode. This also retrieves and parses the device's HID report descriptor, so that the size of each report can be determined in advance."	1	"uint8_t
HID_Host_SetReportProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  uint8_t HIDReportData[HIDInterfaceInfo->State.HIDReportSize];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (DTYPE_Report << 8),
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = HIDInterfaceInfo->State.HIDReportSize,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(HIDReportData)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (HIDInterfaceInfo->State.UsingBootProtocol) {
    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = REQ_SetProtocol,
        .wValue = 1,
        .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
        .wLength = 0,
    };

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful)
      return ErrorCode;

    HIDInterfaceInfo->State.UsingBootProtocol = false;
  }

  if (HIDInterfaceInfo->Config.HIDParserData == NULL)
    return HID_ERROR_LOGICAL;

  if ((ErrorCode = USB_ProcessHIDReport(
           HIDReportData, HIDInterfaceInfo->State.HIDReportSize,
           HIDInterfaceInfo->Config.HIDParserData)) != HID_PARSE_Successful) {
    return HID_ERROR_LOGICAL | ErrorCode;
  }

  uint8_t LargestReportSizeBits =
      HIDInterfaceInfo->Config.HIDParserData->LargestReportSizeBits;
  HIDInterfaceInfo->State.LargestReportSize =
      (LargestReportSizeBits >> 3) + ((LargestReportSizeBits & 0x07) != 0);

  return 0;
}"
GargoyleSoftware-voip-client-ios-134091a/submodules/externals/ffmpeg/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  unsigned frames = 0;
  unsigned size = 0;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (ff_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  avio_skip(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1]);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
    v = avio_rb32(s->pb);
    if (v & 0x1)
      frames = avio_rb32(s->pb);
    if (v & 0x2)
      size = avio_rb32(s->pb);
  }

  avio_seek(s->pb, base + 4 + 32, SEEK_SET);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (avio_rb16(s->pb) == 1) {

      avio_skip(s->pb, 4);
      frames = avio_rb32(s->pb);
      size = avio_rb32(s->pb);
    }
  }

  if (!frames && !size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  spf = c.lsf ? 576 : 1152;
  if (frames)
    st->duration =
        av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
  if (size && frames)
    st->codec->bit_rate =
        av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);

  return 0;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Read Capacity command to the attached device, to determine the capacity of the given Logical Unit within the device."	2	"uint8_t MassStore_ReadCapacity(const uint8_t LUNIndex,
                               SCSI_Capacity_t *const CapacityPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Capacity_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, CapacityPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  CapacityPtr->Blocks = SwapEndian_32(CapacityPtr->Blocks);
  CapacityPtr->BlockSize = SwapEndian_32(CapacityPtr->BlockSize);

  if ((ErrorCode = MassStore_GetReturnedStatus(&SCSICommandStatus)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ErrorCode;
  }

  return ErrorCode;
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavdevice/x11grab.c	Initialize the x11 grab device demuxer (public device demuxer API).	0	"x11grab_read_header(AVFormatContext *s1) {
  struct x11_grab *x11grab = s1->priv_data;
  Display *dpy;
  AVStream *st = NULL;
  enum PixelFormat input_pixfmt;
  XImage *image;
  int x_off = 0;
  int y_off = 0;
  int screen;
  int use_shm;
  char *dpyname, *offset;
  int ret = 0;
  AVRational framerate;

  dpyname = av_strdup(s1->filename);
  if (!dpyname)
    goto out;

  offset = strchr(dpyname, '+');
  if (offset) {
    sscanf(offset, ""%d,%d"", &x_off, &y_off);
    x11grab->draw_mouse = !strstr(offset, ""nomouse"");
    *offset = 0;
  }

  if ((ret = av_parse_video_size(&x11grab->width, &x11grab->height,
                                 x11grab->video_size)) < 0) {
    av_log(s1, AV_LOG_ERROR, ""Couldn't parse video size.\n"");
    goto out;
  }
  if ((ret = av_parse_video_rate(&framerate, x11grab->framerate)) < 0) {
    av_log(s1, AV_LOG_ERROR, ""Could not parse framerate: %s.\n"",
           x11grab->framerate);
    goto out;
  }
  av_log(s1, AV_LOG_INFO,
         ""device: %s -> display: %s x: %d y: %d width: %d height: %d\n"",
         s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);

  dpy = XOpenDisplay(dpyname);
  av_freep(&dpyname);
  if (!dpy) {
    av_log(s1, AV_LOG_ERROR, ""Could not open X display.\n"");
    ret = AVERROR(EIO);
    goto out;
  }

  st = avformat_new_stream(s1, NULL);
  if (!st) {
    ret = AVERROR(ENOMEM);
    goto out;
  }
  avpriv_set_pts_info(st, 64, 1, 1000000);

  screen = DefaultScreen(dpy);

  if (x11grab->follow_mouse) {
    int screen_w, screen_h;
    Window w;

    screen_w = DisplayWidth(dpy, screen);
    screen_h = DisplayHeight(dpy, screen);
    XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret,
                  &ret, &ret);
    x_off -= x11grab->width / 2;
    y_off -= x11grab->height / 2;
    x_off = FFMIN(FFMAX(x_off, 0), screen_w - x11grab->width);
    y_off = FFMIN(FFMAX(y_off, 0), screen_h - x11grab->height);
    av_log(s1, AV_LOG_INFO,
           ""followmouse is enabled, resetting grabbing region to x: %d y: %d\n"",
           x_off, y_off);
  }

  use_shm = XShmQueryExtension(dpy);
  av_log(s1, AV_LOG_INFO, ""shared memory extension%s found\n"",
         use_shm ? """" : "" not"");

  if (use_shm) {
    int scr = XDefaultScreen(dpy);
    image = XShmCreateImage(dpy, DefaultVisual(dpy, scr),
                            DefaultDepth(dpy, scr), ZPixmap, NULL,
                            &x11grab->shminfo, x11grab->width, x11grab->height);
    x11grab->shminfo.shmid = shmget(
        IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT | 0777);
    if (x11grab->shminfo.shmid == -1) {
      av_log(s1, AV_LOG_ERROR, ""Fatal: Can't get shared memory!\n"");
      ret = AVERROR(ENOMEM);
      goto out;
    }
    x11grab->shminfo.shmaddr = image->data =
        shmat(x11grab->shminfo.shmid, 0, 0);
    x11grab->shminfo.readOnly = False;

    if (!XShmAttach(dpy, &x11grab->shminfo)) {
      av_log(s1, AV_LOG_ERROR, ""Fatal: Failed to attach shared memory!\n"");

      ret = AVERROR(EIO);
      goto out;
    }
  } else {
    image = XGetImage(dpy, RootWindow(dpy, screen), x_off, y_off,
                      x11grab->width, x11grab->height, AllPlanes, ZPixmap);
  }

  switch (image->bits_per_pixel) {
  case 8:
    av_log(s1, AV_LOG_DEBUG, ""8 bit palette\n"");
    input_pixfmt = PIX_FMT_PAL8;
    break;
  case 16:
    if (image->red_mask == 0xf800 && image->green_mask == 0x07e0 &&
        image->blue_mask == 0x001f) {
      av_log(s1, AV_LOG_DEBUG, ""16 bit RGB565\n"");
      input_pixfmt = PIX_FMT_RGB565;
    } else if (image->red_mask == 0x7c00 && image->green_mask == 0x03e0 &&
               image->blue_mask == 0x001f) {
      av_log(s1, AV_LOG_DEBUG, ""16 bit RGB555\n"");
      input_pixfmt = PIX_FMT_RGB555;
    } else {
      av_log(s1, AV_LOG_ERROR,
             ""RGB ordering at image depth %i not supported ... aborting\n"",
             image->bits_per_pixel);
      av_log(s1, AV_LOG_ERROR, ""color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n"",
             image->red_mask, image->green_mask, image->blue_mask);
      ret = AVERROR(EIO);
      goto out;
    }
    break;
  case 24:
    if (image->red_mask == 0xff0000 && image->green_mask == 0x00ff00 &&
        image->blue_mask == 0x0000ff) {
      input_pixfmt = PIX_FMT_BGR24;
    } else if (image->red_mask == 0x0000ff && image->green_mask == 0x00ff00 &&
               image->blue_mask == 0xff0000) {
      input_pixfmt = PIX_FMT_RGB24;
    } else {
      av_log(s1, AV_LOG_ERROR,
             ""rgb ordering at image depth %i not supported ... aborting\n"",
             image->bits_per_pixel);
      av_log(s1, AV_LOG_ERROR, ""color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n"",
             image->red_mask, image->green_mask, image->blue_mask);
      ret = AVERROR(EIO);
      goto out;
    }
    break;
  case 32:
    input_pixfmt = PIX_FMT_0RGB32;
    break;
  default:
    av_log(s1, AV_LOG_ERROR, ""image depth %i not supported ... aborting\n"",
           image->bits_per_pixel);
    ret = AVERROR(EINVAL);
    goto out;
  }

  x11grab->frame_size =
      x11grab->width * x11grab->height * image->bits_per_pixel / 8;
  x11grab->dpy = dpy;
  x11grab->time_base = (AVRational){framerate.den, framerate.num};
  x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);
  x11grab->x_off = x_off;
  x11grab->y_off = y_off;
  x11grab->image = image;
  x11grab->use_shm = use_shm;

  st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
  st->codec->codec_id = CODEC_ID_RAWVIDEO;
  st->codec->width = x11grab->width;
  st->codec->height = x11grab->height;
  st->codec->pix_fmt = input_pixfmt;
  st->codec->time_base = x11grab->time_base;
  st->codec->bit_rate =
      x11grab->frame_size * 1 / av_q2d(x11grab->time_base) * 8;

out:
  av_free(dpyname);
  return ret;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands."	1	"uint8_t MS_Host_TestUnitReady(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                              const uint8_t LUNIndex) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(0),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
dm-vdo-kvdo-8df6805/vdo/base/referenceOperation.c	Set up a ReferenceOperation for which we will need to look up the lock later.	2	"void setUpReferenceOperationWithZone(JournalOperation type,
                                     PhysicalBlockNumber pbn,
                                     BlockMappingState state,
                                     PhysicalZone *zone,
                                     ReferenceOperation *operation) {
  *operation = (ReferenceOperation){
      .type = type,
      .pbn = pbn,
      .state = state,
      .lockGetter = lookUpPBNLock,
      .context = zone,
  };
}"
darktable-org-darktable-32fab21/src/iop/demosaic.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_demosaic_params_t tmp = (dt_iop_demosaic_params_t){
      .green_eq = DT_IOP_GREEN_EQ_NO,
      .median_thrs = 0.0f,
      .color_smoothing = 0,
      .demosaicing_method = DT_IOP_DEMOSAIC_PPG,
      .yet_unused_data_specific_to_demosaicing_method = 0};

  if (!module->dev)
    goto end;

  if (dt_image_is_monochrome(&module->dev->image_storage))
    tmp.demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;

  if (dt_image_is_raw(&module->dev->image_storage))
    module->default_enabled = 1;
  else
    module->default_enabled = 0;

  if (module->dev->image_storage.buf_dsc.filters == 9u)
    tmp.demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;

end:
  memcpy(module->params, &tmp, sizeof(dt_iop_demosaic_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_demosaic_params_t));
}"
legatoproject-legato-af-231fbd8/framework/liblegato/timer.c	Allocate and initialize the named timer with default values.	2	"(
#if LE_CONFIG_TIMER_NAMES_ENABLED
    const char *nameStr
#else
    void
#endif
) {
  Timer_t *timerPtr;

  timerPtr = le_mem_ForceAlloc(TimerMemPoolRef);

#if LE_CONFIG_TIMER_NAMES_ENABLED
  if (le_utf8_Copy(timerPtr->name, nameStr, sizeof(timerPtr->name), NULL) ==
      LE_OVERFLOW) {
    LE_WARN(""Timer name '%s' truncated to '%s'."", nameStr, timerPtr->name);
  }
#endif

  timerPtr->handlerRef = NULL;
  timerPtr->interval = (le_clk_Time_t){0, 0};
  timerPtr->repeatCount = 1;
  timerPtr->contextPtr = NULL;
  timerPtr->link = LE_DLS_LINK_INIT;
  timerPtr->isActive = false;
  timerPtr->expiryTime = (le_clk_Time_t){0, 0};
  timerPtr->expiryCount = 0;
  Lock();
  timerPtr->safeRef = le_ref_CreateRef(SafeRefMap, timerPtr);
  Unlock();
  timerPtr->isWakeupEnabled = true;

  return timerPtr;
}"
rabm2k7-transports-c603a38/node_modules/google-cloud/node_modules/grpc/src/core/ext/filters/client_channel/subchannel.c	create a subchannel given a connector	2	"grpc_subchannel *grpc_subchannel_create(grpc_exec_ctx *exec_ctx,
                                        grpc_connector *connector,
                                        const grpc_subchannel_args *args) {
  grpc_subchannel_key *key = grpc_subchannel_key_create(connector, args);
  grpc_subchannel *c = grpc_subchannel_index_find(exec_ctx, key);
  if (c) {
    grpc_subchannel_key_destroy(exec_ctx, key);
    return c;
  }

  c = gpr_zalloc(sizeof(*c));
  c->key = key;
  gpr_atm_no_barrier_store(&c->ref_pair, 1 << INTERNAL_REF_BITS);
  c->connector = connector;
  grpc_connector_ref(c->connector);
  c->num_filters = args->filter_count;
  if (c->num_filters > 0) {
    c->filters = gpr_malloc(sizeof(grpc_channel_filter *) * c->num_filters);
    memcpy((void *)c->filters, args->filters,
           sizeof(grpc_channel_filter *) * c->num_filters);
  } else {
    c->filters = NULL;
  }
  c->pollset_set = grpc_pollset_set_create();
  grpc_resolved_address *addr = gpr_malloc(sizeof(*addr));
  grpc_get_subchannel_address_arg(exec_ctx, args->args, addr);
  grpc_resolved_address *new_address = NULL;
  grpc_channel_args *new_args = NULL;
  if (grpc_proxy_mappers_map_address(exec_ctx, addr, args->args, &new_address,
                                     &new_args)) {
    GPR_ASSERT(new_address != NULL);
    gpr_free(addr);
    addr = new_address;
  }
  static const char *keys_to_remove[] = {GRPC_ARG_SUBCHANNEL_ADDRESS};
  grpc_arg new_arg = grpc_create_subchannel_address_arg(addr);
  gpr_free(addr);
  c->args = grpc_channel_args_copy_and_add_and_remove(
      new_args != NULL ? new_args : args->args, keys_to_remove,
      GPR_ARRAY_SIZE(keys_to_remove), &new_arg, 1);
  gpr_free(new_arg.value.string);
  if (new_args != NULL)
    grpc_channel_args_destroy(exec_ctx, new_args);
  c->root_external_state_watcher.next = c->root_external_state_watcher.prev =
      &c->root_external_state_watcher;
  grpc_closure_init(&c->connected, subchannel_connected, c,
                    grpc_schedule_on_exec_ctx);
  grpc_connectivity_state_init(&c->state_tracker, GRPC_CHANNEL_IDLE,
                               ""subchannel"");
  int initial_backoff_ms =
      GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS * 1000;
  int min_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MIN_BACKOFF_SECONDS * 1000;
  int max_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS * 1000;
  bool fixed_reconnect_backoff = false;
  if (c->args) {
    for (size_t i = 0; i < c->args->num_args; i++) {
      if (0 == strcmp(c->args->args[i].key,
                      ""grpc.testing.fixed_reconnect_backoff_ms"")) {
        fixed_reconnect_backoff = true;
        initial_backoff_ms = min_backoff_ms = max_backoff_ms =
            grpc_channel_arg_get_integer(
                &c->args->args[i],
                (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MIN_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        min_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){min_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        max_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){max_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        initial_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      }
    }
  }
  gpr_backoff_init(
      &c->backoff_state, initial_backoff_ms,
      fixed_reconnect_backoff ? 1.0
                              : GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER,
      fixed_reconnect_backoff ? 0.0 : GRPC_SUBCHANNEL_RECONNECT_JITTER,
      min_backoff_ms, max_backoff_ms);
  gpr_mu_init(&c->mu);

  return grpc_subchannel_index_register(exec_ctx, key, c);
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	"Given the 3D geometry Jacobian ordering of using the nonconservative metric (NC) for clarity of exposition (section 5.1 Abe2015), the ordering of the metric terms is:"	2	"(const bool recompute_geom_coef, struct Solver_Volume_T *s_vol,
 const struct Simulation *sim) {
  struct Volume *vol = (struct Volume *)s_vol;
  if (recompute_geom_coef) {
    compute_geom_coef_fptr_T compute_geom_coef =
        set_fptr_geom_coef_T(sim->domain_type, vol->curved);
    compute_geom_coef_p1(sim, s_vol);
    compute_geom_coef(sim, s_vol);
  }

  if (1) {
    constructor_volume_metric_terms_T('m', s_vol);
    constructor_volume_metric_terms_T('c', s_vol);
    if (get_set_method(NULL) == METHOD_OPG ||
        get_set_method(NULL) == METHOD_OPGC0)
      constructor_volume_metric_terms_T('s', s_vol);
  } else {
    const char op_format = get_set_op_format(0);

    const struct Geometry_Element *g_e =
        &((struct Solver_Element *)vol->element)->g_e;

    const int d = ((struct const_Element *)g_e)->d;
    assert(d == DIM);

    const struct const_Multiarray_T *const geom_coef = s_vol->geom_coef;

    const int p = s_vol->p_ref;

    const bool curved = vol->curved;
    const int p_g = (curved ? p : 1);

    struct Ops {
      const struct Multiarray_Operator cv1_vg_vm;
      const struct Multiarray_Operator cv1_vg_vc;
      const struct Operator *vv0_vm_vc;
    } ops = {
        .cv1_vg_vm = set_MO_from_MO(g_e->cv1_vg_vm[curved], 1,
                                    (ptrdiff_t[]){0, 0, p_g, p_g}),
        .cv1_vg_vc = set_MO_from_MO(g_e->cv1_vg_vc[curved], 1,
                                    (ptrdiff_t[]){0, 0, p, p_g}),
        .vv0_vm_vc = get_Multiarray_Operator(g_e->vv0_vm_vc[curved],
                                             (ptrdiff_t[]){0, 0, p, p_g}),
    };

    const ptrdiff_t n_vm = ops.cv1_vg_vm.data[0]->op_std->ext_0,
                    n_vc = ops.cv1_vg_vc.data[0]->op_std->ext_0;

    struct Multiarray_T *jacobian_vm = constructor_empty_Multiarray_T(
                            'C', 3, (ptrdiff_t[]){n_vm, d, d}),
                        *jacobian_vc = constructor_empty_Multiarray_T(
                            'C', 3, (ptrdiff_t[]){n_vc, d, d});

    for (ptrdiff_t row = 0; row < d; ++row) {
      mm_NN1C_Operator_Multiarray_T(ops.cv1_vg_vm.data[row], geom_coef,
                                    jacobian_vm, op_format, 2, NULL, &row);
      mm_NN1C_Operator_Multiarray_T(ops.cv1_vg_vc.data[row], geom_coef,
                                    jacobian_vc, op_format, 2, NULL, &row);
    }

    const ptrdiff_t *perm = set_jacobian_permutation(d);
    permute_Multiarray_T(jacobian_vc, perm, jacobian_vc->layout);

    compute_detJV_T((struct const_Multiarray_T *)jacobian_vc,
                    (struct Multiarray_T *)s_vol->jacobian_det_vc);
    compute_cofactors_T((struct const_Multiarray_T *)jacobian_vm,
                        (struct Multiarray_T *)s_vol->metrics_vm);

    destructor_Multiarray_T(jacobian_vm);
    destructor_Multiarray_T(jacobian_vc);

    const struct const_Multiarray_T *met_vm = s_vol->metrics_vm;

    resize_Multiarray_T((struct Multiarray_T *)s_vol->metrics_vc, 3,
                        (ptrdiff_t[]){n_vc, d, d});
    mm_NN1C_Operator_Multiarray_T(ops.vv0_vm_vc, met_vm,
                                  (struct Multiarray_T *)s_vol->metrics_vc,
                                  op_format, met_vm->order, NULL, NULL);
  }
}"
darktable-org-darktable-32fab21/src/iop/exposure.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""magic lantern defaults""), self->op, self->version(),
      &(dt_iop_exposure_params_t){.mode = EXPOSURE_MODE_DEFLICKER,
                                  .black = 0.0f,
                                  .exposure = 0.0f,
                                  .deflicker_percentile = 50.0f,
                                  .deflicker_target_level = -4.0f},
      sizeof(dt_iop_exposure_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavfilter/src_movie.c	Try to push a frame to the requested output.	2	"static int movie_push_frame(AVFilterContext *ctx, unsigned out_id) {
  MovieContext *movie = ctx->priv;
  AVPacket *pkt = &movie->pkt;
  enum AVMediaType frame_type;
  MovieStream *st;
  int ret, got_frame = 0, pkt_out_id;
  AVFilterLink *outlink;
  AVFrame *frame;

  if (!pkt->size) {
    if (movie->eof) {
      if (movie->st[out_id].done) {
        if (movie->loop_count != 1) {
          ret = rewind_file(ctx);
          if (ret < 0)
            return ret;
          movie->loop_count -= movie->loop_count > 1;
          av_log(ctx, AV_LOG_VERBOSE, ""Stream finished, looping.\n"");
          return 0;
        }
        return AVERROR_EOF;
      }
      pkt->stream_index = movie->st[out_id].st->index;

    } else {
      ret = av_read_frame(movie->format_ctx, &movie->pkt0);
      if (ret < 0) {
        av_init_packet(&movie->pkt0);
        *pkt = movie->pkt0;
        if (ret == AVERROR_EOF) {
          movie->eof = 1;
          return 0;
        }
        return ret;
      }
      *pkt = movie->pkt0;
    }
  }

  pkt_out_id = pkt->stream_index > movie->max_stream_index
                   ? -1
                   : movie->out_index[pkt->stream_index];
  if (pkt_out_id < 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
    return 0;
  }
  st = &movie->st[pkt_out_id];
  outlink = ctx->outputs[pkt_out_id];

  frame = av_frame_alloc();
  if (!frame)
    return AVERROR(ENOMEM);

  frame_type = st->st->codecpar->codec_type;
  switch (frame_type) {
  case AVMEDIA_TYPE_VIDEO:
    ret = avcodec_decode_video2(st->codec_ctx, frame, &got_frame, pkt);
    break;
  case AVMEDIA_TYPE_AUDIO:
    ret = avcodec_decode_audio4(st->codec_ctx, frame, &got_frame, pkt);
    break;
  default:
    ret = AVERROR(ENOSYS);
    break;
  }
  if (ret < 0) {
    av_log(ctx, AV_LOG_WARNING, ""Decode error: %s\n"", av_err2str(ret));
    av_frame_free(&frame);
    av_packet_unref(&movie->pkt0);
    movie->pkt.size = 0;
    movie->pkt.data = NULL;
    return 0;
  }
  if (!ret || st->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
    ret = pkt->size;

  pkt->data += ret;
  pkt->size -= ret;
  if (pkt->size <= 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
  }
  if (!got_frame) {
    if (!ret)
      st->done = 1;
    av_frame_free(&frame);
    return 0;
  }

  frame->pts = av_frame_get_best_effort_timestamp(frame);
  if (frame->pts != AV_NOPTS_VALUE) {
    if (movie->ts_offset)
      frame->pts += av_rescale_q_rnd(movie->ts_offset, AV_TIME_BASE_Q,
                                     outlink->time_base, AV_ROUND_UP);
    if (st->discontinuity_threshold) {
      if (st->last_pts != AV_NOPTS_VALUE) {
        int64_t diff = frame->pts - st->last_pts;
        if (diff < 0 || diff > st->discontinuity_threshold) {
          av_log(ctx, AV_LOG_VERBOSE,
                 ""Discontinuity in stream:%d diff:%"" PRId64 ""\n"", pkt_out_id,
                 diff);
          movie->ts_offset += av_rescale_q_rnd(-diff, outlink->time_base,
                                               AV_TIME_BASE_Q, AV_ROUND_UP);
          frame->pts -= diff;
        }
      }
    }
    st->last_pts = frame->pts;
  }
  ff_dlog(
      ctx, ""movie_push_frame(): file:'%s' %s\n"", movie->file_name,
      describe_frame_to_str((char[1024]){0}, 1024, frame, frame_type, outlink));

  if (st->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
    if (frame->format != outlink->format) {
      av_log(ctx, AV_LOG_ERROR, ""Format changed %s -> %s, discarding frame\n"",
             av_get_pix_fmt_name(outlink->format),
             av_get_pix_fmt_name(frame->format));
      av_frame_free(&frame);
      return 0;
    }
  }
  ret = ff_filter_frame(outlink, frame);

  if (ret < 0)
    return ret;
  return pkt_out_id == out_id;
}"
Valloric-ycmd-60f51f8/third_party/clang/lib/clang/7.0.0/include/emmintrin.h	Loads a 64-bit integer value to the low element of a 128-bit integer vector and clears the upper element.	2	"_mm_loadu_si64(void const *__a) {
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((struct __loadu_si64 *)__a)->__v;
  return __extension__(__m128i)(__v2di){__u, 0L};
}"
ethereum-mining-ethminer-bf57b70/libdevcore/Log.h	A simple log-output function that prints log messages to stdout.	2	"{public :

     LogOutputStream() : LogOutputStreamBase(Id::name()){}

 ~LogOutputStream(){simpleDebugOut(m_sstr.str());
}

template <class T> LogOutputStream &operator<<(T const &_t) {
  append(_t);
  return *this;
}
}
;

#define clog(X) dev::LogOutputStream<X>()

#define cnote clog(dev::NoteChannel)
#define cwarn clog(dev::WarnChannel)
}"
ceph-samba-9f7ed6b/source3/lib/gencache.c	"Set an entry in the cache file. If there's no such one, then add it."	2	"bool gencache_set_data_blob(const char *keystr, const DATA_BLOB *blob,
                            time_t timeout) {
  int ret;
  fstring hdr;
  int hdr_len;
  time_t last_stabilize;
  static int writecount;
  TDB_DATA dbufs[2];

  if (tdb_data_cmp(string_term_tdb_data(keystr), last_stabilize_key()) == 0) {
    DEBUG(10, (""Can't store %s as a key\n"", keystr));
    return false;
  }

  if ((keystr == NULL) || (blob == NULL)) {
    return false;
  }

  if (!gencache_init()) {
    return false;
  }

  if ((timeout != 0) && gencache_have_val(keystr, blob, timeout)) {
    DEBUG(10, (""Did not store value for %s, we already got it\n"", keystr));
    return true;
  }

  hdr_len = fstr_sprintf(hdr, CACHE_DATA_FMT, (int)timeout);

  if (hdr_len == -1) {
    return false;
  }
  if ((blob->length + (size_t)hdr_len) < blob->length) {
    return false;
  }

  dbufs[0] = (TDB_DATA){.dptr = (uint8_t *)hdr, .dsize = hdr_len};
  dbufs[1] = (TDB_DATA){.dptr = blob->data, .dsize = blob->length};

  DEBUG(10,
        (""Adding cache entry with key=[%s] and timeout=""
         ""[%s] (%d seconds %s)\n"",
         keystr, timestring(talloc_tos(), timeout), (int)(timeout - time(NULL)),
         timeout > time(NULL) ? ""ahead"" : ""in the past""));

  ret =
      tdb_storev(cache_notrans->tdb, string_term_tdb_data(keystr), dbufs, 2, 0);
  if (ret != 0) {
    return false;
  }

  writecount += 1;
  if (writecount > lp_parm_int(-1, ""gencache"", ""stabilize_count"", 100)) {
    gencache_stabilize();
    writecount = 0;
    goto done;
  }

  last_stabilize = 0;

  tdb_parse_record(cache_notrans->tdb, last_stabilize_key(),
                   last_stabilize_parser, &last_stabilize);

  if ((last_stabilize +
       lp_parm_int(-1, ""gencache"", ""stabilize_interval"", 300)) < time(NULL)) {
    gencache_stabilize();
  }

done:
  return ret == 0;
}"
r1emu-R1EMU-b5ccca1/src/barrack_server/barrack_handler/barrack_handler.c	Request for the player to enter in game	2	"static PacketHandlerState
barrackHandlerStartGame(Worker *self, Session *session, uint8_t *packet,
                        size_t packetSize, zmsg_t *reply) {
  PacketHandlerState status = PACKET_HANDLER_ERROR;

#pragma pack(push, 1)
  struct {
    RouterId_t routerId;
    uint8_t commanderIndex;
  } *clientPacket = (void *)packet;
#pragma pack(pop)

  CHECK_CLIENT_PACKET_SIZE(*clientPacket, packetSize, CB_START_GAME);

  if (!session->game.accountSession
           .commanders[clientPacket->commanderIndex - 1]) {
    error(""Selected commander index doesnt exist in account"");
    return PACKET_HANDLER_ERROR;
  }

  uint32_t zoneServerIps[] = {
      *(uint32_t *)((char[]){127, 0, 0, 1}),
      *(uint32_t *)((char[]){46, 105, 97, 46}),
      *(uint32_t *)((char[]){192, 168, 33, 10}),
      *(uint32_t *)((char[]){37, 187, 102, 130}),
  };
  int maxServerCount = sizeof_array(zoneServerIps);
  if (clientPacket->routerId >= maxServerCount) {
    error(""Invalid RouterId."");
    goto cleanup;
  }

  int zoneServerPorts[] = {2004, 2005, 2006, 2007};

  uint32_t zoneServerIp = zoneServerIps[clientPacket->routerId];
  int zoneServerPort = zoneServerPorts[clientPacket->routerId];

  size_t commanderIndex = clientPacket->commanderIndex - 1;

  Session tmpSession = *session;
  CommanderSession *tmpCommanderSession = &tmpSession.game.commanderSession;
  AccountSession *tmpAccountSession = &tmpSession.game.accountSession;
  tmpCommanderSession->currentCommander =
      tmpAccountSession->commanders[commanderIndex];

  if (!(redisUpdateSession(self->redis, &tmpSession))) {
    error(""Cannot update the Redis session."");
    goto cleanup;
  }

  dbg(""routerId %x"", tmpSession.socket.routerId);
  dbg(""mapId %x"", tmpSession.socket.mapId);
  dbg(""accountId %llx"", tmpSession.socket.accountId);
  dbg(""S PcId %x"", tmpCommanderSession->currentCommander->pcId);
  dbg(""S socialInfoId %llx"",
      tmpCommanderSession->currentCommander->socialInfoId);
  dbg(""S commanderId %llx"", tmpCommanderSession->currentCommander->commanderId);

  RedisGameSessionKey fromKey = {.routerId = tmpSession.socket.routerId,
                                 .mapId = tmpSession.socket.mapId,
                                 .accountId = tmpSession.socket.accountId};
  RedisGameSessionKey toKey = {.routerId = clientPacket->routerId,
                               .mapId = -1,
                               .accountId = tmpSession.socket.accountId};
  if (!(redisMoveGameSession(self->redis, &fromKey, &toKey))) {
    error(""Cannot move the Game session %s."", tmpSession.socket.sessionKey);
    goto cleanup;
  }

  session->game.commanderSession.currentCommander =
      tmpAccountSession->commanders[commanderIndex];

  barrackBuilderStartGameOk(
      self->info.routerId, zoneServerIp, zoneServerPort,
      session->game.commanderSession.currentCommander->mapId,
      clientPacket->commanderIndex,
      session->game.commanderSession.currentCommander->socialInfoId, false,
      reply);

  status = PACKET_HANDLER_UPDATE_SESSION;

cleanup:
  return status;
}"
samba-team-samba-b2c2c4c/source3/lib/gencache.c	"Set an entry in the cache file. If there's no such one, then add it."	2	"bool gencache_set_data_blob(const char *keystr, DATA_BLOB blob,
                            time_t timeout) {
  TDB_DATA key;
  int ret;
  TDB_DATA dbufs[3];
  uint32_t crc;

  if ((keystr == NULL) || (blob.data == NULL)) {
    return false;
  }

  key = string_term_tdb_data(keystr);

  if (!gencache_init()) {
    return false;
  }

  dbufs[0] = (TDB_DATA){.dptr = (uint8_t *)&timeout, .dsize = sizeof(time_t)};
  dbufs[1] = (TDB_DATA){.dptr = blob.data, .dsize = blob.length};

  crc = crc32(0, Z_NULL, 0);
  crc = crc32(crc, key.dptr, key.dsize);
  crc = crc32(crc, dbufs[0].dptr, dbufs[0].dsize);
  crc = crc32(crc, dbufs[1].dptr, dbufs[1].dsize);

  dbufs[2] = (TDB_DATA){.dptr = (uint8_t *)&crc, .dsize = sizeof(crc)};

  DBG_DEBUG(""Adding cache entry with key=[%s] and timeout=""
            ""[%s] (%ld seconds %s)\n"",
            keystr, timestring(talloc_tos(), timeout),
            ((long int)timeout) - time(NULL),
            timeout > time(NULL) ? ""ahead"" : ""in the past"");

  ret = tdb_chainlock(cache->tdb, key);
  if (ret == -1) {
    DBG_WARNING(""tdb_chainlock for key [%s] failed: %s\n"", keystr,
                tdb_errorstr(cache->tdb));
    return false;
  }

  gencache_prune_expired(cache->tdb, key);

  ret = tdb_storev(cache->tdb, key, dbufs, ARRAY_SIZE(dbufs), 0);

  tdb_chainunlock(cache->tdb, key);

  if (ret == 0) {
    return true;
  }
  if (tdb_error(cache->tdb) != TDB_ERR_CORRUPT) {
    return false;
  }

  ret = tdb_wipe_all(cache->tdb);
  SMB_ASSERT(ret == 0);

  return false;
}"
CoolProp-CoolProp-3748093/include/IncompressibleFluid.h	"Thermal conductivity as a function of temperature, pressure and composition."	2	"Polynomial2DFrac poly;

public:
IncompressibleFluid()
    : Tmin(_HUGE), Tmax(_HUGE), xmin(_HUGE), xmax(_HUGE), TminPsat(_HUGE),
      xbase(_HUGE), Tbase(_HUGE) {
  strict = true;
  xid = IFRAC_UNDEFINED;
};
virtual ~IncompressibleFluid(){};

std::string getName() const { return name; }
std::string get_name() const { return getName(); }
std::string getDescription() const { return description; }
std::string getReference() const { return reference; }

double getTmax() const { return Tmax; }
double getTmin() const { return Tmin; }"
dm-vdo-kvdo-8df6805/vdo/base/recoveryJournalEntry.h	Unpack the on-disk representation of a recovery journal entry.	2	"unpackRecoveryJournalEntry(const PackedRecoveryJournalEntry *entry) {
  PhysicalBlockNumber low32 = getUInt32LE(entry->fields.pbnLowWord);
  PhysicalBlockNumber high4 = entry->fields.pbnHighNibble;
  return (RecoveryJournalEntry){
      .operation = entry->fields.operation,
      .slot =
          {
              .pbn = ((high4 << 32) | low32),
              .slot = (entry->fields.slotLow | (entry->fields.slotHigh << 6)),
          },
      .mapping = unpackBlockMapEntry(&entry->fields.blockMapEntry),
  };
}"
AVSystem-Anjay-09239b2/src/downloader/downloader.c	Initializes a downloader object.	2	"int _anjay_downloader_init(anjay_downloader_t *dl, anjay_t *anjay,
                           coap_id_source_t **id_source_move) {
  assert(anjay);
  assert(_anjay_downloader_get_anjay(dl) == anjay);
  assert(_anjay_downloader_get_anjay(dl)->sched);
  assert(_anjay_downloader_get_anjay(dl)->coap_ctx);

  if (!anjay || anjay != _anjay_downloader_get_anjay(dl) || !anjay->sched ||
      !anjay->coap_ctx) {
    dl_log(ERROR, ""invalid anjay pointer passed"");
    return -1;
  }

  *dl = (anjay_downloader_t){
      .id_source = *id_source_move,
      .next_id = 1,
      .downloads = NULL,
  };

  *id_source_move = NULL;
  return 0;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/PrinterHost/Lib/PrinterCommands.c	"Issues a Printer class Get Port Status command to the attached device, to retrieve the current status flags of the printer."	1	"uint8_t Printer_GetPortStatus(uint8_t *const PortStatus) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetPortStatus,
      .wValue = 0,
      .wIndex = PrinterInterfaceNumber,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(PortStatus);
}"
darktable-org-darktable-32fab21/src/iop/tonemap.cc	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_tonemapping_params_t tmp = (dt_iop_tonemapping_params_t){2.5, 30};
  memcpy(module->params, &tmp, sizeof(dt_iop_tonemapping_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_tonemapping_params_t));
}"
opticron-libuweave-2e5e385/src/channel.c	Creates a channel with the specified read buffer and handlers. The message_config handler is invoked when a packet completes re-assembly in the message_in_buffer.	2	"void uw_channel_init_(UwChannel *channel, UwChannelMessageConfig message_config,
                      UwBuffer *message_in_buffer, UwBuffer *message_out_buffer,
                      size_t max_packet_size) {
  *channel = (UwChannel){.message_config = message_config,
                         .max_packet_size = max_packet_size,
                         .packet_in_counter = 0,
                         .packet_out_counter = 0};

  uw_message_in_init_(&channel->message_in, message_in_buffer);
  uw_message_out_init_(&channel->message_out, message_out_buffer);
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavcodec/utils.c	Get a buffer for a frame. This is a wrapper around AVCodecContext.get_buffer() and should be used instead calling get_buffer() directly.	2	"int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) {
  const AVHWAccel *hwaccel = avctx->hwaccel;
  int override_dimensions = 1;
  int ret;

  switch (avctx->codec_type) {
  case AVMEDIA_TYPE_VIDEO:
    if (frame->width <= 0 || frame->height <= 0) {
      frame->width = FFMAX(avctx->width, avctx->coded_width);
      frame->height = FFMAX(avctx->height, avctx->coded_height);
      override_dimensions = 0;
    }
    if (frame->format < 0)
      frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    if ((ret = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)
      return ret;
    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }

        frame->channel_layout = av_get_default_channel_layout(avctx->channels);
        if (!frame->channel_layout)
          frame->channel_layout = (1ULL << avctx->channels) - 1;
      }
    }
    break;
  default:
    return AVERROR(EINVAL);
  }

  ret = ff_decode_frame_props(avctx, frame);
  if (ret < 0)
    return ret;

  if (hwaccel) {
    if (hwaccel->alloc_frame) {
      ret = hwaccel->alloc_frame(avctx, frame);
      goto end;
    }
  } else
    avctx->sw_pix_fmt = avctx->pix_fmt;

  ret = avctx->get_buffer2(avctx, frame, flags);

end:
  if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && !override_dimensions) {
    frame->width = avctx->width;
    frame->height = avctx->height;
  }

  return ret;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/ConfigDescriptors.c	"Retrieves the configuration descriptor data from an attached device via a standard request into a buffer, including validity and size checking to prevent a buffer overflow."	0	"uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t *const ConfigSizePtr,
                                           void *const BufferPtr,
                                           const uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Configuration_Header_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  *ConfigSizePtr = le16_to_cpu(
      DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
          ->TotalConfigurationSize);

  if (*ConfigSizePtr > BufferSize)
    return HOST_GETCONFIG_BuffOverflow;

  USB_ControlRequest.wLength = *ConfigSizePtr;

  if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    return HOST_GETCONFIG_InvalidData;

  return HOST_GETCONFIG_Successful;
}"
ros2-rcutils-fe82622/src/error_handling.c	"This function is ""safe"" because it returns a copy of the current error string or one containing the string ""error not set"" if no error was set. This ensures that the copy is owned by the calling thread and is therefore never invalidated by other error handling calls, and that the C string inside is always valid and null terminated."	4	"rcutils_get_error_string(void) {
  if (!gtls_rcutils_error_is_set) {
    return (rcutils_error_string_t){""error not set""};
  }
  if (!gtls_rcutils_error_string_is_formatted) {
    __rcutils_format_error_string(&gtls_rcutils_error_string,
                                  &gtls_rcutils_error_state);
    gtls_rcutils_error_string_is_formatted = true;
  }
  return gtls_rcutils_error_string;
}"
Deadlocked007-EventUp-a067de4/Pods/gRPC-Core/src/core/ext/filters/client_channel/subchannel.c	create a subchannel given a connector	2	"grpc_subchannel *grpc_subchannel_create(grpc_exec_ctx *exec_ctx,
                                        grpc_connector *connector,
                                        const grpc_subchannel_args *args) {
  grpc_subchannel_key *key = grpc_subchannel_key_create(args);
  grpc_subchannel *c = grpc_subchannel_index_find(exec_ctx, key);
  if (c) {
    grpc_subchannel_key_destroy(exec_ctx, key);
    return c;
  }

  GRPC_STATS_INC_CLIENT_SUBCHANNELS_CREATED(exec_ctx);
  c = (grpc_subchannel *)gpr_zalloc(sizeof(*c));
  c->key = key;
  gpr_atm_no_barrier_store(&c->ref_pair, 1 << INTERNAL_REF_BITS);
  c->connector = connector;
  grpc_connector_ref(c->connector);
  c->num_filters = args->filter_count;
  if (c->num_filters > 0) {
    c->filters = (const grpc_channel_filter **)gpr_malloc(
        sizeof(grpc_channel_filter *) * c->num_filters);
    memcpy((void *)c->filters, args->filters,
           sizeof(grpc_channel_filter *) * c->num_filters);
  } else {
    c->filters = NULL;
  }
  c->pollset_set = grpc_pollset_set_create();
  grpc_resolved_address *addr =
      (grpc_resolved_address *)gpr_malloc(sizeof(*addr));
  grpc_get_subchannel_address_arg(exec_ctx, args->args, addr);
  grpc_resolved_address *new_address = NULL;
  grpc_channel_args *new_args = NULL;
  if (grpc_proxy_mappers_map_address(exec_ctx, addr, args->args, &new_address,
                                     &new_args)) {
    GPR_ASSERT(new_address != NULL);
    gpr_free(addr);
    addr = new_address;
  }
  static const char *keys_to_remove[] = {GRPC_ARG_SUBCHANNEL_ADDRESS};
  grpc_arg new_arg = grpc_create_subchannel_address_arg(addr);
  gpr_free(addr);
  c->args = grpc_channel_args_copy_and_add_and_remove(
      new_args != NULL ? new_args : args->args, keys_to_remove,
      GPR_ARRAY_SIZE(keys_to_remove), &new_arg, 1);
  gpr_free(new_arg.value.string);
  if (new_args != NULL)
    grpc_channel_args_destroy(exec_ctx, new_args);
  c->root_external_state_watcher.next = c->root_external_state_watcher.prev =
      &c->root_external_state_watcher;
  GRPC_CLOSURE_INIT(&c->connected, subchannel_connected, c,
                    grpc_schedule_on_exec_ctx);
  grpc_connectivity_state_init(&c->state_tracker, GRPC_CHANNEL_IDLE,
                               ""subchannel"");
  int initial_backoff_ms =
      GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS * 1000;
  int min_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MIN_BACKOFF_SECONDS * 1000;
  int max_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS * 1000;
  bool fixed_reconnect_backoff = false;
  if (c->args) {
    for (size_t i = 0; i < c->args->num_args; i++) {
      if (0 == strcmp(c->args->args[i].key,
                      ""grpc.testing.fixed_reconnect_backoff_ms"")) {
        fixed_reconnect_backoff = true;
        initial_backoff_ms = min_backoff_ms = max_backoff_ms =
            grpc_channel_arg_get_integer(
                &c->args->args[i],
                (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MIN_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        min_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){min_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        max_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){max_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        initial_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      }
    }
  }
  gpr_backoff_init(
      &c->backoff_state, initial_backoff_ms,
      fixed_reconnect_backoff ? 1.0
                              : GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER,
      fixed_reconnect_backoff ? 0.0 : GRPC_SUBCHANNEL_RECONNECT_JITTER,
      min_backoff_ms, max_backoff_ms);
  gpr_mu_init(&c->mu);

  return grpc_subchannel_index_register(exec_ctx, key, c);
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Host/Incomplete/BluetoothHost/Lib/BluetoothHCICommands.c	Bluetooth HCI processing task. This task should be called repeatedly the main Bluetooth stack task to manage the HCI processing state.	0	"void Bluetooth_HCITask(void) {
  BT_HCICommand_Header_t HCICommandHeader;

  switch (Bluetooth_State.CurrentHCIState) {
  case Bluetooth_ProcessEvents:
    Pipe_SelectPipe(BLUETOOTH_EVENTS_PIPE);
    Pipe_Unfreeze();

    if (Pipe_IsReadWriteAllowed()) {
      BT_HCIEvent_Header_t HCIEventHeader;

      Pipe_Read_Stream_LE(&HCIEventHeader, sizeof(HCIEventHeader), NULL);

      uint8_t EventParams[HCIEventHeader.ParameterLength];

      Pipe_Read_Stream_LE(&EventParams, HCIEventHeader.ParameterLength, NULL);
      Pipe_ClearIN();

      BT_HCI_DEBUG(1, ""Event Received (0x%02X)"", HCIEventHeader.EventCode);

      switch (HCIEventHeader.EventCode) {
      case EVENT_COMMAND_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Command Complete"");

        switch (((BT_HCIEvent_CommandComplete_t *)&EventParams)->Opcode) {
        case (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBDADDR):

          memcpy(
              Bluetooth_State.LocalBDADDR,
              &((BT_HCIEvent_CommandComplete_t *)&EventParams)->ReturnParams[1],
              sizeof(Bluetooth_State.LocalBDADDR));
          break;
        }

        Bluetooth_State.CurrentHCIState = Bluetooth_State.NextHCIState;
        break;
      case EVENT_COMMAND_STATUS:
        BT_HCI_DEBUG(1, ""<< Command Status"");
        BT_HCI_DEBUG(2, ""-- Status Code: 0x%02X"",
                     (((BT_HCIEvent_CommandStatus_t *)&EventParams)->Status));

        if (((BT_HCIEvent_CommandStatus_t *)&EventParams)->Status)
          Bluetooth_State.CurrentHCIState = Bluetooth_Init;
        break;
      case EVENT_CONNECTION_REQUEST:
        BT_HCI_DEBUG(1, ""<< Connection Request"");
        BT_HCI_DEBUG(
            2, ""-- Link Type: 0x%02X"",
            (((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->LinkType));

        memcpy(
            Bluetooth_TempDeviceAddress,
            &((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->RemoteAddress,
            sizeof(Bluetooth_TempDeviceAddress));

        bool IsACLConnection =
            (((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->LinkType ==
             0x01);

        Bluetooth_State.CurrentHCIState =
            (Bluetooth_Connection.IsConnected || !(IsACLConnection) ||
             !(Bluetooth_ConnectionRequest(Bluetooth_TempDeviceAddress)))
                ? Bluetooth_Conn_RejectConnection
                : Bluetooth_Conn_AcceptConnection;

        BT_HCI_DEBUG(
            2, ""-- Connection %S"",
            (Bluetooth_State.CurrentHCIState == Bluetooth_Conn_RejectConnection)
                ? PSTR(""REJECTED"")
                : PSTR(""ACCEPTED""));

        break;
      case EVENT_PIN_CODE_REQUEST:
        BT_HCI_DEBUG(1, ""<< Pin Code Request"");

        memcpy(Bluetooth_TempDeviceAddress,
               &((BT_HCIEvent_PinCodeReq_t *)&EventParams)->RemoteAddress,
               sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_State.CurrentHCIState = Bluetooth_Conn_SendPINCode;
        break;
      case EVENT_LINK_KEY_REQUEST:
        BT_HCI_DEBUG(1, ""<< Link Key Request"");

        memcpy(Bluetooth_TempDeviceAddress,
               &((BT_HCIEvent_LinkKeyReq_t *)&EventParams)->RemoteAddress,
               sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_State.CurrentHCIState = Bluetooth_Conn_SendLinkKeyNAK;
        break;
      case EVENT_CONNECTION_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Connection Complete"");
        BT_HCI_DEBUG(2, ""-- Handle: 0x%04X"",
                     ((BT_HCIEvent_ConnectionComplete_t *)&EventParams)
                         ->ConnectionHandle);

        memcpy(
            Bluetooth_Connection.RemoteAddress,
            &((BT_HCIEvent_ConnectionComplete_t *)&EventParams)->RemoteAddress,
            sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_Connection.ConnectionHandle =
            ((BT_HCIEvent_ConnectionComplete_t *)&EventParams)
                ->ConnectionHandle;
        Bluetooth_Connection.IsConnected = true;

        Bluetooth_ConnectionComplete();
        break;
      case EVENT_DISCONNECTION_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Disconnection Complete"");

        Bluetooth_Connection.IsConnected = false;

        Bluetooth_DisconnectionComplete();
        break;
      }
    }

    Pipe_Freeze();

    break;
  case Bluetooth_Init:
    BT_HCI_DEBUG(1, ""# Init"");

    Bluetooth_State.IsInitialized = false;

    memset(&Bluetooth_Connection, 0x00, sizeof(Bluetooth_Connection));

    Bluetooth_State.CurrentHCIState = Bluetooth_Init_Reset;
    break;
  case Bluetooth_Init_Reset:
    BT_HCI_DEBUG(1, ""# Reset"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_RESET),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_ReadBufferSize;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_ReadBufferSize:
    BT_HCI_DEBUG(1, ""# Read Buffer Size"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode :
          (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBUFFERSIZE),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_GetBDADDR;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_GetBDADDR:
    BT_HCI_DEBUG(1, ""# Get BDADDR"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBDADDR),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_SetLocalName;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_SetLocalName:
    BT_HCI_DEBUG(1, ""# Set Local Name"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_LOCAL_NAME),
      ParameterLength : 248,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader,
                             Bluetooth_DeviceConfiguration.Name,
                             strlen(Bluetooth_DeviceConfiguration.Name));

    Bluetooth_State.NextHCIState = Bluetooth_Init_SetDeviceClass;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_SetDeviceClass:
    BT_HCI_DEBUG(1, ""# Set Device Class"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_CLASS_OF_DEVICE),
      ParameterLength : 3,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader,
                             &Bluetooth_DeviceConfiguration.Class, 3);

    Bluetooth_State.NextHCIState = Bluetooth_Init_WriteScanEnable;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_WriteScanEnable:
    BT_HCI_DEBUG(1, ""# Write Scan Enable"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_SCAN_ENABLE),
      ParameterLength : 1,
    };

    uint8_t Interval = BT_SCANMODE_InquiryAndPageScans;

    Bluetooth_SendHCICommand(&HCICommandHeader, &Interval, 1);

    Bluetooth_State.NextHCIState = Bluetooth_Init_FinalizeInit;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_FinalizeInit:
    Bluetooth_State.IsInitialized = true;

    Bluetooth_StackInitialized();

    Bluetooth_State.NextHCIState = Bluetooth_ProcessEvents;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_AcceptConnection:
    BT_HCI_DEBUG(1, ""# Accept Connection"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_ACCEPT_CONNECTION_REQUEST),
      ParameterLength : sizeof(BT_HCICommand_AcceptConnectionReq_t),
    };

    BT_HCICommand_AcceptConnectionReq_t AcceptConnectionParams;
    memcpy(AcceptConnectionParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(AcceptConnectionParams.RemoteAddress));
    AcceptConnectionParams.SlaveRole = true;

    Bluetooth_SendHCICommand(&HCICommandHeader, &AcceptConnectionParams,
                             sizeof(BT_HCICommand_AcceptConnectionReq_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_RejectConnection:
    BT_HCI_DEBUG(1, ""# Reject Connection"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_REJECT_CONNECTION_REQUEST),
      ParameterLength : sizeof(BT_HCICommand_RejectConnectionReq_t),
    };

    BT_HCICommand_RejectConnectionReq_t RejectConnectionParams;
    memcpy(RejectConnectionParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(RejectConnectionParams.RemoteAddress));
    RejectConnectionParams.Reason = Bluetooth_Connection.IsConnected
                                        ? ERROR_LIMITED_RESOURCES
                                        : ERROR_UNACCEPTABLE_BDADDR;

    Bluetooth_SendHCICommand(&HCICommandHeader, &RejectConnectionParams,
                             sizeof(BT_HCICommand_RejectConnectionReq_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_SendPINCode:
    BT_HCI_DEBUG(1, ""# Send Pin Code"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_PIN_CODE_REQUEST_REPLY),
      ParameterLength : sizeof(BT_HCICommand_PinCodeResp_t),
    };

    BT_HCICommand_PinCodeResp_t PINCodeRequestParams;
    memcpy(PINCodeRequestParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(PINCodeRequestParams.RemoteAddress));
    PINCodeRequestParams.PINCodeLength =
        strlen(Bluetooth_DeviceConfiguration.PINCode);
    memcpy(PINCodeRequestParams.PINCode, Bluetooth_DeviceConfiguration.PINCode,
           sizeof(PINCodeRequestParams.PINCode));

    Bluetooth_SendHCICommand(&HCICommandHeader, &PINCodeRequestParams,
                             sizeof(BT_HCICommand_PinCodeResp_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_SendLinkKeyNAK:
    BT_HCI_DEBUG(1, ""# Send Link Key NAK"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_LINK_KEY_REQUEST_NEG_REPLY),
      ParameterLength : sizeof(BT_HCICommand_LinkKeyNAKResp_t),
    };

    BT_HCICommand_LinkKeyNAKResp_t LinkKeyNAKParams;
    memcpy(LinkKeyNAKParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(LinkKeyNAKParams.RemoteAddress));

    Bluetooth_SendHCICommand(&HCICommandHeader, &LinkKeyNAKParams,
                             sizeof(BT_HCICommand_LinkKeyNAKResp_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/PrinterHost/Lib/PrinterCommands.c	"Issues a Printer class Get Device ID command to the attached device, to retrieve the device ID string (which indicates the accepted printer languages, the printer's model and other pertinent information)."	1	"uint8_t Printer_GetDeviceID(char *DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PrinterInterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = SwapEndian_16(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavcodec/audio_frame_queue.c	Add a frame to the queue.	2	"int ff_af_queue_add(AudioFrameQueue *afq, const AVFrame *f) {
  AudioFrame *new_frame;
  AudioFrame *queue_end = afq->frame_queue;

  while (queue_end && queue_end->next)
    queue_end = queue_end->next;

  if (!(new_frame = av_malloc(sizeof(*new_frame))))
    return AVERROR(ENOMEM);

  new_frame->next = NULL;
  new_frame->duration = f->nb_samples;
  if (f->pts != AV_NOPTS_VALUE) {
    new_frame->pts = av_rescale_q(f->pts, afq->avctx->time_base,
                                  (AVRational){1, afq->avctx->sample_rate});
    afq->next_pts = new_frame->pts + new_frame->duration;
  } else {
    new_frame->pts = AV_NOPTS_VALUE;
    afq->next_pts = AV_NOPTS_VALUE;
  }

  if (!queue_end)
    afq->frame_queue = new_frame;
  else
    queue_end->next = new_frame;

  afq->remaining_samples += f->nb_samples;

#ifdef DEBUG
  ff_af_queue_log_state(afq);
#endif

  return 0;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Sends a MASS STORAGE RESET control request to the attached device, resetting the Mass Storage Interface and readying it for the next Mass Storage command. This should be called after a failed SCSI request to ensure the attached Mass Storage device is ready to receive the next command."	1	"uint8_t
MS_Host_ResetMSInterface(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MSInterfaceInfo->Config.DataINPipe.Address);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  Pipe_SelectPipe(MSInterfaceInfo->Config.DataOUTPipe.Address);

  if ((ErrorCode = USB_Host_ClearEndpointStall(
           Pipe_GetBoundEndpointAddress())) != HOST_SENDCONTROL_Successful)
    return ErrorCode;

  return HOST_SENDCONTROL_Successful;
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/core/config.c	registers a host context	2	"h2o_hostconf_t *h2o_config_register_host(h2o_globalconf_t *config,
                                         h2o_iovec_t host, uint16_t port) {
  h2o_hostconf_t *hostconf = NULL;
  h2o_iovec_t host_lc;

  assert(host.len != 0);

  host_lc = h2o_strdup(NULL, host.base, host.len);
  h2o_strtolower(host_lc.base, host_lc.len);

  {
    h2o_hostconf_t **p;
    for (p = config->hosts; *p != NULL; ++p)
      if (h2o_memis((*p)->authority.host.base, (*p)->authority.host.len,
                    host_lc.base, host_lc.len) &&
          (*p)->authority.port == port)
        goto Exit;
  }

  hostconf = create_hostconf(config);
  hostconf->authority.host = host_lc;
  host_lc = (h2o_iovec_t){NULL};
  hostconf->authority.port = port;
  if (hostconf->authority.port == 65535) {
    hostconf->authority.hostport = hostconf->authority.host;
  } else {
    hostconf->authority.hostport.base = h2o_mem_alloc(
        hostconf->authority.host.len + sizeof(""[]:"" H2O_UINT16_LONGEST_STR));
    if (strchr(hostconf->authority.host.base, ':') != NULL) {
      hostconf->authority.hostport.len =
          sprintf(hostconf->authority.hostport.base, ""[%s]:%"" PRIu16,
                  hostconf->authority.host.base, port);
    } else {
      hostconf->authority.hostport.len =
          sprintf(hostconf->authority.hostport.base, ""%s:%"" PRIu16,
                  hostconf->authority.host.base, port);
    }
  }

  h2o_append_to_null_terminated_list((void *)&config->hosts, hostconf);

Exit:
  free(host_lc.base);
  return hostconf;
}"
Metaswitch-clearwater-monit-043c17f/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVhB"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""id"", no_argument, NULL, 'i'},
                              {""help"", no_argument, NULL, 'h'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""batch"", no_argument, NULL, 'B'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""version"", no_argument, NULL, 'V'},
                              {0}};

  Run.flags |= Run_Batch;

  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.files.control = Str_dup(f);
      break;
    }
    case 'd': {
      Run.flags |= Run_Daemon;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.files.log = Str_dup(optarg);
      if (IS(Run.files.log, ""syslog""))
        Run.flags |= Run_UseSyslog;
      Run.flags |= Run_Log;
      break;
    }
    case 'p': {
      Run.files.pid = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.files.state = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.flags |= Run_Foreground;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case 'B': {
      Run.flags &= ~Run_Batch;
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.files.id);
      Util_monitId(Run.files.id);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server ready for SNI, and the client sends a name that doesn't match any known credentials and so the SNI callback fails, causing the context to fail establishment."	3	"init_sni_fail(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = false;
  OM_uint32 ignore_minor_status = 0;

  major_status = gss_set_sec_context_option(&minor_status, &accept_context,
                                            GSS_SNI_CREDENTIALS,
                                            &(gss_buffer_desc){
                                                .value = creds,
                                                .length = sizeof(creds),
                                            });
  if (major_status != GSS_S_COMPLETE) {
    result = false;

    goto fail;
  }

  major_status =
      gss_import_name(&minor_status,
                      &(gss_buffer_desc){
                          .value = ""not-at-example.globus.org"",
                          .length = strlen(""not-at-example.globus.org""),
                      },
                      GLOBUS_GSS_C_NT_HOST_IP, &target_name);

  if (major_status != GSS_S_COMPLETE) {
    result = false;
    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = true;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = true;
        break;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/pointer.c	Constructs a pointer with the given prototype and native pointer.	2	"ava_pointer_value
ava_pointer_of_proto(const ava_pointer_prototype *restrict prototype,
                     const void *restrict ptr) {
  return (ava_pointer_value){ava_value_with_ulong(prototype, obfuscate(ptr))};
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavcodec/utils.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  AVPacket *pkt = avctx->internal->pkt;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
  };

  if (pkt) {
    frame->pkt_pts = pkt->pts;
    av_frame_set_pkt_pos(frame, pkt->pos);
    av_frame_set_pkt_duration(frame, pkt->duration);
    av_frame_set_pkt_size(frame, pkt->size);

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
  } else {
    frame->pkt_pts = AV_NOPTS_VALUE;
    av_frame_set_pkt_pos(frame, -1);
    av_frame_set_pkt_duration(frame, 0);
    av_frame_set_pkt_size(frame, -1);
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
    av_frame_set_colorspace(frame, avctx->colorspace);
  if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
    av_frame_set_color_range(frame, avctx->color_range);
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    av_frame_set_channels(frame, avctx->channels);
    break;
  }
  return 0;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/PrinterHost/Lib/PrinterCommands.c	"Issues a Printer class Get Device ID command to the attached device, to retrieve the device ID string (which indicates the accepted printer languages, the printer's model and other pertinent information)."	1	"uint8_t Printer_GetDeviceID(char *DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PrinterInterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = SwapEndian_16(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
dxjia-ffmpeg-compile-shared-library-for-android-a1e1313/source/ffmpeg/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    if (out_pkt.data == pkt->data && out_pkt.size == pkt->size) {
      out_pkt.buf = pkt->buf;
      pkt->buf = NULL;
#if FF_API_DESTRUCT_PACKET
      FF_DISABLE_DEPRECATION_WARNINGS
      out_pkt.destruct = pkt->destruct;
      pkt->destruct = NULL;
      FF_ENABLE_DEPRECATION_WARNINGS
#endif
    }
    if ((ret = av_dup_packet(&out_pkt)) < 0)
      goto fail;

    if (!add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
                       &s->internal->parse_queue_end)) {
      av_free_packet(&out_pkt);
      ret = AVERROR(ENOMEM);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_free_packet(pkt);
  return ret;
}"
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the index parser state struct with data to be parsed.	2	"psyc_parse_index_buffer_set(PsycParseIndexState *state, const char *buffer,
                            size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/source-manager/source/arm_uc_source_manager.c	find source of lowest cost and call consecutive sources until retrieved.	2	"static arm_uc_error_t ARM_UCSM_Get(request_t *req) {
  UC_SRCE_TRACE_ENTRY("">> %s"", __func__);
  arm_uc_error_t retval = (arm_uc_error_t){ERR_NONE};

  if (req->uri != NULL) {
    UC_SRCE_TRACE_VERBOSE(""    with %"" PRIxPTR
                          "", host [%s], path [%s], type %"" PRIu32,
                          (uintptr_t)req->uri, req->uri->host, req->uri->path,
                          (uint32_t)req->type);
  } else {
    UC_SRCE_TRACE_VERBOSE(""    with NULL, type %"" PRIu32, (uint32_t)req->type);
  }

  uint32_t index = 0;
  if (retval.error == ERR_NONE) {

    retval = ARM_UCSM_SourceRegistryGetLowestCost(req->uri, req->type,
                                                  req->excludes, &index);
  }
  if (retval.error == ERR_NONE) {

    switch (req->type) {
    case QUERY_TYPE_MANIFEST_DEFAULT:
      UC_SRCE_TRACE_VERBOSE(""calling source %"" PRIu32 "" GetManifestDefault"",
                            index);
      retval =
          source_registry[index]->GetManifestDefault(req->buffer, req->offset);
      break;
    case QUERY_TYPE_MANIFEST_URL:
      UC_SRCE_TRACE_VERBOSE(""calling source %"" PRIu32
                            "" GetManifestURL with %"" PRIxPTR,
                            index, (uintptr_t)req->uri);
      retval = source_registry[index]->GetManifestURL(req->uri, req->buffer,
                                                      req->offset);
      break;
    case QUERY_TYPE_FIRMWARE:
      UC_SRCE_TRACE_VERBOSE(""calling source %"" PRIu32
                            "" GetFirmwareFragment with %"" PRIxPTR,
                            index, (uintptr_t)req->uri);
      retval = source_registry[index]->GetFirmwareFragment(
          req->uri, req->buffer, req->offset);
      break;
    case QUERY_TYPE_KEYTABLE:
      UC_SRCE_TRACE_VERBOSE(""calling source %"" PRIu32
                            "" GetKeytableURL with %"" PRIxPTR,
                            index, (uintptr_t)req->uri);
      retval = source_registry[index]->GetKeytableURL(req->uri, req->buffer);
      break;
    default:
      if (req->uri == NULL) {
        UC_SRCE_ERR_MSG(
            ""-ARM_UCSM_Get: Error - Invalid parameter (URI == NULL)"");
        ARM_UCSM_SetError(retval = (arm_uc_error_t){SOMA_ERR_INVALID_URI});
      } else {
        UC_SRCE_ERR_MSG(
            ""-ARM_UCSM_Get: Error - Invalid parameter (unknown request type)"");
        ARM_UCSM_SetError(retval = (arm_uc_error_t){SOMA_ERR_INVALID_REQUEST});
      }
      break;
    }
  } else {
    UC_SRCE_ERR_MSG(""%s error retval.code %"" PRIu32, __func__, retval.code);
  }

  if (retval.code == SRCE_ERR_BUSY) {
    UC_SRCE_TRACE_VERBOSE(""%s Busy -> ScheduleAsyncBusyRetryGet"", __func__);
    ARM_UCSM_ScheduleAsyncBusyRetryGet();
    retval = (arm_uc_error_t){ERR_NONE};
  } else if (retval.code == SOMA_ERR_NO_ROUTE_TO_SOURCE) {
    UC_SRCE_ERR_MSG("".. %s: Error - no route available"", __func__);
    return retval;
  } else if (retval.error != ERR_NONE) {

    ARM_UCSM_SetError(retval);
    req->excludes[index] = 1;
    UC_SRCE_TRACE_VERBOSE(
        "".. %s: Error - failure (try source with the next smallest cost)"",
        __func__);
    retval = ARM_UCSM_Get(req);
  } else {

    req->current_source = index;
    UC_SRCE_TRACE_VERBOSE("".. %s: Using source %"" PRIu32, __func__, index);
    retval = (arm_uc_error_t){ERR_NONE};
  }
  if (ARM_UC_IS_ERROR(retval)) {
    ARM_UCSM_SetError(retval);
  }
  return retval;
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/ffplay.c	"Decode one audio frame and return its uncompressed size. The processed audio frame is decoded, converted if required, and stored in is->audio_buf, with size in bytes given by the return value."	2	"static int audio_decode_frame(VideoState *is) {
  AVPacket *pkt_temp = &is->audio_pkt_temp;
  AVPacket *pkt = &is->audio_pkt;
  AVCodecContext *dec = is->audio_st->codec;
  int len1, data_size, resampled_data_size;
  int64_t dec_channel_layout;
  int got_frame;
  av_unused double audio_clock0;
  int new_packet = 0;
  int flush_complete = 0;
  int wanted_nb_samples;
  AVRational tb;
  int ret;
  int reconfigure;

  for (;;) {

    while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet) ||
           is->audio_buf_frames_pending) {
      if (!is->frame) {
        if (!(is->frame = avcodec_alloc_frame()))
          return AVERROR(ENOMEM);
      } else {
        av_frame_unref(is->frame);
        avcodec_get_frame_defaults(is->frame);
      }

      if (is->audioq.serial != is->audio_pkt_temp_serial)
        break;

      if (is->paused)
        return -1;

      if (!is->audio_buf_frames_pending) {
        if (flush_complete)
          break;
        new_packet = 0;
        len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);
        if (len1 < 0) {

          pkt_temp->size = 0;
          break;
        }

        pkt_temp->data += len1;
        pkt_temp->size -= len1;

        if (!got_frame) {

          if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)
            flush_complete = 1;
          continue;
        }

        tb = (AVRational){1, is->frame->sample_rate};
        if (is->frame->pts != AV_NOPTS_VALUE)
          is->frame->pts = av_rescale_q(is->frame->pts, dec->time_base, tb);
        else if (is->frame->pkt_pts != AV_NOPTS_VALUE)
          is->frame->pts =
              av_rescale_q(is->frame->pkt_pts, is->audio_st->time_base, tb);
        if (pkt_temp->pts != AV_NOPTS_VALUE)
          pkt_temp->pts += (double)is->frame->nb_samples /
                           is->frame->sample_rate /
                           av_q2d(is->audio_st->time_base);

#if CONFIG_AVFILTER
        dec_channel_layout = get_valid_channel_layout(
            is->frame->channel_layout, av_frame_get_channels(is->frame));

        reconfigure =
            cmp_audio_fmts(is->audio_filter_src.fmt,
                           is->audio_filter_src.channels, is->frame->format,
                           av_frame_get_channels(is->frame)) ||
            is->audio_filter_src.channel_layout != dec_channel_layout ||
            is->audio_filter_src.freq != is->frame->sample_rate ||
            is->audio_pkt_temp_serial != is->audio_last_serial;

        if (reconfigure) {
          char buf1[1024], buf2[1024];
          av_get_channel_layout_string(buf1, sizeof(buf1), -1,
                                       is->audio_filter_src.channel_layout);
          av_get_channel_layout_string(buf2, sizeof(buf2), -1,
                                       dec_channel_layout);
          av_log(NULL, AV_LOG_DEBUG,
                 ""Audio frame changed from rate:%d ch:%d fmt:%s layout:%s ""
                 ""serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n"",
                 is->audio_filter_src.freq, is->audio_filter_src.channels,
                 av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1,
                 is->audio_last_serial, is->frame->sample_rate,
                 av_frame_get_channels(is->frame),
                 av_get_sample_fmt_name(is->frame->format), buf2,
                 is->audio_pkt_temp_serial);

          is->audio_filter_src.fmt = is->frame->format;
          is->audio_filter_src.channels = av_frame_get_channels(is->frame);
          is->audio_filter_src.channel_layout = dec_channel_layout;
          is->audio_filter_src.freq = is->frame->sample_rate;
          is->audio_last_serial = is->audio_pkt_temp_serial;

          if ((ret = configure_audio_filters(is, afilters, 1)) < 0)
            return ret;
        }

        if ((ret = av_buffersrc_add_frame(is->in_audio_filter, is->frame)) < 0)
          return ret;
        av_frame_unref(is->frame);
#endif
      }
#if CONFIG_AVFILTER
      if ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, is->frame,
                                               0)) < 0) {
        if (ret == AVERROR(EAGAIN)) {
          is->audio_buf_frames_pending = 0;
          continue;
        }
        return ret;
      }
      is->audio_buf_frames_pending = 1;
      tb = is->out_audio_filter->inputs[0]->time_base;
#endif

      data_size = av_samples_get_buffer_size(
          NULL, av_frame_get_channels(is->frame), is->frame->nb_samples,
          is->frame->format, 1);

      dec_channel_layout =
          (is->frame->channel_layout &&
           av_frame_get_channels(is->frame) ==
               av_get_channel_layout_nb_channels(is->frame->channel_layout))
              ? is->frame->channel_layout
              : av_get_default_channel_layout(av_frame_get_channels(is->frame));
      wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);

      if (is->frame->format != is->audio_src.fmt ||
          dec_channel_layout != is->audio_src.channel_layout ||
          is->frame->sample_rate != is->audio_src.freq ||
          (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {
        swr_free(&is->swr_ctx);
        is->swr_ctx = swr_alloc_set_opts(NULL, is->audio_tgt.channel_layout,
                                         is->audio_tgt.fmt, is->audio_tgt.freq,
                                         dec_channel_layout, is->frame->format,
                                         is->frame->sample_rate, 0, NULL);
        if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {
          av_log(NULL, AV_LOG_ERROR,
                 ""Cannot create sample rate converter for conversion of %d Hz ""
                 ""%s %d channels to %d Hz %s %d channels!\n"",
                 is->frame->sample_rate,
                 av_get_sample_fmt_name(is->frame->format),
                 av_frame_get_channels(is->frame), is->audio_tgt.freq,
                 av_get_sample_fmt_name(is->audio_tgt.fmt),
                 is->audio_tgt.channels);
          break;
        }
        is->audio_src.channel_layout = dec_channel_layout;
        is->audio_src.channels = av_frame_get_channels(is->frame);
        is->audio_src.freq = is->frame->sample_rate;
        is->audio_src.fmt = is->frame->format;
      }

      if (is->swr_ctx) {
        const uint8_t **in = (const uint8_t **)is->frame->extended_data;
        uint8_t **out = &is->audio_buf1;
        int out_count = (int64_t)wanted_nb_samples * is->audio_tgt.freq /
                            is->frame->sample_rate +
                        256;
        int out_size = av_samples_get_buffer_size(
            NULL, is->audio_tgt.channels, out_count, is->audio_tgt.fmt, 0);
        int len2;
        if (out_size < 0) {
          av_log(NULL, AV_LOG_ERROR, ""av_samples_get_buffer_size() failed\n"");
          break;
        }
        if (wanted_nb_samples != is->frame->nb_samples) {
          if (swr_set_compensation(is->swr_ctx,
                                   (wanted_nb_samples - is->frame->nb_samples) *
                                       is->audio_tgt.freq /
                                       is->frame->sample_rate,
                                   wanted_nb_samples * is->audio_tgt.freq /
                                       is->frame->sample_rate) < 0) {
            av_log(NULL, AV_LOG_ERROR, ""swr_set_compensation() failed\n"");
            break;
          }
        }
        av_fast_malloc(&is->audio_buf1, &is->audio_buf1_size, out_size);
        if (!is->audio_buf1)
          return AVERROR(ENOMEM);
        len2 =
            swr_convert(is->swr_ctx, out, out_count, in, is->frame->nb_samples);
        if (len2 < 0) {
          av_log(NULL, AV_LOG_ERROR, ""swr_convert() failed\n"");
          break;
        }
        if (len2 == out_count) {
          av_log(NULL, AV_LOG_WARNING, ""audio buffer is probably too small\n"");
          swr_init(is->swr_ctx);
        }
        is->audio_buf = is->audio_buf1;
        resampled_data_size = len2 * is->audio_tgt.channels *
                              av_get_bytes_per_sample(is->audio_tgt.fmt);
      } else {
        is->audio_buf = is->frame->data[0];
        resampled_data_size = data_size;
      }

      audio_clock0 = is->audio_clock;

      if (is->frame->pts != AV_NOPTS_VALUE)
        is->audio_clock =
            is->frame->pts * av_q2d(tb) +
            (double)is->frame->nb_samples / is->frame->sample_rate;
      else
        is->audio_clock = NAN;
      is->audio_clock_serial = is->audio_pkt_temp_serial;
#ifdef DEBUG
      {
        static double last_clock;
        printf(""audio: delay=%0.3f clock=%0.3f clock0=%0.3f\n"",
               is->audio_clock - last_clock, is->audio_clock, audio_clock0);
        last_clock = is->audio_clock;
      }
#endif
      return resampled_data_size;
    }

    if (pkt->data)
      av_free_packet(pkt);
    memset(pkt_temp, 0, sizeof(*pkt_temp));

    if (is->audioq.abort_request) {
      return -1;
    }

    if (is->audioq.nb_packets == 0)
      SDL_CondSignal(is->continue_read_thread);

    if ((new_packet = packet_queue_get(&is->audioq, pkt, 1,
                                       &is->audio_pkt_temp_serial)) < 0)
      return -1;

    if (pkt->data == flush_pkt.data) {
      avcodec_flush_buffers(dec);
      flush_complete = 0;
      is->audio_buf_frames_pending = 0;
    }

    *pkt_temp = *pkt;
  }
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/source-manager/source/arm_uc_source_manager.c	Remove pointer to source from the source_registry array.	2	"static arm_uc_error_t
ARM_UCSM_SourceRegistryRemove(const ARM_UPDATE_SOURCE *source) {
  uint32_t index = ARM_UCSM_GetIndexOfSource(source);

  if (index == MAX_SOURCES) {
    return ARM_UCSM_SetError((arm_uc_error_t){SOMA_ERR_SOURCE_NOT_FOUND});
  }

  source_registry[index] = NULL;
  return (arm_uc_error_t){ERR_NONE};
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/StillImage.c	"Sends a given PIMA command to the attached device, filling out the PIMA command header's Transaction ID automatically."	0	"uint8_t SImage_Host_SendCommand(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo,
                                const uint16_t Operation,
                                const uint8_t TotalParams,
                                uint32_t *const Params) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(TotalParams),
      .Type = CType_CommandBlock,
      .Code = Operation,
  };

  memcpy(&PIMABlock.Params, Params, sizeof(uint32_t) * TotalParams);

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/source/update_client_hub.c	Delete any global allocations.	2	"arm_uc_error_t ARM_UC_HUB_Uninitialize(void) {
  if (ARM_UC_HUB_getState() <= ARM_UC_HUB_STATE_INITIALIZED) {
    UC_HUB_ERR_MSG(""Update Client not initialized"");
    return (arm_uc_error_t){ERR_INVALID_STATE};
  }

  arm_uc_error_t err = ARM_UC_SourceManager.Uninitialize();
  ARM_UC_HUB_setState(ARM_UC_HUB_STATE_UNINITIALIZED);
  return err;
}"
Lefinnois-hackrf_433-1dbc0cb/src/pulse_detect.c	Demodulate On/Off Keying (OOK) and Frequency Shift Keying (FSK) from an envelope signal	2	"int detect_pulse_package(const int16_t *envelope_data, const int16_t *fm_data,
                         uint32_t len, int16_t level_limit, uint32_t samp_rate,
                         pulse_data_t *pulses, pulse_data_t *fsk_pulses) {
  const unsigned int samples_per_ms = samp_rate / 1000;
  pulse_state_t *s = &pulse_state;
  s->ook_high_estimate = max(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);

  while (s->data_counter < len) {

    const int16_t am_n = envelope_data[s->data_counter];
    int16_t ook_threshold =
        s->ook_low_estimate + (s->ook_high_estimate - s->ook_low_estimate) / 2;
    if (level_limit != 0)
      ook_threshold = level_limit;
    const int16_t ook_hysteresis = ook_threshold / 8;

    switch (s->state) {
    case PD_STATE_IDLE:
      if (am_n > (ook_threshold + ook_hysteresis) &&
          s->lead_in_counter > OOK_EST_RATIO) {

        pulse_data_clear(pulses);
        pulse_data_clear(fsk_pulses);
        s->pulse_length = 0;
        s->max_pulse = 0;
        s->FSK_state =
            (pulse_FSK_state_t){0, .fm_delta_est = FSK_DEFAULT_FM_DELTA};
        s->state = PD_STATE_PULSE;
      } else {

        s->ook_low_estimate +=
            am_n / OOK_EST_RATIO - s->ook_low_estimate / OOK_EST_RATIO;

        s->ook_high_estimate = OOK_HIGH_LOW_RATIO * s->ook_low_estimate;
        s->ook_high_estimate = max(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);
        s->ook_high_estimate = min(s->ook_high_estimate, OOK_MAX_HIGH_LEVEL);
        if (s->lead_in_counter <= OOK_EST_RATIO)
          s->lead_in_counter++;
      }
      break;
    case PD_STATE_PULSE:
      s->pulse_length++;

      if (am_n < (ook_threshold - ook_hysteresis)) {

        if (s->pulse_length < PD_MIN_PULSE_SAMPLES) {
          s->state = PD_STATE_IDLE;
        } else {

          pulses->pulse[pulses->num_pulses] = s->pulse_length;
          s->max_pulse = max(s->pulse_length, s->max_pulse);
          s->pulse_length = 0;
          s->state = PD_STATE_GAP;
        }

        if (fsk_pulses->num_pulses > PD_MIN_PULSES) {

          s->FSK_state.fsk_pulse_length++;
          if (s->FSK_state.state_fsk == PD_STATE_FSK_F1) {
            fsk_pulses->pulse[fsk_pulses->num_pulses] =
                s->FSK_state.fsk_pulse_length;
            fsk_pulses->gap[fsk_pulses->num_pulses] = 0;
          } else {
            fsk_pulses->gap[fsk_pulses->num_pulses] =
                s->FSK_state.fsk_pulse_length;
          }
          fsk_pulses->num_pulses++;

          fsk_pulses->ook_low_estimate = s->ook_low_estimate;
          fsk_pulses->ook_high_estimate = s->ook_high_estimate;
          return 2;
        }
      } else {

        s->ook_high_estimate +=
            am_n / OOK_EST_RATIO - s->ook_high_estimate / OOK_EST_RATIO;
        s->ook_high_estimate = max(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);
        s->ook_high_estimate = min(s->ook_high_estimate, OOK_MAX_HIGH_LEVEL);

        if (pulses->num_pulses == 0) {
          if (pulse_FSK_detect(fm_data[s->data_counter], fsk_pulses,
                               &s->FSK_state) != 0) {
            s->state = PD_STATE_IDLE;

            fsk_pulses->ook_low_estimate = s->ook_low_estimate;
            fsk_pulses->ook_high_estimate = s->ook_high_estimate;
          }
        }
      }
      break;
    case PD_STATE_GAP:
      s->pulse_length++;

      if (am_n > (ook_threshold + ook_hysteresis)) {
        pulses->gap[pulses->num_pulses] = s->pulse_length;
        pulses->num_pulses++;

        if (pulses->num_pulses >= PD_MAX_PULSES) {
          s->state = PD_STATE_IDLE;

          pulses->ook_low_estimate = s->ook_low_estimate;
          pulses->ook_high_estimate = s->ook_high_estimate;
          return 1;
        }

        s->pulse_length = 0;
        s->state = PD_STATE_PULSE;
      }

      if (((s->pulse_length > (PD_MAX_GAP_RATIO * s->max_pulse)) &&
           (s->pulse_length > (PD_MIN_GAP_MS * samples_per_ms))) ||
          (s->pulse_length > (PD_MAX_GAP_MS * samples_per_ms))) {
        pulses->gap[pulses->num_pulses] = s->pulse_length;
        pulses->num_pulses++;
        s->state = PD_STATE_IDLE;

        pulses->ook_low_estimate = s->ook_low_estimate;
        pulses->ook_high_estimate = s->ook_high_estimate;
        return 1;
      }
      break;
    default:
      fprintf(stderr, ""demod_OOK(): Unknown state!!\n"");
      s->state = PD_STATE_IDLE;
    }
    s->data_counter++;
  }

  s->data_counter = 0;
  return 0;
}"
pycom-pycom-esp-idf-c84098d/components/driver/sdspi_host.c	"These steps can be done separately, but that leads to a less than optimal performance on large transfers because of delays between each step. For example, if steps 3 and 4 are separate SPI transactions queued one after another, there will be ~16 microseconds of dead time between end of step 3 and the beginning of step 4. A delay between two blocking SPI transactions in step 2 is even higher (~60 microseconds). With this approach the delay between blocks of a multi-block transfer is ~95 microseconds, out of which 35 microseconds are spend doing the CRC check. Further speedup is possible by pipelining transfers and CRC checks, at an expense of one extra temporary buffer."	2	"static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
                                           uint8_t *data, uint32_t rx_length) {
  bool need_stop_command = rx_length > SDSPI_MAX_DATA_LEN;
  spi_transaction_t *t_command = get_transaction(slot);
  *t_command = (spi_transaction_t){
      .length = (SDSPI_CMD_R1_SIZE + 8) * 8,
      .tx_buffer = cmd,
      .rx_buffer = cmd,
  };
  esp_err_t ret = spi_device_transmit(spi_handle(slot), t_command);
  if (ret != ESP_OK) {
    return ret;
  }
  release_transaction(slot);

  uint8_t *cmd_u8 = (uint8_t *)cmd;
  size_t pre_scan_data_size = 8;
  uint8_t *pre_scan_data_ptr = cmd_u8 + SDSPI_CMD_R1_SIZE;

  while (rx_length > 0) {
    size_t extra_data_size = 0;
    const uint8_t *extra_data_ptr = NULL;
    bool need_poll = true;

    for (int i = 0; i < pre_scan_data_size; ++i) {
      if (pre_scan_data_ptr[i] == TOKEN_BLOCK_START) {
        extra_data_size = pre_scan_data_size - i - 1;
        extra_data_ptr = pre_scan_data_ptr + i + 1;
        need_poll = false;
        break;
      }
    }

    if (need_poll) {

      spi_transaction_t *t_poll = get_transaction(slot);
      ret = poll_data_token(slot, t_poll, cmd_u8 + SDSPI_CMD_R1_SIZE,
                            &extra_data_size, cmd->timeout_ms);
      release_transaction(slot);
      if (ret != ESP_OK) {
        return ret;
      }
      if (extra_data_size) {
        extra_data_ptr = cmd_u8 + SDSPI_CMD_R1_SIZE;
      }
    }

    size_t will_receive = MIN(rx_length, SDSPI_MAX_DATA_LEN) - extra_data_size;
    uint8_t *rx_data;
    ret = get_block_buf(slot, &rx_data);
    if (ret != ESP_OK) {
      return ret;
    }

    const size_t receive_extra_bytes = 4;
    memset(rx_data, 0xff, will_receive + receive_extra_bytes);
    spi_transaction_t *t_data = get_transaction(slot);
    *t_data =
        (spi_transaction_t){.length = (will_receive + receive_extra_bytes) * 8,
                            .rx_buffer = rx_data,
                            .tx_buffer = rx_data};

    ret = spi_device_transmit(spi_handle(slot), t_data);
    if (ret != ESP_OK) {
      return ret;
    }
    release_transaction(slot);

    uint16_t crc = UINT16_MAX;
    memcpy(&crc, rx_data + will_receive, sizeof(crc));

    pre_scan_data_size = receive_extra_bytes - sizeof(crc);
    pre_scan_data_ptr = rx_data + will_receive + sizeof(crc);

    memcpy(data + extra_data_size, rx_data, will_receive);
    if (extra_data_size) {
      memcpy(data, extra_data_ptr, extra_data_size);
    }

    uint16_t crc_of_data = 0;
    if (data_crc_enabled(slot)) {
      crc_of_data = sdspi_crc16(data, will_receive + extra_data_size);
      if (crc_of_data != crc) {
        ESP_LOGE(TAG, ""data CRC failed, got=0x%04x expected=0x%04x"",
                 crc_of_data, crc);
        esp_log_buffer_hex(TAG, data, 16);
        return ESP_ERR_INVALID_CRC;
      }
    }

    data += will_receive + extra_data_size;
    rx_length -= will_receive + extra_data_size;
    extra_data_size = 0;
    extra_data_ptr = NULL;
  }

  if (need_stop_command) {

    sdspi_hw_cmd_t stop_cmd;
    make_hw_cmd(MMC_STOP_TRANSMISSION, 0, cmd->timeout_ms, &stop_cmd);
    ret = start_command_default(slot, SDSPI_CMD_FLAG_RSP_R1, &stop_cmd);
    if (ret != ESP_OK) {
      return ret;
    }
    spi_transaction_t *t_poll = get_transaction(slot);
    ret = poll_busy(slot, t_poll, cmd->timeout_ms);
    release_transaction(slot);
    if (ret != ESP_OK) {
      return ret;
    }
  }
  return ESP_OK;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/PrinterHost/Lib/PrinterCommands.c	"Issues a Printer class Soft Reset command to the attached device, to reset the printer ready for new input without physically cycling the printer's power."	1	"uint8_t Printer_SoftReset(void) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_SoftReset,
      .wValue = 0,
      .wIndex = PrinterInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	Multiply scalar array with a scalar and save to output (with strides) optr = iptr * var	2	"void md_smul2(unsigned int D, const long dims[D], const long ostr[D],
              float *optr, const long istr[D], const float *iptr, float var) {
#ifdef USE_CUDA

  if (cuda_ondevice(iptr)) {

    assert(cuda_ondevice(optr));

    if (md_calc_blockdim(D, dims, ostr, FL_SIZE) != D)
      goto fallback;

    if (md_calc_blockdim(D, dims, istr, FL_SIZE) != D)
      goto fallback;

    if (iptr == optr) {

      gpu_ops.axpy(md_calc_size(D, dims), optr, var - 1., iptr);
      return;
    }

    md_clear(D, dims, optr, FL_SIZE);

    gpu_ops.axpy(md_calc_size(D, dims), optr, var, iptr);
    return;
  }
fallback:
#endif

#if 0
	make_3op_scalar(md_mul2, D, dims, ostr, optr, istr, iptr, var);
#else

  (void)0;

  NESTED(void, nary_smul, (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->smul(data->size, var, ptr[0], ptr[1]);
  };

  optimized_twoop_oi(D, dims, ostr, optr, istr, iptr,
                     (size_t[2]){FL_SIZE, FL_SIZE}, nary_smul);
#endif
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/JoystickHostWithParser/HIDReport.c	"Function to read in the HID report descriptor from the attached device, and process it into easy-to-read structures via the HID parser routines in the LUFA library."	0	"uint8_t GetHIDReportData(void) {

  uint8_t HIDReportData[HIDReportSize];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (HID_DTYPE_Report << 8),
      .wIndex = 0,
      .wLength = HIDReportSize,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if (USB_Host_SendControlRequest(HIDReportData) != HOST_SENDCONTROL_Successful)
    return ParseControlError;

  if (USB_ProcessHIDReport(HIDReportData, HIDReportSize, &HIDReportInfo) !=
      HID_PARSE_Successful)
    return ParseError;

  return ParseSuccessful;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/numerical_flux/numerical_flux_central_T.c	Version of compute_Numerical_Flux_fptr_T computing the numerical fluxes and Jacobians for the flux of compute_Numerical_Flux_T_central.	2	"(const struct Numerical_Flux_Input_T *num_flux_i,
 struct mutable_Numerical_Flux_T *num_flux) {
  struct Fluxes_LR fluxes_lr = constructor_Fluxes_LR(num_flux_i);
  struct Flux_T *const flux_l = fluxes_lr.flux_l, *const flux_r =
                                                      fluxes_lr.flux_r;

  struct Flux_Input_T *const flux_i = num_flux_i->flux_i;

  const struct const_Multiarray_T *const n_l = num_flux_i->bv_l.normals;
  transpose_Multiarray_T((struct Multiarray_T *)n_l, true);

  const bool *const c_m = flux_i->compute_member;

  const int n_eq_set = (!num_flux_i->bv_r.nf_E_provided ? NEQ : NEQ - 1);
  assert(c_m[0]);
  {
    struct Multiarray_T *const f_avg =
        (struct Multiarray_T *)constructor_sum_Multiarrays_const_Multiarray_T(
            0.5, flux_l->f, 0.5, flux_r->f);
    set_Numerical_Flux_member(n_l, f_avg, num_flux->nnf, 1.0,
                              (int[]){n_eq_set, 1, 1});
    destructor_Multiarray_T(f_avg);
  }

  if (c_m[1]) {
    struct Multiarray_T *const df_ds_l =
        constructor_copy_Multiarray_T((struct Multiarray_T *)flux_l->df_ds);
    set_Numerical_Flux_member(n_l, df_ds_l, num_flux->neigh_info[0].dnnf_ds,
                              0.5, (int[]){n_eq_set, NVR, 1});
    destructor_Multiarray_T(df_ds_l);

    struct Multiarray_T *const df_ds_r =
        constructor_copy_Multiarray_T((struct Multiarray_T *)flux_r->df_ds);
    set_Numerical_Flux_member(n_l, df_ds_r, num_flux->neigh_info[1].dnnf_ds,
                              0.5, (int[]){n_eq_set, NVR, 1});
    destructor_Multiarray_T(df_ds_r);
  }

  assert(c_m[2]);
  {
    struct Multiarray_T *const df_dg_l =
        constructor_copy_Multiarray_T((struct Multiarray_T *)flux_l->df_dg);
    set_Numerical_Flux_member(n_l, df_dg_l, num_flux->neigh_info[0].dnnf_dg,
                              0.5, (int[]){n_eq_set, NVR, DIM});
    destructor_Multiarray_T(df_dg_l);

    struct Multiarray_T *const df_dg_r =
        constructor_copy_Multiarray_T((struct Multiarray_T *)flux_r->df_dg);
    set_Numerical_Flux_member(n_l, df_dg_r, num_flux->neigh_info[1].dnnf_dg,
                              0.5, (int[]){n_eq_set, NVR, DIM});
    destructor_Multiarray_T(df_dg_r);
  }

  if (num_flux_i->bv_r.nf_E_provided)
    set_provided_Numerical_Flux_jacobian_members(num_flux_i, num_flux);

  assert(c_m[3] == 0);
  assert(c_m[4] == 0);
  assert(c_m[5] == 0);

  transpose_Multiarray_T((struct Multiarray_T *)n_l, true);

  destructor_Fluxes_LR(&fluxes_lr);
}"
mato-docker-unikernel-runner-4ddadd3/src/ptrvec.c	"Allocate a new ptrvec from the heap, initialize it as zero, and return a pointer to it."	2	"pvnew() {
  ptrvec *p = malloc(sizeof(*p));
  *p = (ptrvec){0};
  return p;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered."	2	"uint8_t MS_Host_PreventAllowMediumRemoval(
    USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex,
    const bool PreventRemoval) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(0),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, NULL);
}"
Return-To-The-Roots-s25client-e94be25/libs/s25main/random/Random.h	"Return a random number in the range [0, max)"	2	"unsigned obj_id;

RandomEntry() : counter(0), max(0), src_line(0), obj_id(0){};
RandomEntry(unsigned counter, int max, const PRNG &rngState,
            const std::string &src_name, unsigned src_line, unsigned obj_id)
    : counter(counter), max(max), rngState(rngState), src_name(src_name),
      src_line(src_line), obj_id(obj_id){};

friend std::ostream &operator<<(std::ostream &os, const RandomEntry &entry) {
  return entry.print(os);
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/cma_fe.c	User clicked either load or delete preset widget.	2	"static void popup_load_del_presets_dialog(bool load, struct widget *pButton) {
  int hh, count, i;
  struct widget *pBuf, *pWindow;
  utf8_str *pstr;
  SDL_Rect area;

  if (pCma->pAdv) {
    return;
  }

  count = cmafec_preset_num();

  if (count == 1) {
    if (load) {
      cm_copy_parameter(&pCma->edited_cm_parm, cmafec_preset_get_parameter(0));
      set_cma_hscrollbars();

      cmafec_set_fe_parameter(pCma->pCity, &pCma->edited_cm_parm);

      if (cma_is_city_under_agent(pCma->pCity, NULL)) {
        cma_release_city(pCma->pCity);
      }
    } else {
      cmafec_preset_remove(0);
    }
    update_city_cma_dialog();
    return;
  }

  pCma->pAdv = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pstr = create_utf8_from_char(_(""Presets""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = save_cma_window_callback;
  set_wstate(pWindow, FC_WS_NORMAL);
  pCma->pAdv->pEndWidgetList = pWindow;

  add_to_gui_list(ID_WINDOW, pWindow);

  area = pWindow->area;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  pBuf->action = cancel_SLD_cma_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;
  area.w += (pBuf->size.w + adj_size(10));

  add_to_gui_list(ID_BUTTON, pBuf);

  for (i = 0; i < count; i++) {
    pstr = create_utf8_from_char(cmafec_preset_get_descr(i), adj_font(10));
    pstr->style |= TTF_STYLE_BOLD;
    pBuf = create_iconlabel(
        NULL, pWindow->dst, pstr,
        (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));
    pBuf->string_utf8->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf->action = LD_cma_callback;

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;
    set_wstate(pBuf, FC_WS_NORMAL);

    if (load) {
      pBuf->data.ptr = (void *)1;
    } else {
      pBuf->data.ptr = NULL;
    }

    add_to_gui_list(MAX_ID - i, pBuf);

    if (i > 10) {
      set_wflag(pBuf, WF_HIDDEN);
    }
  }
  pCma->pAdv->pBeginWidgetList = pBuf;
  pCma->pAdv->pBeginActiveWidgetList = pCma->pAdv->pBeginWidgetList;
  pCma->pAdv->pEndActiveWidgetList = pWindow->prev->prev;
  pCma->pAdv->pActiveWidgetList = pCma->pAdv->pEndActiveWidgetList;

  area.w += adj_size(2);
  area.h += 1;

  if (count > 11) {
    create_vertical_scrollbar(pCma->pAdv, 1, 11, FALSE, TRUE);

    area.h = 11 * pWindow->prev->prev->size.h + adj_size(2) +
             2 * pCma->pAdv->pScroll->pUp_Left_Button->size.h;
    pCma->pAdv->pScroll->pUp_Left_Button->size.w = area.w;
    pCma->pAdv->pScroll->pDown_Right_Button->size.w = area.w;
  }

  resize_window(pWindow, NULL, NULL,
                (pWindow->size.w - pWindow->area.w) + area.w,
                (pWindow->size.h - pWindow->area.h) + area.h);

  area = pWindow->area;

  widget_set_position(pWindow, pButton->size.x - (pWindow->size.w / 2),
                      pButton->size.y - pWindow->size.h);

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  pBuf = pBuf->prev;
  hh = (pCma->pAdv->pScroll ? pCma->pAdv->pScroll->pUp_Left_Button->size.h + 1
                            : 0);
  setup_vertical_widgets_position(1, area.x + 1, area.y + 1 + hh, area.w - 1, 0,
                                  pCma->pAdv->pBeginActiveWidgetList, pBuf);

  if (pCma->pAdv->pScroll) {
    pCma->pAdv->pScroll->pUp_Left_Button->size.x = area.x;
    pCma->pAdv->pScroll->pUp_Left_Button->size.y = area.y;
    pCma->pAdv->pScroll->pDown_Right_Button->size.x = area.x;
    pCma->pAdv->pScroll->pDown_Right_Button->size.y =
        area.y + area.h - pCma->pAdv->pScroll->pDown_Right_Button->size.h;
  }

  redraw_group(pCma->pAdv->pBeginWidgetList, pWindow, 0);

  widget_flush(pWindow);
}"
darktable-org-darktable-32fab21/src/iop/rawprepare.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_rawprepare_params_t tmp = {{{0}}};

  if (!self->dev)
    goto end;

  const dt_image_t *const image = &(self->dev->image_storage);

  tmp = (dt_iop_rawprepare_params_t){
      .crop.named.x = image->crop_x,
      .crop.named.y = image->crop_y,
      .crop.named.width = image->crop_width,
      .crop.named.height = image->crop_height,
      .raw_black_level_separate[0] = image->raw_black_level_separate[0],
      .raw_black_level_separate[1] = image->raw_black_level_separate[1],
      .raw_black_level_separate[2] = image->raw_black_level_separate[2],
      .raw_black_level_separate[3] = image->raw_black_level_separate[3],
      .raw_white_point = image->raw_white_point};

  self->default_enabled = dt_image_is_raw(image) && !image_is_normalized(image);

end:
  memcpy(self->params, &tmp, sizeof(dt_iop_rawprepare_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_rawprepare_params_t));
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size."	1	"uint8_t
MS_Host_ReadDeviceCapacity(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                           const uint8_t LUNIndex,
                           SCSI_Capacity_t *const DeviceCapacity) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Capacity_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       DeviceCapacity)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  DeviceCapacity->Blocks = BE32_TO_CPU(DeviceCapacity->Blocks);
  DeviceCapacity->BlockSize = BE32_TO_CPU(DeviceCapacity->BlockSize);

  return PIPE_RWSTREAM_NoError;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Add two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion qadd(const quaternion num1,
                                   const quaternion num2) {
  return (quaternion){num1.R + num2.R, num1.i + num2.i, num1.j + num2.j,
                      num1.k + num2.k};
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Creates / finds a filter channel, adds a reference count and locks it."	2	"static channel_s *fio_filter_dup_lock(uint32_t filter) {
  channel_s ch = (channel_s){
      .name = (char *)&filter,
      .name_len = (sizeof(filter)),
      .parent = &fio_postoffice.filters,
      .ref = 8,
  };
  return fio_filter_dup_lock_internal(&ch, filter, &fio_postoffice.filters);
}"
apiaryio-drafter-0b11e03/ext/boost_1_66_0/boost/container/detail/node_pool_impl.hpp	Allocates several blocks of nodes. Can throw.	2	"void priv_alloc_block(size_type num_blocks) {
  BOOST_ASSERT(num_blocks > 0);
  size_type blocksize =
      (get_rounded_size)(m_real_node_size * m_nodes_per_block,
                         (size_type)alignment_of<node_t>::value);

  BOOST_TRY {
    for (size_type i = 0; i != num_blocks; ++i) {

      char *pNode = reinterpret_cast<char *>(
          mp_segment_mngr_base->allocate(blocksize + sizeof(node_t)));
      char *pBlock = pNode;
      m_blocklist.push_front(get_block_hook(pBlock, blocksize));

      for (size_type j = 0; j < m_nodes_per_block;
           ++j, pNode += m_real_node_size) {
        m_freelist.push_front(*new (pNode) node_t);
      }
    }
  }
  BOOST_CATCH(...){

      BOOST_RETHROW} BOOST_CATCH_END
}"
YggdrasiI-KinectGrid-f0ea947/3rdparty/onion/src/onion/handlers/exportlocal.c	Returns the directory listing.	2	"int onion_handler_export_local_directory(onion_handler_export_local_data *data,
                                         const char *realp,
                                         const char *showpath,
                                         onion_request *req,
                                         onion_response *res) {
  DIR *dir = opendir(realp);
  if (!dir)
    return 0;
  onion_response_set_header(res, ""Content-Type"", ""text/html; charset=utf-8"");

  onion_response_write0(
      res, ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" ""
           ""\""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">\n""
           ""<html>\n""
           "" <head><meta content=\""text/html; charset=UTF-8\"" ""
           ""http-equiv=\""content-type\""/>\n"");
  onion_response_printf(res, ""<title>Directory listing of %s</title>\n"",
                        showpath);
  onion_response_write0(res, ""</head>\n""
                             "" <body>\n""
                             ""<script>\n""
                             ""showListing = function(){\n""
                             ""	var q = function(t){\n""
                             ""		return t.replace('\""','%22')\n""
                             ""	}	\n""
                             ""	var t=document.getElementById('filebody')\n""
                             ""  while ( t.childNodes.length >= 1 )\n""
                             ""		t.removeChild( t.firstChild );       \n""
                             ""	for (var i=0;i<files.length;i++){\n""
                             ""		var f=files[i]\n""
                             ""		var h='<tr class=\""'+f[3]+'\""><td><a ""
                             ""href=\""'+q(f[0])+'\"">'+f[0]+'</a></""
                             ""td><td>'+f[1]+'</td><td>'+f[2]+'</td></tr>'\n""
                             ""		t.innerHTML+=h\n""
                             ""	}\n""
                             ""}\n""
                             ""\n""
                             ""update = function(n){\n""
                             ""	var _cmp = function(a,b){\n""
                             ""		if (a[n]<b[n])\n""
                             ""			return -1\n""
                             ""		if (a[n]>b[n])\n""
                             ""			return 1\n""
                             ""		return 0\n""
                             ""	}\n""
                             ""	files=files.sort(_cmp)\n""
                             ""	showListing()\n""
                             ""}\n""
                             ""window.onload=function(){\n""
                             ""	files=files.splice(0,files.length-1)\n""
                             ""	update(0)\n""
                             ""}\n""
                             ""\n""
                             ""files=[\n"");

  struct dirent *fi;
  struct stat st;
  char temp[1024];
  struct passwd *pwd;
  while ((fi = readdir(dir)) != NULL) {
    if (fi->d_name[0] == '.')
      continue;
    snprintf(temp, sizeof(temp), ""%s/%s"", realp, fi->d_name);
    stat(temp, &st);
    pwd = getpwuid(st.st_uid);

    if (S_ISDIR(st.st_mode))
      onion_response_printf(res, ""  ['%s/',%ld,'%s','dir'],\n"", fi->d_name,
                            st.st_size, pwd ? pwd->pw_name : ""???"");
    else
      onion_response_printf(res, ""  ['%s',%ld,'%s','file'],\n"", fi->d_name,
                            st.st_size, pwd ? pwd->pw_name : ""???"");
  }

  onion_response_write0(res, ""  [] ]\n</script>\n"");

  if (data->renderer_header)
    data->renderer_header(res, showpath);

  onion_response_write0(
      res, ""<table id=\""filelist\"">\n""
           ""<thead><tr>\n""
           "" <th onclick=\""update(0)\"" id=\""filename\"">Filename</th>\n""
           "" <th onclick=\""update(1)\"" id=\""size\"">Size</th>""
           "" <th onclick=\""update(2)\"" id=\""owner\"">Owner</th></tr>\n""
           ""</thead>\n""
           ""<tbody id=\""filebody\"">\n</tbody>\n</table>\n</body>\n"");

  if (data->renderer_footer)
    data->renderer_footer(res, showpath);

  onion_response_write0(res, ""</body></html>"");

  closedir(dir);

  return OCS_PROCESSED;
}"
opticks-org-opticks-f57aa89/Code/application/PlugInUtilities/Interfaces/MultiThreadedAlgorithm.h	Calculate the range of values for which a thread is responsible.	2	"mpAlgorithmMutex(NULL), mReporter(reporter),
    mThreadHandle(static_cast<void *>(this),
                  reinterpret_cast<void *>(AlgorithmThread::threadFunction)),
    mThreadIndex(threadIndex) {}

virtual ~AlgorithmThread(){};

AlgorithmThread(const AlgorithmThread &thread)
    : mpAlgorithmMutex(thread.mpAlgorithmMutex), mReporter(thread.mReporter),
      mThreadHandle(static_cast<void *>(this),
                    reinterpret_cast<void *>(AlgorithmThread::threadFunction)),
      mThreadIndex(thread.mThreadIndex) {}"
tiglabs-jupiter-1fd7df0/dpdk/drivers/net/mlx5/mlx5_rxtx_vec_neon.h	Send multi-segmented packets until it encounters a single segment packet in the pkts list.	2	"txq_scatter_v(struct mlx5_txq_data *txq, struct rte_mbuf **pkts,
              uint16_t pkts_n) {
  uint16_t elts_head = txq->elts_head;
  const uint16_t elts_n = 1 << txq->elts_n;
  const uint16_t elts_m = elts_n - 1;
  const uint16_t wq_n = 1 << txq->wqe_n;
  const uint16_t wq_mask = wq_n - 1;
  const unsigned int nb_dword_per_wqebb = MLX5_WQE_SIZE / MLX5_WQE_DWORD_SIZE;
  const unsigned int nb_dword_in_hdr =
      sizeof(struct mlx5_wqe) / MLX5_WQE_DWORD_SIZE;
  unsigned int n;
  volatile struct mlx5_wqe *wqe = NULL;

  assert(elts_n > pkts_n);
  mlx5_tx_complete(txq);

  assert((1u << txq->cqe_n) - (txq->cq_pi - txq->cq_ci));
  if (unlikely(!pkts_n))
    return 0;
  for (n = 0; n < pkts_n; ++n) {
    struct rte_mbuf *buf = pkts[n];
    unsigned int segs_n = buf->nb_segs;
    unsigned int ds = nb_dword_in_hdr;
    unsigned int len = PKT_LEN(buf);
    uint16_t wqe_ci = txq->wqe_ci;
    const uint8x16_t ctrl_shuf_m = {3,  2,  1, 0, 7,  6,  5,  4,
                                    11, 10, 9, 8, 12, 13, 14, 15};
    uint8_t cs_flags;
    uint16_t max_elts;
    uint16_t max_wqe;
    uint8x16_t *t_wqe;
    uint8_t *dseg;
    uint8x16_t ctrl;

    assert(segs_n);
    max_elts = elts_n - (elts_head - txq->elts_tail);
    max_wqe = wq_n - (txq->wqe_ci - txq->wqe_pi);

    if (segs_n == 1 || max_elts < segs_n || max_wqe < 2)
      break;
    wqe = &((volatile struct mlx5_wqe64 *)txq->wqes)[wqe_ci & wq_mask].hdr;
    cs_flags = txq_ol_cksum_to_cs(txq, buf);

    t_wqe = (uint8x16_t *)wqe;
    dseg = (uint8_t *)(wqe + 1);
    do {
      if (!(ds++ % nb_dword_per_wqebb)) {
        dseg = (uint8_t *)&(
            (volatile struct mlx5_wqe64 *)txq->wqes)[++wqe_ci & wq_mask];
      }
      txq_wr_dseg_v(txq, dseg, &buf, 1);
      dseg += MLX5_WQE_DWORD_SIZE;
      (*txq->elts)[elts_head++ & elts_m] = buf;
      buf = buf->next;
    } while (--segs_n);
    ++wqe_ci;

    ctrl = vreinterpretq_u8_u32((uint32x4_t){
        MLX5_OPC_MOD_MPW << 24 | txq->wqe_ci << 8 | MLX5_OPCODE_TSO,
        txq->qp_num_8s | ds, 0, 0});
    ctrl = vqtbl1q_u8(ctrl, ctrl_shuf_m);
    vst1q_u8((void *)t_wqe, ctrl);

    vst1q_u16(
        (void *)(t_wqe + 1),
        ((uint16x8_t){0, 0, cs_flags, rte_cpu_to_be_16(len), 0, 0, 0, 0}));
    txq->wqe_ci = wqe_ci;
  }
  if (!n)
    return 0;
  txq->elts_comp += (uint16_t)(elts_head - txq->elts_head);
  txq->elts_head = elts_head;
  if (txq->elts_comp >= MLX5_TX_COMP_THRESH) {
    wqe->ctrl[2] = rte_cpu_to_be_32(8);
    wqe->ctrl[3] = txq->elts_head;
    txq->elts_comp = 0;
#ifndef NDEBUG
    ++txq->cq_pi;
#endif
  }
#ifdef MLX5_PMD_SOFT_COUNTERS
  txq->stats.opackets += n;
#endif
  mlx5_tx_dbrec(txq, wqe);
  return n;
}"
ravidontharaju-pion-core-934f6e9/platform/include/pion/platform/Transform.hpp	Finds credit card numbers in a sequence of characters and replaces them with X's Note: this algorithm should work for any ASCII or UTF-8 sequence but will not work for other types of character encodings. Using Boost's ICU regex algorithms is not required because doing so does not affect the results for ASCII and UTF-8 encodings.	2	"inline bool HideCreditCardNumbers(IteratorType first, IteratorType last) {

  static const boost::regex FIND_CC_NUMBER_RX(
      ""\\b(?:4(?:[\\s+-]?\\d){15}|5[1-5](?:[\\s+-]?\\d){14}|(?:34|37)(?:[\\s+-]""
      ""?\\d){13}|(?:6011|65\\d\\d)(?:[\\s+-]?\\d){12}|(?:30[0-5]|36\\d|38\\d)(?""
      "":[\\s+-]?\\d){11}|35(?:[\\s+-]?\\d){14})\\b"");

  boost::match_results<IteratorType> results;

  bool found_match = false;

  while (boost::regex_search(first, last, results, FIND_CC_NUMBER_RX)) {

    found_match = true;

    for (IteratorType tmp_it = results[0].first; tmp_it != results[0].second;
         ++tmp_it) {
      *tmp_it = 'X';
    }

    first = results[0].second;
  }

  return found_match;
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavcodec/audio_frame_queue.c	Add a frame to the queue.	2	"int ff_af_queue_add(AudioFrameQueue *afq, const AVFrame *f) {
  AudioFrame *new =
      av_fast_realloc(afq->frames, &afq->frame_alloc,
                      sizeof(*afq->frames) * (afq->frame_count + 1));
  if (!new)
    return AVERROR(ENOMEM);
  afq->frames = new;
  new += afq->frame_count;

  new->duration = f->nb_samples;
  new->duration += afq->remaining_delay;
  if (f->pts != AV_NOPTS_VALUE) {
    new->pts = av_rescale_q(f->pts, afq->avctx->time_base,
                            (AVRational){1, afq->avctx->sample_rate});
    new->pts -= afq->remaining_delay;
    if (afq->frame_count && new[-1].pts >= new->pts)
      av_log(afq->avctx, AV_LOG_WARNING, ""Queue input is backward in time\n"");
  } else {
    new->pts = AV_NOPTS_VALUE;
  }
  afq->remaining_delay = 0;

  afq->remaining_samples += f->nb_samples;

  afq->frame_count++;

  return 0;
}"
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float8() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 8);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_64}}};
  return item;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set1_epi64x(long long __q) { return (__m128i){__q, __q}; }"
Snaipe-Criterion-982e569/src/compat/mockfile.c	Create a file mock.	2	"FILE *cr_mock_file_size(size_t max_size) {
#if defined(HAVE_FUNOPEN) || defined(HAVE_FOPENCOOKIE)
  struct memfile *cookie = malloc(sizeof(struct memfile));
  *cookie = (struct memfile){
      .max_size = max_size,
      .region_size = 4096,
      .mem = malloc(4096),
  };

  FILE *f;
#if defined(HAVE_FOPENCOOKIE)
  f = fopencookie(cookie, ""w+"",
                  (cookie_io_functions_t){
                      .read = mock_file_read,
                      .write = mock_file_write,
                      .seek = mock_file_seek,
                      .close = mock_file_close,
                  });
#else
  f = funopen(cookie, mock_file_read, mock_file_write, mock_file_seek,
              mock_file_close);
#endif
  return f;
#elif defined(HAVE_OPEN_MEMSTREAM)
  (void)max_size;
  char *mem;
  size_t sz;

  return open_memstream(&mem, &sz);
#else
  (void)max_size;

  return tmpfile();
#endif
}"
cmassiot-vlc-broadcast-de11815/src/misc/objects.c	"Returns the readable end of a pipe that becomes readable once termination of the object is requested (vlc_object_kill()). This can be used to wake-up out of a select() or poll() event loop, such typically when doing network I/O. Note that the pipe will remain the same for the lifetime of the object. DO NOT read the pipe nor close it yourself. Ever."	2	"int vlc_object_waitpipe(vlc_object_t *obj) {
  vlc_object_internals_t *internals = vlc_internals(obj);

  vlc_mutex_lock(&pipe_lock);
  if (internals->pipes[0] == -1) {

    assert(internals->pipes[1] == -1);

    int canc = vlc_savecancel();
#if defined(HAVE_SYS_EVENTFD_H)
    internals->pipes[0] = internals->pipes[1] = eventfd(0, EFD_CLOEXEC);
    if (internals->pipes[0] == -1)
#endif
    {
      if (pipe(internals->pipes))
        internals->pipes[0] = internals->pipes[1] = -1;
    }

    if (internals->pipes[0] != -1 && obj->b_die) {
      msg_Dbg(obj, ""waitpipe: object already dying"");
      write(internals->pipes[1], &(uint64_t){1}, sizeof(uint64_t));
    }
    vlc_restorecancel(canc);
  }
  vlc_mutex_unlock(&pipe_lock);
  return internals->pipes[0];
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MouseHost/MouseHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  puts_P(PSTR(""Mouse Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
cmassiot-vlc-broadcast-de11815/modules/stream_out/rtp.c	Add an ES as a new RTP stream	2	"static sout_stream_id_t *Add(sout_stream_t *p_stream, es_format_t *p_fmt) {

  sout_stream_sys_t *p_sys = p_stream->p_sys;
  char *psz_sdp;

  sout_stream_id_t *id = malloc(sizeof(*id));
  if (unlikely(id == NULL))
    return NULL;
  id->p_stream = p_stream;

  id->i_mtu = var_InheritInteger(p_stream, ""mtu"");
  if (id->i_mtu <= 12 + 16)
    id->i_mtu = 576 - 20 - 8;
  msg_Dbg(p_stream, ""maximum RTP packet size: %d bytes"", id->i_mtu);

#ifdef HAVE_SRTP
  id->srtp = NULL;
#endif
  vlc_mutex_init(&id->lock_sink);
  id->sinkc = 0;
  id->sinkv = NULL;
  id->rtsp_id = NULL;
  id->p_fifo = NULL;
  id->listen.fd = NULL;

  id->i_caching =
      (int64_t)1000 * var_GetInteger(p_stream, SOUT_CFG_PREFIX ""caching"");

  vlc_rand_bytes(&id->i_sequence, sizeof(id->i_sequence));
  vlc_rand_bytes(id->ssrc, sizeof(id->ssrc));

  bool format = false;

  if (p_sys->p_vod_media != NULL) {
    id->rtp_fmt.ptname = NULL;
    uint32_t ssrc;
    int val = vod_init_id(p_sys->p_vod_media, p_sys->psz_vod_session,
                          p_fmt ? p_fmt->i_id : 0, id, &id->rtp_fmt, &ssrc,
                          &id->i_seq_sent_next);
    if (val == VLC_SUCCESS) {
      memcpy(id->ssrc, &ssrc, sizeof(id->ssrc));

      id->i_sequence = id->i_seq_sent_next;
    }

    format = (id->rtp_fmt.ptname != NULL);
  }

  if (!format) {
    id->rtp_fmt.fmtp = NULL;
    char *psz = var_GetNonEmptyString(p_stream, SOUT_CFG_PREFIX ""mux"");
    if (p_fmt == NULL && psz == NULL)
      goto error;
    int val = rtp_get_fmt(VLC_OBJECT(p_stream), p_fmt, psz, &id->rtp_fmt);
    free(psz);
    if (val != VLC_SUCCESS)
      goto error;
  }

#ifdef HAVE_SRTP
  char *key = var_CreateGetNonEmptyString(p_stream, SOUT_CFG_PREFIX ""key"");
  if (key) {
    id->srtp = srtp_create(SRTP_ENCR_AES_CM, SRTP_AUTH_HMAC_SHA1, 10,
                           SRTP_PRF_AES_CM, SRTP_RCC_MODE1);
    if (id->srtp == NULL) {
      free(key);
      goto error;
    }

    char *salt = var_CreateGetNonEmptyString(p_stream, SOUT_CFG_PREFIX ""salt"");
    errno = srtp_setkeystring(id->srtp, key, salt ? salt : """");
    free(salt);
    free(key);
    if (errno) {
      msg_Err(p_stream, ""bad SRTP key/salt combination (%m)"");
      goto error;
    }
    id->i_sequence = 0;
  }
#endif

  id->i_seq_sent_next = id->i_sequence;

  int mcast_fd = -1;
  if (p_sys->psz_destination != NULL) {

    uint16_t i_port = 0;
    if (p_fmt == NULL)
      ;
    else if (p_fmt->i_cat == AUDIO_ES && p_sys->i_port_audio > 0)
      i_port = p_sys->i_port_audio;
    else if (p_fmt->i_cat == VIDEO_ES && p_sys->i_port_video > 0)
      i_port = p_sys->i_port_video;

    for (int i = 0; i_port && (i < p_sys->i_es); i++)
      if (i_port == p_sys->es[i]->i_port)
        i_port = 0;
    for (uint16_t p = p_sys->i_port; i_port == 0; p += 2) {
      if (p == 0) {
        msg_Err(p_stream, ""too many RTP elementary streams"");
        goto error;
      }
      i_port = p;
      for (int i = 0; i_port && (i < p_sys->i_es); i++)
        if (p == p_sys->es[i]->i_port)
          i_port = 0;
    }

    id->i_port = i_port;

    int type = SOCK_STREAM;

    switch (p_sys->proto) {
#ifdef SOCK_DCCP
    case IPPROTO_DCCP: {
      const char *code;
      switch (id->rtp_fmt.cat) {
      case VIDEO_ES:
        code = ""RTPV"";
        break;
      case AUDIO_ES:
        code = ""RTPARTPV"";
        break;
      case SPU_ES:
        code = ""RTPTRTPV"";
        break;
      default:
        code = ""RTPORTPV"";
        break;
      }
      var_SetString(p_stream, ""dccp-service"", code);
      type = SOCK_DCCP;
    }
#endif
    case IPPROTO_TCP:
      id->listen.fd = net_Listen(VLC_OBJECT(p_stream), p_sys->psz_destination,
                                 i_port, type, p_sys->proto);
      if (id->listen.fd == NULL) {
        msg_Err(p_stream, ""passive COMEDIA RTP socket failed"");
        goto error;
      }
      if (vlc_clone(&id->listen.thread, rtp_listen_thread, id,
                    VLC_THREAD_PRIORITY_LOW)) {
        net_ListenClose(id->listen.fd);
        id->listen.fd = NULL;
        goto error;
      }
      break;

    default: {
      int fd = net_ConnectDgram(p_stream, p_sys->psz_destination, i_port, -1,
                                p_sys->proto);
      if (fd == -1) {
        msg_Err(p_stream, ""cannot create RTP socket"");
        goto error;
      }

      setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &(int){0}, sizeof(int));
      rtp_add_sink(id, fd, p_sys->rtcp_mux, NULL);

      mcast_fd = fd;
    }
    }
  }

  if (p_fmt != NULL)
    switch (p_fmt->i_codec) {
    case VLC_CODEC_MULAW:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_U8:
      rtp_set_ptime(id, 20, 1);
      break;
    case VLC_CODEC_S16B:
    case VLC_CODEC_S16L:
      rtp_set_ptime(id, 20, 2);
      break;
    default:
      break;
    }

#if 0  
    int cscov = -1;
    if( cscov != -1 )
        cscov += 8   + 12  ;
    if( id->sinkc > 0 )
        net_SetCSCov( id->sinkv[0].rtp_fd, cscov, -1 );
#endif

  vlc_mutex_lock(&p_sys->lock_ts);
  id->b_ts_init = (p_sys->i_npt_zero != VLC_TS_INVALID);
  vlc_mutex_unlock(&p_sys->lock_ts);
  if (id->b_ts_init)
    id->i_ts_offset =
        rtp_compute_ts(id->rtp_fmt.clock_rate, p_sys->i_pts_offset);

  if (p_sys->rtsp != NULL)
    id->rtsp_id = RtspAddId(p_sys->rtsp, id, GetDWBE(id->ssrc),
                            id->rtp_fmt.clock_rate, mcast_fd);

  id->p_fifo = block_FifoNew();
  if (unlikely(id->p_fifo == NULL))
    goto error;
  if (vlc_clone(&id->thread, ThreadSend, id, VLC_THREAD_PRIORITY_HIGHEST)) {
    block_FifoRelease(id->p_fifo);
    id->p_fifo = NULL;
    goto error;
  }

  vlc_mutex_lock(&p_sys->lock_es);
  TAB_APPEND(p_sys->i_es, p_sys->es, id);
  vlc_mutex_unlock(&p_sys->lock_es);

  psz_sdp = SDPGenerate(p_stream, NULL);

  vlc_mutex_lock(&p_sys->lock_sdp);
  free(p_sys->psz_sdp);
  p_sys->psz_sdp = psz_sdp;
  vlc_mutex_unlock(&p_sys->lock_sdp);

  msg_Dbg(p_stream, ""sdp=\n%s"", p_sys->psz_sdp);

  if (p_sys->b_export_sap)
    SapSetup(p_stream);
  if (p_sys->psz_sdp_file != NULL)
    FileSetup(p_stream);

  return id;

error:
  Del(p_stream, id);
  return NULL;
}"
ARM-software-scmi-tests-24dd373/protocols/sensor/sensor_exe.c	The function is called by the test engine before sending the sensor reading get command and testing the received values.	3	"void arm_scmi_custom_tester_sensor_reading_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {

  uint32_t idx;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_sensor_reading_get, sensor_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_reading_get,
                                       sensor_id)] =
        sensor_protocol_data.num_sensors;
    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_sensor_reading_get, flags)] =
        (RESERVED << SNR_READING_FLAG_RESERVED_LOW) |
        (SENSOR_SYNC << SNR_READING_FLAG_SYNC_ASYNC);
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (idx = 0; idx < sensor_protocol_data.num_sensors; ++idx) {
      snprintf(description, NUM_ELEMS(description), ""\n\n\t\t\tSENSOR ID %d"",
               sensor_protocol_data.sensor_id[idx]);
      arm_scmi_log(test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_reading_get,
                                         sensor_id)] =
          sensor_protocol_data.sensor_id[idx];
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_reading_get,
                                         flags)] =
          (RESERVED << SNR_READING_FLAG_RESERVED_LOW) |
          (SENSOR_SYNC << SNR_READING_FLAG_SYNC_ASYNC);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      arm_scmi_check_and_report_hex(
          test_stats, ALL_BITS_SET, PRINT, 0,
          RETURN_VAL(received, struct arm_scmi_sensor_reading_get,
                     sensor_value_low),
          ""SENSOR VALUE LOW"");

      arm_scmi_check_and_report_hex(
          test_stats, ALL_BITS_SET, PRINT, 0,
          RETURN_VAL(received, struct arm_scmi_sensor_reading_get,
                     sensor_value_high),
          ""SENSOR VALUE HIGH"");
    }
  }
}"
boazsegev-iodine-b6bdf50/ext/iodine/iodine_tcp.c	assigns a protocol and IO object to a handler	2	"void iodine_tcp_attch_uuid(intptr_t uuid, VALUE handler) {
  FIO_LOG_DEBUG(""Iodine attaching handler %p to uuid %p"", (void *)handler,
                (void *)uuid);
  if (handler == Qnil || handler == Qfalse || handler == Qtrue) {
    fio_close(uuid);
    return;
  }

  iodine_protocol_s *p = malloc(sizeof(*p));
  FIO_ASSERT_ALLOC(p);
  *p = (iodine_protocol_s){
      .p =
          {
              .on_data = iodine_tcp_on_data,
              .on_ready = NULL,
              .on_shutdown = iodine_tcp_on_shutdown,
              .on_close = iodine_tcp_on_close,
              .ping = iodine_tcp_ping,
          },
      .io = iodine_connection_new(.type = IODINE_CONNECTION_RAW, .uuid = uuid,
                                  .arg = p, .handler = handler),
  };

  fio_attach(uuid, &p->p);
  if (fio_is_valid(uuid)) {
    iodine_connection_fire_event(p->io, IODINE_CONNECTION_ON_OPEN, Qnil);
    p->p.on_ready = iodine_tcp_on_ready;
    fio_force_event(uuid, FIO_EVENT_ON_READY);
  } else {
    FIO_LOG_DEBUG(
        ""Iodine couldn't attach handler %p to uuid %p - invalid uuid."",
        (void *)handler, (void *)uuid);
  }
}"
googlei18n-noto-emoji-6a609ec/third_party/pngquant/lib/pam.h	Converts 8-bit color to internal gamma and premultiplied alpha. (premultiplied color space is much better for blending of semitransparent colors)	2	"inline static f_pixel to_f(const float gamma_lut[], const rgba_pixel px) {
  float a = px.a / 255.f;

  return (f_pixel){
      .a = a,
      .r = gamma_lut[px.r] * a,
      .g = gamma_lut[px.g] * a,
      .b = gamma_lut[px.b] * a,
  };
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	"Step (2) of Soft Thresholding multi-dimensional arrays, y = ST(x, lambda) 2) computes resid = MAX( (abs(x) - lambda)/abs(x), 0 ) (with strides)"	2	"void md_softthresh_half2(unsigned int D, const long dim[D], float lambda,
                         const long ostr[D], float *optr, const long istr[D],
                         const float *iptr) {
  NESTED(void, nary_softthresh_half,
         (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->softthresh_half(data->size, lambda, ptr[0], ptr[1]);
  };

  optimized_twoop_oi(D, dim, ostr, optr, istr, iptr,
                     (size_t[2]){FL_SIZE, FL_SIZE}, nary_softthresh_half);
}"
mikeryan-SlideQuacker-9d39f28/apps/quacker/src/main.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"quacker_advertise(void) {
  struct ble_hs_adv_fields fields;
  int rc;

  memset(&fields, 0, sizeof fields);

  fields.name = (uint8_t *)quacker_device_name;
  fields.name_len = strlen(quacker_device_name);
  fields.name_is_complete = 1;

  fields.uuids16 = (uint16_t[]){GATT_SVR_SVC_HID_UUID};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  fields.appearance = 961;
  fields.appearance_is_present = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    QUACKER_LOG(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  rc = ble_gap_adv_start(BLE_GAP_DISC_MODE_GEN, BLE_GAP_CONN_MODE_UND, NULL, 0,
                         NULL, quacker_gap_event, NULL);
  if (rc != 0) {
    QUACKER_LOG(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
Airblader-xedgewarp-1695e18/src/event.c	This is called when we receive a RawMotion event. It will query the pointer position and figure out whether we need to warp the cursor etc.	2	"void event_handle_motion(void) {
  xcb_query_pointer_reply_t *reply = xcb_query_pointer_reply(
      connection, xcb_query_pointer(connection, root), NULL);
  if (reply == NULL) {
    ELOG(""Failed to query the cursor position, ignoring this event."");
    return;
  }

  position_t pointer = (position_t){.x = reply->root_x, .y = reply->root_y};

  FREE(reply);

  direction_t direction = pointer_touches_border(pointer);
  if (direction == D_NONE)
    return;

  if (has_warped) {
    DLOG(""Pointer has already been warped, not warping it again."");
    return;
  }

  DLOG(""Touching a dead border segment at %d / %d."", pointer.x, pointer.y);
  pointer_warp_to_adjacent_output(pointer, direction);
}"
HiPhish-XeenTools-ee7c26c/Source/pal/pal_tool.c	Retrieve the PAL-formatted palette from PAL file.	2	"int xeen_read_pal(FILE *fp, long fo, XeenColor **pal) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    ALLOC_FAIL,
    FREAD_FAIL,
  } error = SUCCESS;

  if (!pal || !fp) {

    error = INVALID_ARGS;
    goto end;
  } else if (*pal) {

    error = INVALID_ARGS;
    goto end;
  }

  if (!(*pal = malloc(XEEN_PAL_SIZE * sizeof(XeenColor)))) {

    error = ALLOC_FAIL;
    goto end;
  }

  fseek(fp, fo, SEEK_SET);

  for (int i = 0; i < XEEN_PAL_SIZE; ++i) {
    uint8_t byte[3];
    if (fread(byte, sizeof(uint8_t), 3, fp) != 3) {

      error = FREAD_FAIL;
      free(pal);
      pal = NULL;
      goto end;
    }
    (*pal)[i] = (XeenColor){
        .r = byte[0],
        .g = byte[1],
        .b = byte[2],
    };
  }

  assert(pal);

end:
  return error;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	Update Client call for informing the Control Center about the current firmware name. The Control Center will send this to the monitor. The firmware name is the SHA256 hash.	2	"arm_uc_error_t ARM_UC_ControlCenter_ReportName(arm_uc_buffer_t *name) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportName: %p"", name);

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct) {
    arm_uc_monitor_struct->SendName(name);
    result.code = ERR_NONE;
  }

  return result;
}"
dm-vdo-kvdo-8df6805/vdo/base/vdoRecovery.c	Apply any synthesized decrefs entries to the appropriate slab journal.	2	"static void applySynthesizedDecrefs(RecoveryCompletion *recovery) {
  if (abortRecoveryOnError(recovery->completion.result, recovery)) {
    return;
  }

  logInfo(""Recreating missing journal entries"");
  int result = computeUsages(recovery);
  if (abortRecoveryOnError(result, recovery)) {
    return;
  }

  recovery->nextJournalPoint = (JournalPoint){
      .sequenceNumber = recovery->tail,
      .entryCount = recovery->vdo->recoveryJournal->entriesPerBlock,
  };
  launchCallbackWithParent(&recovery->subTaskCompletion, addSynthesizedEntries,
                           getAdminThread(getThreadConfig(recovery->vdo)),
                           &recovery->completion);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/hash-map-impl.c	"If the given hash map has any deleted elements, the keys and values arrays are rebuilt to have no deleted elements, and the deleted bitmap is nulled. This destroys the hash table proper, so it should only be called from ava_hash_map_rehash()."	2	"static size_t ava_hash_map_vacuum(ava_hash_map *restrict src,
                                  size_t num_elements) {
  ava_hash_map dst;
  size_t i, bitmap_nelt, new_num_elements;
  ava_list_value src_keys, src_values;
  ava_list_value dst_keys, dst_values;
  ava_value key, value;
  const ava_ulong *restrict bitmap;
  ava_esba_tx tx;

  if (0 == src->num_deleted_entries)
    return num_elements;

  new_num_elements = num_elements - src->num_deleted_entries;

  dst = *src;

  dst.deleted_entries = (ava_esba){0, 0};
  dst.num_deleted_entries = 0;
  dst.effective_indices = 0;

  src_keys = (ava_list_value){ava_value_with_ulong(src->keys, num_elements)};
  src_values =
      (ava_list_value){ava_value_with_ulong(src->values, num_elements)};

  bitmap_nelt = ava_esba_length(src->deleted_entries);
  do {
    bitmap = ava_esba_access(src->deleted_entries, &tx);

    for (i = 0; i / BME_BITS < bitmap_nelt &&
                ((bitmap[i / BME_BITS] >> i % BME_BITS) & 1);
         ++i)
      assert(i < num_elements);

    key = src->esba_trait->index(src_keys, i);
    value = src->esba_trait->index(src_values, i);
    dst_keys = ava_esba_list_of_raw(&key, 1);
    dst_values = ava_esba_list_of_raw(&value, 1);

    for (++i; i < num_elements; ++i) {
      if (i / BME_BITS >= bitmap_nelt ||
          0 == ((bitmap[i / BME_BITS] >> i % BME_BITS) & 1)) {
        dst_keys = dst.esba_trait->append(dst_keys,
                                          src->esba_trait->index(src_keys, i));
        dst_values = dst.esba_trait->append(
            dst_values, src->esba_trait->index(src_values, i));
      }
    }
  } while (
      AVA_UNLIKELY(!ava_esba_check_access(src->deleted_entries, bitmap, tx)));

  dst.keys = ava_value_attr(dst_keys.v);
  dst.values = ava_value_attr(dst_values.v);

  *src = dst;
  return new_num_elements;
}"
pando-project-jerryscript-772ab27/jerry-main/cli.c	Initialize a command line option processor.	2	"cli_init(const cli_opt_t *options_p, int argc, char **argv) {
  return (cli_state_t){.error = NULL,
                       .arg = NULL,
                       .argc = argc,
                       .argv = argv,
                       .opts = options_p};
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands."	1	"uint8_t MS_Host_TestUnitReady(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                              const uint8_t LUNIndex) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/xmmintrin.h	Constructs a 128-bit floating-point vector of [4 x float] initialized to zero.	2	"_mm_setzero_ps(void) { return __extension__(__m128){0, 0, 0, 0}; }"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/CDC.c	"Sends a Serial Control Line State Change notification to the device. This should be called when the virtual serial control lines (DTR, RTS, etc.) have changed states. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.HostToDevice value is updated to push the new states to the USB device."	2	"uint8_t CDC_Host_SendControlLineStateChange(
    USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SetControlLineState,
      .wValue = CDCInterfaceInfo->State.ControlLineStates.HostToDevice,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
opticron-libuweave-2e5e385/src/macaroon.c	Reset the result object to the lowest scope when encountering errors	2	"static void reset_validation_result(UwMacaroonValidationResult *result) {
  *result = (UwMacaroonValidationResult){
      .app_commands_only = true,
      .granted_scope = UW_MACAROON_CAVEAT_SCOPE_LOWEST_POSSIBLE};
}"
a2flo-floor-07f1bfc/math/vector.hpp	"applies the rsqrt function on all components converts this vector to the corresponding clang vector type, e.g. float4 to ""float __attribute__((ext_vector_type(4)))"" explicitly converts this vector to the corresponding clang vector type, e.g. float4 to ""float __attribute__((ext_vector_type(4)))"""	2	"FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::sqrt, sqrt, sqrted)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::rsqrt, rsqrt, rsqrted)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::sin, sin, sined)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::cos, cos, cosed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::tan, tan, taned)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::asin, asin, asined)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::acos, acos, acosed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::atan, atan, ataned)

FLOOR_VEC_FUNC_ARGS(vector_helper<decayed_scalar_type>::atan2, atan2, atan2ed,
                    (const scalar_type &rhs), rhs)

FLOOR_VEC_FUNC_ARGS_VEC(vector_helper<decayed_scalar_type>::atan2, atan2,
                        atan2ed, (const vector_type &rhs), rhs.)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::sinh, sinh, sinhed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::cosh, cosh, coshed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::tanh, tanh, tanhed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::asinh, asinh, asinhed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::acosh, acosh, acoshed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::atanh, atanh, atanhed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::exp, exp, exped)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::exp2, exp2, exp2ed)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::log, log, loged)

FLOOR_VEC_FUNC(vector_helper<decayed_scalar_type>::log2, log2, log2ed)

FLOOR_VEC_FUNC_ARGS(vector_helper<decayed_scalar_type>::pow, pow, powed,
                    (const scalar_type &exponent), exponent)

FLOOR_VEC_FUNC_ARGS_VEC(vector_helper<decayed_scalar_type>::pow, pow, powed,
                        (const vector_type &exponent), exponent.)

#pragma mark type conversion

#if FLOOR_VECTOR_WIDTH == 1

explicit operator scalar_type() const { return x; }
#endif

template <typename vec_type = vector_type,
          enable_if_t<vec_type::has_clang_vector_type()> * = nullptr>
constexpr operator clang_vector_type() const {
  return (clang_vector_type){FLOOR_VEC_EXPAND(FLOOR_COMMA)};
}

template <typename vec_type = vector_type,
          enable_if_t<vec_type::has_clang_vector_type()> * = nullptr>
constexpr clang_vector_type to_clang_vector() const {
  return (clang_vector_type){FLOOR_VEC_EXPAND(FLOOR_COMMA)};
}

template <typename vec_type = vector_type,
          enable_if_t<vec_type::has_clang_vector_type()> * = nullptr>
static constexpr vector_type from_clang_vector(const clang_vector_type &vec) {
  return {FLOOR_VEC_EXPAND_ENCLOSED(FLOOR_COMMA, vec., )};
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	Clears the stall condition in the attached device on the nominated endpoint number.	0	"uint8_t MassStore_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
scorelab-OpenDF-2664307/sleuthkit/tools/fiwalk/src/hash_t.h	Compute a sha1 from a buffer and return the hash	2	"static hash__<T> hash_buf(const uint8_t *buf, size_t bufsize) {

#if 0
	if(sha1_ctr==0){
	    uint8_t b2[512];
	    EVP_MD_CTX ctx2;
	    unsigned int len = sizeof(sha1_512nulls);
	    memset(b2,0,sizeof(b2));
	    EVP_MD_CTX_init(&ctx2);
	    EVP_DigestInit_ex(&ctx2, EVP_sha1(), NULL);
	    EVP_DigestUpdate(&ctx2,b2,sizeof(b2));
	    EVP_DigestFinal(&ctx2,sha1_512nulls,&len);
	    sha1_ctr++;
	}

	 
	if(bufsize==512 && iszero(buf,bufsize)){
	    return sha1_t(sha1_512nulls);
	}
#endif
  hash_generator__ g;
  g.update(buf, bufsize);
  return g.final();
}"
dm-vdo-kvdo-8df6805/vdo/base/blockMap.c	Schedule an action and act if there is no other action already in progress.	2	"static bool scheduleAction(BlockMap *map, BlockMapActionType action,
                           VDOCompletion *parent) {
  ASSERT_LOG_ONLY((getCallbackThreadID() == map->recoveryJournalThreadID),
                  ""scheduleAction() called in journal zone"");
  if (hasNextAction(map)) {
    finishCompletion(parent, VDO_COMPONENT_BUSY);
    return false;
  }

  map->nextAction = (BlockMapAction){
      .action = action,
      .parent = parent,
  };

  if (isActing(map)) {
    return false;
  }

  advanceActions(map);
  return true;
}"
gnuradio-gnuradio-b238e90/gnuradio-runtime/include/gnuradio/flowgraph.h	Clear existing flowgraph.	2	"{
public:
  msg_edge() : d_src(), d_dst(){};
  msg_edge(const msg_endpoint &src, const msg_endpoint &dst)
      : d_src(src), d_dst(dst) {}
  ~msg_edge() {}"
CoolProp-CoolProp-3748093/src/Backends/Tabular/TabularBackends.h	"If you need all three values (drho_dh__p, drho_dp__h and rho_spline), you should calculate drho_dp__h first to avoid duplicate calculations."	2	"xmin = Tmin;
ymin = AS->p();

xmax = AS->Tmax() * 1.499;
ymax = AS->pmax();
}
void deserialize(msgpack::object &deserialized) {
  LogPTTable temp;
  deserialized.convert(temp);
  temp.unpack();
  if (Nx != temp.Nx || Ny != temp.Ny) {
    throw ValueError(
        format(""old [%dx%d] and new [%dx%d] dimensions don't agree"", temp.Nx,
               temp.Ny, Nx, Ny));
  } else if (revision > temp.revision) {
    throw ValueError(
        format(""loaded revision [%d] is older than current revision [%d]"",
               temp.revision, revision));
  } else if ((std::abs(xmin) > 1e-10 && std::abs(xmax) > 1e-10) &&
             (std::abs(temp.xmin - xmin) / xmin > 1e-6 ||
              std::abs(temp.xmax - xmax) / xmax > 1e-6)) {
    throw ValueError(format(
        ""Current limits for x [%g,%g] do not agree with loaded limits [%g,%g]"",
        xmin, xmax, temp.xmin, temp.xmax));
  } else if ((std::abs(ymin) > 1e-10 && std::abs(ymax) > 1e-10) &&
             (std::abs(temp.ymin - ymin) / ymin > 1e-6 ||
              std::abs(temp.ymax - ymax) / ymax > 1e-6)) {
    throw ValueError(format(
        ""Current limits for y [%g,%g] do not agree with loaded limits [%g,%g]"",
        ymin, ymax, temp.ymin, temp.ymax));
  }
  std::swap(*this, temp);
  this->AS = temp.AS;
};
}
;

class CellCoeffs {
private:
  std::size_t alt_i, alt_j;
  bool _valid, _has_valid_neighbor;

public:
  double dx_dxhat, dy_dyhat;
  CellCoeffs() {
    _valid = false;
    _has_valid_neighbor = false;
    dx_dxhat = _HUGE;
    dy_dyhat = _HUGE;
    alt_i = 9999999;
    alt_j = 9999999;
  }
  std::vector<double> T, rhomolar, hmolar, p, smolar, umolar;

  const std::vector<double> &get(const parameters params) const {
    switch (params) {
    case iT:
      return T;
    case iP:
      return p;
    case iDmolar:
      return rhomolar;
    case iHmolar:
      return hmolar;
    case iSmolar:
      return smolar;
    case iUmolar:
      return umolar;
    default:
      throw KeyError(format(""Invalid key to get() function of CellCoeffs""));
    }
  };

  void set(parameters params, const std::vector<double> &mat) {
    switch (params) {
    case iT:
      T = mat;
      break;
    case iP:
      p = mat;
      break;
    case iDmolar:
      rhomolar = mat;
      break;
    case iHmolar:
      hmolar = mat;
      break;
    case iSmolar:
      smolar = mat;
      break;
    case iUmolar:
      umolar = mat;
      break;
    default:
      throw KeyError(format(""Invalid key to set() function of CellCoeffs""));
    }
  };

  bool valid() const { return _valid; };

  void set_valid() { _valid = true; };

  void set_invalid() { _valid = false; };

  void set_alternate(std::size_t i, std::size_t j) {
    alt_i = i;
    alt_j = j;
    _has_valid_neighbor = true;
  }

  void get_alternate(std::size_t &i, std::size_t &j) const {
    if (_has_valid_neighbor) {
      i = alt_i;
      j = alt_j;
    } else {
      throw ValueError(""No valid neighbor"");
    }
  }

  bool has_valid_neighbor() const { return _has_valid_neighbor; }
};

class TabularDataSet {
public:
  bool tables_loaded;
  LogPHTable single_phase_logph;
  LogPTTable single_phase_logpT;
  PureFluidSaturationTableData pure_saturation;
  PackablePhaseEnvelopeData phase_envelope;
  std::vector<std::vector<CellCoeffs>> coeffs_ph, coeffs_pT;

  TabularDataSet() { tables_loaded = false; }

  void write_tables(const std::string &path_to_tables);

  void load_tables(const std::string &path_to_tables,
                   shared_ptr<CoolProp::AbstractState> &AS);

  void build_tables(shared_ptr<CoolProp::AbstractState> &AS);

  void build_coeffs(SinglePhaseGriddedTableData &table,
                    std::vector<std::vector<CellCoeffs>> &coeffs);
};

class TabularDataLibrary {
private:
  std::map<std::string, TabularDataSet> data;

public:
  TabularDataLibrary(){};
  std::string path_to_tables(shared_ptr<CoolProp::AbstractState> &AS) {
    std::vector<std::string> fluids = AS->fluid_names();
    std::vector<CoolPropDbl> fractions = AS->get_mole_fractions();
    std::vector<std::string> components;
    for (std::size_t i = 0; i < fluids.size(); ++i) {
      components.push_back(
          format(""%s[%0.10Lf]"", fluids[i].c_str(), fractions[i]));
    }
    std::string table_directory = get_home_dir() + ""/.CoolProp/Tables/"";
    std::string alt_table_directory =
        get_config_string(ALTERNATIVE_TABLES_DIRECTORY);
    if (!alt_table_directory.empty()) {
      table_directory = alt_table_directory;
    }
    return table_directory + AS->backend_name() + ""("" +
           strjoin(components, ""&"") + "")"";
  }"
HiPhish-XeenTools-ee7c26c/Source/dat/dat_tool.c	Read sprite information form a DAT file.	2	"int xeen_read_sprite_info(FILE *fp, long o, int i, XeenSpriteFrameInfo *info) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
  } error = SUCCESS;
  uint8_t bytes[3 * XEEN_SPRITE_DIRECTIONS];

  if (!fp || !info) {
    error = INVALID_ARGS;
    goto end;
  }

  if (fseek(fp, o + i * 3 * XEEN_SPRITE_DIRECTIONS, SEEK_SET) != 0) {
    error = FREAD_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), 12, fp) != 12 * sizeof(uint8_t)) {
    error = FREAD_FAIL;
    goto end;
  }

  *info = (XeenSpriteFrameInfo){
      .first =
          {
              [XEEN_SPRITE_FRONT] =
                  bytes[0 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_FRONT],
              [XEEN_SPRITE_LEFT] =
                  bytes[0 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_LEFT],
              [XEEN_SPRITE_BACK] =
                  bytes[0 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_BACK],
              [XEEN_SPRITE_RIGHT] =
                  bytes[0 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_RIGHT],
          },
      .flip =
          {
              [XEEN_SPRITE_FRONT] =
                  bytes[1 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_FRONT],
              [XEEN_SPRITE_LEFT] =
                  bytes[1 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_LEFT],
              [XEEN_SPRITE_BACK] =
                  bytes[1 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_BACK],
              [XEEN_SPRITE_RIGHT] =
                  bytes[1 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_RIGHT],
          },
      .last =
          {
              [XEEN_SPRITE_FRONT] =
                  bytes[2 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_FRONT],
              [XEEN_SPRITE_LEFT] =
                  bytes[2 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_LEFT],
              [XEEN_SPRITE_BACK] =
                  bytes[2 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_BACK],
              [XEEN_SPRITE_RIGHT] =
                  bytes[2 * XEEN_SPRITE_DIRECTIONS + XEEN_SPRITE_RIGHT],
          },
  };

end:
  return error;
}"
darktable-org-darktable-32fab21/src/iop/channelmixer.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""swap R and B""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){
          {0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 0, 0}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""swap G and B""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){
          {0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 0}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""color contrast boost""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0.8, 1, 0, 0, 0},
                                      {0, 0, 0.1, 0, 1, 0, 0},
                                      {0, 0, 0.1, 0, 0, 1, 0}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""color details boost""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0.1, 1, 0, 0, 0},
                                      {0, 0, 0.8, 0, 1, 0, 0},
                                      {0, 0, 0.1, 0, 0, 1, 0}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""color artifacts boost""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0.1, 1, 0, 0, 0},
                                      {0, 0, 0.1, 0, 1, 0, 0},
                                      {0, 0, 0.800, 0, 0, 1, 0}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""B/W luminance-based""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 1, 0, 0, 0.21},
                                      {0, 0, 0, 0, 1, 0, 0.72},
                                      {0, 0, 0, 0, 0, 1, 0.07}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""B/W artifacts boost""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 1, 0, 0, -0.275},
                                      {0, 0, 0, 0, 1, 0, -0.275},
                                      {0, 0, 0, 0, 0, 1, 1.275}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""B/W smooth skin""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 1, 0, 0, 1.0},
                                      {0, 0, 0, 0, 0, 1, 0.325},
                                      {0, 0, 0, 0, 0, 0, -0.4}},
      sizeof(dt_iop_channelmixer_params_t), 1);
  dt_gui_presets_add_generic(
      _(""B/W blue artifacts reduce""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.4},
                                      {0, 0, 0, 0, 0, 0, 0.750},
                                      {0, 0, 0, 0, 0, 0, -0.15}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Ilford Delta 100-400""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.21},
                                      {0, 0, 0, 0, 0, 0, 0.42},
                                      {0, 0, 0, 0, 0, 0, 0.37}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Ilford Delta 3200""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.31},
                                      {0, 0, 0, 0, 0, 0, 0.36},
                                      {0, 0, 0, 0, 0, 0, 0.33}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Ilford FP4""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.28},
                                      {0, 0, 0, 0, 0, 0, 0.41},
                                      {0, 0, 0, 0, 0, 0, 0.31}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Ilford HP5""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.23},
                                      {0, 0, 0, 0, 0, 0, 0.37},
                                      {0, 0, 0, 0, 0, 0, 0.40}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Ilford SFX""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.36},
                                      {0, 0, 0, 0, 0, 0, 0.31},
                                      {0, 0, 0, 0, 0, 0, 0.33}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Kodak T-Max 100""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.24},
                                      {0, 0, 0, 0, 0, 0, 0.37},
                                      {0, 0, 0, 0, 0, 0, 0.39}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Kodak T-max 400""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.27},
                                      {0, 0, 0, 0, 0, 0, 0.36},
                                      {0, 0, 0, 0, 0, 0, 0.37}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  dt_gui_presets_add_generic(
      _(""B/W Kodak Tri-X 400""), self->op, self->version(),
      &(dt_iop_channelmixer_params_t){{0, 0, 0, 0, 0, 0, 0.25},
                                      {0, 0, 0, 0, 0, 0, 0.35},
                                      {0, 0, 0, 0, 0, 0, 0.40}},
      sizeof(dt_iop_channelmixer_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
moehriegitt-hob3l-40cfda8/src/dict-test.c	Unit tests for dictionary data structure	2	"extern void cp_dict_test(void) {
  cp_dict_t *r = NULL;
  TEST_EQ(cp_dict_find((size_t[1]){50}, r, cmp_num_f, NULL), NULL);

  TEST_EQ(cp_dict_insert(&num_new(50)->node, &r, cmp_num, NULL, 0), NULL);

  cp_dict_t *r50;
  TEST_NE((r50 = cp_dict_find((size_t[1]){50}, r, cmp_num_f, NULL)), NULL);

  TEST_EQ(num_value(r50), 50);
  TEST_EQ(dict_size(r), 1);

  TEST_EQ(cp_dict_insert(&num_new(20)->node, &r, cmp_num, NULL, 0), NULL);
  TEST_EQ(dict_size(r), 2);

  TEST_EQ(cp_dict_insert(&num_new(60)->node, &r, cmp_num, NULL, 0), NULL);
  TEST_EQ(dict_size(r), 3);

  TEST_EQ(cp_dict_insert(&num_new(70)->node, &r, cmp_num, NULL, 0), NULL);
  TEST_EQ(dict_size(r), 4);

  TEST_EQ(cp_dict_insert(&num_new(80)->node, &r, cmp_num, NULL, 0), NULL);
  TEST_EQ(dict_size(r), 5);

  TEST_EQ(cp_dict_insert(&num_new(90)->node, &r, cmp_num, NULL, 0), NULL);
  TEST_EQ(dict_size(r), 6);

  cp_dict_t *r20;
  TEST_NE((r20 = cp_dict_min(r)), NULL);
  TEST_EQ(num_value(r20), 20);

  TEST_NE((r50 = cp_dict_next(r20)), NULL);
  TEST_EQ(num_value(r50), 50);

  cp_dict_t *r60;
  TEST_NE((r60 = cp_dict_next(r50)), NULL);
  TEST_EQ(num_value(r60), 60);

  cp_dict_t *r70;
  TEST_NE((r70 = cp_dict_next(r60)), NULL);
  TEST_EQ(num_value(r70), 70);

  cp_dict_t *r80;
  TEST_NE((r80 = cp_dict_next(r70)), NULL);
  TEST_EQ(num_value(r80), 80);

  cp_dict_t *r90;
  TEST_NE((r90 = cp_dict_next(r80)), NULL);
  TEST_EQ(num_value(r90), 90);

  TEST_VOID(cp_dict_remove(r60, &r));
  TEST_NE(r, NULL);
  TEST_EQ(dict_size(r), 5);

  TEST_EQ(cp_dict_next(r60), NULL);
  TEST_EQ(cp_dict_prev(r60), NULL);

  TEST_NE((r70 = cp_dict_next(r50)), NULL);
  TEST_EQ(num_value(r70), 70);

  TEST_VOID(cp_dict_remove(r, &r));
  TEST_NE(r, NULL);
  TEST_EQ(dict_size(r), 4);

  TEST_VOID(cp_dict_remove(r, &r));
  TEST_NE(r, NULL);
  TEST_EQ(dict_size(r), 3);

  TEST_VOID(cp_dict_remove(r, &r));
  TEST_NE(r, NULL);
  TEST_EQ(dict_size(r), 2);

  TEST_VOID(cp_dict_remove(r, &r));
  TEST_NE(r, NULL);
  TEST_EQ(dict_size(r), 1);

  TEST_VOID(cp_dict_remove(r, &r));
  TEST_EQ(r, NULL);
  TEST_EQ(dict_size(r), 0);

  cp_dict_insert(r20, &r, cmp_num, NULL, 0);
  cp_dict_insert(r50, &r, cmp_num, NULL, 0);
  cp_dict_insert(r60, &r, cmp_num, NULL, 0);
  cp_dict_insert(r70, &r, cmp_num, NULL, 0);
  cp_dict_insert(r80, &r, cmp_num, NULL, 0);
  cp_dict_insert(r90, &r, cmp_num, NULL, 0);
  TEST_EQ(dict_size(r), 6);
  TEST_EQ((cp_dict_remove(r20, &r), dict_size(r)), 5);
  TEST_EQ((cp_dict_remove(r50, &r), dict_size(r)), 4);
  TEST_EQ((cp_dict_remove(r60, &r), dict_size(r)), 3);
  TEST_EQ((cp_dict_remove(r70, &r), dict_size(r)), 2);
  TEST_EQ((cp_dict_remove(r80, &r), dict_size(r)), 1);
  TEST_EQ((cp_dict_remove(r90, &r), dict_size(r)), 0);

  cp_dict_insert(r60, &r, cmp_num, NULL, 0);
  cp_dict_insert(r90, &r, cmp_num, NULL, 0);
  cp_dict_insert(r80, &r, cmp_num, NULL, 0);
  cp_dict_insert(r20, &r, cmp_num, NULL, 0);
  cp_dict_insert(r70, &r, cmp_num, NULL, 0);
  cp_dict_insert(r50, &r, cmp_num, NULL, 0);
  TEST_EQ(dict_size(r), 6);
  TEST_EQ((cp_dict_remove(r80, &r), dict_size(r)), 5);
  TEST_EQ((cp_dict_remove(r60, &r), dict_size(r)), 4);
  TEST_EQ((cp_dict_remove(r70, &r), dict_size(r)), 3);
  TEST_EQ((cp_dict_remove(r90, &r), dict_size(r)), 2);
  TEST_EQ((cp_dict_remove(r20, &r), dict_size(r)), 1);
  TEST_EQ((cp_dict_remove(r50, &r), dict_size(r)), 0);

  cp_dict_t *a[] = {r20, r50, r60, r70, r80, r90};
  for (cp_size_each(i, 10)) {
    for (cp_size_each(k, 2 * cp_countof(a))) {
      size_t u = irand(cp_countof(a));
      size_t v = irand(cp_countof(a));
      CP_SWAP(&a[u], &a[v]);
    }

    fprintf(stderr, ""INSERT:"");
    for (cp_arr_each(k, a)) {
      fprintf(stderr, "" %"" CP_Z ""u"", CP_BOX_OF(a[k], num_t, node)->value);
      cp_dict_insert(a[k], &r, cmp_num, NULL, 0);
    }
    fprintf(stderr, ""\n"");
    TEST_EQ(dict_size(r), cp_countof(a));

    for (cp_size_each(k, 2 * cp_countof(a))) {
      size_t u = irand(cp_countof(a));
      size_t v = irand(cp_countof(a));
      CP_SWAP(&a[u], &a[v]);
    }
    fprintf(stderr, ""REMOVE:"");
    for (cp_arr_each(k, a)) {
      fprintf(stderr, "" %"" CP_Z ""u"", CP_BOX_OF(a[k], num_t, node)->value);
    }
    fprintf(stderr, ""\n"");
    for (cp_arr_each(k, a)) {
      TEST_EQ((cp_dict_remove(a[k], &r), dict_size(r)), cp_countof(a) - k - 1);
    }
  }
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = cpu_to_le32((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
EvolBioInf-andi-e92b453/src/sequence.c	Frees the array and all sequences stored within.	2	"void dsa_free(dsa_t *A) {
  size_t i;
  for (i = 0; i < A->size; i++) {
    seq_free(&A->data[i]);
  }

  free(A->data);
  *A = (dsa_t){};
}"
darktable-org-darktable-32fab21/src/iop/scalepixels.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_scalepixels_params_t tmp =
      (dt_iop_scalepixels_params_t){.pixel_aspect_ratio = 1.0f};

  if (!self->dev)
    goto end;

  const dt_image_t *const image = &(self->dev->image_storage);

  tmp.pixel_aspect_ratio = image->pixel_aspect_ratio;

  self->default_enabled =
      (!isnan(tmp.pixel_aspect_ratio) && tmp.pixel_aspect_ratio > 0.0f &&
       tmp.pixel_aspect_ratio != 1.0f);

  self->hide_enable_button = !self->default_enabled;

end:
  memcpy(self->params, &tmp, sizeof(dt_iop_scalepixels_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_scalepixels_params_t));
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Creates / finds a pattern channel, adds a reference count and locks it."	2	"static channel_s *fio_channel_match_dup_lock(fio_str_info_s name,
                                             fio_match_fn match) {
  channel_s ch = (channel_s){
      .name = name.data,
      .name_len = name.len,
      .parent = &fio_postoffice.patterns,
      .match = match,
      .ref = 8,
  };
  uint64_t hashed_name = FIO_HASH_FN(
      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);
  channel_s *ch_p =
      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.patterns);
  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {
    fio_pubsub_on_channel_create(ch_p);
  }
  return ch_p;
}"
ARM-software-scmi-tests-24dd373/protocols/sensor/sensor_exe.c	The function is called by the test engine before sending the sensor description get command and testing the received values.	3	"void arm_scmi_custom_tester_sensor_description_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {

  uint32_t start_desc_index;
  uint32_t num_sensor_flags;
  uint32_t remaining_sensor_desc;
  uint32_t sensor_desc_returned;
  uint32_t rcv_u, exp_u;
  uint32_t check_or_print;
  int total_sensor_desc;
  uint32_t offset;
  char *exp_s;
  struct arm_scmi_sensor_descriptor *sensor_desc;
  uint32_t sensor_idx, current_idx;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  char *sensor_name;
  struct arm_scmi_sensor_expected *se = sensor_expected;
  enum test_status res;
  int error_code;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_sensor_description_get,
                           desc_index)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_description_get,
                                       desc_index)] =
        sensor_protocol_data.num_sensors;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    start_desc_index = 0;
    total_sensor_desc = 0;
    do {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_description_get,
                                         desc_index)] = start_desc_index;

      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      num_sensor_flags = RETURN_VAL(
          received, struct arm_scmi_sensor_description_get, num_sensor_flags);

      remaining_sensor_desc = arm_scmi_get_norm_bits(
          num_sensor_flags, SNR_NUMBER_REMAIN_SNR_DESC_HIGH,
          SNR_NUMBER_REMAIN_SNR_DESC_LOW);
      arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                    remaining_sensor_desc,
                                    ""NUMBER OF REMAINING SENSOR DESCRIPTORS"");

      rcv_u =
          arm_scmi_get_norm_bits(num_sensor_flags, SNR_NUM_SNR_FLAG_RESV_HIGH,
                                 SNR_NUM_SNR_FLAG_RESV_LOW);
      arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, CHECK, RESERVED,
                                    rcv_u, ""RESERVED BITS"");

      sensor_desc_returned = arm_scmi_get_norm_bits(
          num_sensor_flags, SNR_NUMBER_SNR_DESC_HIGH, SNR_NUMBER_SNR_DESC_LOW);
      check_or_print = (remaining_sensor_desc == 0) ? CHECK : PRINT;
      arm_scmi_check_and_report_dec(
          test_stats, expected_flags_mask, check_or_print,
          sensor_expected->number_sensors, sensor_desc_returned,
          ""NUMBER OF SENSOR DESCRIPTORS"");
      offset = OFFSET_BYTES_RET(struct arm_scmi_sensor_description_get,
                                sensor_descriptors) +
               offsetof(struct arm_scmi_sensor_descriptor, sensor_id);
      sensor_desc =
          (struct arm_scmi_sensor_descriptor *)((uint8_t *)received.payload +
                                                offset);

      for (sensor_idx = 0; sensor_idx < sensor_desc_returned; ++sensor_idx) {

        current_idx = total_sensor_desc + sensor_idx;

        check_or_print =
            (sensor_desc->sensor_id == current_idx) ? CHECK : PRINT;
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0,
                                      sensor_desc->sensor_id, ""SENSOR ID"");
        sensor_protocol_data.sensor_id[current_idx] = sensor_desc->sensor_id;

        res = INFO;
        rcv_u = arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_low,
                                       SNR_DESC_ATTRLOW_ASYNC_READ_SUPPORT,
                                       SNR_DESC_ATTRLOW_ASYNC_READ_SUPPORT);
        snprintf(name, NUM_ELEMS(name), ""ASYNCHRONOUS SENSOR READ SUPPORT"");
        if (check_or_print && (current_idx < se->number_sensors) &&
            (se->asynchronous_sensor_read_support != NULL) &&
            (expected_flags_mask &
             LEFT_SHIFT(SENSOR_ASYNCHRONOUS_READ_SUPPORT))) {
          exp_u = se->asynchronous_sensor_read_support[current_idx];
          res = (exp_u == rcv_u) ? PASSED : FAILED;
          snprintf(description, NUM_ELEMS(description),
                   ""Expected: %d, Received: %d"", exp_u, rcv_u);
        }
        if ((res == PASSED) || (res == INFO)) {
          snprintf(description, NUM_ELEMS(description), ""Received: %d"", rcv_u);
        }
        arm_scmi_log_test_result(test_stats, res, name, description);

        res = INFO;
        rcv_u = arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_low,
                                       SNR_DESC_ATTRLOW_NUM_TRIPPOINT_SPRT_HIGH,
                                       SNR_DESC_ATTRLOW_NUM_TRIPPOINT_SPRT_LOW);
        sensor_protocol_data.snsr_trip_points_supported[current_idx] = rcv_u;
        snprintf(name, NUM_ELEMS(name), ""NUMBER OF TRIP POINTS SUPPORTED"");
        if (check_or_print && (current_idx < se->number_sensors) &&
            (se->number_of_trip_points_supported != NULL) &&
            (expected_flags_mask &
             LEFT_SHIFT(SENSOR_NUMBER_OF_TRIP_POINTS_SUPPORTED))) {
          exp_u = se->number_of_trip_points_supported[current_idx];
          res = (exp_u == rcv_u) ? PASSED : FAILED;
          snprintf(description, NUM_ELEMS(description),
                   ""Expected: %d, Received: %d"", exp_u, rcv_u);
        }
        if ((res == PASSED) || (res == INFO)) {
          snprintf(description, NUM_ELEMS(description), ""Received: %d"", rcv_u);
        }
        arm_scmi_log_test_result(test_stats, res, name, description);

        rcv_u =
            arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_high,
                                   SNR_DESC_ATTRHIGH_UPDATE_INTERVAL_SEC_HIGH,
                                   SNR_DESC_ATTRHIGH_UPDATE_INTERVAL_SEC_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0, rcv_u,
                                      ""SENSOR UPDATE INTERVAL/sec"");

        rcv_u =
            arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_high,
                                   SNR_DESC_ATTRHIGH_UPDATE_INTERVAL_MULT_HIGH,
                                   SNR_DESC_ATTRHIGH_UPDATE_INTERVAL_MULT_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0, rcv_u,
                                      ""SENSOR UPDATE INTERVAL/mult"");

        rcv_u = arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_high,
                                       SNR_DESC_ATTRHIGH_MULTIPLIER_HIGH,
                                       SNR_DESC_ATTRHIGH_MULTIPLIER_LOW);
        arm_scmi_check_and_report_dec(test_stats, ALL_BITS_SET, PRINT, 0, rcv_u,
                                      ""SENSOR TYPE UNIT MULTIPLIER"");

        res = INFO;
        rcv_u = arm_scmi_get_norm_bits(sensor_desc->sensor_attributes_high,
                                       SNR_DESC_ATTRHIGH_SNR_TYPE_HIGH,
                                       SNR_DESC_ATTRHIGH_SNR_TYPE_LOW);
        snprintf(name, NUM_ELEMS(name), ""SENSOR TYPE"");
        if (check_or_print && (current_idx < se->number_sensors) &&
            (se->sensor_type != NULL) &&
            (expected_flags_mask & LEFT_SHIFT(SENSOR_TYPE))) {
          exp_u = se->sensor_type[current_idx];
          res = (exp_u == rcv_u) ? PASSED : FAILED;
          snprintf(description, NUM_ELEMS(description),
                   ""Expected: %d, Received: %d"", exp_u, rcv_u);
        }
        if ((res == PASSED) || (res == INFO)) {
          snprintf(description, NUM_ELEMS(description), ""%d"", rcv_u);
        }
        arm_scmi_log_test_result(test_stats, res, name, description);

        res = INFO;
        sensor_name = (char *)sensor_desc->sensor_name;
        snprintf(name, NUM_ELEMS(name), ""SENSOR NAME"");
        if (check_or_print && (current_idx < se->number_sensors) &&
            (se->sensor_name != NULL) &&
            (expected_flags_mask & LEFT_SHIFT(SENSOR_TYPE))) {
          exp_s = se->sensor_name[current_idx];
          res = sensor_name == exp_s;
          snprintf(description, NUM_ELEMS(description),
                   ""Expected: '%s', Received: '%s'"", exp_s, sensor_name);
        }
        if ((res == PASSED) || (res == INFO)) {
          snprintf(description, NUM_ELEMS(description), ""'%s'"", sensor_name);
        }
        arm_scmi_log_test_result(test_stats, res, name, description);

        sensor_desc = (struct arm_scmi_sensor_descriptor
                           *)((uint8_t *)sensor_desc->sensor_name +
                              sizeof(sensor_desc->sensor_name));
        arm_scmi_log(&protocol_execution_context->test_stats, ""\n"");
      }
      total_sensor_desc += sensor_desc_returned;
      start_desc_index += sensor_desc_returned;
    } while (remaining_sensor_desc > 0);
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/MouseHost/MouseHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs."	1	"void Mouse_HID_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Mouse Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    ReadNextReport();

    break;
  }
}"
ahmedsaieed-OpenBTS-0f23160/GSM/GSML1FEC.h	Returns true if the channel is in use for a transaction. Returns true if T3111 is not active.	2	"virtual ~L1FEC(){};

void writeLowSide(const RxBurst &burst) {
  assert(mDecoder);
  mDecoder->writeLowSide(burst);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/HIDClassHost.c	"Switches the attached HID device's reporting protocol over to the standard Report protocol mode. This also retrieves and parses the device's HID report descriptor, so that the size of each report can be determined in advance."	1	"uint8_t
HID_Host_SetReportProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  uint8_t HIDReportData[HIDInterfaceInfo->State.HIDReportSize];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (HID_DTYPE_Report << 8),
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = HIDInterfaceInfo->State.HIDReportSize,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(HIDReportData)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (HIDInterfaceInfo->State.UsingBootProtocol) {
    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetProtocol,
        .wValue = 1,
        .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
        .wLength = 0,
    };

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful)
      return ErrorCode;

    HIDInterfaceInfo->State.UsingBootProtocol = false;
  }

  if (HIDInterfaceInfo->Config.HIDParserData == NULL)
    return HID_ERROR_LOGICAL;

  if ((ErrorCode = USB_ProcessHIDReport(
           HIDReportData, HIDInterfaceInfo->State.HIDReportSize,
           HIDInterfaceInfo->Config.HIDParserData)) != HID_PARSE_Successful) {
    return HID_ERROR_LOGICAL | ErrorCode;
  }

  uint16_t LargestReportSizeBits =
      HIDInterfaceInfo->Config.HIDParserData->LargestReportSizeBits;
  HIDInterfaceInfo->State.LargestReportSize =
      (LargestReportSizeBits >> 3) + ((LargestReportSizeBits & 0x07) != 0);

  return 0;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/ClassDriver/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t *const RNDISInterfaceInfo) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  Ethernet_Frame_Info_t *FrameOUT = &RNDISInterfaceInfo->State.FrameOUT;

  if (FrameOUT->FrameInBuffer)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT->FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                                               sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                               sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
                         ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT->FrameLength = PacketSize;
      FrameOUT->FrameInBuffer = true;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/CDCHost/CDCHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read in data received from the attached CDC device and print it to the serial port."	1	"TASK(USB_CDC_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""CDC Device Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    Pipe_SelectPipe(CDC_DATAPIPE_IN);

    if (Pipe_IsINReceived()) {

      if (Pipe_IsReadWriteAllowed()) {

        uint16_t BufferLength = Pipe_BytesInPipe();
        uint8_t Buffer[BufferLength];

        Pipe_Read_Stream_LE(Buffer, BufferLength);

        for (uint16_t BufferByte = 0; BufferByte < BufferLength; BufferByte++)
          putchar(Buffer[BufferByte]);
      }

      Pipe_ClearIN();
    }

    Pipe_SelectPipe(CDC_NOTIFICATIONPIPE);
    Pipe_Unfreeze();

    if (Pipe_IsINReceived()) {

      Pipe_ClearIN();
    }

    Pipe_Freeze();

    break;
  }
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/tls-cipher-test.c	"In this test case, establish a security context and check that the cipher used does not contain ""NULL"" if encrypted is true, and does contain ""NULL"" if encrypted is false"	1	"cipher_test(bool encrypted) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;
  const char *why = """";

  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, GSS_C_NO_NAME,
        GSS_C_NO_OID, encrypted ? GSS_C_CONF_FLAG : 0, 0,
        GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token, NULL,
        &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token,
          &(OM_uint32){encrypted ? GSS_C_CONF_FLAG : 0}, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, accept_context, (gss_OID_desc *)tls_cipher_oid, &data);

    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 1) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    if (encrypted && strstr(data->elements[0].value, ""NULL"") != NULL) {
      why = globus_common_create_string(""expected encryption, got %s"",
                                        data->elements[0].value);
      result = false;
      goto fail;
    } else if (!encrypted && strstr(data->elements[0].value, ""NULL"") == NULL) {
      why = globus_common_create_string(""didn't expect encryption, got %s"",
                                        data->elements[0].value);
      result = false;
      goto fail;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }

  if (!result) {
    fprintf(stderr, ""Failed because %s\n"", why);
  }

  return result;
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	"Ungrab a currently FocusIn grabbed device and grab the device on the given window. If the win given is the NoneWin, the device is ungrabbed if applicable and FALSE is returned."	2	"ActivateFocusInGrab(DeviceIntPtr dev, WindowPtr old, WindowPtr win) {
  BOOL rc = FALSE;
  DeviceEvent event;

  if (dev->deviceGrab.grab) {
    if (!dev->deviceGrab.fromPassiveGrab ||
        dev->deviceGrab.grab->type != XI_FocusIn ||
        dev->deviceGrab.grab->window == win ||
        IsParent(dev->deviceGrab.grab->window, win))
      return FALSE;
    DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveUngrab);
    (*dev->deviceGrab.DeactivateGrab)(dev);
  }

  if (win == NoneWin || win == PointerRootWin)
    return FALSE;

  event = (DeviceEvent){.header = ET_Internal,
                        .type = ET_FocusIn,
                        .length = sizeof(DeviceEvent),
                        .time = GetTimeInMillis(),
                        .deviceid = dev->id,
                        .sourceid = dev->id,
                        .detail.button = 0};
  rc = (CheckPassiveGrabsOnWindow(win, dev, (InternalEvent *)&event, FALSE,
                                  TRUE) != NULL);
  if (rc)
    DoEnterLeaveEvents(dev, dev->id, old, win, XINotifyPassiveGrab);
  return rc;
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Vereint zwei 32-bit Vektoren auf einen mit 16  Verhalten fr Werte, die mit 16 Bit nicht dargestellt werden knnen, sind nicht definiert."	2	"static inline vec_ushort8 simd_conv32to16(const vec_uint4 a,
                                          const vec_uint4 b) {
#if defined(__SSE__)
  return (vec_ushort8)_mm_packs_epi32((__m128i)a, (__m128i)b);
#elif defined(__VEC__)
  return vec_packsu(a, b);
#elif defined(__NEON__)
  return vcombine_u16(vmovn_u32(a), vmovn_u32(b));
#else
  const int *aI = (const int *)&a;
  const int *bI = (const int *)&b;

  return (vec_ushort8){(unsigned short)aI[0], (unsigned short)aI[1],
                       (unsigned short)aI[2], (unsigned short)aI[3],
                       (unsigned short)bI[0], (unsigned short)bI[1],
                       (unsigned short)bI[2], (unsigned short)bI[3]};
#endif
}"
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance levels set command and testing the received values.	2	"void arm_scmi_custom_test_performance_levels_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_levels_set, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                       performance_level)] =
        ptr_data->domain_runtime_values[0].range_max;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_performance_levels_set,
                                  performance_level)) {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                         performance_level)] =
          ptr_data->domain_runtime_values[domain_id].range_max + 1;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LEVEL_SET,
              PERFORMANCE_DOMAIN_ATTR_LEVEL_SET) == 1
              ? SCMI_STATUS_OUT_OF_RANGE
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  } else {

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                         domain_id)] = domain_id;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_levels_set,
                                         performance_level)] =
          ptr_data->domain_runtime_values[domain_id].range_max;
      test_case->status =
          arm_scmi_get_norm_bits(
              ptr_data->domain_runtime_values[domain_id].attributes,
              PERFORMANCE_DOMAIN_ATTR_LEVEL_SET,
              PERFORMANCE_DOMAIN_ATTR_LEVEL_SET) == 1
              ? SCMI_STATUS_SUCCESS
              : SCMI_STATUS_DENIED;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        ptr_data->domain_runtime_values[domain_id].current_level =
            test_case->parameters[OFFSET_PARAM(
                struct arm_scmi_performance_levels_set, performance_level)];
        ptr_data->domain_runtime_values[domain_id].current_level_known = true;
      }
    }
  }
}"
tvlabs-edge264-7e3927e/edge264.c	"This function sets the context pointers to the frame about to be decoded, and fills the context caches with useful values."	2	"static void initialise_decoding_context(Edge264_stream *e) {
  ctx->x = 0;
  ctx->y = 0;
  ctx->plane_Y = e->DPB + e->currPic * e->frame_size;
  ctx->plane_Cb = ctx->plane_Y + e->plane_size_Y;
  int MbWidthC = ctx->ps.ChromaArrayType < 3 ? 8 : 16;
  ctx->col_offset_C = ctx->ps.BitDepth_C == 8 ? MbWidthC : MbWidthC * 2;
  ctx->row_offset_C =
      ctx->ps.ChromaArrayType == 1 ? e->stride_C * 7 : e->stride_C * 15;
  mb = (Edge264_macroblock *)(ctx->plane_Cb + e->plane_size_C * 2 +
                              (ctx->ps.width / 16 + 2) * sizeof(*mb));

  int cY = (1 << ctx->ps.BitDepth_Y) - 1;
  int cC = (1 << ctx->ps.BitDepth_C) - 1;
  ctx->clip_Y = (v8hi){cY, cY, cY, cY, cY, cY, cY, cY};
  ctx->clip_C = (v8hi){cC, cC, cC, cC, cC, cC, cC, cC};

  int offsetA = sizeof(*mb);
  int offsetB = (ctx->ps.width / 16 + 1) * sizeof(*mb);
  ctx->A4x4_8[0] = (v8hi){5 - offsetA, 0, 7 - offsetA, 2, 1, 4, 3, 6};
  ctx->A4x4_8[1] = (v8hi){13 - offsetA, 8, 15 - offsetA, 10, 9, 12, 11, 14};
  ctx->B4x4_8[0] = (v4si){10 - offsetB, 11 - offsetB, 0, 1};
  ctx->B4x4_8[1] = (v4si){14 - offsetB, 15 - offsetB, 4, 5};
  ctx->B4x4_8[2] = (v4si){2, 3, 8, 9};
  ctx->B4x4_8[3] = (v4si){6, 7, 12, 13};
  ctx->A8x8_8[0] = (v4hi){1 - offsetA, 0, 3 - offsetA, 2};
  ctx->B8x8_8[0] = (v4si){2 - offsetB, 3 - offsetB, 0, 1};
  if (ctx->ps.ChromaArrayType == 1) {
    ctx->A4x4_8[2] = (v8hi){17 - offsetA, 16, 19 - offsetA, 18,
                            21 - offsetA, 20, 23 - offsetA, 22};
    ctx->B4x4_8[4] = (v4si){18 - offsetB, 19 - offsetB, 16, 17};
    ctx->B4x4_8[5] = (v4si){22 - offsetB, 23 - offsetB, 20, 21};
  } else if (ctx->ps.ChromaArrayType == 2) {
    ctx->A4x4_8[2] = (v8hi){17 - offsetA, 16, 19 - offsetA, 18,
                            21 - offsetA, 20, 23 - offsetA, 22};
    ctx->A4x4_8[3] = (v8hi){25 - offsetA, 24, 27 - offsetA, 26,
                            29 - offsetA, 28, 31 - offsetA, 30};
    ctx->B4x4_8[4] = (v4si){22 - offsetB, 23 - offsetB, 16, 17};
    ctx->B4x4_8[5] = (v4si){18, 19, 20, 21};
    ctx->B4x4_8[6] = (v4si){30 - offsetB, 31 - offsetB, 24, 25};
    ctx->B4x4_8[7] = (v4si){26, 27, 28, 29};
  } else if (ctx->ps.ChromaArrayType == 3) {
    v8hi h16 = {16, 16, 16, 16, 16, 16, 16, 16};
    for (int i = 2; i < 6; i++)
      ctx->A4x4_8[i] = ctx->A4x4_8[i - 2] + h16;
    v4si s16 = {16, 16, 16, 16};
    for (int i = 4; i < 12; i++)
      ctx->B4x4_8[i] = ctx->B4x4_8[i - 4] + s16;
    ctx->A8x8_8[1] = (v4hi){5 - offsetA, 4, 7 - offsetA, 6};
    ctx->A8x8_8[2] = (v4hi){9 - offsetA, 8, 11 - offsetA, 10};
    ctx->B8x8_8[1] = (v4si){6 - offsetB, 7 - offsetB, 4, 5};
    ctx->B8x8_8[2] = (v4si){10 - offsetB, 11 - offsetB, 8, 9};
  }

  for (int i = 0; i < 16; i++) {
    int x = (i << 2 & 4) | (i << 1 & 8);
    int y = (i << 1 & 4) | (i & 8);
    ctx->plane_offsets[i] =
        y * e->stride_Y + (ctx->ps.BitDepth_Y == 8 ? x : x * 2);
    if (ctx->ps.ChromaArrayType == 3) {
      ctx->plane_offsets[16 + i] =
          y * e->stride_C + (ctx->ps.BitDepth_C == 8 ? x : x * 2);
      ctx->plane_offsets[32 + i] = ctx->plane_offsets[16 + i] + e->plane_size_C;
    }
  }
  for (int i = 0;
       ctx->ps.ChromaArrayType < 3 && i < ctx->ps.ChromaArrayType * 4; i++) {
    int x = i << 2 & 4;
    int y = i << 1 & 12;
    ctx->plane_offsets[16 + i] =
        y * e->stride_C + (ctx->ps.BitDepth_C == 8 ? x : x * 2);
    ctx->plane_offsets[16 + ctx->ps.ChromaArrayType * 4 + i] =
        ctx->plane_offsets[16 + i] + e->plane_size_C;
  }

  v4hi h4 = {4, 4, 4, 4};
  ctx->A8x8_v[0] = (v4hi){1 - (int)sizeof(*mb), 0, 3 - (int)sizeof(*mb), 2};
  ctx->A8x8_v[1] = ctx->A8x8_v[0] + h4;
  ctx->A8x8_v[2] = ctx->A8x8_v[1] + h4;
  v4si s4 = {4, 4, 4, 4};
  ctx->B8x8_v[0] = (v4si){2 - offsetB, 3 - offsetB, 0, 1};
  ctx->B8x8_v[1] = ctx->B8x8_v[0] + s4;
  ctx->B8x8_v[2] = ctx->B8x8_v[1] + s4;
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  MP3DecContext *mp3 = s->priv_data;
  uint32_t v, spf;
  unsigned frames = 0;
  unsigned size = 0;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;
  int is_cbr;

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (avpriv_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  avio_skip(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1]);
  v = avio_rb32(s->pb);
  is_cbr = v == MKBETAG('I', 'n', 'f', 'o');
  if (v == MKBETAG('X', 'i', 'n', 'g') || is_cbr) {
    v = avio_rb32(s->pb);
    if (v & XING_FLAG_FRAMES)
      frames = avio_rb32(s->pb);
    if (v & XING_FLAG_SIZE)
      size = avio_rb32(s->pb);
    if (v & XING_FLAG_TOC)
      read_xing_toc(s, size,
                    av_rescale_q(frames, (AVRational){spf, c.sample_rate},
                                 st->time_base));
    if (v & 8)
      avio_skip(s->pb, 4);

    v = avio_rb32(s->pb);
    if (v == MKBETAG('L', 'A', 'M', 'E') || v == MKBETAG('L', 'a', 'v', 'f')) {
      avio_skip(s->pb, 21 - 4);
      v = avio_rb24(s->pb);
      mp3->start_pad = v >> 12;
      mp3->end_pad = v & 4095;
      st->skip_samples = mp3->start_pad + 528 + 1;
      av_log(s, AV_LOG_DEBUG, ""pad %d %d\n"", mp3->start_pad, mp3->end_pad);
    }
  }

  avio_seek(s->pb, base + 4 + 32, SEEK_SET);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (avio_rb16(s->pb) == 1) {

      avio_skip(s->pb, 4);
      size = avio_rb32(s->pb);
      frames = avio_rb32(s->pb);
    }
  }

  if (!frames && !size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (frames)
    st->duration =
        av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
  if (size && frames && !is_cbr)
    st->codec->bit_rate =
        av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);

  mp3->is_cbr = is_cbr;
  mp3->header_filesize = size;

  return 0;
}"
ikeydoherty-ui-tests-41140ce/src/popover.c	"Work out exactly where the popover needs to appear on screen This will try to account for all potential positions, using a fairly biased view of what the popover should do in each situation. Unlike a typical popover implementation, this relies on some information from the toplevel window on what edge it happens to be on."	2	"static void budgie_popover_compute_positition(BudgiePopover *self,
                                              GdkRectangle *target) {
  GdkRectangle widget_rect = {0};
  GtkPositionType tail_position = GTK_POS_BOTTOM;
  gint our_width = 0, our_height = 0;
  GtkStyleContext *style = NULL;
  int x = 0, y = 0, width = 0, height = 0;
  static const gchar *position_classes[] = {""top"", ""left"", ""right"", ""bottom""};
  const gchar *style_class = NULL;
  GdkRectangle display_geom = {0};

  budgie_popover_compute_widget_geometry(self->priv->relative_to, &widget_rect);

  gtk_window_get_size(GTK_WINDOW(self), &our_width, &our_height);

  budgie_popover_get_screen_for_widget(self->priv->relative_to, &display_geom);

  if (self->priv->policy == BUDGIE_POPOVER_POSITION_TOPLEVEL_HINT) {
    tail_position = budgie_popover_select_position_toplevel(self);
  } else {
    tail_position = budgie_popover_select_position_automatic(
        our_height, display_geom, widget_rect);
  }

  switch (tail_position) {
  case GTK_POS_BOTTOM:

    y = widget_rect.y - our_height;
    x = (widget_rect.x + (widget_rect.width / 2)) - (our_width / 2);
    g_object_set(self->priv->add_area, ""margin-top"", 5, ""margin-bottom"", 15,
                 ""margin-start"", 5, ""margin-end"", 5, NULL);
    style_class = ""bottom"";
    break;
  case GTK_POS_TOP:

    y = widget_rect.y + widget_rect.height + (TAIL_DIMENSION / 2);
    x = (widget_rect.x + (widget_rect.width / 2)) - (our_width / 2);
    g_object_set(self->priv->add_area, ""margin-top"", 10, ""margin-bottom"", 10,
                 ""margin-start"", 5, ""margin-end"", 5, NULL);
    style_class = ""top"";
    break;
  case GTK_POS_LEFT:

    y = (widget_rect.y + (widget_rect.height / 2)) - (our_height / 2);
    y += TAIL_DIMENSION / 4;
    x = widget_rect.x + widget_rect.width;
    g_object_set(self->priv->add_area, ""margin-top"", 5, ""margin-bottom"", 10,
                 ""margin-start"", 15, ""margin-end"", 5, NULL);
    style_class = ""left"";
    break;
  case GTK_POS_RIGHT:
    y = (widget_rect.y + (widget_rect.height / 2)) - (our_height / 2);
    y += TAIL_DIMENSION / 4;
    x = widget_rect.x - our_width;
    g_object_set(self->priv->add_area, ""margin-top"", 5, ""margin-bottom"", 10,
                 ""margin-start"", 5, ""margin-end"", 15, NULL);
    style_class = ""right"";
    break;
  default:
    break;
  }

  self->priv->tail.position = tail_position;
  budgie_popover_compute_tail(self);

  style = gtk_widget_get_style_context(GTK_WIDGET(self));
  for (guint i = 0; i < G_N_ELEMENTS(position_classes); i++) {
    gtk_style_context_remove_class(style, position_classes[i]);
  }

  gtk_style_context_add_class(style, style_class);

  static int pad_num = 1;

  if (x < display_geom.x) {
    self->priv->tail.x_offset += (x - (display_geom.x + pad_num));
    x -= (int)(self->priv->tail.x_offset);
  } else if ((x + our_width) >= display_geom.x + display_geom.width) {
    self->priv->tail.x_offset -=
        ((display_geom.x + display_geom.width) - (our_width + pad_num)) - x;
    x -= (int)(self->priv->tail.x_offset);
  }

  double display_tail_x = x + self->priv->tail.x + self->priv->tail.x_offset;
  double display_tail_y = y + self->priv->tail.y + self->priv->tail.y_offset;
  static double required_offset_x = TAIL_DIMENSION * 1.25;
  static double required_offset_y = TAIL_DIMENSION * 1.75;

  if (display_tail_x <= display_geom.x + required_offset_x) {
    self->priv->tail.x_offset +=
        (display_geom.x + required_offset_x) - display_tail_x;
  } else if (display_tail_x >=
             ((display_geom.x + display_geom.width) - required_offset_x)) {
    self->priv->tail.x_offset -= (display_tail_x + required_offset_x) -
                                 (display_geom.x + display_geom.width);
  }

  if (display_tail_y <= display_geom.y + required_offset_y) {
    self->priv->tail.y_offset +=
        (display_geom.y + required_offset_y) - display_tail_y;
  } else if (display_tail_y >=
             ((display_geom.y + display_geom.height) - required_offset_y)) {
    self->priv->tail.y_offset -= (display_tail_y + required_offset_y) -
                                 (display_geom.y + display_geom.height);
  }

  if (y < display_geom.y) {
    self->priv->tail.y_offset += (y - (display_geom.y + pad_num));
    y -= (int)(self->priv->tail.y_offset);
  } else if ((y + our_height) >= display_geom.y + display_geom.height) {
    self->priv->tail.y_offset -=
        ((display_geom.y + display_geom.height) - (our_height + pad_num)) - y;
    y -= (int)(self->priv->tail.y_offset);
  }

  *target = (GdkRectangle){.x = x, .y = y, .width = width, .height = height};
}"
merbanan-rtl_433-9ae2db7/src/pulse_detect.c	Demodulate On/Off Keying (OOK) and Frequency Shift Keying (FSK) from an envelope signal.	2	"int pulse_detect_package(pulse_detect_t *pulse_detect,
                         int16_t const *envelope_data, int16_t const *fm_data,
                         int len, int16_t level_limit, uint32_t samp_rate,
                         uint64_t sample_offset, pulse_data_t *pulses,
                         pulse_data_t *fsk_pulses) {
  int const samples_per_ms = samp_rate / 1000;
  pulse_detect_t *s = pulse_detect;
  s->ook_high_estimate = MAX(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);

  if (s->data_counter == 0) {

    pulses->start_ago += len;
    fsk_pulses->start_ago += len;
  }

  while (s->data_counter < len) {

    int16_t const am_n = envelope_data[s->data_counter];
    int16_t ook_threshold =
        s->ook_low_estimate + (s->ook_high_estimate - s->ook_low_estimate) / 2;
    if (level_limit != 0)
      ook_threshold = level_limit;
    int16_t const ook_hysteresis = ook_threshold / 8;

    switch (s->ook_state) {
    case PD_OOK_STATE_IDLE:
      if (am_n > (ook_threshold + ook_hysteresis) &&
          s->lead_in_counter > OOK_EST_LOW_RATIO) {

        pulse_data_clear(pulses);
        pulse_data_clear(fsk_pulses);
        pulses->sample_rate = samp_rate;
        fsk_pulses->sample_rate = samp_rate;
        pulses->offset = sample_offset + s->data_counter;
        fsk_pulses->offset = sample_offset + s->data_counter;
        pulses->start_ago = len - s->data_counter;
        fsk_pulses->start_ago = len - s->data_counter;
        s->pulse_length = 0;
        s->max_pulse = 0;
        s->FSK_state = (pulse_FSK_state_t){0};
        s->ook_state = PD_OOK_STATE_PULSE;
      } else {

        int const ook_low_delta = am_n - s->ook_low_estimate;
        s->ook_low_estimate += ook_low_delta / OOK_EST_LOW_RATIO;
        s->ook_low_estimate += ((ook_low_delta > 0) ? 1 : -1);

        s->ook_high_estimate = OOK_HIGH_LOW_RATIO * s->ook_low_estimate;
        s->ook_high_estimate = MAX(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);
        s->ook_high_estimate = MIN(s->ook_high_estimate, OOK_MAX_HIGH_LEVEL);
        if (s->lead_in_counter <= OOK_EST_LOW_RATIO)
          s->lead_in_counter++;
      }
      break;
    case PD_OOK_STATE_PULSE:
      s->pulse_length++;

      if (am_n < (ook_threshold - ook_hysteresis)) {

        if (s->pulse_length < PD_MIN_PULSE_SAMPLES) {
          s->ook_state = PD_OOK_STATE_IDLE;
        } else {

          pulses->pulse[pulses->num_pulses] = s->pulse_length;
          s->max_pulse = MAX(s->pulse_length, s->max_pulse);
          s->pulse_length = 0;
          s->ook_state = PD_OOK_STATE_GAP_START;
        }
      }

      else {

        s->ook_high_estimate += am_n / OOK_EST_HIGH_RATIO -
                                s->ook_high_estimate / OOK_EST_HIGH_RATIO;
        s->ook_high_estimate = MAX(s->ook_high_estimate, OOK_MIN_HIGH_LEVEL);
        s->ook_high_estimate = MIN(s->ook_high_estimate, OOK_MAX_HIGH_LEVEL);

        pulses->fsk_f1_est += fm_data[s->data_counter] / OOK_EST_HIGH_RATIO -
                              pulses->fsk_f1_est / OOK_EST_HIGH_RATIO;
      }

      if (pulses->num_pulses == 0) {
        pulse_FSK_detect(fm_data[s->data_counter], fsk_pulses, &s->FSK_state);
      }
      break;
    case PD_OOK_STATE_GAP_START:
      s->pulse_length++;

      if (am_n > (ook_threshold + ook_hysteresis)) {
        s->pulse_length += pulses->pulse[pulses->num_pulses];
        s->ook_state = PD_OOK_STATE_PULSE;
      }

      else if (s->pulse_length >= PD_MIN_PULSE_SAMPLES) {
        s->ook_state = PD_OOK_STATE_GAP;

        if (fsk_pulses->num_pulses > PD_MIN_PULSES) {

          pulse_FSK_wrap_up(fsk_pulses, &s->FSK_state);

          fsk_pulses->fsk_f1_est = s->FSK_state.fm_f1_est;
          fsk_pulses->fsk_f2_est = s->FSK_state.fm_f2_est;
          fsk_pulses->ook_low_estimate = s->ook_low_estimate;
          fsk_pulses->ook_high_estimate = s->ook_high_estimate;
          pulses->end_ago = len - s->data_counter;
          fsk_pulses->end_ago = len - s->data_counter;
          s->ook_state = PD_OOK_STATE_IDLE;
          return 2;
        }
      }

      if (pulses->num_pulses == 0) {
        pulse_FSK_detect(fm_data[s->data_counter], fsk_pulses, &s->FSK_state);
      }
      break;
    case PD_OOK_STATE_GAP:
      s->pulse_length++;

      if (am_n > (ook_threshold + ook_hysteresis)) {
        pulses->gap[pulses->num_pulses] = s->pulse_length;
        pulses->num_pulses++;

        if (pulses->num_pulses >= PD_MAX_PULSES) {
          s->ook_state = PD_OOK_STATE_IDLE;

          pulses->ook_low_estimate = s->ook_low_estimate;
          pulses->ook_high_estimate = s->ook_high_estimate;
          pulses->end_ago = len - s->data_counter;
          return 1;
        }

        s->pulse_length = 0;
        s->ook_state = PD_OOK_STATE_PULSE;
      }

      if (((s->pulse_length > (PD_MAX_GAP_RATIO * s->max_pulse)) &&
           (s->pulse_length > (PD_MIN_GAP_MS * samples_per_ms))) ||
          (s->pulse_length > (PD_MAX_GAP_MS * samples_per_ms))) {
        pulses->gap[pulses->num_pulses] = s->pulse_length;
        pulses->num_pulses++;
        s->ook_state = PD_OOK_STATE_IDLE;

        pulses->ook_low_estimate = s->ook_low_estimate;
        pulses->ook_high_estimate = s->ook_high_estimate;
        pulses->end_ago = len - s->data_counter;
        return 1;
      }
      break;
    default:
      fprintf(stderr, ""demod_OOK(): Unknown state!!\n"");
      s->ook_state = PD_OOK_STATE_IDLE;
    }
    s->data_counter++;
  }

  s->data_counter = 0;
  return 0;
}"
CZ-NIC-knot-886f882/src/knot/conf/confdb.c	Dumps the configuration DB in the textual form.	2	"int conf_db_raw_dump(conf_t *conf, knot_db_txn_t *txn, const char *file_name) {
  if (conf == NULL) {
    return KNOT_EINVAL;
  }

  if (txn == NULL) {
    txn = &conf->read_txn;
  }

  FILE *fp = stdout;
  if (file_name != NULL) {
    fp = fopen(file_name, ""w"");
    if (fp == NULL) {
      return KNOT_ERROR;
    }
  }

  int ret = KNOT_EOK;

  knot_db_iter_t *it = conf->api->iter_begin(txn, KNOT_DB_FIRST);
  while (it != NULL) {
    knot_db_val_t key;
    ret = conf->api->iter_key(it, &key);
    if (ret != KNOT_EOK) {
      break;
    }

    knot_db_val_t data;
    ret = conf->api->iter_val(it, &data);
    if (ret != KNOT_EOK) {
      break;
    }

    uint8_t *k = (uint8_t *)key.data;
    uint8_t *d = (uint8_t *)data.data;
    if (k[1] == KEY1_ITEMS) {
      fprintf(fp, ""[%i][%i]%.*s"", k[0], k[1], (int)key.len - 2, k + 2);
      fprintf(fp, "": %u\n"", d[0]);
    } else if (k[1] == KEY1_ID) {
      fprintf(fp, ""[%i][%i](%zu){"", k[0], k[1], key.len - 2);
      for (size_t i = 2; i < key.len; i++) {
        fprintf(fp, ""%02x"", (uint8_t)k[i]);
      }
      fprintf(fp, ""}\n"");
    } else {
      fprintf(fp, ""[%i][%i]"", k[0], k[1]);
      if (key.len > 2) {
        fprintf(fp, ""(%zu){"", key.len - 2);
        for (size_t i = 2; i < key.len; i++) {
          fprintf(fp, ""%02x"", (uint8_t)k[i]);
        }
        fprintf(fp, ""}"");
      }
      fprintf(fp, "": (%zu)<"", data.len);
      for (size_t i = 0; i < data.len; i++) {
        fprintf(fp, ""%02x"", (uint8_t)d[i]);
      }
      fprintf(fp, "">\n"");
    }

    it = conf->api->iter_next(it);
  }
  conf->api->iter_finish(it);

  if (file_name != NULL) {
    fclose(fp);
  } else {
    fflush(fp);
  }

  return ret;
}"
vm6502q-qrack-df6132d/include/qengine.hpp	Measure permutation state of a register.	2	"public:
QEngine(bitLenInt n, qrack_rand_gen_ptr rgp = nullptr, bool doNorm = true,
        bool randomGlobalPhase = true, bool useHostMem = false)
    : QInterface(n, rgp, doNorm), randGlobalPhase(randomGlobalPhase),
      useHostRam(useHostMem), runningNorm(ONE_R1){};

virtual bool ForceM(bitLenInt qubitIndex, bool result, bool doForce = true);
virtual bitCapInt ForceM(const bitLenInt *bits, const bitLenInt &length,
                         const bool *values);
virtual bitCapInt ForceMReg(bitLenInt start, bitLenInt length, bitCapInt result,
                            bool doForce = true);

virtual void ApplyM(bitCapInt qPower, bool result, complex nrm) {
  bitCapInt powerTest = result ? qPower : 0U;
  ApplyM(qPower, powerTest, nrm);
}
virtual void ApplyM(bitCapInt regMask, bitCapInt result, complex nrm) = 0;

virtual void ApplySingleBit(const complex *mtrx, bool doCalcNorm,
                            bitLenInt qubit);
virtual void ApplyControlledSingleBit(const bitLenInt *controls,
                                      const bitLenInt &controlLen,
                                      const bitLenInt &target,
                                      const complex *mtrx);
virtual void ApplyAntiControlledSingleBit(const bitLenInt *controls,
                                          const bitLenInt &controlLen,
                                          const bitLenInt &target,
                                          const complex *mtrx);
virtual void CSwap(const bitLenInt *controls, const bitLenInt &controlLen,
                   const bitLenInt &qubit1, const bitLenInt &qubit2);
virtual void AntiCSwap(const bitLenInt *controls, const bitLenInt &controlLen,
                       const bitLenInt &qubit1, const bitLenInt &qubit2);
virtual void CSqrtSwap(const bitLenInt *controls, const bitLenInt &controlLen,
                       const bitLenInt &qubit1, const bitLenInt &qubit2);
virtual void AntiCSqrtSwap(const bitLenInt *controls,
                           const bitLenInt &controlLen, const bitLenInt &qubit1,
                           const bitLenInt &qubit2);
virtual void CISqrtSwap(const bitLenInt *controls, const bitLenInt &controlLen,
                        const bitLenInt &qubit1, const bitLenInt &qubit2);
virtual void AntiCISqrtSwap(const bitLenInt *controls,
                            const bitLenInt &controlLen,
                            const bitLenInt &qubit1, const bitLenInt &qubit2);

using QInterface::Swap;
virtual void Swap(bitLenInt qubit1, bitLenInt qubit2);
using QInterface::SqrtSwap;
virtual void SqrtSwap(bitLenInt qubit1, bitLenInt qubit2);
using QInterface::ISqrtSwap;
virtual void ISqrtSwap(bitLenInt qubit1, bitLenInt qubit2);

virtual real1 ProbReg(const bitLenInt &start, const bitLenInt &length,
                      const bitCapInt &permutation) = 0;
virtual void ProbRegAll(const bitLenInt &start, const bitLenInt &length,
                        real1 *probsArray);
virtual real1 ProbMask(const bitCapInt &mask, const bitCapInt &permutation) = 0;
virtual void ProbMaskAll(const bitCapInt &mask, real1 *probsArray);

protected:
virtual void Apply2x2(bitCapInt offset1, bitCapInt offset2, const complex *mtrx,
                      const bitLenInt bitCount, const bitCapInt *qPowersSorted,
                      bool doCalcNorm) = 0;
virtual void ApplyControlled2x2(const bitLenInt *controls,
                                const bitLenInt &controlLen,
                                const bitLenInt &target, const complex *mtrx,
                                bool doCalcNorm);
virtual void ApplyAntiControlled2x2(const bitLenInt *controls,
                                    const bitLenInt &controlLen,
                                    const bitLenInt &target,
                                    const complex *mtrx, bool doCalcNorm);
}
;
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/gen.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      gen,
      'g',
      ""gen"",
      ""generate a new private key"",
      {""[--type rsa|ecdsa] [--size bits] [--outform der|pem|pgp]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""type"", 't', 1, ""type of key, default: rsa""},
          {""size"", 's', 1, ""keylength in bits, default: rsa 2048, ecdsa 384""},
          {""outform"", 'f', 1, ""encoding of generated private key""},
      }});
}"
AVSystem-Anjay-09239b2/src/servers/activate.c	"This function is called as a ""callback"" whenever _anjay_active_server_refresh finishes its operation."	2	"void _anjay_server_on_refreshed(anjay_t *anjay, anjay_server_info_t *server,
                                anjay_server_connection_state_t state) {
  assert(server);
  if (state == ANJAY_SERVER_CONNECTION_ERROR) {
    anjay_log(TRACE, ""could not initialize sockets for SSID %u"", server->ssid);
    _anjay_server_on_server_communication_error(anjay, server);
  } else if (server->ssid == ANJAY_SSID_BOOTSTRAP) {
    if (_anjay_should_retry_bootstrap(anjay)) {
      server->refresh_failed = !!_anjay_bootstrap_request_if_appropriate(anjay);
    } else {
      server->refresh_failed = false;
      _anjay_connection_mark_stable((anjay_connection_ref_t){
          .server = server,
          .conn_type = _anjay_server_primary_conn_type(server)});
    }
    if (!server->refresh_failed) {
      server->reactivate_time = AVS_TIME_REAL_INVALID;
    }

  } else {
    switch (_anjay_server_ensure_valid_registration(anjay, server)) {
    case ANJAY_REGISTRATION_SUCCESS:
      server->reactivate_time = AVS_TIME_REAL_INVALID;
      server->refresh_failed = false;

      _anjay_bootstrap_notify_regular_connection_available(anjay);
      break;
    case ANJAY_REGISTRATION_TIMEOUT:
      _anjay_server_on_registration_timeout(anjay, server);
      break;
    case ANJAY_REGISTRATION_ERROR:
      _anjay_server_on_server_communication_error(anjay, server);
      break;
    }
  }
}"
tsani-tetrefis-02d47ef/input.c	Loads an input manager from UEFI.	2	"input_manager_t load_input_manager(EFI_STATUS *status) {

  return (input_manager_t){.protocol = ST->ConIn};
}"
hnsl-wsr-d31c7ea/src/wsr-tpl.c	"Takes raw json and encodes it as ""script json"", i.e. json that is safe to print in a <script> tag anywhere generating a single unambiguous expression that is valid Javascript affecting HTML5 parsing while preserving the exact semantic meaning of the JSON expression in Javascript. This also requires the function to escape certain Unicode characters that are valid in JSON but not valid in Javascript."	2	"fstr_mem_t *wsr_json_script_escape(fstr_t raw_json) {
  sub_heap {
    list(fstr_t) *toks = new_list(fstr_t, ""("");
    for (;;) {
      fstr_t ok_json, replace;
      do {
        {
          fstr_t json_left = raw_json;
#pragma re2c(raw_json) : ^(.*){ok_json } < / {                                 \
  @escape_script } | ^(.*){ok_json } < !{                                      \
    @data_double_escape } | ^(.*) {                                            \
      ok_json } -> {                                                           \
        @escape_comment } | ^(.*){ok_json }[\xe2][\x80][\xa8] {                \
          @uc_line_separator } | ^(.*){ok_json }[\xe2][\x80][\xa9] {           \
            @uc_paragraph_separator }
          ok_json = json_left;
          replace = """";
          break;
        }
      escape_script : {

        replace = ""<\\/"";
        break;
      }
      data_double_escape : {

        replace = ""<\\!"";
        break;
      }
      escape_comment : {

        replace = ""-\\>"";
        break;
      }
      uc_line_separator : {

        replace = ""\\u2028"";
        break;
      }
      uc_paragraph_separator : {

        replace = ""\\u2029"";
        break;
      }
      } while (false);
      list_push_end(toks, fstr_t, ok_json);
      if (replace.len == 0)
        break;
      list_push_end(toks, fstr_t, replace);
    }
    list_push_end(toks, fstr_t, "")"");
    return escape(fstr_implode(toks, """"));
  }
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/avalanche/value.h	(This does not mean stringification; it merely inverts ava_string_to_datum().)	2	"static inline ava_string ava_string_of_datum(ava_datum datum) {
  return (ava_string){.ascii9 = datum.ulong};
}"
CZ-NIC-knot-resolver-3775bbc/lib/cache/nsec3.c	Common part: write all but the NSEC3 hash.	2	"static knot_db_val_t key_NSEC3_common(struct key *k, const knot_dname_t *zname,
                                      const nsec_p_hash_t nsec_p_hash) {
  int ret;
  const bool ok = k && zname && !(ret = kr_dname_lf(k->buf, zname, false));
  if (!ok) {
    assert(false);
    return VAL_EMPTY;
  }

  uint8_t *begin = k->buf + 1 + k->zlf_len;
  begin[0] = 0;
  begin[1] = '3';
  k->type = KNOT_RRTYPE_NSEC3;
  memcpy(begin + 2, &nsec_p_hash, sizeof(nsec_p_hash));
  return (knot_db_val_t){
      .data = k->buf + 1,
      .len = begin + 2 + sizeof(nsec_p_hash) - (k->buf + 1),
  };
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/req.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      req,
      'r',
      ""req"",
      ""create a PKCS#10 certificate request"",
      {""[--in file] [--type rsa|ecdsa]"",
       "" --dn distinguished-name [--san subjectAltName]+"",
       ""[--password challengePassword]"",
       ""[--digest md5|sha1|sha224|sha256|sha384|sha512] [--outform der|pem]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""private key input file, default: stdin""},
          {""type"", 't', 1, ""type of input key, default: rsa""},
          {""dn"", 'd', 1, ""subject distinguished name""},
          {""san"", 'a', 1, ""subjectAltName to include in cert request""},
          {""password"", 'p', 1, ""challengePassword to include in cert request""},
          {""digest"", 'g', 1, ""digest for signature creation, default: sha1""},
          {""outform"", 'f', 1, ""encoding of generated request, default: der""},
      }});
}"
darktable-org-darktable-32fab21/src/iop/levels.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_levels_params_t tmp = (dt_iop_levels_params_t){
      LEVELS_MODE_MANUAL, {0.0f, 50.0f, 100.0f}, {0.0f, 0.5f, 1.0f}};
  memcpy(self->params, &tmp, sizeof(dt_iop_levels_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_levels_params_t));
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/botnet/botnet_ui.c	"1) Randomly generate an exploit 2) Draw the screen with some faked console stuff 3) Do ""research"" 4) Wait for user"	2	"static uint8_t __do_research() {
  botnet_state_t *p_state = state_botnet_get();

  uint8_t exploit_class = util_random(0, 100);
  uint16_t exploit_strength = 0;

  if (exploit_class >= 85) {
    exploit_strength = util_random(90, 100);
  }

  else if (exploit_class >= 60) {
    exploit_strength = util_random(25, 60);
  }

  else {
    exploit_strength = util_random(10, 25);
  }

  exploit_strength += (p_state->level * BOTNET_STRENGTH_PER_LEVEL);

  exploit_strength = MIN(exploit_strength, BOTNET_MAX_STRENGTH);

  gfx_fill_screen(COLOR_BLACK);
  gfx_font_set(font_small);
  gfx_color_set(COLOR_GREEN);
  gfx_cursor_set((cursor_coord_t){0, 0});

  char player_level[32];
  sprintf(player_level, ""Player level: %d\n"", p_state->level);
  char player_points[32];
  sprintf(player_points, ""Player points: %d\n"", p_state->points);
  char exploit[64];
  sprintf(exploit, ""Exploit researched:\n  %d strength"", exploit_strength);

  char *text[] = {""AND!XOR b0tneT 2.0\n"",
                  ""~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"",
                  ""loading b0tneT modules\n"",
                  ""  TCP.........."",
                  ""Loaded\n"",
                  ""  UDP.........."",
                  ""Loaded\n"",
                  ""  HTTP........."",
                  ""Loaded\n"",
                  ""  IoT.........."",
                  ""Loaded\n"",
                  ""  EMAIL........"",
                  ""Loaded\n"",
                  ""  APT..........""
                  ""Loaded\n"",
                  ""  Bling........"",
                  ""Loaded\n"",
                  ""  Cmd & Ctrl..."",
                  ""Loaded\n\n"",
                  ""\n"",
                  player_level,
                  player_points,
                  ""\n"",
                  ""Researching Exploit\n"",
                  "".."",
                  ""--"",
                  "".."",
                  ""--""
                  "".."",
                  ""--""
                  "".."",
                  ""--""
                  "".."",
                  ""--""
                  ""..\n"",
                  exploit};
  uint8_t text_count = sizeof(text) / sizeof(uint32_t);

  for (uint8_t i = 0; i < text_count; i++) {
    gfx_print(text[i]);
    DELAY(100);
    gfx_push_screen_buffer();
  }

  if (exploit_class >= 85) {
    gfx_color_set(COLOR_GOLD);
    gfx_print("" LEGENDARY"");
    gfx_push_screen_buffer();
  }

  else if (exploit_class >= 60) {
    gfx_color_set(COLOR_BLUE);
    gfx_print("" Special"");
    gfx_push_screen_buffer();
  }

  btn_wait();
  btn_clear();

  return (uint8_t)exploit_strength;
}"
dm-vdo-kvdo-8df6805/vdo/base/referenceCountRebuild.c	Rebuild reference counts from the leaf block map pages now that reference counts have been rebuilt from the interior tree pages (which have been loaded in the process). This callback is registered in rebuildReferenceCounts().	2	"static void rebuildFromLeaves(VDOCompletion *completion) {
  RebuildCompletion *rebuild = asRebuildCompletion(completion->parent);
  *rebuild->logicalBlocksUsed = 0;

  rebuild->lastSlot = (BlockMapSlot){
      .slot = rebuild->blockMap->entryCount % BLOCK_MAP_ENTRIES_PER_PAGE,
      .pbn = findBlockMapPagePBN(rebuild->blockMap, rebuild->leafPages - 1),
  };

  rebuild->launching = true;
  for (PageCount i = 0; i < rebuild->pageCount; i++) {
    fetchPage(rebuild, &rebuild->pageCompletions[i].completion);
  }
  rebuild->launching = false;
  finishIfDone(rebuild);
}"
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the dict parser state struct with data to be parsed.	2	"psyc_parse_dict_buffer_set(PsycParseDictState *state, const char *buffer,
                           size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Device/ClassDriver/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t *const RNDISInterfaceInfo,
                 Ethernet_Frame_Info_t *const FrameOUT) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT->FrameLength)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT->FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                                               sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                               sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
                         ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT->FrameLength = PacketSize;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4,
               short __w5, short __w6, short __w7) {
  return (__m128i)(__v8hi){__w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7};
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Constructs a quaternion from four scalar values.	2	"static inline SIMD_CFUNC simd_quatd simd_quaternion(double ix, double iy,
                                                    double iz, double r) {
  return (simd_quatd){{ix, iy, iz, r}};
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/manifest-manager/source/arm_uc_mmCryptoUtils.c	"In order to simplify many tests, the cryptographic mode identifier is converted into a structure of mode identifiers, one for each cryptographic primitive. This allows other parts of the code to examine the mode of one particular primitive without testing against many enums. This function performs no validation. The calling function should have performed validation in advance. If the cryptoMode is unrecognized, then a return will be populated with 0 for every flag."	2	"arm_uc_mm_crypto_flags_t ARM_UC_mmGetCryptoFlags(uint32_t cryptoMode) {

  switch (cryptoMode) {
  case MFST_CRYPT_SHA256:
    return (arm_uc_mm_crypto_flags_t){.hash = 1U};

#if defined(ARM_UC_FEATURE_MANIFEST_PUBKEY) &&                                 \
    (ARM_UC_FEATURE_MANIFEST_PUBKEY == 1)
  case MFST_CRYPT_SHA256_ECC:
    return (arm_uc_mm_crypto_flags_t){.hash = 1U, .ecc = 1U};
  case MFST_CRYPT_SHA256_ECC_AES128_PSK:
    return (arm_uc_mm_crypto_flags_t){
        .hash = 1U, .ecc = 1U, .aes = 1U, .psk = 1U};
#endif
#if defined(ARM_UC_FEATURE_MANIFEST_PSK) && (ARM_UC_FEATURE_MANIFEST_PSK == 1)
  case MFST_CRYPT_PSK_AES128CCM_SHA256:
    return (arm_uc_mm_crypto_flags_t){.hash = 1U, .aes = 1U, .psk = 1U};
  case MFST_CRYPT_NONE_PSK_AES128CCM_SHA256:
    return (arm_uc_mm_crypto_flags_t){.hash = 1U, .psk = 1U};
#endif
  }
  return (arm_uc_mm_crypto_flags_t){.hash = 0};
}"
Blue-Rocket-BRFullTextSearch-e742f22/SampleOSXCocoaPodsProject/Pods/BRCLucene/src/core/CLucene/debug/error.cpp	the type that is stored in the field cache. can't use a typedef because the decorated name would become too long	4	"CL_NS_USE(util)

#ifdef _LUCENE_DISABLE_EXCEPTIONS
#ifdef _LUCENE_PRAGMA_WARNINGS
#pragma message(                                                               \
    ""==================Lucene exceptions are disabled=================="")
#else
#warning ""==================Lucene exceptions are disabled==================""
#endif
#else
    CLuceneError::CLuceneError():_twhat(NULL),error_number(0){
#ifndef _ASCII
		_awhat = NULL;
#endif
	}"
dmalhotra-pvfmm-67595dd/include/tree_node.hpp	Initialize the node by passing the relevant data.	2	"public:
virtual ~NodeData(){};

virtual void Clear() {}

int max_depth;
int dim;
}
;

TreeNode()
    : dim(0), depth(0), max_depth(PVFMM_MAX_DEPTH), parent(NULL), child(NULL),
      status(1) {}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Print the solution gradient data of a scalar (advection/diffusion) piece to the file.	2	"static void
fprint_vtk_piece_grad_scalar(FILE *file, const char sp_type,
                             const struct const_Multiarray_d *const grad) {
  char data_name[4];
  for (int d = 0; d < DIM; ++d) {
    sprintf(data_name, ""%s%d"", ""g_"", d);
    if (sp_type == 'p') {
      fprint_vtk_DataArray_d(file, sp_type, data_name, NULL, false, 's');
    } else if (sp_type == 's') {
      const struct const_Multiarray_d grad_slice =
          interpret_const_Multiarray_as_slice_d(grad, 2, (ptrdiff_t[]){d});
      assert(grad_slice.extents[1] == 1);

      fprint_vtk_DataArray_d(file, sp_type, data_name, &grad_slice, false, 's');
    } else {
      EXIT_ERROR(""Unsupported: %c\n"", sp_type);
    }
  }
}"
ging-isabel-1ec0172/lib/ffmpeg/Win32/src/ffmpeg/libavcodec/ituh263enc.c	Return the 4 bit value that specifies the given aspect ratio. This may be one of the standard aspect ratios or it specifies that the aspect will be stored explicitly later.	2	"av_const int ff_h263_aspect_to_info(AVRational aspect) {
  int i;

#if __STDC_VERSION__ >= 199901L
  if (aspect.num == 0)
    aspect = (AVRational){1, 1};
#else
  if (aspect.num == 0) {
    aspect.num = 1;
    aspect.den = 1;
  }
#endif

  for (i = 1; i < 6; i++) {
    if (av_cmp_q(ff_h263_pixel_aspect[i], aspect) == 0) {
      return i;
    }
  }

  return FF_ASPECT_EXTENDED;
}"
CZ-NIC-knot-resolver-3775bbc/lib/cache/api.c	The inside for cache_peek(); implementation separated to ./peek.c	2	"if (ret != 0) {
  return ret;
}
cache->ttl_min = KR_CACHE_DEFAULT_TTL_MIN;
cache->ttl_max = KR_CACHE_DEFAULT_TTL_MAX;

kr_cache_make_checkpoint(cache);
(void)assert_right_version(cache);

char *fpath;
ret = asprintf(&fpath, ""%s/data.mdb"", opts->path);
if (ret > 0) {
  kr_cache_emergency_file_to_remove = fpath;
} else {
  assert(false);
}
return 0;
}

const char *kr_cache_emergency_file_to_remove = NULL;

#define cache_isvalid(cache) ((cache) && (cache)->api && (cache)->db)

void kr_cache_close(struct kr_cache *cache) {
  if (cache_isvalid(cache)) {
    cache_op(cache, close);
    cache->db = NULL;
  }
  free((char *)kr_cache_emergency_file_to_remove);
  kr_cache_emergency_file_to_remove = NULL;
}

int kr_cache_commit(struct kr_cache *cache) {
  if (!cache_isvalid(cache)) {
    return kr_error(EINVAL);
  }
  if (cache->api->commit) {
    return cache_op(cache, commit);
  }
  return kr_ok();
}

int kr_cache_insert_rr(struct kr_cache *cache, const knot_rrset_t *rr,
                       const knot_rrset_t *rrsig, uint8_t rank,
                       uint32_t timestamp) {
  int err = stash_rrset_precond(rr, NULL);
  if (err <= 0) {
    return kr_ok();
  }
  ssize_t written =
      stash_rrset(cache, NULL, rr, rrsig, timestamp, rank, NULL, NULL);

  if (written >= 0) {
    return kr_ok();
  }

  return (int)written;
}

int kr_cache_clear(struct kr_cache *cache) {
  if (!cache_isvalid(cache)) {
    return kr_error(EINVAL);
  }
  int ret = cache_op(cache, clear);
  if (ret == 0) {
    kr_cache_make_checkpoint(cache);
    ret = assert_right_version(cache);
  }
  return ret;
}

struct entry_h *entry_h_consistent(knot_db_val_t data, uint16_t type) {
  (void)type;
  if (!data.data)
    return NULL;

  if (data.len < offsetof(struct entry_h, data))
    return NULL;
  const struct entry_h *eh = data.data;
  if (eh->is_packet) {
    uint16_t pkt_len;
    if (data.len < offsetof(struct entry_h, data) + sizeof(pkt_len)) {
      return NULL;
    }
    memcpy(&pkt_len, eh->data, sizeof(pkt_len));
    if (data.len < offsetof(struct entry_h, data) + sizeof(pkt_len) + pkt_len) {
      return NULL;
    }
  }

  bool ok = true;
  ok = ok && kr_rank_check(eh->rank);
  ok = ok && (!kr_rank_test(eh->rank, KR_RANK_BOGUS) || eh->is_packet);
  ok = ok && (eh->is_packet || !eh->has_optout);

  return ok ? (struct entry_h *)eh : NULL;
}

int32_t get_new_ttl(const struct entry_h *entry, const struct kr_query *qry,
                    const knot_dname_t *owner, uint16_t type, uint32_t now) {
  int32_t diff = now - entry->time;
  if (diff < 0) {

    diff = 0;
  }
  int32_t res = entry->ttl - diff;
  if (res < 0 && owner && qry && qry->stale_cb) {

    int res_stale = qry->stale_cb(res, owner, type, qry);
    if (res_stale >= 0)
      return res_stale;
  }
  return res;
}

int32_t kr_cache_ttl(const struct kr_cache_p *peek, const struct kr_query *qry,
                     const knot_dname_t *name, uint16_t type) {
  const struct entry_h *eh = peek->raw_data;
  return get_new_ttl(eh, qry, name, type, qry->timestamp.tv_sec);
}

static bool check_dname_for_lf(const knot_dname_t *n,
                               const struct kr_query *qry) {
  const bool ret = knot_dname_size(n) == strlen((const char *)n) + 1;
  if (!ret) {
    WITH_VERBOSE(qry) {
      auto_free char *n_str = kr_dname_text(n);
      VERBOSE_MSG(qry, ""=> skipping zero-containing name %s\n"", n_str);
    }
  }
  return ret;
}

static bool check_rrtype(uint16_t type, const struct kr_query *qry) {
  const bool ret = !knot_rrtype_is_metatype(type) && type != KNOT_RRTYPE_RRSIG;
  if (!ret) {
    WITH_VERBOSE(qry) {
      auto_free char *type_str = kr_rrtype_text(type);
      VERBOSE_MSG(qry, ""=> skipping RR type %s\n"", type_str);
    }
  }
  return ret;
}

knot_db_val_t key_exact_type_maypkt(struct key *k, uint16_t type) {
  assert(check_rrtype(type, NULL));
  switch (type) {
  case KNOT_RRTYPE_RRSIG:
    assert(false);
    return (knot_db_val_t){NULL, 0};

  case KNOT_RRTYPE_CNAME:
  case KNOT_RRTYPE_DNAME:
    type = KNOT_RRTYPE_NS;
  default:
    break;
  }

  int name_len = k->buf[0];
  k->buf[name_len + 1] = 0;
  k->buf[name_len + 2] = 'E';
  memcpy(k->buf + name_len + 3, &type, 2);
  k->type = type;

  return (knot_db_val_t){k->buf + 1, name_len + 4};
}

int peek_nosync(kr_layer_t *ctx, knot_pkt_t *pkt);

int cache_peek(kr_layer_t *ctx, knot_pkt_t *pkt) {
  struct kr_request *req = ctx->req;
  struct kr_query *qry = req->current_query;

  if (!kr_cache_is_open(&req->ctx->cache) ||
      ctx->state & (KR_STATE_FAIL | KR_STATE_DONE) || qry->flags.NO_CACHE ||
      (qry->flags.CACHE_TRIED && !qry->stale_cb) ||
      !check_rrtype(qry->stype, qry) || qry->sclass != KNOT_CLASS_IN) {
    return ctx->state;
  }

  qry->flags.CACHE_TRIED = true;

  if (qry->stype == KNOT_RRTYPE_NSEC) {
    VERBOSE_MSG(qry, ""=> skipping stype NSEC\n"");
    return ctx->state;
  }
  if (!check_dname_for_lf(qry->sname, qry)) {
    return ctx->state;
  }"
darktable-org-darktable-32fab21/src/iop/watermark.c	construct widget.	2	"void gui_init(struct dt_iop_module_t *self) {
  self->gui_data = calloc(1, sizeof(dt_iop_watermark_gui_data_t));
  dt_iop_watermark_gui_data_t *g =
      (dt_iop_watermark_gui_data_t *)self->gui_data;
  dt_iop_watermark_params_t *p = (dt_iop_watermark_params_t *)self->params;

  int line = 0;
  self->widget = gtk_grid_new();
  gtk_grid_set_row_spacing(GTK_GRID(self->widget), DT_BAUHAUS_SPACE);
  gtk_grid_set_column_spacing(GTK_GRID(self->widget), DT_PIXEL_APPLY_DPI(10));
  dt_gui_add_help_link(self->widget, dt_get_help_url(self->op));

  gtk_grid_attach(GTK_GRID(self->widget), dt_ui_section_label_new(_(""content"")),
                  0, line++, 3, 1);

  gchar configdir[PATH_MAX] = {0};
  gchar datadir[PATH_MAX] = {0};
  dt_loc_get_datadir(datadir, sizeof(datadir));
  dt_loc_get_user_config_dir(configdir, sizeof(configdir));
  GtkWidget *label = dtgtk_reset_label_new(_(""marker""), self, &p->filename,
                                           sizeof(p->filename));
  g->watermarks = dt_bauhaus_combobox_new(self);
  gtk_widget_set_hexpand(GTK_WIDGET(g->watermarks), TRUE);
  char *tooltip =
      g_strdup_printf(_(""SVG watermarks in %s/watermarks or %s/watermarks""),
                      configdir, datadir);
  gtk_widget_set_tooltip_text(g->watermarks, tooltip);
  g_free(tooltip);
  g->refresh = dtgtk_button_new(dtgtk_cairo_paint_refresh,
                                CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);
  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), g->watermarks, label,
                          GTK_POS_RIGHT, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), g->refresh, g->watermarks,
                          GTK_POS_RIGHT, 1, 1);

  float red = dt_conf_get_float(""plugins/darkroom/watermark/color_red"");
  float green = dt_conf_get_float(""plugins/darkroom/watermark/color_green"");
  float blue = dt_conf_get_float(""plugins/darkroom/watermark/color_blue"");
  GdkRGBA color =
      (GdkRGBA){.red = red, .green = green, .blue = blue, .alpha = 1.0};

  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);

  label = dtgtk_reset_label_new(_(""color""), self, &p->color, 3 * sizeof(float));
  g->colorpick = gtk_color_button_new_with_rgba(&color);
  gtk_widget_set_tooltip_text(g->colorpick,
                              _(""watermark color, tag:\n$(WATERMARK_COLOR)""));
  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g->colorpick), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->colorpick), DT_PIXEL_APPLY_DPI(24),
                              DT_PIXEL_APPLY_DPI(24));
  gtk_color_button_set_title(GTK_COLOR_BUTTON(g->colorpick),
                             _(""select watermark color""));

  g->color_picker_button = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(
      dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));
  gtk_widget_set_tooltip_text(GTK_WIDGET(g->color_picker_button),
                              _(""pick color from image""));
  gtk_widget_set_size_request(GTK_WIDGET(g->color_picker_button),
                              DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));
  g_signal_connect(G_OBJECT(g->color_picker_button), ""toggled"",
                   G_CALLBACK(dt_iop_color_picker_callback), &g->color_picker);

  gtk_box_pack_start(GTK_BOX(box), g->colorpick, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g->color_picker_button), FALSE,
                     TRUE, 0);

  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), box, label, GTK_POS_RIGHT, 2,
                          1);

  label = gtk_label_new(_(""text""));
  gtk_widget_set_halign(label, GTK_ALIGN_START);
  g->text = gtk_entry_new();
  gtk_entry_set_width_chars(GTK_ENTRY(g->text), 1);
  gtk_widget_set_tooltip_text(g->text,
                              _(""text string, tag:\n$(WATERMARK_TEXT)""));
  dt_gui_key_accel_block_on_focus_connect(g->text);
  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), g->text, label, GTK_POS_RIGHT,
                          2, 1);

  gchar *str = dt_conf_get_string(""plugins/darkroom/watermark/text"");
  gtk_entry_set_text(GTK_ENTRY(g->text), str);
  g_free(str);

  label = dtgtk_reset_label_new(_(""font""), self, &p->font, sizeof(p->font));
  str = dt_conf_get_string(""plugins/darkroom/watermark/font"");
  g->fontsel =
      gtk_font_button_new_with_font(str == NULL ? ""DejaVu Sans 10"" : str);
  GList *childs = gtk_container_get_children(
      GTK_CONTAINER(gtk_bin_get_child(GTK_BIN(g->fontsel))));
  gtk_label_set_ellipsize(GTK_LABEL(childs->data), PANGO_ELLIPSIZE_MIDDLE);
  g_list_free(childs);
  gtk_widget_set_tooltip_text(
      g->fontsel, _(""text font, tags:\n$(WATERMARK_FONT_FAMILY)\n""
                    ""$(WATERMARK_FONT_STYLE)\n$(WATERMARK_FONT_WEIGHT)""));
  gtk_font_button_set_show_size(GTK_FONT_BUTTON(g->fontsel), FALSE);
  g_free(str);
  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), g->fontsel, label,
                          GTK_POS_RIGHT, 2, 1);

  gtk_grid_attach(GTK_GRID(self->widget),
                  dt_ui_section_label_new(_(""properties"")), 0, line++, 3, 1);

  g->opacity =
      dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 1.0, p->opacity, 0);
  dt_bauhaus_slider_set_format(g->opacity, ""%.f%%"");
  dt_bauhaus_widget_set_label(g->opacity, NULL, _(""opacity""));
  g->scale =
      dt_bauhaus_slider_new_with_range(self, 1.0, 100.0, 1.0, p->scale, 0);
  dt_bauhaus_slider_enable_soft_boundaries(g->scale, 1.0, 500.0);
  dt_bauhaus_slider_set_format(g->scale, ""%.f%%"");
  dt_bauhaus_widget_set_label(g->scale, NULL, _(""scale""));
  g->rotate =
      dt_bauhaus_slider_new_with_range(self, -180.0, 180.0, 1.0, p->rotate, 2);
  dt_bauhaus_slider_set_format(g->rotate, ""%.02f"");
  dt_bauhaus_widget_set_label(g->rotate, NULL, _(""rotation""));
  gtk_grid_attach(GTK_GRID(self->widget), g->opacity, 0, line++, 3, 1);
  gtk_grid_attach(GTK_GRID(self->widget), g->scale, 0, line++, 3, 1);
  gtk_grid_attach(GTK_GRID(self->widget), g->rotate, 0, line++, 3, 1);

  g->sizeto = dt_bauhaus_combobox_new(self);
  dt_bauhaus_combobox_add(g->sizeto, C_(""size"", ""image""));
  dt_bauhaus_combobox_add(g->sizeto, _(""larger border""));
  dt_bauhaus_combobox_add(g->sizeto, _(""smaller border""));
  dt_bauhaus_combobox_set(g->sizeto, p->sizeto);
  dt_bauhaus_widget_set_label(g->sizeto, NULL, _(""scale on""));
  gtk_widget_set_tooltip_text(g->sizeto, _(""size is relative to""));
  gtk_grid_attach(GTK_GRID(self->widget), g->sizeto, 0, line++, 3, 1);

  gtk_grid_attach(GTK_GRID(self->widget),
                  dt_ui_section_label_new(_(""position"")), 0, line++, 3, 1);

  label = dtgtk_reset_label_new(_(""alignment""), self, &p->alignment,
                                sizeof(p->alignment));
  GtkWidget *bat = gtk_grid_new();
  gtk_grid_set_row_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));
  gtk_grid_set_column_spacing(GTK_GRID(bat), DT_PIXEL_APPLY_DPI(3));
  for (int i = 0; i < 9; i++) {
    g->align[i] =
        dtgtk_togglebutton_new(dtgtk_cairo_paint_alignment,
                               CPF_STYLE_FLAT | (CPF_SPECIAL_FLAG << i), NULL);
    gtk_widget_set_size_request(GTK_WIDGET(g->align[i]), DT_PIXEL_APPLY_DPI(16),
                                DT_PIXEL_APPLY_DPI(16));
    gtk_grid_attach(GTK_GRID(bat), GTK_WIDGET(g->align[i]), i % 3, i / 3, 1, 1);
    g_signal_connect(G_OBJECT(g->align[i]), ""toggled"",
                     G_CALLBACK(alignment_callback), self);
  }
  gtk_grid_attach(GTK_GRID(self->widget), label, 0, line++, 1, 1);
  gtk_grid_attach_next_to(GTK_GRID(self->widget), bat, label, GTK_POS_RIGHT, 2,
                          1);

  g->x_offset =
      dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p->xoffset, 3);
  dt_bauhaus_slider_set_format(g->x_offset, ""%.3f"");
  dt_bauhaus_widget_set_label(g->x_offset, NULL, _(""x offset""));
  g->y_offset =
      dt_bauhaus_slider_new_with_range(self, -1.0, 1.0, 0.001, p->yoffset, 3);
  dt_bauhaus_slider_set_format(g->y_offset, ""%.3f"");
  dt_bauhaus_widget_set_label(g->y_offset, NULL, _(""y offset""));
  gtk_grid_attach(GTK_GRID(self->widget), g->x_offset, 0, line++, 3, 1);
  gtk_grid_attach(GTK_GRID(self->widget), g->y_offset, 0, line++, 3, 1);

  gtk_widget_set_tooltip_text(g->opacity, _(""the opacity of the watermark""));
  gtk_widget_set_tooltip_text(g->scale, _(""the scale of the watermark""));
  gtk_widget_set_tooltip_text(g->rotate, _(""the rotation of the watermark""));

  g_signal_connect(G_OBJECT(g->opacity), ""value-changed"",
                   G_CALLBACK(opacity_callback), self);
  g_signal_connect(G_OBJECT(g->scale), ""value-changed"",
                   G_CALLBACK(scale_callback), self);
  g_signal_connect(G_OBJECT(g->rotate), ""value-changed"",
                   G_CALLBACK(rotate_callback), self);

  g_signal_connect(G_OBJECT(g->x_offset), ""value-changed"",
                   G_CALLBACK(xoffset_callback), self);

  g_signal_connect(G_OBJECT(g->y_offset), ""value-changed"",
                   G_CALLBACK(yoffset_callback), self);

  g_signal_connect(G_OBJECT(g->refresh), ""clicked"",
                   G_CALLBACK(refresh_callback), self);

  refresh_watermarks(self);

  g_signal_connect(G_OBJECT(g->watermarks), ""value-changed"",
                   G_CALLBACK(watermark_callback), self);
  g_signal_connect(G_OBJECT(g->sizeto), ""value-changed"",
                   G_CALLBACK(sizeto_callback), self);

  g_signal_connect(G_OBJECT(g->text), ""changed"", G_CALLBACK(text_callback),
                   self);
  g_signal_connect(G_OBJECT(g->colorpick), ""color-set"",
                   G_CALLBACK(colorpick_color_set), self);
  g_signal_connect(G_OBJECT(g->fontsel), ""font-set"",
                   G_CALLBACK(fontsel_callback), self);

  dt_iop_init_single_picker(&g->color_picker, self,
                            GTK_WIDGET(g->color_picker_button),
                            DT_COLOR_PICKER_POINT, _iop_color_picker_apply);
}"
swift-nav-piksi_firmware-3580085/src/simulator.c	"Populate a navigation_measurement_t structure with simulated data for the almanac_i satellite, currently dist away from simulated point at given elevation."	2	"void populate_nav_meas(navigation_measurement_t *nav_meas, double dist,
                       double elevation, int almanac_i) {
  nav_meas->sid = (gnss_signal_t){
      .code = simulation_almanacs[almanac_i].sid.code,
      .sat = simulation_almanacs[almanac_i].sid.sat + SIM_PRN_OFFSET};

  nav_meas->raw_pseudorange = dist;
  nav_meas->raw_pseudorange += rand_gaussian(sim_settings.pseudorange_sigma *
                                             sim_settings.pseudorange_sigma);

  nav_meas->raw_carrier_phase = dist / (GPS_C / GPS_L1_HZ);
  nav_meas->raw_carrier_phase += simulation_fake_carrier_bias[almanac_i];
  nav_meas->raw_carrier_phase +=
      rand_gaussian(sim_settings.phase_sigma * sim_settings.phase_sigma);

  nav_meas->snr =
      lerp(elevation, 0, M_PI / 2, 35, 45) +
      rand_gaussian(sim_settings.cn0_sigma * sim_settings.cn0_sigma);
}"
Funky-System-Funky-VM-b389879/src/libvm/instructions/instr_mem.c	Load Register. Pushes a value from a register.	4	"INSTR(ld_reg) {
  AJS_STACK(+1);
  USE_STACK();
  vm_type_t rid = GET_OPERAND();
  switch (rid) {
  case 0:
    *stack = (vm_value_t){.uint_value = state->pc, .type = VM_TYPE_INT};
    break;
  case 1:
    *stack = (vm_value_t){.uint_value = state->sp, .type = VM_TYPE_INT};
    break;
  case 2:
    *stack = (vm_value_t){.uint_value = state->mp, .type = VM_TYPE_INT};
    break;
  case 3:
    *stack = (vm_value_t){.uint_value = state->ap, .type = VM_TYPE_INT};
    break;
  case 4:
    *stack = state->rr;
    break;
  case 5:
    *stack = state->r0;
    break;
  case 6:
    *stack = state->r1;
    break;
  case 7:
    *stack = state->r2;
    break;
  case 8:
    *stack = state->r3;
    break;
  case 9:
    *stack = state->r4;
    break;
  case 10:
    *stack = state->r5;
    break;
  case 11:
    *stack = state->r6;
    break;
  case 12:
    *stack = state->r7;
    break;
  default:
    vm_error(state, ""Register id %d is not defined"", rid);
    vm_exit(state, EXIT_FAILURE);
    break;
  }

  retain(state, stack);
}"
dariorapisardi-flipdroid-fe43378/jni/ffmpeg/libavformat/utils.c	"Adds a new stream to a media file. Can only be called in the read_header() function. If the flag AVFMTCTX_NOHEADER is in the format context, then new streams can be added in read_packet too."	2	"AVStream *av_new_stream(AVFormatContext *s, int id) {
  AVStream *st;
  int i;

  if (s->nb_streams >= MAX_STREAMS)
    return NULL;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;

  st->codec = avcodec_alloc_context();
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->id = id;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  av_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  s->streams[s->nb_streams++] = st;
  return st;
}"
mansoncui-monit-1d7cce1/src/validate.c	Test the connection and protocol	2	"static State_Type _checkConnection(Service_T s, Port_T p) {
  ASSERT(s);
  ASSERT(p);
  volatile int retry_count = p->retry;
  volatile State_Type rv = State_Succeeded;
  char buf[STRLEN];
  char report[1024] = {};
retry:
  TRY {
    Socket_test(p);
    rv = State_Succeeded;
    DEBUG(""'%s' succeeded testing protocol [%s] at %s [response time %s]\n"",
          s->name, p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
          Str_time2str(p->response, (char[11]){}));
  }
  ELSE {
    rv = State_Failed;
    snprintf(report, sizeof(report), ""failed protocol test [%s] at %s -- %s"",
             p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
             Exception_frame.message);
  }
  END_TRY;
  if (rv == State_Failed) {
    if (retry_count-- > 1) {
      LogWarning(""'%s' %s (attempt %d/%d)\n"", s->name, report,
                 p->retry - retry_count, p->retry);
      goto retry;
    }
    Event_post(s, Event_Connection, State_Failed, p->action, ""%s"", report);
  } else {
    Event_post(s, Event_Connection, State_Succeeded, p->action,
               ""connection succeeded to %s"",
               Util_portDescription(p, buf, sizeof(buf)));
  }
  if (p->target.net.ssl.options.flags &&
      p->target.net.ssl.certificate.validDays >= 0 &&
      p->target.net.ssl.certificate.minimumDays > 0) {
    if (p->target.net.ssl.certificate.validDays <
        p->target.net.ssl.certificate.minimumDays) {
      Event_post(
          s, Event_Timestamp, State_Failed, p->action,
          ""certificate expiry in %d days matches check limit [valid > %d days]"",
          p->target.net.ssl.certificate.validDays,
          p->target.net.ssl.certificate.minimumDays);
      rv = State_Failed;
    } else {
      Event_post(s, Event_Timestamp, State_Succeeded, p->action,
                 ""certificate valid days test succeeded [valid for %d days]"",
                 p->target.net.ssl.certificate.validDays);
    }
  }
  return rv;
}"
dbabits-monit-d398eff/src/validate.c	Validate a program status. Events are posted according to its configuration. In case of a fatal event false is returned.	2	"State_Type check_program(Service_T s) {
  ASSERT(s);
  ASSERT(s->program);
  State_Type rv = State_Succeeded;
  time_t now = Time_now();
  Process_T P = s->program->P;
  if (P) {

    _programOutput(Process_getErrorStream(P), s->program->inprogressOutput);
    _programOutput(Process_getInputStream(P), s->program->inprogressOutput);

    if (Process_exitStatus(P) < 0) {
      int64_t execution_time = (now - s->program->started) * 1000;
      if (execution_time > s->program->timeout) {
        rv = State_Failed;
        LogError(
            ""'%s' program timed out after %s. Killing program with pid %ld\n"",
            s->name, Str_time2str(execution_time, (char[11]){}),
            (long)Process_getPid(P));
        Process_kill(P);
        Process_waitFor(P);

      } else {

        DEBUG(""'%s' status check deferred - waiting on program to exit\n"",
              s->name);
        return State_Init;
      }
    }
    s->program->exitStatus = Process_exitStatus(P);
    StringBuffer_trim(s->program->inprogressOutput);

    StringBuffer_clear(s->program->lastOutput);
    StringBuffer_append(s->program->lastOutput, ""%s"",
                        StringBuffer_toString(s->program->inprogressOutput));

    const char *output =
        StringBuffer_length(s->program->inprogressOutput)
            ? StringBuffer_toString(s->program->inprogressOutput)
            : ""no output"";
    for (Status_T status = s->statuslist; status; status = status->next) {
      if (status->operator== Operator_Changed) {
        if (status->initialized) {
          if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                   status->return_value)) {
            Event_post(s, Event_Status, State_Changed, status->action,
                       ""status changed (%d -> %d) -- %s"", status->return_value,
                       s->program->exitStatus, output);
            status->return_value = s->program->exitStatus;
          } else {
            Event_post(s, Event_Status, State_ChangedNot, status->action,
                       ""status didn't change (%d) -- %s"",
                       s->program->exitStatus, output);
          }
        } else {
          status->initialized = true;
          status->return_value = s->program->exitStatus;
        }
      } else {
        if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                 status->return_value)) {
          rv = State_Failed;
          Event_post(s, Event_Status, State_Failed, status->action,
                     ""status failed (%d) -- %s"", s->program->exitStatus,
                     output);
        } else {
          Event_post(s, Event_Status, State_Succeeded, status->action,
                     ""status succeeded (%d) -- %s"", s->program->exitStatus,
                     output);
        }
      }
    }
    Process_free(&s->program->P);
  } else {
    rv = State_Init;
  }

  if (s->monitor != Monitor_Not && !_checkSkip(s)) {

    StringBuffer_clear(s->program->inprogressOutput);
    s->program->P = Command_execute(s->program->C);
    if (!s->program->P) {
      rv = State_Failed;
      Event_post(s, Event_Status, State_Failed, s->action_EXEC,
                 ""failed to execute '%s' -- %s"", s->path, STRERROR);
    } else {
      Event_post(s, Event_Status, State_Succeeded, s->action_EXEC,
                 ""program started"");
      s->program->started = now;
    }
  }
  return rv;
}"
SSLAB-HSA-HSAemu-0e02c10/qemu/block.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t sector_num, int nb_sectors,
                                  bool is_write) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .sector_num = sector_num,
      .nb_sectors = nb_sectors,
      .is_write = is_write,
      .co = qemu_coroutine_self(),
  };

  qemu_co_queue_init(&req->wait_queue);

  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
}"
BRiAl-BRiAl-309cf26/libbrial/include/polybori/routines/pbori_algo_int.h	"A first version Function templates extracting minimal elements of dd wrt. inclusion Assumption, navi is navigator of dd"	2	"dd_minimal_elements(NaviType navi, DDType2 &multiples, ReverseIterator idxStart,
                    ReverseIterator idxEnd, const DDOperations &apply) {

  if (!navi.isConstant()) {

    int nlen = apply.length(navi);

    if (false && (nlen == 2)) {

      navi = minimal_of_two_terms(navi, multiples, idxStart, idxEnd, apply);

      return navi;

#if 0
    multiples = navi;


      std::vector<int> indices (apply.nSupport(navi));
      std::vector<int>::iterator iter(indices.begin()), iend(indices.end());
      bool is_reducible = true;
      bool reducible_tested = false;

      int used = 0;
      NaviType thenBr;
      NaviType elseBr;
      while( is_reducible&&(!multiples.isConstant())) {
        *iter = *multiples;
        used++;
          
        thenBr = multiples.thenBranch();
        elseBr = multiples.elseBranch();

        if((elseBr.isConstant() && elseBr.terminalValue())) {
          --iter;
          --used;
          multiples = elseBr;
        }
        else if (elseBr.isConstant() && !elseBr.terminalValue()) 
          multiples = thenBr;
        else {
          if (!reducible_tested){
            reducible_tested == true;
            is_reducible = is_reducible_by(thenBr, elseBr);
          }
          if(is_reducible){
            --iter;
            --used;
          }

          multiples = elseBr;
        }
        
          
          ++iter;
 
      }



      indices.resize(used);

      if (is_reducible) {

        std::vector<int>::const_reverse_iterator start(indices.rbegin()),
          finish(indices.rend());
        
         
        
        inc_ref(multiples);
        

        NaviType tmp,tmpnavi;

        apply.assign(tmpnavi, multiples);
        
        ReverseIterator idxIter = idxStart;
        while(start != finish){
         
          while((idxIter != idxEnd) && (*idxIter > *start) ) {

            apply.multiplesAssign(multiples, *idxIter);
            ++idxIter;
          }
          apply.productAssign(multiples, *start);
          apply.productAssign(tmpnavi, *start);      
          if(idxIter != idxEnd)
            ++idxIter;
          ++start;
        }

        navi = tmpnavi;
        return navi;
      }

#endif
    }

    if (nlen == 1) {

      multiples = indexed_term_multiples(navi, idxStart, idxEnd, apply);
      return apply.newNode(navi);
    }

    NaviType elseMult;
    NaviType elsedd = dd_minimal_elements(navi.elseBranch(), elseMult, idxStart,
                                          idxEnd, apply);
    elseMult =
        prepend_multiples_wrt_indices(elseMult, *navi, idxStart, idxEnd, apply);

    if ((navi.elseBranch() == navi.thenBranch()) ||
        (elsedd.isConstant() && elsedd.terminalValue())) {
      multiples = elseMult;
      return elsedd;
    }

    NaviType thenNavi(apply.diff(navi.thenBranch(), elseMult));

    NaviType thenMult;
    apply.replace(thenNavi, dd_minimal_elements(thenNavi, thenMult, idxStart,
                                                idxEnd, apply));
    thenMult =
        prepend_multiples_wrt_indices(thenMult, *navi, idxStart, idxEnd, apply);

    apply.uniteAssign(thenMult, elseMult);
    apply.replacingNode(multiples, *navi, thenMult, elseMult);

    NaviType result;
    apply.replacingNode(result, *navi, thenNavi, elsedd);

    return result;
  }

  apply.assign(multiples, navi);

  return apply.newNode(navi);
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/core/util.c	"builds destination URL or path, by contatenating the prefix and path_info of the request"	2	"h2o_iovec_t h2o_build_destination(h2o_req_t *req, const char *prefix,
                                  size_t prefix_len, int use_path_normalized) {
  h2o_iovec_t parts[4];
  size_t num_parts = 0;
  int conf_ends_with_slash =
      req->pathconf->path.base[req->pathconf->path.len - 1] == '/';
  int prefix_ends_with_slash = prefix[prefix_len - 1] == '/';

  parts[num_parts++] = h2o_iovec_init(prefix, prefix_len);

  if (conf_ends_with_slash != prefix_ends_with_slash) {
    if (conf_ends_with_slash) {
      parts[num_parts++] = h2o_iovec_init(H2O_STRLIT(""/""));
    } else {
      if (req->path_normalized.len != req->pathconf->path.len)
        parts[num_parts - 1].len -= 1;
    }
  }

  if (use_path_normalized) {
    parts[num_parts++] = h2o_uri_escape(
        &req->pool, req->path_normalized.base + req->pathconf->path.len,
        req->path_normalized.len - req->pathconf->path.len, ""/@:"");
    if (req->query_at != SIZE_MAX) {
      parts[num_parts++] = h2o_iovec_init(req->path.base + req->query_at,
                                          req->path.len - req->query_at);
    }
  } else {
    if (req->path.len > 1) {

      size_t next_unnormalized;
      if (req->norm_indexes && req->pathconf->path.len > 1) {
        next_unnormalized = req->norm_indexes[req->pathconf->path.len - 1];
      } else {
        next_unnormalized = req->pathconf->path.len;
      }

      if (req->path.base[0] != '/' && next_unnormalized == 1) {
        next_unnormalized = 0;
      }
      parts[num_parts++] = (h2o_iovec_t){req->path.base + next_unnormalized,
                                         req->path.len - next_unnormalized};
    }
  }

  return h2o_concat_list(&req->pool, parts, num_parts);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the versor the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion qversor(const quaternion num) {
  const quaternion conj_num =
      (quaternion){num.R, num.i * -1.0, num.j * -1.0, num.k * -1.0};
  return qdiv(num, conj_num);
}"
luakit-luakit-65f3f8d/clib/download.c	Creates the Lua download class.	2	"download_class_setup(lua_State *L) {
  static const struct luaL_Reg download_methods[] = {
      LUA_CLASS_METHODS(download){""__call"", luaH_download_new}, {NULL, NULL}};

  static const struct luaL_Reg download_meta[] = {
      LUA_OBJECT_META(download) LUA_CLASS_META{""start"", luaH_download_start},
      {""cancel"", luaH_download_cancel},
      {""__gc"", luaH_download_gc},
      {NULL, NULL},
  };

  luaH_class_setup(L, &download_class, ""download"",
                   (lua_class_allocator_t)download_new, NULL, NULL,
                   download_methods, download_meta);

  luaH_class_add_property(
      &download_class, L_TK_ALLOW_OVERWRITE,
      (lua_class_propfunc_t)luaH_download_set_allow_overwrite,
      (lua_class_propfunc_t)luaH_download_get_allow_overwrite,
      (lua_class_propfunc_t)luaH_download_set_allow_overwrite);

  luaH_class_add_property(&download_class, L_TK_DESTINATION,
                          (lua_class_propfunc_t)luaH_download_set_destination,
                          (lua_class_propfunc_t)luaH_download_get_destination,
                          (lua_class_propfunc_t)luaH_download_set_destination);

  luaH_class_add_property(&download_class, L_TK_PROGRESS, NULL,
                          (lua_class_propfunc_t)luaH_download_get_progress,
                          NULL);

  luaH_class_add_property(&download_class, L_TK_STATUS, NULL,
                          (lua_class_propfunc_t)luaH_download_get_status, NULL);

  luaH_class_add_property(&download_class, L_TK_ERROR, NULL,
                          (lua_class_propfunc_t)luaH_download_get_error, NULL);

  luaH_class_add_property(
      &download_class, L_TK_TOTAL_SIZE, NULL,
      (lua_class_propfunc_t)luaH_download_get_content_length, NULL);

  luaH_class_add_property(
      &download_class, L_TK_CURRENT_SIZE, NULL,
      (lua_class_propfunc_t)luaH_download_get_received_data_length, NULL);

  luaH_class_add_property(&download_class, L_TK_ELAPSED_TIME, NULL,
                          (lua_class_propfunc_t)luaH_download_get_elapsed_time,
                          NULL);

  luaH_class_add_property(&download_class, L_TK_MIME_TYPE, NULL,
                          (lua_class_propfunc_t)luaH_download_get_mime_type,
                          NULL);

  luaH_class_add_property(
      &download_class, L_TK_SUGGESTED_FILENAME, NULL,
      (lua_class_propfunc_t)luaH_download_get_suggested_filename, NULL);

  luaH_class_add_property(
      &download_class, L_TK_URI, (lua_class_propfunc_t)luaH_download_set_uri,
      (lua_class_propfunc_t)luaH_download_get_uri, (lua_class_propfunc_t)NULL);

  luaH_uniq_setup(L, REG_KEY, ""v"");
}"
PJK-libcbor-87f977e/src/cbor/tags.c	Create a new tag	2	"cbor_item_t *cbor_new_tag(uint64_t value) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_TAG,
      .metadata = {.tag_metadata = {.value = value, .tagged_item = NULL}},
      .data = NULL};
  return item;
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/tags.c	Create a new tag	2	"cbor_item_t *cbor_new_tag(uint64_t value) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_TAG,
      .metadata = {.tag_metadata = {.value = value, .tagged_item = NULL}},
      .data = NULL};
  return item;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	"The callback function takes an enum request and an authorization function pointer. To authorize the given request, the caller invokes the authorization function."	2	"arm_uc_error_t
ARM_UC_ControlCenter_SetAuthorityHandler(void (*callback)(int32_t)) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_SetAuthorityHandler: %p"", callback);

  arm_uc_authority_callback = callback;

  return (arm_uc_error_t){ERR_NONE};
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavutil/opt.c	Check if given option is set to its default value.	2	"int av_opt_is_set_to_default(void *obj, const AVOption *o) {
  int64_t i64;
  double d, d2;
  float f;
  AVRational q;
  int ret, w, h;
  char *str;
  void *dst;

  if (!o || !obj)
    return AVERROR(EINVAL);

  dst = ((uint8_t *)obj) + o->offset;

  switch (o->type) {
  case AV_OPT_TYPE_CONST:
    return 1;
  case AV_OPT_TYPE_BOOL:
  case AV_OPT_TYPE_FLAGS:
  case AV_OPT_TYPE_PIXEL_FMT:
  case AV_OPT_TYPE_SAMPLE_FMT:
  case AV_OPT_TYPE_INT:
  case AV_OPT_TYPE_CHANNEL_LAYOUT:
  case AV_OPT_TYPE_DURATION:
  case AV_OPT_TYPE_INT64:
    read_number(o, dst, NULL, NULL, &i64);
    return o->default_val.i64 == i64;
  case AV_OPT_TYPE_STRING:
    str = *(char **)dst;
    if (str == o->default_val.str)
      return 1;
    if (!str || !o->default_val.str)
      return 0;
    return !strcmp(str, o->default_val.str);
  case AV_OPT_TYPE_DOUBLE:
    read_number(o, dst, &d, NULL, NULL);
    return o->default_val.dbl == d;
  case AV_OPT_TYPE_FLOAT:
    read_number(o, dst, &d, NULL, NULL);
    f = o->default_val.dbl;
    d2 = f;
    return d2 == d;
  case AV_OPT_TYPE_RATIONAL:
    q = av_d2q(o->default_val.dbl, INT_MAX);
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_BINARY: {
    struct {
      uint8_t *data;
      int size;
    } tmp = {0};
    int opt_size = *(int *)((void **)dst + 1);
    void *opt_ptr = *(void **)dst;
    if (!opt_size && (!o->default_val.str || !strlen(o->default_val.str)))
      return 1;
    if (!opt_size || !o->default_val.str || !strlen(o->default_val.str))
      return 0;
    if (opt_size != strlen(o->default_val.str) / 2)
      return 0;
    ret = set_string_binary(NULL, NULL, o->default_val.str, &tmp.data);
    if (!ret)
      ret = !memcmp(opt_ptr, tmp.data, tmp.size);
    av_free(tmp.data);
    return ret;
  }
  case AV_OPT_TYPE_DICT:

    return !!(*(void **)dst);
  case AV_OPT_TYPE_IMAGE_SIZE:
    if (!o->default_val.str || !strcmp(o->default_val.str, ""none""))
      w = h = 0;
    else if ((ret = av_parse_video_size(&w, &h, o->default_val.str)) < 0)
      return ret;
    return (w == *(int *)dst) && (h == *((int *)dst + 1));
  case AV_OPT_TYPE_VIDEO_RATE:
    q = (AVRational){0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_video_rate(&q, o->default_val.str)) < 0)
        return ret;
    }
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_COLOR: {
    uint8_t color[4] = {0, 0, 0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_color(color, o->default_val.str, -1, NULL)) < 0)
        return ret;
    }
    return !memcmp(color, dst, sizeof(color));
  }
  default:
    av_log(obj, AV_LOG_WARNING,
           ""Not supported option type: %d, option name: %s\n"", o->type,
           o->name);
    break;
  }
  return AVERROR_PATCHWELCOME;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/name-mangle.c	"Identifies the mangling scheme used on the given mangled name, returning the scheme itself and the unmangled form of the given name. This always succeeds; if the function cannot interpret the string, it assumes no mangling was enacted."	2	"ava_demangled_name ava_name_demangle(ava_string instr) {
  size_t srclen = ava_strlen(instr);
  char dst[srclen];
  ava_str_tmpbuff srctmp;
  const unsigned char *src;
  size_t in, out;

  src = (const unsigned char *)ava_string_to_cstring_buff(srctmp, instr);

  if (srclen >= 3 && 'a' == src[0] && '$' == src[1]) {

    in = 2;
    out = 0;

    while (in < srclen) {
      switch (src[in]) {
      case '_':
        if (in + 1 >= srclen || '_' != src[in + 1]) {
          dst[out++] = '-';
          in += 1;
        } else if (in + 2 >= srclen || '_' != src[in + 2]) {
          dst[out++] = '.';
          in += 2;
        } else {
          dst[out++] = ':';
          in += 3;
        }
        break;

      case '$':
        if (in + 2 >= srclen || 255 == ava_hexes[src[in + 1]] ||
            255 == ava_hexes[src[in + 2]] ||

            (src[in + 1] >= 'a' && src[in + 1] <= 'f') ||
            (src[in + 2] >= 'a' && src[in + 2] <= 'f'))

          goto no_name_mangling;

        dst[out++] = (ava_hexes[src[in + 1]] << 4) | ava_hexes[src[in + 2]];
        in += 3;
        break;

      default:
        dst[out++] = src[in++];
      }
    }

    return (ava_demangled_name){.scheme = ava_nms_ava,
                                .name = ava_string_of_bytes(dst, out)};
  }

no_name_mangling:
  return (ava_demangled_name){.scheme = ava_nms_none, .name = instr};
}"
mansoncui-monit-1d7cce1/src/validate.c	Check process resources	2	"static State_Type _checkProcessResources(Service_T s, Resource_T r) {
  ASSERT(s);
  ASSERT(r);
  State_Type rv = State_Succeeded;
  char report[STRLEN] = {}, buf1[10], buf2[10];
  switch (r->resource_id) {
  case Resource_CpuPercent:
    if (s->inf.process->cpu_percent < 0.) {
      DEBUG(""'%s' cpu usage check skipped (initializing)\n"", s->name);
      return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->cpu_percent, r->limit)) {
      rv = State_Failed;
                                snprintf(report, STRLEN, ""cpu usage of %.1f%% matches resource limit [cpu usage %s %.1f%%]"", s->inf.process->cpu_percent, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""cpu usage check succeeded [current ""
                                         ""cpu usage = %.1f%%]"",
                                         s->inf.process->cpu_percent);
    }
    break;

  case Resource_CpuPercentTotal:
    if (s->inf.process->total_cpu_percent < 0.) {
                                DEBUG(""'%s' total cpu usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_cpu_percent, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""total cpu usage of %.1f%% matches resource limit [cpu usage %s %.1f%%]"", s->inf.process->total_cpu_percent, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""total cpu usage check succeeded ""
                                         ""[current cpu usage = %.1f%%]"",
                                         s->inf.process->total_cpu_percent);
    }
    break;

  case Resource_MemoryPercent:
    if (s->inf.process->mem_percent < 0.) {
                                DEBUG(""'%s' memory usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->mem_percent, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""mem usage of %.1f%% matches resource limit [mem usage %s %.1f%%]"", s->inf.process->mem_percent, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""mem usage check succeeded [current ""
                                         ""mem usage = %.1f%%]"",
                                         s->inf.process->mem_percent);
    }
    break;

  case Resource_MemoryKbyte:
    if (s->inf.process->mem == 0) {
                                DEBUG(""'%s' process memory usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, s->inf.process->mem,
                                          r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""mem amount of %s matches resource limit [mem amount %s %s]"", Str_bytes2str(s->inf.process->mem, buf1), operatorshortnames[r->operator], Str_bytes2str(r->limit, buf2));
    } else {
                                snprintf(
                                    report, STRLEN,
                                    ""mem amount check succeeded [current mem ""
                                    ""amount = %s]"",
                                    Str_bytes2str(s->inf.process->mem, buf1));
    }
    break;

  case Resource_Threads:
    if (s->inf.process->threads < 0) {
                                DEBUG(""'%s' process threads count check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, s->inf.process->threads,
                                          r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""threads count %i matches resource limit [threads %s %.0f]"", s->inf.process->threads, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""threads check succeeded [current ""
                                         ""threads = %i]"",
                                         s->inf.process->threads);
    }
    break;

  case Resource_Children:
    if (s->inf.process->children < 0) {
                                DEBUG(""'%s' process children count check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, s->inf.process->children,
                                          r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""children count %i matches resource limit [children %s %.0f]"", s->inf.process->children, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""children check succeeded [current ""
                                         ""children = %i]"",
                                         s->inf.process->children);
    }
    break;

  case Resource_MemoryKbyteTotal:
    if (s->inf.process->total_mem == 0) {
                                DEBUG(""'%s' process total memory usage check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_mem, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""total mem amount of %s matches resource limit [total mem amount %s %s]"", Str_bytes2str(s->inf.process->total_mem, buf1), operatorshortnames[r->operator], Str_bytes2str(r->limit, buf2));
    } else {
                                snprintf(report, STRLEN,
                                         ""total mem amount check succeeded ""
                                         ""[current total mem amount = %s]"",
                                         Str_bytes2str(
                                             s->inf.process->total_mem, buf1));
    }
    break;

  case Resource_MemoryPercentTotal:
    if (s->inf.process->total_mem_percent < 0.) {
                                DEBUG(""'%s' total memory usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_mem_percent, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""total mem amount of %.1f%% matches resource limit [total mem amount %s %.1f%%]"", (float)s->inf.process->total_mem_percent, operatorshortnames[r->operator], (float)r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""total mem amount check succeeded ""
                                         ""[current total mem amount = %.1f%%]"",
                                         s->inf.process->total_mem_percent);
    }
    break;

  case Resource_ReadBytes:
    if (Statistics_initialized(&(s->inf.process->read.bytes))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->read.bytes));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                  rv = State_Failed;
                                        snprintf(report, STRLEN, ""read rate %s/s matches resource limit [read %s %s/s]"", Str_bytes2str(value, (char[10]){}), operatorshortnames[r->operator], Str_bytes2str(r->limit, (char[10]){}));
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""read rate test succeeded [current ""
                                            ""read = %s/s]"",
                                            Str_bytes2str(value, (char[10]){}));
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for bytes read rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_ReadOperations:
    if (Statistics_initialized(&(s->inf.process->read.operations))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->read.operations));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""read rate %.1f operations/s matches resource limit [read %s %.0f operations/s]"", value, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""read rate test succeeded [current ""
                                            ""read = %.1f operations/s]"",
                                            value);
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for read rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_WriteBytes:
    if (Statistics_initialized(&(s->inf.process->write.bytes))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->write.bytes));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""write rate %s/s matches resource limit [write %s %s/s]"", Str_bytes2str(value, (char[10]){}), operatorshortnames[r->operator], Str_bytes2str(r->limit, (char[10]){}));
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""write rate test succeeded ""
                                            ""[current write = %s/s]"",
                                            Str_bytes2str(value, (char[10]){}));
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for bytes write rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_WriteOperations:
    if (Statistics_initialized(&(s->inf.process->write.operations))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->write.operations));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""write rate %.1f operations/s matches resource limit [write %s %.0f operations/s]"", value, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(report, STRLEN,
                                                 ""write rate test succeeded ""
                                                 ""[current write = %.1f ""
                                                 ""operations/s]"",
                                                 value);
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for write rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  default:
    LogError(""'%s' error -- unknown resource ID: [%d]\n"", s->name,
             r->resource_id);
    return State_Failed;
  }
  Event_post(s, Event_Resource, rv, r->action, ""%s"", report);
  return rv;
}"
silveraid-monit-4ead10f/src/validate.c	Test the connection and protocol	2	"static State_Type _checkConnection(Service_T s, Port_T p) {
  ASSERT(s);
  ASSERT(p);
  volatile int retry_count = p->retry;
  volatile State_Type rv = State_Succeeded;
  char buf[STRLEN];
  char report[STRLEN] = {};
retry:
  TRY {
    Socket_test(p);
    rv = State_Succeeded;
    DEBUG(""'%s' succeeded testing protocol [%s] at %s [response time %s]\n"",
          s->name, p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
          Str_milliToTime(p->response, (char[23]){}));
  }
  ELSE {
    rv = State_Failed;
    snprintf(report, STRLEN, ""failed protocol test [%s] at %s -- %s"",
             p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
             Exception_frame.message);
  }
  END_TRY;
  if (rv == State_Failed) {
    if (retry_count-- > 1) {
      LogWarning(""'%s' %s (attempt %d/%d)\n"", s->name, report,
                 p->retry - retry_count, p->retry);
      goto retry;
    }
    Event_post(s, Event_Connection, State_Failed, p->action, ""%s"", report);
  } else {
    Event_post(s, Event_Connection, State_Succeeded, p->action,
               ""connection succeeded to %s"",
               Util_portDescription(p, buf, sizeof(buf)));
  }
  if (p->target.net.ssl.options.flags &&
      p->target.net.ssl.certificate.validDays >= 0 &&
      p->target.net.ssl.certificate.minimumDays > 0) {
    if (p->target.net.ssl.certificate.validDays <
        p->target.net.ssl.certificate.minimumDays) {
      Event_post(
          s, Event_Timestamp, State_Failed, p->action,
          ""certificate expiry in %d days matches check limit [valid > %d days]"",
          p->target.net.ssl.certificate.validDays,
          p->target.net.ssl.certificate.minimumDays);
      rv = State_Failed;
    } else {
      Event_post(s, Event_Timestamp, State_Succeeded, p->action,
                 ""certificate valid days test succeeded [valid for %d days]"",
                 p->target.net.ssl.certificate.validDays);
    }
  }
  return rv;
}"
cisco-system-traffic-generator-trex-core-d48fc67/src/dpdk/drivers/net/mlx5/mlx5_nl_flow.c	Create and configure a libmnl socket for Netlink flow rules.	2	"mlx5_nl_flow_socket_create(void) {
  struct mnl_socket *nl = mnl_socket_open(NETLINK_ROUTE);

  if (nl) {
    mnl_socket_setsockopt(nl, NETLINK_CAP_ACK, &(int){1}, sizeof(int));
    if (!mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID))
      return nl;
  }
  rte_errno = errno;
  if (nl)
    mnl_socket_close(nl);
  return NULL;
}"
debuti-PebbleNotepad-6bf3a43/src/main.c	Here we capture when a user selects a menu item	2	"void menu_select_callback(MenuLayer *me, MenuIndex *cell_index, void *data) {
  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0,
          ""###menu_select_callback: Entering###"");
  app_log(APP_LOG_LEVEL_INFO, ""main.c"", 0,
          ""###menu_select_callback: Item selected section %d, row %d###"",
          cell_index->section, cell_index->row);

  note_selected = row_to_resource(cell_index->row);

  note_window = window_create();

  window_set_window_handlers(note_window, (WindowHandlers){
                                              .load = note_window_load,
                                              .unload = note_window_unload,
                                          });

  window_stack_push(note_window, true);

  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0,
          ""###menu_select_callback: Exiting###"");
}"
opticron-libuweave-2e5e385/src/trace.c	Returns the next target trace entry with the id and timestamp populated.	2	"UwTraceEntry *uw_trace_log_append_(UwDevice *device, UwTraceType type) {
  UwTraceLog *log = &device->trace_log;
  UwTraceEntry *entry = &log->entries[log->next_index];
  log->next_index = (log->next_index + 1) % UW_TRACE_LOG_ENTRY_COUNT;
  *entry = (UwTraceEntry){
      .id = log->next_id++,
      .timestamp = uw_time_get_timestamp_seconds_(),
      .type = type,
  };
  return entry;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Projects/MissileLauncher/MissileLauncher.c	Writes a report to the attached device.	1	"void WriteNextReport(uint8_t *const ReportOUTData,
                     const uint16_t ReportLength) {
  if (USB_HostState != HOST_STATE_Configured)
    return;

  Pipe_SelectPipe(HID_DATA_OUT_PIPE);

  if (Pipe_IsConfigured()) {
    Pipe_Unfreeze();

    if (!(Pipe_IsOUTReady())) {

      Pipe_Freeze();

      return;
    }

    Pipe_Write_Stream_LE(ReportOUTData, ReportLength, NULL);

    Pipe_ClearOUT();

    Pipe_Freeze();
  } else {

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetReport,
        .wValue = 0x02,
        .wIndex = 0x01,
        .wLength = ReportLength,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    USB_Host_SendControlRequest(ReportOUTData);
  }
}"
darktable-org-darktable-32fab21/src/iop/relight.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(_(""fill-light 0.25EV with 4 zones""), self->op,
                             self->version(),
                             &(dt_iop_relight_params_t){0.25, 0.25, 4.0},
                             sizeof(dt_iop_relight_params_t), 1);
  dt_gui_presets_add_generic(_(""fill-shadow -0.25EV with 4 zones""), self->op,
                             self->version(),
                             &(dt_iop_relight_params_t){-0.25, 0.25, 4.0},
                             sizeof(dt_iop_relight_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands."	1	"uint8_t MS_Host_TestUnitReady(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                              const uint8_t LUNIndex) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = 0,
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/KeyboardHostWithParser/HIDReport.c	"Function to read in the HID report descriptor from the attached device, and process it into easy-to-read structures via the HID parser routines in the LUFA library."	0	"uint8_t GetHIDReportData(void) {

  uint8_t HIDReportData[HIDReportSize];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE),
      .bRequest = REQ_GetDescriptor,
      .wValue = (DTYPE_Report << 8),
      .wIndex = 0,
      .wLength = HIDReportSize,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if (USB_Host_SendControlRequest(HIDReportData) != HOST_SENDCONTROL_Successful)
    return ParseControlError;

  if (USB_ProcessHIDReport(HIDReportData, HIDReportSize, &HIDReportInfo) !=
      HID_PARSE_Successful)
    return ParseError;

  return ParseSuccessful;
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	Joint Hard thresholding (with strides) Performs hard thresholding to the norm along dimension specified by flags Applies the support of thresholded norm to every vector along that dimension Hard thresholding refers to the selection of the k largest elements in vector.	2	"void md_zhardthresh_joint2(unsigned int D, const long dims[D], unsigned int k,
                           unsigned int flags, complex float *tmp_norm,
                           const long ostrs[D], complex float *optr,
                           const long istrs[D], const complex float *iptr) {
  long norm_dims[D];
  long norm_strs[D];

  md_select_dims(D, ~flags, norm_dims, dims);
  md_calc_strides(D, norm_strs, norm_dims, CFL_SIZE);

  md_zrss(D, dims, flags, tmp_norm, iptr);

  NESTED(void, nary_zhardthresh_mask,
         (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->zhardthresh_mask(data->size, k, ptr[0], ptr[1]);
  };

  optimized_twoop_oi(D, norm_dims, norm_strs, tmp_norm, norm_strs, tmp_norm,
                     (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zhardthresh_mask);
  md_zmul2(D, dims, ostrs, optr, norm_strs, tmp_norm, istrs, iptr);
}"
darktable-org-darktable-32fab21/src/iop/graduatednd.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(_(""neutral gray ND2 (soft)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(_(""neutral gray ND4 (soft)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){2, 0, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(_(""neutral gray ND8 (soft)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){3, 0, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(_(""neutral gray ND2 (hard)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){1, 75, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(_(""neutral gray ND4 (hard)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){2, 75, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(_(""neutral gray ND8 (hard)""), self->op,
                             self->version(),
                             &(dt_iop_graduatednd_params_t){3, 75, 0, 50, 0, 0},
                             sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""orange ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0.102439, 0.8},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""yellow ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0.151220, 0.5},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""purple ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0.824390, 0.5},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""green ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0.302439, 0.5},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""red ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0, 0.5},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""blue ND2 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){1, 0, 0, 50, 0.663415, 0.5},
      sizeof(dt_iop_graduatednd_params_t), 1);
  dt_gui_presets_add_generic(
      _(""brown ND4 (soft)""), self->op, self->version(),
      &(dt_iop_graduatednd_params_t){2, 0, 0, 50, 0.082927, 0.25},
      sizeof(dt_iop_graduatednd_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
BrendelGroup-AEGeAn-7fe9449/src/core/AgnCompareReportHTML.c	Print locus report header.	2	"static void compare_report_html_locus_header(AgnLocus *locus, FILE *outstream) {
  GtRange range = gt_genome_node_get_range(locus);
  GtStr *seqid = gt_genome_node_get_seqid(locus);
  GtArray *pairs2report = agn_locus_pairs_to_report(locus);
  GtUword numpairs = gt_array_size(pairs2report);

  fprintf(outstream,
          ""<!doctype html>\n""
          ""<html lang=\""en\"">\n""
          ""  <head>\n""
          ""    <meta charset=\""utf-8\"" />\n""
          ""    <title>ParsEval: Locus at %s[%lu, %lu]</title>\n""
          ""    <link rel=\""stylesheet\"" type=\""text/css\"" ""
          ""href=\""../parseval.css\"" />\n"",
          gt_str_get(seqid), range.start, range.end);

  if (numpairs > 1) {
    GtUword i;
    fputs(
        ""    <script type=\""text/javascript\""""
        "" src=\""../vendor/mootools-core-1.3.2-full-nocompat-yc.js\""></script>\n""
        ""    <script type=\""text/javascript\"" ""
        ""src=\""../vendor/mootools-more-1.3.2.1.js\""></script>\n""
        ""    <script type=\""text/javascript\"">\n""
        ""window.addEvent('domready', function() {\n""
        ""  var status =\n""
        ""  {\n""
        ""    'true': \""(hide details)\"",\n""
        ""    'false': \""(show details)\"",\n""
        ""  }\n"",
        outstream);
    for (i = 0; i < numpairs; i++) {
      fprintf(outstream,
              ""  var compareWrapper%lu = new Fx.Slide('compare_wrapper_%lu');\n""
              ""  compareWrapper%lu.hide();\n""
              ""  $('toggle_compare_%lu').addEvent('click', function(event){\n""
              ""    event.stop();\n""
              ""    compareWrapper%lu.toggle();\n""
              ""  });\n""
              ""  compareWrapper%lu.addEvent('complete', function() {\n""
              ""    $('toggle_compare_%lu').set('text', ""
              ""status[compareWrapper%lu.open]);\n""
              ""  });\n"",
              i, i, i, i, i, i, i, i);
    }
    fputs(""});\n""
          ""    </script>\n"",
          outstream);
  }

  fprintf(outstream,
          ""  </head>\n""
          ""  <body>\n""
          ""    <div id=\""content\"">\n""
          ""      <h1>Locus at %s[%lu, %lu]</h1>\n""
          ""      <p><a href=\""index.html\""> Back to %s loci</a></p>\n\n"",
          gt_str_get(seqid), range.start, range.end, gt_str_get(seqid));

  compare_report_html_locus_gene_ids(locus, outstream);
}"
felipec-libomxil-bellagio-3da79f8/src/components/ffmpeg/omx_videoenc_component.c	"It initializates the FFmpeg framework, and opens an FFmpeg videoencoder of type specified by IL client"	2	"OMX_ERRORTYPE omx_videoenc_component_ffmpegLibInit(
    omx_videoenc_component_PrivateType *omx_videoenc_component_Private) {

  omx_base_video_PortType *inPort =
      (omx_base_video_PortType *)omx_videoenc_component_Private
          ->ports[OMX_BASE_FILTER_INPUTPORT_INDEX];
  OMX_U32 target_coencID;
  avcodec_init();
  av_register_all();

  DEBUG(DEB_LEV_SIMPLE_SEQ, ""FFmpeg library/encoder initialized\n"");

  switch (omx_videoenc_component_Private->video_encoding_type) {
  case OMX_VIDEO_CodingMPEG4:
    target_coencID = CODEC_ID_MPEG4;
    break;
  default:
    DEBUG(DEB_LEV_ERR, ""\n encoders other than MPEG-4 are not supported -- ""
                       ""encoder not found\n"");
    return OMX_ErrorComponentNotFound;
  }

  omx_videoenc_component_Private->avCodec =
      avcodec_find_encoder(target_coencID);
  if (omx_videoenc_component_Private->avCodec == NULL) {
    DEBUG(DEB_LEV_ERR, ""Encoder Not found\n"");
    return OMX_ErrorInsufficientResources;
  }

  omx_videoenc_component_Private->avCodecContext = avcodec_alloc_context();
  omx_videoenc_component_Private->picture = avcodec_alloc_frame();

  omx_videoenc_component_Private->avCodecContext->bit_rate = 200000;
  omx_videoenc_component_Private->avCodecContext->bit_rate_tolerance = 4000000;
  omx_videoenc_component_Private->avCodecContext->width =
      inPort->sPortParam.format.video.nFrameWidth;
  omx_videoenc_component_Private->avCodecContext->height =
      inPort->sPortParam.format.video.nFrameHeight;

  DEBUG(DEB_LEV_SIMPLE_SEQ, ""Frame Rate=%d\n"",
        (int)inPort->sPortParam.format.video.xFramerate);
  omx_videoenc_component_Private->avCodecContext->time_base =
      (AVRational){1, inPort->sPortParam.format.video.xFramerate};
  omx_videoenc_component_Private->avCodecContext->gop_size =
      omx_videoenc_component_Private->pVideoMpeg4.nPFrames + 1;
  omx_videoenc_component_Private->avCodecContext->pix_fmt = PIX_FMT_YUV420P;
  omx_videoenc_component_Private->avCodecContext->strict_std_compliance =
      FF_COMPLIANCE_NORMAL;
  omx_videoenc_component_Private->avCodecContext->sample_fmt = SAMPLE_FMT_S16;
  omx_videoenc_component_Private->avCodecContext->qmin = 2;
  omx_videoenc_component_Private->avCodecContext->qmax = 31;
  omx_videoenc_component_Private->avCodecContext->workaround_bugs |=
      FF_BUG_AUTODETECT;

  if (omx_videoenc_component_Private->pVideoMpeg4.eProfile ==
      OMX_VIDEO_MPEG4ProfileAdvancedScalable) {
    omx_videoenc_component_Private->avCodecContext->max_b_frames =
        omx_videoenc_component_Private->pVideoMpeg4.nBFrames;
  }

  if (omx_videoenc_component_Private->pVideoMpeg4.bACPred == OMX_TRUE) {
    omx_videoenc_component_Private->avCodecContext->flags |= CODEC_FLAG_AC_PRED;
  }

#if 0  
  switch(omx_videoenc_component_Private->pVideoMpeg4.eLevel) {
  case OMX_VIDEO_MPEG4Level0:                    
  case OMX_VIDEO_MPEG4Level0b:                   
  case OMX_VIDEO_MPEG4Level1:                    
  case OMX_VIDEO_MPEG4Level2:                    
  case OMX_VIDEO_MPEG4Level3:                    
  case OMX_VIDEO_MPEG4Level4:                    
  case OMX_VIDEO_MPEG4Level4a:                   
  case OMX_VIDEO_MPEG4Level5:                    
  case default:
    break;
  }
#endif
  if (avcodec_open(omx_videoenc_component_Private->avCodecContext,
                   omx_videoenc_component_Private->avCodec) < 0) {
    DEBUG(DEB_LEV_ERR, ""Could not open encoder\n"");
    return OMX_ErrorInsufficientResources;
  }
  tsem_up(omx_videoenc_component_Private->avCodecSyncSem);
  DEBUG(DEB_LEV_SIMPLE_SEQ, ""done\n"");

  return OMX_ErrorNone;
}"
ImpulseAdventure-GUIslice-4bd031f/src/GUIslice_drv_adagfx.cpp	Copy the background image to destination screen	2	"void gslc_DrvDrawBkgnd(gslc_tsGui *pGui) {
  if (pGui->pvDriver) {
    gslc_tsDriver *pDriver = (gslc_tsDriver *)(pGui->pvDriver);

    if (pGui->sImgRefBkgnd.eImgFlags == GSLC_IMGREF_NONE) {

      gslc_tsRect rRect = (gslc_tsRect){0, 0, pGui->nDispW, pGui->nDispH};
      gslc_DrvDrawFillRect(pGui, rRect, pDriver->nColBkgnd);
    } else {

      gslc_DrvDrawImage(pGui, 0, 0, pGui->sImgRefBkgnd);
    }
  }
}"
debuti-PebbleNotepad-6bf3a43/src/main.c	This initializes the menu upon main_window load	2	"void main_window_load(Window *me) {
  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0, ""###main_window_load: Entering###"");

  Layer *main_window_layer = window_get_root_layer(me);
  GRect bounds = layer_get_bounds(main_window_layer);

  menu_layer = menu_layer_create(bounds);

  menu_layer_set_callbacks(
      menu_layer, NULL,
      (MenuLayerCallbacks){
          .get_num_sections = menu_get_num_sections_callback,
          .get_num_rows = menu_get_num_rows_callback,
          .get_header_height = menu_get_header_height_callback,
          .draw_header = menu_draw_header_callback,
          .draw_row = menu_draw_row_callback,
          .select_click = menu_select_callback,
      });

  menu_layer_set_click_config_onto_window(menu_layer, me);

  layer_add_child(main_window_layer, menu_layer_get_layer(menu_layer));

  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0, ""###main_window_load: Exiting###"");
}"
casadi-casadi-6b0de13/docs/examples/cplusplus/sensitivity_analysis.cpp	Generate a simple ODE.	2	"Test simpleODE() {

  SX t = SX::sym(""t"");

  SX u = SX::sym(""u"");

  SX s = SX::sym(""s""), v = SX::sym(""v""), m = SX::sym(""m"");
  SX x = vertcat(s, v, m);

  double alpha = 0.05;
  double beta = 0.1;

  SX ode = vertcat(v, (u - alpha * v * v) / m, -beta * u * u);

  SX quad = pow(v, 3) + pow((3 - sin(t)) - u, 2);

  Test r;
  r.dae = decltype(r.dae){
      {""t"", t}, {""x"", x}, {""p"", u}, {""ode"", ode}, {""quad"", quad}};
  r.tf = 0.5;
  r.x0 = {0, 0, 1};
  r.u0 = 0.4;
  r.is_ode = true;
  r.name = ""simple_ode"";
  return r;
}"
cmassiot-vlc-broadcast-de11815/libs/srtp/srtp.c	"Turns a RTP packet into a SRTP packet: encrypt it, then computes the authentication tag and appends it. Note that you can encrypt packet in disorder."	2	"srtp_send(srtp_session_t *s, uint8_t *buf, size_t *lenp, size_t bufsize) {
  size_t len = *lenp;
  size_t tag_len = s->tag_len;

  if (!(s->flags & SRTP_UNAUTHENTICATED)) {
    *lenp = len + tag_len;
    if (bufsize < (len + tag_len))
      return ENOSPC;
  }

  int val = srtp_crypt(s, buf, len);
  if (val)
    return val;

  if (!(s->flags & SRTP_UNAUTHENTICATED)) {
    uint32_t roc = srtp_compute_roc(s, rtp_seq(buf));
    const uint8_t *tag = rtp_digest(s, buf, len, roc);
    if (rcc_mode(s)) {
      assert(s->rtp_rcc);
      if ((rtp_seq(buf) % s->rtp_rcc) == 0) {
        memcpy(buf + len, &(uint32_t){htonl(s->rtp_roc)}, 4);
        len += 4;
        if (rcc_mode(s) == 3)
          tag_len = 0;
        else
          tag_len -= 4;
      } else {
        if (rcc_mode(s) & 1)
          tag_len = 0;
      }
    }
    memcpy(buf + len, tag, tag_len);
  }

  return 0;
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavutil/softfloat_ieee754.h	Make a softfloat out of the bitstream. Assumes the bits are in the form as defined by the IEEE 754 spec.	2	"static SoftFloat_IEEE754 av_bits2sf_ieee754(uint32_t n) {
  return ((SoftFloat_IEEE754){(n & 0x80000000UL), (n & 0x7FFFFFUL),
                              (n & 0x7F800000UL)});
}"
mikestir-timestore-d2c4586/src/http_tsdb.c	Generate random admin key. MUST be called during startup.	4	"void http_tsdb_gen_admin_key(int persistent) {
  const char *keychars = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0""
                         ""1234567890^(){}[]-_=+;:@#~<>,./?"";
  char *ptr = (char *)&g_admin_key;
  time_t now;
  int n, nkeychars;
  FILE *keyfile;

  FUNCTION_TRACE;

  now = time(NULL);
  srandom(now);

  if (persistent) {
    int nread = 0;

    keyfile = fopen(ADMIN_KEY_FILE, ""r"");
    if (keyfile >= 0) {
      nread = fread(&g_admin_key, 1, sizeof(g_admin_key), keyfile);
      fclose(keyfile);
    }
    if (nread == sizeof(g_admin_key)) {
      INFO(""Read persistent admin key: %.*s\n"", (int)sizeof(g_admin_key),
           (char *)&g_admin_key);
      return;
    }
  }

  nkeychars = strlen(keychars);
  for (n = 0; n < sizeof(g_admin_key); n++) {
    *ptr++ = keychars[random() % nkeychars];
  }

  INFO(""Generated admin key: %.*s\n"", (int)sizeof(g_admin_key),
       (char *)&g_admin_key);

  keyfile = fopen(ADMIN_KEY_FILE, ""w"");
  if (keyfile < 0) {
    ERROR(""Failed opening admin key file\n"");
    return;
  }
  fprintf(keyfile, ""%.*s\n"", (int)sizeof(g_admin_key), (char *)&g_admin_key);
  fclose(keyfile);
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/arrays.c	Create new definite array	2	"cbor_item_t *cbor_new_definite_array(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }

  cbor_item_t **data = _cbor_alloc_multiple(sizeof(cbor_item_t *), size);
  if (data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }

  for (size_t i = 0; i < size; i++)
    data[i] = NULL;

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_DEFINITE,
                                      .allocated = size,
                                      .end_ptr = 0}},
      .data = (unsigned char *)data};

  return item;
}"
johan162-hpdf_table-15de569/src/hpdf_table.c	Stroke the table at the specified position and size. The position is by default specified as the lower left corner of the table. Use the hpdf_table_set_origin_top_left() to use the top left of the table as reference point.	2	"hpdf_table_stroke(const HPDF_Doc pdf, const HPDF_Page page, hpdf_table_t t,
                  const HPDF_REAL xpos, const HPDF_REAL ypos,
                  const HPDF_REAL width, HPDF_REAL height) {

  if (NULL == pdf || NULL == page || NULL == t) {
    _SET_ERR(-6, -1, -1);
    return -1;
  }

  HPDF_REAL y = ypos;
  HPDF_REAL x = xpos;

  last_auto_height = 0;
  if (height <= 0) {

    height = t->content_style.fsize;
    if (t->use_cell_labels)
      height += t->label_style.fsize;
    height *= 1.5f * t->rows;
    last_auto_height = height;
  }

  const HPDF_REAL page_height = HPDF_Page_GetHeight(page);
  if (origin_as_top_left) {
    y = page_height - ypos - height;
    if (t->title_txt) {
      y -= 1.5f * t->title_style.fsize;
    }
  }

  t->pdf_doc = pdf;
  t->pdf_page = page;
  t->height = height;
  t->width = width;
  t->posx = x;
  t->posy = y;

  if (-1 == _calc_cell_pos(t)) {
    return -1;
  }

  HPDF_Page_SetRGBFill(page, t->content_style.background.r,
                       t->content_style.background.g,
                       t->content_style.background.b);
  HPDF_Page_Rectangle(page, x, y, width, height);
  HPDF_Page_Fill(page);

  HPDF_Page_SetRGBStroke(page, t->inner_border.color.r, t->inner_border.color.g,
                         t->inner_border.color.b);
  HPDF_Page_SetLineWidth(page, t->inner_border.width);
  for (size_t r = 0; r < t->rows; r++) {
    for (size_t c = 0; c < t->cols; c++) {
      hpdf_table_cell_t *cell = &t->cells[_IDX(r, c)];

      if (cell->parent_cell == NULL) {

        if (cell->style_cb) {
#ifdef __cplusplus
          hpdf_text_style_t style = {
              t->content_style.font, t->content_style.fsize,
              t->content_style.color, t->content_style.background,
              t->content_style.halign};
#else
          hpdf_text_style_t style = (hpdf_text_style_t){
              t->content_style.font, t->content_style.fsize,
              t->content_style.color, t->content_style.background,
              t->content_style.halign};
#endif
          if (cell->style_cb(t->tag, r, c, &style)) {
            HPDF_Page_SetRGBFill(page, style.background.r, style.background.g,
                                 style.background.b);
            HPDF_Page_Rectangle(page, x + cell->delta_x, y + cell->delta_y,
                                cell->width, cell->height);
            HPDF_Page_Fill(page);
          }
        } else if (cell->content_style.font) {

          HPDF_Page_SetRGBFill(page, cell->content_style.background.r,
                               cell->content_style.background.g,
                               cell->content_style.background.b);
          HPDF_Page_Rectangle(page, x + cell->delta_x, y + cell->delta_y,
                              cell->width, cell->height);
          HPDF_Page_Fill(page);
        }

        if (cell->canvas_cb) {
          cell->canvas_cb(pdf, page, t->tag, r, c, x + cell->delta_x,
                          y + cell->delta_y, cell->width, cell->height);
        } else if (t->canvas_cb) {
          t->canvas_cb(pdf, page, t->tag, r, c, x + cell->delta_x,
                       y + cell->delta_y, cell->width, cell->height);
        }

        _table_cell_stroke(t, r, c);

        HPDF_Page_SetLineWidth(page, t->inner_border.width);

        if (t->use_label_grid_style) {

          if (cell->rowspan > 1) {
            HPDF_Page_MoveTo(page, x + cell->delta_x, y + cell->delta_y);
          } else {
            HPDF_Page_MoveTo(page, x + cell->delta_x,
                             y + cell->delta_y + cell->height -
                                 t->label_style.fsize * 1.2f);
          }
          HPDF_Page_LineTo(page, x + cell->delta_x,
                           y + cell->delta_y + cell->height);
          HPDF_Page_MoveTo(page, x + cell->delta_x,
                           y + cell->delta_y + cell->height);
          HPDF_Page_LineTo(page, x + cell->delta_x + cell->width,
                           y + cell->delta_y + cell->height);

        } else {

          HPDF_Page_Rectangle(page, x + cell->delta_x, y + cell->delta_y,
                              cell->width, cell->height);
        }

        HPDF_Page_Stroke(page);
      }
    }
  }

  HPDF_Page_SetRGBStroke(page, t->outer_border.color.r, t->outer_border.color.g,
                         t->outer_border.color.b);
  HPDF_Page_SetLineWidth(page, t->outer_border.width);
  HPDF_Page_Rectangle(page, x, y, width, height);
  HPDF_Page_Stroke(page);

  if (t->use_header_row) {
    hpdf_table_cell_t *cell = &t->cells[_IDX(0, 0)];
    HPDF_Page_MoveTo(page, x + cell->delta_x, y + cell->delta_y);
    HPDF_Page_LineTo(page, x + width, y + cell->delta_y);
    HPDF_Page_Stroke(page);
  }

  const HPDF_REAL title_height = _table_title_stroke(t);
  if (last_auto_height > 0) {
    last_auto_height += title_height;
  }

  return 0;
}"
kemadz-monit-9b51725/src/validate.c	Validate a given process service s. Events are posted according to its configuration. In case of a fatal event false is returned.	2	"State_Type check_process(Service_T s) {
  ASSERT(s);
  State_Type rv = State_Succeeded;
  pid_t pid = ProcessTree_findProcess(s);
  if (!pid) {
    for (NonExist_T l = s->nonexistlist; l; l = l->next) {
      rv = State_Failed;
      Event_post(s, Event_NonExist, State_Failed, l->action,
                 ""process is not running"");
    }
    for (Exist_T l = s->existlist; l; l = l->next) {
      Event_post(s, Event_Exist, State_Succeeded, l->action,
                 ""process is not running"");
    }
    return rv;
  } else {
    for (NonExist_T l = s->nonexistlist; l; l = l->next) {
      Event_post(s, Event_NonExist, State_Succeeded, l->action,
                 ""process is running with pid %d"", (int)pid);
    }
    for (Exist_T l = s->existlist; l; l = l->next) {
      rv = State_Failed;
      Event_post(s, Event_Exist, State_Failed, l->action,
                 ""process is running with pid %d"", (int)pid);
    }
  }

  if (IS_EVENT_SET(s->error, Event_Exec))
    Event_post(s, Event_Exec, State_Succeeded, s->action_EXEC,
               ""process is running after previous exec error (slow starting or ""
               ""manually recovered?)"");
  if (IS_EVENT_SET(s->error, Event_Timeout))
    for (ActionRate_T ar = s->actionratelist; ar; ar = ar->next)
      Event_post(s, Event_Timeout, State_Succeeded, ar->action,
                 ""process is running after previous restart timeout (manually ""
                 ""recovered?)"");
  if (Run.flags & Run_ProcessEngineEnabled) {
    if (ProcessTree_updateProcess(s, pid)) {
      if (_checkProcessState(s) == State_Failed)
        rv = State_Failed;
      if (_checkProcessPid(s) == State_Failed)
        rv = State_Failed;
      if (_checkProcessPpid(s) == State_Failed)
        rv = State_Failed;
      if (_checkUid(s, s->inf.process->uid) == State_Failed)
        rv = State_Failed;
      if (_checkEuid(s, s->inf.process->euid) == State_Failed)
        rv = State_Failed;
      if (_checkGid(s, s->inf.process->gid) == State_Failed)
        rv = State_Failed;
      if (_checkUptime(s, s->inf.process->uptime) == State_Failed)
        rv = State_Failed;
      for (Resource_T pr = s->resourcelist; pr; pr = pr->next)
        if (_checkProcessResources(s, pr) == State_Failed)
          rv = State_Failed;
    } else {
      LogError(""'%s' failed to get service data\n"", s->name);
      rv = State_Failed;
    }
  }
  int64_t uptimeMilli = s->inf.process->uptime * 1000;
  for (Port_T pp = s->portlist; pp; pp = pp->next) {

    if (!s->start || uptimeMilli > s->start->timeout) {
      if (_checkConnection(s, pp) == State_Failed)
        rv = State_Failed;
    } else {
      pp->is_available = Connection_Init;
      DEBUG(
          ""'%s' connection test paused for %s while the process is starting\n"",
          s->name,
          Str_milliToTime(s->start->timeout -
                              (uptimeMilli < 0 ? 0 : uptimeMilli),
                          (char[23]){}));
    }
  }
  for (Port_T pp = s->socketlist; pp; pp = pp->next) {

    if (!s->start || uptimeMilli > s->start->timeout) {
      if (_checkConnection(s, pp) == State_Failed)
        rv = State_Failed;
    } else {
      pp->is_available = Connection_Init;
      DEBUG(
          ""'%s' connection test paused for %s while the process is starting\n"",
          s->name,
          Str_milliToTime(s->start->timeout -
                              (uptimeMilli < 0 ? 0 : uptimeMilli),
                          (char[23]){}));
    }
  }
  return rv;
}"
field-FieldKit.cpp-a2e9d4f/include/fieldkit/physics/strategy/ParticleUpdate.h	updates all particles by applying all behaviours and constraints	2	"public:
ParticleUpdate() { constraintIterations = 1; };
~ParticleUpdate(){};

void apply(Physics *physics, float dt);

void setConstraintIterations(int iterations) {
  constraintIterations = iterations;
};
int getConstraintIterations() { return constraintIterations; };

protected:
int constraintIterations;
}
;
}
}"
mtraiola-XbarGen-1f147f4/include/entities.h	Prints out the matrix through the std output	2	"map<string, int> literalCount;

public:
Function(){};
Function(vector<string> inputs, vector<string> outputs,
         multimap<string, vector<string>> minterms)
    : inputs(inputs), outputs(outputs), minterms(minterms){};
void addInput(string s) { inputs.push_back(s); }"
mrRay-VVISF-GL-5ca4cc8/VVGL/include/GLCPUToTexCopier.hpp	"Sets the size of the queue used for streaming. Effectively, this is the number of calls it takes for the CPU data to ""finish uploading"" and get returned as a texture."	2	"private:
void _beginProcessing(const GLBufferRef &inCPUBuffer,
                      const GLBufferRef &inPBOBuffer,
                      const GLBufferRef &inTexBuffer);
void _finishProcessing(const GLBufferRef &inCPUBuffer,
                       const GLBufferRef &inPBOBuffer,
                       const GLBufferRef &inTexBuffer);

public:
GLCPUToTexCopier();
GLCPUToTexCopier(const GLContextRef &inCtx) : _queueCtx(inCtx){};
~GLCPUToTexCopier();

GLContextRef context() { return _queueCtx; }"
Melown-libmath-09a4a31/math/signal.hpp	"provide a signal sample at given position, of given value, and with given sampling period hint."	2	"namespace math {

class Signal2Base {

public:
  enum Type_t { Nonperiodic = 0x00, Xperiodic = 0x01 };

  Signal2Base(int sizeX, int sizeY, const double llx, const double lly,
              const double urx, const double ury,
              const Type_t type = Nonperiodic);

  int width() const { return sizeX; }
  int height() const { return sizeY; }

  double pixelX() { return pixelx; }
  double pixelY() { return pixely; }

  struct Cell_s {

    enum {

      QUADRANT_LL = 0x01,
      QUADRANT_LR = 0x02,
      QUADRANT_UL = 0x04,
      QUADRANT_UR = 0x08,

      QUADRANT_NONE = 0x00,
      QUADRANT_ALL = 0x0f

    };

    double valueSum, pwsum, nwsum;
    unsigned char quadrants;

    Cell_s()
        : valueSum(0.0), pwsum(0.0), nwsum(0.0), quadrants(QUADRANT_NONE){};

    bool defined() const {

      if (pwsum - nwsum < 1E-15)
        return false;
      if (pwsum <= 3 * nwsum)
        return false;
      if (quadrants != QUADRANT_ALL)
        return false;

      return true;
    }"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/Printer.c	"Retrieves the attached printer device's ID string, formatted according to IEEE 1284. This string is sent as a Unicode string from the device and is automatically converted to an ASCII encoded C string by this function, thus the maximum reportable string length is two less than the size given (to accommodate the Unicode string length bytes which are removed). This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device."	2	"uint8_t
PRNT_Host_GetDeviceID(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                      char *const DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = be16_to_cpu(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	"Compares the lower double-precision floating-point values in each of the two 128-bit floating-point vectors of [2 x double] to determine if the value in the first parameter is greater than the corresponding value in the second parameter. The comparison yields 0x0 for false, 0xFFFFFFFFFFFFFFFF for true."	2	"_mm_cmpgt_sd(__m128d __a, __m128d __b) {
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return __extension__(__m128d){__c[0], __a[1]};
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/bytestrings.c	Creates a new indefinite byte string	2	"cbor_item_t *cbor_new_indefinite_bytestring() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_BYTESTRING,
      .metadata = {.bytestring_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                           .length = 0}},
      .data = _CBOR_MALLOC(sizeof(struct cbor_indefinite_string_data))};
  *((struct cbor_indefinite_string_data *)item->data) =
      (struct cbor_indefinite_string_data){
          .chunk_count = 0,
          .chunk_capacity = 0,
          .chunks = NULL,
      };
  return item;
}"
CZ-NIC-knot-resolver-3775bbc/lib/cache/entry_list.c	"Prepare space to insert an entry. Some checks are performed (rank, TTL), the current entry in cache is copied with a hole ready for the new entry (old one of the same type is cut out)."	2	"int entry_h_splice(knot_db_val_t *val_new_entry, uint8_t rank,
                   const knot_db_val_t key, const uint16_t ktype,
                   const uint16_t type, const knot_dname_t *owner,
                   const struct kr_query *qry, struct kr_cache *cache,
                   uint32_t timestamp) {

  const bool ok = val_new_entry && val_new_entry->len > 0;
  if (!ok) {
    assert(!EINVAL);
    return kr_error(EINVAL);
  }

  int i_type;
  switch (type) {
  case KNOT_RRTYPE_NS:
    i_type = EL_NS;
    break;
  case KNOT_RRTYPE_CNAME:
    i_type = EL_CNAME;
    break;
  case KNOT_RRTYPE_DNAME:
    i_type = EL_DNAME;
    break;
  default:
    i_type = 0;
  }

  const struct entry_h *eh_orig = NULL;
  entry_list_t el;
  int ret = -1;
  if (!kr_rank_test(rank, KR_RANK_SECURE) || ktype == KNOT_RRTYPE_NS) {
    knot_db_val_t val;
    ret = cache_op(cache, read, &key, &val, 1);
    if (i_type) {
      if (!ret)
        ret = entry_list_parse(val, el);
      if (ret)
        memset(el, 0, sizeof(el));
      val = el[i_type];
    }

    if (!ret) {
      eh_orig = entry_h_consistent(val, type);
    }
  } else {

    memset(el, 0, sizeof(el));
  }

  if (!kr_rank_test(rank, KR_RANK_SECURE) && eh_orig) {

    int32_t old_ttl = get_new_ttl(eh_orig, qry, NULL, 0, timestamp);
    if (old_ttl > 0 && !is_expiring(eh_orig->ttl, old_ttl) &&
        rank <= eh_orig->rank) {
      WITH_VERBOSE(qry) {
        auto_free char *type_str = kr_rrtype_text(type),
                       *owner_str = kr_dname_text(owner);
        VERBOSE_MSG(qry, ""=> not overwriting %s %s\n"", type_str, owner_str);
      }
      return kr_error(EEXIST);
    }
  }

  if (!i_type) {

    return cache_write_or_clear(cache, &key, val_new_entry, qry);
  }

  el[i_type] = (knot_db_val_t){
      .len = val_new_entry->len,
      .data = NULL,
  };
  knot_db_val_t val = {
      .len = entry_list_serial_size(el),
      .data = NULL,
  };
  void *buf = mm_alloc(&qry->request->pool, val.len);
  entry_list_memcpy(buf, el);
  ret = cache_write_or_clear(cache, &key, &val, qry);
  if (ret)
    return kr_error(ret);
  memcpy(val.data, buf, val.len);
  val_new_entry->data =
      (uint8_t *)val.data + ((uint8_t *)el[i_type].data - (uint8_t *)buf);
  return kr_ok();
}"
truls-libsme-8e97b7c/cbits/api.c	"Propagates the values of both internal and external facing buses defined in libsme. Run this function before the clock is advanced (by calling sme_tick) in the simulation loop and it should be run together with any bus propagations that need to be performed by the calling code. When this function returns, the values of all buses defined within libsme have been propagated."	2	"sme_propagate(SmeCtx *ctx) {
  Bus *bus;
  Channel *chan;

  for (bus = ctx->buses; bus != NULL; bus = bus->hh.next) {
    for (chan = bus->channel; chan != NULL; chan = chan->hh.next) {
      switch (chan->type) {
      case SME_INT:
      case SME_UINT: {
        SMEInt *rv = chan->read.value.integer;
        SMEInt *wv = chan->write.value.integer;
        sme_integer_resize(rv, wv->len);
        memcpy(rv->num, wv->num, wv->len);
        rv->len = wv->len;
        rv->negative = wv->negative;
        chan->read.undef = chan->write.undef;
        break;
      }
      default:
        chan->read = chan->write;

        chan->write = (Value){
            .type = chan->write.type, .undef = chan->read.undef, .value = {0}};
      }
      assert(bus->name);
      assert(chan);
      assert(chan->name);
    }
  }

  return hs_propagate_buses(ctx->sim_state);
}"
simsong-frag_find-59782b2/src/dfxml.h	Remember - 's' is NOT null-terminated	4	"static void read_dfxml(const std::string &fname, fileobject_callback_t process);
static void characterDataHandler(void *userData, const XML_Char *s, int len);

virtual ~file_object_reader(){};
file_object_reader()
    : XMLReader(), volumeobject(), fileobject(), callback(), hashdigest_type() {
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_hash.c	Notice that these Hash objects are designed for smaller collections and retain order of object insertion.	2	"FIOBJ fiobj_hash_new(void) {
  fiobj_hash_s *h = fio_malloc(sizeof(*h));
  FIO_ASSERT_ALLOC(h);
  *h = (fiobj_hash_s){.head = {.ref = 1, .type = FIOBJ_T_HASH},
                      .hash = FIO_SET_INIT};
  return (FIOBJ)h | FIOBJECT_HASH_FLAG;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/dpg/compute_all_rlhs_dpg_T.c	Increment the lhs terms with the contribution of the boundary face.	2	"(struct Matrix_T *lhs, const struct Numerical_Flux_T *num_flux,
 const struct Solver_Face_T *s_face, const struct Simulation *sim) {
  UNUSED(sim);
  assert(((struct Face *)s_face)->boundary);

  struct Matrix_T *lhs_ll =
      constructor_lhs_f_1_T((int[]){0, 0}, num_flux, s_face);

  set_block_Matrix_T(lhs, 0, 0, (struct const_Matrix_T *)lhs_ll, 0, 0,
                     lhs_ll->ext_0, lhs_ll->ext_1, 'a');
  destructor_Matrix_T(lhs_ll);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the squareroot of a quaternion	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qsqrtl(const quaternion_long_double num) {
  return qmidl(num, (quaternion_long_double){1.0L, 0.0L, 0.0L, 0.0L});
}"
Proxmark-proxmark3-fdd9395/client/cmdhf15.c	Commandline handling: HF15 CMD READ Reads a single Block	2	"int CmdHF15CmdRead(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[100] = """";

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(""Usage:  hf 15 cmd read    [options] <uid|s|u|*> <page#>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           page#:        page number 0-255"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15693_READBLOCK}, 1);
  reqlen = c.arg[0];

  pagenum = strtol(cmd, NULL, 0);

  req[reqlen++] = (uint8_t)pagenum;

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15693_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15693_RES_ERROR)) {
        *output = 0;

        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%02X "", recv[i]);
        }
        strcat(output, ""   "");
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%c"",
                  recv[i] > 31 && recv[i] < 127 ? recv[i] : '.');
        }
        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[1], TagErrorStr(recv[1]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""no answer"");
  }

  return 0;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/Printer.c	"Retrieves the attached printer device's ID string, formatted according to IEEE 1284. This string is sent as a Unicode string from the device and is automatically converted to an ASCII encoded C string by this function, thus the maximum reportable string length is two less than the size given (to accommodate the Unicode string length bytes which are removed). This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device."	2	"uint8_t
PRNT_Host_GetDeviceID(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                      char *const DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = SwapEndian_16(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the negative quaternion	2	"LIB_FUNC MATH_FUNC quaternion_float qnegf(const quaternion_float qnum) {
  return (quaternion_float){(-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k)};
}"
mansoncui-monit-1d7cce1/src/validate.c	Validate a given process service s. Events are posted according to its configuration. In case of a fatal event false is returned.	2	"State_Type check_process(Service_T s) {
  ASSERT(s);
  State_Type rv = State_Succeeded;
  pid_t pid = ProcessTree_findProcess(s);
  if (!pid) {
    for (NonExist_T l = s->nonexistlist; l; l = l->next) {
      rv = State_Failed;
      Event_post(s, Event_NonExist, State_Failed, l->action,
                 ""process is not running"");
    }
    for (Exist_T l = s->existlist; l; l = l->next) {
      Event_post(s, Event_Exist, State_Succeeded, l->action,
                 ""process is not running"");
    }
    return rv;
  } else {
    for (NonExist_T l = s->nonexistlist; l; l = l->next) {
      Event_post(s, Event_NonExist, State_Succeeded, l->action,
                 ""process is running with pid %d"", (int)pid);
    }
    for (Exist_T l = s->existlist; l; l = l->next) {
      rv = State_Failed;
      Event_post(s, Event_Exist, State_Failed, l->action,
                 ""process is running with pid %d"", (int)pid);
    }
  }

  if (IS_EVENT_SET(s->error, Event_Exec))
    Event_post(s, Event_Exec, State_Succeeded, s->action_EXEC,
               ""process is running after previous exec error (slow starting or ""
               ""manually recovered?)"");
  if (IS_EVENT_SET(s->error, Event_Timeout))
    for (ActionRate_T ar = s->actionratelist; ar; ar = ar->next)
      Event_post(s, Event_Timeout, State_Succeeded, ar->action,
                 ""process is running after previous restart timeout (manually ""
                 ""recovered?)"");
  if (Run.flags & Run_ProcessEngineEnabled) {
    if (ProcessTree_updateProcess(s, pid)) {
      if (_checkProcessState(s) == State_Failed)
        rv = State_Failed;
      if (_checkProcessPid(s) == State_Failed)
        rv = State_Failed;
      if (_checkProcessPpid(s) == State_Failed)
        rv = State_Failed;
      if (_checkUid(s, s->inf.process->uid) == State_Failed)
        rv = State_Failed;
      if (_checkEuid(s, s->inf.process->euid) == State_Failed)
        rv = State_Failed;
      if (_checkGid(s, s->inf.process->gid) == State_Failed)
        rv = State_Failed;
      if (_checkUptime(s, s->inf.process->uptime) == State_Failed)
        rv = State_Failed;
      if (_checkSecurityAttribute(s, s->inf.process->secattr) == State_Failed)
        rv = State_Failed;
      for (Resource_T pr = s->resourcelist; pr; pr = pr->next)
        if (_checkProcessResources(s, pr) == State_Failed)
          rv = State_Failed;
    } else {
      LogError(""'%s' failed to get service data\n"", s->name);
      rv = State_Failed;
    }
  }
  int64_t uptimeMilli = (int64_t)(s->inf.process->uptime) * 1000LL;
  for (Port_T pp = s->portlist; pp; pp = pp->next) {

    if (!s->start || uptimeMilli > s->start->timeout) {
      if (_checkConnection(s, pp) == State_Failed)
        rv = State_Failed;
    } else {
      pp->is_available = Connection_Init;
      DEBUG(
          ""'%s' connection test paused for %s while the process is starting\n"",
          s->name,
          Str_time2str(s->start->timeout - (uptimeMilli < 0 ? 0 : uptimeMilli),
                       (char[11]){}));
    }
  }
  for (Port_T pp = s->socketlist; pp; pp = pp->next) {

    if (!s->start || uptimeMilli > s->start->timeout) {
      if (_checkConnection(s, pp) == State_Failed)
        rv = State_Failed;
    } else {
      pp->is_available = Connection_Init;
      DEBUG(
          ""'%s' connection test paused for %s while the process is starting\n"",
          s->name,
          Str_time2str(s->start->timeout - (uptimeMilli < 0 ? 0 : uptimeMilli),
                       (char[11]){}));
    }
  }
  return rv;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/Incomplete/BluetoothHost/Lib/BluetoothHCICommands.c	Bluetooth HCI processing task. This task should be called repeatedly the main Bluetooth stack task to manage the HCI processing state.	0	"void Bluetooth_HCITask(void) {
  BT_HCICommand_Header_t HCICommandHeader;

  switch (Bluetooth_State.CurrentHCIState) {
  case Bluetooth_ProcessEvents:
    Pipe_SelectPipe(BLUETOOTH_EVENTS_PIPE);
    Pipe_Unfreeze();

    if (Pipe_IsReadWriteAllowed()) {
      BT_HCIEvent_Header_t HCIEventHeader;

      Pipe_Read_Stream_LE(&HCIEventHeader, sizeof(HCIEventHeader));

      uint8_t EventParams[HCIEventHeader.ParameterLength];

      Pipe_Read_Stream_LE(&EventParams, HCIEventHeader.ParameterLength);
      Pipe_ClearIN();

      BT_HCI_DEBUG(1, ""Event Received (0x%02X)"", HCIEventHeader.EventCode);

      switch (HCIEventHeader.EventCode) {
      case EVENT_COMMAND_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Command Complete"");

        switch (((BT_HCIEvent_CommandComplete_t *)&EventParams)->Opcode) {
        case (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBDADDR):

          memcpy(
              Bluetooth_State.LocalBDADDR,
              &((BT_HCIEvent_CommandComplete_t *)&EventParams)->ReturnParams[1],
              sizeof(Bluetooth_State.LocalBDADDR));
          break;
        }

        Bluetooth_State.CurrentHCIState = Bluetooth_State.NextHCIState;
        break;
      case EVENT_COMMAND_STATUS:
        BT_HCI_DEBUG(1, ""<< Command Status"");
        BT_HCI_DEBUG(2, ""-- Status Code: 0x%02X"",
                     (((BT_HCIEvent_CommandStatus_t *)&EventParams)->Status));

        if (((BT_HCIEvent_CommandStatus_t *)&EventParams)->Status)
          Bluetooth_State.CurrentHCIState = Bluetooth_Init;
        break;
      case EVENT_CONNECTION_REQUEST:
        BT_HCI_DEBUG(1, ""<< Connection Request"");
        BT_HCI_DEBUG(
            2, ""-- Link Type: 0x%02X"",
            (((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->LinkType));

        memcpy(
            Bluetooth_TempDeviceAddress,
            &((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->RemoteAddress,
            sizeof(Bluetooth_TempDeviceAddress));

        bool IsACLConnection =
            (((BT_HCIEvent_ConnectionRequest_t *)&EventParams)->LinkType ==
             0x01);

        Bluetooth_State.CurrentHCIState =
            (Bluetooth_Connection.IsConnected || !(IsACLConnection) ||
             !(Bluetooth_ConnectionRequest(Bluetooth_TempDeviceAddress)))
                ? Bluetooth_Conn_RejectConnection
                : Bluetooth_Conn_AcceptConnection;

        BT_HCI_DEBUG(
            2, ""-- Connection %S"",
            (Bluetooth_State.CurrentHCIState == Bluetooth_Conn_RejectConnection)
                ? PSTR(""REJECTED"")
                : PSTR(""ACCEPTED""));

        break;
      case EVENT_PIN_CODE_REQUEST:
        BT_HCI_DEBUG(1, ""<< Pin Code Request"");

        memcpy(Bluetooth_TempDeviceAddress,
               &((BT_HCIEvent_PinCodeReq_t *)&EventParams)->RemoteAddress,
               sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_State.CurrentHCIState = Bluetooth_Conn_SendPINCode;
        break;
      case EVENT_LINK_KEY_REQUEST:
        BT_HCI_DEBUG(1, ""<< Link Key Request"");

        memcpy(Bluetooth_TempDeviceAddress,
               &((BT_HCIEvent_LinkKeyReq_t *)&EventParams)->RemoteAddress,
               sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_State.CurrentHCIState = Bluetooth_Conn_SendLinkKeyNAK;
        break;
      case EVENT_CONNECTION_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Connection Complete"");
        BT_HCI_DEBUG(2, ""-- Handle: 0x%04X"",
                     ((BT_HCIEvent_ConnectionComplete_t *)&EventParams)
                         ->ConnectionHandle);

        memcpy(
            Bluetooth_Connection.RemoteAddress,
            &((BT_HCIEvent_ConnectionComplete_t *)&EventParams)->RemoteAddress,
            sizeof(Bluetooth_TempDeviceAddress));

        Bluetooth_Connection.ConnectionHandle =
            ((BT_HCIEvent_ConnectionComplete_t *)&EventParams)
                ->ConnectionHandle;
        Bluetooth_Connection.IsConnected = true;

        Bluetooth_ConnectionComplete();
        break;
      case EVENT_DISCONNECTION_COMPLETE:
        BT_HCI_DEBUG(1, ""<< Disconnection Complete"");

        Bluetooth_Connection.IsConnected = false;

        Bluetooth_DisconnectionComplete();
        break;
      }
    }

    Pipe_Freeze();

    break;
  case Bluetooth_Init:
    BT_HCI_DEBUG(1, ""# Init"");

    Bluetooth_State.IsInitialized = false;

    memset(&Bluetooth_Connection, 0x00, sizeof(Bluetooth_Connection));

    Bluetooth_State.CurrentHCIState = Bluetooth_Init_Reset;
    break;
  case Bluetooth_Init_Reset:
    BT_HCI_DEBUG(1, ""# Reset"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_RESET),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_ReadBufferSize;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_ReadBufferSize:
    BT_HCI_DEBUG(1, ""# Read Buffer Size"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode :
          (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBUFFERSIZE),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_GetBDADDR;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_GetBDADDR:
    BT_HCI_DEBUG(1, ""# Get BDADDR"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_INFORMATIONAL | OCF_CTRLR_INFORMATIONAL_READBDADDR),
      ParameterLength : 0,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader, NULL, 0);

    Bluetooth_State.NextHCIState = Bluetooth_Init_SetLocalName;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_SetLocalName:
    BT_HCI_DEBUG(1, ""# Set Local Name"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_LOCAL_NAME),
      ParameterLength : 248,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader,
                             Bluetooth_DeviceConfiguration.Name,
                             strlen(Bluetooth_DeviceConfiguration.Name));

    Bluetooth_State.NextHCIState = Bluetooth_Init_SetDeviceClass;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_SetDeviceClass:
    BT_HCI_DEBUG(1, ""# Set Device Class"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_CLASS_OF_DEVICE),
      ParameterLength : 3,
    };

    Bluetooth_SendHCICommand(&HCICommandHeader,
                             &Bluetooth_DeviceConfiguration.Class, 3);

    Bluetooth_State.NextHCIState = Bluetooth_Init_WriteScanEnable;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_WriteScanEnable:
    BT_HCI_DEBUG(1, ""# Write Scan Enable"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_CTRLR_BASEBAND | OCF_CTRLR_BASEBAND_WRITE_SCAN_ENABLE),
      ParameterLength : 1,
    };

    uint8_t Interval = BT_SCANMODE_InquiryAndPageScans;

    Bluetooth_SendHCICommand(&HCICommandHeader, &Interval, 1);

    Bluetooth_State.NextHCIState = Bluetooth_Init_FinalizeInit;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Init_FinalizeInit:
    Bluetooth_State.IsInitialized = true;

    Bluetooth_StackInitialized();

    Bluetooth_State.NextHCIState = Bluetooth_ProcessEvents;
    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_AcceptConnection:
    BT_HCI_DEBUG(1, ""# Accept Connection"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_ACCEPT_CONNECTION_REQUEST),
      ParameterLength : sizeof(BT_HCICommand_AcceptConnectionReq_t),
    };

    BT_HCICommand_AcceptConnectionReq_t AcceptConnectionParams;
    memcpy(AcceptConnectionParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(AcceptConnectionParams.RemoteAddress));
    AcceptConnectionParams.SlaveRole = true;

    Bluetooth_SendHCICommand(&HCICommandHeader, &AcceptConnectionParams,
                             sizeof(BT_HCICommand_AcceptConnectionReq_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_RejectConnection:
    BT_HCI_DEBUG(1, ""# Reject Connection"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_REJECT_CONNECTION_REQUEST),
      ParameterLength : sizeof(BT_HCICommand_RejectConnectionReq_t),
    };

    BT_HCICommand_RejectConnectionReq_t RejectConnectionParams;
    memcpy(RejectConnectionParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(RejectConnectionParams.RemoteAddress));
    RejectConnectionParams.Reason = Bluetooth_Connection.IsConnected
                                        ? ERROR_LIMITED_RESOURCES
                                        : ERROR_UNACCEPTABLE_BDADDR;

    Bluetooth_SendHCICommand(&HCICommandHeader, &RejectConnectionParams,
                             sizeof(BT_HCICommand_RejectConnectionReq_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_SendPINCode:
    BT_HCI_DEBUG(1, ""# Send Pin Code"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_PIN_CODE_REQUEST_REPLY),
      ParameterLength : sizeof(BT_HCICommand_PinCodeResp_t),
    };

    BT_HCICommand_PinCodeResp_t PINCodeRequestParams;
    memcpy(PINCodeRequestParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(PINCodeRequestParams.RemoteAddress));
    PINCodeRequestParams.PINCodeLength =
        strlen(Bluetooth_DeviceConfiguration.PINCode);
    memcpy(PINCodeRequestParams.PINCode, Bluetooth_DeviceConfiguration.PINCode,
           sizeof(PINCodeRequestParams.PINCode));

    Bluetooth_SendHCICommand(&HCICommandHeader, &PINCodeRequestParams,
                             sizeof(BT_HCICommand_PinCodeResp_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  case Bluetooth_Conn_SendLinkKeyNAK:
    BT_HCI_DEBUG(1, ""# Send Link Key NAK"");

    HCICommandHeader = (BT_HCICommand_Header_t){
      OpCode : (OGF_LINK_CONTROL | OCF_LINK_CONTROL_LINK_KEY_REQUEST_NEG_REPLY),
      ParameterLength : sizeof(BT_HCICommand_LinkKeyNAKResp_t),
    };

    BT_HCICommand_LinkKeyNAKResp_t LinkKeyNAKParams;
    memcpy(LinkKeyNAKParams.RemoteAddress, Bluetooth_TempDeviceAddress,
           sizeof(LinkKeyNAKParams.RemoteAddress));

    Bluetooth_SendHCICommand(&HCICommandHeader, &LinkKeyNAKParams,
                             sizeof(BT_HCICommand_LinkKeyNAKResp_t));

    Bluetooth_State.CurrentHCIState = Bluetooth_ProcessEvents;
    break;
  }
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/floats_ctrls.c	Constructs a new ctrl item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_ctrl() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = NULL,
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_0,
                                           .ctrl = CBOR_CTRL_NONE}}};
  return item;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/eh.c	"The defer intrinsic macro. Syntax: ""defer"" {statement} body... {statement} ::= block | syntax-unit+ If statement is a single block, the contents of the block are evaluated as described below. Otherwise, the statement resulting from the remaning syntax units in the defer statement are used. All statements following the defer are used as its body. Semantics: The defer macro has exactly the same semantics as try { body } finally { statement } Rationale: This defer construct is intended to serve much the same purpose as the construct of the same name in Go, providing a convenient way to guarantee destruction of a resource which is located in source immediately after its acquisition and which doesn't require adding another level of explicit nesting / indentation. Note that it has very different semantics than the defer statement in Go. Go requires the statement to be a function call and evaluates its arguments when the defer statement is encountered; Avalanche allows any statement (or even group of statements), but evaluates nothing until the defer statement is actually run. Furthermore, Go defer statements add elements to a stack of pending actions which occur when the function exits, while Avalanche's defer takes effect when the lexical scope is exited. In the majority of cases, the two end up being mostly equivalent. When they do differ, lexical scoping is felt to usually be more useful. The use of lexical scoping also greatly diminishes the need to evaluate parameters early; furthermore, evaluating nothing until the deferred statement is executed permits inspecting the results of the body. It is possible to construct a Go-like defer using Avalanche defer, but the reverse is not possible."	2	"ava_macro_subst_result ava_intr_defer_subst(
    const struct ava_symbol_s *self, ava_macsub_context *context,
    const ava_parse_statement *statement, const ava_parse_unit *provoker,
    ava_bool *consumed_other_statements) {
  const ava_parse_unit *finally_begin, *finally_end;
  ava_intr_try *this;

  finally_begin = TAILQ_NEXT(provoker, next);
  assert(finally_begin);
  finally_end = TAILQ_LAST(&statement->units, ava_parse_unit_list_s);

  this = ava_intr_try_new(context, provoker, 0);
  this->expression_form = ava_false;
  this->is_defer = ava_true;
  if (finally_begin == finally_end && ava_put_block == finally_begin->type) {
    this->finally = ava_macsub_run_contents(context, finally_begin);
  } else {
    this->finally = ava_macsub_run_units(context, finally_begin, finally_end);
  }
  this->body = ava_macsub_run_from(context, &this->header.location,
                                   TAILQ_NEXT(statement, next), ava_isrp_void);

  *consumed_other_statements = ava_true;
  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v = {.node = (ava_ast_node *)this},
  };
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/VirtualSerialHost/VirtualSerialHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  CDC_LineEncoding_t LineEncoding = {.BaudRateBPS = 9600,
                                     .CharFormat = CDC_LINEENCODING_OneStopBit,
                                     .ParityType = CDC_PARITY_None,
                                     .DataBits = 8};

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SetLineEncoding,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(LineEncoding),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  if (USB_Host_SendControlRequest(&LineEncoding) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Line Encoding).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  puts_P(PSTR(""CDC Device Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;
    if (!link->src || !link->dst) {
      av_log(filter, AV_LOG_ERROR,
             ""Not all input and output are properly linked (%d).\n"", i);
      return AVERROR(EINVAL);
    }

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = link->current_pts_us = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink) {
          if (!link->frame_rate.num && !link->frame_rate.den)
            link->frame_rate = inlink->frame_rate;
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if (link->src->nb_inputs && link->src->inputs[0]->hw_frames_ctx &&
          !link->hw_frames_ctx) {
        AVHWFramesContext *input_ctx =
            (AVHWFramesContext *)link->src->inputs[0]->hw_frames_ctx->data;

        if (input_ctx->format == link->format) {
          link->hw_frames_ctx =
              av_buffer_ref(link->src->inputs[0]->hw_frames_ctx);
          if (!link->hw_frames_ctx)
            return AVERROR(ENOMEM);
        }
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
tsani-tetrefis-02d47ef/rng.c	Constructs a linear congruential PRNG using current time as a seed.	2	"RNG load_rng(EFI_STATUS *status) {

  EFI_TIME time;
  if (EFI_ERROR((*status = RT->GetTime(&time, NULL))))
    return (RNG){};

  *status = EFI_SUCCESS;

  UINT32 s = (time.Hour * 60 + time.Minute * 60) + time.Second;
  return make_rng(s);
}"
kernkonzept-l4re-core-0dd677e/l4sys/include/__timeout.h	Get relative timeout consisting of mantissa and exponent.	2	"l4_timeout_s l4_timeout_rel(unsigned man, unsigned exp) L4_NOTHROW {
  return (l4_timeout_s){(l4_uint16_t)((man & 0x3ff) | ((exp << 10) & 0x7c00))};
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	"Create a new question attached to the given site object, ready for marshalling."	2	"MPMarshalledQuestion *mpw_marshal_question(MPMarshalledSite *site,
                                           const char *keyword) {

  if (!mpw_realloc(&site->questions, NULL,
                   sizeof(MPMarshalledQuestion) * ++site->questions_count))
    return NULL;
  if (!keyword)
    keyword = """";

  MPMarshalledQuestion *question = &site->questions[site->questions_count - 1];
  *question = (MPMarshalledQuestion){
      .keyword = mpw_strdup(keyword),
      .content = NULL,
      .type = MPResultTypeTemplatePhrase,
  };
  return question;
}"
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new ctrl item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_ctrl() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = NULL,
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_0,
                                           .ctrl = CBOR_CTRL_NONE}}};
  return item;
}"
mattbeghin-FFmpegHapGlPlayer-8053312/dependencies/Windows/x86_64/ffmpeg/include/libavutil/softfloat_ieee754.h	Make a softfloat out of the bitstream. Assumes the bits are in the form as defined by the IEEE 754 spec.	2	"static inline SoftFloat_IEEE754 av_bits2sf_ieee754(uint32_t n) {
  return ((SoftFloat_IEEE754){(n & 0x80000000UL), (n & 0x7FFFFFUL),
                              (n & 0x7F800000UL)});
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/StillImage.c	Opens a new PIMA session with the attached device. This should be used before any session-orientated PIMA commands are issued to the device. Only one session can be open at the one time.	2	"uint8_t
SImage_Host_OpenSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(0),
      .Type = CType_CommandBlock,
      .Code = 0x1002,
      .Params = {},
  };

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SImage_Host_ReceiveBlockHeader(
           SIInterfaceInfo, &PIMABlock)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((PIMABlock.Type != CType_ResponseBlock) || (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  SIInterfaceInfo->State.TransactionID = 0;
  SIInterfaceInfo->State.IsSessionOpen = true;

  return PIPE_RWSTREAM_NoError;
}"
ManagementCenterInnsbruck-Multicopter_LARIX-0d9e18e/Software/LARIX Flightcontroller/DAVE4/Flightcontroller/Dave/Model/APPS/USBD_VCOM/v4_0_10/Templates/class_driver/device/cdc_class_device.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState == DEVICE_STATE_Configured) &&
      (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0)) {

    Endpoint_SelectEndpoint(
        CDCInterfaceInfo->Config.NotificationEndpoint.Address);

    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = CDC_NOTIF_SerialState,
        .wValue = 0,
        .wIndex = 0,
        .wLength =
            sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    Endpoint_Write_Stream_LE(
        &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
        sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
    Endpoint_ClearIN();
  }"
asogor-thrift-as3-d2691bd/compiler/cpp/src/generate/t_js_generator.cc	Generates the write() method for a struct	2	"void t_js_generator::generate_js_struct_writer(ofstream &out,
                                               t_struct *tstruct) {
  string name = tstruct->get_name();
  const vector<t_field *> &fields = tstruct->get_members();
  vector<t_field *>::const_iterator f_iter;

  out << js_namespace(tstruct->get_program()) << tstruct->get_name()
      << "".prototype.write = function(output){ "" << endl;

  indent_up();

  indent(out) << ""output.writeStructBegin('"" << name << ""')"" << endl;

  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
    out << indent() << ""if (null != this."" << (*f_iter)->get_name() << "") {""
        << endl;
    indent_up();

    indent(out) << ""output.writeFieldBegin(""
                << ""'"" << (*f_iter)->get_name() << ""', ""
                << type_to_enum((*f_iter)->get_type()) << "", ""
                << (*f_iter)->get_key() << "")"" << endl;

    generate_serialize_field(out, *f_iter, ""this."");

    indent(out) << ""output.writeFieldEnd()"" << endl;

    indent_down();
    indent(out) << ""}"" << endl;
  }

  out << indent() << ""output.writeFieldStop()"" << endl
      << indent() << ""output.writeStructEnd()"" << endl;

  out << indent() << ""return"" << endl;

  indent_down();
  out << indent() << ""}"" << endl << endl;
}"
uber-h3-go-84b7920/h3_linkedGeo.c	Input to this function is assumed to be a single polygon including all loops to normalize. It's assumed that a valid arrangement is possible.	2	"int normalizeMultiPolygon(LinkedGeoPolygon *root) {

  if (root->next) {
    return NORMALIZATION_ERR_MULTIPLE_POLYGONS;
  }

  int loopCount = countLinkedLoops(root);
  if (loopCount <= 1) {
    return NORMALIZATION_SUCCESS;
  }

  int resultCode = NORMALIZATION_SUCCESS;
  LinkedGeoPolygon *polygon = NULL;
  LinkedGeoLoop *next;
  int innerCount = 0;
  int outerCount = 0;

  LinkedGeoLoop **innerLoops = malloc(loopCount * sizeof(LinkedGeoLoop *));
  assert(innerLoops != NULL);

  BBox *bboxes = malloc(loopCount * sizeof(BBox));
  assert(bboxes != NULL);

  LinkedGeoLoop *loop = root->first;
  *root = (LinkedGeoPolygon){0};

  while (loop) {
    if (isClockwiseLinkedGeoLoop(loop)) {
      innerLoops[innerCount] = loop;
      innerCount++;
    } else {
      polygon = polygon == NULL ? root : addNewLinkedPolygon(polygon);
      addLinkedLoop(polygon, loop);
      bboxFromLinkedGeoLoop(loop, &bboxes[outerCount]);
      outerCount++;
    }

    next = loop->next;
    loop->next = NULL;
    loop = next;
  }

  for (int i = 0; i < innerCount; i++) {
    polygon = (LinkedGeoPolygon *)findPolygonForHole(innerLoops[i], root,
                                                     bboxes, outerCount);
    if (polygon) {
      addLinkedLoop(polygon, innerLoops[i]);
    } else {

      destroyLinkedGeoLoop(innerLoops[i]);
      free(innerLoops[i]);
      resultCode = NORMALIZATION_ERR_UNASSIGNED_HOLES;
    }
  }

  free(innerLoops);
  free(bboxes);

  return resultCode;
}"
wyres-lowapp-b466f6d/hardware/src/mac/LoRaMac.c	Deactivates the id in the channel mask.	2	"LoRaMacStatus_t LoRaMacChannelRemove(uint8_t id) {
#if defined(USE_BAND_433) || defined(USE_BAND_780) || defined(USE_BAND_868)
  if ((LoRaMacState & MAC_TX_RUNNING) == MAC_TX_RUNNING) {
    if ((LoRaMacState & MAC_TX_CONFIG) != MAC_TX_CONFIG) {
      return LORAMAC_STATUS_BUSY;
    }
  }

  if ((id < 3) || (id >= LORA_MAX_NB_CHANNELS)) {
    return LORAMAC_STATUS_PARAMETER_INVALID;
  } else {

    Channels[id] = (ChannelParams_t){0, {0}, 0};

    if (DisableChannelInMask(id, LoRaMacParams.ChannelsMask) == false) {
      return LORAMAC_STATUS_PARAMETER_INVALID;
    }
  }
  return LORAMAC_STATUS_OK;
#elif (defined(USE_BAND_915) || defined(USE_BAND_915_HYBRID))
  return LORAMAC_STATUS_PARAMETER_INVALID;
#endif
}"
AprilRobotics-apriltags-7955e00/apriltag_pose.c	Estimate tag pose using orthogonal iteration.	2	"void estimate_tag_pose_orthogonal_iteration(
    apriltag_detection_info_t *info, double *err1, apriltag_pose_t *solution1,
    double *err2, apriltag_pose_t *solution2, int nIters) {
  double scale = info->tagsize / 2.0;
  matd_t *p[4] = {matd_create_data(3, 1, (double[]){-scale, scale, 0}),
                  matd_create_data(3, 1, (double[]){scale, scale, 0}),
                  matd_create_data(3, 1, (double[]){scale, -scale, 0}),
                  matd_create_data(3, 1, (double[]){-scale, -scale, 0})};
  matd_t *v[4];
  for (int i = 0; i < 4; i++) {
    v[i] = matd_create_data(
        3, 1,
        (double[]){(info->det->p[i][0] - info->cx) / info->fx,
                   (info->det->p[i][1] - info->cy) / info->fy, 1});
  }

  estimate_pose_for_tag_homography(info, solution1);
  *err1 = orthogonal_iteration(v, p, &solution1->t, &solution1->R, 4, nIters);
  solution2->R = fix_pose_ambiguities(v, p, solution1->t, solution1->R, 4);
  if (solution2->R) {
    solution2->t = matd_create(3, 1);
    *err2 = orthogonal_iteration(v, p, &solution2->t, &solution2->R, 4, nIters);
  } else {
    *err2 = HUGE_VAL;
  }

  for (int i = 0; i < 4; i++) {
    matd_destroy(p[i]);
    matd_destroy(v[i]);
  }
}"
sblanas-pythia-b138eaa/operators/operators.h	"Initializes operator. Called once. Tree structure (eg. nextOp, buildOp, etc.) must have been initialized before this call."	2	"#include ""../Barrier.h""
#include ""../conjunctionevaluator.h""

#include ""../util/affinitizer.h""
#include ""../visitors/visitor.h""

#ifdef ENABLE_HDF5
#include ""hdf5.h""
#endif

#ifdef ENABLE_FASTBIT
#include ""ibis.h""
#endif

static const int FILTERMAXWIDTH = 128;

static const unsigned short MAX_THREADS = 128;

class Operator {
public:
  Operator()
      : buffsize(0)
#ifdef DEBUG
        ,
        firstcaller(-1)
#endif
  {
  }

  enum ResultCode { Ready = 0, Finished, Error };

  typedef TupleBuffer Page;
  typedef std::pair<Operator::ResultCode, Page *> GetNextResultT;

  virtual ~Operator() {}

  virtual void init(libconfig::Config &root, libconfig::Setting &node);

  virtual void threadInit(unsigned short threadid){};

  virtual ResultCode scanStart(unsigned short threadid, Page *indexdatapage,
                               Schema &indexdataschema) = 0;

  virtual GetNextResultT getNext(unsigned short threadid) = 0;

  virtual ResultCode scanStop(unsigned short threadid) = 0;

  virtual void threadClose(unsigned short threadid){};

  virtual void destroy(){};

  virtual void accept(Visitor *v) = 0;

  virtual Schema &getOutSchema() { return schema; }

protected:
  Schema schema;
  unsigned int buffsize;

  void dbgSetSingleThreaded(unsigned short threadid) {
#ifdef DEBUG
    static_assert(sizeof(long) == sizeof(void *));
    long tid = threadid;
    atomic_compare_and_swap((void **)&firstcaller, (void *)-1ll, (void *)tid);
#endif
  }"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the versor the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qversorl(const quaternion_long_double num) {
  const quaternion_long_double conj_num = (quaternion_long_double){
      num.R, num.i * -1.0L, num.j * -1.0L, num.k * -1.0L};
  return qdivl(num, conj_num);
}"
fanglingsu-vimb-beba6b1/src/ex.c	This is called if the user typed <nl> or <cr> into the inputbox.	2	"static void input_activate(Client *c) {
  int count = -1;
  char *text, *cmd;
  VbCmdResult res;

  text = vb_input_get_text(c);

  cmd = text + 1;
  switch (*text) {
  case '/':
    count = 1;
  case '?':
    vb_enter(c, 'n');

    command_search(c, &((Arg){count, strlen(cmd) ? cmd : NULL}), TRUE);
    break;

  case ';':
  case 'g':

    break;

  case ':':
    vb_enter(c, 'n');
    res = ex_run_string(c, cmd, TRUE);
    if (!(res & CMD_KEEPINPUT)) {

      vb_input_set_text(c, """");
    }
    break;
  }
  g_free(text);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/source-manager/source/arm_uc_source_manager.c	Add pointer to source to the source_registry array.	2	"static arm_uc_error_t
ARM_UCSM_SourceRegistryAdd(const ARM_UPDATE_SOURCE *source) {
  uint32_t index = ARM_UCSM_GetIndexOf(NULL);
  if (index == MAX_SOURCES) {
    return ARM_UCSM_SetError((arm_uc_error_t){SOMA_ERR_SOURCE_REGISTRY_FULL});
  } else {
    source_registry[index] = source;
    return (arm_uc_error_t){ERR_NONE};
  }
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/HID.c	"Receives a HID IN report from the attached device, by the report ID."	0	"uint8_t
HID_Host_ReceiveReportByID(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo,
                           const uint8_t ReportID, void *Buffer) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SetReport,
      .wValue = ((REPORT_ITEM_TYPE_In + 1) << 8) | ReportID,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = USB_GetHIDReportSize(HIDInterfaceInfo->Config.HIDParserData,
                                      ReportID, REPORT_ITEM_TYPE_In),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
samba-team-samba-b2c2c4c/source3/smbd/files.c	Return a jenkins hash of a pathname on a connection.	2	"NTSTATUS file_name_hash(connection_struct *conn, const char *name,
                        uint32_t *p_name_hash) {
  char tmpbuf[PATH_MAX];
  char *fullpath, *to_free;
  ssize_t len;
  TDB_DATA key;

  len = full_path_tos(conn->connectpath, name, tmpbuf, sizeof(tmpbuf),
                      &fullpath, &to_free);
  if (len == -1) {
    return NT_STATUS_NO_MEMORY;
  }
  key = (TDB_DATA){.dptr = (uint8_t *)fullpath, .dsize = len + 1};
  *p_name_hash = tdb_jenkins_hash(&key);

  DEBUG(10, (""file_name_hash: %s hash 0x%x\n"", fullpath,
             (unsigned int)*p_name_hash));

  TALLOC_FREE(to_free);
  return NT_STATUS_OK;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Schedule a network service on a listening socket. Returns the listening socket or -1 (on error).	2	"intptr_t fio_listen FIO_IGNORE_MACRO(struct fio_listen_args args) {

  if ((!args.on_open && (!args.tls || !fio_tls_alpn_count(args.tls))) ||
      (!args.address && !args.port)) {
    errno = EINVAL;
    goto error;
  }

  size_t addr_len = 0;
  size_t port_len = 0;
  if (args.address)
    addr_len = strlen(args.address);
  if (args.port) {
    port_len = strlen(args.port);
    char *tmp = (char *)args.port;
    if (!fio_atol(&tmp)) {
      port_len = 0;
      args.port = NULL;
    }
    if (*tmp) {

      errno = EINVAL;
      goto error;
    }
  }
  const intptr_t uuid = fio_socket(args.address, args.port, 1);
  if (uuid == -1)
    goto error;

  fio_listen_protocol_s *pr = malloc(sizeof(*pr) + addr_len + port_len +
                                     ((addr_len + port_len) ? 2 : 0));
  FIO_ASSERT_ALLOC(pr);

  if (args.tls)
    fio_tls_dup(args.tls);

  *pr = (fio_listen_protocol_s){
      .pr =
          {
              .on_close = fio_listen_on_close,
              .ping = mock_ping_eternal,
              .on_data = (args.tls ? (fio_tls_alpn_count(args.tls)
                                          ? fio_listen_on_data_tls_alpn
                                          : fio_listen_on_data_tls)
                                   : fio_listen_on_data),
          },
      .uuid = uuid,
      .udata = args.udata,
      .on_open = args.on_open,
      .on_start = args.on_start,
      .on_finish = args.on_finish,
      .tls = args.tls,
      .addr_len = addr_len,
      .port_len = port_len,
      .addr = (char *)(pr + 1),
      .port = ((char *)(pr + 1) + addr_len + 1),
  };

  if (addr_len)
    memcpy(pr->addr, args.address, addr_len + 1);
  if (port_len)
    memcpy(pr->port, args.port, port_len + 1);

  if (fio_is_running()) {
    fio_attach(pr->uuid, &pr->pr);
  } else {
    fio_state_callback_add(FIO_CALL_ON_START, fio_listen_on_startup, pr);
    fio_state_callback_add(FIO_CALL_ON_SHUTDOWN, fio_listen_cleanup_task, pr);
  }

  if (args.port)
    FIO_LOG_INFO(""Listening on port %s"", args.port);
  else
    FIO_LOG_INFO(""Listening on Unix Socket at %s"", args.address);

  return uuid;
error:
  if (args.on_finish) {
    args.on_finish(-1, args.udata);
  }
  return -1;
}"
kemadz-monit-9b51725/src/validate.c	Check process resources	2	"static State_Type _checkProcessResources(Service_T s, Resource_T r) {
  ASSERT(s);
  ASSERT(r);
  State_Type rv = State_Succeeded;
  char report[STRLEN] = {}, buf1[STRLEN], buf2[STRLEN];
  switch (r->resource_id) {
  case Resource_CpuPercent: {
    float cpu;
    if (s->type == Service_System) {
      cpu =
#ifdef HAVE_CPU_WAIT
          (systeminfo.cpu.usage.wait > 0. ? systeminfo.cpu.usage.wait : 0.) +
#endif
          (systeminfo.cpu.usage.system > 0. ? systeminfo.cpu.usage.system
                                            : 0.) +
          (systeminfo.cpu.usage.user > 0. ? systeminfo.cpu.usage.user : 0.);
    } else {
      cpu = s->inf.process->cpu_percent;
    }
    if (cpu < 0.) {
      DEBUG(""'%s' cpu usage check skipped (initializing)\n"", s->name);
      return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, cpu, r->limit)) {
      rv = State_Failed;
                                        snprintf(report, STRLEN, ""cpu usage of %.1f%% matches resource limit [cpu usage %s %.1f%%]"", cpu, operatorshortnames[r->operator], r->limit);
    } else {
                                        snprintf(report, STRLEN,
                                                 ""cpu usage check succeeded ""
                                                 ""[current cpu usage = %.1f%%]"",
                                                 cpu);
    }
  } break;

  case Resource_CpuPercentTotal:
    if (s->inf.process->total_cpu_percent < 0.) {
                                        DEBUG(""'%s' total cpu usage check ""
                                              ""skipped (initializing)\n"",
                                              s->name);
                                        return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_cpu_percent, r->limit)) {
                                        rv = State_Failed;
                                snprintf(report, STRLEN, ""total cpu usage of %.1f%% matches resource limit [cpu usage %s %.1f%%]"", s->inf.process->total_cpu_percent, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""total cpu usage check succeeded ""
                                         ""[current cpu usage = %.1f%%]"",
                                         s->inf.process->total_cpu_percent);
    }
    break;

  case Resource_CpuUser:
    if (systeminfo.cpu.usage.user < 0.) {
                                DEBUG(""'%s' cpu user usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, systeminfo.cpu.usage.user, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""cpu user usage of %.1f%% matches resource limit [cpu user usage %s %.1f%%]"", systeminfo.cpu.usage.user, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""cpu user usage check succeeded ""
                                         ""[current cpu user usage = %.1f%%]"",
                                         systeminfo.cpu.usage.user);
    }
    break;

  case Resource_CpuSystem:
    if (systeminfo.cpu.usage.system < 0.) {
                                DEBUG(""'%s' cpu system usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, systeminfo.cpu.usage.system, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""cpu system usage of %.1f%% matches resource limit [cpu system usage %s %.1f%%]"", systeminfo.cpu.usage.system, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""cpu system usage check succeeded ""
                                         ""[current cpu system usage = %.1f%%]"",
                                         systeminfo.cpu.usage.system);
    }
    break;

  case Resource_CpuWait:
    if (systeminfo.cpu.usage.wait < 0.) {
                                DEBUG(""'%s' cpu wait usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, systeminfo.cpu.usage.wait, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""cpu wait usage of %.1f%% matches resource limit [cpu wait usage %s %.1f%%]"", systeminfo.cpu.usage.wait, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""cpu wait usage check succeeded ""
                                         ""[current cpu wait usage = %.1f%%]"",
                                         systeminfo.cpu.usage.wait);
    }
    break;

  case Resource_MemoryPercent:
    if (s->type == Service_System) {
                                if (Util_evalDoubleQExpression(
                                        r->operator,
                                        systeminfo.memory.usage.percent,
                                        r->limit)) {
                                  rv = State_Failed;
                                        snprintf(report, STRLEN, ""mem usage of %.1f%% matches resource limit [mem usage %s %.1f%%]"", systeminfo.memory.usage.percent, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""mem usage check succeeded ""
                                            ""[current mem usage = %.1f%%]"",
                                            systeminfo.memory.usage.percent);
                                }
    } else {
                                if (s->inf.process->mem_percent < 0.) {
                                        DEBUG(""'%s' memory usage check skipped ""
                                              ""(initializing)\n"",
                                              s->name);
                                        return State_Init;
                                } else if (Util_evalDoubleQExpression(
                                               r->operator,
                                               s->inf.process->mem_percent,
                                               r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""mem usage of %.1f%% matches resource limit [mem usage %s %.1f%%]"", s->inf.process->mem_percent, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(report, STRLEN,
                                                 ""mem usage check succeeded ""
                                                 ""[current mem usage = %.1f%%]"",
                                                 s->inf.process->mem_percent);
                                }
    }
    break;

  case Resource_MemoryKbyte:
    if (s->type == Service_System) {
                                if (Util_evalDoubleQExpression(
                                        r->operator,
                                        systeminfo.memory.usage.bytes,
                                        r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""mem amount of %s matches resource limit [mem amount %s %s]"", Str_bytesToSize(systeminfo.memory.usage.bytes, buf1), operatorshortnames[r->operator], Str_bytesToSize(r->limit, buf2));
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""mem amount check succeeded ""
                                            ""[current mem amount = %s]"",
                                            Str_bytesToSize(
                                                systeminfo.memory.usage.bytes,
                                                buf1));
                                }
    } else {
                                if (s->inf.process->mem == 0) {
                                        DEBUG(""'%s' process memory usage check ""
                                              ""skipped (initializing)\n"",
                                              s->name);
                                        return State_Init;
                                } else if (Util_evalDoubleQExpression(
                                               r->operator, s->inf.process->mem,
                                               r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""mem amount of %s matches resource limit [mem amount %s %s]"", Str_bytesToSize(s->inf.process->mem, buf1), operatorshortnames[r->operator], Str_bytesToSize(r->limit, buf2));
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""mem amount check succeeded ""
                                            ""[current mem amount = %s]"",
                                            Str_bytesToSize(s->inf.process->mem,
                                                            buf1));
                                }
    }
    break;

  case Resource_SwapPercent:
    if (s->type == Service_System) {
                                if (Util_evalDoubleQExpression(
                                        r->operator,
                                        systeminfo.swap.usage.percent,
                                        r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""swap usage of %.1f%% matches resource limit [swap usage %s %.1f%%]"", systeminfo.swap.usage.percent, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""swap usage check succeeded ""
                                            ""[current swap usage = %.1f%%]"",
                                            systeminfo.swap.usage.percent);
                                }
    }
    break;

  case Resource_SwapKbyte:
    if (s->type == Service_System) {
                                if (Util_evalDoubleQExpression(
                                        r->operator,
                                        systeminfo.swap.usage.bytes,
                                        r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""swap amount of %s matches resource limit [swap amount %s %s]"", Str_bytesToSize(systeminfo.swap.usage.bytes, buf1), operatorshortnames[r->operator], Str_bytesToSize(r->limit, buf2));
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""swap amount check succeeded ""
                                            ""[current swap amount = %s]"",
                                            Str_bytesToSize(
                                                systeminfo.swap.usage.bytes,
                                                buf1));
                                }
    }
    break;

  case Resource_LoadAverage1m:
    if (Util_evalDoubleQExpression(r->operator, systeminfo.loadavg[0],
                                   r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""loadavg(1min) of %.1f matches resource limit [loadavg(1min) %s %.1f]"", systeminfo.loadavg[0], operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""loadavg(1min) check succeeded ""
                                         ""[current loadavg(1min) = %.1f]"",
                                         systeminfo.loadavg[0]);
    }
    break;

  case Resource_LoadAverage5m:
    if (Util_evalDoubleQExpression(r->operator, systeminfo.loadavg[1],
                                   r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""loadavg(5min) of %.1f matches resource limit [loadavg(5min) %s %.1f]"", systeminfo.loadavg[1], operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""loadavg(5min) check succeeded ""
                                         ""[current loadavg(5min) = %.1f]"",
                                         systeminfo.loadavg[1]);
    }
    break;

  case Resource_LoadAverage15m:
    if (Util_evalDoubleQExpression(r->operator, systeminfo.loadavg[2],
                                   r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""loadavg(15min) of %.1f matches resource limit [loadavg(15min) %s %.1f]"", systeminfo.loadavg[2], operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""loadavg(15min) check succeeded ""
                                         ""[current loadavg(15min) = %.1f]"",
                                         systeminfo.loadavg[2]);
    }
    break;

  case Resource_Threads:
    if (s->inf.process->threads < 0) {
                                DEBUG(""'%s' process threads count check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, s->inf.process->threads,
                                          r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""threads count %i matches resource limit [threads %s %.0f]"", s->inf.process->threads, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""threads check succeeded [current ""
                                         ""threads = %i]"",
                                         s->inf.process->threads);
    }
    break;

  case Resource_Children:
    if (s->inf.process->children < 0) {
                                DEBUG(""'%s' process children count check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(r->operator, s->inf.process->children,
                                          r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""children count %i matches resource limit [children %s %.0f]"", s->inf.process->children, operatorshortnames[r->operator], r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""children check succeeded [current ""
                                         ""children = %i]"",
                                         s->inf.process->children);
    }
    break;

  case Resource_MemoryKbyteTotal:
    if (s->inf.process->total_mem == 0) {
                                DEBUG(""'%s' process total memory usage check ""
                                      ""skipped (initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_mem, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""total mem amount of %s matches resource limit [total mem amount %s %s]"", Str_bytesToSize(s->inf.process->total_mem, buf1), operatorshortnames[r->operator], Str_bytesToSize(r->limit, buf2));
    } else {
                                snprintf(report, STRLEN,
                                         ""total mem amount check succeeded ""
                                         ""[current total mem amount = %s]"",
                                         Str_bytesToSize(
                                             s->inf.process->total_mem, buf1));
    }
    break;

  case Resource_MemoryPercentTotal:
    if (s->inf.process->total_mem_percent < 0.) {
                                DEBUG(""'%s' total memory usage check skipped ""
                                      ""(initializing)\n"",
                                      s->name);
                                return State_Init;
    } else if (Util_evalDoubleQExpression(
                   r->operator, s->inf.process->total_mem_percent, r->limit)) {
                                rv = State_Failed;
                                snprintf(report, STRLEN, ""total mem amount of %.1f%% matches resource limit [total mem amount %s %.1f%%]"", (float)s->inf.process->total_mem_percent, operatorshortnames[r->operator], (float)r->limit);
    } else {
                                snprintf(report, STRLEN,
                                         ""total mem amount check succeeded ""
                                         ""[current total mem amount = %.1f%%]"",
                                         s->inf.process->total_mem_percent);
    }
    break;

  case Resource_ReadBytes:
    if (Statistics_initialized(&(s->inf.process->read.bytes))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->read.bytes));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""read rate %s/s matches resource limit [read %s %s/s]"", Str_bytesToSize(value, (char[10]){}), operatorshortnames[r->operator], Str_bytesToSize(r->limit, (char[10]){}));
                                } else {
                                        snprintf(report, STRLEN,
                                                 ""read rate test succeeded ""
                                                 ""[current read = %s/s]"",
                                                 Str_bytesToSize(value,
                                                                 (char[10]){}));
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for bytes read rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_ReadOperations:
    if (Statistics_initialized(&(s->inf.process->read.operations))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->read.operations));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""read rate %.1f operations/s matches resource limit [read %s %.0f operations/s]"", value, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(
                                            report, STRLEN,
                                            ""read rate test succeeded [current ""
                                            ""read = %.1f operations/s]"",
                                            value);
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for read rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_WriteBytes:
    if (Statistics_initialized(&(s->inf.process->write.bytes))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->write.bytes));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""write rate %s/s matches resource limit [write %s %s/s]"", Str_bytesToSize(value, (char[10]){}), operatorshortnames[r->operator], Str_bytesToSize(r->limit, (char[10]){}));
                                } else {
                                        snprintf(report, STRLEN,
                                                 ""write rate test succeeded ""
                                                 ""[current write = %s/s]"",
                                                 Str_bytesToSize(value,
                                                                 (char[10]){}));
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for bytes write rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  case Resource_WriteOperations:
    if (Statistics_initialized(&(s->inf.process->write.operations))) {
                                double value = Statistics_deltaNormalize(
                                    &(s->inf.process->write.operations));
                                if (Util_evalDoubleQExpression(
                                        r->operator, value, r->limit)) {
                                        rv = State_Failed;
                                        snprintf(report, STRLEN, ""write rate %.1f operations/s matches resource limit [write %s %.0f operations/s]"", value, operatorshortnames[r->operator], r->limit);
                                } else {
                                        snprintf(report, STRLEN,
                                                 ""write rate test succeeded ""
                                                 ""[current write = %.1f ""
                                                 ""operations/s]"",
                                                 value);
                                }
    } else {
                                DEBUG(""'%s' warning -- no data are available ""
                                      ""for write rate test\n"",
                                      s->name);
                                return State_Init;
    }
    break;

  default:
    LogError(""'%s' error -- unknown resource ID: [%d]\n"", s->name,
             r->resource_id);
    return State_Failed;
  }
  Event_post(s, Event_Resource, rv, r->action, ""%s"", report);
  return rv;
}"
ezotrank-monit-src-cd9009e/src/status.c	Show all services in the service list.	2	"int status(char *level) {

#define LINE 1024

  int status = FALSE;
  Socket_T S = NULL;
  char buf[LINE];
  char *auth = NULL;

  if (!exist_daemon()) {
    LogError(""%s: Status not available -- the monit daemon is not running\n"",
             prog);
    return status;
  }
  S = socket_create_t(
      Run.bind_addr ? Run.bind_addr : ""localhost"", Run.httpdport, SOCKET_TCP,
      (Ssl_T){.use_ssl = Run.httpdssl, .clientpemfile = Run.httpsslclientpem},
      NET_TIMEOUT);
  if (!S) {
    LogError(""%s: error connecting to the monit daemon\n"", prog);
    return status;
  }

  auth = Util_getBasicAuthHeaderMonit();
  socket_print(S, ""GET /_status?format=text&level=%s HTTP/1.0\r\n%s\r\n"", level,
               auth ? auth : """");
  FREE(auth);

  while (socket_readln(S, buf, LINE)) {
    if (*buf == '\n' || *buf == '\r')
      break;
    if (Str_startsWith(buf, ""HTTP/1.0 200""))
      status = TRUE;
  }

  if (!status) {
    LogError(""%s: cannot read status from the monit daemon\n"", prog);
  } else {
    while (socket_readln(S, buf, LINE)) {
      printf(""%s"", buf);
    }
  }
  socket_free(&S);

  return status;
}"
squidfunk-protobluff-f6ee42c/src/message/journal.c	"Add an entry to a journal. If allocation fails, the journal's internal state is fully recoverable."	2	"push(pb_journal_t *journal, size_t origin, size_t offset, ptrdiff_t delta) {
  assert(journal && origin <= offset && delta);
  assert(pb_journal_valid(journal));
  pb_allocator_t *allocator = pb_buffer_allocator(&(journal->buffer));
  if (unlikely_(allocator == &allocator_zero_copy))
    return PB_ERROR_ALLOC;

  pb_journal_entry_t *data = pb_allocator_resize(allocator, journal->entry.data,
                                                 sizeof(pb_journal_entry_t) *
                                                     (journal->entry.size + 1));
  if (data) {
    journal->entry.data = data;
    journal->entry.data[journal->entry.size++] = (pb_journal_entry_t){
        .origin = origin, .offset = offset, .delta = delta};
    return PB_ERROR_NONE;
  }
  return PB_ERROR_ALLOC;
}"
vvaltchev-tfblib-993a946/src/text.c	Iterate over the fonts embedded in the library.	2	"void tfb_iterate_over_fonts(tfb_font_iter_func f, void *user_arg) {
  tfb_font_info fi;
  psf1_header *h1;
  psf2_header *h2;
  const font_file **it;

  for (it = tfb_font_file_list; *it; it++) {

    h1 = (void *)(*it)->data;
    h2 = (void *)(*it)->data;

    if (h2->magic == PSF2_MAGIC) {

      fi = (tfb_font_info){.name = (*it)->filename,
                           .width = h2->width,
                           .height = h2->height,
                           .psf_version = 2,
                           .font_id = (tfb_font_t)*it};

    } else {

      fi = (tfb_font_info){.name = (*it)->filename,
                           .width = 8,
                           .height = h1->bytes_per_glyph,
                           .psf_version = 1,
                           .font_id = (tfb_font_t)*it};
    }

    if (!f(&fi, user_arg))
      break;
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/CDC.c	"Sends a Serial Control Line State Change notification to the device. This should be called when the virtual serial control lines (DTR, RTS, etc.) have changed states. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.HostToDevice value is updated to push the new states to the USB device."	2	"uint8_t CDC_Host_SendControlLineStateChange(
    USB_ClassInfo_CDC_Host_t *const CDCInterfaceInfo) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_REQ_SetControlLineState,
      .wValue = CDCInterfaceInfo->State.ControlLineStates.HostToDevice,
      .wIndex = CDCInterfaceInfo->State.ControlInterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
PJK-libcbor-87f977e/src/cbor/bytestrings.c	Creates a new definite byte string	2	"cbor_item_t *cbor_new_definite_bytestring() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_BYTESTRING,
      .metadata = {.bytestring_metadata = {_CBOR_METADATA_DEFINITE, 0}}};
  return item;
}"
zooko-libzstr-80ce66c/zstr.c	Copy z2 and return copy in newly allocated zstr..	2	"zdup(const czstr z1) {
  zstr res;
  if ((z1.len == 0) || (z1.buf == NULL)) {
    return (zstr){0, NULL};
  }
  res.buf = (zbyte *)malloc(z1.len + 1);
#ifdef Z_EXHAUST_EXIT
  CHECKMALLOCEXIT(res.buf);
#else
  if (p == NULL) {
    return (zstr){0, NULL};
  }
#endif
  memcpy(res.buf, z1.buf, z1.len + 1);
  res.len = z1.len;
  return res;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/StillImageClassHost.c	"Sends a given PIMA command to the attached device, filling out the PIMA command header's Transaction ID automatically."	0	"uint8_t SI_Host_SendCommand(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo,
                            const uint16_t Operation, const uint8_t TotalParams,
                            uint32_t *const Params) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = cpu_to_le32(PIMA_COMMAND_SIZE(TotalParams)),
      .Type = CPU_TO_LE16(PIMA_CONTAINER_CommandBlock),
      .Code = cpu_to_le16(Operation),
  };

  memcpy(&PIMABlock.Params, Params, sizeof(uint32_t) * TotalParams);

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
AsydSolutions-monit-9e43388/src/status.c	Show all services in the service list.	2	"boolean_t status(char *level) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    char *auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, ""GET /_status?format=text&level=%s HTTP/1.0\r\n%s\r\n"",
                 level, auth ? auth : """");
    FREE(auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Device/LowLevel/MIDI/MIDI.c	"Task to handle the generation of MIDI note change events in response to presses of the board joystick, and send them to the host."	0	"void MIDI_Task(void) {
  static uint8_t PrevJoystickStatus;

  if (USB_DeviceState != DEVICE_STATE_Configured)
    return;

  Endpoint_SelectEndpoint(MIDI_STREAM_IN_EPADDR);

  if (Endpoint_IsINReady()) {
    uint8_t MIDICommand = 0;
    uint8_t MIDIPitch;

    uint8_t JoystickStatus = Joystick_GetStatus();
    uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

    uint8_t Channel =
        ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                 : MIDI_CHANNEL(1));

    if (JoystickChanges & JOY_LEFT) {
      MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3C;
    }

    if (JoystickChanges & JOY_UP) {
      MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3D;
    }

    if (JoystickChanges & JOY_RIGHT) {
      MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3E;
    }

    if (JoystickChanges & JOY_DOWN) {
      MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3F;
    }

    if (JoystickChanges & JOY_PRESS) {
      MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3B;
    }

    if (MIDICommand) {
      MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
          .Event = MIDI_EVENT(0, MIDICommand),

          .Data1 = MIDICommand | Channel,
          .Data2 = MIDIPitch,
          .Data3 = MIDI_STANDARD_VELOCITY,
      };

      Endpoint_Write_Stream_LE(&MIDIEvent, sizeof(MIDIEvent), NULL);

      Endpoint_ClearIN();
    }

    PrevJoystickStatus = JoystickStatus;
  }

  Endpoint_SelectEndpoint(MIDI_STREAM_OUT_EPADDR);

  if (Endpoint_IsOUTReceived()) {
    MIDI_EventPacket_t MIDIEvent;

    Endpoint_Read_Stream_LE(&MIDIEvent, sizeof(MIDIEvent), NULL);

    if ((MIDIEvent.Event == MIDI_EVENT(0, MIDI_COMMAND_NOTE_ON)) &&
        (MIDIEvent.Data3 > 0)) {

      LEDs_SetAllLEDs(MIDIEvent.Data2 > 64 ? LEDS_LED1 : LEDS_LED2);
    } else {

      LEDs_SetAllLEDs(LEDS_NO_LEDS);
    }

    if (!(Endpoint_BytesInEndpoint())) {

      Endpoint_ClearOUT();
    }
  }
}"
NVlabs-nvbio-9bb7e63/nvbio/io/sequence/sequence.h	factory method to open a read file	2	"enum QualityEncoding {
  Phred = 0,
  Phred33 = 1,
  Phred64 = 2,
  Solexa = 3,
};

enum SequenceEncoding {
  FORWARD = 0x0001,
  REVERSE = 0x0002,
  FORWARD_COMPLEMENT = 0x0004,
  REVERSE_COMPLEMENT = 0x0008,
};

enum SequenceFlags {
  SEQUENCE_DATA = 0x0001,
  SEQUENCE_QUALS = 0x0002,
  SEQUENCE_NAMES = 0x0004,
};

enum PairedEndPolicy {
  PE_POLICY_FF = 0,
  PE_POLICY_FR = 1,
  PE_POLICY_RF = 2,
  PE_POLICY_RR = 3,
};

struct SequenceDataInfo {

  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE SequenceDataInfo()
      : m_alphabet(PROTEIN), m_n_seqs(0), m_name_stream_len(0),
        m_sequence_stream_len(0), m_sequence_stream_words(0),
        m_has_qualities(0), m_min_sequence_len(uint32(-1)),
        m_max_sequence_len(0), m_avg_sequence_len(0){};

  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE Alphabet alphabet() const {
    return m_alphabet;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 size() const { return m_n_seqs; }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 bps() const {
    return m_sequence_stream_len;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 words() const {
    return m_sequence_stream_words;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 qs() const {
    return m_has_qualities ? m_sequence_stream_len : 0u;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 name_stream_len() const {
    return m_name_stream_len;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE bool has_qualities() const {
    return m_has_qualities ? true : false;
  }
  NVBIO_HOST_DEVICE NVBIO_FORCEINLINE uint32 max_sequence_len() const {
    return m_max_sequence_len;
  }"
epik-wAMP-b1b1c58/plugin/include/libavformat/utils.c	"Add a new stream to a media file. Can only be called in the read_header() function. If the flag AVFMTCTX_NOHEADER is in the format context, then new streams can be added in read_packet too."	2	"AVStream *av_new_stream(AVFormatContext *s, int id) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }

  st->codec = avcodec_alloc_context3(NULL);
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->id = id;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  av_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  s->streams[s->nb_streams++] = st;
  return st;
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/command.c	Register a command	2	"void command_register(command_t command) {
  int i;

  cmds[registered] = command;

  if (!active) {
    for (i = 0; i < countof(cmds[registered].options); i++) {
      if (cmds[registered].options[i].name) {
        continue;
      }
      cmds[registered].options[i++] =
          (command_option_t){""debug"", 'v', 1, ""set debug level, default: 1""};
      cmds[registered].options[i++] = (command_option_t){
          ""options"", '+', 1, ""read command line options from file""};
      break;
    }
  }
  registered++;
}"
darktable-org-darktable-32fab21/src/iop/clipping.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_clipping_params_t tmp = (dt_iop_clipping_params_t){
      0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f,  0.2f, 0.2f, 0.8f, 0.2f,
      0.8f, 0.8f, 0.2f, 0.8f, 0,    0,    FALSE, TRUE, -1,   -1};
  memcpy(self->params, &tmp, sizeof(dt_iop_clipping_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_clipping_params_t));
  self->default_enabled = 0;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a Mass Storage class specific request to reset the attached device's Mass Storage interface, readying the device for the next CBW."	1	"uint8_t MassStore_MassStorageReset(void) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_MassStorageReset,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
dm-vdo-kvdo-8df6805/vdo/base/slabSummary.c	Fetch the cumulative statistics for all slab summary zones in a summary.	2	"SlabSummaryStatistics getSlabSummaryStatistics(const SlabSummary *summary) {
  const AtomicSlabSummaryStatistics *atoms = &summary->statistics;
  return (SlabSummaryStatistics){
      .blocksWritten = atomicLoad64(&atoms->blocksWritten),
  };
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue"	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration = 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    } else if (st->codec->time_base.num != 0 && st->codec->time_base.den != 0) {
      out_pkt.duration =
          av_rescale_q_rnd(st->parser->duration, st->codec->time_base,
                           st->time_base, AV_ROUND_DOWN);
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt);

    if (out_pkt.data == pkt->data && out_pkt.size == pkt->size) {
      out_pkt.buf = pkt->buf;
      pkt->buf = NULL;
#if FF_API_DESTRUCT_PACKET
      out_pkt.destruct = pkt->destruct;
      pkt->destruct = NULL;
#endif
    }
    if ((ret = av_dup_packet(&out_pkt)) < 0)
      goto fail;

    if (!add_to_pktbuf(&s->parse_queue, &out_pkt, &s->parse_queue_end)) {
      av_free_packet(&out_pkt);
      ret = AVERROR(ENOMEM);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_free_packet(pkt);
  return ret;
}"
darktable-org-darktable-32fab21/src/iop/exposure.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_exposure_params_t tmp =
      (dt_iop_exposure_params_t){.mode = EXPOSURE_MODE_MANUAL,
                                 .black = 0.0f,
                                 .exposure = 0.0f,
                                 .deflicker_percentile = 50.0f,
                                 .deflicker_target_level = -4.0f};

  memcpy(module->params, &tmp, sizeof(dt_iop_exposure_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_exposure_params_t));
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/buffersink.c	"Same as av_buffersink_get_frame(), but with the ability to specify the number of samples read. This function is less efficient than av_buffersink_get_frame(), because it copies the data around."	2	"int attribute_align_arg av_buffersink_get_samples(AVFilterContext *ctx,
                                                  AVFrame *frame,
                                                  int nb_samples) {
  BufferSinkContext *s = ctx->priv;
  AVFilterLink *link = ctx->inputs[0];
  AVFrame *cur_frame;
  int ret = 0;

  if (!s->audio_fifo) {
    int nb_channels = link->channels;
    if (!(s->audio_fifo =
              av_audio_fifo_alloc(link->format, nb_channels, nb_samples)))
      return AVERROR(ENOMEM);
  }

  while (ret >= 0) {
    if (av_audio_fifo_size(s->audio_fifo) >= nb_samples)
      return read_from_fifo(ctx, frame, nb_samples);

    if (!(cur_frame = av_frame_alloc()))
      return AVERROR(ENOMEM);
    ret = av_buffersink_get_frame_flags(ctx, cur_frame, 0);
    if (ret == AVERROR_EOF && av_audio_fifo_size(s->audio_fifo)) {
      av_frame_free(&cur_frame);
      return read_from_fifo(ctx, frame, av_audio_fifo_size(s->audio_fifo));
    } else if (ret < 0) {
      av_frame_free(&cur_frame);
      return ret;
    }

    if (cur_frame->pts != AV_NOPTS_VALUE) {
      s->next_pts =
          cur_frame->pts - av_rescale_q(av_audio_fifo_size(s->audio_fifo),
                                        (AVRational){1, link->sample_rate},
                                        link->time_base);
    }

    ret = av_audio_fifo_write(s->audio_fifo, (void **)cur_frame->extended_data,
                              cur_frame->nb_samples);
    av_frame_free(&cur_frame);
  }

  return ret;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/source/update_client_hub.c	Add sources to the update client.	2	"arm_uc_error_t ARM_UC_HUB_SetSources(const ARM_UPDATE_SOURCE *sources[],
                                     uint8_t size) {
  arm_uc_sources = sources;
  arm_uc_sources_size = size;

  return (arm_uc_error_t){ERR_NONE};
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/manifest-manager/source/arm_uc_mmCryptoUtils.c	"First, the state machine attempts to fetch the certificate. When the certificate has been fetched, the state machine validates the signature, then alerts the calling application with the result."	2	"static arm_uc_error_t
ARM_UC_mmValidateSignatureFSM(arm_uc_mm_validate_signature_context_t *ctx,
                              uint32_t event) {
  arm_uc_error_t err = {ERR_NONE};
  enum arm_uc_mm_pk_sig_state oldState;
  UC_MMGR_TRACE(""%s (%"" PRIu32 "")\n"", __PRETTY_FUNCTION__, event);
  do {
    oldState = ctx->pk_state;
    UC_MMGR_TRACE(""%s state:%u\n"", __PRETTY_FUNCTION__, oldState);
    switch (ctx->pk_state) {
    case UCMM_PKSIG_STATE_FIND_CA:

      err =
          ARM_UC_certificateFetch(&ctx->cert, &ctx->fingerprint, &ctx->certList,
                                  ARM_UC_mmCertificateCallback);
      if (err.error == ERR_NONE || err.code == MFST_ERR_PENDING) {
        ctx->pk_state = UCMM_PKSIG_STATE_FINDING_CA;
        err.code = MFST_ERR_PENDING;
      }
      break;
    case UCMM_PKSIG_STATE_FINDING_CA:

      switch (event) {

      case ARM_UC_MM_CERTIFICATE_FETCH_SUCCESS:
        err.code = ERR_NONE;
        ctx->pk_state = UCMM_PKSIG_STATE_CHECK;
        break;

      case ARM_UC_MM_CERTIFICATE_FETCH_ERROR:
        err = ctx->storedError;
        break;

      case ARM_UC_MM_CERTIFICATE_FETCH_UNINIT:
      case ARM_UC_MM_CERTIFICATE_FETCH_MISMATCH:
      default:
        err.code = MFST_ERR_BAD_EVENT;
        break;
      }
      break;

    case UCMM_PKSIG_STATE_CHECK:
      err = ARM_UC_mmValidateSignatureCert(ctx->manifest, &ctx->cert,
                                           ctx->sigIndex);
      if (err.code == ERR_NONE) {
        ctx->pk_state = UCMM_PKSIG_STATE_IDLE;
      }
      break;
    case UCMM_PKSIG_STATE_IDLE:
      err.code = ERR_NONE;

      break;
    default:
      err = (arm_uc_error_t){MFST_ERR_INVALID_STATE};
      break;
    }

  } while (err.code == ERR_NONE && ctx->pk_state != oldState);
  UC_MMGR_TRACE(""%s() return code: %c%c:%hu (%s)\n"", __PRETTY_FUNCTION__,
                CC_ASCII(err.modulecc[0]), CC_ASCII(err.modulecc[1]), err.error,
                ARM_UC_err2Str(err));
  return err;
}"
SanderMertens-flecs-f50e6b1/src/entity.c	Commit an entity with a specified type to memory	2	"uint32_t commit_w_type(EcsWorld *world, EcsStage *stage, EcsEntityInfo *info,
                       EcsType type_id, EcsType to_add, EcsType to_remove) {
  EcsTable *old_table, *new_table = NULL;
  EcsTableColumn *new_columns, *old_columns;
  EcsMap *entity_index;
  EcsType old_type_id = 0;
  uint32_t new_index = -1, old_index = -1;
  bool in_progress = world->in_progress;
  EcsEntity entity = info->entity;
  EcsArray *old_type = NULL;

  entity_index = stage->entity_index;

  if (in_progress) {

    EcsType remove_type = ecs_map_get64(stage->remove_merge, entity);

    remove_type = ecs_type_merge(world, stage, remove_type, to_remove, to_add);
    ecs_map_set64(stage->remove_merge, entity, remove_type);
  }

  if ((old_table = info->table)) {
    old_type_id = info->type_id;
    if (old_type_id == type_id) {
      return info->index;
    }

    old_index = info->index;
    if (in_progress) {
      old_columns = ecs_map_get(stage->data_stage, old_type_id);
    } else {
      old_columns = old_table->columns;
    }

    old_type = old_table->type;
  }

  if (type_id) {
    EcsArray *old_table_db = stage->tables;
    new_table = ecs_world_get_table(world, stage, type_id);

    if (old_table && old_table_db != stage->tables) {
      old_table = ecs_world_get_table(world, stage, info->type_id);
    }

    if (in_progress) {
      EcsTableColumn *columns = ecs_map_get(stage->data_stage, type_id);
      new_columns = columns;

      if (!new_columns) {
        EcsArray *type = ecs_type_get(world, stage, type_id);
        ecs_assert(type != NULL, ECS_INTERNAL_ERROR, NULL);
        new_columns = ecs_table_get_columns(world, stage, type);
      }

      new_index = ecs_table_insert(world, new_table, new_columns, entity);
      assert(new_index != -1);

      if (new_columns != columns) {
        ecs_map_set(stage->data_stage, type_id, new_columns);
      }
    } else {
      new_index =
          ecs_table_insert(world, new_table, new_table->columns, entity);

      new_columns = new_table->columns;
    }
  }

  if (old_type_id && type_id) {
    copy_row(new_table->type, new_columns, new_index, old_type, old_columns,
             old_index);
  }

  if (type_id) {
    EcsRow new_row = (EcsRow){.type_id = type_id, .index = new_index};
    ecs_map_set64(entity_index, entity, ecs_from_row(new_row));
  } else {
    if (in_progress) {

      ecs_map_set64(entity_index, entity, 0);
    } else {
      ecs_map_remove(entity_index, entity);
    }
  }

  if (!in_progress) {
    bool merged = false;

    if (to_remove && old_index != -1) {
      merged = notify_post_merge(world, old_table, old_columns, old_index, 1,
                                 to_remove);
    }

    if (!merged && old_type_id) {
      ecs_table_delete(world, old_table, old_index);
    }
  }

  if (type_id) {
    if (to_add) {
      notify_pre_merge(world, new_table, new_columns, new_index, 1, to_add,
                       world->type_sys_add_index);

      copy_from_prefab(world, stage, new_table, entity, new_index, type_id,
                       to_add);
    }
  }

  world->valid_schedule = false;

  return new_index;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/solution/solution_T.c	Compute the coefficients associated with the values of the face normal flux.	2	"(const struct Solver_Face_T *s_face, const struct const_Multiarray_T *f_val,
 struct Multiarray_T *f_coef) {
  const struct Face *face = (struct Face *)s_face;
  const struct Solution_Element *s_e =
      &((struct Solver_Element *)face->neigh_info[0].volume->element)->s_e;

  const int ind_e = get_face_element_index(face), p = s_face->p_ref;
  const struct Operator *vc0_ff_ff = get_Multiarray_Operator(
      s_e->vc0_ff_ff, (ptrdiff_t[]){ind_e, ind_e, 0, 0, p, p});

  resize_Multiarray_T(f_coef, f_val->order, f_val->extents);
  mm_NN1C_Operator_Multiarray_T(vc0_ff_ff, f_val, f_coef, 'd', f_coef->order,
                                NULL, NULL);
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/alpn-test.c	"In this test case, establish a security context, with server ready for ALPN, but the client not providing one. The server inquires the context and sees no ALPN."	3	"init_no_client_alpn(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;
  unsigned char server_alpn[] = {
      3,
      'g',
      's',
      'i',
  };
  const char *why = """";

  major_status =
      gss_set_sec_context_option(&minor_status, &accept_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = server_alpn,
                                     .length = sizeof(server_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, GSS_C_NO_NAME,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, accept_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);

    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }

  return result;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered."	2	"uint8_t MS_Host_PreventAllowMediumRemoval(
    USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex,
    const bool PreventRemoval) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal tensor-product basis functions.	2	"static void
test_unit_basis_tensor_product_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_TP_Ortho *b_data_a = constructor_Basis_Data_TP_Ortho('a'),
                             *b_data_c = constructor_Basis_Data_TP_Ortho('c');

  tol = (double[]){
      EPS,
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi13, b_data_c->phi13, tol[0]),
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[1]),
      diff_const_Matrix_d(b_data_a->phi31, b_data_c->phi31, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi13, b_data_c->phi13, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi31, b_data_c->phi31, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      EPS,
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi13, b_data_c->grad_phi13,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[1]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi13,
                                           b_data_c->grad_phi13, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[1]);
    if (differences[2])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[2]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      EPS,
      EPS,
      2 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_14, b_data_c->m_14, tol[0]),
      diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[1]),
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_14, b_data_c->m_14, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->m_24, b_data_c->m_24, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[2]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      EPS,
      2 * EPS,
      20 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_13, b_data_c->grad_coef_13,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_23, b_data_c->grad_coef_23,
                              tol[1]),
      diff_const_Multiarray_d(b_data_a->grad_coef_33, b_data_c->grad_coef_33,
                              tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_13,
                                    b_data_c->grad_coef_13, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_23,
                                    b_data_c->grad_coef_23, tol[1]);
    if (differences[2])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_33,
                                    b_data_c->grad_coef_33, tol[2]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_TP_Ortho(b_data_a);
  destructor_Basis_Data_TP_Ortho(b_data_c);

  assert_condition(pass);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	Update Client call for informing the Control Center about the current download progress. The Control Center will send this to the appication handler and the monitor if either/both are attached.	2	"arm_uc_error_t ARM_UC_ControlCenter_ReportProgress(uint32_t progress,
                                                   uint32_t total) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportProgress: %"" PRIu32 "" / %"" PRIu32,
                progress, total);

  if (arm_uc_progress_callback) {
    arm_uc_progress_callback(progress, total);
  }

  return (arm_uc_error_t){ERR_NONE};
}"
dm-vdo-kvdo-8df6805/vdo/base/dataVIO.c	"Clear a DataVIO's mapped block location, setting it to be unmapped. This indicates the block map entry for the logical block is either unmapped or corrupted."	2	"void clearMappedLocation(DataVIO *dataVIO) {
  dataVIO->mapped = (ZonedPBN){.state = MAPPING_STATE_UNMAPPED};
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size."	1	"uint8_t
MS_Host_ReadDeviceCapacity(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                           const uint8_t LUNIndex,
                           SCSI_Capacity_t *const DeviceCapacity) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Capacity_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       DeviceCapacity)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SwapEndian_n(&DeviceCapacity->Blocks, sizeof(DeviceCapacity->Blocks));
  SwapEndian_n(&DeviceCapacity->BlockSize, sizeof(DeviceCapacity->BlockSize));

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
sahib-rmlint-fd355d0/lib/formats.c	"Some handlers might require this in order to print a progress indicator. Calling the same state several times is allowed in order to update numbers Callers should make sure that this function is not called on every increment, as it needs to iterate over all handlers:"	2	"void rm_fmt_set_state(RmFmtTable *self, RmFmtProgressState state) {
  rm_fmt_lock_state(self);
  {RM_FMT_FOR_EACH_HANDLER_BEGIN(self){RM_FMT_CALLBACK(handler->prog, state);
}
RM_FMT_FOR_EACH_HANDLER_END
}
rm_fmt_unlock_state(self);
}"
psyc-libpsyc-d16deca/src/packet.c	Initialize a packet.	2	"psyc_packet_init(PsycPacket *p, PsycModifier *routing, size_t routinglen,
                 PsycModifier *entity, size_t entitylen, char *method,
                 size_t methodlen, char *data, size_t datalen, char stateop,
                 PsycPacketFlag flag) {
  *p = (PsycPacket){
      .routing = {routinglen, routing},
      .entity = {entitylen, entity},
      .method = {methodlen, method},
      .data = {datalen, data},
      .content = {0, 0},
      .routinglen = 0,
      .contentlen = 0,
      .length = 0,
      .stateop = stateop,
      .flag = flag,
  };

  if (flag == PSYC_PACKET_CHECK_LENGTH)
    p->flag = psyc_packet_length_check(p);

  psyc_packet_length_set(p);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/source-manager/source/arm_uc_source_manager.c	find the index of the source with the smallest cost	2	"static arm_uc_error_t ARM_UCSM_SourceRegistryGetLowestCost(arm_uc_uri_t *uri,
                                                           query_type_t type,
                                                           uint8_t *excludes,
                                                           uint32_t *index) {
  uint32_t min_cost = UINT32_MAX;
  uint32_t min_cost_index = 0;

  arm_uc_error_t retval = (arm_uc_error_t){SOMA_ERR_NO_ROUTE_TO_SOURCE};

  UC_SRCE_TRACE_ENTRY("">> %s, type %"" PRIu32, __func__, (uint32_t)type);

  for (uint32_t i = 0; i < MAX_SOURCES; i++) {

    retval = (arm_uc_error_t){SOMA_ERR_NO_ROUTE_TO_SOURCE};

    if (source_registry[i] == NULL) {
      continue;
    } else if ((excludes != NULL) && (excludes[i] == 1)) {
      UC_SRCE_TRACE_VERBOSE(""skipping excluded index %"" PRIu32, i);
      continue;
    } else {
      UC_SRCE_TRACE_VERBOSE(""testing index %"" PRIu32, i);
    }

    ARM_SOURCE_CAPABILITIES cap = source_registry[i]->GetCapabilities();
    uint32_t cost = UINT32_MAX;

    switch (type) {
    case QUERY_TYPE_UNKNOWN:
      break;
    case QUERY_TYPE_MANIFEST_DEFAULT:
      if ((uri == NULL) && (cap.manifest_default == 1)) {
        UC_SRCE_TRACE_VERBOSE(""getting manifest default cost, index %"" PRIu32,
                              i);
        retval = source_registry[i]->GetManifestDefaultCost(&cost);
      }
      break;
    case QUERY_TYPE_MANIFEST_URL:
      if ((uri != NULL) && (cap.manifest_url == 1)) {
        UC_SRCE_TRACE_VERBOSE(""getting manifest url cost, index %"" PRIu32, i);
        retval = source_registry[i]->GetManifestURLCost(uri, &cost);
      }
      break;
    case QUERY_TYPE_FIRMWARE:
      if ((uri != NULL) && (cap.firmware == 1)) {
        UC_SRCE_TRACE_VERBOSE(""getting firmware url cost, index %"" PRIu32, i);
        retval = source_registry[i]->GetFirmwareURLCost(uri, &cost);
      }
      break;
    case QUERY_TYPE_KEYTABLE:
      if ((uri != NULL) && (cap.keytable == 1)) {
        UC_SRCE_TRACE_VERBOSE(""getting keytable url cost, index %"" PRIu32, i);
        retval = source_registry[i]->GetKeytableURLCost(uri, &cost);
      }
      break;
    default:
      break;
    }
    if (retval.error != ERR_NONE) {

      ARM_UCSM_SetError(retval);
      UC_SRCE_TRACE(""invalid cost for index %"" PRIu32 "" type %"" PRIu32, i,
                    (uint32_t)type);
      continue;
    }

    if (cost < min_cost) {
      min_cost = cost;
      min_cost_index = i;
    }
  }

  if (min_cost == UINT32_MAX) {
    UC_SRCE_ERR_MSG("".. %s: Error - No route"", __func__);
    return ARM_UCSM_SetError((arm_uc_error_t){SOMA_ERR_NO_ROUTE_TO_SOURCE});
  } else {
    *index = min_cost_index;
    UC_SRCE_TRACE_VERBOSE(""%s index = %"" PRIu32, __func__, min_cost_index);
    return (arm_uc_error_t){ERR_NONE};
  }
}"
HiPhish-XeenTools-ee7c26c/Source/maze/maze_tool.c	Read a maze from from DAT and MOB file.	2	"int xeen_read_maze(FILE *dat, FILE *mob, XeenMaze *maze) {
#define TILES (MAZE_WIDTH * MAZE_HEIGHT)

  enum {
    SUCCESS,
    INVALID_ARGS,
    FREAD_FAIL,
    MALLOC_FAIL,
  } error = SUCCESS;

  XeenMazeTile *tile = NULL;

  uint8_t object_list[16];
  uint8_t monster_list[16];
  uint8_t decor_list[16];

  int mob_objects = 0;
  int mob_monsters = 0;
  int mob_decors = 0;

  uint8_t(*mob_object)[4] = NULL;
  uint8_t(*mob_monster)[4] = NULL;
  uint8_t(*mob_decor)[4] = NULL;

  if (!dat || !mob || !maze) {
    error = INVALID_ARGS;
    goto fail;
  } else if (maze->tile) {
    error = INVALID_ARGS;
    goto fail;
  }

  if (!(tile = malloc(TILES * sizeof(*tile)))) {
    error = MALLOC_FAIL;
    goto fail;
  }

  if (fseek(dat, 0, SEEK_SET) != 0) {
    error = FREAD_FAIL;
    goto fail;
  }

  uint8_t dat_bytes[3 * TILES + 124];

  if (fread(dat_bytes, sizeof(dat_bytes[0]), 3 * TILES, dat) !=
      sizeof(dat_bytes)) {
    error = FREAD_FAIL;
    goto fail;
  }

  for (int y = 0; y < MAZE_HEIGHT; ++y) {
    for (int x = 0; x < MAZE_WIDTH; ++x) {
      int i = 1 * y * MAZE_HEIGHT + 1 * x;
      int j = 2 * y * MAZE_HEIGHT + 2 * x;

      tile[i].layer[0] = dat_bytes[j + 0] & 0x0F;
      tile[i].layer[1] = dat_bytes[j + 0] & 0xF0;
      tile[i].layer[2] = dat_bytes[j + 1] & 0x0F;
      tile[i].layer[3] = dat_bytes[j + 1] & 0xF0;

      tile[i].flags = dat_bytes[2 * TILES + i];
    }
  }

  do {
    int i = 3 * TILES + 60;
    int b = 0;
    uint8_t mask = 0x01;

    for (int y = 0; y < MAZE_HEIGHT; ++y) {
      for (int x = 0; x < MAZE_WIDTH; ++x) {

        int t = 1 * y * MAZE_HEIGHT + 1 * x;

        if (b == 8) {
          ++i;
          b = 0;
          mask = 0x01;
        }

        tile[t].seen = dat_bytes[i + 0] & mask ? 0x01 : 0x00;
        tile[t].stepped = dat_bytes[i + 32] & mask ? 0x01 : 0x00;

        ++b;
        mask <<= 1;
      }
    }
  } while (0);

#define READ_LIST(list)                                                        \
  if (fread(list, sizeof(list[0]), 16, mob) != sizeof(list)) {                 \
    error = FREAD_FAIL;                                                        \
    goto fail;                                                                 \
  }
  READ_LIST(object_list)
  READ_LIST(monster_list)
  READ_LIST(decor_list)
#undef READ_LIST

  uint8_t mob_bytes[4] = {0x00, 0x00, 0x00, 0x00};
#define COUNT_ITEMS(kind, count)                                               \
  do {                                                                         \
    if (fread(mob_bytes, sizeof(mob_bytes[0]), 4, mob) != sizeof(mob_bytes)) { \
      error = FREAD_FAIL;                                                      \
      goto fail;                                                               \
    }                                                                          \
    ++count;                                                                   \
  } while (mob_bytes != (uint8_t[4]){0xFF, 0xFF, 0xFF, 0xFF});                 \
  if (fseek(mob, -(--count), SEEK_CUR)) {                                      \
    error = FREAD_FAIL;                                                        \
    goto fail;                                                                 \
  }                                                                            \
  if (malloc(count * sizeof(*kind)) == NULL) {                                 \
    error = MALLOC_FAIL;                                                       \
    goto fail;                                                                 \
  }                                                                            \
  if (fread(kind, sizeof(*kind), count, mob) != count * sizeof(*kind)) {       \
    error = FREAD_FAIL;                                                        \
    goto fail;                                                                 \
  }                                                                            \
                                                                               \
  if (fseek(mob, 1, SEEK_CUR)) {                                               \
    error = FREAD_FAIL;                                                        \
    goto fail;                                                                 \
  }
  COUNT_ITEMS(mob_object, mob_objects)
  COUNT_ITEMS(mob_monster, mob_monsters)
  COUNT_ITEMS(mob_decor, mob_decors)
#undef COUNT_ITEMS
  assert(mob_object && mob_monster && mob_decor);

  for (int i = 0; i < mob_objects; ++i) {
    int x = mob_object[i][0];
    int y = mob_object[i][1];
    tile[y * MAZE_WIDTH + x].object.id = mob_object[i][2];
    tile[y * MAZE_WIDTH + x].object.dir = mob_object[i][3];
  }
  for (int i = 0; i < mob_monsters; ++i) {
    int x = mob_monster[i][0];
    int y = mob_monster[i][1];
    tile[y * MAZE_WIDTH + x].monster.id = mob_monster[i][2];
    tile[y * MAZE_WIDTH + x].monster.dir = mob_monster[i][3];
  }
  for (int i = 0; i < mob_decors; ++i) {
    int x = mob_decor[i][0];
    int y = mob_decor[i][1];
    tile[y * MAZE_WIDTH + x].decor = mob_decor[i][2];
  }

  free(mob_object);
  free(mob_monster);
  free(mob_decor);
  assert(!mob_object && !mob_monster && !mob_decor);

  *maze = (XeenMaze){
      .tile = tile,

#define OFF(n) (3 * TILES + n)
      .maze_n = dat_bytes[OFF(2)],
      .maze_e = dat_bytes[OFF(3)],
      .maze_s = dat_bytes[OFF(4)],
      .maze_w = dat_bytes[OFF(5)],

      .maze_flag_1 =
          ((uint16_t)dat_bytes[OFF(7)] << 8) + (uint16_t)dat_bytes[OFF(6)],
      .maze_flag_2 =
          ((uint16_t)dat_bytes[OFF(9)] << 8) + (uint16_t)dat_bytes[OFF(8)],

      .wall_types =
          {
              [0] = dat_bytes[OFF(10) + 0],
              [1] = dat_bytes[OFF(10) + 1],
              [2] = dat_bytes[OFF(10) + 2],
              [3] = dat_bytes[OFF(10) + 3],
              [4] = dat_bytes[OFF(10) + 4],
              [5] = dat_bytes[OFF(10) + 5],
              [6] = dat_bytes[OFF(10) + 6],
              [7] = dat_bytes[OFF(10) + 7],
              [8] = dat_bytes[OFF(10) + 8],
              [9] = dat_bytes[OFF(10) + 9],
              [10] = dat_bytes[OFF(10) + 10],
              [11] = dat_bytes[OFF(10) + 11],
              [12] = dat_bytes[OFF(10) + 12],
              [13] = dat_bytes[OFF(10) + 13],
              [14] = dat_bytes[OFF(10) + 14],
              [15] = dat_bytes[OFF(10) + 15],
          },

      .floor_types =
          {
              [0] = dat_bytes[OFF(26) + 0],
              [1] = dat_bytes[OFF(26) + 1],
              [2] = dat_bytes[OFF(26) + 2],
              [3] = dat_bytes[OFF(26) + 3],
              [4] = dat_bytes[OFF(26) + 4],
              [5] = dat_bytes[OFF(26) + 5],
              [6] = dat_bytes[OFF(26) + 6],
              [7] = dat_bytes[OFF(26) + 7],
              [8] = dat_bytes[OFF(26) + 8],
              [9] = dat_bytes[OFF(26) + 9],
              [10] = dat_bytes[OFF(26) + 10],
              [11] = dat_bytes[OFF(26) + 11],
              [12] = dat_bytes[OFF(26) + 12],
              [13] = dat_bytes[OFF(26) + 13],
              [14] = dat_bytes[OFF(26) + 14],
              [15] = dat_bytes[OFF(26) + 15],
          },

      .floor_type = dat_bytes[OFF(42)],
      .run_x = dat_bytes[OFF(43)],
      .wall_no_pass = dat_bytes[OFF(44)],
      .surf_no_pass = dat_bytes[OFF(45)],
      .unlock_door = dat_bytes[OFF(46)],
      .unlock_box = dat_bytes[OFF(47)],
      .bash_door = dat_bytes[OFF(48)],
      .bash_grate = dat_bytes[OFF(49)],
      .bash_wall = dat_bytes[OFF(50)],
      .run_chance = dat_bytes[OFF(51)],
      .run_y = dat_bytes[OFF(52)],
      .trap_dmg = dat_bytes[OFF(53)],
      .wall_type = dat_bytes[OFF(54)],
      .tavern_tips = dat_bytes[OFF(55)],
#undef OFF
  };

  return error;

fail:
  if (tile) {
    free(tile);
  }
  if (mob_object) {
    free(mob_object);
  }
  if (mob_monster) {
    free(mob_monster);
  }
  if (mob_decor) {
    free(mob_decor);
  }
  return error;

#undef TILES
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/dialogs.c	"Popup a generic dialog to display some generic information about terrain : tile, units , cities, etc."	2	"void popup_advanced_terrain_dialog(struct tile *ptile, Uint16 pos_x,
                                   Uint16 pos_y) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  struct city *pCity;
  struct unit *pFocus_Unit;
  utf8_str *pstr;
  SDL_Rect area2;
  struct CONTAINER *pCont;
  char cBuf[255];
  int n, w = 0, h, units_h = 0;
  SDL_Rect area;

  if (pAdvanced_Terrain_Dlg) {
    return;
  }

  pCity = tile_city(ptile);
  n = unit_list_size(ptile->units);
  pFocus_Unit = head_of_units_in_focus();

  if (!n && !pCity && !pFocus_Unit) {
    popup_terrain_info_dialog(NULL, ptile);

    return;
  }

  area.h = adj_size(2);
  is_unit_move_blocked = TRUE;

  pAdvanced_Terrain_Dlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pCont = fc_calloc(1, sizeof(struct CONTAINER));
  pCont->id0 = index_to_map_pos_x(tile_index(ptile));
  pCont->id1 = index_to_map_pos_y(tile_index(ptile));

  pstr = create_utf8_from_char(_(""Advanced Menu""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = advanced_terrain_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_TERRAIN_ADV_DLG_WINDOW, pWindow);
  pAdvanced_Terrain_Dlg->pEndWidgetList = pWindow;

  area = pWindow->area;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  area.w += pBuf->size.w + adj_size(10);
  pBuf->action = exit_advanced_terrain_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_TERRAIN_ADV_DLG_EXIT_BUTTON, pBuf);

  pstr = create_utf8_from_char(_(""Terrain Info""), adj_font(10));
  pstr->style |= TTF_STYLE_BOLD;

  pBuf = create_iconlabel(
      NULL, pWindow->dst, pstr,
      (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE | WF_FREE_DATA));

  pBuf->string_utf8->bgcol = (SDL_Color){0, 0, 0, 0};

  pBuf->data.cont = pCont;

  pBuf->action = terrain_info_callback;
  set_wstate(pBuf, FC_WS_NORMAL);

  add_to_gui_list(ID_LABEL, pBuf);

  area.w = MAX(area.w, pBuf->size.w);
  area.h += pBuf->size.h;

  if (pCity && city_owner(pCity) == client.conn.playing) {

    pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);

    add_to_gui_list(ID_SEPARATOR, pBuf);
    area.h += pBuf->next->size.h;

    fc_snprintf(cBuf, sizeof(cBuf), _(""Zoom to : %s""), city_name_get(pCity));

    create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                            zoom_to_city_callback);
    pBuf->data.city = pCity;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(ID_LABEL, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;

    create_active_iconlabel(pBuf, pWindow->dst, pstr, _(""Change Production""),
                            change_production_callback);

    pBuf->data.city = pCity;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(ID_LABEL, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;

    create_active_iconlabel(pBuf, pWindow->dst, pstr, _(""Hurry production""),
                            hurry_production_callback);

    pBuf->data.city = pCity;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(ID_LABEL, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;

    create_active_iconlabel(pBuf, pWindow->dst, pstr,
                            _(""Change City Governor settings""), cma_callback);

    pBuf->data.city = pCity;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(ID_LABEL, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;
  }

  if (pFocus_Unit &&
      (tile_index(unit_tile(pFocus_Unit)) != tile_index(ptile))) {

    pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);

    add_to_gui_list(ID_SEPARATOR, pBuf);
    area.h += pBuf->next->size.h;

    create_active_iconlabel(pBuf, pWindow->dst, pstr, _(""Goto here""),
                            goto_here_callback);
    pBuf->data.cont = pCont;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(MAX_ID - 1000 - pFocus_Unit->id, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;

    create_active_iconlabel(pBuf, pWindow->dst, pstr, _(""Patrol here""),
                            patrol_here_callback);
    pBuf->data.cont = pCont;
    set_wstate(pBuf, FC_WS_NORMAL);

    add_to_gui_list(MAX_ID - 1000 - pFocus_Unit->id, pBuf);

    area.w = MAX(area.w, pBuf->size.w);
    area.h += pBuf->size.h;

#if 0  
    if (unit_has_type_flag(pFocus_Unit, UTYF_SETTLERS)) {
      create_active_iconlabel(pBuf, pWindow->dst->surface, pstr, _(""Connect here""),
                              connect_here_callback);
      pBuf->data.cont = pCont;
      set_wstate(pBuf, FC_WS_NORMAL);

      add_to_gui_list(ID_LABEL, pBuf);

      area.w = MAX(area.w, pBuf->size.w);
      area.h += pBuf->size.h;
    }
#endif

    if (can_unit_paradrop(pFocus_Unit) && client_tile_get_known(ptile) &&
        !(((pCity &&
            pplayers_non_attack(client.conn.playing, city_owner(pCity))) ||
           is_non_attack_unit_tile(ptile, client.conn.playing))) &&
        (unit_type_get(pFocus_Unit)->paratroopers_range >=
         real_map_distance(unit_tile(pFocus_Unit), ptile))) {

      create_active_iconlabel(pBuf, pWindow->dst, pstr, _(""Paradrop here""),
                              paradrop_here_callback);
      pBuf->data.cont = pCont;
      set_wstate(pBuf, FC_WS_NORMAL);

      add_to_gui_list(ID_LABEL, pBuf);

      area.w = MAX(area.w, pBuf->size.w);
      area.h += pBuf->size.h;
    }
  }
  pAdvanced_Terrain_Dlg->pBeginWidgetList = pBuf;

  if (n) {
    int i;
    struct unit *pUnit;
    struct unit_type *pUnitType = NULL;

    units_h = 0;

    pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);

    add_to_gui_list(ID_SEPARATOR, pBuf);
    area.h += pBuf->next->size.h;

    if (n > 1) {
      struct unit *pDefender, *pAttacker;
      struct widget *pLast = pBuf;
      bool reset = FALSE;
      int my_units = 0;
      const char *vetname;

#define ADV_NUM_SEEN 15

      pDefender = (pFocus_Unit ? get_defender(pFocus_Unit, ptile) : NULL);
      pAttacker = (pFocus_Unit ? get_attacker(pFocus_Unit, ptile) : NULL);
      for (i = 0; i < n; i++) {
        pUnit = unit_list_get(ptile->units, i);
        if (pUnit == pFocus_Unit) {
          continue;
        }
        pUnitType = unit_type_get(pUnit);
        vetname = utype_veteran_name_translation(pUnitType, pUnit->veteran);

        if (unit_owner(pUnit) == client.conn.playing) {
          fc_snprintf(cBuf, sizeof(cBuf),
                      _(""Activate %s (%d / %d) %s (%d,%d,%s) %s""),
                      (vetname != NULL ? vetname : """"), pUnit->hp,
                      pUnitType->hp, utype_name_translation(pUnitType),
                      pUnitType->attack_strength, pUnitType->defense_strength,
                      move_points_text(pUnitType->move_rate, FALSE),
                      unit_activity_text(pUnit));

          create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                                  adv_unit_select_callback);
          pBuf->data.unit = pUnit;
          set_wstate(pBuf, FC_WS_NORMAL);
          add_to_gui_list(ID_LABEL, pBuf);
          my_units++;
        } else {
          int att_chance, def_chance;

          fc_snprintf(
              cBuf, sizeof(cBuf), _(""%s %s %s (A:%d D:%d M:%s FP:%d) HP:%d%%""),
              nation_adjective_for_player(unit_owner(pUnit)),
              (vetname != NULL ? vetname : """"),
              utype_name_translation(pUnitType), pUnitType->attack_strength,
              pUnitType->defense_strength,
              move_points_text(pUnitType->move_rate, FALSE),
              pUnitType->firepower, ((pUnit->hp * 100) / pUnitType->hp));

          if (sdl_get_chance_to_win(&att_chance, &def_chance, pUnit,
                                    pFocus_Unit)) {

            cat_snprintf(cBuf, sizeof(cBuf), _("" CtW: Att:%d%% Def:%d%%""),
                         att_chance, def_chance);
          }

          if (pAttacker && pAttacker == pUnit) {
            pstr->fgcol = *(get_game_color(COLOR_OVERVIEW_ENEMY_UNIT));
            reset = TRUE;
          } else {
            if (pDefender && pDefender == pUnit) {
              pstr->fgcol = *(get_game_color(COLOR_OVERVIEW_MY_UNIT));
              reset = TRUE;
            }
          }

          create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf, NULL);

          if (reset) {
            pstr->fgcol = *get_theme_color(COLOR_THEME_ADVANCEDTERRAINDLG_TEXT);
            reset = FALSE;
          }

          add_to_gui_list(ID_LABEL, pBuf);
        }

        area.w = MAX(area.w, pBuf->size.w);
        units_h += pBuf->size.h;

        if (i > ADV_NUM_SEEN - 1) {
          set_wflag(pBuf, WF_HIDDEN);
        }
      }

      pAdvanced_Terrain_Dlg->pEndActiveWidgetList = pLast->prev;
      pAdvanced_Terrain_Dlg->pActiveWidgetList =
          pAdvanced_Terrain_Dlg->pEndActiveWidgetList;
      pAdvanced_Terrain_Dlg->pBeginWidgetList = pBuf;
      pAdvanced_Terrain_Dlg->pBeginActiveWidgetList =
          pAdvanced_Terrain_Dlg->pBeginWidgetList;

      if (n > ADV_NUM_SEEN) {
        units_h = ADV_NUM_SEEN * pBuf->size.h;
        n = create_vertical_scrollbar(pAdvanced_Terrain_Dlg, 1, ADV_NUM_SEEN,
                                      TRUE, TRUE);
        area.w += n;
      }

      if (my_units > 1) {
        fc_snprintf(cBuf, sizeof(cBuf), ""%s (%d)"", _(""Ready all""), my_units);
        create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                                adv_unit_select_all_callback);
        pBuf->data.unit =
            pAdvanced_Terrain_Dlg->pEndActiveWidgetList->data.unit;
        set_wstate(pBuf, FC_WS_NORMAL);
        pBuf->ID = ID_LABEL;
        DownAdd(pBuf, pLast);
        area.h += pBuf->size.h;

        fc_snprintf(cBuf, sizeof(cBuf), ""%s (%d)"", _(""Sentry idle""), my_units);
        create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                                adv_unit_sentry_idle_callback);
        pBuf->data.unit =
            pAdvanced_Terrain_Dlg->pEndActiveWidgetList->data.unit;
        set_wstate(pBuf, FC_WS_NORMAL);
        pBuf->ID = ID_LABEL;
        DownAdd(pBuf, pLast->prev);
        area.h += pBuf->size.h;

        pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);
        pBuf->ID = ID_SEPARATOR;
        DownAdd(pBuf, pLast->prev->prev);
        area.h += pBuf->next->size.h;
      }
#undef ADV_NUM_SEEN
    } else {

      pUnit = unit_list_get(ptile->units, 0);
      pUnitType = unit_type_get(pUnit);
      if (pUnit != pFocus_Unit) {
        const char *vetname;

        vetname = utype_veteran_name_translation(pUnitType, pUnit->veteran);
        if ((pCity && city_owner(pCity) == client.conn.playing) ||
            (unit_owner(pUnit) == client.conn.playing)) {
          fc_snprintf(cBuf, sizeof(cBuf),
                      _(""Activate %s (%d / %d) %s (%d,%d,%s) %s""),
                      (vetname != NULL ? vetname : """"), pUnit->hp,
                      pUnitType->hp, utype_name_translation(pUnitType),
                      pUnitType->attack_strength, pUnitType->defense_strength,
                      move_points_text(pUnitType->move_rate, FALSE),
                      unit_activity_text(pUnit));

          create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                                  adv_unit_select_callback);
          pBuf->data.unit = pUnit;
          set_wstate(pBuf, FC_WS_NORMAL);

          add_to_gui_list(ID_LABEL, pBuf);

          area.w = MAX(area.w, pBuf->size.w);
          units_h += pBuf->size.h;

          pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);

          add_to_gui_list(ID_SEPARATOR, pBuf);
          area.h += pBuf->next->size.h;
        } else {
          int att_chance, def_chance;

          fc_snprintf(
              cBuf, sizeof(cBuf), _(""%s %s %s (A:%d D:%d M:%s FP:%d) HP:%d%%""),
              nation_adjective_for_player(unit_owner(pUnit)),
              (vetname != NULL ? vetname : """"),
              utype_name_translation(pUnitType), pUnitType->attack_strength,
              pUnitType->defense_strength,
              move_points_text(pUnitType->move_rate, FALSE),
              pUnitType->firepower, ((pUnit->hp * 100) / pUnitType->hp));

          if (sdl_get_chance_to_win(&att_chance, &def_chance, pUnit,
                                    pFocus_Unit)) {
            cat_snprintf(cBuf, sizeof(cBuf), _("" CtW: Att:%d%% Def:%d%%""),
                         att_chance, def_chance);
          }
          create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf, NULL);
          add_to_gui_list(ID_LABEL, pBuf);
          area.w = MAX(area.w, pBuf->size.w);
          units_h += pBuf->size.h;

          pBuf = create_iconlabel(NULL, pWindow->dst, NULL, WF_FREE_THEME);

          add_to_gui_list(ID_SEPARATOR, pBuf);
          area.h += pBuf->next->size.h;
        }
      }

      fc_snprintf(cBuf, sizeof(cBuf), _(""Look up \""%s\"" in the Help Browser""),
                  utype_name_translation(pUnitType));
      create_active_iconlabel(pBuf, pWindow->dst, pstr, cBuf,
                              unit_help_callback);
      set_wstate(pBuf, FC_WS_NORMAL);
      add_to_gui_list(MAX_ID - utype_number(pUnitType), pBuf);

      area.w = MAX(area.w, pBuf->size.w);
      units_h += pBuf->size.h;

      pAdvanced_Terrain_Dlg->pBeginWidgetList = pBuf;
    }
  }

  area.w += adj_size(2);
  area.h += units_h;

  resize_window(pWindow, NULL, NULL,
                (pWindow->size.w - pWindow->area.w) + area.w,
                (pWindow->size.h - pWindow->area.h) + area.h);

  area = pWindow->area;

  widget_set_position(pWindow, pos_x, pos_y);

  w = area.w - adj_size(2);

  if (pAdvanced_Terrain_Dlg->pScroll) {
    units_h = n;
  } else {
    units_h = 0;
  }

  pBuf = pWindow->prev;

  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  pBuf = pBuf->prev;

  pBuf->size.x = area.x + 1;
  pBuf->size.y = area.y + 1;
  pBuf->size.w = w;
  h = pBuf->size.h;

  area2.x = adj_size(10);
  area2.h = adj_size(2);

  pBuf = pBuf->prev;
  while (pBuf) {
    if (pBuf == pAdvanced_Terrain_Dlg->pEndActiveWidgetList) {
      w -= units_h;
    }

    pBuf->size.w = w;
    pBuf->size.x = pBuf->next->size.x;
    pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h;

    if (pBuf->ID == ID_SEPARATOR) {
      FREESURFACE(pBuf->theme);
      pBuf->size.h = h;
      pBuf->theme = create_surf(w, h, SDL_SWSURFACE);

      area2.y = pBuf->size.h / 2 - 1;
      area2.w = pBuf->size.w - adj_size(20);

      SDL_FillRect(
          pBuf->theme, &area2,
          map_rgba(pBuf->theme->format,
                   *get_theme_color(COLOR_THEME_ADVANCEDTERRAINDLG_TEXT)));
    }

    if (pBuf == pAdvanced_Terrain_Dlg->pBeginWidgetList ||
        pBuf == pAdvanced_Terrain_Dlg->pBeginActiveWidgetList) {
      break;
    }
    pBuf = pBuf->prev;
  }

  if (pAdvanced_Terrain_Dlg->pScroll) {
    setup_vertical_scrollbar_area(
        pAdvanced_Terrain_Dlg->pScroll, area.x + area.w,
        pAdvanced_Terrain_Dlg->pEndActiveWidgetList->size.y,
        area.y - pAdvanced_Terrain_Dlg->pEndActiveWidgetList->size.y + area.h,
        TRUE);
  }

  redraw_group(pAdvanced_Terrain_Dlg->pBeginWidgetList, pWindow, 0);

  widget_flush(pWindow);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a GET MAX LUN control request to the attached device, retrieving the index of the highest LUN (Logical UNit, a logical drive) in the device. This value can then be used in the other functions of the Mass Storage Host mode Class driver to address a specific LUN within the device."	1	"uint8_t MS_Host_GetMaxLUN(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) !=
      HOST_SENDCONTROL_Successful) {
    *MaxLUNIndex = 0;
    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the bezier pyramid basis functions.	2	"static void test_unit_basis_pyramid_bezier(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_PYR_Bezier *b_data_a =
                                   constructor_Basis_Data_PYR_Bezier('a'),
                               *b_data_c =
                                   constructor_Basis_Data_PYR_Bezier('c');

  tol = (double[]){
      EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[0]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2e0 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi32, b_data_c->grad_phi32,
                                     tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi32,
                                           b_data_c->grad_phi32, tol[0]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){EPS};
  differences = (bool[]){
      diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[0]);
  }
  expect_condition(pass, ""partition of unity"");

  tol = (double[]){
      6e2 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_36, b_data_c->grad_coef_36,
                              tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_36,
                                    b_data_c->grad_coef_36, tol[0]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_PYR_Bezier(b_data_a);
  destructor_Basis_Data_PYR_Bezier(b_data_c);

  assert_condition(pass);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the conjugate of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_float qconjugatef(const quaternion_float num) {
  return (quaternion_float){num.R, num.i * -1.0F, num.j * -1.0F, num.k * -1.0F};
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Subtract two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion qsub(const quaternion num1,
                                   const quaternion num2) {
  return (quaternion){num1.R - num2.R, num1.i - num2.i, num1.j - num2.j,
                      num1.k - num2.k};
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/alpn-test.c	"In this test case, establish a security context, with server ready for ALPN, and the client sends a known protocol. The ALPN callback should respond with the matching protocol. The client and server inquire the context and verify the protocol matches the desired alpn."	3	"init_alpn1(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;
  const char *why = """";
  unsigned char server_alpn[] = {
      3,
      'g',
      's',
      'i',
  };
  unsigned char client_alpn[] = {
      3,
      'g',
      's',
      'i',
  };

  major_status =
      gss_set_sec_context_option(&minor_status, &accept_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = server_alpn,
                                     .length = sizeof(server_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }
  major_status =
      gss_set_sec_context_option(&minor_status, &init_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = client_alpn,
                                     .length = sizeof(client_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }

  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;
    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, init_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);
    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 1 || data->elements[0].length != server_alpn[0] ||
        memcmp(data->elements[0].value, &server_alpn[1], server_alpn[0]) != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    gss_release_buffer_set(&minor_status, &data);

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, accept_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);
    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 1 || data->elements[0].length != client_alpn[0] ||
        memcmp(data->elements[0].value, &client_alpn[1], client_alpn[0]) != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    gss_release_buffer_set(&minor_status, &data);
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a double-precision value into the high-order bits of a 128-bit vector of [2 x double]. The low-order bits are copied from the low-order bits of the first operand.	2	"_mm_loadh_pd(__m128d __a, double const *__dp) {
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__a[0], __u};
}"
PJK-libcbor-87f977e/src/cbor/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float4() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_32}}};
  return item;
}"
luciotato-LiteScript-118e12d/devel/litec/core/LiteC-core.c	"make a COPY of this string contents -if it was mode:ConcatdSlices, create a continuous string. also NULL terminated -if it was simple, crate a COPY un a new allocd space, NULL terminated"	2	"any _newCCompatString(any s) {
  assert(s.class == String_inx);
  if (!s.res) {
    Cloned_to_CString++;
    return _cloneSimpleString(s);
  };
  Flatten_calls++;

  len_t combinedSize = _getConcatdCombinedSize(s);

  char *buf = mem_alloc(combinedSize + 1);

  _copyConcatd(s, buf, combinedSize + 1);

  return (any){
      .class = String_inx, .res = 0, .value.ptr = buf, .len = combinedSize};
}"
yagu0-cgds-71e16e3/src/Heap.c	"Insert a pair (item,value) inside the heap."	2	"void _heap_insert(Heap *heap, void *item, Real value) {
  ItemValue itemValue =
      (ItemValue){.item = safe_malloc(heap->dataSize), .value = value};
  memcpy(itemValue.item, item, heap->dataSize);
  _vector_push(heap->array, &itemValue);
  _heap_bubble_up(heap, heap->array->size - 1);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Device/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"TASK(TCP_Task) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT.FrameInBuffer)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT.FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT
              .FrameData[sizeof(Ethernet_Frame_Header_t) + sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
                              sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
                         ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT.FrameLength = PacketSize;
      FrameOUT.FrameInBuffer = true;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
viking-gps-viking-4518f80/src/vikmapslayer.c	"Caller has to decrease reference counter of returned GdkPixbuf, when buffer is no longer needed."	4	"static GdkPixbuf *pixbuf_apply_settings(GdkPixbuf *pixbuf, VikMapsLayer *vml,
                                        guint vp_scale, MapCoord *mapcoord,
                                        gdouble xshrinkfactor,
                                        gdouble yshrinkfactor) {
  VikMapSource *map = MAPS_LAYER_NTH_TYPE(vml->maptype);

  if (pixbuf && vml->alpha < 255)
    pixbuf = ui_pixbuf_set_alpha(pixbuf, vml->alpha);

  if (pixbuf && (xshrinkfactor != 1.0 || yshrinkfactor != 1.0))
    pixbuf = pixbuf_shrink(pixbuf, xshrinkfactor, yshrinkfactor);

  if (pixbuf && (vp_scale != 1 || vik_map_source_get_scale(map) != 1)) {
    gdouble xscale = vp_scale;
    gdouble yscale = vp_scale;
    if (vik_map_source_get_scale(map) != 0.0) {
      xscale = vp_scale / vik_map_source_get_scale(map);
      yscale = vp_scale / vik_map_source_get_scale(map);
    }
    pixbuf = pixbuf_shrink(pixbuf, xscale, yscale);
  }

  if (pixbuf)
    a_mapcache_add(pixbuf, (mapcache_extra_t){0.0}, mapcoord->x, mapcoord->y,
                   mapcoord->z, vik_map_source_get_uniq_id(map),
                   mapcoord->scale, vml->alpha, xshrinkfactor, yshrinkfactor,
                   vml->filename);

  return pixbuf;
}"
SanderMertens-flecs-f50e6b1/src/entity.c	Create a new set of entities. This operation creates the number of specified entities with one API call which is a more efficient alternative to calling ecs_new in a loop.	2	"EcsEntity _ecs_new_w_count(EcsWorld *world, EcsType type, uint32_t count,
                           EcsEntity *handles_out) {
  ecs_assert(world != NULL, ECS_INVALID_PARAMETERS, NULL);

  EcsStage *stage = ecs_get_stage(&world);
  EcsEntity result = world->last_handle + 1;
  world->last_handle += count;

  ecs_assert(!world->is_merging, ECS_INVALID_WHILE_MERGING, NULL);

  if (type) {
    EcsTable *table = ecs_world_get_table(world, stage, type);
    uint32_t row = ecs_table_grow(world, table, table->columns, count, result);

    EcsMap *entity_index = stage->entity_index;

    uint32_t cur_index_count = ecs_map_count(entity_index);
    ecs_map_set_size(entity_index, cur_index_count + count);

    int i;
    for (i = result; i < (result + count); i++) {

      EcsRow new_row = (EcsRow){.type_id = type, .index = row};
      ecs_map_set64(entity_index, i, ecs_from_row(new_row));

      row++;
    }

    notify_pre_merge(world, table, table->columns, row - count, count, type,
                     world->type_sys_add_index);
  }

  if (handles_out) {
    int i;
    for (i = 0; i < count; i++) {
      handles_out[i] = result + i;
    }
  }

  return result;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/structops.c	"The S.exstatic, S.Exstatic, and S.EXSTATIC control macros. exstatic name linkage-name [""-thread-local""] name is a bareword; linkage-name is a stringoid. Semantics: A constant variable with the given name is defined, referencing a statically-allocated strangelet (as with S.static) with the given linkage name. -thread-local must be given if and only if the corresponding S.static is also thread-local. The visibility is passed to the macro via the macro userdata. This is a direct front-end to the S-ext-bss P-Code declaration."	2	"AVA_DEF_MACRO_SUBST(ava_intr_S_exstatic_subst) {
  const ava_parse_unit *name_unit, *linkage_name_unit;
  const ava_parse_unit *option_unit = NULL;
  ava_string name, linkage_name, option;
  ava_intr_S_exstatic *node;

  node = AVA_NEW(ava_intr_S_exstatic);

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN {
      AVA_MACRO_ARG_CURRENT_UNIT(name_unit, ""name"");
      AVA_MACRO_ARG_BAREWORD(name, ""name"");
      AVA_MACRO_ARG_CURRENT_UNIT(linkage_name_unit, ""linkage name"");
      AVA_MACRO_ARG_STRINGOID(linkage_name, ""linkage name"");

      while (AVA_MACRO_ARG_HAS_ARG()) {
        AVA_MACRO_ARG_CURRENT_UNIT(option_unit, ""option"");
        AVA_MACRO_ARG_BAREWORD(option, ""option"");

        if (ava_string_equal(ava_intr_S_static_thread_local_option, option)) {
          if (node->thr_local) {
            ava_macsub_record_error(context,
                                    ava_error_macro_arg_given_more_than_once(
                                        &option_unit->location,
                                        ava_intr_S_static_thread_local_option));
          } else {
            node->thr_local = ava_true;
          }
        } else {
          ava_macsub_record_error(
              context, ava_error_bad_macro_keyword(
                           &option_unit->location, self->full_name, option,
                           ava_intr_S_static_thread_local_option));
        }
      }
    }
  }

  node->header.v = &ava_intr_S_exstatic_vtable;
  node->header.context = context;
  node->header.location = provoker->location;
  node->var_sym = AVA_NEW(ava_symbol);
  node->var_sym->type = ava_st_global_variable;
  node->var_sym->level = ava_macsub_get_level(context);
  node->var_sym->visibility = *(const ava_visibility *)self->v.macro.userdata;
  node->var_sym->definer = (ava_ast_node *)node;
  node->var_sym->full_name = ava_macsub_apply_prefix(context, name);
  node->var_sym->v.var.is_mutable = ava_false;
  node->var_sym->v.var.name.scheme = ava_nms_none;
  node->var_sym->v.var.name.name = linkage_name;

  ava_macsub_put_symbol(context, node->var_sym, &name_unit->location);

  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = (ava_ast_node *)node};
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libpostproc/postprocess_template.c	Filter array of bytes (Y or U or V values)	2	"static void RENAME(postProcess)(const uint8_t src[], int srcStride,
                                uint8_t dst[], int dstStride, int width,
                                int height, const int8_t QPs[], int QPStride,
                                int isColor, PPContext *c2) {
  DECLARE_ALIGNED(8, PPContext, c) = *c2;
  int x, y;
#ifdef TEMPLATE_PP_TIME_MODE
  const int mode = TEMPLATE_PP_TIME_MODE;
#else
  const int mode = isColor ? c.ppMode.chromMode : c.ppMode.lumMode;
#endif
  int black = 0, white = 255;
  int QPCorrecture = 256 * 256;

  int copyAhead;
#if TEMPLATE_PP_MMX
  int i;
#endif

  const int qpHShift = isColor ? 4 - c.hChromaSubSample : 4;
  const int qpVShift = isColor ? 4 - c.vChromaSubSample : 4;

  uint64_t *const yHistogram = c.yHistogram;
  uint8_t *const tempSrc =
      srcStride > 0 ? c.tempSrc : c.tempSrc - 23 * srcStride;
  uint8_t *const tempDst =
      (dstStride > 0 ? c.tempDst : c.tempDst - 23 * dstStride) + 32;

  if (mode & VISUALIZE) {
    if (!(mode & (V_A_DEBLOCK | H_A_DEBLOCK)) || TEMPLATE_PP_MMX) {
      av_log(c2, AV_LOG_WARNING,
             ""Visualization is currently only supported with the accurate ""
             ""deblock filter without SIMD\n"");
    }
  }

#if TEMPLATE_PP_MMX
  for (i = 0; i < 57; i++) {
    int offset = ((i * c.ppMode.baseDcDiff) >> 8) + 1;
    int threshold = offset * 2 + 1;
    c.mmxDcOffset[i] = 0x7F - offset;
    c.mmxDcThreshold[i] = 0x7F - threshold;
    c.mmxDcOffset[i] *= 0x0101010101010101LL;
    c.mmxDcThreshold[i] *= 0x0101010101010101LL;
  }
#endif

  if (mode & CUBIC_IPOL_DEINT_FILTER)
    copyAhead = 16;
  else if ((mode & LINEAR_BLEND_DEINT_FILTER) || (mode & FFMPEG_DEINT_FILTER) ||
           (mode & LOWPASS5_DEINT_FILTER))
    copyAhead = 14;
  else if ((mode & V_DEBLOCK) || (mode & LINEAR_IPOL_DEINT_FILTER) ||
           (mode & MEDIAN_DEINT_FILTER) || (mode & V_A_DEBLOCK))
    copyAhead = 13;
  else if (mode & V_X1_FILTER)
    copyAhead = 11;

  else if (mode & DERING)
    copyAhead = 9;
  else
    copyAhead = 8;

  copyAhead -= 8;

  if (!isColor) {
    uint64_t sum = 0;
    int i;
    uint64_t maxClipped;
    uint64_t clipped;
    AVRational scale;

    c.frameNum++;

    if (c.frameNum == 1)
      yHistogram[0] = width * (uint64_t)height / 64 * 15 / 256;

    for (i = 0; i < 256; i++) {
      sum += yHistogram[i];
    }

    maxClipped = av_rescale(sum, c.ppMode.maxClippedThreshold.num,
                            c.ppMode.maxClippedThreshold.den);

    clipped = sum;
    for (black = 255; black > 0; black--) {
      if (clipped < maxClipped)
        break;
      clipped -= yHistogram[black];
    }

    clipped = sum;
    for (white = 0; white < 256; white++) {
      if (clipped < maxClipped)
        break;
      clipped -= yHistogram[white];
    }

    scale = (AVRational){c.ppMode.maxAllowedY - c.ppMode.minAllowedY,
                         white - black};

#if TEMPLATE_PP_MMXEXT
    c.packedYScale = (uint16_t)av_rescale(scale.num, 256, scale.den);
    c.packedYOffset =
        (((black * c.packedYScale) >> 8) - c.ppMode.minAllowedY) & 0xFFFF;
#else
    c.packedYScale = (uint16_t)av_rescale(scale.num, 1024, scale.den);
    c.packedYOffset = (black - c.ppMode.minAllowedY) & 0xFFFF;
#endif

    c.packedYOffset |= c.packedYOffset << 32;
    c.packedYOffset |= c.packedYOffset << 16;

    c.packedYScale |= c.packedYScale << 32;
    c.packedYScale |= c.packedYScale << 16;

    if (mode & LEVEL_FIX)
      QPCorrecture = (int)av_rescale(scale.num, 256 * 256, scale.den);
    else
      QPCorrecture = 256 * 256;
  } else {
    c.packedYScale = 0x0100010001000100LL;
    c.packedYOffset = 0;
    QPCorrecture = 256 * 256;
  }

  y = -BLOCK_SIZE;
  {
    const uint8_t *srcBlock = &(src[y * srcStride]);
    uint8_t *dstBlock = tempDst + dstStride;

    for (x = 0; x < width; x += BLOCK_SIZE) {
      RENAME(prefetchnta)
      (srcBlock + (((x >> 2) & 6) + copyAhead) * srcStride + 32);
      RENAME(prefetchnta)
      (srcBlock + (((x >> 2) & 6) + copyAhead + 1) * srcStride + 32);
      RENAME(prefetcht0)
      (dstBlock + (((x >> 2) & 6) + copyAhead) * dstStride + 32);
      RENAME(prefetcht0)
      (dstBlock + (((x >> 2) & 6) + copyAhead + 1) * dstStride + 32);

      RENAME(blockCopy)
      (dstBlock + dstStride * 8, dstStride, srcBlock + srcStride * 8, srcStride,
       mode & LEVEL_FIX, &c.packedYOffset);

      RENAME(duplicate)(dstBlock + dstStride * 8, dstStride);

      if (mode & LINEAR_IPOL_DEINT_FILTER)
        RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
      else if (mode & LINEAR_BLEND_DEINT_FILTER)
        RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
      else if (mode & MEDIAN_DEINT_FILTER)
        RENAME(deInterlaceMedian)(dstBlock, dstStride);
      else if (mode & CUBIC_IPOL_DEINT_FILTER)
        RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
      else if (mode & FFMPEG_DEINT_FILTER)
        RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
      else if (mode & LOWPASS5_DEINT_FILTER)
        RENAME(deInterlaceL5)
        (dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);

      dstBlock += 8;
      srcBlock += 8;
    }
    if (width == FFABS(dstStride))
      linecpy(dst, tempDst + 9 * dstStride, copyAhead, dstStride);
    else {
      int i;
      for (i = 0; i < copyAhead; i++) {
        memcpy(dst + i * dstStride, tempDst + (9 + i) * dstStride, width);
      }
    }
  }

  for (y = 0; y < height; y += BLOCK_SIZE) {

    const uint8_t *srcBlock = &(src[y * srcStride]);
    uint8_t *dstBlock = &(dst[y * dstStride]);
#if TEMPLATE_PP_MMX
    uint8_t *tempBlock1 = c.tempBlocks;
    uint8_t *tempBlock2 = c.tempBlocks + 8;
#endif
    const int8_t *QPptr = &QPs[(y >> qpVShift) * QPStride];
    int8_t *nonBQPptr = &c.nonBQPTable[(y >> qpVShift) * FFABS(QPStride)];
    int QP = 0, nonBQP = 0;

    if (y + 15 >= height) {
      int i;

      linecpy(tempSrc + srcStride * copyAhead, srcBlock + srcStride * copyAhead,
              FFMAX(height - y - copyAhead, 0), srcStride);

      for (i = FFMAX(height - y, 8); i < copyAhead + 8; i++)
        memcpy(tempSrc + srcStride * i, src + srcStride * (height - 1),
               FFABS(srcStride));

      linecpy(tempDst, dstBlock - dstStride,
              FFMIN(height - y + 1, copyAhead + 1), dstStride);

      for (i = height - y + 1; i <= copyAhead; i++)
        memcpy(tempDst + dstStride * i, dst + dstStride * (height - 1),
               FFABS(dstStride));

      dstBlock = tempDst + dstStride;
      srcBlock = tempSrc;
    }

    for (x = 0; x < width;) {
      int startx = x;
      int endx = FFMIN(width, x + 32);
      uint8_t *dstBlockStart = dstBlock;
      const uint8_t *srcBlockStart = srcBlock;
      int qp_index = 0;
      for (qp_index = 0; qp_index < (endx - startx) / BLOCK_SIZE; qp_index++) {
        QP = QPptr[(x + qp_index * BLOCK_SIZE) >> qpHShift];
        nonBQP = nonBQPptr[(x + qp_index * BLOCK_SIZE) >> qpHShift];
        if (!isColor) {
          QP = (QP * QPCorrecture + 256 * 128) >> 16;
          nonBQP = (nonBQP * QPCorrecture + 256 * 128) >> 16;
          yHistogram[(srcBlock + qp_index * 8)[srcStride * 12 + 4]]++;
        }
        c.QP_block[qp_index] = QP;
        c.nonBQP_block[qp_index] = nonBQP;
#if TEMPLATE_PP_MMX
        __asm__ volatile(""movd %1, %%mm7         \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""movq %%mm7, %0         \n\t""
                         : ""=m""(c.pQPb_block[qp_index])
                         : ""r""(QP));
#endif
      }
      for (; x < endx; x += BLOCK_SIZE) {
        RENAME(prefetchnta)
        (srcBlock + (((x >> 2) & 6) + copyAhead) * srcStride + 32);
        RENAME(prefetchnta)
        (srcBlock + (((x >> 2) & 6) + copyAhead + 1) * srcStride + 32);
        RENAME(prefetcht0)
        (dstBlock + (((x >> 2) & 6) + copyAhead) * dstStride + 32);
        RENAME(prefetcht0)
        (dstBlock + (((x >> 2) & 6) + copyAhead + 1) * dstStride + 32);

        RENAME(blockCopy)
        (dstBlock + dstStride * copyAhead, dstStride,
         srcBlock + srcStride * copyAhead, srcStride, mode & LEVEL_FIX,
         &c.packedYOffset);

        if (mode & LINEAR_IPOL_DEINT_FILTER)
          RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
        else if (mode & LINEAR_BLEND_DEINT_FILTER)
          RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
        else if (mode & MEDIAN_DEINT_FILTER)
          RENAME(deInterlaceMedian)(dstBlock, dstStride);
        else if (mode & CUBIC_IPOL_DEINT_FILTER)
          RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
        else if (mode & FFMPEG_DEINT_FILTER)
          RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
        else if (mode & LOWPASS5_DEINT_FILTER)
          RENAME(deInterlaceL5)
          (dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);

        dstBlock += 8;
        srcBlock += 8;
      }

      dstBlock = dstBlockStart;
      srcBlock = srcBlockStart;

      for (x = startx, qp_index = 0; x < endx; x += BLOCK_SIZE, qp_index++) {
        const int stride = dstStride;

        c.QP = c.QP_block[qp_index];
        c.nonBQP = c.nonBQP_block[qp_index];
        c.pQPb = c.pQPb_block[qp_index];
        c.pQPb2 = c.pQPb2_block[qp_index];

        if (y + 8 < height) {
          if (mode & V_X1_FILTER)
            RENAME(vertX1Filter)(dstBlock, stride, &c);
          else if (mode & V_DEBLOCK) {
            const int t = RENAME(vertClassify)(dstBlock, stride, &c);

            if (t == 1)
              RENAME(doVertLowPass)(dstBlock, stride, &c);
            else if (t == 2)
              RENAME(doVertDefFilter)(dstBlock, stride, &c);
          } else if (mode & V_A_DEBLOCK) {
            RENAME(do_a_deblock)(dstBlock, stride, 1, &c, mode);
          }
        }

        dstBlock += 8;
        srcBlock += 8;
      }

      dstBlock = dstBlockStart;
      srcBlock = srcBlockStart;

      for (x = startx, qp_index = 0; x < endx; x += BLOCK_SIZE, qp_index++) {
        const int stride = dstStride;
        av_unused uint8_t *tmpXchg;
        c.QP = c.QP_block[qp_index];
        c.nonBQP = c.nonBQP_block[qp_index];
        c.pQPb = c.pQPb_block[qp_index];
        c.pQPb2 = c.pQPb2_block[qp_index];
#if TEMPLATE_PP_MMX
        RENAME(transpose1)(tempBlock1, tempBlock2, dstBlock, dstStride);
#endif

        if (x - 8 >= 0) {
#if TEMPLATE_PP_MMX
          if (mode & H_X1_FILTER)
            RENAME(vertX1Filter)(tempBlock1, 16, &c);
          else if (mode & H_DEBLOCK) {
            const int t = RENAME(vertClassify)(tempBlock1, 16, &c);
            if (t == 1)
              RENAME(doVertLowPass)(tempBlock1, 16, &c);
            else if (t == 2)
              RENAME(doVertDefFilter)(tempBlock1, 16, &c);
          } else if (mode & H_A_DEBLOCK) {
            RENAME(do_a_deblock)(tempBlock1, 16, 1, &c, mode);
          }

          RENAME(transpose2)(dstBlock - 4, dstStride, tempBlock1 + 4 * 16);

#else
          if (mode & H_X1_FILTER)
            horizX1Filter(dstBlock - 4, stride, c.QP);
          else if (mode & H_DEBLOCK) {
#if TEMPLATE_PP_ALTIVEC
            DECLARE_ALIGNED(16, unsigned char, tempBlock)[272];
            int t;
            transpose_16x8_char_toPackedAlign_altivec(
                tempBlock, dstBlock - (4 + 1), stride);

            t = vertClassify_altivec(tempBlock - 48, 16, &c);
            if (t == 1) {
              doVertLowPass_altivec(tempBlock - 48, 16, &c);
              transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1),
                                                          tempBlock, stride);
            } else if (t == 2) {
              doVertDefFilter_altivec(tempBlock - 48, 16, &c);
              transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1),
                                                          tempBlock, stride);
            }
#else
            const int t = RENAME(horizClassify)(dstBlock - 4, stride, &c);

            if (t == 1)
              RENAME(doHorizLowPass)(dstBlock - 4, stride, &c);
            else if (t == 2)
              RENAME(doHorizDefFilter)(dstBlock - 4, stride, &c);
#endif
          } else if (mode & H_A_DEBLOCK) {
            RENAME(do_a_deblock)(dstBlock - 8, 1, stride, &c, mode);
          }
#endif
          if (mode & DERING) {

            if (y > 0)
              RENAME(dering)(dstBlock - stride - 8, stride, &c);
          }

          if (mode & TEMP_NOISE_FILTER) {
            RENAME(tempNoiseReducer)
            (dstBlock - 8, stride, c.tempBlurred[isColor] + y * dstStride + x,
             c.tempBlurredPast[isColor] + (y >> 3) * 256 + (x >> 3) + 256,
             c.ppMode.maxTmpNoise);
          }
        }

        dstBlock += 8;
        srcBlock += 8;

#if TEMPLATE_PP_MMX
        tmpXchg = tempBlock1;
        tempBlock1 = tempBlock2;
        tempBlock2 = tmpXchg;
#endif
      }
    }

    if (mode & DERING) {
      if (y > 0)
        RENAME(dering)(dstBlock - dstStride - 8, dstStride, &c);
    }

    if ((mode & TEMP_NOISE_FILTER)) {
      RENAME(tempNoiseReducer)
      (dstBlock - 8, dstStride, c.tempBlurred[isColor] + y * dstStride + x,
       c.tempBlurredPast[isColor] + (y >> 3) * 256 + (x >> 3) + 256,
       c.ppMode.maxTmpNoise);
    }

    if (y + 15 >= height) {
      uint8_t *dstBlock = &(dst[y * dstStride]);
      if (width == FFABS(dstStride))
        linecpy(dstBlock, tempDst + dstStride, height - y, dstStride);
      else {
        int i;
        for (i = 0; i < height - y; i++) {
          memcpy(dstBlock + i * dstStride, tempDst + (i + 1) * dstStride,
                 width);
        }
      }
    }
  }
#if TEMPLATE_PP_3DNOW
  __asm__ volatile(""femms"");
#elif TEMPLATE_PP_MMX
  __asm__ volatile(""emms"");
#endif

#ifdef DEBUG_BRIGHTNESS
  if (!isColor) {
    int max = 1;
    int i;
    for (i = 0; i < 256; i++)
      if (yHistogram[i] > max)
        max = yHistogram[i];

    for (i = 1; i < 256; i++) {
      int x;
      int start = yHistogram[i - 1] / (max / 256 + 1);
      int end = yHistogram[i] / (max / 256 + 1);
      int inc = end > start ? 1 : -1;
      for (x = start; x != end + inc; x += inc)
        dst[i * dstStride + x] += 128;
    }

    for (i = 0; i < 100; i += 2) {
      dst[(white)*dstStride + i] += 128;
      dst[(black)*dstStride + i] += 128;
    }
  }
#endif

  *c2 = c;
}"
dirk-hivm-bdead2e/src/jit-compiler.c	Set up a bailout from the current JIT state back to the normal VM state at the given instruction address; execution will resume at that address in the VM.	2	"LLVMBasicBlockRef hvm_jit_build_bailout_block(hvm_vm *vm,
                                              LLVMBuilderRef builder,
                                              LLVMValueRef parent_func,
                                              LLVMValueRef exit_value,
                                              void *void_context, uint64_t ip) {

  struct hvm_jit_compile_context *context = void_context;
  hvm_compile_bundle *bundle = context->bundle;

  LLVMBasicBlockRef basic_block =
      LLVMAppendBasicBlockInContext(hvm_shared_llvm_context, parent_func, NULL);
  LLVMPositionBuilderAtEnd(builder, basic_block);

  hvm_obj_ref **general_regs = vm->general_regs;

  LLVMValueRef general_regs_ptr =
      LLVMConstInt(pointer_type, (unsigned long long)general_regs, false);

  for (byte i = 0; i < HVM_GENERAL_REGISTERS; i++) {
    LLVMValueRef value_ptr = context->general_regs[i];
    if (value_ptr == NULL) {

      continue;
    }
    LLVMValueRef value = hvm_jit_load_general_reg_value(context, builder, i);
    LLVMValueRef idx_val = LLVMConstInt(int32_type, i, true);

    LLVMValueRef reg_ptr = LLVMBuildGEP(builder, general_regs_ptr,
                                        (LLVMValueRef[]){idx_val}, 1, NULL);

    LLVMBuildStore(builder, value, reg_ptr);
  }

  LLVMValueRef func = hvm_jit_set_local_llvm_value(bundle);

  LLVMValueRef frame_ptr =
      LLVMConstInt(int64_type, (unsigned long long)(bundle->frame), false);
  frame_ptr = LLVMBuildIntToPtr(builder, frame_ptr, pointer_type, ""frame"");
  hvm_obj_struct *locals = context->locals;

  for (unsigned int i = 0; i < locals->heap_length; i++) {
    hvm_obj_struct_heap_pair *pair = locals->heap[i];
    hvm_symbol_id sym = pair->id;
    void *slot = pair->obj;

    char *symbol_name = hvm_desymbolicate(context->vm->symbols, sym);
    LLVMValueRef value = hvm_jit_load_slot(builder, slot, symbol_name);

    LLVMValueRef value_symbol = LLVMConstInt(int64_type, sym, false);

    LLVMValueRef args[] = {frame_ptr, value_symbol, value};
    LLVMBuildCall(builder, func, args, 3, """");
  }

  hvm_jit_build_bailout_return_to_ip(builder, exit_value, ip);

  return basic_block;
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavfilter/src_movie.c	Try to push a frame to the requested output.	2	"static int movie_push_frame(AVFilterContext *ctx, unsigned out_id) {
  MovieContext *movie = ctx->priv;
  AVPacket *pkt = &movie->pkt;
  enum AVMediaType frame_type;
  MovieStream *st;
  int ret, got_frame = 0, pkt_out_id;
  AVFilterLink *outlink;
  AVFrame *frame;

  if (!pkt->size) {
    if (movie->eof) {
      if (movie->st[out_id].done) {
        if (movie->loop_count != 1) {
          ret = rewind_file(ctx);
          if (ret < 0)
            return ret;
          movie->loop_count -= movie->loop_count > 1;
          av_log(ctx, AV_LOG_VERBOSE, ""Stream finished, looping.\n"");
          return 0;
        }
        return AVERROR_EOF;
      }
      pkt->stream_index = movie->st[out_id].st->index;

    } else {
      ret = av_read_frame(movie->format_ctx, &movie->pkt0);
      if (ret < 0) {
        av_init_packet(&movie->pkt0);
        *pkt = movie->pkt0;
        if (ret == AVERROR_EOF) {
          movie->eof = 1;
          return 0;
        }
        return ret;
      }
      *pkt = movie->pkt0;
    }
  }

  pkt_out_id = pkt->stream_index > movie->max_stream_index
                   ? -1
                   : movie->out_index[pkt->stream_index];
  if (pkt_out_id < 0) {
    av_free_packet(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
    return 0;
  }
  st = &movie->st[pkt_out_id];
  outlink = ctx->outputs[pkt_out_id];

  frame = av_frame_alloc();
  if (!frame)
    return AVERROR(ENOMEM);

  frame_type = st->st->codec->codec_type;
  switch (frame_type) {
  case AVMEDIA_TYPE_VIDEO:
    ret = avcodec_decode_video2(st->st->codec, frame, &got_frame, pkt);
    break;
  case AVMEDIA_TYPE_AUDIO:
    ret = avcodec_decode_audio4(st->st->codec, frame, &got_frame, pkt);
    break;
  default:
    ret = AVERROR(ENOSYS);
    break;
  }
  if (ret < 0) {
    av_log(ctx, AV_LOG_WARNING, ""Decode error: %s\n"", av_err2str(ret));
    av_frame_free(&frame);
    av_free_packet(&movie->pkt0);
    movie->pkt.size = 0;
    movie->pkt.data = NULL;
    return 0;
  }
  if (!ret || st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
    ret = pkt->size;

  pkt->data += ret;
  pkt->size -= ret;
  if (pkt->size <= 0) {
    av_free_packet(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
  }
  if (!got_frame) {
    if (!ret)
      st->done = 1;
    av_frame_free(&frame);
    return 0;
  }

  frame->pts = av_frame_get_best_effort_timestamp(frame);
  av_dlog(
      ctx, ""movie_push_frame(): file:'%s' %s\n"", movie->file_name,
      describe_frame_to_str((char[1024]){0}, 1024, frame, frame_type, outlink));

  if (st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
    if (frame->format != outlink->format) {
      av_log(ctx, AV_LOG_ERROR, ""Format changed %s -> %s, discarding frame\n"",
             av_get_pix_fmt_name(outlink->format),
             av_get_pix_fmt_name(frame->format));
      av_frame_free(&frame);
      return 0;
    }
  }
  ret = ff_filter_frame(outlink, frame);

  if (ret < 0)
    return ret;
  return pkt_out_id == out_id;
}"
opticron-libuweave-2e5e385/src/macaroon_helpers.c	Mint an initial client authorization token (CAT).	2	"bool uw_macaroon_mint_client_authorization_token_(
    const uint8_t *root_key, size_t root_key_len, const uint8_t *token_str,
    size_t token_str_len, uint32_t current_time,
    UwMacaroonCaveatCloudServiceId service_id, uint8_t *buffer,
    size_t buffer_size, UwMacaroon *new_macaroon) {
  if (root_key == NULL || root_key_len == 0 || buffer == NULL ||
      buffer_size == 0 || new_macaroon == NULL) {
    return false;
  }
  if (token_str == NULL && token_str_len != 0) {
    return false;
  }

  *new_macaroon = (UwMacaroon){};

  const size_t num_caveats = 3;
  UwMacaroonCaveat **caveat_list =
      allocate_caveat_list_(num_caveats, &buffer, &buffer_size);
  if (caveat_list == NULL) {
    return false;
  }

  size_t needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeClientAuthorizationTokenV1, token_str_len);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_client_authorization_token_(
          token_str, token_str_len, buffer, needed_buffer_size,
          caveat_list[0])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeDelegationTimestamp, 0);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_delegation_timestamp_(
          current_time, buffer, needed_buffer_size, caveat_list[1])) {
    return false;
  }
  buffer += needed_buffer_size;
  buffer_size -= needed_buffer_size;

  needed_buffer_size = uw_macaroon_caveat_creation_get_buffsize_(
      kUwMacaroonCaveatTypeDelegateeService, 0);
  if ((needed_buffer_size == 0) || (needed_buffer_size > buffer_size) ||
      !uw_macaroon_caveat_create_delegatee_service_(
          service_id, buffer, needed_buffer_size, caveat_list[2])) {
    return false;
  }

  UwMacaroonContext context = {};
  return uw_macaroon_create_from_root_key_(
      new_macaroon, root_key, root_key_len, &context,
      (const UwMacaroonCaveat *const *)caveat_list, num_caveats);
}"
SanderMertens-flecs-f50e6b1/src/system.c	Run system on a single row	2	"bool ecs_notify_row_system(EcsWorld *world, EcsEntity system, EcsArray *type,
                           EcsTableColumn *table_columns, uint32_t offset,
                           uint32_t limit) {
  EcsRowSystem *system_data = ecs_get_ptr(world, system, EcsRowSystem);
  assert(system_data != NULL);

  if (!system_data->base.enabled) {
    return false;
  }

  EcsSystemAction action = system_data->base.action;

  uint32_t i, column_count = ecs_array_count(system_data->base.columns);
  EcsSystemColumn *buffer = ecs_array_buffer(system_data->base.columns);
  int32_t columns[column_count];
  EcsReference references[column_count];
  void *ref_ptrs[column_count];
  uint32_t ref_id = 0;

  for (i = 0; i < column_count; i++) {
    if (buffer[i].kind == EcsFromSelf) {
      columns[i] = ecs_type_index_of(type, buffer[i].is.component) + 1;
    } else {
      EcsEntity entity = 0;
      EcsType component = ecs_type_from_entity(world, buffer[i].is.component);
      ;

      if (buffer[i].kind == EcsFromSystem) {
        entity = system;
      } else if (buffer[i].kind == EcsFromSingleton) {
        entity = 0;
      } else if (buffer[i].kind == EcsFromEntity) {
        entity = buffer[i].source;
      }

      references[ref_id] =
          (EcsReference){.entity = entity, .component = component};
      ref_ptrs[ref_id] = _ecs_get_ptr(world, entity, component);

      ref_id++;
      columns[i] = -ref_id;
    }
  }

  EcsRows rows = {.world = world,
                  .system = system,
                  .columns = columns,
                  .column_count = ecs_array_count(system_data->components),
                  .references = references,
                  .table_columns = table_columns,
                  .components = ecs_array_buffer(system_data->components),
                  .index_offset = 0,
                  .begin = offset,
                  .end = offset + limit,
                  .count = limit};

  if (ref_id) {
    rows.references = references;
    rows.ref_ptrs = ref_ptrs;
  }

  if (table_columns) {
    rows.entities = ecs_array_buffer(table_columns[0].data);
  }

  action(&rows);

  return true;
}"
Airblader-xedgewarp-1695e18/src/pointer.c	Takes the given position and transforms it to the position it should have when warped from one output to the other.	2	"position_t pointer_transform_position(position_t pointer, Output *from,
                                      Output *to, direction_t direction) {
  switch (config.warp_mode) {
  case WM_CLOSEST:
    return pointer_transform_position_closest(pointer, from, to, direction);
  case WM_RELATIVE:
    return pointer_transform_position_relative(pointer, from, to, direction);
  default:
    bail(""Unhandled warp mode, bailing out."");

    return (position_t){.x = 0, .y = 0};
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_epi16(short __w15, short __w14, short __w13, short __w12,
                  short __w11, short __w10, short __w09, short __w08,
                  short __w07, short __w06, short __w05, short __w04,
                  short __w03, short __w02, short __w01, short __w00) {
  return (__m256i)(__v16hi){__w15, __w14, __w13, __w12, __w11, __w10,
                            __w09, __w08, __w07, __w06, __w05, __w04,
                            __w03, __w02, __w01, __w00};
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	"Constructs a quaternion from a four-element vector. Note that the imaginary (vector) part of the quaternion comes from lanes 0, 1, and 2 of the vector, and the real (scalar) part comes from lane 3."	2	"static inline SIMD_CFUNC simd_quatf simd_quaternion(simd_float4 xyzr) {
  return (simd_quatf){xyzr};
}"
EvolBioInf-andi-e92b453/src/esa.c	"Given an ESA and a string Q find the longest prefix of Q that matches somewhere in C. This search is done entirely via jumping around in the ESA, and thus is slow."	2	"lcp_inter_t get_match(const esa_s *C, const char *query, size_t qlen) {

  if (!C || !query || !C->len || !C->SA || !C->LCP || !C->S || !C->CLD) {
    return (lcp_inter_t){-1, -1, -1, -1};
  }

  saidx_t m = L(C->CLD, C->len);
  lcp_inter_t ij = {.i = 0, .j = C->len - 1, .m = m, .l = C->LCP[m]};

  return get_match_from(C, query, qlen, 0, ij);
}"
boazsegev-iodine-b6bdf50/ext/iodine/http.c	Connects to an HTTP server as a client.	1	"intptr_t http_connect FIO_IGNORE_MACRO(const char *url,
                                       const char *unix_address,
                                       struct http_settings_s arg_settings) {
  if (!arg_settings.on_response && !arg_settings.on_upgrade) {
    FIO_LOG_ERROR(""http_connect requires either an on_response ""
                  "" or an on_upgrade callback.\n"");
    errno = EINVAL;
    goto on_error;
  }
  size_t len = 0, h_len = 0;
  char *a = NULL, *p = NULL, *host = NULL;
  uint8_t is_websocket = 0;
  uint8_t is_secure = 0;
  FIOBJ path = FIOBJ_INVALID;
  if (!url && !unix_address) {
    FIO_LOG_ERROR(""http_connect requires a valid address."");
    errno = EINVAL;
    goto on_error;
  }
  if (url) {
    fio_url_s u = fio_url_parse(url, strlen(url));
    if (u.scheme.data &&
        (u.scheme.len == 2 || (u.scheme.len == 3 && u.scheme.data[2] == 's')) &&
        u.scheme.data[0] == 'w' && u.scheme.data[1] == 's') {
      is_websocket = 1;
      is_secure = (u.scheme.len == 3);
    } else if (u.scheme.data &&
               (u.scheme.len == 4 ||
                (u.scheme.len == 5 && u.scheme.data[4] == 's')) &&
               u.scheme.data[0] == 'h' && u.scheme.data[1] == 't' &&
               u.scheme.data[2] == 't' && u.scheme.data[3] == 'p') {
      is_secure = (u.scheme.len == 5);
    }
    if (is_secure && !arg_settings.tls) {
      FIO_LOG_ERROR(""Secure connections (%.*s) require a TLS object."",
                    (int)u.scheme.len, u.scheme.data);
      errno = EINVAL;
      goto on_error;
    }
    if (u.path.data) {
      path = fiobj_str_new(u.path.data, strlen(u.path.data));
    }
    if (unix_address) {
      a = (char *)unix_address;
      h_len = len = strlen(a);
      host = a;
    } else {
      if (!u.host.data) {
        FIO_LOG_ERROR(""http_connect requires a valid address."");
        errno = EINVAL;
        goto on_error;
      }

      a = fio_malloc(u.host.len + 1);
      memcpy(a, u.host.data, u.host.len);
      a[u.host.len] = 0;
      len = u.host.len;

      if (u.port.data) {
        p = fio_malloc(u.port.len + 1);
        memcpy(p, u.port.data, u.port.len);
        p[u.port.len] = 0;
      } else if (is_secure) {
        p = fio_malloc(3 + 1);
        memcpy(p, ""443"", 3);
        p[3] = 0;
      } else {
        p = fio_malloc(2 + 1);
        memcpy(p, ""80"", 2);
        p[2] = 0;
      }
    }
    if (u.host.data) {
      host = u.host.data;
      h_len = u.host.len;
    }
  }

  if (!arg_settings.timeout)
    arg_settings.timeout = 30;
  http_settings_s *settings = http_settings_new(arg_settings);
  settings->is_client = 1;

  if (!arg_settings.ws_timeout)
    settings->ws_timeout = 0;
  if (!arg_settings.timeout)
    settings->timeout = 0;
  http_s *h = fio_malloc(sizeof(*h));
  FIO_ASSERT(h, ""HTTP Client handler allocation failed"");
  http_s_new(h, 0, http1_vtable());
  h->udata = arg_settings.udata;
  h->status = 0;
  h->path = path;
  settings->udata = h;
  settings->tls = arg_settings.tls;
  if (host)
    http_set_header2(h, (fio_str_info_s){.data = (char *)""host"", .len = 4},
                     (fio_str_info_s){.data = host, .len = h_len});
  intptr_t ret;
  if (is_websocket) {

    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,
                      .on_connect = http_on_open_client, .udata = settings,
                      .tls = arg_settings.tls);
    (void)0;
  } else {

    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,
                      .on_connect = http_on_open_client, .udata = settings,
                      .tls = arg_settings.tls);
    (void)0;
  }
  if (a != unix_address)
    fio_free(a);
  fio_free(p);
  return ret;
on_error:
  if (arg_settings.on_finish)
    arg_settings.on_finish(&arg_settings);
  return -1;
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavformat/utils.c	Return the frame duration in seconds. Return 0 if not available.	2	"void ff_compute_frame_duration(AVFormatContext *s, int *pnum, int *pden,
                               AVStream *st, AVCodecParserContext *pc,
                               AVPacket *pkt) {
  AVRational codec_framerate =
      s->iformat ? st->internal->avctx->framerate : (AVRational){0, 1};
  int frame_size;

  *pnum = 0;
  *pden = 0;
  switch (st->codecpar->codec_type) {
  case AVMEDIA_TYPE_VIDEO:
    if (st->avg_frame_rate.num) {
      *pnum = st->avg_frame_rate.den;
      *pden = st->avg_frame_rate.num;
    } else if (st->time_base.num * 1000LL > st->time_base.den) {
      *pnum = st->time_base.num;
      *pden = st->time_base.den;
    } else if (codec_framerate.den * 1000LL > codec_framerate.num) {
      *pnum = codec_framerate.den;
      *pden = codec_framerate.num;
      if (pc && pc->repeat_pict) {
        if (*pnum > INT_MAX / (1 + pc->repeat_pict))
          *pden /= 1 + pc->repeat_pict;
        else
          *pnum *= 1 + pc->repeat_pict;
      }

      if (st->internal->avctx->ticks_per_frame > 1 && !pc)
        *pnum = *pden = 0;
    }
    break;
  case AVMEDIA_TYPE_AUDIO:
    frame_size = av_get_audio_frame_duration2(st->codecpar, pkt->size);
    if (frame_size <= 0 || st->codecpar->sample_rate <= 0)
      break;
    *pnum = frame_size;
    *pden = st->codecpar->sample_rate;
    break;
  default:
    break;
  }
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Subscribes to a filter, pub/sub channle or patten"	2	"subscription_s *fio_subscribe FIO_IGNORE_MACRO(subscribe_args_s args) {
  if (!args.on_message)
    goto error;
  channel_s *ch;
  subscription_s *s = fio_malloc(sizeof(*s));
  FIO_ASSERT_ALLOC(s);
  *s = (subscription_s){
      .on_message = args.on_message,
      .on_unsubscribe = args.on_unsubscribe,
      .udata1 = args.udata1,
      .udata2 = args.udata2,
      .ref = 1,
      .lock = FIO_LOCK_INIT,
  };
  if (args.filter) {
    ch = fio_filter_dup_lock(args.filter);
  } else if (args.match) {
    ch = fio_channel_match_dup_lock(args.channel, args.match);
  } else {
    ch = fio_channel_dup_lock(args.channel);
  }
  s->parent = ch;
  fio_ls_embd_push(&ch->subscriptions, &s->node);
  fio_unlock((&ch->lock));
  return s;
error:
  if (args.on_unsubscribe)
    args.on_unsubscribe(args.udata1, args.udata2);
  return NULL;
}"
NVIDIA-AI-IOT-deepstream_reference_apps-3a8957b/yolo/plugins/gst-yoloplugin-tesla/gstyoloplugin.cpp	Attach metadata for the full frame. We will be adding a new metadata.	2	"attach_metadata_full_frame(GstYoloPlugin *yoloplugin, GstBuffer *inbuf,
                           gdouble scale_ratio, YoloPluginOutput *output,
                           guint batch_id) {
  NvDsMeta *dsmeta;
  NvDsFrameMeta *bbparams = (NvDsFrameMeta *)g_malloc0(sizeof(NvDsFrameMeta));

  bbparams->obj_params = (NvDsObjectParams *)g_malloc0(
      sizeof(NvDsObjectParams) * output->numObjects);

  bbparams->gie_type = 3;

  bbparams->nvosd_mode = NV_OSD_MODE_GPU;
  bbparams->batch_id = batch_id;

  static gchar font_name[] = ""Arial"";
  GST_DEBUG_OBJECT(yoloplugin, ""Attaching metadata %d\n"", output->numObjects);
  for (gint i = 0; i < output->numObjects; i++) {
    YoloPluginObject *obj = &output->object[i];
    NvDsObjectParams *obj_param = &bbparams->obj_params[i];
    NvOSD_RectParams &rect_params = obj_param->rect_params;
    NvOSD_TextParams &text_params = obj_param->text_params;

    rect_params.left = obj->left;
    rect_params.top = obj->top;
    rect_params.width = obj->width;
    rect_params.height = obj->height;

    rect_params.has_bg_color = 0;
    rect_params.bg_color = (NvOSD_ColorParams){1, 1, 0, 0.4};

    rect_params.border_width = 1;
    rect_params.border_color = (NvOSD_ColorParams){1, 0, 0, 1};

    rect_params.left /= scale_ratio;
    rect_params.top /= scale_ratio;
    rect_params.width /= scale_ratio;
    rect_params.height /= scale_ratio;
    GST_DEBUG_OBJECT(yoloplugin,
                     ""Attaching rect%d of batch%u""
                     ""  left->%u top->%u width->%u""
                     "" height->%u label->%s\n"",
                     i, batch_id, rect_params.left, rect_params.top,
                     rect_params.width, rect_params.height, obj->label);
    bbparams->num_rects++;

    obj_param->has_new_info = TRUE;

    strcpy(obj_param->attr_info[yoloplugin->unique_id].attr_label, obj->label);

    obj_param->attr_info[yoloplugin->unique_id].is_attr_label = 1;

    obj_param->tracking_id = -1;

    text_params.display_text = g_strdup(obj->label);

    text_params.x_offset = rect_params.left;
    text_params.y_offset = rect_params.top - 10;

    text_params.set_bg_clr = 1;
    text_params.text_bg_clr = (NvOSD_ColorParams){0, 0, 0, 1};

    text_params.font_params.font_name = font_name;
    text_params.font_params.font_size = 11;
    text_params.font_params.font_color = (NvOSD_ColorParams){1, 1, 1, 1};
    bbparams->num_strings++;
  }

  dsmeta = gst_buffer_add_nvds_meta(inbuf, bbparams, free_ds_meta);
  dsmeta->meta_type = NVDS_META_FRAME_INFO;
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];

    if (!link)
      continue;
    if (!link->src || !link->dst) {
      av_log(filter, AV_LOG_ERROR,
             ""Not all input and output are properly linked (%d).\n"", i);
      return AVERROR(EINVAL);
    }

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      if (link->time_base.num == 0 && link->time_base.den == 0)
        link->time_base = link->src->nb_inputs ? link->src->inputs[0]->time_base
                                               : AV_TIME_BASE_Q;

      if (link->type == AVMEDIA_TYPE_VIDEO) {
        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              link->src->nb_inputs ? link->src->inputs[0]->sample_aspect_ratio
                                   : (AVRational){1, 1};

        if (link->src->nb_inputs) {
          if (!link->frame_rate.num && !link->frame_rate.den)
            link->frame_rate = link->src->inputs[0]->frame_rate;
          if (!link->w)
            link->w = link->src->inputs[0]->w;
          if (!link->h)
            link->h = link->src->inputs[0]->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
      }

      if (link->src->nb_inputs && link->src->inputs[0]->hw_frames_ctx &&
          !link->hw_frames_ctx) {
        AVHWFramesContext *input_ctx =
            (AVHWFramesContext *)link->src->inputs[0]->hw_frames_ctx->data;

        if (input_ctx->format == link->format) {
          link->hw_frames_ctx =
              av_buffer_ref(link->src->inputs[0]->hw_frames_ctx);
          if (!link->hw_frames_ctx)
            return AVERROR(ENOMEM);
        }
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/ints.c	Allocates new integer with 1B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int8() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 1);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_8}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
mike-johnson-jr-pymedia-redux-full-9fcee96/audio/libavcodec/golomb.h	write unsigned exp golomb code.	2	"static inline void set_ue_golomb(PutBitContext *pb, int i) {
  int e;

  assert(i >= 0);

#if 0
    if(i=0){
        put_bits(pb, 1, 1);
        return;
    }
#endif
  if (i < 256)
    put_bits(pb, ff_ue_golomb_len[i], i + 1);
  else {
    e = av_log2(i + 1);

    put_bits(pb, 2 * e + 1, i + 1);
  }
}"
i-rinat-apulse-bcd55c8/src/apulse-mainloop-glib.c	Create a new GLIB main loop object for the specified GLIB main loop context. Takes an argument c for the GMainContext to use. If c is NULL the default context is used.	2	"pa_glib_mainloop_new(GMainContext *c) {
  trace_info_z(""Z %s c=%p\n"", __func__, c);

  pa_glib_mainloop *m = g_malloc0(sizeof(pa_glib_mainloop));

  m->api = (pa_mainloop_api){
      .userdata = m,
      .io_new = gml_api_io_new,
      .io_enable = gml_api_io_enable,
      .io_free = gml_api_io_free,
      .io_set_destroy = gml_api_io_set_destroy,
      .time_new = gml_api_time_new,
      .time_restart = gml_api_time_restart,
      .time_free = gml_api_time_free,
      .time_set_destroy = gml_api_time_set_destroy,
      .defer_new = gml_api_defer_new,
      .defer_enable = gml_api_defer_enable,
      .defer_free = gml_api_defer_free,
      .defer_set_destroy = gml_api_defer_set_destroy,
      .quit = gml_api_quit,
  };

  return m;
}"
rampantpixels-foundation_lib-ffe3b47/foundation/string.c	"Replace all occurrences of the given key string inside the given string, optionally repeating the replace after an occurrence have been replaced. If repeat is set to false, the newly replaced part of the string is not rechecked for replacement. The repeat is recursion safe and will not endlessly loop, like repeat replacing ""foo"" with ""foobar"". The string will not be reallocated, replacement will continue in a best effort way until the capacity of the string buffer is reached."	2	"string_replace(char *str, size_t length, size_t capacity, const char *key,
               size_t key_length, const char *newkey, size_t newkey_length,
               bool repeat) {
  size_t pos, oldlength, lastpos, replaced, needsize;
  ssize_t lendiff;

  FOUNDATION_ASSERT(length <= capacity);
  if (!capacity || !length || !key_length)
    return (string_t){str, length};

  oldlength = length;
  lastpos = STRING_NPOS;
  lendiff = (ssize_t)newkey_length - (ssize_t)key_length;
  pos = 0;
  replaced = 0;

  while ((pos = string_find_string(str, length, key, key_length, pos)) !=
         STRING_NPOS) {

    if (repeat && (lastpos != STRING_NPOS) && (lendiff > 0) &&
        (pos <= (lastpos + (size_t)lendiff))) {

      pos = lastpos + newkey_length;
      continue;
    }

    ++replaced;

    if (lendiff <= 0) {

      memcpy(str + pos, newkey, newkey_length);
      if (lendiff < 0) {
        memmove(str + pos + newkey_length, str + pos + key_length,
                (length - (pos + key_length)) + 1);
        FOUNDATION_ASSERT(length >= (size_t)(-lendiff));
        length -= (size_t)(-lendiff);
      }
    } else {
      needsize = length + (size_t)lendiff + 1;
      if (needsize > capacity) {

        size_t dest_clamp = pos + newkey_length;
        if (dest_clamp < capacity) {
          size_t size_clamp = (length - (pos + key_length)) + 1;
          if (dest_clamp + size_clamp >= capacity)
            size_clamp = capacity - (dest_clamp + 1);
          if (size_clamp > 0)
            memmove(str + dest_clamp, str + pos + key_length, size_clamp);
          memcpy(str + pos, newkey, newkey_length);
          length = capacity - 1;
        } else {
          size_t size_clamp = capacity - pos;
          if (size_clamp > 0)
            memcpy(str + pos, newkey, size_clamp);
        }
      } else {
        memmove(str + pos + newkey_length, str + pos + key_length,
                (length - (pos + key_length)) + 1);
        memcpy(str + pos, newkey, newkey_length);
        length += (size_t)lendiff;
      }
    }

    lastpos = pos;
    if (!repeat)
      pos += newkey_length;
  }

  if (replaced && (length != oldlength))
    str[length] = 0;

  return (string_t){str, length};
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/PrinterHost/PrinterHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to send some test page data to the attached printer."	1	"void USB_Printer_Host(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if (PrinterAltSetting) {
      USB_ControlRequest = (USB_Request_Header_t){
          .bmRequestType =
              (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_INTERFACE),
          .bRequest = REQ_SetInterface,
          .wValue = PrinterAltSetting,
          .wIndex = PrinterInterfaceNumber,
          .wLength = 0,
      };

      if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
          HOST_SENDCONTROL_Successful) {
        printf_P(PSTR(ESC_FG_RED ""Control Error (Set Interface).\r\n""
                                 "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
                 ErrorCode);

        LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

        USB_HostState = HOST_STATE_WaitForDeviceRemoval;
        break;
      }
    }

    puts_P(PSTR(""Retrieving Device ID...\r\n""));

    char DeviceIDString[300];
    if ((ErrorCode =
             Printer_GetDeviceID(DeviceIDString, sizeof(DeviceIDString))) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Get Device ID).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    printf_P(PSTR(""Printer Device ID: %s\r\n""), DeviceIDString);

    puts_P(PSTR(""Printer Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

    char TestPageData[] = ""\033%-12345X\033E""
                          ""LUFA PCL Test Page""
                          ""\033E\033%-12345X"";
    uint16_t TestPageLength = strlen(TestPageData);

    printf_P(PSTR(""Sending Test Page (%d bytes)...\r\n""), TestPageLength);

    if ((ErrorCode = Printer_SendData(&TestPageData, TestPageLength)) !=
        PIPE_RWSTREAM_NoError) {
      printf_P(PSTR(ESC_FG_RED ""Error Sending Test Page.\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Test Page Sent.\r\n""));

    LEDs_SetAllLEDs(LEDMASK_USB_READY);

    USB_HostState = HOST_STATE_WaitForDeviceRemoval;
    break;
  }
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/ClassDriver/MIDIHost/MIDIHost.c	"Checks for movement of the board's joystick, and sends corresponding MIDI note on/off messages to the host."	2	"void CheckJoystickMovement(void) {
  static uint8_t PrevJoystickStatus;

  uint8_t MIDICommand = 0;
  uint8_t MIDIPitch;

  uint8_t JoystickStatus = Joystick_GetStatus();
  uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

  uint8_t Channel = ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                             : MIDI_CHANNEL(1));

  if (JoystickChanges & JOY_LEFT) {
    MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3C;
  } else if (JoystickChanges & JOY_UP) {
    MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                             : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3D;
  } else if (JoystickChanges & JOY_RIGHT) {
    MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3E;
  } else if (JoystickChanges & JOY_DOWN) {
    MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3F;
  } else if (JoystickChanges & JOY_PRESS) {
    MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3B;
  }

  if (MIDICommand) {
    MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
        .Event = MIDI_EVENT(0, MIDICommand),

        .Data1 = MIDICommand | Channel,
        .Data2 = MIDIPitch,
        .Data3 = MIDI_STANDARD_VELOCITY,
    };

    MIDI_Host_SendEventPacket(&Keyboard_MIDI_Interface, &MIDIEvent);
    MIDI_Host_Flush(&Keyboard_MIDI_Interface);
  }

  PrevJoystickStatus = JoystickStatus;
}"
libfirm-libfirm-bb6b635/ir/lower/lower_calls.c	"Do not lower aggregate types. This may only be used to lower parameters, return values must always be lowered. When using this function, the call lowering does not change aggregate parameters, and the backend is responsible for correctly handling them. This function is stateless and does not require an environment (you may pass NULL)."	2	"aggregate_spec_t dont_lower_aggregates(void *env, ir_type const *type) {
  (void)env;

  if (is_aggregate_type(type)) {
    return (aggregate_spec_t){
        .length = 1,
        .modes = {mode_M},
    };
  } else {
    return (aggregate_spec_t){
        .length = 1,
        .modes = {get_type_mode(type)},
    };
  }
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the orthonormal pyramid basis functions.	2	"static void
test_unit_basis_pyramid_orthonormal(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_PYR_Ortho *b_data_a = constructor_Basis_Data_PYR_Ortho('a'),
                              *b_data_c = constructor_Basis_Data_PYR_Ortho('c');

  tol = (double[]){
      3 * EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[0]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      2 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi32, b_data_c->grad_phi32,
                                     tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi32,
                                           b_data_c->grad_phi32, tol[0]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){2e2 * EPS};
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->m_34, b_data_c->m_34, tol[0]);
  }
  expect_condition(pass, ""mass matrix"");

  tol = (double[]){
      5e6 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_36, b_data_c->grad_coef_36,
                              tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_36,
                                    b_data_c->grad_coef_36, tol[0]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_PYR_Ortho(b_data_a);
  destructor_Basis_Data_PYR_Ortho(b_data_c);

  assert_condition(pass);
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/core/logconf.c	compiles a log configuration	2	"h2o_logconf_t *h2o_logconf_compile(const char *fmt, int escape, char *errbuf) {
  h2o_logconf_t *logconf = h2o_mem_alloc(sizeof(*logconf));
  const char *pt = fmt;
  size_t fmt_len = strlen(fmt);

  *logconf = (h2o_logconf_t){{NULL}, escape};

#define LAST_ELEMENT() (logconf->elements.entries + logconf->elements.size - 1)

#define NEW_ELEMENT(ty)                                                        \
  do {                                                                         \
    h2o_vector_reserve(NULL, &logconf->elements, logconf->elements.size + 1);  \
    logconf->elements.size++;                                                  \
    *LAST_ELEMENT() = (struct log_element_t){0};                               \
    LAST_ELEMENT()->type = ty;                                                 \
    LAST_ELEMENT()->suffix.base = h2o_mem_alloc(fmt_len + 1);                  \
  } while (0)

  while (*pt != '\0') {
    if (*pt == '%') {
      ++pt;
      if (*pt == '%') {

      } else if (*pt == '{') {
        const h2o_token_t *token;
        const char *quote_end = strchr(++pt, '}');
        if (quote_end == NULL) {
          sprintf(errbuf,
                  ""failed to compile log format: unterminated header name ""
                  ""starting at: \""%16s\"""",
                  pt);
          goto Error;
        }
        const char modifier = quote_end[1];
        switch (modifier) {
        case 'i':
        case 'o': {
          h2o_iovec_t name = strdup_lowercased(pt, quote_end - pt);
          token = h2o_lookup_token(name.base, name.len);
          if (token != NULL) {
            free(name.base);
            if (modifier == 'o' && token == H2O_TOKEN_SET_COOKIE) {
              NEW_ELEMENT(ELEMENT_TYPE_OUT_HEADER_TOKEN_CONCATENATED);
              LAST_ELEMENT()->data.header_token = token;
            } else {
              NEW_ELEMENT(modifier == 'i' ? ELEMENT_TYPE_IN_HEADER_TOKEN
                                          : ELEMENT_TYPE_OUT_HEADER_TOKEN);
              LAST_ELEMENT()->data.header_token = token;
            }
          } else {
            NEW_ELEMENT(modifier == 'i' ? ELEMENT_TYPE_IN_HEADER_STRING
                                        : ELEMENT_TYPE_OUT_HEADER_STRING);
            LAST_ELEMENT()->data.name = name;
          }
        } break;
        case 't':
          if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""sec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_SEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""msec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_MSEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""usec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_USEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""msec_frac""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_MSEC_FRAC);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""usec_frac""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_USEC_FRAC);
          } else {
            h2o_iovec_t name = h2o_strdup(NULL, pt, quote_end - pt);
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_STRFTIME);
            LAST_ELEMENT()->data.name = name;
          }
          break;
        case 'x':
#define MAP_EXT_TO_TYPE(name, id)                                              \
  if (h2o_lcstris(pt, quote_end - pt, H2O_STRLIT(name))) {                     \
    NEW_ELEMENT(id);                                                           \
    goto MAP_EXT_Found;                                                        \
  }
#define MAP_EXT_TO_PROTO(name, cb)                                             \
  if (h2o_lcstris(pt, quote_end - pt, H2O_STRLIT(name))) {                     \
    NEW_ELEMENT(ELEMENT_TYPE_PROTOCOL_SPECIFIC);                               \
    LAST_ELEMENT()->data.protocol_specific_callback_index =                    \
        &((h2o_conn_callbacks_t *)NULL)->log_.cb -                             \
        ((h2o_conn_callbacks_t *)NULL)->log_.callbacks;                        \
    goto MAP_EXT_Found;                                                        \
  }
          MAP_EXT_TO_TYPE(""connection-id"", ELEMENT_TYPE_CONNECTION_ID);
          MAP_EXT_TO_TYPE(""connect-time"", ELEMENT_TYPE_CONNECT_TIME);
          MAP_EXT_TO_TYPE(""request-total-time"",
                          ELEMENT_TYPE_REQUEST_TOTAL_TIME);
          MAP_EXT_TO_TYPE(""request-header-time"",
                          ELEMENT_TYPE_REQUEST_HEADER_TIME);
          MAP_EXT_TO_TYPE(""request-body-time"", ELEMENT_TYPE_REQUEST_BODY_TIME);
          MAP_EXT_TO_TYPE(""process-time"", ELEMENT_TYPE_PROCESS_TIME);
          MAP_EXT_TO_TYPE(""response-time"", ELEMENT_TYPE_RESPONSE_TIME);
          MAP_EXT_TO_TYPE(""duration"", ELEMENT_TYPE_DURATION);
          MAP_EXT_TO_TYPE(""error"", ELEMENT_TYPE_ERROR);
          MAP_EXT_TO_PROTO(""http1.request-index"", http1.request_index);
          MAP_EXT_TO_PROTO(""http2.stream-id"", http2.stream_id);
          MAP_EXT_TO_PROTO(""http2.priority.received"", http2.priority_received);
          MAP_EXT_TO_PROTO(""http2.priority.received.exclusive"",
                           http2.priority_received_exclusive);
          MAP_EXT_TO_PROTO(""http2.priority.received.parent"",
                           http2.priority_received_parent);
          MAP_EXT_TO_PROTO(""http2.priority.received.weight"",
                           http2.priority_received_weight);
          MAP_EXT_TO_PROTO(""http2.priority.actual"", http2.priority_actual);
          MAP_EXT_TO_PROTO(""http2.priority.actual.parent"",
                           http2.priority_actual_parent);
          MAP_EXT_TO_PROTO(""http2.priority.actual.weight"",
                           http2.priority_actual_weight);
          MAP_EXT_TO_PROTO(""ssl.protocol-version"", ssl.protocol_version);
          MAP_EXT_TO_PROTO(""ssl.session-reused"", ssl.session_reused);
          MAP_EXT_TO_PROTO(""ssl.cipher"", ssl.cipher);
          MAP_EXT_TO_PROTO(""ssl.cipher-bits"", ssl.cipher_bits);
          {
            h2o_iovec_t name = strdup_lowercased(pt, quote_end - pt);
            NEW_ELEMENT(ELEMENT_TYPE_EXTENDED_VAR);
            LAST_ELEMENT()->data.name = name;
          }
        MAP_EXT_Found:
#undef MAP_EXT_TO_TYPE
#undef MAP_EXT_TO_PROTO
          break;
        default:
          sprintf(errbuf, ""failed to compile log format: header name is not ""
                          ""followed by either `i`, `o`, `x`"");
          goto Error;
        }
        pt = quote_end + 2;
        continue;
      } else {
        unsigned type = NUM_ELEMENT_TYPES;
        switch (*pt++) {
#define TYPE_MAP(ch, ty)                                                       \
  case ch:                                                                     \
    type = ty;                                                                 \
    break
          TYPE_MAP('A', ELEMENT_TYPE_LOCAL_ADDR);
          TYPE_MAP('b', ELEMENT_TYPE_BYTES_SENT);
          TYPE_MAP('H', ELEMENT_TYPE_PROTOCOL);
          TYPE_MAP('h', ELEMENT_TYPE_REMOTE_ADDR);
          TYPE_MAP('l', ELEMENT_TYPE_LOGNAME);
          TYPE_MAP('m', ELEMENT_TYPE_METHOD);
          TYPE_MAP('p', ELEMENT_TYPE_LOCAL_PORT);
          TYPE_MAP('q', ELEMENT_TYPE_QUERY);
          TYPE_MAP('r', ELEMENT_TYPE_REQUEST_LINE);
          TYPE_MAP('s', ELEMENT_TYPE_STATUS);
          TYPE_MAP('t', ELEMENT_TYPE_TIMESTAMP);
          TYPE_MAP('U', ELEMENT_TYPE_URL_PATH);
          TYPE_MAP('u', ELEMENT_TYPE_REMOTE_USER);
          TYPE_MAP('V', ELEMENT_TYPE_AUTHORITY);
          TYPE_MAP('v', ELEMENT_TYPE_HOSTCONF);
#undef TYPE_MAP
        default:
          sprintf(errbuf,
                  ""failed to compile log format: unknown escape sequence: %%%c"",
                  pt[-1]);
          goto Error;
        }
        NEW_ELEMENT(type);
        continue;
      }
    }

    if (logconf->elements.size == 0)
      NEW_ELEMENT(ELEMENT_TYPE_EMPTY);
    LAST_ELEMENT()->suffix.base[LAST_ELEMENT()->suffix.len++] = *pt++;
  }

  if (logconf->elements.size == 0)
    NEW_ELEMENT(ELEMENT_TYPE_EMPTY);
  LAST_ELEMENT()->suffix.base[LAST_ELEMENT()->suffix.len++] = '\n';

#undef NEW_ELEMENT
#undef LAST_ELEMENT

  return logconf;

Error:
  h2o_logconf_dispose(logconf);
  return NULL;
}"
emlai-emregex-c086b23/lib/match.c	Creates a new branch and adds it to the branches array. Only MAX_BRANCHES branches can be in the array at once.	2	"void addBranch(char input, const reNode *node) {
  reDynArrayPush(((reBranch){input, node}), branches);
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_data.c	The C string object will be invalidate the next time a function call to the IO object is made.	2	"fio_str_info_s fiobj_data_pread(FIOBJ io, intptr_t start_at, uintptr_t length) {
  if (!io || !FIOBJ_TYPE_IS(io, FIOBJ_T_DATA)) {
    errno = EFAULT;
    return (fio_str_info_s){
        .data = NULL,
        .len = 0,
    };
  }

  errno = 0;
  switch (obj2io(io)->fd) {
  case -1:
    return fiobj_data_pread_str(io, start_at, length);
    break;
  case -2:
    return fiobj_data_pread_slice(io, start_at, length);
    break;
  default:
    return fiobj_data_pread_file(io, start_at, length);
  }
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	Liefert das jeweils grere Element der beiden Vektoren	2	"static inline vec_float4 simd_max(vec_float4 a, vec_float4 b) {
#if defined(__SSE__)
  return _mm_max_ps(a, b);
#elif defined(__VEC__)
  return vec_max(a, b);
#elif defined(__NEON__)
  return vmaxq_f32(a, b);
#else
  const float *aF = (const float *)&a;
  const float *bF = (const float *)&b;
  return (vec_float4){fmaxf(aF[0], bF[0]), fmaxf(aF[1], bF[1]),
                      fmaxf(aF[2], bF[2]), fmaxf(aF[3], bF[3])};
#endif
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_bases.c	Provides unit tests for the bezier simplex basis functions.	2	"static void test_unit_basis_simplex_bezier(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  struct Basis_Data_SI_Bezier *b_data_a = constructor_Basis_Data_SI_Bezier('a'),
                              *b_data_c = constructor_Basis_Data_SI_Bezier('c');

  tol = (double[]){
      EPS,
      2 * EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]),
      diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]),
      diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]),
  };
  if (check_diff(3, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(b_data_a->phi22, b_data_c->phi22, tol[0]);
    if (differences[1])
      print_diff_const_Matrix_d(b_data_a->phi23, b_data_c->phi23, tol[1]);
    if (differences[2])
      print_diff_const_Matrix_d(b_data_a->phi32, b_data_c->phi32, tol[2]);
  }
  expect_condition(pass, ""basis"");

  tol = (double[]){
      EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22, b_data_c->grad_phi22,
                                     tol[0]),
      diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31, b_data_c->grad_phi31,
                                     tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi22,
                                           b_data_c->grad_phi22, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_Matrix_d(b_data_a->grad_phi31,
                                           b_data_c->grad_phi31, tol[1]);
  }
  expect_condition(pass, ""grad basis"");

  tol = (double[]){
      EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Vector_d(b_data_a->p_24, b_data_c->p_24, tol[0]),
      diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Vector_d(b_data_a->p_24, b_data_c->p_24, tol[0]);
    if (differences[1])
      print_diff_const_Vector_d(b_data_a->p_34, b_data_c->p_34, tol[1]);
  }
  expect_condition(pass, ""partition of unity"");

  tol = (double[]){
      2e1 * EPS,
      11e4 * EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(b_data_a->grad_coef_25, b_data_c->grad_coef_25,
                              tol[0]),
      diff_const_Multiarray_d(b_data_a->grad_coef_37, b_data_c->grad_coef_37,
                              tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_25,
                                    b_data_c->grad_coef_25, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(b_data_a->grad_coef_37,
                                    b_data_c->grad_coef_37, tol[1]);
  }
  expect_condition(pass, ""gradient evaluation"");

  destructor_Basis_Data_SI_Bezier(b_data_a);
  destructor_Basis_Data_SI_Bezier(b_data_c);

  assert_condition(pass);
}"
simondlevy-ARDroneAutoPylot-7ca39e9/ARDroneLib/FFMPEG/ffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);
    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open(st->codec, codec);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;

      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))
      try_decode_frame(st, pkt);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }

  av_estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
systemd-systemd-17b7025/src/shared/install.c	"Returns negative on error, 0 if the unit was already known, 1 otherwise."	2	"static int install_info_add(InstallContext *c, const char *name,
                            const char *path, bool auxiliary,
                            UnitFileInstallInfo **ret) {

  UnitFileInstallInfo *i = NULL;
  int r;

  assert(c);
  assert(name || path);

  if (!name)
    name = basename(path);

  if (!unit_name_is_valid(name, UNIT_NAME_ANY))
    return -EINVAL;

  i = install_info_find(c, name);
  if (i) {
    i->auxiliary = i->auxiliary && auxiliary;

    if (ret)
      *ret = i;
    return 0;
  }

  r = ordered_hashmap_ensure_allocated(&c->will_process, &string_hash_ops);
  if (r < 0)
    return r;

  i = new (UnitFileInstallInfo, 1);
  if (!i)
    return -ENOMEM;

  *i = (UnitFileInstallInfo){
      .type = _UNIT_FILE_TYPE_INVALID,
      .auxiliary = auxiliary,
  };

  i->name = strdup(name);
  if (!i->name) {
    r = -ENOMEM;
    goto fail;
  }

  if (path) {
    i->path = strdup(path);
    if (!i->path) {
      r = -ENOMEM;
      goto fail;
    }
  }

  r = ordered_hashmap_put(c->will_process, i->name, i);
  if (r < 0)
    goto fail;

  if (ret)
    *ret = i;

  return 1;

fail:
  install_info_free(i);
  return r;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/StillImage.c	Opens a new PIMA session with the attached device. This should be used before any session-orientated PIMA commands are issued to the device. Only one session can be open at the one time.	2	"uint8_t SI_Host_OpenSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  SIInterfaceInfo->State.TransactionID = 0;
  SIInterfaceInfo->State.IsSessionOpen = false;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = 0x1002,
      .Params = {1},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((PIMABlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  SIInterfaceInfo->State.IsSessionOpen = true;

  return PIPE_RWSTREAM_NoError;
}"
dm-vdo-kvdo-8df6805/vdo/base/blockMapTree.c	"Attempt to acquire a lock on a page in the block map tree. If the page is already locked, queue up to wait for the lock to be released. If the lock is acquired, the DataVIO's treeLock.locked field will be set to true."	2	"static int attemptPageLock(BlockMapTreeZone *zone, DataVIO *dataVIO) {
  TreeLock *lock = &dataVIO->treeLock;
  Height height = lock->height;
  BlockMapTreeSlot treeSlot = lock->treeSlots[height];
  PageKey key;
  key.descriptor = (PageDescriptor){
      .rootIndex = lock->rootIndex,
      .height = height,
      .pageIndex = treeSlot.pageIndex,
      .slot = treeSlot.blockMapSlot.slot,
  };
  lock->key = key.key;

  TreeLock *lockHolder;
  int result = intMapPut(zone->loadingPages, lock->key, lock, false,
                         (void **)&lockHolder);
  if (result != VDO_SUCCESS) {
    return result;
  }

  if (lockHolder == NULL) {

    dataVIO->treeLock.locked = true;
    return VDO_SUCCESS;
  }

  return enqueueDataVIO(&lockHolder->waiters, dataVIO,
                        THIS_LOCATION(""$F;cb=blockMapTreePage""));
}"
dm-vdo-kvdo-8df6805/vdo/base/waitQueue.h	Initialize a wait queue.	2	"static inline void initializeWaitQueue(WaitQueue *queue) {
  *queue = (WaitQueue){
      .lastWaiter = NULL,
      .queueLength = 0,
  };
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Device/ClassDriver/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t *const RNDISInterfaceInfo,
                 Ethernet_Frame_Info_t *const FrameOUT) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT->FrameLength)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT->FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                                               sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
                               sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
                         &ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT->FrameLength = PacketSize;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
libyuni-libyuni-dcd55a1/src/yuni/core/event/observer/observer.h	"Disconnect all event emitters, if any."	2	"******template <template <class> class TP = Policy::ObjectLevelLockable>
     **class ThermalSensor : public TP<ThermalSensor> ** {
  **public : ****typedef TP<ThermalSensor> ThreadingPolicy;
  ****public : **ThermalSensor() : pLastValue(0.){} * *~ThermalSensor() {}"
HiPhish-XeenTools-ee7c26c/Source/raw/raw_tool.c	Read a raw image form file into a sprite.	2	"int xeen_read_raw(FILE *fp, long o, XeenSprite *raw) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    MALLOC_FAIL,
    FREAD_FAIL,
  } error = SUCCESS;

  if (!fp || !raw) {
    error = INVALID_ARGS;
    goto end;
  } else if (raw->frames != 0 || raw->cells != 0 || raw->map != NULL ||
             raw->cell != NULL) {
    error = INVALID_ARGS;
    goto end;
  }

  uint8_t *bytes = malloc(A * sizeof(*bytes));
  uint16_t(*map)[2] = malloc(1 * sizeof(*map));
  XeenFrame *frame = malloc(1 * sizeof(*frame));

  if (!bytes || !map || !frame) {
    error = MALLOC_FAIL;
    goto end;
  }

  if (fread(bytes, sizeof(uint8_t), X * Y, fp) != A * sizeof(uint8_t)) {
    error = FREAD_FAIL;
    free(bytes);
    free(map);
    free(frame);
    goto end;
  }

  *map[0] = *map[1] = 0;
  *frame = (XeenFrame){
      .width = X,
      .height = Y,
      .pixels = bytes,
  };

  *raw = (XeenSprite){
      .frames = 1,
      .cells = 1,
      .map = map,
      .cell = frame,
  };

end:
  return error;
}"
ventanium-ventanium-e769f5e/src/vtm/net/http/ws_client.c	Connects to given HTTP/WebSocket server	1	"int vtm_ws_client_connect(vtm_ws_client *cl, enum vtm_socket_family fam,
                          const char *url) {
  int rc, status;
  vtm_http_client *http_cl;
  struct vtm_http_client_req req;
  struct vtm_http_client_res res;
  vtm_dataset *headers;
  char ws_key[VTM_BASE64_ENC_BUF_LEN(sizeof(uint64_t))];
  uint64_t time;

  http_cl = vtm_http_client_new();
  if (!http_cl)
    return vtm_err_get_code();

  if (cl->hints & VTM_WS_CL_HINT_NO_CERT_CHECK) {
    rc = vtm_http_client_set_opt(http_cl, VTM_HTTP_CL_OPT_NO_CERT_CHECK,
                                 (bool[]){true}, sizeof(bool));
    if (rc != VTM_OK)
      goto end;
  }

  if (cl->opt_timeout > 0) {
    rc = vtm_http_client_set_opt(http_cl, VTM_HTTP_CL_OPT_TIMEOUT,
                                 (unsigned long[]){cl->opt_timeout},
                                 sizeof(unsigned long));
    if (rc != VTM_OK)
      goto end;
  }

  time = vtm_time_current_micros();
  rc = vtm_base64_encode(&time, sizeof(time), ws_key, sizeof(ws_key));
  if (rc != VTM_OK)
    goto end;

  headers = vtm_dataset_new();
  if (!headers) {
    rc = vtm_err_get_code();
    goto end;
  }

  vtm_dataset_set_string(headers, VTM_HTTP_HEADER_UPGRADE,
                         VTM_HTTP_VALUE_WEBSOCKET);
  vtm_dataset_set_string(headers, VTM_HTTP_HEADER_CONNECTION,
                         VTM_HTTP_VALUE_UPGRADE);
  vtm_dataset_set_string(headers, VTM_HTTP_HEADER_SEC_WEBSOCKET_KEY, ws_key);
  vtm_dataset_set_string(headers, VTM_HTTP_HEADER_SEC_WEBSOCKET_VERSION, ""13"");

  memset(&req, 0, sizeof(req));
  req.method = VTM_HTTP_METHOD_GET;
  req.version = VTM_HTTP_VER_1_1;
  req.fam = fam;
  req.headers = headers;
  req.url = url;
  req.body = NULL;
  req.body_len = 0;

  rc = vtm_http_client_request(http_cl, &req, &res);
  if (rc != VTM_OK)
    goto end;

  status = res.status_code;
  vtm_http_client_res_release(&res);
  if (status != VTM_HTTP_101_SWITCHING_PROTOCOLS) {
    rc = VTM_E_IO_UNKNOWN;
    goto end;
  }

  vtm_buf_clear(&cl->recvbuf);
  vtm_ws_parser_reset(&cl->parser);

  rc = vtm_http_client_take_socket(http_cl, &cl->sock);

end:
  vtm_http_client_free(http_cl);

  return rc;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a double-precision floating-point value from a specified memory location and duplicates it to both vector elements of a 128-bit vector of [2 x double].	2	"_mm_load1_pd(double const *__dp) {
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, __u};
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/code-gen.c	"Performs code-generation on the given AST node. It is up to the root node to know how to correctly handle being the root, ie, the semantics around global scope and so forth."	2	"ava_pcode_global_list *ava_codegen_run(ava_ast_node *root,
                                       ava_list_value implicit_packages,
                                       ava_compile_error_list *errors) {
  ava_pcg_builder *global_builder = ava_pcg_builder_new();
  ava_pcx_builder *init_builder;
  ava_uint init_function;
  const ava_function *init_prototype;
  ava_demangled_name init_name;
  ava_list_value init_vars;
  ava_codegen_context *context;
  size_t i, n;

  init_name.scheme = ava_nms_ava;
  init_name.name = AVA_ASCII9_STRING(""\\init"");
  init_prototype = ava_function_of_value(ava_value_of_cstring(""1 ava pos""));
  init_vars = ava_list_of_values((ava_value[]){ava_empty_list().v}, 1);

  ava_pcgb_src_pos(global_builder, root->location.filename,
                   root->location.line_offset, root->location.start_line,
                   root->location.end_line, root->location.start_column,
                   root->location.end_column);

  n = ava_list_length(implicit_packages);
  for (i = 0; i < n; ++i)
    ava_pcgb_load_pkg(global_builder,
                      ava_to_string(ava_list_index(implicit_packages, i)));

  init_function = ava_pcgb_fun(global_builder, ava_false, init_name,
                               init_prototype, init_vars, &init_builder);
  ava_pcgb_init(global_builder, init_function);

  context = ava_codegen_context_alloc(init_builder, errors);
  ava_ast_node_cg_discard(root, context);

  return ava_pcg_builder_get(global_builder);
}"
parapluu-encore-3d5e973/src/runtime/stream/stream.c	Put a value in an EXISTING stream	2	"stream_t *stream_put_fut(pony_ctx_t **ctx, future_t *fut, stream_t *s,
                         encore_arg_t value, pony_type_t *type) {
  struct scons *scons = scons_mk(*ctx, type);
  scons->element = value;
  scons->next = fut;
  future_fulfil(ctx, (future_t *)s, (encore_arg_t){.p = scons});
  return fut;
}"
foss-teiwest-irc-bot-936f281/src/socket.c	Start listening for connections	2	"int sock_listen(const char *address, const char *port) {

  int retval, sock = -1;
  struct addrinfo *addr, *iterator;

  struct addrinfo hints = {.ai_family = AF_UNSPEC,
                           .ai_socktype = SOCK_STREAM,
                           .ai_flags = AI_NUMERICSERV};
  assert(atoi(port) > 0 && atoi(port) <= MAXPORT);

  retval = getaddrinfo(address, port, &hints, &addr);
  if (retval) {
    fprintf(stderr, ""getaddrinfo: %s\n"", gai_strerror(retval));
    return -1;
  }
  for (iterator = addr; iterator; iterator = iterator->ai_next) {

    sock = socket(iterator->ai_family, iterator->ai_socktype,
                  iterator->ai_protocol);
    if (sock < 0) {
      perror(__func__);
      continue;
    }

    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &(socklen_t){1},
               sizeof(socklen_t));
    if (!bind(sock, iterator->ai_addr, iterator->ai_addrlen) &&
        !listen(sock, 5))
      break;

    perror(__func__);
    close(sock);
    sock = -1;
  }
  freeaddrinfo(addr);
  return sock;
}"
MRChemSoft-mrcpp-a736976/src/trees/OperatorNode.h	"OperatorNorms are defined as matrix 2-norms that are expensive to calculate. Thus we calculate some cheaper upper bounds for this norm for thresholding. First a simple vector norm, then a product of the 1- and infinity-norm."	2	"MWNode<2>::createChildren();
this->clearIsEndNode();
this->giveChildrenCoefs();
}
void deleteChildren() override {
  MWNode<2>::deleteChildren();
  this->setIsEndNode();
}

friend class MWNode<2>;
friend class OperatorTree;
friend class SerialOperatorTree;

protected:
OperatorNode() : MWNode<2>(){};
OperatorNode(const OperatorNode &node) = delete;
OperatorNode &operator=(const OperatorNode &node) = delete;

void dealloc() override;
double calcComponentNorm(int i) const override;
}
;
}"
liyouchang-webrtc-qt-5d246c6/VideoMonitor/jni/h264/golomb.h	write unsigned exp golomb code.	2	"static void set_ue_golomb(PutBitContext *pb, int i) {
  int e;

  assert(i >= 0);

#if 0
    if(i=0){
        put_bits(pb, 1, 1);
        return;
    }
#endif
  if (i < 256)
    put_bits(pb, ff_ue_golomb_len[i], i + 1);
  else {
    e = av_log2(i + 1);

    put_bits(pb, 2 * e + 1, i + 1);
  }
}"
UCLA-ECE209AS-2018W-Hui-Wenxuan-Yifan-87cb1db/proxmark3-master/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd[],
                   int iso15cmdlen) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLog(""missing addr"");
    return 0;
    break;
  case 's':
  case 'S':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_SELECT;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    if (!getUID(uid)) {
      PrintAndLog(""No Tag found"");
      return 0;
    }
    memcpy(req + reqlen, uid, 8);
    PrintAndLog(""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += 8;
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLog(""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], &uid[0], 8);
    reqlen += 8;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"
balp-DevIL-64f5ae3/src-ILU/ilur/ilur.c	Just dump infos about functions to the structures so we can somehow automate the processing of user input later...	2	"void init_strings() {
  ilu_functions[ILU_ALIENIFY] =
      (Ilu_function){""iluAlienify"", PARAM_VOID, &iluAlienify};
  ilu_functions[ILU_BLURAVG] =
      (Ilu_function){""iluBlurAvg"", PARAM_ILUINT, &iluBlurAvg};
  ilu_functions[ILU_BLURGAUSSIAN] =
      (Ilu_function){""iluBlurGaussian"", PARAM_ILUINT, &iluBlurGaussian};
  ilu_functions[ILU_BUILDMIPMAPS] =
      (Ilu_function){""iluBuildMipmaps"", PARAM_VOID, &iluBuildMipmaps};
  ilu_functions[ILU_COMPAREIMAGE] =
      (Ilu_function){""iluCompareImage"", PARAM_ILUINT, &iluCompareImage};
  ilu_functions[ILU_CONTRAST] =
      (Ilu_function){""iluContrast"", PARAM_ILFLOAT, &iluContrast};
  ilu_functions[ILU_CROP] = (Ilu_function){""iluCrop"", PARAM_OTHERS, &iluCrop};
  ilu_functions[ILU_EDGEDETECTE] =
      (Ilu_function){""iluEdgeDetectE"", PARAM_VOID, &iluEdgeDetectE};
  ilu_functions[ILU_EDGEDETECTP] =
      (Ilu_function){""iluEdgeDetectP"", PARAM_VOID, &iluEdgeDetectP};
  ilu_functions[ILU_EDGEDETECTS] =
      (Ilu_function){""iluEdgeDetectS"", PARAM_VOID, &iluEdgeDetectS};
  ilu_functions[ILU_EMBOSS] =
      (Ilu_function){""iluEmboss"", PARAM_VOID, &iluEmboss};
  ilu_functions[ILU_ENLARGECANVAS] =
      (Ilu_function){""iluEnlargeCanvas"", PARAM_OTHERS, &iluEnlargeCanvas};
  ilu_functions[ILU_ENLARGEIMAGE] =
      (Ilu_function){""iluEnlargeImage"", PARAM_OTHERS, &iluEnlargeImage};
  ilu_functions[ILU_EQUALIZE] =
      (Ilu_function){""iluEqualize"", PARAM_VOID, &iluEqualize};
  ilu_functions[ILU_CONVOLUTION] =
      (Ilu_function){""iluConvolution"", PARAM_OTHERS, &iluConvolution};
  ilu_functions[ILU_FLIPIMAGE] =
      (Ilu_function){""iluFlipImage"", PARAM_VOID, &iluFlipImage};
  ilu_functions[ILU_GAMMACORRECT] =
      (Ilu_function){""iluGammaCorrect"", PARAM_ILFLOAT, &iluGammaCorrect};
  ilu_functions[ILU_INVERTALPHA] =
      (Ilu_function){""iluInvertAlpha"", PARAM_VOID, &iluInvertAlpha};
  ilu_functions[ILU_MIRROR] =
      (Ilu_function){""iluMirror"", PARAM_VOID, &iluMirror};
  ilu_functions[ILU_NEGATIVE] =
      (Ilu_function){""iluNegative"", PARAM_VOID, &iluNegative};
  ilu_functions[ILU_NOISIFY] =
      (Ilu_function){""iluNoisify"", PARAM_ILFLOAT, &iluNoisify};
  ilu_functions[ILU_PIXELIZE] =
      (Ilu_function){""iluPixelize"", PARAM_ILUINT, &iluPixelize};
  ilu_functions[ILU_REPLACECOLOUR] =
      (Ilu_function){""iluReplaceColour"", PARAM_OTHERS, &iluReplaceColour};
  ilu_functions[ILU_ROTATE] =
      (Ilu_function){""iluRotate"", PARAM_ILFLOAT, &iluRotate};
  ilu_functions[ILU_ROTATE3D] =
      (Ilu_function){""iluRotate3D"", PARAM_OTHERS, &iluRotate3D};
  ilu_functions[ILU_SATURATE1F] =
      (Ilu_function){""iluSaturate1f"", PARAM_ILFLOAT, &iluSaturate1f};
  ilu_functions[ILU_SATURATE4F] =
      (Ilu_function){""iluSaturate4f"", PARAM_OTHERS, &iluSaturate4f};
  ilu_functions[ILU_SCALE] =
      (Ilu_function){""iluScale"", PARAM_OTHERS, &iluScale};
  ilu_functions[ILU_SCALEALPHA] =
      (Ilu_function){""iluScaleAlpha"", PARAM_ILFLOAT, &iluScaleAlpha};
  ilu_functions[ILU_SCALECOLOURS] =
      (Ilu_function){""iluScaleColours"", PARAM_OTHERS, &iluScaleColours};
  ilu_functions[ILU_SETLANGUAGE] =
      (Ilu_function){""iluSetLanguage"", PARAM_OTHERS, &iluSetLanguage};
  ilu_functions[ILU_SHARPEN] =
      (Ilu_function){""iluSharpen"", PARAM_OTHERS, &iluSharpen};
  ilu_functions[ILU_SWAPCOLOURS] =
      (Ilu_function){""iluSwapColours"", PARAM_VOID, &iluSwapColours};
  ilu_functions[ILU_WAVE] = (Ilu_function){""iluWave"", PARAM_ILFLOAT, &iluWave};
}"
Meulengracht-MollenOS-e48f4ab/librt/include/mmintrin.h	Constructs a 64-bit integer vector initialized to zero.	2	_mm_setzero_si64(void) { return __extension__(__m64){0LL}; }
freeciv-freeciv-e4ead30/server/srv_log.c	"Log unit messages, they will appear like this 2: Polish Archers[139] (5,35)->(0,0){0,0} stays to defend city where [] is unit id, ()->() are coordinates present and goto, and {,} contains bodyguard and ferryboat ids."	2	"void real_unit_log(const char *file, const char *function, int line,
                   enum log_level level, bool notify, const struct unit *punit,
                   const char *msg, ...) {
  char buffer[500];
  char buffer2[500];
  va_list ap;
  int gx, gy;
  char aibuf[500] = ""\0"";

  CALL_PLR_AI_FUNC(log_fragment_unit, unit_owner(punit), aibuf, sizeof(aibuf),
                   punit);

  if (punit->goto_tile) {
    index_to_map_pos(&gx, &gy, tile_index(punit->goto_tile));
  } else {
    gx = gy = -1;
  }

  fc_snprintf(buffer, sizeof(buffer), ""%s %s(%d) %s (%d,%d)->(%d,%d){%s} "",
              nation_rule_name(nation_of_unit(punit)), unit_rule_name(punit),
              punit->id, get_activity_text(punit->activity),
              TILE_XY(unit_tile(punit)), gx, gy, aibuf);

  va_start(ap, msg);
  fc_vsnprintf(buffer2, sizeof(buffer2), msg, ap);
  va_end(ap);

  cat_snprintf(buffer, sizeof(buffer), ""%s"", buffer2);
  if (notify) {
    notify_conn(NULL, NULL, E_AI_DEBUG, ftc_log, ""%s"", buffer);
  }
  do_log(file, function, line, FALSE, level, ""%s"", buffer);
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Device/LowLevel/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_Task(void) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT.FrameLength)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT.FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT
              .FrameData[sizeof(Ethernet_Frame_Header_t) + sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
                              sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
                         &ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT.FrameLength = PacketSize;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
luciotato-LiteScript-118e12d/devel/litec/core/LiteC-core.c	"unified _unifiedGetNVPAtIndex, for Objects & Maps. Unified get name-value pair at index to make js LiteralObjects and Maps interchangeable, _unifiedGetNVPAtIndex(), if the object is a Map, returns *MAP_NVP_PTR(index) else returns a _nameValuePair with decoded PropName and PropValue"	2	"_unifiedGetNVPAtIndex(any this, len_t index) {
  if (this.class == Map_inx)
    return *(MAP_NVP_PTR(index, this));
  else

    return (_nameValuePair_s){.name =
                                  _object_getPropertyNameAtIndex(this, index),
                              .value = this.value.prop[index]};
}"
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit integer vector initialized with the specified 8-bit integral values. This intrinsic is a utility function and does not correspond to a specific instruction.	2	"_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28, char __b27,
                char __b26, char __b25, char __b24, char __b23, char __b22,
                char __b21, char __b20, char __b19, char __b18, char __b17,
                char __b16, char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08, char __b07,
                char __b06, char __b05, char __b04, char __b03, char __b02,
                char __b01, char __b00) {
  return __extension__(__m256i)(__v32qi){
      __b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
      __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
      __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
      __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31};
}"
kwakeham-BLE_ANT_Template-f1e60c0/nRF5_SDK/components/iot/ipv6_stack/sntp_client/sntp_client.c	The SNTP client module implements the retransmission mechanism by invoking this function periodically. This procedure is to be added to the IoT Timer client list and has to be called repeatedly with a minimum period of SNTP_RETRANSMISSION_INTERVAL.	1	"void sntp_client_timeout_process(iot_timer_time_in_ms_t wall_clock_value) {
  SNTP_C_MUTEX_LOCK();

  UNUSED_PARAMETER(wall_clock_value);

  if (m_sntp_client_state == SNTP_CLIENT_STATE_BUSY) {
    if (is_it_time_to_retransmit()) {
      m_retransmission_count++;
      if (m_retransmission_count > SNTP_MAX_RETRANSMISSION_COUNT) {
        m_sntp_client_state = SNTP_CLIENT_STATE_IDLE;
        m_retransmission_count = 0;
        m_do_sync_local_time = false;

        SNTP_C_MUTEX_UNLOCK();

        if (m_app_evt_handler != NULL) {
          m_app_evt_handler(m_p_ntp_server_address, m_ntp_server_port,
                            NTP_SERVER_UNREACHABLE,
                            (sntp_client_cb_param_t){.callback_data = 0x00});
        }

        SNTP_TRC(""NTP server did not respond to query."");
        return;
      } else {
        SNTP_TRC(""Query retransmission [%d]."", m_retransmission_count);
        UNUSED_VARIABLE(sntp_query_send());
      }
    }
  }

  SNTP_C_MUTEX_UNLOCK();
  return;
}"
mrirecon-bart-47fce6b/src/num/multind.c	Zero out array (with strides) ptr[i] = 0	2	"void md_clear2(unsigned int D, const long dim[D], const long str[D], void *ptr,
               size_t size) {
  const long(*nstr[1])[D] = {(const long(*)[D])str};
#ifdef USE_CUDA
  bool use_gpu = cuda_ondevice(ptr);
#endif
  unsigned long flags = 0;

  for (unsigned int i = 0; i < D; i++)
    if (0 == str[i])
      flags |= MD_BIT(i);

  long dim2[D];
  md_select_dims(D, ~flags, dim2, dim);

  NESTED(void, nary_clear, (struct nary_opt_data_s * opt_data, void *ptr[])) {
    size_t size2 = size * opt_data->size;

#ifdef USE_CUDA
    if (use_gpu) {

      cuda_clear(size2, ptr[0]);
      return;
    }
#endif
    memset(ptr[0], 0, size2);
  };

  optimized_nop(1, MD_BIT(0), D, dim2, nstr, (void *[1]){ptr},
                (size_t[1]){size}, nary_clear);
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  MPADecodeHeader c;
  int vbrtag_size = 0;
  MP3DecContext *mp3 = s->priv_data;

  ffio_init_checksum(s->pb, ff_crcA001_update, 0);

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (avpriv_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  mp3->frames = 0;
  mp3->header_filesize = 0;

  mp3_parse_info_tag(s, st, &c, spf);
  mp3_parse_vbri_tag(s, st, base);

  if (!mp3->frames && !mp3->header_filesize)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (mp3->frames) {
    st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                st->time_base);
  }
  if (mp3->header_filesize && mp3->frames && !mp3->is_cbr)
    st->codec->bit_rate = av_rescale(mp3->header_filesize, 8 * c.sample_rate,
                                     mp3->frames * (int64_t)spf);

  return 0;
}"
dm-vdo-vdo-bebf98e/utils/uds/timeUtilsLinuxUser.c	Return a time offset from the specified time.	2	"AbsTime deltaTime(AbsTime time, RelTime reltime) {
  if (!isValidTime(time)) {
    return time;
  }
  if ((reltime >= 0) && (reltime < 10 * BILLION)) {
    reltime += time.tv_nsec;
    while (reltime >= BILLION) {
      reltime -= BILLION;
      time.tv_sec++;
    }
    time.tv_nsec = reltime;
    return time;
  }

  int64_t ns = time.tv_sec * BILLION + time.tv_nsec;
  if ((ns < INT64_MIN / 2) || (ns > INT64_MAX / 2) ||
      (reltime < INT64_MIN / 2) || (reltime > INT64_MAX / 2)) {
    return invalidTime;
  }
  ns += reltime;
  return (AbsTime){.tv_sec = ns / BILLION, .tv_nsec = ns % BILLION};
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Subtract two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qsubl(const quaternion_long_double num1, const quaternion_long_double num2) {
  return (quaternion_long_double){num1.R - num2.R, num1.i - num2.i,
                                  num1.j - num2.j, num1.k - num2.k};
}"
squidfunk-protobluff-f6ee42c/src/util/chunk_allocator.c	"Allocate a memory block of given size. Memory blocks are stored in pre-allocated chunks to account for later growth by allocating more space than is needed upfront. If the block grows inside the corresponding chunk's capacity, the same block is returned. Otherwise, the chunk is doubled in size to make room for more growth. Chunks are managed through a linked list. New chunks are always appended to the end of the list. If a chunk is freed, it is removed from the list and its predecessor and successor are linked. The first chunk does not store any data, it just holds the initial capacity and the head of the list."	2	"allocator_allocate(void *data, size_t size) {
  assert(size);
  if (unlikely_(!data))
    return NULL;

  pb_chunk_allocator_t *base = data;
  pb_chunk_allocator_t *head = data;
  while (head->next)
    head = head->next;

  size_t capacity = base->capacity * (size / base->capacity + 1);

  pb_chunk_allocator_t *chunk = malloc(sizeof(pb_chunk_allocator_t) + capacity);
  if (chunk) {
    *chunk = (pb_chunk_allocator_t){.next = NULL, .capacity = capacity};
    head->next = chunk;

    return block_from_chunk(head->next);
  }

  return NULL;
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m3/amffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t file_size = 0;
  int bit_rate = 0;
  int64_t old_offset = -1;
  int fast_switch = am_getconfig_bool(""media.libplayer.fastswitch"");
  av_log(NULL, AV_LOG_INFO, ""[%s]fast_switch=%d\n"", __FUNCTION__, fast_switch);
  if (ic->pb != NULL)
    old_offset = avio_tell(ic->pb);
  if (!strcmp(ic->iformat->name, ""DRMdemux"")) {
    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];
      if (st->codec->bit_rate > 0) {
        bit_rate += st->codec->bit_rate;
        if (st->duration != AV_NOPTS_VALUE)
          file_size += (st->duration / AV_TIME_BASE * st->codec->bit_rate) >> 3;
      }
    }
    if (file_size > 0)
      ic->file_size = file_size;
    if (bit_rate > 0)
      ic->bit_rate = bit_rate;
    av_log(NULL, AV_LOG_INFO,
           ""]av_find_stream_info]DRMdemux, do not check stream info ,return ""
           ""directly\n"");
    return 0;
  }
  av_log(NULL, AV_LOG_INFO, ""[%s:%d]fast_switch=%d\n"", __FUNCTION__, __LINE__,
         fast_switch);
  if (fast_switch) {
    for (i = 0; i < ic->nb_streams; i++) {
      ic->streams[i]->need_parsing = AVSTREAM_PARSE_NONE;
    }
  }
  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);

    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec) {
      avcodec_open(st->codec, codec);
    }

    if (!has_codec_parameters_ex(st->codec, fast_switch)) {
      if (codec && !st->codec->codec) {
        avcodec_open(st->codec, codec);
      }
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  int stream_parser_count = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;
      st = ic->streams[i];
      int parse_mode = fast_switch;
      if (ic->pb && ic->pb->is_streamed == 1 &&
          !strcmp(ic->iformat->name, ""mpegts"")) {
        parse_mode = SPEED_PARSE_MODE;
      }
      if (!has_codec_parameters_ex(st->codec, parse_mode)) {
        break;
      } else {
        stream_parser_count = i + 1;
      }

      if (ic->pb && ic->pb->fastdetectedinfo)
        continue;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (!fast_switch && tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (!fast_switch && st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER) ||
          (fast_switch && ic->nb_streams >= 2)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters_ex(st->codec, fast_switch)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }
    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters_ex(st->codec, fast_switch) ||
        (!fast_switch && !has_decode_delay_been_guessed(st))) {
      try_decode_frame(st, pkt);
    }

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }
  ret = av_estimate_timings(ic, old_offset);
  if (ret < 0)
    goto find_stream_info_err;
  compute_chapters_end(ic);
#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  av_log(NULL, AV_LOG_INFO, ""[%s]return\n"", __FUNCTION__);
  return ret;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/Printer.c	Retrieves the status of the virtual Printer port's inbound status lines. The result can then be masked against the PRNT_PORTSTATUS_* macros to determine the printer port's status.	2	"uint8_t
PRNT_Host_GetPortStatus(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                        uint8_t *const PortStatus) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetPortStatus,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(PortStatus);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/list-proj.c	"Returns a list whose values are alternatively taken from each input list in sequence. For example, the lists [a b c], [d e f], [g h i] interleave to produce [a d g b e h c f i]. All lists must be of the same length. This function is aware of values produced by ava_list_proj_demux() and can invert them quickly."	2	"ava_list_value ava_list_proj_interleave(const ava_list_value *restrict lists,
                                        size_t num_lists) {
  size_t i;
#ifndef NDEBUG
  size_t first_list_length;
#endif

  if (0 == num_lists)
    return ava_empty_list();

#ifndef NDEBUG
  first_list_length = ava_list_length(lists[0].v);
  for (i = 1; i < num_lists; ++i)
    assert(first_list_length == ava_list_length(lists[i].v));
#endif

  if (1 == num_lists)
    return lists[0];

  const ava_list_proj_demux_list *restrict demux0 = ava_value_ptr(lists[0].v);
  for (i = 0; i < num_lists; ++i) {
    if (&ava_list_proj_demux_list_impl !=
        ava_get_attribute(lists[i].v, &ava_list_trait_tag))
      goto project;

    const ava_list_proj_demux_list *restrict demux = ava_value_ptr(lists[i].v);

    if (i != demux->offset || num_lists != demux->stride)
      goto project;

    if (memcmp(&demux->delegate, &demux0->delegate, sizeof(ava_fat_list_value)))
      goto project;
  }

  return demux0->delegate.c;

project:;
  ava_list_proj_interleave_list *dst =
      ava_alloc(sizeof(ava_list_proj_interleave_list) +
                sizeof(ava_fat_list_value) * num_lists);
  dst->num_lists = num_lists;

  for (i = 0; i < num_lists; ++i)
    dst->lists[i] = ava_fat_list_value_of(lists[i].v);

  return (ava_list_value){
      ava_value_with_ptr(&ava_list_proj_interleave_list_impl, dst)};
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/StillImageClassHost.c	Closes an already opened PIMA session with the attached device. This should be used after all session-orientated PIMA commands have been issued to the device.	2	"uint8_t SI_Host_CloseSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = CPU_TO_LE32(PIMA_COMMAND_SIZE(1)),
      .Type = CPU_TO_LE16(PIMA_CONTAINER_CommandBlock),
      .Code = CPU_TO_LE16(0x1003),
      .Params = {CPU_TO_LE32(1)},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SIInterfaceInfo->State.IsSessionOpen = false;

  if ((PIMABlock.Type != CPU_TO_LE16(PIMA_CONTAINER_ResponseBlock)) ||
      (PIMABlock.Code != CPU_TO_LE16(0x2001)))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  return PIPE_RWSTREAM_NoError;
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/common/hostinfo.c	dispatches a (possibly) asynchronous hostname lookup	0	"h2o_hostinfo_getaddr_req_t *
h2o_hostinfo_getaddr(h2o_multithread_receiver_t *receiver, h2o_iovec_t name,
                     h2o_iovec_t serv, int family, int socktype, int protocol,
                     int flags, h2o_hostinfo_getaddr_cb cb, void *cbdata) {
  h2o_hostinfo_getaddr_req_t *req =
      h2o_mem_alloc(sizeof(*req) + name.len + 1 + serv.len + 1);
  req->_receiver = receiver;
  req->_cb = cb;
  req->cbdata = cbdata;
  req->_pending = (h2o_linklist_t){NULL};
  req->_in.name = (char *)req + sizeof(*req);
  memcpy(req->_in.name, name.base, name.len);
  req->_in.name[name.len] = '\0';
  req->_in.serv = req->_in.name + name.len + 1;
  memcpy(req->_in.serv, serv.base, serv.len);
  req->_in.serv[serv.len] = '\0';
  memset(&req->_in.hints, 0, sizeof(req->_in.hints));
  req->_in.hints.ai_family = family;
  req->_in.hints.ai_socktype = socktype;
  req->_in.hints.ai_protocol = protocol;
  req->_in.hints.ai_flags = flags;

  h2o__hostinfo_getaddr_dispatch(req);

  return req;
}"
darktable-org-darktable-32fab21/src/iop/colormapping.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_colormapping_params_t tmp = (dt_iop_colormapping_params_t){
      .flag = NEUTRAL, .n = 3, .dominance = 100.0f, .equalization = 50.0f};

  if (!module->dev)
    goto end;

  dt_iop_colormapping_gui_data_t *g =
      (dt_iop_colormapping_gui_data_t *)module->gui_data;
  if (module->dev->gui_attached && g && g->flowback_set) {
    memcpy(tmp.source_ihist, g->flowback.hist, sizeof(float) * HISTN);
    memcpy(tmp.source_mean, g->flowback.mean, sizeof(float) * MAXN * 2);
    memcpy(tmp.source_var, g->flowback.var, sizeof(float) * MAXN * 2);
    memcpy(tmp.source_weight, g->flowback.weight, sizeof(float) * MAXN);
    tmp.n = g->flowback.n;
    tmp.flag = HAS_SOURCE;
  }
  module->default_enabled = 0;

end:
  memcpy(module->default_params, &tmp, sizeof(dt_iop_colormapping_params_t));
  memcpy(module->params, &tmp, sizeof(dt_iop_colormapping_params_t));
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_hash.c	Notice that these Hash objects are designed for smaller collections and retain order of object insertion.	2	"FIOBJ fiobj_hash_new2(size_t capa) {
  fiobj_hash_s *h = fio_malloc(sizeof(*h));
  FIO_ASSERT_ALLOC(h);
  *h = (fiobj_hash_s){.head = {.ref = 1, .type = FIOBJ_T_HASH},
                      .hash = FIO_SET_INIT};
  fio_hash___capa_require(&h->hash, capa);
  return (FIOBJ)h | FIOBJECT_HASH_FLAG;
}"
Yeolar-coral-folly-01efac5/folly/futures/Future-inl.h	"like reduce, but calls func on finished futures as they complete does NOT keep the order of the input"	2	"Future<T> unorderedReduce(It first, It last, T initial, F func) {
  if (first == last) {
    return makeFuture(std::move(initial));
  }

  typedef isTry<Arg> IsTry;

  struct UnorderedReduceContext {
    UnorderedReduceContext(T &&memo, F &&fn, size_t n)
        : lock_(), memo_(makeFuture<T>(std::move(memo))), func_(std::move(fn)),
          numThens_(0), numFutures_(n), promise_(){};
    folly::MicroSpinLock lock_;
    Future<T> memo_;
    F func_;
    size_t numThens_;
    size_t numFutures_;
    Promise<T> promise_;
  };

  auto ctx = std::make_shared<UnorderedReduceContext>(
      std::move(initial), std::move(func), std::distance(first, last));

  mapSetCallback<ItT>(first, last, [ctx](size_t i, Try<ItT> &&t) {
    folly::MoveWrapper<Try<ItT>> mt(std::move(t));

    folly::MSLGuard lock(ctx->lock_);
    ctx->memo_ = ctx->memo_.then([ctx, mt](T &&v) mutable {
      return ctx->func_(std::move(v), mt->template get<IsTry::value, Arg &&>());
    });
    if (++ctx->numThens_ == ctx->numFutures_) {

      ctx->memo_.setCallback_(
          [ctx](Try<T> &&t2) { ctx->promise_.setValue(std::move(t2)); });
    }
  });

  return ctx->promise_.getFuture();
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the scalar portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion qscalar(const quaternion num) {
  const quaternion conj_num =
      (quaternion){num.R, num.i * -1.0, num.j * -1.0, num.k * -1.0};
  return (quaternion){(num.R + conj_num.R) * 0.5, (num.i + conj_num.i) * 0.5,
                      (num.j + conj_num.j) * 0.5, (num.k + conj_num.k) * 0.5};
}"
psyc-libpsyc-d16deca/src/packet.c	Initialize packet with raw content.	2	"psyc_packet_init_raw(PsycPacket *p, PsycModifier *routing, size_t routinglen,
                     char *content, size_t contentlen, PsycPacketFlag flag) {
  *p = (PsycPacket){
      .routing = {routinglen, routing},
      .entity = {0, 0},
      .method = {0, 0},
      .data = {0, 0},
      .content = {contentlen, content},
      .routinglen = 0,
      .contentlen = 0,
      .length = 0,
      .stateop = 0,
      .flag = flag,
  };

  if (flag == PSYC_PACKET_CHECK_LENGTH)
    p->flag = psyc_packet_length_check(p);

  psyc_packet_length_set(p);
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavformat/utils.c	Return the frame duration in seconds. Return 0 if not available.	2	"void ff_compute_frame_duration(AVFormatContext *s, int *pnum, int *pden,
                               AVStream *st, AVCodecParserContext *pc,
                               AVPacket *pkt) {
  AVRational codec_framerate =
      s->iformat ? st->codec->framerate
                 : av_mul_q(av_inv_q(st->codec->time_base),
                            (AVRational){1, st->codec->ticks_per_frame});
  int frame_size;

  *pnum = 0;
  *pden = 0;
  switch (st->codec->codec_type) {
  case AVMEDIA_TYPE_VIDEO:
    if (st->r_frame_rate.num && !pc && s->iformat) {
      *pnum = st->r_frame_rate.den;
      *pden = st->r_frame_rate.num;
    } else if (st->time_base.num * 1000LL > st->time_base.den) {
      *pnum = st->time_base.num;
      *pden = st->time_base.den;
    } else if (codec_framerate.den * 1000LL > codec_framerate.num) {
      av_assert0(st->codec->ticks_per_frame);
      av_reduce(pnum, pden, codec_framerate.den,
                codec_framerate.num * (int64_t)st->codec->ticks_per_frame,
                INT_MAX);

      if (pc && pc->repeat_pict) {
        av_assert0(s->iformat);
        av_reduce(pnum, pden, (*pnum) * (1LL + pc->repeat_pict), (*pden),
                  INT_MAX);
      }

      if (st->codec->ticks_per_frame > 1 && !pc)
        *pnum = *pden = 0;
    }
    break;
  case AVMEDIA_TYPE_AUDIO:
    frame_size = av_get_audio_frame_duration(st->codec, pkt->size);
    if (frame_size <= 0 || st->codec->sample_rate <= 0)
      break;
    *pnum = frame_size;
    *pden = st->codec->sample_rate;
    break;
  default:
    break;
  }
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the device sense data, indicating the current device state and error codes for the previously issued command."	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Request_Sense_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       SenseData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
openastroproject-openastro-ec7e71c/ext/ffmpeg/libavcodec/utils.c	"Decode the audio frame of size avpkt->size from avpkt->data into frame. Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with AV_CODEC_CAP_DELAY, then no samples will be returned."	2	"int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx,
                                              AVFrame *frame,
                                              int *got_frame_ptr,
                                              const AVPacket *avpkt) {
  AVCodecInternal *avci = avctx->internal;
  int ret = 0;

  *got_frame_ptr = 0;

  if (!avpkt->data && avpkt->size) {
    av_log(avctx, AV_LOG_ERROR, ""invalid packet: NULL data, size != 0\n"");
    return AVERROR(EINVAL);
  }
  if (!avctx->codec)
    return AVERROR(EINVAL);
  if (avctx->codec->type != AVMEDIA_TYPE_AUDIO) {
    av_log(avctx, AV_LOG_ERROR, ""Invalid media type for audio\n"");
    return AVERROR(EINVAL);
  }

  av_frame_unref(frame);

  if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size ||
      (avctx->active_thread_type & FF_THREAD_FRAME)) {
    uint8_t *side;
    int side_size;
    uint32_t discard_padding = 0;
    uint8_t skip_reason = 0;
    uint8_t discard_reason = 0;

    AVPacket tmp = *avpkt;
    int did_split = av_packet_split_side_data(&tmp);
    ret = apply_param_change(avctx, &tmp);
    if (ret < 0) {
      av_log(avctx, AV_LOG_ERROR, ""Error applying parameter changes.\n"");
      if (avctx->err_recognition & AV_EF_EXPLODE)
        goto fail;
    }

    avctx->internal->pkt = &tmp;
    if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
      ret = ff_thread_decode_frame(avctx, frame, got_frame_ptr, &tmp);
    else {
      ret = avctx->codec->decode(avctx, frame, got_frame_ptr, &tmp);
      av_assert0(ret <= tmp.size);
      frame->pkt_dts = avpkt->dts;
    }
    if (ret >= 0 && *got_frame_ptr) {
      avctx->frame_number++;
      av_frame_set_best_effort_timestamp(
          frame, guess_correct_pts(avctx, frame->pkt_pts, frame->pkt_dts));
      if (frame->format == AV_SAMPLE_FMT_NONE)
        frame->format = avctx->sample_fmt;
      if (!frame->channel_layout)
        frame->channel_layout = avctx->channel_layout;
      if (!av_frame_get_channels(frame))
        av_frame_set_channels(frame, avctx->channels);
      if (!frame->sample_rate)
        frame->sample_rate = avctx->sample_rate;
    }

    side = av_packet_get_side_data(avctx->internal->pkt,
                                   AV_PKT_DATA_SKIP_SAMPLES, &side_size);
    if (side && side_size >= 10) {
      avctx->internal->skip_samples = AV_RL32(side);
      discard_padding = AV_RL32(side + 4);
      av_log(avctx, AV_LOG_DEBUG,
             ""skip %d / discard %d samples due to side data\n"",
             avctx->internal->skip_samples, (int)discard_padding);
      skip_reason = AV_RL8(side + 8);
      discard_reason = AV_RL8(side + 9);
    }
    if (avctx->internal->skip_samples > 0 && *got_frame_ptr &&
        !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (frame->nb_samples <= avctx->internal->skip_samples) {
        *got_frame_ptr = 0;
        avctx->internal->skip_samples -= frame->nb_samples;
        av_log(avctx, AV_LOG_DEBUG, ""skip whole frame, skip left: %d\n"",
               avctx->internal->skip_samples);
      } else {
        av_samples_copy(frame->extended_data, frame->extended_data, 0,
                        avctx->internal->skip_samples,
                        frame->nb_samples - avctx->internal->skip_samples,
                        avctx->channels, frame->format);
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(avctx->internal->skip_samples,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (frame->pkt_pts != AV_NOPTS_VALUE)
            frame->pkt_pts += diff_ts;
          if (frame->pkt_dts != AV_NOPTS_VALUE)
            frame->pkt_dts += diff_ts;
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for skipped samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""skip %d/%d samples\n"",
               avctx->internal->skip_samples, frame->nb_samples);
        frame->nb_samples -= avctx->internal->skip_samples;
        avctx->internal->skip_samples = 0;
      }
    }

    if (discard_padding > 0 && discard_padding <= frame->nb_samples &&
        *got_frame_ptr && !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (discard_padding == frame->nb_samples) {
        *got_frame_ptr = 0;
      } else {
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for discarded samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""discard %d/%d samples\n"",
               (int)discard_padding, frame->nb_samples);
        frame->nb_samples -= discard_padding;
      }
    }

    if ((avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL) && *got_frame_ptr) {
      AVFrameSideData *fside =
          av_frame_new_side_data(frame, AV_FRAME_DATA_SKIP_SAMPLES, 10);
      if (fside) {
        AV_WL32(fside->data, avctx->internal->skip_samples);
        AV_WL32(fside->data + 4, discard_padding);
        AV_WL8(fside->data + 8, skip_reason);
        AV_WL8(fside->data + 9, discard_reason);
        avctx->internal->skip_samples = 0;
      }
    }
  fail:
    avctx->internal->pkt = NULL;
    if (did_split) {
      av_packet_free_side_data(&tmp);
      if (ret == tmp.size)
        ret = avpkt->size;
    }

    if (ret >= 0 && *got_frame_ptr) {
      if (!avctx->refcounted_frames) {
        int err = unrefcount_frame(avci, frame);
        if (err < 0)
          return err;
      }
    } else
      av_frame_unref(frame);
  }

  return ret;
}"
jaruiz-ION-f6dc541/tools/ion32sim/src/ion32sim.c	Logs last cycle's activity (changes in state and/or loads/stores)	2	"uint32_t log_cycle(t_state *s) {
  static unsigned int last_pc = 0;
  int i;
  uint32_t log_pc;

  if (s->pc != (last_pc + 4)) {
    s->t.buf[s->t.next] = s->pc;
    s->t.next = (s->t.next + 1) % TRACE_BUFFER_SIZE;
  }
  last_pc = s->pc;
  log_pc = s->op_addr;

  if (log_enabled(s)) {

    for (i = 1; i < 32; i++) {
      if (s->t.pr[i] != s->r[i]) {
        fprintf(s->t.log, ""(%08x) [%02x]=%08x\n"", log_pc, i, s->r[i]);
      }
      s->t.pr[i] = s->r[i];
    }
    if (s->lo != s->t.lo) {
    }
    s->t.lo = s->lo;

    if (s->hi != s->t.hi) {
    }
    s->t.hi = s->hi;

    s->t.epc = s->epc;

    if (s->cp0_status != s->t.status) {

#if 0
            fprintf(s->t.log, ""(%08x) [01]=%08x\n"", 0x0  , s->cp0_status & STATUS_MASK);
#endif
    }
    s->t.status = s->cp0_status & STATUS_MASK;

    if (s->sr_load_pending) {
      s->cp0_status = s->sr_load_pending_value & STATUS_MASK;
      s->sr_load_pending = false;
    }
  }

#if 0
     
    if(1){
            if((s->r[29]&0xffff0000) == 0xffff00000){
                printf(""SP derailed! @ 0x%08x [0x%08x]\n"", log_pc, s->r[29]);
                return 1;
            }
    }
#endif

  return 0;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered."	2	"uint8_t MS_Host_PreventAllowMediumRemoval(
    USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex,
    const bool PreventRemoval) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = COMMAND_DIRECTION_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
opticron-libuweave-2e5e385/src/counters.c	Initializes a UwCounterSet for the specific set of application counter ids. The list of individual counter ids allows the counter-set to evolve over time while maintaining consistent counter ids that can be non-sequential. The app_counter_counter parameter must match the app_counter_count for uw_counter_set_sizeof().	2	"void uw_counter_set_init(UwCounterSet *counter_set, const UwCounterId app_ids[],
                         size_t app_counter_count) {
  UwCounter *uw_counters =
      (UwCounter *)((void *)counter_set + sizeof(UwCounterSet));
  UwCounter *app_counters =
      (UwCounter *)((void *)counter_set + sizeof(UwCounterSet) +
                    sizeof(UwCounter) * kUwInternalCounterLast);

  *counter_set = (UwCounterSet){.uw_counter_count = kUwInternalCounterLast,
                                .uw_counters = uw_counters,
                                .app_counter_count = app_counter_count,
                                .app_counters = app_counters};

  if (uwp_time_is_time_set()) {
    counter_set->generation_time = uw_time_get_timestamp_seconds_();
  }

  for (size_t i = 0; i < kUwInternalCounterLast; ++i) {
    uw_counters[i] = (UwCounter){.id = i};
  }

  for (size_t i = 0; i < app_counter_count; ++i) {
    app_counters[i] = (UwCounter){.id = app_ids[i]};
  }
}"
svenanders-Crystalis-objc-a74bec0/crystalwiper/libs/cocos2d/ccTypes.h	helper that creates a ccColor4f type	2	"ccc4f(const GLfloat r, const GLfloat g, const GLfloat b, const GLfloat a) {
  return (ccColor4F){r, g, b, a};
}"
opalenzuela-opendomo-1adadbd/src/odcgi/src/script.c	Process a comments line and format the output in HTML or XML.	2	"script_process_comments(const char *buf) {
  char tipname[50];
  char *classname = NULL;
  char *contents = NULL;

  if (strlen(buf) < 3)
    return;

  if (gui == html) {
    if ((buf[0] == '-') && (buf[1] == '-')) {
      printf(""\t<hr/>\n"");
    } else if (SPELL3(buf, 'E', 'R', 'R')) {
      printf(""\t<p class='error'>%s</p>\n"", T(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R')) {
      printf(""\t<p class='warning'>%s</p>\n"", T(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F')) {
      printf(""\t<p class='info'>%s</p>\n"", T(buf += 5));
    } else if (SPELL3(buf, 'L', 'O', 'A')) {

      printf(""\t<p class='loading'>%s</p>\n"", T(buf += 8));

      printf(""<script type='text/Javascript'>\n""
             ""$(function($){\n""
             ""	$('p.loading').hide() ;\n""
             ""});\n""
             ""</script>\n"");
    } else if (SPELL3(buf, 'U', 'R', 'L')) {
      printf(""\t<p class='link'>""
             ""<a href='%s' target='_blank'>%s</a></p>\n"",
             buf += 4, buf);
    } else if (SPELL3(buf, 'T', 'I', 'P')) {
      for (int i = 4; i < 100; i++) {
        if (buf[i] == ')' || buf[i] == 0) {
          i++;
          printf(""\t<div id='%s_tt' class='tooltip'>%s</div>\n"", tipname,
                 T(buf += i));
          printf(""<script>\n""
                 ""$(\""#%s_lbl\"").on('mouseenter',function(){showTT('%s');})\n""
                 ""$(\""#%s_lbl\"").on('mouseleave',function(){hideTT('%s');})\n""
                 ""</script>"",
                 tipname, tipname, tipname, tipname);
          return;
        } else {
          tipname[i - 4] = buf[i];
          tipname[i - 3] = 0;
        }
      }
    } else if (buf[0] == '>') {
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    } else {

      if (buf[0] == ' ') {
        printf(""\t<p class='comments'>%s</p>\n"", T(buf += 1));
      } else {
        classname = strtok(buf, "" "");
        contents = strtok(NULL, ""\n"");

        printf(""\t<p class='%s'>%s</p>\n"", classname, T(contents));
      }
    }
  } else {
    if (SPELL3(buf, 'E', 'R', 'R') || SPELL3(buf, 'e', 'r', 'r')) {
      printf(""\t<error description='%s'/>\n"", CT(buf += 4));
      fflush(stdout);
    } else if (SPELL3(buf, 'W', 'A', 'R') || SPELL3(buf, 'w', 'a', 'r')) {
      printf(""\t<warning description='%s'/>\n"", CT(buf += 5));
      fflush(stdout);
    } else if (SPELL3(buf, 'I', 'N', 'F') || SPELL3(buf, 'i', 'n', 'f'))
      printf(""\t<info description='%s'/>\n"", CT(buf += 5));
    else if (buf[0] == '>')
      sstrncpy(legend, T(buf += 1), sizeof(legend));
    else
      printf(""\t<message description='%s'/>\n"", CT(buf += 1));
  }
}"
timowest-flauta-58dd8e3/orig/stk/Stk.h	Remove class pointer from list for sample rate change notification.	2	"virtual ~StkError(void){};

virtual void printMessage(void) { std::cerr << '\n' << message_ << ""\n\n""; }

virtual const Type &getType(void) { return type_; }"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libpostproc/postprocess.c	Return a pp_mode or NULL if an error occurred.	2	"pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality) {
  char temp[GET_MODE_BUFFER_SIZE];
  char *p = temp;
  static const char filterDelimiters[] = "",/"";
  static const char optionDelimiters[] = "":|"";
  struct PPMode *ppMode;
  char *filterToken;

  if (!name) {
    av_log(NULL, AV_LOG_ERROR, ""pp: Missing argument\n"");
    return NULL;
  }

  if (!strcmp(name, ""help"")) {
    const char *p;
    for (p = pp_help; strchr(p, '\n'); p = strchr(p, '\n') + 1) {
      av_strlcpy(temp, p, FFMIN(sizeof(temp), strchr(p, '\n') - p + 2));
      av_log(NULL, AV_LOG_INFO, ""%s"", temp);
    }
    return NULL;
  }

  ppMode = av_malloc(sizeof(PPMode));
  if (!ppMode)
    return NULL;

  ppMode->lumMode = 0;
  ppMode->chromMode = 0;
  ppMode->maxTmpNoise[0] = 700;
  ppMode->maxTmpNoise[1] = 1500;
  ppMode->maxTmpNoise[2] = 3000;
  ppMode->maxAllowedY = 234;
  ppMode->minAllowedY = 16;
  ppMode->baseDcDiff = 256 / 8;
  ppMode->flatnessThreshold = 56 - 16 - 1;
  ppMode->maxClippedThreshold = (AVRational){1, 100};
  ppMode->error = 0;

  memset(temp, 0, GET_MODE_BUFFER_SIZE);
  av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);

  av_log(NULL, AV_LOG_DEBUG, ""pp: %s\n"", name);

  for (;;) {
    const char *filterName;
    int q = 1000000;
    int chrom = -1;
    int luma = -1;
    const char *option;
    const char *options[OPTIONS_ARRAY_SIZE];
    int i;
    int filterNameOk = 0;
    int numOfUnknownOptions = 0;
    int enable = 1;
    char *tokstate;

    filterToken = av_strtok(p, filterDelimiters, &tokstate);
    if (!filterToken)
      break;
    p += strlen(filterToken) + 1;
    filterName = av_strtok(filterToken, optionDelimiters, &tokstate);
    if (!filterName) {
      ppMode->error++;
      break;
    }
    av_log(NULL, AV_LOG_DEBUG, ""pp: %s::%s\n"", filterToken, filterName);

    if (*filterName == '-') {
      enable = 0;
      filterName++;
    }

    for (;;) {
      option = av_strtok(NULL, optionDelimiters, &tokstate);
      if (!option)
        break;

      av_log(NULL, AV_LOG_DEBUG, ""pp: option: %s\n"", option);
      if (!strcmp(""autoq"", option) || !strcmp(""a"", option))
        q = quality;
      else if (!strcmp(""nochrom"", option) || !strcmp(""y"", option))
        chrom = 0;
      else if (!strcmp(""chrom"", option) || !strcmp(""c"", option))
        chrom = 1;
      else if (!strcmp(""noluma"", option) || !strcmp(""n"", option))
        luma = 0;
      else {
        options[numOfUnknownOptions] = option;
        numOfUnknownOptions++;
      }
      if (numOfUnknownOptions >= OPTIONS_ARRAY_SIZE - 1)
        break;
    }
    options[numOfUnknownOptions] = NULL;

    for (i = 0; replaceTable[2 * i]; i++) {
      if (!strcmp(replaceTable[2 * i], filterName)) {
        size_t newlen = strlen(replaceTable[2 * i + 1]);
        int plen;
        int spaceLeft;

        p--, *p = ',';

        plen = strlen(p);
        spaceLeft = p - temp + plen;
        if (spaceLeft + newlen >= GET_MODE_BUFFER_SIZE - 1) {
          ppMode->error++;
          break;
        }
        memmove(p + newlen, p, plen + 1);
        memcpy(p, replaceTable[2 * i + 1], newlen);
        filterNameOk = 1;
      }
    }

    for (i = 0; filters[i].shortName; i++) {
      if (!strcmp(filters[i].longName, filterName) ||
          !strcmp(filters[i].shortName, filterName)) {
        ppMode->lumMode &= ~filters[i].mask;
        ppMode->chromMode &= ~filters[i].mask;

        filterNameOk = 1;
        if (!enable)
          break;

        if (q >= filters[i].minLumQuality && luma)
          ppMode->lumMode |= filters[i].mask;
        if (chrom == 1 || (chrom == -1 && filters[i].chromDefault))
          if (q >= filters[i].minChromQuality)
            ppMode->chromMode |= filters[i].mask;

        if (filters[i].mask == LEVEL_FIX) {
          int o;
          ppMode->minAllowedY = 16;
          ppMode->maxAllowedY = 234;
          for (o = 0; options[o]; o++) {
            if (!strcmp(options[o], ""fullyrange"") || !strcmp(options[o], ""f"")) {
              ppMode->minAllowedY = 0;
              ppMode->maxAllowedY = 255;
              numOfUnknownOptions--;
            }
          }
        } else if (filters[i].mask == TEMP_NOISE_FILTER) {
          int o;
          int numOfNoises = 0;

          for (o = 0; options[o]; o++) {
            char *tail;
            ppMode->maxTmpNoise[numOfNoises] = strtol(options[o], &tail, 0);
            if (tail != options[o]) {
              numOfNoises++;
              numOfUnknownOptions--;
              if (numOfNoises >= 3)
                break;
            }
          }
        } else if (filters[i].mask == V_DEBLOCK ||
                   filters[i].mask == H_DEBLOCK ||
                   filters[i].mask == V_A_DEBLOCK ||
                   filters[i].mask == H_A_DEBLOCK) {
          int o;

          for (o = 0; options[o] && o < 2; o++) {
            char *tail;
            int val = strtol(options[o], &tail, 0);
            if (tail == options[o])
              break;

            numOfUnknownOptions--;
            if (o == 0)
              ppMode->baseDcDiff = val;
            else
              ppMode->flatnessThreshold = val;
          }
        } else if (filters[i].mask == FORCE_QUANT) {
          int o;
          ppMode->forcedQuant = 15;

          for (o = 0; options[o] && o < 1; o++) {
            char *tail;
            int val = strtol(options[o], &tail, 0);
            if (tail == options[o])
              break;

            numOfUnknownOptions--;
            ppMode->forcedQuant = val;
          }
        }
      }
    }
    if (!filterNameOk)
      ppMode->error++;
    ppMode->error += numOfUnknownOptions;
  }

  av_log(NULL, AV_LOG_DEBUG, ""pp: lumMode=%X, chromMode=%X\n"", ppMode->lumMode,
         ppMode->chromMode);
  if (ppMode->error) {
    av_log(NULL, AV_LOG_ERROR, ""%d errors in postprocess string \""%s\""\n"",
           ppMode->error, name);
    av_free(ppMode);
    return NULL;
  }
  return ppMode;
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	"Hard thresholding (with strides) y = HT(x, k), selects k largest elements of x computes y = x * (abs(x) > t(k)), k = threshold index of sorted x, t(k)= value of sorted x at k"	2	"void md_zhardthresh2(unsigned int D, const long dims[D], unsigned int k,
                     unsigned int flags, const long ostrs[D],
                     complex float *optr, const long istrs[D],
                     const complex float *iptr) {
  NESTED(void, nary_zhardthresh, (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->zhardthresh(data->size, k, ptr[0], ptr[1]);
  };

  if (0 == flags) {

    optimized_twoop_oi(D, dims, ostrs, optr, istrs, iptr,
                       (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zhardthresh);
    return;
  }

  long norm_dims[D];
  md_select_dims(D, ~flags, norm_dims, dims);

  complex float *tmp_norm = md_alloc_sameplace(D, norm_dims, CFL_SIZE, iptr);
  md_zhardthresh_joint2(D, dims, k, flags, tmp_norm, ostrs, optr, istrs, iptr);

  md_free(tmp_norm);
}"
asmodehn-wkcmake-ac4e0cc/Utils/astyle/src/astyle.h	build vectors for each programing language depending on the file extension.	2	"static const string AS_QUESTION, AS_COLON, AS_SEMICOLON, AS_COMMA;
static const string AS_ASM;
static const string AS_FOREACH, AS_LOCK, AS_UNSAFE, AS_FIXED;
static const string AS_GET, AS_SET, AS_ADD, AS_REMOVE;
static const string AS_CONST_CAST, AS_DYNAMIC_CAST, AS_REINTERPRET_CAST,
    AS_STATIC_CAST;
}
;

class ASBase {
private:
  int fileType;

protected:
  ASBase(){};
  ~ASBase(){};

  bool findKeyword(const string &line, int i, const string &keyword) const;
  string getCurrentWord(const string &line, size_t charNum) const;

protected:
  void init(int fileTypeArg) { fileType = fileTypeArg; }
  bool isCStyle() const { return (fileType == C_TYPE); }
  bool isJavaStyle() const { return (fileType == JAVA_TYPE); }
  bool isSharpStyle() const { return (fileType == SHARP_TYPE); }"
Japh-FlipClock-df892d6/src/flipclock.c	Animate a single digit.	2	"static void animate_digit(const uint8_t layer_id, const uint8_t old,
                          const uint8_t new) {
  APP_LOG(APP_LOG_LEVEL_DEBUG, ""animate_digit(%d, %d, %d)"", layer_id, old, new);

  if (new == old) {
    return;
  }

  const uint8_t anim_layer_id = layer_id * 2;

  if (layer_id == DAY_ONES) {

    return;
  } else if (layer_id == DAY_TENS) {

    return;
  } else if (layer_id == MONTH) {
    return;
  }

  AnimationHandlers handlers = {.started = NULL, .stopped = NULL};
  context[layer_id] = (AnimationContext){
      .layer_id = anim_layer_id, .prev_value = old, .value = new};
  animation_set_handlers(animation[layer_id], handlers, &context[layer_id]);

  animation_schedule(animation[layer_id]);
}"
opticron-libuweave-2e5e385/src/session.c	Clears a session on client disconnect or timeout.	2	"void uw_session_invalidate_(UwSession *session) {
  *session = (UwSession){.device = session->device, .role = kUwRoleUnspecified};
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m1/amffmpeg/libavdevice/x11grab.c	Initialize the x11 grab device demuxer (public device demuxer API).	0	"x11grab_read_header(AVFormatContext *s1, AVFormatParameters *ap) {
  struct x11_grab *x11grab = s1->priv_data;
  Display *dpy;
  AVStream *st = NULL;
  enum PixelFormat input_pixfmt;
  XImage *image;
  int x_off = 0;
  int y_off = 0;
  int use_shm;
  char *dpyname, *offset;
  int ret = 0;
  AVRational framerate;

  dpyname = av_strdup(s1->filename);
  offset = strchr(dpyname, '+');
  if (offset) {
    sscanf(offset, ""%d,%d"", &x_off, &y_off);
    x11grab->nomouse = strstr(offset, ""nomouse"");
    *offset = 0;
  }

  if ((ret = av_parse_video_size(&x11grab->width, &x11grab->height,
                                 x11grab->video_size)) < 0) {
    av_log(s1, AV_LOG_ERROR, ""Couldn't parse video size.\n"");
    goto out;
  }
  if ((ret = av_parse_video_rate(&framerate, x11grab->framerate)) < 0) {
    av_log(s1, AV_LOG_ERROR, ""Could not parse framerate: %s.\n"",
           x11grab->framerate);
    goto out;
  }
#if FF_API_FORMAT_PARAMETERS
  if (ap->width > 0)
    x11grab->width = ap->width;
  if (ap->height > 0)
    x11grab->height = ap->height;
  if (ap->time_base.num)
    framerate = (AVRational){ap->time_base.den, ap->time_base.num};
#endif
  av_log(s1, AV_LOG_INFO,
         ""device: %s -> display: %s x: %d y: %d width: %d height: %d\n"",
         s1->filename, dpyname, x_off, y_off, x11grab->width, x11grab->height);

  dpy = XOpenDisplay(dpyname);
  av_freep(&dpyname);
  if (!dpy) {
    av_log(s1, AV_LOG_ERROR, ""Could not open X display.\n"");
    ret = AVERROR(EIO);
    goto out;
  }

  st = av_new_stream(s1, 0);
  if (!st) {
    ret = AVERROR(ENOMEM);
    goto out;
  }
  av_set_pts_info(st, 64, 1, 1000000);

  use_shm = XShmQueryExtension(dpy);
  av_log(s1, AV_LOG_INFO, ""shared memory extension%s found\n"",
         use_shm ? """" : "" not"");

  if (use_shm) {
    int scr = XDefaultScreen(dpy);
    image = XShmCreateImage(dpy, DefaultVisual(dpy, scr),
                            DefaultDepth(dpy, scr), ZPixmap, NULL,
                            &x11grab->shminfo, x11grab->width, x11grab->height);
    x11grab->shminfo.shmid = shmget(
        IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT | 0777);
    if (x11grab->shminfo.shmid == -1) {
      av_log(s1, AV_LOG_ERROR, ""Fatal: Can't get shared memory!\n"");
      ret = AVERROR(ENOMEM);
      goto out;
    }
    x11grab->shminfo.shmaddr = image->data =
        shmat(x11grab->shminfo.shmid, 0, 0);
    x11grab->shminfo.readOnly = False;

    if (!XShmAttach(dpy, &x11grab->shminfo)) {
      av_log(s1, AV_LOG_ERROR, ""Fatal: Failed to attach shared memory!\n"");

      ret = AVERROR(EIO);
      goto out;
    }
  } else {
    image = XGetImage(dpy, RootWindow(dpy, DefaultScreen(dpy)), x_off, y_off,
                      x11grab->width, x11grab->height, AllPlanes, ZPixmap);
  }

  switch (image->bits_per_pixel) {
  case 8:
    av_log(s1, AV_LOG_DEBUG, ""8 bit palette\n"");
    input_pixfmt = PIX_FMT_PAL8;
    break;
  case 16:
    if (image->red_mask == 0xf800 && image->green_mask == 0x07e0 &&
        image->blue_mask == 0x001f) {
      av_log(s1, AV_LOG_DEBUG, ""16 bit RGB565\n"");
      input_pixfmt = PIX_FMT_RGB565;
    } else if (image->red_mask == 0x7c00 && image->green_mask == 0x03e0 &&
               image->blue_mask == 0x001f) {
      av_log(s1, AV_LOG_DEBUG, ""16 bit RGB555\n"");
      input_pixfmt = PIX_FMT_RGB555;
    } else {
      av_log(s1, AV_LOG_ERROR,
             ""RGB ordering at image depth %i not supported ... aborting\n"",
             image->bits_per_pixel);
      av_log(s1, AV_LOG_ERROR, ""color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n"",
             image->red_mask, image->green_mask, image->blue_mask);
      ret = AVERROR(EIO);
      goto out;
    }
    break;
  case 24:
    if (image->red_mask == 0xff0000 && image->green_mask == 0x00ff00 &&
        image->blue_mask == 0x0000ff) {
      input_pixfmt = PIX_FMT_BGR24;
    } else if (image->red_mask == 0x0000ff && image->green_mask == 0x00ff00 &&
               image->blue_mask == 0xff0000) {
      input_pixfmt = PIX_FMT_RGB24;
    } else {
      av_log(s1, AV_LOG_ERROR,
             ""rgb ordering at image depth %i not supported ... aborting\n"",
             image->bits_per_pixel);
      av_log(s1, AV_LOG_ERROR, ""color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\n"",
             image->red_mask, image->green_mask, image->blue_mask);
      ret = AVERROR(EIO);
      goto out;
    }
    break;
  case 32:
#if 0
        GetColorInfo (image, &c_info);
        if ( c_info.alpha_mask == 0xff000000 && image->green_mask == 0x0000ff00) {
             
            input_pixfmt = PIX_FMT_ARGB32;
        }  else {
            av_log(s1, AV_LOG_ERROR,""image depth %i not supported ... aborting\n"", image->bits_per_pixel);
            return AVERROR(EIO);
        }
#endif
    input_pixfmt = PIX_FMT_RGB32;
    break;
  default:
    av_log(s1, AV_LOG_ERROR, ""image depth %i not supported ... aborting\n"",
           image->bits_per_pixel);
    ret = AVERROR(EINVAL);
    goto out;
  }

  x11grab->frame_size =
      x11grab->width * x11grab->height * image->bits_per_pixel / 8;
  x11grab->dpy = dpy;
  x11grab->time_base = (AVRational){framerate.den, framerate.num};
  x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);
  x11grab->x_off = x_off;
  x11grab->y_off = y_off;
  x11grab->image = image;
  x11grab->use_shm = use_shm;

  st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
  st->codec->codec_id = CODEC_ID_RAWVIDEO;
  st->codec->width = x11grab->width;
  st->codec->height = x11grab->height;
  st->codec->pix_fmt = input_pixfmt;
  st->codec->time_base = x11grab->time_base;
  st->codec->bit_rate =
      x11grab->frame_size * 1 / av_q2d(x11grab->time_base) * 8;

out:
  return ret;
}"
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/ccnxCodec_TlvDecoder.h	"Advance the decoder a given number of bytes Advance the decoder, throwing away a given number of bytes. If there are not enough bytes left in the decoder, no action is taken"	0	"*@code * {
  ****PARCBuffer *input = parcBuffer_Wrap(
      (uint8_t[]){0xAA, 0xBB, 0x00, 0x04, 0x01, 0x02, 0x03, 0x04}, 8, 0, 8);
  *CCNxCodecTlvDecoder *decoder = ccnxCodecTlvDecoder_Create(input);
  *unsigned type = ccnxCodecTlvDecoder_GetType(decoder);
  *unsigned length = ccnxCodecTlvDecoder_GetLength(decoder);
  *PARCBuffer *value = ccnxCodecTlvDecoder_GetValue(decoder, length);
  **
}"
libfirm-cparser-be2d414/src/ast/types.c	Initialize predefined types. This has to be called after setting up the language dialect.	2	"void init_predefined_types(void) {
  static const type_base_t error = {TYPE_ERROR, TYPE_QUALIFIER_NONE, NULL};

  type_error_type = (type_t *)&error;
  type_bool = make_atomic_type(ATOMIC_TYPE_BOOL, TYPE_QUALIFIER_NONE);
  type_signed_char = make_atomic_type(ATOMIC_TYPE_SCHAR, TYPE_QUALIFIER_NONE);
  type_unsigned_char = make_atomic_type(ATOMIC_TYPE_UCHAR, TYPE_QUALIFIER_NONE);
  type_short = make_atomic_type(ATOMIC_TYPE_SHORT, TYPE_QUALIFIER_NONE);
  type_unsigned_short =
      make_atomic_type(ATOMIC_TYPE_USHORT, TYPE_QUALIFIER_NONE);
  type_int = make_atomic_type(ATOMIC_TYPE_INT, TYPE_QUALIFIER_NONE);
  type_unsigned_int = make_atomic_type(ATOMIC_TYPE_UINT, TYPE_QUALIFIER_NONE);
  type_long = make_atomic_type(ATOMIC_TYPE_LONG, TYPE_QUALIFIER_NONE);
  type_unsigned_long = make_atomic_type(ATOMIC_TYPE_ULONG, TYPE_QUALIFIER_NONE);
  type_long_long = make_atomic_type(ATOMIC_TYPE_LONGLONG, TYPE_QUALIFIER_NONE);
  type_unsigned_long_long =
      make_atomic_type(ATOMIC_TYPE_ULONGLONG, TYPE_QUALIFIER_NONE);
  type_long_double =
      make_atomic_type(ATOMIC_TYPE_LONG_DOUBLE, TYPE_QUALIFIER_NONE);
  type_double = make_atomic_type(ATOMIC_TYPE_DOUBLE, TYPE_QUALIFIER_NONE);
  type_float = make_atomic_type(ATOMIC_TYPE_FLOAT, TYPE_QUALIFIER_NONE);
  type_char = make_atomic_type(ATOMIC_TYPE_CHAR, TYPE_QUALIFIER_NONE);

  type_void = make_void_type(TYPE_QUALIFIER_NONE);
  type_const_void = make_void_type(TYPE_QUALIFIER_CONST);

  type_builtin_template = allocate_type_zero(TYPE_BUILTIN_TEMPLATE);
  type_builtin_template = identify_new_type(type_builtin_template);

  int8_type_kind = find_signed_int_atomic_type_kind_for_size(1);
  int16_type_kind = find_signed_int_atomic_type_kind_for_size(2);
  int32_type_kind = find_signed_int_atomic_type_kind_for_size(4);
  int64_type_kind = find_signed_int_atomic_type_kind_for_size(8);

  type_int32_t = make_atomic_type(int32_type_kind, TYPE_QUALIFIER_NONE);
  type_int64_t = make_atomic_type(int64_type_kind, TYPE_QUALIFIER_NONE);

  type_void_ptr = make_pointer_type(type_void, TYPE_QUALIFIER_NONE);
  type_const_void_ptr = make_pointer_type(type_const_void, TYPE_QUALIFIER_NONE);
  type_void_ptr_restrict =
      make_pointer_type(type_void, TYPE_QUALIFIER_RESTRICT);
  type_const_void_ptr_restrict =
      make_pointer_type(type_const_void, TYPE_QUALIFIER_RESTRICT);
  type_char_ptr = make_pointer_type(type_char, TYPE_QUALIFIER_NONE);
  type_char_ptr_restrict =
      make_pointer_type(type_char, TYPE_QUALIFIER_RESTRICT);
  type_signed_char_ptr =
      make_pointer_type(type_signed_char, TYPE_QUALIFIER_NONE);
  type_short_ptr = make_pointer_type(type_short, TYPE_QUALIFIER_NONE);
  type_int_ptr = make_pointer_type(type_int, TYPE_QUALIFIER_NONE);
  type_long_ptr = make_pointer_type(type_long, TYPE_QUALIFIER_NONE);
  type_unsigned_char_ptr =
      make_pointer_type(type_unsigned_char, TYPE_QUALIFIER_NONE);
  type_unsigned_short_ptr =
      make_pointer_type(type_unsigned_short, TYPE_QUALIFIER_NONE);
  type_unsigned_int_ptr =
      make_pointer_type(type_unsigned_int, TYPE_QUALIFIER_NONE);
  type_unsigned_long_ptr =
      make_pointer_type(type_unsigned_long, TYPE_QUALIFIER_NONE);
  type_unsigned_long_long_ptr =
      make_pointer_type(type_unsigned_long, TYPE_QUALIFIER_NONE);
  type_long_long_ptr = make_pointer_type(type_long_long, TYPE_QUALIFIER_NONE);
  type_long_double_ptr =
      make_pointer_type(type_long_double, TYPE_QUALIFIER_NONE);
  type_double_ptr = make_pointer_type(type_double, TYPE_QUALIFIER_NONE);
  type_float_ptr = make_pointer_type(type_float, TYPE_QUALIFIER_NONE);

  type_char_ptr_ptr = make_pointer_type(type_char_ptr, TYPE_QUALIFIER_NONE);

  type_builtin_template_ptr =
      make_pointer_type(type_builtin_template, TYPE_QUALIFIER_NONE);

  ir_type *va_list_type = ir_platform_va_list_type();
  if (!va_list_type) {

    type_valist = type_error_type;
    type_valist_arg = type_error_type;
  } else if (is_Pointer_type(va_list_type)) {
    type_valist = type_void_ptr;
    type_valist_arg = type_void_ptr;
  } else if (is_Struct_type(va_list_type)) {
    entity_t *ent = allocate_entity_zero(ENTITY_STRUCT, NAMESPACE_NORMAL,
                                         sym_anonymous, &builtin_position);
    ent->compound.alignment = get_type_alignment(va_list_type);
    ent->compound.size = get_type_size(va_list_type);
    ent->compound.complete = true;
    ent->compound.members =
        (scope_t){.first_entity = NULL, .last_entity = NULL, .depth = 0};

    type_t *type_valist_struct = allocate_type_zero(TYPE_COMPOUND_STRUCT);
    type_valist_struct->base.firm_type = va_list_type;
    type_valist_struct->compound.compound = &ent->compound;

    type_valist = make_array_type(type_valist_struct, 1, TYPE_QUALIFIER_NONE);
    type_valist_arg = automatic_type_conversion(type_valist);
  }

  type_const_char = make_atomic_type(ATOMIC_TYPE_CHAR, TYPE_QUALIFIER_CONST);
  type_const_char_ptr = make_pointer_type(type_const_char, TYPE_QUALIFIER_NONE);
  type_const_char_ptr_restrict =
      make_pointer_type(type_const_char, TYPE_QUALIFIER_RESTRICT);

  type_intmax_t = type_long_long;
  type_uintmax_t = type_unsigned_long_long;
  type_wint_t = type_unsigned_int;
  type_intmax_t_ptr = make_pointer_type(type_intmax_t, TYPE_QUALIFIER_NONE);
  type_uintmax_t_ptr = make_pointer_type(type_uintmax_t, TYPE_QUALIFIER_NONE);
  type_ptrdiff_t_ptr = make_pointer_type(type_ptrdiff_t, TYPE_QUALIFIER_NONE);
  type_uptrdiff_t_ptr = make_pointer_type(type_uptrdiff_t, TYPE_QUALIFIER_NONE);
  type_ssize_t_ptr = make_pointer_type(type_ssize_t, TYPE_QUALIFIER_NONE);
  type_size_t_ptr = make_pointer_type(type_size_t, TYPE_QUALIFIER_NONE);

  atomic_type_kind_t const u2 = find_unsigned_int_atomic_type_kind_for_size(2);
  type_char16_t = make_atomic_type(u2, TYPE_QUALIFIER_NONE);
  type_char16_t_const = make_atomic_type(u2, TYPE_QUALIFIER_CONST);
  type_char16_t_ptr = make_pointer_type(type_char16_t, TYPE_QUALIFIER_NONE);
  type_char16_t_const_ptr =
      make_pointer_type(type_char16_t_const, TYPE_QUALIFIER_NONE);

  atomic_type_kind_t const u4 = find_unsigned_int_atomic_type_kind_for_size(4);
  type_char32_t = make_atomic_type(u4, TYPE_QUALIFIER_NONE);
  type_char32_t_const = make_atomic_type(u4, TYPE_QUALIFIER_CONST);
  type_char32_t_ptr = make_pointer_type(type_char32_t, TYPE_QUALIFIER_NONE);
  type_char32_t_const_ptr =
      make_pointer_type(type_char32_t_const, TYPE_QUALIFIER_NONE);

  if (dialect.ms)
    init_ms_types();
}"
pando-project-jerryscript-772ab27/jerry-core/api/jerry.c	Get heap memory stats.	2	"jerry_get_memory_stats(jerry_heap_stats_t *out_stats_p) {
#ifdef JMEM_STATS
  if (out_stats_p == NULL) {
    return false;
  }

  jmem_heap_stats_t jmem_heap_stats;
  memset(&jmem_heap_stats, 0, sizeof(jmem_heap_stats));
  jmem_heap_get_stats(&jmem_heap_stats);

  *out_stats_p = (jerry_heap_stats_t){
      .version = 1,
      .size = jmem_heap_stats.size,
      .allocated_bytes = jmem_heap_stats.allocated_bytes,
      .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes};

  return true;
#else
  JERRY_UNUSED(out_stats_p);
  return false;
#endif
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/core/request.c	sends a redirect response	2	"void h2o_send_redirect(h2o_req_t *req, int status, const char *reason,
                       const char *url, size_t url_len) {
  if (req->res_is_delegated) {
    h2o_iovec_t method = h2o_get_redirect_method(req->method, status);
    h2o_send_redirect_internal(req, method, url, url_len, 0);
    return;
  }

  static h2o_generator_t generator = {NULL, NULL};
  static const h2o_iovec_t body_prefix = {
      H2O_STRLIT(""<!DOCTYPE html><TITLE>Moved</TITLE><P>The document has moved ""
                 ""<A HREF=\"""")};
  static const h2o_iovec_t body_suffix = {H2O_STRLIT(""\"">here</A>"")};

  h2o_iovec_t bufs[3];
  size_t bufcnt;
  if (h2o_memis(req->input.method.base, req->input.method.len,
                H2O_STRLIT(""HEAD""))) {
    req->res.content_length = SIZE_MAX;
    bufcnt = 0;
  } else {
    bufs[0] = body_prefix;
    bufs[1] = h2o_htmlescape(&req->pool, url, url_len);
    bufs[2] = body_suffix;
    bufcnt = 3;
    req->res.content_length = body_prefix.len + bufs[1].len + body_suffix.len;
  }
  req->res.status = status;
  req->res.reason = reason;
  req->res.headers = (h2o_headers_t){NULL};
  h2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_LOCATION, url,
                 url_len);
  h2o_add_header(&req->pool, &req->res.headers, H2O_TOKEN_CONTENT_TYPE,
                 H2O_STRLIT(""text/html; charset=utf-8""));
  h2o_start_response(req, &generator);
  h2o_send(req, bufs, bufcnt, H2O_SEND_STATE_FINAL);
}"
PJK-libcbor-87f977e/src/cbor/ints.c	Allocates new integer with 4B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int32() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_32}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/StillImage.c	Opens a new PIMA session with the attached device. This should be used before any session-orientated PIMA commands are issued to the device. Only one session can be open at the one time.	2	"uint8_t
SImage_Host_OpenSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SIInterfaceInfo->State.TransactionID = 0;
  SIInterfaceInfo->State.IsSessionOpen = false;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = CType_CommandBlock,
      .Code = 0x1002,
      .Params = {1},
  };

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SImage_Host_ReceiveBlockHeader(
           SIInterfaceInfo, &PIMABlock)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((PIMABlock.Type != CType_ResponseBlock) || (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  SIInterfaceInfo->State.IsSessionOpen = true;

  return PIPE_RWSTREAM_NoError;
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Construct a quaternion that rotates from one vector to another.	2	"static SIMD_NOINLINE simd_quatf simd_quaternion(simd_float3 from,
                                                simd_float3 to) {

  if (simd_dot(from, to) >= 0) {
    return _simd_quaternion_reduced(from, to);
  }

  simd_float3 half = simd_normalize(from + to);

  if (simd_length_squared(half) == 0) {

    simd_float3 abs_from = simd_abs(from);
    if (abs_from.x <= abs_from.y && abs_from.x <= abs_from.z)
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_float3){1, 0, 0})), 0.f);
    else if (abs_from.y <= abs_from.z)
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_float3){0, 1, 0})), 0.f);
    else
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_float3){0, 0, 1})), 0.f);
  }

  return simd_mul(_simd_quaternion_reduced(from, half),
                  _simd_quaternion_reduced(half, to));
}"
tempesta-tech-tempesta-9bbfee9/tempesta_fw/http_msg.c	Same as () but use c-strings as argument.	2	"tfw_http_msg_hdr_xfrm(TfwHttpMsg *hm, char *name, size_t n_len, char *val,
                      size_t v_len, unsigned int hid, bool append) {
  TfwStr new_hdr = {.chunks =
                        (TfwStr[]){
                            {.data = name, .len = n_len},
                            {.data = S_DLM, .len = SLEN(S_DLM)},
                            {.data = val, .len = v_len},
                        },
                    .len = n_len + SLEN(S_DLM) + v_len,
                    .eolen = 2,
                    .nchunks = (val ? 3 : 2)};

  BUG_ON(!val && v_len);

  return tfw_http_msg_hdr_xfrm_str(hm, &new_hdr, hid, append);
}"
Mimecast-ioriot-fbf1757/ioriot/src/replay/rtask.c	This function creates a new thread task object. Such a task object is used by the worker to hand over I/O tasks to the corresponding threads. The actual I/O work is performed by the threads then.	2	"rtask_s *rtask_new() {
  rtask_s *task = Malloc(rtask_s);

  *task = (rtask_s){.worker = NULL, .process = NULL};
  task->line[0] = '\0';

#ifdef THREAD_DEBUG
  task->clone = NULL;
#endif

  return task;
}"
mltframework-mlt-bbb55f1/src/modules/avformat/consumer_avformat.c	Add an audio output stream	2	"static AVStream *add_audio_stream(mlt_consumer consumer, AVFormatContext *oc,
                                  AVCodec *codec, int channels,
                                  int64_t channel_layout) {

  mlt_properties properties = MLT_CONSUMER_PROPERTIES(consumer);

  AVStream *st = avformat_new_stream(oc, codec);

  if (st != NULL) {
    AVCodecContext *c = st->codec;

    avcodec_get_context_defaults3(c, codec);

    c->codec_id = codec->id;
    c->codec_type = AVMEDIA_TYPE_AUDIO;
    c->sample_fmt = pick_sample_fmt(properties, codec);
    c->channel_layout = channel_layout;

#if 0  
		 
		int thread_count = mlt_properties_get_int( properties, ""threads"" );
		if ( thread_count == 0 && getenv( ""MLT_AVFORMAT_THREADS"" ) )
			thread_count = atoi( getenv( ""MLT_AVFORMAT_THREADS"" ) );
		if ( thread_count >= 0 )
			c->thread_count = thread_count;
#endif

    if (oc->oformat->flags & AVFMT_GLOBALHEADER)
      c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;

    if (mlt_properties_get(properties, ""atag"")) {
      char *tail = NULL;
      char *arg = mlt_properties_get(properties, ""atag"");
      int tag = strtol(arg, &tail, 0);
      if (!tail || *tail)
        tag = arg[0] + (arg[1] << 8) + (arg[2] << 16) + (arg[3] << 24);
      c->codec_tag = tag;
    }

    char *apre = mlt_properties_get(properties, ""apre"");
    if (apre) {
      mlt_properties p = mlt_properties_load(apre);
      apply_properties(c, p,
                       AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM);
      mlt_properties_close(p);
    }
    apply_properties(c, properties,
                     AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM);

    int audio_qscale = mlt_properties_get_int(properties, ""aq"");
    if (audio_qscale > QSCALE_NONE) {
      c->flags |= AV_CODEC_FLAG_QSCALE;
      c->global_quality = FF_QP2LAMBDA * audio_qscale;
    }

    c->sample_rate = mlt_properties_get_int(properties, ""frequency"");
    st->time_base = (AVRational){1, c->sample_rate};
    c->channels = channels;

    if (mlt_properties_get(properties, ""alang"") != NULL)
      av_dict_set(&oc->metadata, ""language"",
                  mlt_properties_get(properties, ""alang""), 0);
  } else {
    mlt_log_error(MLT_CONSUMER_SERVICE(consumer),
                  ""Could not allocate a stream for audio\n"");
  }

  return st;
}"
dm-vdo-kvdo-8df6805/vdo/base/packer.c	Get the current statistics from the packer.	2	"PackerStatistics getPackerStatistics(const Packer *packer) {

  return (PackerStatistics){
      .compressedFragmentsWritten = relaxedLoad64(&packer->fragmentsWritten),
      .compressedBlocksWritten = relaxedLoad64(&packer->blocksWritten),
      .compressedFragmentsInPacker = relaxedLoad64(&packer->fragmentsPending),
  };
}"
Wolframe-Wolframe-cbc2c7e/include/processor/execContext.hpp	"Checks if a function tagged with AUTHORIZE( funcname, resource) is allowed to be executed."	2	":m_provider(p),m_authorizer(0),m_aaaaProvider(a),m_default_timeout(0){}

                const ProcessorProviderInterface *provider() const {
                  return m_provider;
                }

                const AAAA::User *user() const { return m_user.get(); }

                void setUser(AAAA::User *u) { m_user.reset(u); }

                const AAAA::Authorizer *authorizer() const {
                  return m_authorizer;
                }

                void setAuthorizer(const AAAA::Authorizer *a) {
                  m_authorizer = a;
                }

                unsigned int defaultTimeout() const {
                  return m_default_timeout;
                }

                void setDefaultTimeout(unsigned int timeout_sec_) {
                  m_default_timeout = timeout_sec_;
                }"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for QueryPointer request. Returns the current state and position of the client's ClientPointer to the client.	2	"ProcQueryPointer(ClientPtr client) {
  xQueryPointerReply rep;
  WindowPtr pWin, t;
  DeviceIntPtr mouse = PickPointer(client);
  DeviceIntPtr keyboard;
  SpritePtr pSprite;
  int rc;

  REQUEST(xResourceReq);
  REQUEST_SIZE_MATCH(xResourceReq);

  rc = dixLookupWindow(&pWin, stuff->id, client, DixGetAttrAccess);
  if (rc != Success)
    return rc;
  rc = XaceHook(XACE_DEVICE_ACCESS, client, mouse, DixReadAccess);
  if (rc != Success && rc != BadAccess)
    return rc;

  keyboard = GetMaster(mouse, MASTER_KEYBOARD);

  pSprite = mouse->spriteInfo->sprite;
  if (mouse->valuator->motionHintWindow)
    MaybeStopHint(mouse, client);
  rep = (xQueryPointerReply){.type = X_Reply,
                             .sequenceNumber = client->sequence,
                             .length = 0,
                             .mask = event_get_corestate(mouse, keyboard),
                             .root = (GetCurrentRootWindow(mouse))->drawable.id,
                             .rootX = pSprite->hot.x,
                             .rootY = pSprite->hot.y,
                             .child = None};
  if (pSprite->hot.pScreen == pWin->drawable.pScreen) {
    rep.sameScreen = xTrue;
    rep.winX = pSprite->hot.x - pWin->drawable.x;
    rep.winY = pSprite->hot.y - pWin->drawable.y;
    for (t = pSprite->win; t; t = t->parent)
      if (t->parent == pWin) {
        rep.child = t->drawable.id;
        break;
      }
  } else {
    rep.sameScreen = xFalse;
    rep.winX = 0;
    rep.winY = 0;
  }

#ifdef PANORAMIX
  if (!noPanoramiXExtension) {
    rep.rootX += screenInfo.screens[0]->x;
    rep.rootY += screenInfo.screens[0]->y;
    if (stuff->id == rep.root) {
      rep.winX += screenInfo.screens[0]->x;
      rep.winY += screenInfo.screens[0]->y;
    }
  }
#endif

  if (rc == BadAccess) {
    rep.mask = 0;
    rep.child = None;
    rep.rootX = 0;
    rep.rootY = 0;
    rep.winX = 0;
    rep.winY = 0;
  }

  WriteReplyToClient(client, sizeof(xQueryPointerReply), &rep);

  return Success;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_json.c	the JSON parsing is complete	2	"static void fio_json_on_error(json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
#if DEBUG
  FIO_LOG_DEBUG(""JSON on error called."");
#endif
  fiobj_free((FIOBJ)fio_json_stack_get(&pr->stack, 0));
  fiobj_free(pr->key);
  fio_json_stack_free(&pr->stack);
  *pr = (fiobj_json_parser_s){.top = FIOBJ_INVALID};
}"
field-FieldKit.cpp-a2e9d4f/include/fieldkit/physics/strategy/SpringUpdate.h	updates all spring connections based on new particle positions	2	"SpringUpdate(){};
~SpringUpdate(){};
void apply(Physics *physics);
}
;
}
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration = 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    if (out_pkt.data == pkt->data && out_pkt.size == pkt->size) {
      out_pkt.buf = pkt->buf;
      pkt->buf = NULL;
#if FF_API_DESTRUCT_PACKET
      FF_DISABLE_DEPRECATION_WARNINGS
      out_pkt.destruct = pkt->destruct;
      pkt->destruct = NULL;
      FF_ENABLE_DEPRECATION_WARNINGS
#endif
    }
    if ((ret = av_dup_packet(&out_pkt)) < 0)
      goto fail;

    if (!add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
                       &s->internal->parse_queue_end)) {
      av_free_packet(&out_pkt);
      ret = AVERROR(ENOMEM);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_free_packet(pkt);
  return ret;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Compute the cofactor matrix entries of the geometry mapping Jacobian (referred to as the metrics).	2	"static void compute_cofactors_T(struct const_Multiarray_T *jacobian,
                                struct Multiarray_T *metrics) {
  const int order_j = 3, order_m = 3;

  const ptrdiff_t *exts_j = jacobian->extents, *exts_m = metrics->extents;

  assert(metrics->order == order_m);
  assert(jacobian->order == order_j);
  assert(exts_j[1] == exts_j[2]);

  const ptrdiff_t n_vals = exts_j[0], d = exts_j[1];

  resize_Multiarray_T(metrics, order_m, (ptrdiff_t[]){n_vals, d, d});
  switch (d) {
  case 1:
    for (ptrdiff_t i = 0; i < n_vals; ++i)
      metrics->data[i] = 1.0;
    break;
  case 2: {
    const Type *x_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 0})],
               *x_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 1})],
               *y_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 0})],
               *y_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 1})];
    Type *m_00 = &metrics->data[compute_index_sub_container(
             order_m, 1, exts_m, (ptrdiff_t[]){0, 0})],
         *m_01 = &metrics->data[compute_index_sub_container(
             order_m, 1, exts_m, (ptrdiff_t[]){0, 1})],
         *m_10 = &metrics->data[compute_index_sub_container(
             order_m, 1, exts_m, (ptrdiff_t[]){1, 0})],
         *m_11 = &metrics->data[compute_index_sub_container(
             order_m, 1, exts_m, (ptrdiff_t[]){1, 1})];
    for (ptrdiff_t i = 0; i < n_vals; ++i) {
      m_00[i] = y_s[i];
      m_01[i] = -y_r[i];
      m_10[i] = -x_s[i];
      m_11[i] = x_r[i];
    }
    break;
  }
  case 3: {
    EXIT_ADD_SUPPORT;
    break;
  }
  default:
    EXIT_ERROR(""Unsupported: %td\n"", d);
    break;
  }
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
}"
googlei18n-noto-emoji-6a609ec/third_party/pngquant/lib/mediancut.c	finds median in unsorted set by sorting only minimum required	2	"static f_pixel get_median(const struct box *b, hist_item achv[]) {
  const unsigned int median_start = (b->colors - 1) / 2;

  hist_item_sort_range(&(achv[b->ind]), b->colors, median_start);

  if (b->colors & 1)
    return achv[b->ind + median_start].acolor;

  return averagepixels(2, &achv[b->ind + median_start], 1.0,
                       (f_pixel){0.5, 0.5, 0.5, 0.5});
}"
tinloaf-ygg-18de218/src/ziptree.hpp	"Inserts <node> into the tree. For zip trees, the hinted version is equivalent to the unhinted insertion."	2	"public:
ZTreeRankFromHash(){};

static void update_rank(Node &node) noexcept {

  if (Options::ztree_universalize) {

    size_t universalized =
        (std::hash<Node>{}(node)*Options::ztree_universalize_coefficient) %
        Options::ztree_universalize_modul;
    node._zt_rank.rank =
        (decltype(node._zt_rank.rank))__builtin_ffsl((long int)universalized);
  } else {
    node._zt_rank.rank = (decltype(node._zt_rank.rank))__builtin_ffsl(
        (long int)std::hash<Node>{}(node));
  }
}

static size_t get_rank(const Node &node) noexcept {
  return (size_t)node._zt_rank.rank;
}

private:
template <class, class, class> friend class ZTreeNodeBase;
typename Options::ztree_rank_type::type rank;
}
;

template <class Node, class Options>
class ZTreeRankFromHash<Node, Options, false, true> {
public:
  ZTreeRankFromHash() {
    auto rand_val = std::rand();
    this->rank = 0;
    while (rand_val == RAND_MAX) {
      this->rank =
          (decltype(this->rank))(this->rank +
                                 (decltype(this->rank))std::log2(RAND_MAX));
      rand_val = std::rand();
    }
    this->rank = (decltype(this->rank))__builtin_ffsl((long int)rand_val);
  };

  template <class URBG> ZTreeRankFromHash(URBG &&g) {
    auto rand_val = g();
    this->rank = 0;
    while (rand_val == g.max()) {
      this->rank += (size_t)std::log2(g.max());
      rand_val = g();
    }
    this->rank = __builtin_ffsl((long int)rand_val);
  }

  static void update_rank(Node &node) noexcept { (void)node; }

  static size_t get_rank(const Node &node) noexcept {
    return (size_t)node._zt_rank.rank;
  }"
mcveanlab-mccortex-d3901d9/src/tools/genotyping.c	Get a list of kmers (kmer keys) which support variants.	2	"size_t genotyping_get_kmers(Genotyper *typer, const VcfCovAlt *const *vars,
                            size_t nvars, size_t tgtidx, size_t ntgts,
                            const char *chrom, size_t chromlen,
                            size_t kmer_size, HaploKmer **result,
                            uint32_t *nrkmers) {
  ctx_assert2(0 < nvars && nvars <= 32, ""nvars: %zu"", nvars);
  ctx_assert2(0 < ntgts && ntgts <= 32, ""ntgts: %zu"", ntgts);
  ctx_assert2(tgtidx < nvars, ""tgtidx:%zu >= nvars:%zu ??"", tgtidx, nvars);

  HaploKmerBuffer *gkbuf = &typer->kmer_buf;
  haplokmer_buf_reset(gkbuf);

  const VcfCovAlt *tgt = vars[tgtidx];

  size_t i, tgtend = tgtidx + ntgts;
  size_t regstart = MIN2(vcfcovalt_hap_start(vars[0], kmer_size),
                         vcfcovalt_hap_start(tgt, kmer_size));
  size_t regend = regstart;

  i = 0;
  for (; i < tgtidx; i++)
    regend = MAX2(regend, vcfcovalt_hap_end(vars[i], kmer_size));
  for (; i < tgtend; i++)
    regend = MAX2(regend, vcfcovalt_hap_end(vars[i], kmer_size));
  for (; i < nvars; i++)
    regend = MAX2(regend, vcfcovalt_hap_end(vars[i], kmer_size));

  regend = MIN2(regend, chromlen);

  StrBuf *seq = &typer->seq;
  khash_t(BkToBits) *h = typer->h;
  BinaryKmer bkmer, bkey;
  int hret;
  khiter_t kiter;

  if (nrkmers) {
    for (i = 0; i < ntgts; i++) {
      nrkmers[i] = count_ref_kmers(chrom + regstart, regend - regstart,
                                   vars[tgtidx + i]->pos - regstart,
                                   vars[tgtidx + i]->reflen, kmer_size);
    }
  }

  uint64_t bits, limit, altref_bits, mask = UINT64_MAX >> (64 - 2 * ntgts);
  size_t cstart, cend, cnext;

  for (bits = 0, limit = 1UL << nvars; bits < limit; bits++) {
    if (vars_compatible(vars, nvars, bits)) {

      assemble_haplotype_str(seq, chrom, regstart, regend, vars, nvars, bits);

      altref_bits = altrefbits(vars, nvars, bits);
      altref_bits >>= 2 * tgtidx;
      altref_bits &= mask;

      cnext = 0;
      while ((cstart = seq_contig_start2(seq->b, seq->end, NULL, 0, cnext,
                                         kmer_size, 0, 0)) < seq->end) {
        cend = seq_contig_end2(seq->b, seq->end, NULL, 0, cstart, kmer_size, 0,
                               0, &cnext);

        bkmer = binary_kmer_from_str(seq->b + cstart, kmer_size);
        bkmer = binary_kmer_right_shift_one_base(bkmer);

        for (i = cstart + kmer_size - 1; i < cend; i++) {
          bkmer = binary_kmer_left_shift_add(bkmer, kmer_size,
                                             dna_char_to_nuc(seq->b[i]));
          bkey = binary_kmer_get_key(bkmer, kmer_size);
          kiter = kh_put(BkToBits, h, bkey, &hret);
          if (hret < 0)
            die(""khash table failed: out of memory?"");
          if (hret > 0)
            kh_value(h, kiter) = 0;
          kh_value(h, kiter) |= altref_bits;
        }
      }
    }
  }

  size_t nkmers = kh_size(h);
  haplokmer_buf_capacity(gkbuf, nkmers);

  for (i = 0, kiter = kh_begin(h); kiter != kh_end(h); ++kiter) {
    if (kh_exist(h, kiter)) {
      bkey = kh_key(h, kiter);
      altref_bits = kh_value(h, kiter);
      kh_del(BkToBits, h, kiter);
      if (genotyping_refalt_uniq(altref_bits)) {
        gkbuf->b[i++] = (HaploKmer){.bkey = bkey, .arbits = altref_bits};
      }
    }
  }
  gkbuf->len = i;

  *result = gkbuf->b;
  return gkbuf->len;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a 64-bit double-precision value to the low element of a 128-bit integer vector and clears the upper element.	2	"_mm_load_sd(double const *__dp) {
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct *)__dp)->__u;
  return __extension__(__m128d){__u, 0};
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a 16-bit integer value to the low element of a 128-bit integer vector and clears the upper element. This intrinsic does not correspond to a specific instruction.	2	"_mm_loadu_si16(void const *__a) {
  struct __loadu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  short __u = ((struct __loadu_si16 *)__a)->__v;
  return __extension__(__m128i)(__v8hi){__u, 0, 0, 0, 0, 0, 0, 0};
}"
dm-vdo-kvdo-8df6805/vdo/base/vdoRecovery.c	Determine the limits of the valid recovery journal and apply all valid entries to the block map. This callback is registered in recoverJournalAsync().	2	"static void applyJournalEntries(VDOCompletion *completion) {
  RecoveryCompletion *recovery = asRecoveryCompletion(completion->parent);
  VDO *vdo = recovery->vdo;
  RecoveryJournal *journal = vdo->recoveryJournal;
  logInfo(""Finished reading recovery journal"");
  bool foundEntries =
      findHeadAndTail(journal, recovery->journalData, &recovery->highestTail,
                      &recovery->blockMapHead, &recovery->slabJournalHead);
  if (foundEntries) {
    foundEntries = findContiguousRange(recovery);
  }

  if ((recovery->blockMapHead > recovery->tail) ||
      (recovery->slabJournalHead > recovery->tail)) {
    int result = logErrorWithStringError(
        VDO_CORRUPT_JOURNAL,
        ""Journal tail too early. ""
        ""block map head: %"" PRIu64 "", slab journal head: %"" PRIu64
        "", tail: %"" PRIu64,
        recovery->blockMapHead, recovery->slabJournalHead, recovery->tail);
    finishCompletion(&recovery->completion, result);
    return;
  }

  if (!foundEntries) {

    logInfo(""Replaying 0 recovery entries into block map"");
    finishCompletion(&recovery->completion, VDO_SUCCESS);
    return;
  }

  logInfo(""Highest-numbered recovery journal block has sequence number""
          "" %"" PRIu64 "", and the highest-numbered usable block is %"" PRIu64,
          recovery->highestTail, recovery->tail);

  if (isReplaying(vdo)) {

    int result = countIncrementEntries(recovery);
    if (result != VDO_SUCCESS) {
      finishCompletion(&recovery->completion, result);
      return;
    }

    launchCallbackWithParent(
        &recovery->subTaskCompletion, launchBlockMapRecovery,
        getLogicalZoneThread(getThreadConfig(vdo), 0), &recovery->completion);
    return;
  }

  logInfo(""Replaying entries into slab journals"");
  recovery->nextRecoveryPoint = (RecoveryPoint){
      .sequenceNumber = recovery->slabJournalHead,
      .sectorCount = 1,
      .entryCount = 0,
  };

  recovery->nextJournalPoint = (JournalPoint){
      .sequenceNumber = recovery->slabJournalHead,
      .entryCount = 0,
  };

  launchCallbackWithParent(&recovery->subTaskCompletion, addSlabJournalEntries,
                           getCallbackThreadID(), &recovery->completion);
}"
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	The current position is not changed.	2	"protected:
template <typename STR> friend class NativeString;

class Native {
public:
  virtual ~Native(){};
};

template <typename STR> class NativeArray : public Native {
  STR *data;

public:
  NativeArray(STR *data) : data(data) {}
  virtual ~NativeArray() { delete[] data; }"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server ready for SNI, but the client not providing one. The SNI callback should respond with the default credential. The client inquires the peer name and verifies it matches the default credential."	3	"init_no_client_sni(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;

  major_status = gss_set_sec_context_option(&minor_status, &accept_context,
                                            GSS_SNI_CREDENTIALS,
                                            &(gss_buffer_desc){
                                                .value = creds,
                                                .length = sizeof(creds),
                                            });
  if (major_status != GSS_S_COMPLETE) {
    result = false;

    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, GSS_C_NO_NAME,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    major_status =
        gss_inquire_context(&minor_status, init_context, NULL, &peer_name, NULL,
                            NULL, NULL, NULL, NULL);
    if (major_status != GSS_S_COMPLETE) {
      result = false;

      goto fail;
    }

    major_status =
        gss_compare_name(&minor_status, names[0], peer_name, &name_equal);

    if (major_status != GSS_S_COMPLETE) {
      result = false;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }

  return result;
}"
aipame-DDImageCompress-7eb82d2/DDImageCompress/pngquant_lib/libimagequant.c	"Uses edge/noise map to apply dithering only to flat areas. Dithering on edges creates jagged lines, and noisy areas are ""naturally"" dithered. If output_image_is_remapped is true, only pixels noticeably changed by error diffusion will be written to output image."	2	"LIQ_NONNULL static bool remap_to_palette_floyd(
    liq_image *input_image, unsigned char *const output_pixels[],
    liq_remapping_result *quant, const float max_dither_error,
    const bool output_image_is_remapped) {
  const int rows = input_image->height, cols = input_image->width;
  const unsigned char *dither_map =
      quant->use_dither_map ? (input_image->dither_map ? input_image->dither_map
                                                       : input_image->edges)
                            : NULL;

  const colormap *map = quant->palette;
  const colormap_item *acolormap = map->palette;

  if (!liq_image_get_row_f_init(input_image)) {
    return false;
  }
  if (input_image->background &&
      !liq_image_get_row_f_init(input_image->background)) {
    return false;
  }

  const size_t errwidth = cols + 2;
  f_pixel *restrict thiserr =
      input_image->malloc(errwidth * sizeof(thiserr[0]) * 2);
  if (!thiserr)
    return false;
  f_pixel *restrict nexterr = thiserr + errwidth;
  memset(thiserr, 0, errwidth * sizeof(thiserr[0]));

  bool ok = true;
  struct nearest_map *const n = nearest_init(map);
  const int transparent_index =
      input_image->background
          ? nearest_search(n, &(f_pixel){0, 0, 0, 0}, 0, NULL)
          : 0;

  float base_dithering_level = quant->dither_level;
  base_dithering_level =
      1.f - (1.f - base_dithering_level) * (1.f - base_dithering_level);

  if (dither_map) {
    base_dithering_level *= 1.f / 255.f;
  }
  base_dithering_level *= 15.f / 16.f;

  int fs_direction = 1;
  unsigned int last_match = 0;
  for (int row = 0; row < rows; ++row) {
    if (liq_remap_progress(quant,
                           quant->progress_stage1 +
                               row * (100.f - quant->progress_stage1) / rows)) {
      ok = false;
      break;
    }

    memset(nexterr, 0, errwidth * sizeof(nexterr[0]));

    int col = (fs_direction > 0) ? 0 : (cols - 1);
    const f_pixel *const row_pixels = liq_image_get_row_f(input_image, row);
    const f_pixel *const bg_pixels =
        input_image->background &&
                acolormap[transparent_index].acolor.a < 1.f / 256.f
            ? liq_image_get_row_f(input_image->background, row)
            : NULL;

    do {
      float dither_level = base_dithering_level;
      if (dither_map) {
        dither_level *= dither_map[row * cols + col];
      }

      const f_pixel spx = get_dithered_pixel(dither_level, max_dither_error,
                                             thiserr[col + 1], row_pixels[col]);

      const unsigned int guessed_match =
          output_image_is_remapped ? output_pixels[row][col] : last_match;
      float diff;
      last_match = nearest_search(n, &spx, guessed_match, &diff);
      f_pixel output_px = acolormap[last_match].acolor;
      if (bg_pixels && colordifference(bg_pixels[col], output_px) <= diff) {
        output_px = bg_pixels[col];
        output_pixels[row][col] = transparent_index;
      } else {
        output_pixels[row][col] = last_match;
      }

      f_pixel err = {
          .r = (spx.r - output_px.r),
          .g = (spx.g - output_px.g),
          .b = (spx.b - output_px.b),
          .a = (spx.a - output_px.a),
      };

      if (err.r * err.r + err.g * err.g + err.b * err.b + err.a * err.a >
          max_dither_error) {
        err.r *= 0.75f;
        err.g *= 0.75f;
        err.b *= 0.75f;
        err.a *= 0.75f;
      }

      if (fs_direction > 0) {
        thiserr[col + 2].a += err.a * (7.f / 16.f);
        thiserr[col + 2].r += err.r * (7.f / 16.f);
        thiserr[col + 2].g += err.g * (7.f / 16.f);
        thiserr[col + 2].b += err.b * (7.f / 16.f);

        nexterr[col + 2].a = err.a * (1.f / 16.f);
        nexterr[col + 2].r = err.r * (1.f / 16.f);
        nexterr[col + 2].g = err.g * (1.f / 16.f);
        nexterr[col + 2].b = err.b * (1.f / 16.f);

        nexterr[col + 1].a += err.a * (5.f / 16.f);
        nexterr[col + 1].r += err.r * (5.f / 16.f);
        nexterr[col + 1].g += err.g * (5.f / 16.f);
        nexterr[col + 1].b += err.b * (5.f / 16.f);

        nexterr[col].a += err.a * (3.f / 16.f);
        nexterr[col].r += err.r * (3.f / 16.f);
        nexterr[col].g += err.g * (3.f / 16.f);
        nexterr[col].b += err.b * (3.f / 16.f);

      } else {
        thiserr[col].a += err.a * (7.f / 16.f);
        thiserr[col].r += err.r * (7.f / 16.f);
        thiserr[col].g += err.g * (7.f / 16.f);
        thiserr[col].b += err.b * (7.f / 16.f);

        nexterr[col].a = err.a * (1.f / 16.f);
        nexterr[col].r = err.r * (1.f / 16.f);
        nexterr[col].g = err.g * (1.f / 16.f);
        nexterr[col].b = err.b * (1.f / 16.f);

        nexterr[col + 1].a += err.a * (5.f / 16.f);
        nexterr[col + 1].r += err.r * (5.f / 16.f);
        nexterr[col + 1].g += err.g * (5.f / 16.f);
        nexterr[col + 1].b += err.b * (5.f / 16.f);

        nexterr[col + 2].a += err.a * (3.f / 16.f);
        nexterr[col + 2].r += err.r * (3.f / 16.f);
        nexterr[col + 2].g += err.g * (3.f / 16.f);
        nexterr[col + 2].b += err.b * (3.f / 16.f);
      }

      col += fs_direction;
      if (fs_direction > 0) {
        if (col >= cols)
          break;
      } else {
        if (col < 0)
          break;
      }
    } while (1);

    f_pixel *const temperr = thiserr;
    thiserr = nexterr;
    nexterr = temperr;
    fs_direction = -fs_direction;
  }

  input_image->free(MIN(thiserr, nexterr));
  nearest_free(n);

  return ok;
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/ui.c	Display about screen for the badge.	2	"void ui_about() {
  char buffer[64];
  gfx_fill_screen(COLOR_BLACK);
  gfx_color_set(COLOR_GREEN);
  gfx_font_set(font_large);
  gfx_cursor_set((cursor_coord_t){0, 0});
  gfx_print(""About\n"");
  gfx_font_set(font_small);
  gfx_print(""AND!XOR DC26\n"");
  gfx_print(""Firmware:\n   "");

  gfx_color_set(COLOR_LIGHTGREY);
  sprintf(buffer, ""%s\n"", VERSION);
  gfx_print(buffer);

  gfx_color_set(COLOR_GREEN);
  gfx_print(""ESP-IDF:\n   "");

  gfx_color_set(COLOR_LIGHTGREY);
  sprintf(buffer, ""%s\n"", IDF_VER);
  gfx_print(buffer);

  gfx_push_screen_buffer();
  btn_wait();
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/xmmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_setr_ps(float __z, float __y, float __x, float __w) {
  return (__m128){__z, __y, __x, __w};
}"
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;
    if (!link->src || !link->dst) {
      av_log(filter, AV_LOG_ERROR,
             ""Not all input and output are properly linked (%d).\n"", i);
      return AVERROR(EINVAL);
    }

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = link->current_pts_us = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink) {
          if (!link->frame_rate.num && !link->frame_rate.den)
            link->frame_rate = inlink->frame_rate;
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->dst, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Core/HostStandardReq.c	"Retrieves the current feature status of the attached device, via a GET STATUS standard request. The retrieved feature status can then be examined by masking the retrieved value with the various FEATURE_* masks for bus/self power information and remote wakeup support."	0	"uint8_t USB_Host_GetDeviceStatus(uint8_t *const FeatureStatus) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetStatus,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(FeatureStatus);
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	Write the user and all associated data out to the given output buffer using the given marshalling format.	2	"bool mpw_marshal_write(char **out, const MPMarshalFormat outFormat,
                       const MPMarshalledUser *user, MPMarshalError *error) {

  switch (outFormat) {
  case MPMarshalFormatNone:
    *error = (MPMarshalError){.type = MPMarshalSuccess};
    return false;
  case MPMarshalFormatFlat:
    return mpw_marshal_write_flat(out, user, error);
#if MPW_JSON
  case MPMarshalFormatJSON:
    return mpw_marshal_write_json(out, user, error);
#endif
  default:
    *error =
        (MPMarshalError){MPMarshalErrorFormat,
                         mpw_str(""Unsupported output format: %u"", outFormat)};
    return false;
  }
}"
projectchrono-chrono-c476c04/src/chrono/core/ChStream.h	"Creates a wrapper for an already existing, already opened, ostream, given the pointer to that ostream."	2	"ChStreamOutBinaryStream(std::ostream *mfile)
    : ChStreamOstreamWrapper(mfile), ChStreamOutBinary(){};
virtual ~ChStreamOutBinaryStream(){};

virtual bool End_of_stream() { return ChStreamOstreamWrapper::End_of_stream(); }"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/dv_profile.c	Get a DV profile for the provided stream parameters.	2	"const AVDVProfile *av_dv_codec_profile(int width, int height,
                                       enum AVPixelFormat pix_fmt) {
#if CONFIG_DVPROFILE
  return av_dv_codec_profile2(width, height, pix_fmt, (AVRational){0, 0});
#endif

  return NULL;
}"
ThierryNg-pokecopy-57caaae/Pokecopy.spritebuilder/Source/libs/cocos2d-iphone/cocos2d/CCRendererBasicTypes.h	Multiply the vertex's position by the given transform. Pass the rest.	2	"CCVertexApplyTransform(CCVertex v, const GLKMatrix4 *transform) {
  return (CCVertex){
      GLKMatrix4MultiplyVector4(*transform, v.position),
      v.texCoord1,
      v.texCoord2,
      v.color,
  };
}"
varunjampani-video_prop_networks-4f4a398/lib/caffe/include/caffe/malabar_layers.hpp	"Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true."	2	"tmp_param.mutable_concat_param()->set_concat_dim(3);
concat_layer_.reset(new ConcatLayer<Dtype>(tmp_param));
}
virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                        const vector<Blob<Dtype> *> &top);
virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                     const vector<Blob<Dtype> *> &top);

virtual inline const char *type() const { return ""MatMul""; }
virtual inline int MinNumBottomBlobs() const { return 2; }
virtual inline int ExactNumTopBlobs() const { return 1; }

protected:
virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                         const vector<Blob<Dtype> *> &top);
virtual void Forward_gpu(const vector<Blob<Dtype> *> &bottom,
                         const vector<Blob<Dtype> *> &top);
virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                          const vector<bool> &propagate_down,
                          const vector<Blob<Dtype> *> &bottom);
virtual void Backward_gpu(const vector<Blob<Dtype> *> &top,
                          const vector<bool> &propagate_down,
                          const vector<Blob<Dtype> *> &bottom);
Blob<Dtype> tmp_k_;
boost::shared_ptr<ConcatLayer<Dtype>> concat_layer_;
}
;

template <typename Dtype> class MatMul2Layer : public Layer<Dtype> {
public:
  explicit MatMul2Layer(const LayerParameter &param) : Layer<Dtype>(param){};
  virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                          const vector<Blob<Dtype> *> &top);
  virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                       const vector<Blob<Dtype> *> &top);

  virtual inline const char *type() const { return ""MatMul2""; }
  virtual inline int ExactNumBottomBlobs() const { return 2; }
  virtual inline int ExactNumTopBlobs() const { return 1; }"
phase4ground-joco-2019-badge-2dec94a/firmware/src/bling/mbp_custom_bling.c	Per-frame callback for rainbow Per-frame callback for animating the LEDs randomly Snake around the mouth of bender!	2	"static void __menu_custom_anim_callback(void *p_data) {
  uint32_t err_code;

  menu_t menu;
  menu_item_t items[100];
  menu.items = items;
  menu.title = ""LED Mode"";
  menu.count = 0;
  menu.selected = 0;
  menu.top = 0;

  FRESULT result;
  DIR dir;
  static FILINFO fno;

  result = f_opendir(&dir, ""BLING"");
  if (result == FR_OK) {
    for (;;) {
      result = f_readdir(&dir, &fno);
      if (result != FR_OK || fno.fname[0] == 0)
        break;
      if (fno.fattrib & AM_DIR) {

      } else {
        char *ext = strrchr(fno.fname, '.') + 1;

        if (strcmp(ext, ""RGB"") == 0) {

          menu_item_t item;
          item.callback = NULL;
          item.icon = NULL;
          item.preview = NULL;
          item.text = (char *)malloc(16);
          item.data = (char *)malloc(20);

          snprintf(item.text, ext - fno.fname, ""%s"", fno.fname);
          sprintf(item.data, ""BLING/%s"", fno.fname);
          items[menu.count++] = item;
        }
      }

      if (menu.count >= 100) {
        break;
      }
    }
    f_closedir(&dir);
  }

  mbp_sort_menu(&menu);

  menu.items[menu.count++] = (menu_item_t){""<None>"", NULL, NULL, NULL, NULL};

  if (mbp_submenu(&menu) == MENU_QUIT) {
    return;
  }

  util_button_clear();

  void *p_timer_data = NULL;
  app_timer_timeout_handler_t led_callback = NULL;

  if (menu.selected < (menu.count - 1)) {
    char *filename = (char *)menu.items[menu.selected].data;
    util_led_load_rgb_file(filename, &m_anim);
    p_timer_data = &m_anim;
    led_callback = __led_rgb_callback;
  }

  if (led_callback != NULL) {
    uint32_t ticks = APP_TIMER_TICKS(1000 / LED_FPS, UTIL_TIMER_PRESCALER);
    err_code =
        app_timer_create(&m_timer, APP_TIMER_MODE_REPEATED, led_callback);
    APP_ERROR_CHECK(err_code);
    err_code = app_timer_start(m_timer, ticks, p_timer_data);
    APP_ERROR_CHECK(err_code);
  }

  if (p_data != NULL) {

    util_led_clear();
    char *filename = (char *)p_data;
    util_gfx_draw_raw_file(filename, 0, 0, 128, 128, NULL, true, NULL, 0);
  } else {
    mbp_ui_cls();
    util_button_wait();
  }

  if (led_callback != NULL) {
    app_timer_stop(m_timer);
  }

  for (uint16_t i = 0; i < (menu.count - 1); i++) {
    free((items[i].data));
    free((items[i].text));
  }

  app_sched_execute();

  util_led_clear();
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavcodec/ituh263enc.c	Return the 4 bit value that specifies the given aspect ratio. This may be one of the standard aspect ratios or it specifies that the aspect will be stored explicitly later.	2	"av_const int ff_h263_aspect_to_info(AVRational aspect) {
  int i;

  if (aspect.num == 0) {
    aspect = (AVRational){1, 1};
  }

  for (i = 1; i < 6; i++) {
    if (av_cmp_q(ff_h263_pixel_aspect[i], aspect) == 0) {
      return i;
    }
  }

  return FF_ASPECT_EXTENDED;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Divide two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_float qdivf(const quaternion_float num1,
                                          const quaternion_float num2) {
  if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) &&
      (num1.k == num2.k))
    return (quaternion_float){1.0F, 0.0F, 0.0F, 0.0F};
  const float tmp_r = (num2.R * num1.R) + (num2.i * num1.i) +
                      (num2.j * num1.j) + (num2.k * num1.k);
  const float tmp_i = (num2.R * num1.i) - (num2.i * num1.R) -
                      (num2.j * num1.k) + (num2.k * num1.j);
  const float tmp_j = (num2.R * num1.j) + (num2.i * num1.k) -
                      (num2.j * num1.R) - (num2.k * num1.i);
  const float tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                      (num2.j * num1.i) - (num2.k * num1.R);
  register const float tmp2n =
      squarerootf((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) +
                  (num2.k * num2.k));
  return (quaternion_float){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n,
                            tmp_k / tmp2n};
}"
amakaseev-sprite-sheet-packer-beffd9b/SpriteSheetPacker/3rdparty/pngquant/libimagequant.c	"Palette can be NULL, in which case it creates a new palette from scratch."	2	"static colormap *add_fixed_colors_to_palette(colormap *palette,
                                             const int max_colors,
                                             const f_pixel fixed_colors[],
                                             const int fixed_colors_count,
                                             void *(*malloc)(size_t),
                                             void (*free)(void *)) {
  if (!fixed_colors_count)
    return palette;

  colormap *newpal = pam_colormap(
      MIN(max_colors, (palette ? palette->colors : 0) + fixed_colors_count),
      malloc, free);
  unsigned int i = 0;
  if (palette && fixed_colors_count < max_colors) {
    unsigned int palette_max =
        MIN(palette->colors, max_colors - fixed_colors_count);
    for (; i < palette_max; i++) {
      newpal->palette[i] = palette->palette[i];
    }
  }
  for (int j = 0; j < MIN(max_colors, fixed_colors_count); j++) {
    newpal->palette[i++] = (colormap_item){
        .acolor = fixed_colors[j],
        .fixed = true,
    };
  }
  if (palette)
    pam_freecolormap(palette);
  return newpal;
}"
dm-vdo-kvdo-8df6805/uds/errors.c	Register an error code block for stringError and stringErrorName.	2	"int registerErrorBlock(const char *blockName, int firstError,
                       int lastReservedError, const ErrorInfo *infos,
                       size_t infoSize) {
  int result = ASSERT(firstError < lastReservedError, ""bad error block range"");
  if (result != UDS_SUCCESS) {
    return result;
  }

  ensureStandardErrorBlocks();

  if (registeredErrors.count == registeredErrors.allocated) {

    return UDS_OVERFLOW;
  }

  for (ErrorBlock *block = registeredErrors.blocks;
       block < registeredErrors.blocks + registeredErrors.count; ++block) {
    if (strcmp(blockName, block->name) == 0) {
      return UDS_DUPLICATE_NAME;
    }

    if ((firstError < block->max) && (lastReservedError > block->base)) {
      return UDS_ALREADY_REGISTERED;
    }
  }

  registeredErrors.blocks[registeredErrors.count++] =
      (ErrorBlock){.name = blockName,
                   .base = firstError,
                   .last = firstError + (infoSize / sizeof(ErrorInfo)),
                   .max = lastReservedError,
                   .infos = infos};

  return UDS_SUCCESS;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/RNDISEthernetHost/Lib/RNDISCommands.c	Function to receive the given encapsulated RNDIS response from the device.	0	"uint8_t RNDIS_GetEncapsulatedResponse(void *const Buffer,
                                      const uint16_t Length) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = RNDIS_REQ_GetEncapsulatedResponse,
      .wValue = 0,
      .wIndex = 0,
      .wLength = Length,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(Buffer);
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/keyid.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register(
      (command_t){keyid,
                  'k',
                  ""keyid"",
                  ""calculate key identifiers of a key/certificate"",
                  {""[--in file] [--type rsa-priv|ecdsa-priv|pub|pkcs10|x509]""},
                  {
                      {""help"", 'h', 0, ""show usage information""},
                      {""in"", 'i', 1, ""input file, default: stdin""},
                      {""type"", 't', 1, ""type of key, default: rsa-priv""},
                  }});
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_containers.c	Provides unit tests for the matrix-diagonal matrix multiplication functions.	2	"static void test_unit_matrix_mm_diag(struct Test_Info *const test_info) {
  UNUSED(test_info);
  bool pass = true;

  const char *const file_name_full =
      set_data_file_name_unit(""containers/matrix"");

  const struct const_Matrix_d *a =
      constructor_file_name_const_Matrix_d(""a_Matrix"", file_name_full);
  const struct const_Vector_d *bl =
      constructor_file_name_const_Vector_d(""bl_Vector"", file_name_full);
  const struct const_Vector_d *br =
      constructor_file_name_const_Vector_d(""br_Vector"", file_name_full);
  const struct const_Matrix_d *cl =
      constructor_file_name_const_Matrix_d(""cl_Matrix"", file_name_full);
  const struct const_Matrix_d *cr =
      constructor_file_name_const_Matrix_d(""cr_Matrix"", file_name_full);

  const struct const_Matrix_d *a_t =
      constructor_copy_transpose_const_Matrix_d(a, true);
  const struct const_Matrix_d *cl_t =
      constructor_copy_transpose_const_Matrix_d(cl, true);
  const struct const_Matrix_d *cr_t =
      constructor_copy_transpose_const_Matrix_d(cr, true);

  const struct const_Matrix_d *cl_R =
      constructor_mm_diag_const_Matrix_d(1.0, a, bl, 'L', false);
  const struct const_Matrix_d *cr_R =
      constructor_mm_diag_const_Matrix_d(1.0, a, br, 'R', false);
  const struct const_Matrix_d *cl_C =
      constructor_mm_diag_const_Matrix_d(1.0, a_t, bl, 'L', false);
  const struct const_Matrix_d *cr_C =
      constructor_mm_diag_const_Matrix_d(1.0, a_t, br, 'R', false);

  struct Matrix_d *cl_R_alt =
      constructor_empty_Matrix_d(cl_R->layout, cl_R->ext_0, cl_R->ext_1);
  struct Matrix_d *cr_R_alt =
      constructor_empty_Matrix_d(cr_R->layout, cr_R->ext_0, cr_R->ext_1);
  struct Matrix_d *cl_C_alt =
      constructor_empty_Matrix_d(cl_C->layout, cl_C->ext_0, cl_C->ext_1);
  struct Matrix_d *cr_C_alt =
      constructor_empty_Matrix_d(cr_C->layout, cr_C->ext_0, cr_C->ext_1);

  mm_diag_d('L', 1.0, 0.0, a, bl, cl_R_alt, false);
  mm_diag_d('R', 1.0, 0.0, a, br, cr_R_alt, false);
  mm_diag_d('L', 1.0, 0.0, a_t, bl, cl_C_alt, false);
  mm_diag_d('R', 1.0, 0.0, a_t, br, cr_C_alt, false);

  destructor_const_Matrix_d(a);
  destructor_const_Matrix_d(a_t);
  destructor_const_Vector_d(bl);
  destructor_const_Vector_d(br);

  const bool *differences = (bool[]){
      diff_const_Matrix_d(cl, cl_R, EPS),
      diff_const_Matrix_d(cr, cr_R, EPS),
      diff_const_Matrix_d(cl_t, cl_C, EPS),
      diff_const_Matrix_d(cr_t, cr_C, EPS),
      diff_const_Matrix_d(cl, (struct const_Matrix_d *)cl_R_alt, EPS),
      diff_const_Matrix_d(cr, (struct const_Matrix_d *)cr_R_alt, EPS),
      diff_const_Matrix_d(cl_t, (struct const_Matrix_d *)cl_C_alt, EPS),
      diff_const_Matrix_d(cr_t, (struct const_Matrix_d *)cr_C_alt, EPS),
  };
  if (check_diff(8, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(cl, cl_R, EPS);
    if (differences[1])
      print_diff_const_Matrix_d(cr, cr_R, EPS);
    if (differences[2])
      print_diff_const_Matrix_d(cl_t, cl_C, EPS);
    if (differences[3])
      print_diff_const_Matrix_d(cr_t, cr_C, EPS);

    int ind = 4;
    print_diff_cond_const_Matrix_d(cl, (struct const_Matrix_d *)cl_R_alt, EPS,
                                   differences[ind++]);
    print_diff_cond_const_Matrix_d(cr, (struct const_Matrix_d *)cr_R_alt, EPS,
                                   differences[ind++]);
    print_diff_cond_const_Matrix_d(cl_t, (struct const_Matrix_d *)cl_C_alt, EPS,
                                   differences[ind++]);
    print_diff_cond_const_Matrix_d(cr_t, (struct const_Matrix_d *)cr_C_alt, EPS,
                                   differences[ind++]);
  }

  destructor_const_Matrix_d(cl);
  destructor_const_Matrix_d(cr);
  destructor_const_Matrix_d(cl_t);
  destructor_const_Matrix_d(cr_t);

  destructor_const_Matrix_d(cl_R);
  destructor_const_Matrix_d(cr_R);
  destructor_const_Matrix_d(cl_C);
  destructor_const_Matrix_d(cr_C);

  destructor_Matrix_d(cl_R_alt);
  destructor_Matrix_d(cr_R_alt);
  destructor_Matrix_d(cl_C_alt);
  destructor_Matrix_d(cr_C_alt);

  assert_condition(pass);
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Berechnet eine Ebenengleichung in Parameterform  Erstellt aus dem gegebenen Richtungsvektor (muss nicht Einheitslnge haben) und Punkt eine Ebenengleichung, so dass fr jeden Punkt der Abstand bestimmt werden kann, in dem simd_dot(punkt, ebene) berechnet wird."	2	"static inline vec_float4 simd_plane(const vec_float4 normal,
                                    const vec_float4 position) {
  vec_float4 unitNormal = simd_normalize_e(normal);
  return simd_select(unitNormal, -simd_dot(unitNormal, position),
                     (vec_uint4){0, 0, 0, UINT32_MAX});
}"
APCVSRepo-hmi_sdk-20b6f61/hmi_sdk/Tools/ffmpeg-2.6.2/libavutil/opt.c	Check if given option is set to its default value.	2	"int av_opt_is_set_to_default(void *obj, const AVOption *o) {
  int64_t i64;
  double d, d2;
  float f;
  AVRational q;
  int ret, w, h;
  char *str;
  void *dst;

  if (!o || !obj)
    return AVERROR(EINVAL);

  dst = ((uint8_t *)obj) + o->offset;

  switch (o->type) {
  case AV_OPT_TYPE_CONST:
    return 1;
  case AV_OPT_TYPE_FLAGS:
  case AV_OPT_TYPE_PIXEL_FMT:
  case AV_OPT_TYPE_SAMPLE_FMT:
  case AV_OPT_TYPE_INT:
  case AV_OPT_TYPE_CHANNEL_LAYOUT:
  case AV_OPT_TYPE_DURATION:
  case AV_OPT_TYPE_INT64:
    read_number(o, dst, NULL, NULL, &i64);
    return o->default_val.i64 == i64;
  case AV_OPT_TYPE_STRING:
    str = *(char **)dst;
    if (str == o->default_val.str)
      return 1;
    if (!str || !o->default_val.str)
      return 0;
    return !strcmp(str, o->default_val.str);
  case AV_OPT_TYPE_DOUBLE:
    read_number(o, dst, &d, NULL, NULL);
    return o->default_val.dbl == d;
  case AV_OPT_TYPE_FLOAT:
    read_number(o, dst, &d, NULL, NULL);
    f = o->default_val.dbl;
    d2 = f;
    return d2 == d;
  case AV_OPT_TYPE_RATIONAL:
    q = av_d2q(o->default_val.dbl, INT_MAX);
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_BINARY: {
    struct {
      uint8_t *data;
      int size;
    } tmp = {0};
    int opt_size = *(int *)((void **)dst + 1);
    void *opt_ptr = *(void **)dst;
    if (!opt_size && (!o->default_val.str || !strlen(o->default_val.str)))
      return 1;
    if (!opt_size || !o->default_val.str || !strlen(o->default_val.str))
      return 0;
    if (opt_size != strlen(o->default_val.str) / 2)
      return 0;
    ret = set_string_binary(NULL, NULL, o->default_val.str, &tmp.data);
    if (!ret)
      ret = !memcmp(opt_ptr, tmp.data, tmp.size);
    av_free(tmp.data);
    return ret;
  }
  case AV_OPT_TYPE_DICT:

    return !!(*(void **)dst);
  case AV_OPT_TYPE_IMAGE_SIZE:
    if (!o->default_val.str || !strcmp(o->default_val.str, ""none""))
      w = h = 0;
    else if ((ret = av_parse_video_size(&w, &h, o->default_val.str)) < 0)
      return ret;
    return (w == *(int *)dst) && (h == *((int *)dst + 1));
  case AV_OPT_TYPE_VIDEO_RATE:
    q = (AVRational){0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_video_rate(&q, o->default_val.str)) < 0)
        return ret;
    }
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_COLOR: {
    uint8_t color[4] = {0, 0, 0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_color(color, o->default_val.str, -1, NULL)) < 0)
        return ret;
    }
    return !memcmp(color, dst, sizeof(color));
  }
  default:
    av_log(obj, AV_LOG_WARNING,
           ""Not supported option type: %d, option name: %s\n"", o->type,
           o->name);
    break;
  }
  return AVERROR_PATCHWELCOME;
}"
dm-vdo-kvdo-8df6805/vdo/kernel/dataKVIO.c	Get the state needed to generate UDS metadata from the DataKVIO associated with a DedupeContext.	2	"DataLocation getDedupeAdvice(const DedupeContext *context) {
  DataKVIO *dataKVIO = container_of(context, DataKVIO, dedupeContext);
  return (DataLocation){
      .state = dataKVIO->dataVIO.newMapped.state,
      .pbn = dataKVIO->dataVIO.newMapped.pbn,
  };
}"
viking-gps-viking-4518f80/src/vikmapniklayer.c	render: Common render function which can run in separate thread	2	"static void render(VikMapnikLayer *vml, VikCoord *ul, VikCoord *br,
                   MapCoord *ulm) {
  gint64 tt1 = g_get_real_time();
  GdkPixbuf *pixbuf = mapnik_interface_render(
      vml->mi, ul->north_south, ul->east_west, br->north_south, br->east_west);
  gint64 tt2 = g_get_real_time();
  gdouble tt = (gdouble)(tt2 - tt1) / 1000000;
  g_debug(""Mapnik rendering completed in %.3f seconds"", tt);
  if (!pixbuf) {

    pixbuf = gdk_pixbuf_scale_simple(
        gdk_pixbuf_from_pixdata(&vikmapniklayer_pixbuf, FALSE, NULL),
        vml->tile_size_x, vml->tile_size_x, GDK_INTERP_BILINEAR);
  }
  possibly_save_pixbuf(vml, pixbuf, ulm);

  if (vml->alpha < 255)
    pixbuf = ui_pixbuf_scale_alpha(pixbuf, vml->alpha);
  a_mapcache_add(pixbuf, (mapcache_extra_t){tt}, ulm->x, ulm->y, ulm->z,
                 MAP_ID_MAPNIK_RENDER, ulm->scale, vml->alpha, 0.0, 0.0,
                 vml->filename_xml);
  g_object_unref(pixbuf);
}"
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavcodec/utils.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  AVPacket *pkt = avctx->internal->pkt;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
  };

  if (pkt) {
    frame->pkt_pts = pkt->pts;
    av_frame_set_pkt_pos(frame, pkt->pos);
    av_frame_set_pkt_duration(frame, pkt->duration);
    av_frame_set_pkt_size(frame, pkt->size);

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
    add_metadata_from_side_data(pkt, frame);
  } else {
    frame->pkt_pts = AV_NOPTS_VALUE;
    av_frame_set_pkt_pos(frame, -1);
    av_frame_set_pkt_duration(frame, 0);
    av_frame_set_pkt_size(frame, -1);
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
    av_frame_set_colorspace(frame, avctx->colorspace);
  if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
    av_frame_set_color_range(frame, avctx->color_range);
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    av_frame_set_channels(frame, avctx->channels);
    break;
  }
  return 0;
}"
boazsegev-iodine-b6bdf50/ext/iodine/iodine_json.c	the JSON parsing is complete	2	"static void fio_json_on_error(json_parser_s *p) {
  iodine_json_parser_s *pr = (iodine_json_parser_s *)p;
#if DEBUG
  FIO_LOG_ERROR(""JSON on error called."");
#endif
  IodineStore.remove((VALUE)fio_json_stack_get(&pr->stack, 0));
  IodineStore.remove(pr->key);
  fio_json_stack_free(&pr->stack);
  *pr = (iodine_json_parser_s){.top = 0};
}"
tpm2-software-tpm2-abrmd-15be9f7/test/resource-manager_unit.c	A test: exercise the resource_manager_process_tpm2_command function. This function is normally invoked by the ResourceManager internal thread. We invoke it directly here to control variables and timing issues with the thread.	2	"resource_manager_process_tpm2_command_success_test(void **state) {
  test_data_t *data = (test_data_t *)*state;
  Tpm2Response *response;
  guint8 *buffer;

  buffer = calloc(1, TPM_HEADER_SIZE);

  data->command = tpm2_command_new(data->connection, buffer, TPM_HEADER_SIZE,
                                   (TPMA_CC){
                                       0,
                                   });
  response = tpm2_response_new_rc(data->connection, TSS2_RC_SUCCESS);

  g_object_ref(response);

  will_return(__wrap_access_broker_send_command, TSS2_RC_SUCCESS);
  will_return(__wrap_access_broker_send_command, response);

  will_return(__wrap_sink_enqueue, data);
  resource_manager_process_tpm2_command(data->resource_manager, data->command);
  assert_int_equal(data->response, response);
  g_object_unref(response);
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/numerical_flux/numerical_flux_euler_T.c	Version of compute_Numerical_Flux_fptr_T computing the numerical fluxes and Jacobians using the Lax-Friedrichs method. See comments for compute_Numerical_Flux_T_euler_lax_friedrichs.	2	"(const struct Numerical_Flux_Input_T *num_flux_i,
 struct mutable_Numerical_Flux_T *num_flux) {
  const struct const_Multiarray_T *const sL = num_flux_i->bv_l.s;
  const Type *const rhoL_p = get_col_const_Multiarray_T(0, sL),
                    *const rhouvwL_p[] =
                        ARRAY_DIM(get_col_const_Multiarray_T(1, sL),
                                  get_col_const_Multiarray_T(2, sL),
                                  get_col_const_Multiarray_T(3, sL)),
                    *const EL_p = get_col_const_Multiarray_T(NVAR - 1, sL);

  const struct const_Multiarray_T *const sR = num_flux_i->bv_r.s;
  const Type *const rhoR_p = get_col_const_Multiarray_T(0, sR),
                    *const rhouvwR_p[] =
                        ARRAY_DIM(get_col_const_Multiarray_T(1, sR),
                                  get_col_const_Multiarray_T(2, sR),
                                  get_col_const_Multiarray_T(3, sR)),
                    *const ER_p = get_col_const_Multiarray_T(NVAR - 1, sR);

  const bool *const c_m = num_flux_i->flux_i->compute_member;

  assert(c_m[0]);
  Type *nnf[NEQ] = {NULL};
  for (int eq = 0; eq < NEQ; eq++)
    nnf[eq] = get_col_Multiarray_T(eq, num_flux->nnf);

  assert(c_m[1]);
  Type *dnnf_dsL[NEQ * NVR] = {NULL};
  Type *dnnf_dsR[NEQ * NVR] = {NULL};
  for (int vr = 0; vr < NVR; ++vr) {
    for (int eq = 0; eq < NEQ; ++eq) {
      const int ind = eq + NEQ * (vr);
      dnnf_dsL[ind] =
          get_col_Multiarray_T(ind, num_flux->neigh_info[0].dnnf_ds);
      dnnf_dsR[ind] =
          get_col_Multiarray_T(ind, num_flux->neigh_info[1].dnnf_ds);
    }
  }

  assert(!c_m[3]);

  struct Flux_Input_T flux_i = {
      .compute_member = c_m,
  };
  flux_i.s = constructor_move_const_Multiarray_T_T(
      'C', 2, (ptrdiff_t[]){1, NVR}, false, NULL);

  struct mutable_Flux_T flux;
  flux.f = constructor_move_Multiarray_T_T('C', 3, (ptrdiff_t[]){1, DIM, NEQ},
                                           false, NULL);
  flux.df_ds = constructor_move_Multiarray_T_T(
      'C', 4, (ptrdiff_t[]){1, DIM, NEQ, NVAR}, false, NULL);

  const struct const_Multiarray_T *const nL_p = num_flux_i->bv_l.normals;

  const ptrdiff_t n_n = sL->extents[0];
  for (ptrdiff_t n = 0; n < n_n; ++n) {
    const Type rhoL = rhoL_p[n],
               rhouvwL[] =
                   ARRAY_DIM(rhouvwL_p[0][n], rhouvwL_p[1][n], rhouvwL_p[2][n]),
               EL = EL_p[n], rhoL_inv = 1.0 / rhoL,
               uvwL[] = ARRAY_DIM(rhoL_inv * rhouvwL[0], rhoL_inv * rhouvwL[1],
                                  rhoL_inv * rhouvwL[2]),
               V2L = compute_V2_from_uvw_T(uvwL), VL = sqrt_T(V2L),
               pL = GM1 * (EL - 0.5 * rhoL * V2L),
               cL = sqrt_T(GAMMA * pL / rhoL);

    const Type rhoR = rhoR_p[n],
               rhouvwR[] =
                   ARRAY_DIM(rhouvwR_p[0][n], rhouvwR_p[1][n], rhouvwR_p[2][n]),
               ER = ER_p[n], rhoR_inv = 1.0 / rhoR,
               uvwR[] = ARRAY_DIM(rhoR_inv * rhouvwR[0], rhoR_inv * rhouvwR[1],
                                  rhoR_inv * rhouvwR[2]),
               V2R = compute_V2_from_uvw_T(uvwR), VR = sqrt_T(V2R),
               pR = GM1 * (ER - 0.5 * rhoR * V2R),
               cR = sqrt_T(GAMMA * pR / rhoR);

    const Type sL_n[] = ARRAY_VAR(rhoL, rhouvwL[0], rhouvwL[1], rhouvwL[2], EL);
    const_cast_T1(&flux_i.s->data, sL_n);

    Type fL_n[DIM * NEQ] = {0.0};
    Type dfL_dsL_n[DIM * NEQ * NVR] = {0.0};
    flux.f->data = fL_n;
    flux.df_ds->data = dfL_dsL_n;
    compute_Flux_T_euler(&flux_i, &flux);

    const Type sR_n[] = ARRAY_VAR(rhoR, rhouvwR[0], rhouvwR[1], rhouvwR[2], ER);
    const_cast_T1(&flux_i.s->data, sR_n);

    Type fR_n[DIM * NEQ] = {0.0};
    Type dfR_dsR_n[DIM * NEQ * NVR] = {0.0};
    flux.f->data = fR_n;
    flux.df_ds->data = dfR_dsR_n;
    compute_Flux_T_euler(&flux_i, &flux);

    Type const maxlL = VL + cL, maxlR = VR + cR;
    Type maxV = 0.0;
    bool use_left = true;
    if (real_T(maxlL) > real_T(maxlR)) {
      maxV = maxlL;
      use_left = true;
    } else {
      maxV = maxlR;
      use_left = false;
    }

    const Type *const nL = get_row_const_Multiarray_T(n, nL_p);

    for (int eq = 0; eq < NEQ; ++eq) {
      for (int d = 0; d < DIM; ++d) {
        const int ind_f = d + DIM * eq;
        nnf[eq][n] += nL[d] * (fL_n[ind_f] + fR_n[ind_f]);
      }
      nnf[eq][n] += maxV * (sL_n[eq] - sR_n[eq]);
      nnf[eq][n] *= 0.5;
    }

    const Type *const dmaxV_ds =
        (use_left ? compute_dmaxV_ds(rhoL_inv, pL, V2L, VL, cL, uvwL)
                  : compute_dmaxV_ds(rhoR_inv, pR, V2R, VR, cR, uvwR));

    for (int vr = 0; vr < NVR; ++vr) {
      for (int eq = 0; eq < NEQ; ++eq) {
        const int ind_dnnf = eq + NEQ * (vr);
        for (int d = 0; d < DIM; ++d) {
          const int ind_f = d + DIM * ind_dnnf;
          dnnf_dsL[ind_dnnf][n] += nL[d] * (dfL_dsL_n[ind_f]);
          dnnf_dsR[ind_dnnf][n] += nL[d] * (dfR_dsR_n[ind_f]);
        }

        if (use_left)
          dnnf_dsL[ind_dnnf][n] += dmaxV_ds[vr] * (sL_n[eq] - sR_n[eq]);
        else
          dnnf_dsR[ind_dnnf][n] += dmaxV_ds[vr] * (sL_n[eq] - sR_n[eq]);
        if (vr == eq) {
          dnnf_dsL[ind_dnnf][n] += maxV * (1.0);
          dnnf_dsR[ind_dnnf][n] += maxV * (-1.0);
        }

        dnnf_dsL[ind_dnnf][n] *= 0.5;
        dnnf_dsR[ind_dnnf][n] *= 0.5;
      }
    }
  }

  destructor_const_Multiarray_T(flux_i.s);
  destructor_Multiarray_T(flux.f);
  destructor_Multiarray_T(flux.df_ds);
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	Liefert das jeweils kleinere Element der beiden Vektoren	2	"static inline vec_float4 simd_min(vec_float4 a, vec_float4 b) {
#if defined(__SSE__)
  return _mm_min_ps(a, b);
#elif defined(__VEC__)
  return vec_min(a, b);
#elif defined(__NEON__)
  return vminq_f32(a, b);
#else
  const float *aF = (const float *)&a;
  const float *bF = (const float *)&b;
  return (vec_float4){fminf(aF[0], bF[0]), fminf(aF[1], bF[1]),
                      fminf(aF[2], bF[2]), fminf(aF[3], bF[3])};
#endif
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_operators_tp.c	Provides unit tests for the application of tensor-product sub-operators.	2	"static void test_unit_apply_tp(struct Test_Info *const test_info,
                               const char *const e_type) {
  sprintf(test_info->name, ""%s%s%s"", ""Operators - apply tp ("", e_type, "")"");

  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;
  char var_name[STRLEN_MIN] = {
      0,
  };

  const char *const file_name_full =
      set_data_file_name_unit(""operators/operators_tp"");

  sprintf(var_name, ""%s%s"", e_type, ""_ops_tp"");
  const struct const_Multiarray_Matrix_d *ops_tp =
      constructor_file_name_const_Multiarray_Matrix_d(var_name, file_name_full);
  struct Operator op = {
      .ops_tp = ops_tp,
      .op_std = constructor_op_std(ops_tp),
      .op_csr = NULL,
  };

  sprintf(var_name, ""%s%s"", e_type, ""_b"");
  const struct const_Multiarray_d *b_r =
      constructor_file_name_const_Multiarray_d(var_name, file_name_full);

  sprintf(var_name, ""%s%s"", e_type, ""_c"");
  const struct const_Multiarray_d *c_r =
      constructor_file_name_const_Multiarray_d(var_name, file_name_full);

  const struct const_Multiarray_d *c_std =
      constructor_mm_NN1C_const_Multiarray_d(op.op_std, b_r);
  const struct const_Multiarray_d *c_tp =
      constructor_mm_tp_NN1C_const_Multiarray_d(op.ops_tp, b_r);

  destructor_const_Matrix_d(op.op_std);
  destructor_const_Multiarray_Matrix_d(op.ops_tp);
  destructor_const_Multiarray_d(b_r);

  tol = (double[]){
      EPS,
      EPS,
  };
  differences = (bool[]){
      diff_const_Multiarray_d(c_r, c_std, tol[0]),
      diff_const_Multiarray_d(c_r, c_tp, tol[1]),
  };
  if (check_diff(2, differences, &pass)) {
    if (differences[0])
      print_diff_const_Multiarray_d(c_r, c_std, tol[0]);
    if (differences[1])
      print_diff_const_Multiarray_d(c_r, c_tp, tol[1]);
  }
  assert_condition(pass);

  destructor_const_Multiarray_d(c_r);
  destructor_const_Multiarray_d(c_std);
  destructor_const_Multiarray_d(c_tp);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/list-proj.c	"Returns a list containing every strideth value, starting at offset. Specifically, the result will containain every element from the input list of index ix, where (offset == ix % stride). For example, demux([a b c d e f g h i], 1, 3) produces [b e h]. offset must be strictly less than stride. This function is aware of values produced by ava_list_proj_interleave() and can invert them quickly. This transform assumes that the caller plans on extracting a majority of the offsets as separate lists; as such, it holds onto the entire original list."	2	"ava_list_value ava_list_proj_demux(ava_list_value delegate, size_t offset,
                                   size_t stride) {
  ava_list_proj_demux_list *restrict this;

  assert(offset < stride);

  if (1 == stride)
    return delegate;

  if (&ava_list_proj_interleave_list_impl ==
      ava_get_attribute(delegate.v, &ava_list_trait_tag)) {
    const ava_list_proj_interleave_list *restrict il =
        ava_value_ptr(delegate.v);
    if (stride == il->num_lists) {
      return il->lists[offset].c;
    }
  }

  this = AVA_NEW(ava_list_proj_demux_list);
  this->delegate = ava_fat_list_value_of(delegate.v);
  this->offset = offset;
  this->stride = stride;

  return (ava_list_value){
      ava_value_with_ptr(&ava_list_proj_demux_list_impl, this)};
}"
libfirm-libfirm-bb6b635/ir/lower/lower_calls.c	"Lower aggregate types by replacing them with a pointer to the actual data. The caller allocates space for this data in its frame. This is firm's old default behaviour. This implements the SPARC ABI. This function can be used as a provisional ABI for unfinished backends. However, these backends will only be able to link to other code produced by firm. This function is stateless and does not require an environment (you may pass NULL)."	2	"aggregate_spec_t lower_aggregates_as_pointers(void *env, ir_type const *type) {
  (void)env;

  if (is_aggregate_type(type)) {
    return (aggregate_spec_t){
        .length = 1,
        .modes = {mode_P},
    };
  } else {
    return (aggregate_spec_t){
        .length = 1,
        .modes = {get_type_mode(type)},
    };
  }
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GrabKeyboard request. Grabs the client's keyboard and returns success status to client.	2	"ProcGrabKeyboard(ClientPtr client) {
  xGrabKeyboardReply rep;
  BYTE status;

  REQUEST(xGrabKeyboardReq);
  int result;
  DeviceIntPtr keyboard = PickKeyboard(client);
  GrabMask mask;

  REQUEST_SIZE_MATCH(xGrabKeyboardReq);
  UpdateCurrentTime();

  mask.core = KeyPressMask | KeyReleaseMask;

  result = GrabDevice(client, keyboard, stuff->pointerMode, stuff->keyboardMode,
                      stuff->grabWindow, stuff->ownerEvents, stuff->time, &mask,
                      CORE, None, None, &status);

  if (result != Success)
    return result;

  rep = (xGrabKeyboardReply){.type = X_Reply,
                             .status = status,
                             .sequenceNumber = client->sequence,
                             .length = 0};
  WriteReplyToClient(client, sizeof(xGrabKeyboardReply), &rep);
  return Success;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28, char __b27,
                char __b26, char __b25, char __b24, char __b23, char __b22,
                char __b21, char __b20, char __b19, char __b18, char __b17,
                char __b16, char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08, char __b07,
                char __b06, char __b05, char __b04, char __b03, char __b02,
                char __b01, char __b00) {
  return (__m256i)(__v32qi){__b00, __b01, __b02, __b03, __b04, __b05, __b06,
                            __b07, __b08, __b09, __b10, __b11, __b12, __b13,
                            __b14, __b15, __b16, __b17, __b18, __b19, __b20,
                            __b21, __b22, __b23, __b24, __b25, __b26, __b27,
                            __b28, __b29, __b30, __b31};
}"
lxc-lxc-ae6497d/src/lxc/terminal.c	Make fd a duplicate of the standard file descriptors. The fd is made a duplicate of a specific standard file descriptor iff the standard file descriptor refers to a terminal.	0	"int lxc_terminal_set_stdfds(int fd) {
  int i;

  if (fd < 0)
    return 0;

  for (i = 0; i < 3; i++)
    if (!__terminal_dup2(
            fd, (int[]){STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO}[i]))
      return -1;

  return 0;
}"
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  MPADecodeHeader c;
  int vbrtag_size = 0;
  MP3DecContext *mp3 = s->priv_data;
  int ret;

  ffio_init_checksum(s->pb, ff_crcA001_update, 0);

  v = avio_rb32(s->pb);

  ret = avpriv_mpegaudio_decode_header(&c, v);
  if (ret < 0)
    return ret;
  else if (ret == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  mp3->frames = 0;
  mp3->header_filesize = 0;

  mp3_parse_info_tag(s, st, &c, spf);
  mp3_parse_vbri_tag(s, st, base);

  if (!mp3->frames && !mp3->header_filesize)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (mp3->frames)
    st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                st->time_base);
  if (mp3->header_filesize && mp3->frames && !mp3->is_cbr)
    st->codec->bit_rate = av_rescale(mp3->header_filesize, 8 * c.sample_rate,
                                     mp3->frames * (int64_t)spf);

  return 0;
}"
zellio-pdf2laser-95836f6/src/pdf2laser_vector_list.c	Optimize the cut order to minimize transit time. Simplistic greedy algorithm: look for the closest vector that starts or ends at the same point as the current point. This does not split vectors.	2	"vector_list_t *vector_list_optimize(vector_list_t *self) {
  vector_list_t *list = vector_list_create();
  point_t *current_point = &(point_t){0, 0};

  while (self->head) {
    vector_t *vector = vector_list_find_closest(self, current_point);
    vector_list_append(list, vector);
    current_point = vector->end;
  }

  vector_list_stats(list);

  list->pass = self->pass;
  list->power = self->power;
  list->speed = self->speed;

  return list;
}"
amakaseev-sprite-sheet-packer-beffd9b/SpriteSheetPacker/3rdparty/pngquant/pam.h	Converts 8-bit color to internal gamma and premultiplied alpha. (premultiplied color space is much better for blending of semitransparent colors)	2	"inline static f_pixel rgba_to_f(const float gamma_lut[], const rgba_pixel px) {
  float a = px.a / 255.f;

  return (f_pixel){
      .a = a,
      .r = gamma_lut[px.r] * a,
      .g = gamma_lut[px.g] * a,
      .b = gamma_lut[px.b] * a,
  };
}"
mdhsl-FFmpeg-Pnacl-367670c/pnacl-ffmpeg-3.0.1/ffmpeg-3.0.1/libavcodec/utils.c	"Decode the audio frame of size avpkt->size from avpkt->data into frame. Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with AV_CODEC_CAP_DELAY, then no samples will be returned."	2	"int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx,
                                              AVFrame *frame,
                                              int *got_frame_ptr,
                                              const AVPacket *avpkt) {
  AVCodecInternal *avci = avctx->internal;
  int ret = 0;

  *got_frame_ptr = 0;

  if (!avpkt->data && avpkt->size) {
    av_log(avctx, AV_LOG_ERROR, ""invalid packet: NULL data, size != 0\n"");
    return AVERROR(EINVAL);
  }
  if (!avctx->codec)
    return AVERROR(EINVAL);
  if (avctx->codec->type != AVMEDIA_TYPE_AUDIO) {
    av_log(avctx, AV_LOG_ERROR, ""Invalid media type for audio\n"");
    return AVERROR(EINVAL);
  }

  av_frame_unref(frame);

  if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size ||
      (avctx->active_thread_type & FF_THREAD_FRAME)) {
    uint8_t *side;
    int side_size;
    uint32_t discard_padding = 0;
    uint8_t skip_reason = 0;
    uint8_t discard_reason = 0;

    AVPacket tmp = *avpkt;
    int did_split = av_packet_split_side_data(&tmp);
    ret = apply_param_change(avctx, &tmp);
    if (ret < 0) {
      av_log(avctx, AV_LOG_ERROR, ""Error applying parameter changes.\n"");
      if (avctx->err_recognition & AV_EF_EXPLODE)
        goto fail;
    }

    avctx->internal->pkt = &tmp;
    if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
      ret = ff_thread_decode_frame(avctx, frame, got_frame_ptr, &tmp);
    else {
      ret = avctx->codec->decode(avctx, frame, got_frame_ptr, &tmp);
      av_assert0(ret <= tmp.size);
      frame->pkt_dts = avpkt->dts;
    }
    if (ret >= 0 && *got_frame_ptr) {
      avctx->frame_number++;
      av_frame_set_best_effort_timestamp(
          frame, guess_correct_pts(avctx, frame->pkt_pts, frame->pkt_dts));
      if (frame->format == AV_SAMPLE_FMT_NONE)
        frame->format = avctx->sample_fmt;
      if (!frame->channel_layout)
        frame->channel_layout = avctx->channel_layout;
      if (!av_frame_get_channels(frame))
        av_frame_set_channels(frame, avctx->channels);
      if (!frame->sample_rate)
        frame->sample_rate = avctx->sample_rate;
    }

    side = av_packet_get_side_data(avctx->internal->pkt,
                                   AV_PKT_DATA_SKIP_SAMPLES, &side_size);
    if (side && side_size >= 10) {
      avctx->internal->skip_samples = AV_RL32(side);
      discard_padding = AV_RL32(side + 4);
      av_log(avctx, AV_LOG_DEBUG,
             ""skip %d / discard %d samples due to side data\n"",
             avctx->internal->skip_samples, (int)discard_padding);
      skip_reason = AV_RL8(side + 8);
      discard_reason = AV_RL8(side + 9);
    }
    if (avctx->internal->skip_samples && *got_frame_ptr &&
        !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (frame->nb_samples <= avctx->internal->skip_samples) {
        *got_frame_ptr = 0;
        avctx->internal->skip_samples -= frame->nb_samples;
        av_log(avctx, AV_LOG_DEBUG, ""skip whole frame, skip left: %d\n"",
               avctx->internal->skip_samples);
      } else {
        av_samples_copy(frame->extended_data, frame->extended_data, 0,
                        avctx->internal->skip_samples,
                        frame->nb_samples - avctx->internal->skip_samples,
                        avctx->channels, frame->format);
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(avctx->internal->skip_samples,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (frame->pkt_pts != AV_NOPTS_VALUE)
            frame->pkt_pts += diff_ts;
          if (frame->pkt_dts != AV_NOPTS_VALUE)
            frame->pkt_dts += diff_ts;
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for skipped samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""skip %d/%d samples\n"",
               avctx->internal->skip_samples, frame->nb_samples);
        frame->nb_samples -= avctx->internal->skip_samples;
        avctx->internal->skip_samples = 0;
      }
    }

    if (discard_padding > 0 && discard_padding <= frame->nb_samples &&
        *got_frame_ptr && !(avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL)) {
      if (discard_padding == frame->nb_samples) {
        *got_frame_ptr = 0;
      } else {
        if (avctx->pkt_timebase.num && avctx->sample_rate) {
          int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                         (AVRational){1, avctx->sample_rate},
                                         avctx->pkt_timebase);
          if (av_frame_get_pkt_duration(frame) >= diff_ts)
            av_frame_set_pkt_duration(frame, av_frame_get_pkt_duration(frame) -
                                                 diff_ts);
        } else {
          av_log(avctx, AV_LOG_WARNING,
                 ""Could not update timestamps for discarded samples.\n"");
        }
        av_log(avctx, AV_LOG_DEBUG, ""discard %d/%d samples\n"",
               (int)discard_padding, frame->nb_samples);
        frame->nb_samples -= discard_padding;
      }
    }

    if ((avctx->flags2 & AV_CODEC_FLAG2_SKIP_MANUAL) && *got_frame_ptr) {
      AVFrameSideData *fside =
          av_frame_new_side_data(frame, AV_FRAME_DATA_SKIP_SAMPLES, 10);
      if (fside) {
        AV_WL32(fside->data, avctx->internal->skip_samples);
        AV_WL32(fside->data + 4, discard_padding);
        AV_WL8(fside->data + 8, skip_reason);
        AV_WL8(fside->data + 9, discard_reason);
        avctx->internal->skip_samples = 0;
      }
    }
  fail:
    avctx->internal->pkt = NULL;
    if (did_split) {
      av_packet_free_side_data(&tmp);
      if (ret == tmp.size)
        ret = avpkt->size;
    }

    if (ret >= 0 && *got_frame_ptr) {
      if (!avctx->refcounted_frames) {
        int err = unrefcount_frame(avci, frame);
        if (err < 0)
          return err;
      }
    } else
      av_frame_unref(frame);
  }

  return ret;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_data.c	"Returns a temporary(!) C string including the end of line marker. Careful when using this call on large file streams, as the whole file stream might be loaded into the memory. The C string object will be invalidate the next time a function call to the IO object is made."	2	"fio_str_info_s fiobj_data_read2ch(FIOBJ io, uint8_t token) {
  if (!io || !FIOBJ_TYPE_IS(io, FIOBJ_T_DATA)) {
    errno = EFAULT;
    return (fio_str_info_s){.data = NULL, .len = 0};
  }
  switch (obj2io(io)->fd) {
  case -1:
    return fiobj_data_read2ch_str(io, token);
    break;
  case -2:
    return fiobj_data_read2ch_slice(io, token);
    break;
  default:
    return fiobj_data_read2ch_file(io, token);
  }
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  MPADecodeHeader c;
  int vbrtag_size = 0;
  MP3DecContext *mp3 = s->priv_data;
  int ret;

  ffio_init_checksum(s->pb, ff_crcA001_update, 0);

  v = avio_rb32(s->pb);

  ret = avpriv_mpegaudio_decode_header(&c, v);
  if (ret < 0)
    return ret;
  else if (ret == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  mp3->frames = 0;
  mp3->header_filesize = 0;

  mp3_parse_info_tag(s, st, &c, spf);
  mp3_parse_vbri_tag(s, st, base);

  if (!mp3->frames && !mp3->header_filesize)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (mp3->frames)
    st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                st->time_base);
  if (mp3->header_filesize && mp3->frames && !mp3->is_cbr)
    st->codecpar->bit_rate = av_rescale(mp3->header_filesize, 8 * c.sample_rate,
                                        mp3->frames * (int64_t)spf);

  return 0;
}"
nvmd-itpp-547367b/itpp/optim/newton_search.h	Do the line search.	2	"void set_start_point(const vec &x);

vec get_solution();

bool search();

bool search(vec &xn);

bool search(const vec &x0, vec &xn);

void set_stop_values(double epsilon_1, double epsilon_2);

double get_epsilon_1() { return stop_epsilon_1; }

double get_epsilon_2() { return stop_epsilon_2; }

void set_max_evaluations(int value);

int get_max_evaluations() { return max_evaluations; }

void set_initial_stepsize(double value);

double get_initial_stepsize() { return initial_stepsize; }

void set_method(const Newton_Search_Method &method);

double get_function_value();

double get_stop_1();

double get_stop_2();

int get_no_iterations();

int get_no_function_evaluations();

void enable_trace() { trace = true; }

void disable_trace() { trace = false; }

void get_trace(Array<vec> &xvalues, vec &Fvalues, vec &ngvalues, vec &dvalues);

private:
int n;
double (*f)(const vec &);
vec (*df_dx)(const vec &);

vec x_start;
mat D_start;

vec x_end;

Array<vec> x_values;
vec F_values, ng_values, Delta_values;

Newton_Search_Method method;

double initial_stepsize;
double stop_epsilon_1;
double stop_epsilon_2;
int max_evaluations;

int no_feval;
int no_iter;
double F, ng, nh;

bool init, finished, trace;
}
;

enum Line_Search_Method { Soft, Exact };

class Line_Search {
public:
  Line_Search();

  ~Line_Search(){};

  void set_function(double (*function)(const vec &));

  void set_gradient(vec (*gradient)(const vec &));

  void set_functions(double (*function)(const vec &),
                     vec (*gradient)(const vec &)) {
    set_function(function);
    set_gradient(gradient);
  }"
psyc-libpsyc-d16deca/include/psyc/parse.h	Sets a new buffer in the parser state struct with data to be parsed. This function does NOT copy the buffer. It will parse whatever is at the memory pointed to by buffer.	2	"psyc_parse_buffer_set(PsycParseState *state, const char *buffer,
                      size_t length) {
  state->buffer = (PsycString){length, (char *)buffer};
  state->cursor = 0;

  if (state->flags & PSYC_PARSE_START_AT_CONTENT) {
    state->contentlen = length;
    state->contentlen_found = PSYC_TRUE;
  }
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/control-center/source/arm_uc_control_center.c	If the end-user has modified the bootloader the hash of the modified bootloader can be set here.	1	"arm_uc_error_t
ARM_UC_ControlCenter_ReportOEMBootloaderHash(arm_uc_buffer_t *hash) {
  UC_CONT_TRACE(""ARM_UC_ControlCenter_ReportOEMBootloaderHash"");

  arm_uc_error_t result = (arm_uc_error_t){ERR_INVALID_PARAMETER};

  if (arm_uc_monitor_struct && arm_uc_monitor_struct->SetOEMBootloaderHash) {
    result = arm_uc_monitor_struct->SetOEMBootloaderHash(hash);
  }

  return result;
}"
opticron-libuweave-2e5e385/src/value_scan.c	Initializes the array_iter with the binary_cbor_value. Returns an error if the binary value is malformed or invalid.	2	"UwStatus uw_value_array_iterator_init(UwValueArrayIterator *array_iter,
                                      const UwValue *binary_cbor_value) {
  if (binary_cbor_value->type != kUwValueTypeBinaryCbor) {
    return kUwStatusValueTypeMismatch;
  }

  *array_iter = (UwValueArrayIterator){};

  CborError error = cbor_parser_init(binary_cbor_value->value.binary_cbor_value,
                                     binary_cbor_value->length, 0,
                                     &array_iter->parser, &array_iter->root);

  if (error != CborNoError) {
    return kUwStatusInvalidInput;
  }

  if (!cbor_value_is_valid(&array_iter->root) ||
      !cbor_value_is_array(&array_iter->root)) {
    UW_LOG_WARN(""Expecting parameter value to be a array\n"");
    return kUwStatusValueInvalidInput;
  }

  error = cbor_value_get_array_length(&array_iter->root, &array_iter->size);
  if (error != CborNoError) {
    return kUwStatusInvalidInput;
  }

  error = cbor_value_enter_container(&array_iter->root, &array_iter->iter);
  if (error != CborNoError) {
    return kUwStatusInvalidInput;
  }

  return kUwStatusSuccess;
}"
cochrane-GLLara-91ed369/shared_simd/simd_matrix.h	Subtrahiert zwei Matrizen komponentenweise	2	"static inline mat_float16 simd_mat_sub(mat_float16 a, mat_float16 b) {
  return (mat_float16){a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}"
CZ-NIC-knot-886f882/src/contrib/qp-trie/trie.c	"Initialize a new leaf, copying the key, and returning failure code."	2	"static int mkleaf(node_t *leaf, const trie_key_t *key, uint32_t len,
                  knot_mm_t *mm) {
  if (unlikely((word)len > (BIG1 << KEYLENBITS)))
    return KNOT_ENOMEM;
  tkey_t *lkey = mm_alloc(mm, sizeof(tkey_t) + len);
  if (unlikely(!lkey))
    return KNOT_ENOMEM;
  lkey->cow = 0;
  lkey->len = len;
  memcpy(lkey->chars, key, len);
  word i = (uintptr_t)lkey;
  assert((i & TFLAG_BRANCH) == 0);
  *leaf = (node_t){.i = i, .p = NULL};
  return KNOT_EOK;
}"
EvolBioInf-andi-e92b453/libs/pfasta.c	Frees a dynamic string.	2	"static inline void dynstr_free(dynstr *ds) {
  if (!ds)
    return;
  free(ds->str);
  *ds = (dynstr){NULL, 0, 0};
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/alpn-test.c	"In this test case, establish a security context, with server ready for ALPN, and the client sends the second alpn in the server's protocol list."	3	"init_alpn_secondary_match(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;
  const char *why = """";
  unsigned char server_alpn[] = {
      3, 'g', 's', 's', 3, 'g', 's', 'i',
  };
  unsigned char client_alpn[] = {
      3,
      'g',
      's',
      'i',
  };

  major_status =
      gss_set_sec_context_option(&minor_status, &init_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = client_alpn,
                                     .length = sizeof(client_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }

  major_status =
      gss_set_sec_context_option(&minor_status, &accept_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = server_alpn,
                                     .length = sizeof(server_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, init_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);
    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 1 || data->elements[0].length != server_alpn[0] ||
        memcmp(data->elements[0].value, &server_alpn[5], server_alpn[4]) != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    gss_release_buffer_set(&minor_status, &data);

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, accept_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);
    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 1 || data->elements[0].length != client_alpn[0] ||
        memcmp(data->elements[0].value, &client_alpn[1], client_alpn[0]) != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
    gss_release_buffer_set(&minor_status, &data);
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/Incomplete/BluetoothHost/Lib/BluetoothHCICommands.c	Sends a Bluetooth HCI control command to the attached Bluetooth device.	1	"static uint8_t
Bluetooth_SendHCICommand(const BT_HCICommand_Header_t *const HCICommandHeader,
                         const void *Parameters,
                         const uint16_t ParameterLength) {

  uint8_t CommandBuffer[sizeof(BT_HCICommand_Header_t) +
                        HCICommandHeader->ParameterLength];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_DEVICE),
      .bRequest = 0,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CommandBuffer)};

  memcpy(CommandBuffer, HCICommandHeader, sizeof(BT_HCICommand_Header_t));

  memset(&CommandBuffer[sizeof(BT_HCICommand_Header_t)], 0x00,
         HCICommandHeader->ParameterLength);

  memcpy(&CommandBuffer[sizeof(BT_HCICommand_Header_t)], Parameters,
         ParameterLength);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);
  return USB_Host_SendControlRequest(CommandBuffer);
}"
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit integer vector initialized with the specified 64-bit integral values.	2	"_mm256_set_epi64x(long long __a, long long __b, long long __c, long long __d) {
  return __extension__(__m256i)(__v4di){__d, __c, __b, __a};
}"
intel-iot-devkit-zmraa-f8c045d/source/uart.c	"Initialise uart_context, uses board mapping"	2	"mraa_uart_init(int uart) {

  mraa_board_t *board = plat;

  if (board == NULL) {
    printf(""uart: platform not initialised\n"");
    return NULL;
  }

  struct device *pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  if (pinmux_dev == NULL) {
    printf(""Failed to get binding for pinmux\n"");
    return NULL;
  }

#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_ARDUINO_101)
  if (uart == 0) {
    pinmux_pin_set(pinmux_dev, 17, PINMUX_FUNC_C);
    pinmux_pin_set(pinmux_dev, 16, PINMUX_FUNC_C);
    mraa_set_pininfo(board, 0, 17, ""IO0"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 1});
    mraa_set_pininfo(board, 1, 16, ""IO1"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 1});
  }
#endif

  mraa_uart_context dev = (mraa_uart_context)malloc(sizeof(struct _uart));
  dev->zdev = device_get_binding(UART_DEVICE);
  dev->block = 1;

  return dev;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavutil/utils.c	Return the fractional representation of the internal time base.	2	"AVRational av_get_time_base_q(void) { return (AVRational){1, AV_TIME_BASE}; }"
darktable-org-darktable-32fab21/src/iop/invert.c	construct widget.	2	"void gui_init(dt_iop_module_t *self) {
  self->gui_data = g_malloc0(sizeof(dt_iop_invert_gui_data_t));
  dt_iop_invert_gui_data_t *g = (dt_iop_invert_gui_data_t *)self->gui_data;
  dt_iop_invert_params_t *p = (dt_iop_invert_params_t *)self->params;

  self->widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
  dt_gui_add_help_link(self->widget, dt_get_help_url(self->op));

  g->label = DTGTK_RESET_LABEL(
      dtgtk_reset_label_new("""", self, &p->color, 4 * sizeof(float)));
  gtk_box_pack_start(GTK_BOX(self->widget), GTK_WIDGET(g->label), TRUE, TRUE,
                     0);

  g->pickerbuttons = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));
  gtk_box_pack_start(GTK_BOX(self->widget), GTK_WIDGET(g->pickerbuttons), TRUE,
                     TRUE, 0);

  GdkRGBA color = (GdkRGBA){.red = p->color[0],
                            .green = p->color[1],
                            .blue = p->color[2],
                            .alpha = 1.0};
  g->colorpicker = gtk_color_button_new_with_rgba(&color);
  gtk_widget_set_size_request(GTK_WIDGET(g->colorpicker),
                              DT_PIXEL_APPLY_DPI(75), DT_PIXEL_APPLY_DPI(24));
  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g->colorpicker), FALSE);
  gtk_color_button_set_title(GTK_COLOR_BUTTON(g->colorpicker),
                             _(""select color of film material""));
  g_signal_connect(G_OBJECT(g->colorpicker), ""color-set"",
                   G_CALLBACK(colorpicker_callback), self);
  gtk_box_pack_start(GTK_BOX(g->pickerbuttons), GTK_WIDGET(g->colorpicker),
                     TRUE, TRUE, 0);

  g->picker = dtgtk_togglebutton_new(dtgtk_cairo_paint_colorpicker,
                                     CPF_STYLE_FLAT, NULL);
  gtk_widget_set_tooltip_text(g->picker,
                              _(""pick color of film material from image""));
  gtk_widget_set_size_request(g->picker, DT_PIXEL_APPLY_DPI(24),
                              DT_PIXEL_APPLY_DPI(24));
  g_signal_connect(G_OBJECT(g->picker), ""toggled"",
                   G_CALLBACK(dt_iop_color_picker_callback), &g->color_picker);
  gtk_box_pack_start(GTK_BOX(g->pickerbuttons), g->picker, TRUE, TRUE, 5);

  dt_iop_init_single_picker(&g->color_picker, self, GTK_WIDGET(g->picker),
                            DT_COLOR_PICKER_AREA, _iop_color_picker_apply);
}"
Funky-System-Funky-VM-b389879/src/libvm/instructions/instr_branching.c	Branch to subroutine. Pushes the PC on the stack and jumps to the subroutine.	2	"INSTR(call) {

  AJS_STACK(+2);
  USE_STACK();
  vm_type_t addr = GET_OPERAND();
  vm_type_t num_args = GET_OPERAND();
  (stack - 1)->uint_value = state->pc;
  (stack - 1)->type = VM_TYPE_REF;

  state->pc = get_current_module(state)->addr + addr;

  *stack = (vm_value_t){.type = VM_TYPE_UINT, .uint_value = num_args};
}"
Ultimaker-CuraEngine-c7190f7/src/utils/polygonUtils.h	compute the length of a segment of a polygon	2	"ConstPolygonPointer poly;
unsigned int poly_idx;
unsigned int point_idx;
ClosestPolygonPoint(Point p, int pos, ConstPolygonRef poly)
    : location(p), poly(poly), poly_idx(NO_INDEX), point_idx(pos){};
ClosestPolygonPoint(Point p, int pos, ConstPolygonRef poly, int poly_idx)
    : location(p), poly(poly), poly_idx(poly_idx), point_idx(pos){};
ClosestPolygonPoint(ConstPolygonRef poly)
    : poly(poly), poly_idx(NO_INDEX), point_idx(NO_INDEX){};
ClosestPolygonPoint() : poly_idx(NO_INDEX), point_idx(NO_INDEX){};
Point p() const { return location; }
bool isValid() const { return point_idx != NO_INDEX; }
bool operator==(const ClosestPolygonPoint &rhs) {

  return poly == rhs.poly && point_idx == rhs.point_idx &&
         location == rhs.location;
}"
shwetasshinde24-Panoply-9a762c2/case-studies/h2o/src/H2oEnclave/h2omain/socketpool.cpp	connects to the peer (or returns a pooled connection)	2	"void h2o_socketpool_connect(h2o_socketpool_connect_request_t **_req,
                            h2o_socketpool_t *pool, h2o_loop_t *loop,
                            h2o_multithread_receiver_t *getaddr_receiver,
                            h2o_socketpool_connect_cb cb, void *data) {
  struct pool_entry_t *entry = NULL;

  if (_req != NULL)
    *_req = NULL;

  pthread_mutex_lock(&pool->_shared.mutex);
  destroy_expired(pool);
  while (1) {
    if (h2o_linklist_is_empty(&pool->_shared.sockets))
      break;
    entry = H2O_STRUCT_FROM_MEMBER(struct pool_entry_t, link,
                                   pool->_shared.sockets.next);
    h2o_linklist_unlink(&entry->link);
    pthread_mutex_unlock(&pool->_shared.mutex);

    char buf[1];
    ssize_t rret = recv(entry->sockinfo.fd, buf, 1, MSG_PEEK);
    if (rret == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {

      h2o_socket_t *sock = h2o_socket_import(loop, &entry->sockinfo);
      free(entry);
      sock->on_close.cb = on_close;
      sock->on_close.data = pool;
      cb(sock, NULL, data);
      return;
    }

    if (rret <= 0) {
      static long counter = 0;
      if (__sync_fetch_and_add(&counter, 1) == 0)
        fprintf(stderr, ""[WARN] detected close by upstream before the expected ""
                        ""timeout (see issue #679)\n"");
    } else {
      static long counter = 0;
      if (__sync_fetch_and_add(&counter, 1) == 0)
        fprintf(stderr, ""[WARN] unexpectedly received data to a pooled socket ""
                        ""(see issue #679)\n"");
    }
    destroy_detached(entry);
    pthread_mutex_lock(&pool->_shared.mutex);
  }
  pthread_mutex_unlock(&pool->_shared.mutex);

  __sync_add_and_fetch(&pool->_shared.count, 1);

  h2o_socketpool_connect_request_t *req = h2o_mem_alloc(sizeof(*req));
  *req = (h2o_socketpool_connect_request_t){data, cb, pool, loop};
  if (_req != NULL)
    *_req = req;

  switch (pool->type) {
  case H2O_SOCKETPOOL_TYPE_NAMED:

    req->getaddr_req = h2o_hostinfo_getaddr(
        getaddr_receiver, pool->peer.host, pool->peer.named_serv, AF_UNSPEC,
        SOCK_STREAM, IPPROTO_TCP, AI_ADDRCONFIG | AI_NUMERICSERV, on_getaddr,
        req);
    break;
  case H2O_SOCKETPOOL_TYPE_SOCKADDR:

    start_connect(req, (void *)&pool->peer.sockaddr.bytes,
                  pool->peer.sockaddr.len);
    break;
  }
}"
Meulengracht-MollenOS-e48f4ab/librt/include/xmmintrin.h	Loads a 32-bit float value and duplicates it to all four vector elements of a 128-bit vector of [4 x float].	2	"_mm_load1_ps(const float *__p) {
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct *)__p)->__u;
  return __extension__(__m128){__u, __u, __u, __u};
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Inquiry command to the attached device, to determine the device's information. This gives information on the device's capabilities."	1	"uint8_t MassStore_Inquiry(const uint8_t LUNIndex,
                          SCSI_Inquiry_Response_t *const InquiryPtr) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, InquiryPtr);
}"
parapluu-encore-3d5e973/src/runtime/party/reduce.c	"Reduces a ParT sequentially (not in parallel). This function is called when we have no guarantees of the associativity of the closure to run. For instance, the following reduce function reduce :: Par t -> a -> (t -> a -> a) -> Par a Given a Par t, an initial value and a reduce transformation function, run the reduce function sequentially over the items in the ParT"	2	"future_t *party_reduce_sequential(pony_ctx_t **ctx, par_t *const p,
                                  encore_arg_t init, closure_t *const closure,
                                  pony_type_t *type) {

  future_t *fut = future_mk(ctx, type);

  switch (party_tag(p)) {
  case EMPTY_PAR: {
    future_fulfil(ctx, fut, init);
    return fut;
  }
  case VALUE_PAR: {
    encore_arg_t value = party_get_v(p);
    value_t *args = setup_closure_args(value, init);

    value_t result = closure_call(ctx, closure, args);
    future_fulfil(ctx, fut, result);
    return fut;
  }
  case FUTURE_PAR: {
    future_t *fval = party_get_fut(p);
    if (!future_fulfilled(fval)) {
      future_await(ctx, fval);
    }

    encore_arg_t value = future_get_actor(ctx, fval);
    value_t *args = setup_closure_args(value, init);
    encore_arg_t result = closure_call(ctx, closure, args);
    future_fulfil(ctx, fut, result);
    return fut;
  }
  case PAR_PAR: {
    par_t *pleft = party_get_parleft(p);
    par_t *pright = party_get_parright(p);
    par_t **p_par = (par_t *[]){pleft, pright, NULL};

    encore_arg_t result = init;
    while (*p_par) {
      result = reduce_sequential(ctx, *p_par, result, closure, type);
      ++p_par;
    }
    future_fulfil(ctx, fut, result);
    return fut;
  }
  case FUTUREPAR_PAR: {
    future_t *fp = party_get_futpar(p);
    future_await(ctx, fp);
    par_t *const par = (future_get_actor(ctx, fp)).p;
    return party_reduce_sequential(ctx, par, init, closure, type);
  }
  case ARRAY_PAR: {
    array_t *ar = party_extract(ctx, p, type);
    size_t ar_size = array_size(ar);
    encore_arg_t result = init;
    for (size_t i = 0; i < ar_size; ++i) {
      encore_arg_t value = array_get(ar, i);
      result = closure_call(ctx, closure, (value_t[]){result, value});
    }
    future_fulfil(ctx, fut, result);
    return fut;
  }
  default:
    exit(-1);
  }
}"
latchset-luksmeta-fe3e941/libluksmeta.c	Checks for the existence of a valid LUKSMeta header on a LUKSv1 device	1	"luksmeta_test(struct crypt_device *cd) {
  int fd = -1;

  fd = read_header(cd, O_RDONLY, &(uint32_t){0}, &(lm_t){});
  if (fd >= 0) {
    close(fd);
    return 0;
  }

  return fd;
}"
darktable-org-darktable-32fab21/src/iop/sharpen.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_sharpen_params_t tmp = (dt_iop_sharpen_params_t){2.0, 0.5, 0.5};

  dt_gui_presets_add_generic(_(""sharpen""), self->op, self->version(), &tmp,
                             sizeof(dt_iop_sharpen_params_t), 1);

  dt_gui_presets_update_ldr(_(""sharpen""), self->op, self->version(), FOR_RAW);

  const gboolean auto_apply =
      dt_conf_get_bool(""plugins/darkroom/sharpen/auto_apply"");
  dt_gui_presets_update_autoapply(_(""sharpen""), self->op, self->version(),
                                  auto_apply);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Add two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qaddl(const quaternion_long_double num1, const quaternion_long_double num2) {
  return (quaternion_long_double){num1.R + num2.R, num1.i + num2.i,
                                  num1.j + num2.j, num1.k + num2.k};
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavcodec/utils.c	Check that the provided sample aspect ratio is valid and set it on the codec context.	2	"int ff_set_sar(AVCodecContext *avctx, AVRational sar) {
  int ret = av_image_check_sar(avctx->width, avctx->height, sar);

  if (ret < 0) {
    av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"", sar.num,
           sar.den);
    avctx->sample_aspect_ratio = (AVRational){0, 1};
    return ret;
  } else {
    avctx->sample_aspect_ratio = sar;
  }
  return 0;
}"
viking-gps-viking-4518f80/src/vikmapniklayer.c	"load_pixbuf: If function returns GdkPixbuf properly, reference counter to this buffer has to be decreased, when buffer is no longer needed."	4	"static GdkPixbuf *load_pixbuf(VikMapnikLayer *vml, MapCoord *ulm, MapCoord *brm,
                              gboolean *rerender) {
  *rerender = FALSE;
  GdkPixbuf *pixbuf = NULL;
  gchar *filename =
      get_filename(vml->file_cache_dir, ulm->x, ulm->y, ulm->scale);

  GStatBuf gsb;
  if (g_stat(filename, &gsb) == 0) {

    GError *error = NULL;
    pixbuf = gdk_pixbuf_new_from_file(filename, &error);
    if (error) {
      g_warning(""%s: %s"", __FUNCTION__, error->message);
      g_error_free(error);
    } else {
      if (vml->alpha < 255)
        pixbuf = ui_pixbuf_set_alpha(pixbuf, vml->alpha);
      a_mapcache_add(pixbuf, (mapcache_extra_t){-42.0}, ulm->x, ulm->y, ulm->z,
                     MAP_ID_MAPNIK_RENDER, ulm->scale, vml->alpha, 0.0, 0.0,
                     vml->filename_xml);
    }

    if (planet_import_time < gsb.st_mtime) {
      *rerender = TRUE;
    }
  }
  g_free(filename);

  return pixbuf;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/compute_error/compute_error_euler.c	Add the computed and exact specified variable to the solution data Multiarrays.	2	"(const char var_type, struct Error_CE_Data *const e_ce_d,
 const struct Simulation *const sim) {
  UNUSED(sim);
  const ptrdiff_t ext_0 = e_ce_d->sol[0]->extents[0];
  struct Multiarray_d *const var = constructor_move_Multiarray_d_d(
      'C', 2, (ptrdiff_t[]){ext_0, 1}, false, NULL);
  for (int i = 0; i < 2; ++i) {
    struct Multiarray_d *sol = e_ce_d->sol[i];

    const ptrdiff_t ext_1_new = sol->extents[1] + 1;
    resize_Multiarray_d(sol, sol->order, (ptrdiff_t[]){ext_0, ext_1_new});

    sol->extents[1] = DIM + 2;
    var->data = get_col_Multiarray_d(ext_1_new - 1, sol);
    switch (var_type) {
    case 's':
      compute_entropy(var, (const struct const_Multiarray_d *)sol, 'p');
      break;
    case 't':
      compute_temperature(var, (const struct const_Multiarray_d *)sol, 'p');
      break;
    default:
      EXIT_ERROR(""Unsupported: %c."", var_type);
      break;
    }
    sol->extents[1] = ext_1_new;
  }
  destructor_Multiarray_d(var);
}"
dm-vdo-kvdo-8df6805/vdo/base/referenceOperation.c	Set up a ReferenceOperation for which we already have the lock.	2	"void setUpReferenceOperationWithLock(JournalOperation type,
                                     PhysicalBlockNumber pbn,
                                     BlockMappingState state, PBNLock *lock,
                                     ReferenceOperation *operation) {
  *operation = (ReferenceOperation){
      .type = type,
      .pbn = pbn,
      .state = state,
      .lockGetter = returnPBNLock,
      .context = lock,
  };
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Projects/MissileLauncher/MissileLauncher.c	Writes a report to the attached device.	1	"void WriteNextReport(uint8_t *const ReportOUTData,
                     const uint16_t ReportLength) {

  Pipe_SelectPipe(HID_DATA_OUT_PIPE);

  if (Pipe_IsConfigured()) {
    Pipe_Unfreeze();

    if (!(Pipe_IsOUTReady())) {

      Pipe_Freeze();

      return;
    }

    Pipe_Write_Stream_LE(ReportOUTData, ReportLength);

    Pipe_ClearOUT();

    Pipe_Freeze();
  } else {

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = HID_REQ_SetReport,
        .wValue = 0x02,
        .wIndex = 0x01,
        .wLength = ReportLength,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    USB_Host_SendControlRequest(ReportOUTData);
  }
}"
TurboVNC-turbovnc-79d9fbd/unix/Xvnc/programs/Xserver/dix/events.c	Server-side protocol handling for GetInputFocus request. Sends the current input focus for the client's keyboard back to the client.	2	"ProcGetInputFocus(ClientPtr client) {
  DeviceIntPtr kbd = PickKeyboard(client);
  xGetInputFocusReply rep;
  FocusClassPtr focus = kbd->focus;
  int rc;

  REQUEST_SIZE_MATCH(xReq);

  rc = XaceHook(XACE_DEVICE_ACCESS, client, kbd, DixGetFocusAccess);
  if (rc != Success)
    return rc;

  rep = (xGetInputFocusReply){.type = X_Reply,
                              .length = 0,
                              .sequenceNumber = client->sequence,
                              .revertTo = focus->revert};

  if (focus->win == NoneWin)
    rep.focus = None;
  else if (focus->win == PointerRootWin)
    rep.focus = PointerRoot;
  else
    rep.focus = focus->win->drawable.id;

  WriteReplyToClient(client, sizeof(xGetInputFocusReply), &rep);
  return Success;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Print the solution gradient data of a Navier-Stokes piece to the file.	2	"(FILE *file, const char sp_type, const struct const_Multiarray_d *const sol,
 const struct const_Multiarray_d *const grad) {
  char name[STRLEN_MIN];
  if (sp_type == 'p') {
    for (int d = 0; d < DIM; ++d) {
      sprintf(name, ""%s%c%d"", ""grad_rho"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 's');

      sprintf(name, ""%s%c%d"", ""grad_velocity"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 'v');

      sprintf(name, ""%s%c%d"", ""grad_p"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name, NULL, false, 's');
    }
  } else if (sp_type == 's') {
    const ptrdiff_t ext_0 = sol->extents[0], n_var = sol->extents[1];
    struct Multiarray_d *var =
        constructor_empty_Multiarray_d('C', 2, (ptrdiff_t[]){ext_0, 0});
    double *data = var->data;

    for (int d = 0; d < DIM; ++d) {
      var->extents[1] = 1;
      var->data = (double *)get_col_const_Multiarray_d(0 + d * n_var, grad);

      sprintf(name, ""%s%c%d"", ""grad_rho"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name,
                             (struct const_Multiarray_d *)var, false, 's');

      var->extents[1] = n_var - 2;
      var->data = (double *)get_col_const_Multiarray_d(1 + d * n_var, grad);

      sprintf(name, ""%s%c%d"", ""grad_velocity"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name,
                             (struct const_Multiarray_d *)var, false, 'v');

      var->extents[1] = 1;
      var->data =
          (double *)get_col_const_Multiarray_d(n_var - 1 + d * n_var, grad);

      sprintf(name, ""%s%c%d"", ""grad_p"", '_', d);
      fprint_vtk_DataArray_d(file, sp_type, name,
                             (struct const_Multiarray_d *)var, false, 's');
    }
    var->data = data;
    destructor_Multiarray_d(var);
  } else {
    EXIT_ERROR(""Unsupported: %c\n"", sp_type);
  }
}"
ImpulseAdventure-GUIslice-4bd031f/src/GUIslice.c	Initialize an Element struct	2	"void gslc_ResetElem(gslc_tsElem *pElem) {
  if (pElem == NULL) {
    static const char GSLC_PMEM FUNCSTR[] = ""ResetElem"";
    GSLC_DEBUG_PRINT_CONST(ERRSTR_NULL, FUNCSTR);
    return;
  }
  pElem->nFeatures = GSLC_ELEM_FEA_NONE;
  pElem->nFeatures &= ~GSLC_ELEM_FEA_VALID;
  pElem->nFeatures &= ~GSLC_ELEM_FEA_CLICK_EN;
  pElem->nFeatures &= ~GSLC_ELEM_FEA_GLOW_EN;
  pElem->nFeatures &= ~GSLC_ELEM_FEA_FRAME_EN;
  pElem->nFeatures &= ~GSLC_ELEM_FEA_FILL_EN;
  pElem->nId = GSLC_ID_NONE;
  pElem->nType = GSLC_TYPE_BOX;
  pElem->nGroup = GSLC_GROUP_ID_NONE;
  pElem->rElem = (gslc_tsRect){0, 0, 0, 0};
  pElem->sImgRefNorm = gslc_ResetImage();
  pElem->sImgRefGlow = gslc_ResetImage();
  pElem->colElemFrame = GSLC_COL_WHITE;
  pElem->colElemFill = GSLC_COL_WHITE;
  pElem->colElemFrameGlow = GSLC_COL_WHITE;
  pElem->colElemFillGlow = GSLC_COL_WHITE;
  pElem->eTxtFlags = GSLC_TXT_DEFAULT;
#if (GSLC_LOCAL_STR)
  pElem->pStrBuf[0] = '\0';
  pElem->nStrBufMax = 0;
#else
  pElem->pStrBuf = NULL;
  pElem->nStrBufMax = 0;
#endif
  pElem->colElemText = GSLC_COL_WHITE;
  pElem->colElemTextGlow = GSLC_COL_WHITE;
  pElem->eTxtAlign = GSLC_ALIGN_MID_MID;
  pElem->nTxtMargin = 0;
  pElem->pTxtFont = NULL;

  pElem->pXData = NULL;
  pElem->pfuncXEvent = NULL;
  pElem->pfuncXDraw = NULL;
  pElem->pfuncXTouch = NULL;
  pElem->pfuncXTick = NULL;
#if (GSLC_FEATURE_COMPOUND)
  pElem->pElemRefParent = NULL;
#endif
}"
zooko-libzstr-80ce66c/zstr.c	"The human-readable representation is: if a byte is a printable ASCII character other than `\', then just show it. If it is a '\', then show double backslash: '\'. Else the byte is not a printable ASCII character, so show its value in lowercase hexadecimal notation with a preceding backslash, e.g. `'. (This is like the Python human-readable representation.)"	2	"repr(const czstr z) {
  const zbyte *const ze = z.buf + z.len;
  const zbyte *zp = z.buf;
  zbyte *resp;
  zbyte *newp;

  zstr result = new_z(z.len * 4);
  if (result.buf == NULL)
    return result;

  resp = result.buf;
  while (zp < ze) {
    if (*zp == '\\') {
      *resp++ = '\\';
      *resp++ = '\\';
      zp++;
    } else if (isgraph(*zp) || (*zp == ' ')) {
      *resp++ = *zp++;
    } else {
      *resp++ = '\\';
      *resp++ = 'x';
      sprintf((char *)resp, ""%02x"", *zp++);
      resp += 2;
    }
  }
  result.len = resp - result.buf;
  *resp = '\0';
  newp = (zbyte *)realloc(result.buf, result.len + 1);
#ifdef Z_EXHAUST_EXIT
  CHECKMALLOCEXIT(newp);
#else
  if (newp == NULL) {
    return (zstr){0, NULL};
  }
#endif
  result.buf = newp;
  return result;
}"
darktable-org-darktable-32fab21/src/iop/borders.c	construct widget.	2	"void gui_init(struct dt_iop_module_t *self) {
  self->gui_data = malloc(sizeof(dt_iop_borders_gui_data_t));
  dt_iop_borders_gui_data_t *g = (dt_iop_borders_gui_data_t *)self->gui_data;
  dt_iop_borders_params_t *p = (dt_iop_borders_params_t *)self->params;

  self->widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);
  dt_gui_add_help_link(self->widget, dt_get_help_url(self->op));

  g->size = dt_bauhaus_slider_new_with_range(self, 0.0, 50.0, 0.5,
                                             p->size * 100.0, 2);
  dt_bauhaus_widget_set_label(g->size, NULL, _(""border size""));
  dt_bauhaus_slider_set_format(g->size, ""%.2f%%"");
  g_signal_connect(G_OBJECT(g->size), ""value-changed"",
                   G_CALLBACK(size_callback), self);
  gtk_widget_set_tooltip_text(
      g->size, _(""size of the border in percent of the full image""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->size, TRUE, TRUE, 0);

  g->aspect = dt_bauhaus_combobox_new(self);
  dt_bauhaus_combobox_set_editable(g->aspect, 1);
  dt_bauhaus_widget_set_label(g->aspect, NULL, _(""aspect""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->aspect, TRUE, TRUE, 0);
  gui_init_aspect(self);
  g_signal_connect(G_OBJECT(g->aspect), ""value-changed"",
                   G_CALLBACK(aspect_changed), self);
  gtk_widget_set_tooltip_text(
      g->aspect,
      _(""select the aspect ratio or right click and type your own (w:h)""));

  g->aspect_orient = dt_bauhaus_combobox_new(self);
  dt_bauhaus_widget_set_label(g->aspect_orient, NULL, _(""orientation""));
  dt_bauhaus_combobox_add(g->aspect_orient, _(""auto""));
  dt_bauhaus_combobox_add(g->aspect_orient, _(""portrait""));
  dt_bauhaus_combobox_add(g->aspect_orient, _(""landscape""));
  gtk_widget_set_tooltip_text(
      g->aspect_orient, _(""aspect ratio orientation of the image with border""));
  g_signal_connect(G_OBJECT(g->aspect_orient), ""value-changed"",
                   G_CALLBACK(aspect_orient_changed), self);
  gtk_box_pack_start(GTK_BOX(self->widget), g->aspect_orient, TRUE, TRUE, 0);

  g->pos_h = dt_bauhaus_combobox_new(self);
  dt_bauhaus_combobox_set_editable(g->pos_h, 1);
  dt_bauhaus_widget_set_label(g->pos_h, NULL, _(""horizontal position""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->pos_h, TRUE, TRUE, 0);
  g_signal_connect(G_OBJECT(g->pos_h), ""value-changed"",
                   G_CALLBACK(position_h_changed), self);
  gtk_widget_set_tooltip_text(
      g->pos_h, _(""select the horizontal position ratio relative to top ""
                  ""or right click and type your own (y:h)""));
  g->pos_v = dt_bauhaus_combobox_new(self);
  dt_bauhaus_combobox_set_editable(g->pos_v, 1);
  dt_bauhaus_widget_set_label(g->pos_v, NULL, _(""vertical position""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->pos_v, TRUE, TRUE, 0);
  g_signal_connect(G_OBJECT(g->pos_v), ""value-changed"",
                   G_CALLBACK(position_v_changed), self);
  gtk_widget_set_tooltip_text(
      g->pos_v, _(""select the vertical position ratio relative to left ""
                  ""or right click and type your own (x:w)""));
  gui_init_positions(self);

  g->frame_size = dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 0.5,
                                                   p->frame_size * 100.0, 2);
  dt_bauhaus_widget_set_label(g->frame_size, NULL, _(""frame line size""));
  dt_bauhaus_slider_set_format(g->frame_size, ""%.2f%%"");
  g_signal_connect(G_OBJECT(g->frame_size), ""value-changed"",
                   G_CALLBACK(frame_size_callback), self);
  gtk_widget_set_tooltip_text(
      g->frame_size,
      _(""size of the frame line in percent of min border width""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->frame_size, TRUE, TRUE, 0);

  g->frame_offset = dt_bauhaus_slider_new_with_range(
      self, 0.0, 100.0, 0.5, p->frame_offset * 100.0, 2);
  dt_bauhaus_widget_set_label(g->frame_offset, NULL, _(""frame line offset""));
  dt_bauhaus_slider_set_format(g->frame_offset, ""%.2f%%"");
  g_signal_connect(G_OBJECT(g->frame_offset), ""value-changed"",
                   G_CALLBACK(frame_offset_callback), self);
  gtk_widget_set_tooltip_text(
      g->frame_offset, _(""offset of the frame line beginning on picture side""));
  gtk_box_pack_start(GTK_BOX(self->widget), g->frame_offset, TRUE, TRUE, 0);

  GdkRGBA color = (GdkRGBA){.red = p->color[0],
                            .green = p->color[1],
                            .blue = p->color[2],
                            .alpha = 1.0};

  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
  g->colorpick = gtk_color_button_new_with_rgba(&color);
  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g->colorpick), FALSE);
  gtk_widget_set_size_request(GTK_WIDGET(g->colorpick), DT_PIXEL_APPLY_DPI(24),
                              DT_PIXEL_APPLY_DPI(24));
  gtk_color_button_set_title(GTK_COLOR_BUTTON(g->colorpick),
                             _(""select border color""));
  GtkWidget *label = dtgtk_reset_label_new(_(""border color""), self, &p->color,
                                           3 * sizeof(float));
  g_signal_connect(G_OBJECT(g->colorpick), ""color-set"",
                   G_CALLBACK(colorpick_color_set), self);

  g->border_picker = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(
      dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));
  gtk_widget_set_tooltip_text(GTK_WIDGET(g->border_picker),
                              _(""pick border color from image""));
  gtk_widget_set_size_request(GTK_WIDGET(g->border_picker),
                              DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));
  g_signal_connect(G_OBJECT(g->border_picker), ""toggled"",
                   G_CALLBACK(dt_iop_color_picker_callback), &g->color_picker);

  gtk_box_pack_start(GTK_BOX(box), label, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g->colorpick), FALSE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g->border_picker), FALSE, FALSE,
                     0);
  gtk_box_pack_start(GTK_BOX(self->widget), box, TRUE, TRUE, 0);

  box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
  g->frame_colorpick = gtk_color_button_new_with_rgba(&color);
  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(g->frame_colorpick), FALSE);
  gtk_color_button_set_title(GTK_COLOR_BUTTON(g->frame_colorpick),
                             _(""select frame line color""));
  gtk_widget_set_size_request(GTK_WIDGET(g->frame_colorpick),
                              DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));
  label = dtgtk_reset_label_new(_(""frame line color""), self, &p->color,
                                3 * sizeof(float));
  g_signal_connect(G_OBJECT(g->frame_colorpick), ""color-set"",
                   G_CALLBACK(frame_colorpick_color_set), self);

  g->frame_picker = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(
      dtgtk_cairo_paint_colorpicker, CPF_STYLE_FLAT, NULL));
  gtk_widget_set_tooltip_text(GTK_WIDGET(g->frame_picker),
                              _(""pick frame line color from image""));
  gtk_widget_set_size_request(GTK_WIDGET(g->frame_picker),
                              DT_PIXEL_APPLY_DPI(24), DT_PIXEL_APPLY_DPI(24));
  g_signal_connect(G_OBJECT(g->frame_picker), ""toggled"",
                   G_CALLBACK(dt_iop_color_picker_callback), &g->color_picker);

  gtk_box_pack_start(GTK_BOX(box), label, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g->frame_colorpick), FALSE, TRUE,
                     0);
  gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(g->frame_picker), FALSE, FALSE,
                     0);
  gtk_box_pack_start(GTK_BOX(self->widget), box, TRUE, TRUE, 0);

  dt_iop_init_picker(&g->color_picker, self, DT_COLOR_PICKER_POINT,
                     _iop_color_picker_get_set, _iop_color_picker_apply,
                     _iop_color_picker_update);
}"
Nejuf-monit-93afc86/src/status.c	Show all services in the service list.	2	"boolean_t status(const char *level, const char *group, const char *service) {
  boolean_t status = false;
  if (!exist_daemon()) {
    LogError(""Status not available -- the monit daemon is not running\n"");
    return status;
  }
  Socket_T S = NULL;
  if (Run.httpd.flags & Httpd_Net)

    S = Socket_create(
        Run.httpd.socket.net.address ? Run.httpd.socket.net.address
                                     : ""localhost"",
        Run.httpd.socket.net.port, Socket_Tcp, Socket_Ip4,
        (SslOptions_T){.use_ssl = Run.httpd.flags & Httpd_Ssl,
                       .clientpemfile = Run.httpd.socket.net.ssl.clientpem,
                       .allowSelfSigned =
                           Run.httpd.flags & Httpd_AllowSelfSignedCertificates},
        NET_TIMEOUT);
  else if (Run.httpd.flags & Httpd_Unix)
    S = Socket_createUnix(Run.httpd.socket.unix.path, Socket_Tcp, NET_TIMEOUT);
  else
    LogError(""Status not available - monit http interface is not enabled, ""
             ""please add the 'set httpd' statement\n"");
  if (S) {
    Socket_print(S, ""GET /_status?format=text&level=%s"", level);
    if (group) {
      char *_group = Util_urlEncode((char *)group);
      Socket_print(S, ""&group=%s"", _group);
      FREE(_group);
    }
    if (service) {
      char *_service = Util_urlEncode((char *)service);
      Socket_print(S, ""&service=%s"", _service);
      FREE(_service);
    }
    char *_auth = Util_getBasicAuthHeaderMonit();
    Socket_print(S, "" HTTP/1.0\r\n%s\r\n"", _auth ? _auth : """");
    FREE(_auth);

    char buf[1024];
    while (Socket_readLine(S, buf, sizeof(buf))) {
      if (*buf == '\n' || *buf == '\r')
        break;
      if (Str_startsWith(buf, ""HTTP/1.0 200""))
        status = true;
    }

    if (!status) {
      LogError(""Cannot read status from the monit daemon\n"");
    } else {
      while (Socket_readLine(S, buf, sizeof(buf)))
        printf(""%s"", buf);
    }
    Socket_free(&S);
  }
  return status;
}"
SL-RU-MakiseGUI-971c7c7/MakiseGUI/makise.c	Initialize gui and buffer structures.	2	"uint32_t makise_init(MakiseGUI *gui, MakiseDriver *driver,
                     MakiseBuffer *buffer) {
  gui->driver = driver;
  gui->buffer = buffer;
  gui->draw = 0;

  buffer->height = driver->lcd_height;
  buffer->width = driver->lcd_width;
  buffer->border = (MakiseBufferBorder){0,
                                        0,
                                        driver->lcd_width,
                                        driver->lcd_height,
                                        driver->lcd_width,
                                        driver->lcd_height};

  driver->gui = gui;
  buffer->gui = gui;

  buffer->depthmask = MAKISEGUI_BUFFER_DEPTHMASK;
  buffer->pixeldepth = MAKISEGUI_BUFFER_DEPTH;
  buffer->width = driver->lcd_width;
  buffer->height = driver->lcd_height;

  uint32_t len = buffer->height * buffer->width * buffer->pixeldepth;

  uint32_t lenb = len / 8;
  if (lenb * 8 < len)
    lenb += 1;

  buffer->size = lenb;

  return lenb;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Host/LowLevel/KeyboardHost/KeyboardHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = HID_REQ_SetProtocol,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Protocol).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  puts_P(PSTR(""Keyboard Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
MightyPork-avr-projects-1c993f8/projects/lcdsnake_v2/lib/debounce.c	Add a pin for debouncing (low level function)	2	"uint8_t debo_register(PORT_P reg, uint8_t bit, bool invert) {
  debo_slots[debo_next_slot] = (debo_slot_t){
      .reg = reg,
      .bit = bit | ((invert & 1) << 7) | (get_bit_p(reg, bit) << 6),
      .count = 0,
  };

  return debo_next_slot++;
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Host/ClassDriver/MIDIHost/MIDIHost.c	"Checks for movement of the board's joystick, and sends corresponding MIDI note on/off messages to the host."	2	"void CheckJoystickMovement(void) {
  static uint8_t PrevJoystickStatus;

  uint8_t MIDICommand = 0;
  uint8_t MIDIPitch;

  uint8_t JoystickStatus = Joystick_GetStatus();
  uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

  uint8_t Channel = ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                             : MIDI_CHANNEL(1));

  if (JoystickChanges & JOY_LEFT) {
    MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3C;
  } else if (JoystickChanges & JOY_UP) {
    MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                             : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3D;
  } else if (JoystickChanges & JOY_RIGHT) {
    MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3E;
  } else if (JoystickChanges & JOY_DOWN) {
    MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3F;
  } else if (JoystickChanges & JOY_PRESS) {
    MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                : MIDI_COMMAND_NOTE_OFF);
    MIDIPitch = 0x3B;
  }

  if (MIDICommand) {
    MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
        .CableNumber = 0,
        .Command = (MIDICommand >> 4),

        .Data1 = MIDICommand | Channel,
        .Data2 = MIDIPitch,
        .Data3 = MIDI_STANDARD_VELOCITY,
    };

    MIDI_Host_SendEventPacket(&Keyboard_MIDI_Interface, &MIDIEvent);
    MIDI_Host_Flush(&Keyboard_MIDI_Interface);
  }

  PrevJoystickStatus = JoystickStatus;
}"
yingted-miredo-2ea60a3/libteredo/relay.c	Receives a packet coming from the Teredo tunnel (as specified per paragraph 5.4.2). That's called Packet reception. This function will NOT block if no packet are pending processing; it will return immediatly. Thread-safety: This function is thread-safe.	2	"teredo_run_inner(teredo_tunnel *restrict tunnel,
                 const struct teredo_packet *restrict packet) {
  assert(tunnel != NULL);
  assert(packet != NULL);

#ifndef NDEBUG
  char b[INET6_ADDRSTRLEN];
#endif
  struct ip6_hdr *ip6 = packet->ip6;

  if (packet->ip6_len < sizeof(*ip6)) {
    debug(""Packet size invalid: %zu bytes."", packet->ip6_len);
    return;
  }

  size_t length = sizeof(*ip6) + ntohs(ip6->ip6_plen);
  if (((ip6->ip6_vfc >> 4) != 6) || (length > packet->ip6_len)) {
    debug(""Received malformed IPv6 packet."");
    return;
  }

  pthread_rwlock_rdlock(&tunnel->state_lock);
  teredo_state s = tunnel->state;
#ifdef MIREDO_TEREDO_CLIENT
  bool islocal = teredo_islocal(tunnel, packet);
#endif

  pthread_rwlock_unlock(&tunnel->state_lock);

#ifdef MIREDO_TEREDO_CLIENT

  if (IsClient(tunnel)) {
    if (teredo_maintenance_process(tunnel->maintenance, packet) == 0) {
      debug("" packet passed to maintenance procedure"");
      return;
    }

    if (!s.up) {
      debug("" packet dropped because tunnel down"");
      return;
    }

    if ((packet->source_ipv4 == s.addr.teredo.server_ip) &&
        (packet->source_port == htons(IPPORT_TEREDO))) {
      uint32_t ipv4 = packet->orig_ipv4;
      uint16_t port = packet->orig_port;

      if ((ipv4 == 0) && IsBubble(ip6) &&
          (IN6_TEREDO_PREFIX(&ip6->ip6_src) == s.addr.teredo.prefix)) {

        ipv4 = IN6_TEREDO_IPV4(&ip6->ip6_src);
        port = IN6_TEREDO_PORT(&ip6->ip6_src);
      }

      if (ipv4) {

        teredo_reply_bubble(tunnel->fd, ipv4, port, ip6);
        debug("" bubble sent"");
        if (IsBubble(ip6))
          return;
      }
    }

    if (((ip6->ip6_src.s6_addr[0] & 0xff) == 0xfe) &&
        ((ip6->ip6_src.s6_addr[1] & 0xc0) == 0x80))
      return;
  } else
#endif

      if (IN6_TEREDO_PREFIX(&ip6->ip6_src) != s.addr.teredo.prefix) {
    debug(""Source %s is not a teredo address."",
          inet_ntop(AF_INET6, &ip6->ip6_src.s6_addr, b, sizeof b));
    return;
  }

  teredo_clock_t now = teredo_clock();

  struct teredo_peerlist *list = tunnel->list;
  teredo_peer *p = teredo_list_lookup(list, &ip6->ip6_src, NULL);

#ifdef MIREDO_TEREDO_CLIENT

  if (islocal && IsDiscoveryBubble(packet)) {
    if (p == NULL) {
      p = teredo_list_lookup(list, &ip6->ip6_src, &(bool){false});
      if (p == NULL) {
        debug(""Out of memory."");
        return;
      }
      p->trusted = 0;
      p->local = 0;
    }

    if (!p->local)
      p->bubbles = 0;

    SetMappingFromPacket(p, packet);
    p->local = 1;
    TouchReceive(p, now);
    teredo_list_release(list);

    if (CountBubble(p, now) != 0)
      return;

    debug(""Replying to discovery bubble"");
    teredo_send_bubble_anyway(tunnel->fd, packet->source_ipv4,
                              packet->source_port, &s.addr.ip6, &ip6->ip6_src);
    return;
  }
#endif

  if (ip6->ip6_dst.s6_addr[0] == 0xff) {
    if (p != NULL)
      teredo_list_release(list);
    debug(""Multicast destination %s not supported."",
          inet_ntop(AF_INET6, &ip6->ip6_dst.s6_addr, b, sizeof b));
    return;
  }

  if (p != NULL) {

    if (p->trusted && (packet->source_ipv4 == p->mapped_addr) &&
        (packet->source_port == p->mapped_port)) {
      teredo_predecap(tunnel, p, now);
      tunnel->recv_cb(tunnel->opaque, ip6, length);
      return;
    }

#ifdef MIREDO_TEREDO_CLIENT

    if (IsClient(tunnel) && (CheckPing(packet) == 0)) {
      p->trusted = 1;
      SetMappingFromPacket(p, packet);

      teredo_predecap(tunnel, p, now);
      return;
    }
#endif
  }

  if (IN6_TEREDO_PREFIX(&ip6->ip6_src) == s.addr.teredo.prefix) {

    if (IN6_MATCHES_TEREDO_CLIENT(&ip6->ip6_src, packet->source_ipv4,
                                  packet->source_port)
#ifdef MIREDO_TEREDO_CLIENT

        || (p != NULL && p->local && (packet->source_ipv4 == p->mapped_addr) &&
            (packet->source_port == p->mapped_port))

        || (p == NULL && islocal)
#endif

        || (IsBubble(ip6) && (CheckBubble(packet) == 0))) {
#ifdef MIREDO_TEREDO_CLIENT
      if (IsClient(tunnel) && (p == NULL)) {
        p = teredo_list_lookup(list, &ip6->ip6_src, &(bool){false});
        if (p == NULL) {
          debug(""Out of memory."");
          return;
        }
        p->local = islocal;
      }
#endif

      if (p == NULL) {
        debug(""No peer for %s found. Dropping packet."",
              inet_ntop(AF_INET6, &ip6->ip6_src.s6_addr, b, sizeof b));
        return;
      }

      SetMappingFromPacket(p, packet);
      p->trusted = 1;
      teredo_predecap(tunnel, p, now);

      if (!IsBubble(ip6))
        tunnel->recv_cb(tunnel->opaque, ip6, length);
      return;
    }
  }
#ifdef MIREDO_TEREDO_CLIENT
  else {
    assert(IN6_TEREDO_PREFIX(&ip6->ip6_src) != s.addr.teredo.prefix);
    assert(IsClient(tunnel));

    if (p == NULL) {
      bool create;
      p = teredo_list_lookup(list, &ip6->ip6_src, &create);
      if (p == NULL) {
        debug(""Out of memory."");
        return;
      }

      if (create) {
        p->mapped_port = 0;
        p->mapped_addr = 0;
        p->trusted = p->local = 0;
        p->bubbles = p->pings = 0;
      }
    }

    teredo_enqueue_in(p, ip6, length, packet->source_ipv4, packet->source_port);
    TouchReceive(p, now);

    int res = CountPing(p, now);
    teredo_list_release(list);

    if (res == 0)
      SendPing(tunnel->fd, &s.addr, &ip6->ip6_src);

    return;
  }
#endif

  debug(""Dropping packet."");

  if (p != NULL)
    teredo_list_release(list);
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set1_epi8(char __b) {
  return (__m128i)(__v16qi){__b, __b, __b, __b, __b, __b, __b, __b,
                            __b, __b, __b, __b, __b, __b, __b, __b};
}"
apache-nifi-minifi-cpp-6576136/thirdparty/librdkafka-0.11.4/src-cpp/rdkafkacpp_int.h	Any previous subscription will be unassigned and unsubscribed first.	2	"public:
~EventImpl(){};

EventImpl(Type type, ErrorCode err, Severity severity, const char *fac,
          const char *str)
    : type_(type), err_(err), severity_(severity), fac_(fac ? fac : """"),
      str_(str), id_(0), throttle_time_(0){};

EventImpl(Type type)
    : type_(type), err_(ERR_NO_ERROR), severity_(EVENT_SEVERITY_EMERG),
      fac_(""""), str_(""""), id_(0), throttle_time_(0){};

Type type() const { return type_; }
ErrorCode err() const { return err_; }
Severity severity() const { return severity_; }
std::string fac() const { return fac_; }"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Signals children (or self) to shutdown) - NOT signal safe.	2	"static void fio_cluster_signal_children(void) {
  if (fio_parent_pid() != getpid()) {
    kill(getpid(), SIGINT);
    return;
  }
  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,
                                                    (fio_str_info_s){.len = 0},
                                                    (fio_str_info_s){.len = 0},
                                                    0, 1),
                            -1);
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	Create a new user object ready for marshalling.	2	"MPMarshalledUser *mpw_marshal_user(const char *fullName,
                                   const char *masterPassword,
                                   const MPAlgorithmVersion algorithmVersion) {

  MPMarshalledUser *user;
  if (!fullName || !masterPassword ||
      !(user = malloc(sizeof(MPMarshalledUser))))
    return NULL;

  *user = (MPMarshalledUser){
      .fullName = mpw_strdup(fullName),
      .masterPassword = mpw_strdup(masterPassword),
      .algorithm = algorithmVersion,
      .redacted = true,

      .avatar = 0,
      .defaultType = MPResultTypeDefault,
      .lastUsed = 0,

      .sites_count = 0,
      .sites = NULL,
  };
  return user;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Multiply two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_float qmulf(const quaternion_float num1,
                                          const quaternion_float num2) {
  const float tmp_r = (num2.R * num1.R) - (num2.i * num1.i) -
                      (num2.j * num1.j) - (num2.k * num1.k);
  const float tmp_i = (num2.R * num1.i) + (num2.i * num1.R) -
                      (num2.j * num1.k) + (num2.k * num1.j);
  const float tmp_j = (num2.R * num1.j) + (num2.i * num1.k) +
                      (num2.j * num1.R) - (num2.k * num1.i);
  const float tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                      (num2.j * num1.i) + (num2.k * num1.R);
  return (quaternion_float){tmp_r, tmp_i, tmp_j, tmp_k};
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/Demos/Device/LowLevel/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_Task(void) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT.FrameLength)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT.FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT
              .FrameData[sizeof(Ethernet_Frame_Header_t) + sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
                              sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
                         ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT.FrameLength = PacketSize;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/alpn-test.c	"In this test case, establish a security context, with server not ready for alpn, and the client sends the known name. The client inquires the peer name and verifies it matches the desired credential."	3	"init_no_server_alpn(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;
  const char *why = """";
  unsigned char client_alpn[] = {
      3,
      'g',
      's',
      'i',
  };

  major_status =
      gss_set_sec_context_option(&minor_status, &init_context, GSS_ALPN,
                                 &(gss_buffer_desc){
                                     .value = client_alpn,
                                     .length = sizeof(client_alpn),
                                 });
  if (major_status != GSS_S_COMPLETE) {
    why = ""gss_set_sec_context_option"";
    result = false;

    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      why = ""gss_init_sec_context"";
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        why = ""accept_sec_context"";
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    gss_buffer_set_desc *data = NULL;

    major_status = gss_inquire_sec_context_by_oid(
        &minor_status, init_context, (gss_OID_desc *)gss_ext_alpn_oid, &data);
    if (major_status != GSS_S_COMPLETE) {
      why = ""inquire_context_by_oid"";
      result = false;

      goto fail;
    }

    if (data->count != 0) {
      why = ""inquire_result"";
      result = false;
      goto fail;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Creates / finds a pubsub channel, adds a reference count and locks it."	2	"static channel_s *fio_channel_dup_lock(fio_str_info_s name) {
  channel_s ch = (channel_s){
      .name = name.data,
      .name_len = name.len,
      .parent = &fio_postoffice.pubsub,
      .ref = 8,
  };
  uint64_t hashed_name = FIO_HASH_FN(
      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);
  channel_s *ch_p =
      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.pubsub);
  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {
    fio_pubsub_on_channel_create(ch_p);
  }
  return ch_p;
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	"Step (2) of Soft Thresholding multi-dimensional arrays, y = ST(x, lambda) 2) computes resid = MAX( (abs(x) - lambda)/abs(x), 0 ) (with strides)"	2	"void md_zsoftthresh_half2(unsigned int D, const long dim[D], float lambda,
                          const long ostr[D], complex float *optr,
                          const long istr[D], const complex float *iptr) {
  NESTED(void, nary_zsoftthresh_half,
         (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->zsoftthresh_half(data->size, lambda, ptr[0], ptr[1]);
  };

  optimized_twoop_oi(D, dim, ostr, optr, istr, iptr,
                     (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zsoftthresh_half);
}"
dm-vdo-kvdo-8df6805/vdo/base/blockAllocator.c	Get the statistics for this allocator.	2	"getBlockAllocatorStatistics(const BlockAllocator *allocator) {
  const AtomicAllocatorStatistics *atoms = &allocator->statistics;
  return (BlockAllocatorStatistics){
      .slabCount = allocator->slabCount,
      .slabsOpened = relaxedLoad64(&atoms->slabsOpened),
      .slabsReopened = relaxedLoad64(&atoms->slabsReopened),
  };
}"
tsani-tetrefis-02d47ef/basic_types.c	Multiplies a vector by a scalar.	2	"vec2 vec2_mult(INT32 k, vec2 p) { return (vec2){k * p.x, k * p.y}; }"
tpm2-software-tpm2-abrmd-15be9f7/src/tpm2-response.c	This is a convenience wrapper that is used to create an error response where all we need is a header with the RC set to something specific.	2	"tpm2_response_new_rc(Connection *connection, TSS2_RC rc) {
  guint8 *buffer;

  buffer = calloc(1, TPM_RESPONSE_HEADER_SIZE);
  if (buffer == NULL) {
    g_warning(""tpm2_response_new_rc: failed to allocate 0x%zx""
              "" bytes for response: errno: %d: %s"",
              TPM_RESPONSE_HEADER_SIZE, errno, strerror(errno));
    return NULL;
  }
  TPM_RESPONSE_TAG(buffer) = htobe16(TPM2_ST_NO_SESSIONS);
  TPM_RESPONSE_SIZE(buffer) = htobe32(TPM_RESPONSE_HEADER_SIZE);
  TPM_RESPONSE_CODE(buffer) = htobe32(rc);
  return tpm2_response_new(connection, buffer,
                           be32toh(TPM_RESPONSE_SIZE(buffer)), (TPMA_CC){0});
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/list-proj.c	"Groups adjacent elements in the list into sub-lists. Every group of group_sz elements is placed into a sublist of length group_sz, except for the final group, which may be smaller if group_sz does not divide evenly into the length of the list. For example, group([a b c d e f g h], 3) yields [[a b c] [d e f] [g h]]."	2	"ava_list_value ava_list_proj_group(ava_list_value delegate, size_t group_size) {
  ava_list_proj_group_list *this;
  size_t num_groups =
      (ava_list_length(delegate.v) + group_size - 1) / group_size;

  this =
      ava_alloc(sizeof(ava_list_proj_group_list) + sizeof(AO_t) * num_groups);
  this->delegate = ava_fat_list_value_of(delegate.v);
  this->group_size = group_size;
  this->num_groups = num_groups;

  return (ava_list_value){
      ava_value_with_ptr(&ava_list_proj_group_list_impl, this)};
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Device/LowLevel/RNDISEthernet/RNDISEthernet.c	"Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper to a frame in the FrameOUT global before sending the buffer contents to the host."	2	"void RNDIS_Task(void) {

  Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPADDR);

  if (Endpoint_IsINReady() && ResponseReady) {
    USB_Request_Header_t Notification = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = RNDIS_NOTIF_ResponseAvailable,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);

    Endpoint_ClearIN();

    ResponseReady = false;
  }

  if ((CurrRNDISState == RNDIS_Data_Initialized) &&
      !(MessageHeader->MessageLength)) {

    RNDIS_Packet_Message_t RNDISPacketHeader;

    Endpoint_SelectEndpoint(CDC_RX_EPADDR);

    if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength)) {

      Endpoint_Read_Stream_LE(&RNDISPacketHeader,
                              sizeof(RNDIS_Packet_Message_t), NULL);

      if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX) {
        Endpoint_StallTransaction();
        return;
      }

      Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength,
                              NULL);

      Endpoint_ClearOUT();

      FrameIN.FrameLength = RNDISPacketHeader.DataLength;
    }

    Endpoint_SelectEndpoint(CDC_TX_EPADDR);

    if (Endpoint_IsINReady() && FrameOUT.FrameLength) {

      memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));

      RNDISPacketHeader.MessageType = REMOTE_NDIS_PACKET_MSG;
      RNDISPacketHeader.MessageLength =
          (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
      RNDISPacketHeader.DataOffset =
          (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
      RNDISPacketHeader.DataLength = FrameOUT.FrameLength;

      Endpoint_Write_Stream_LE(&RNDISPacketHeader,
                               sizeof(RNDIS_Packet_Message_t), NULL);

      Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength,
                               NULL);

      Endpoint_ClearIN();

      FrameOUT.FrameLength = 0;
    }
  }
}"
amakaseev-sprite-sheet-packer-beffd9b/SpriteSheetPacker/3rdparty/pngquant/mediancut.c	Weighted per-channel variance of the box. It's used to decide which channel to split by	2	"static f_pixel box_variance(const hist_item achv[], const struct box *box) {
  f_pixel mean = box->color;
  double variancea = 0, variancer = 0, varianceg = 0, varianceb = 0;

  for (unsigned int i = 0; i < box->colors; ++i) {
    const f_pixel px = achv[box->ind + i].acolor;
    double weight = achv[box->ind + i].adjusted_weight;
    variancea += variance_diff(mean.a - px.a, 2.0 / 256.0) * weight;
    variancer += variance_diff(mean.r - px.r, 1.0 / 256.0) * weight;
    varianceg += variance_diff(mean.g - px.g, 1.0 / 256.0) * weight;
    varianceb += variance_diff(mean.b - px.b, 1.0 / 256.0) * weight;
  }

  return (f_pixel){
      .a = variancea * (4.0 / 16.0),
      .r = variancer * (7.0 / 16.0),
      .g = varianceg * (9.0 / 16.0),
      .b = varianceb * (5.0 / 16.0),
  };
}"
darktable-org-darktable-32fab21/src/iop/flip.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_flip_params_t tmp =
      (dt_iop_flip_params_t){.orientation = ORIENTATION_NULL};

  if (!self->dev)
    goto end;

  self->default_enabled = 1;

  if (self->dev->image_storage.legacy_flip.user_flip != 0 &&
      self->dev->image_storage.legacy_flip.user_flip != 0xff) {
    sqlite3_stmt *stmt;
    DT_DEBUG_SQLITE3_PREPARE_V2(
        dt_database_get(darktable.db),
        ""SELECT * FROM main.history WHERE imgid = ?1 AND operation = 'flip'"",
        -1, &stmt, NULL);
    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, self->dev->image_storage.id);
    if (sqlite3_step(stmt) != SQLITE_ROW) {

      self->default_enabled = 1;
      tmp.orientation = merge_two_orientations(
          dt_image_orientation(&self->dev->image_storage),
          (dt_image_orientation_t)(self->dev->image_storage.legacy_flip
                                       .user_flip));
    }
    sqlite3_finalize(stmt);
  }

end:
  memcpy(self->params, &tmp, sizeof(dt_iop_flip_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_flip_params_t));
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Print the solution data of an euler piece to the file.	2	"(FILE *file, const char sp_type, const struct const_Multiarray_d *sol,
 const char type_out) {
  const char *const *names_p = NULL;
  switch (type_out) {
  case 's': {
    static const char *const names_s[] = {""$\\rho$"", ""$\\mathbf{v}$"",
                                          ""$\\mathit{p}$""};
    names_p = names_s;
    break;
  }
  case 'e': {

    static const char *const names_e[] = {
        ""$|\\rho-\\rho_e|$"", ""$|\\mathbf{v}-\\mathbf{v}_e|$"", ""$|p-p_e|$""};
    names_p = names_e;
    break;
  }
  default:
    EXIT_ERROR(""Unsupported: %c"", type_out);
    break;
  }

  if (sp_type == 'p') {
    fprint_vtk_DataArray_d(file, sp_type, names_p[0], NULL, false, 's');
    fprint_vtk_DataArray_d(file, sp_type, names_p[1], NULL, false, 'v');
    fprint_vtk_DataArray_d(file, sp_type, names_p[2], NULL, false, 's');
    if (type_out == 's') {
      fprint_vtk_DataArray_d(file, sp_type, ""$\\mathit{s}$"", NULL, false, 's');
      fprint_vtk_DataArray_d(file, sp_type, ""mach"", NULL, false, 's');
    }
  } else if (sp_type == 's') {
    const ptrdiff_t ext_0 = sol->extents[0], n_var = sol->extents[1];

    struct Multiarray_d *var =
        constructor_empty_Multiarray_d('C', 2, (ptrdiff_t[]){ext_0, 1});
    double *data = var->data;

    var->extents[1] = 1;
    var->data = (double *)get_col_const_Multiarray_d(0, sol);
    fprint_vtk_DataArray_d(file, sp_type, names_p[0],
                           (struct const_Multiarray_d *)var, false, 's');

    var->extents[1] = n_var - 2;
    var->data = (double *)get_col_const_Multiarray_d(1, sol);
    fprint_vtk_DataArray_d(file, sp_type, names_p[1],
                           (struct const_Multiarray_d *)var, false, 'v');

    var->extents[1] = 1;
    var->data = (double *)get_col_const_Multiarray_d(n_var - 1, sol);
    fprint_vtk_DataArray_d(file, sp_type, names_p[2],
                           (struct const_Multiarray_d *)var, false, 's');

    var->data = data;

    if (type_out == 's') {

      var->extents[1] = 1;
      compute_entropy(var, sol, 'p');
      fprint_vtk_DataArray_d(file, sp_type, ""$\\mathit{s}$"",
                             (struct const_Multiarray_d *)var, false, 's');

      compute_mach(var, sol, 'p');
      fprint_vtk_DataArray_d(file, sp_type, ""mach"",
                             (struct const_Multiarray_d *)var, false, 's');
    }

    destructor_Multiarray_d(var);
  } else {
    EXIT_ERROR(""Unsupported: %c\n"", sp_type);
  }
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	"Returns a vector of [2 x i64] where the lower element is taken from the lower element of the operand, and the upper element is zero."	2	"_mm_loadl_epi64(__m128i const *__p) {
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return __extension__(__m128i){((struct __mm_loadl_epi64_struct *)__p)->__u,
                                0};
}"
darktable-org-darktable-32fab21/src/iop/temperature.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_temperature_params_t tmp =
      (dt_iop_temperature_params_t){.coeffs = {1.0, 1.0, 1.0, 1.0}};

  if (!module->dev)
    goto end;

  const int is_raw = dt_image_is_raw(&module->dev->image_storage);

  module->default_enabled = 0;
  module->hide_enable_button = 0;

  if (is_raw && dt_image_is_monochrome(&(module->dev->image_storage))) {
    module->hide_enable_button = 1;
  } else {
    if (module->gui_data)
      prepare_matrices(module);

    if (is_raw) {

      module->default_enabled = 1;

      find_coeffs(module, tmp.coeffs);
      tmp.coeffs[0] /= tmp.coeffs[1];
      tmp.coeffs[2] /= tmp.coeffs[1];
      tmp.coeffs[3] /= tmp.coeffs[1];
      tmp.coeffs[1] = 1.0f;
    }
  }

  if (module->gui_data) {
    dt_iop_temperature_gui_data_t *g =
        (dt_iop_temperature_gui_data_t *)module->gui_data;

    dt_bauhaus_slider_set_default(g->scale_r, tmp.coeffs[0]);
    dt_bauhaus_slider_set_default(g->scale_g, tmp.coeffs[1]);
    dt_bauhaus_slider_set_default(g->scale_b, tmp.coeffs[2]);
    dt_bauhaus_slider_set_default(g->scale_g2, tmp.coeffs[3]);

    for (int c = 0; c < 4; c++)
      g->daylight_wb[c] = tmp.coeffs[c];

    if (!calculate_bogus_daylight_wb(module, g->daylight_wb)) {

    } else {

      for (int i = 0; i < wb_preset_count; i++) {
        if (!strcmp(wb_preset[i].make,
                    module->dev->image_storage.camera_maker) &&
            !strcmp(wb_preset[i].model,
                    module->dev->image_storage.camera_model) &&
            !strcmp(wb_preset[i].name, Daylight) && wb_preset[i].tuning == 0) {
          for (int k = 0; k < 4; k++)
            g->daylight_wb[k] = wb_preset[i].channel[k];
          break;
        }
      }
    }

    double TempK, tint;
    mul2temp(module, tmp.coeffs, &TempK, &tint);

    dt_bauhaus_slider_set_default(g->scale_k, TempK);
    dt_bauhaus_slider_set_default(g->scale_tint, tint);

#if COLORED_SLIDERS
    const float neutral_stop_tint = (tint - DT_IOP_LOWEST_TINT) /
                                    (DT_IOP_HIGHEST_TINT - DT_IOP_LOWEST_TINT);
    dt_bauhaus_slider_clear_stops(g->scale_tint);
    dt_bauhaus_slider_set_stop(g->scale_tint, 0.0, 1.0, 0.0, 1.0);
    dt_bauhaus_slider_set_stop(g->scale_tint, neutral_stop_tint, 1.0, 1.0, 1.0);
    dt_bauhaus_slider_set_stop(g->scale_tint, 1.0, 0.0, 1.0, 0.0);
#endif
  }

end:
  memcpy(module->params, &tmp, sizeof(dt_iop_temperature_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_temperature_params_t));
}"
servo-gecko-media-85d10f4/gecko-media/gecko/src/media/ffvpx/libavcodec/decode.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  const AVPacket *pkt = avctx->internal->last_pkt_props;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_SPHERICAL, AV_FRAME_DATA_SPHERICAL},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
      {AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
       AV_FRAME_DATA_MASTERING_DISPLAY_METADATA},
      {AV_PKT_DATA_CONTENT_LIGHT_LEVEL, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL},
      {AV_PKT_DATA_A53_CC, AV_FRAME_DATA_A53_CC},
  };

  if (pkt) {
    frame->pts = pkt->pts;
#if FF_API_PKT_PTS
    FF_DISABLE_DEPRECATION_WARNINGS
    frame->pkt_pts = pkt->pts;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif
    frame->pkt_pos = pkt->pos;
    frame->pkt_duration = pkt->duration;
    frame->pkt_size = pkt->size;

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
    add_metadata_from_side_data(pkt, frame);

    if (pkt->flags & AV_PKT_FLAG_DISCARD) {
      frame->flags |= AV_FRAME_FLAG_DISCARD;
    } else {
      frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
    }
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (frame->colorspace == AVCOL_SPC_UNSPECIFIED)
    frame->colorspace = avctx->colorspace;
  if (frame->color_range == AVCOL_RANGE_UNSPECIFIED)
    frame->color_range = avctx->color_range;
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    frame->channels = avctx->channels;
    break;
  }
  return 0;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/numerical_flux/numerical_flux_central_T.c	Version of compute_Numerical_Flux_fptr_T computing the numerical fluxes as the average of the left and right fluxes.	2	"(const struct Numerical_Flux_Input_T *num_flux_i,
 struct mutable_Numerical_Flux_T *num_flux) {
  struct Fluxes_LR fluxes_lr = constructor_Fluxes_LR(num_flux_i);
  struct Flux_T *const flux_l = fluxes_lr.flux_l, *const flux_r =
                                                      fluxes_lr.flux_r;

  const struct const_Multiarray_T *const n_l = num_flux_i->bv_l.normals;
  transpose_Multiarray_T((struct Multiarray_T *)n_l, true);

  struct Multiarray_T *const f_avg =
      (struct Multiarray_T *)constructor_sum_Multiarrays_const_Multiarray_T(
          0.5, flux_l->f, 0.5, flux_r->f);

  const int n_eq_set = (!num_flux_i->bv_r.nf_E_provided ? NEQ : NEQ - 1);
  set_Numerical_Flux_member(n_l, f_avg, num_flux->nnf, 1.0,
                            (int[]){n_eq_set, 1, 1});
  if (num_flux_i->bv_r.nf_E_provided)
    set_provided_Numerical_Flux_members(num_flux_i, num_flux);

  transpose_Multiarray_T((struct Multiarray_T *)n_l, true);

  destructor_Fluxes_LR(&fluxes_lr);
}"
watr-li-nodes-b771299/plant_node/coap_ext.c	Build a PUT request. The value of buflen will be the request packet's size after successful completion.	2	"int coap_ext_build_PUT(uint8_t *buf, size_t *buflen, const char *payload,
                       const coap_endpoint_path_t *path) {

  seqnum++;

  DEBUG(""creating PUT request...\n"");
  size_t req_pkt_sz;
  int errcode;
  int segment_count = path->count;

  coap_header_t req_hdr = {.ver = 1,
                           .t = COAP_TYPE_CON,
                           .tkl = 0,
                           .code = MAKE_RSPCODE(0, COAP_METHOD_PUT),
                           .id = {seqnum, 22}};

  coap_buffer_t payload_buf = {.p = (const uint8_t *)payload,
                               .len = strlen(payload)};

  coap_packet_t req_pkt = {.hdr = req_hdr,
                           .tok = (coap_buffer_t){},
                           .numopts = segment_count,
                           .payload = payload_buf};

  for (int i = 0; i < segment_count; i++) {
    coap_option_t path_option = {.num = COAP_OPTION_URI_PATH,
                                 .buf = {.p = (const uint8_t *)path->elems[i],
                                         .len = strlen(path->elems[i])}};

    req_pkt.opts[i] = path_option;
  }

  req_pkt_sz = sizeof(req_pkt);

  if (*buflen < req_pkt_sz) {
    DEBUG(""Error: buflen too small:\n\tbuflen:%d\n\treq_pkt_sz:%d\n"", *buflen,
          req_pkt_sz);
    return -1;
  }

#ifdef DEBUG
  DEBUG(""[main-posix] content:\n"");
  coap_dumpPacket(&req_pkt);
#endif

  if (0 != (errcode = coap_build(buf, buflen, &req_pkt))) {
    DEBUG(""Error building packet! Error code: %i\nAborting. \n"", errcode);
    return -1;
  }
  return 0;
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Issues a PREVENT MEDIUM REMOVAL command, to logically (or, depending on the type of device, physically) lock the device from removal so that blocks of data on the medium can be read or altered."	2	"uint8_t MS_Host_PreventAllowMediumRemoval(
    USB_ClassInfo_MS_Host_t *const MSInterfaceInfo, const uint8_t LUNIndex,
    const bool PreventRemoval) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = 0,
      .Flags = COMMAND_DIRECTION_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
wxMaxima-developers-wxmaxima-493b0a0/src/Cell.h	Convert this list to an representation fit for saving in a .wxmx file.	2	"Cell *GetWorkingGroup(bool resortToLast = false) {
  if ((m_workingGroup != NULL) || (!resortToLast))
    return m_workingGroup;
  else
    return m_lastWorkingGroup;
}

void SetWorkingGroup(Cell *group) {
  if (group != NULL)
    m_lastWorkingGroup = group;
  m_workingGroup = group;
}

void WXMXResetCounter() { m_wxmxImgCounter = 0; }

wxString WXMXGetNewFileName();

int WXMXImageCount() { return m_wxmxImgCounter; }

class ErrorList {
public:
  ErrorList(){};

  bool Empty() { return m_errorList.empty(); }"
samba-team-samba-b2c2c4c/lib/util/genrand_util.c	Passwords must contain characters from three of the following five categories: Note: for now do not check if the unicode category is alphabetic character	4	"_PUBLIC_ bool check_password_quality(const char *pwd) {
  size_t ofs = 0;
  size_t num_chars = 0;
  size_t num_digits = 0;
  size_t num_upper = 0;
  size_t num_lower = 0;
  size_t num_nonalpha = 0;
  size_t num_unicode = 0;
  size_t num_categories = 0;

  if (pwd == NULL) {
    return false;
  }

  while (true) {
    const char *s = &pwd[ofs];
    size_t len = 0;
    codepoint_t c;

    c = next_codepoint(s, &len);
    if (c == INVALID_CODEPOINT) {
      return false;
    } else if (c == 0) {
      break;
    }
    ofs += len;
    num_chars += 1;

    if (len == 1) {
      const char *na = ""~!@#$%^&*_-+=`|\\(){}[]:;\""'<>,.?/"";

      if (isdigit(c)) {
        num_digits += 1;
        continue;
      }

      if (isupper(c)) {
        num_upper += 1;
        continue;
      }

      if (islower(c)) {
        num_lower += 1;
        continue;
      }

      if (strchr(na, c)) {
        num_nonalpha += 1;
        continue;
      }

      continue;
    }

    if (isupper_m(c)) {
      num_upper += 1;
      continue;
    }

    if (islower_m(c)) {
      num_lower += 1;
      continue;
    }

    num_unicode += 1;
    continue;
  }

  if (num_digits > 0) {
    num_categories += 1;
  }
  if (num_upper > 0) {
    num_categories += 1;
  }
  if (num_lower > 0) {
    num_categories += 1;
  }
  if (num_nonalpha > 0) {
    num_categories += 1;
  }
  if (num_unicode > 0) {
    num_categories += 1;
  }

  if (num_categories >= 3) {
    return true;
  }

  return false;
}"
dm-vdo-kvdo-8df6805/vdo/base/vdo.c	Allocate a VDO and associate it with its physical layer.	2	"int allocateVDO(PhysicalLayer *layer, VDO **vdoPtr) {
  int result = registerStatusCodes();
  if (result != VDO_SUCCESS) {
    return result;
  }

  VDO *vdo;
  result = ALLOCATE(1, VDO, __func__, &vdo);
  if (result != UDS_SUCCESS) {
    return result;
  }

  vdo->layer = layer;
  vdo->readOnlyContext = (ReadOnlyModeContext){
      .context = vdo,
      .isReadOnly = isReadOnlyVDO,
      .enterReadOnlyMode = enterReadOnlyModeFromContext,
  };

  if (layer->createEnqueueable != NULL) {
    result = makeAdminCompletion(layer, &vdo->adminCompletion);
    if (result != VDO_SUCCESS) {
      freeVDO(&vdo);
      return result;
    }
  }

  *vdoPtr = vdo;
  return VDO_SUCCESS;
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/boot.c	Put badge into developer mode which allows uploads over ymodem	2	"static void __developer_mode() {
  while (1) {
    led_eye_pulse_start();
    gfx_fill_screen(COLOR_RED);
    gfx_font_set(font_large);
    gfx_cursor_set((cursor_coord_t){0, 20});
    gfx_color_set(COLOR_BLACK);
    gfx_bg_transparent(true);
    gfx_print(""Developer Mode\n"");
    gfx_font_set(font_small);
    gfx_print(
        ""Upload with Atom\n\nor\n\nstty -F /dev/ttyUSB0 115200\n\nsz --ymodem ""
        ""FILE > /dev/ttyUSB0 < /dev/ttyUSB0"");
    gfx_push_screen_buffer();

    ymodem_listen();
    gfx_fill_screen(COLOR_BLACK);
    util_heap_stats_dump();
    led_eye_pulse_stop();
    DELAY(500);
  }
}"
cochrane-GLLara-91ed369/shared_simd/simd_matrix.h	Addiert zwei Matrizen komponentenweise	2	"static inline mat_float16 simd_mat_add(mat_float16 a, mat_float16 b) {
  return (mat_float16){a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}"
dm-vdo-kvdo-8df6805/vdo/base/header.h	Convert a PackedVersionNumber to its native in-memory representation.	2	"static inline VersionNumber unpackVersionNumber(PackedVersionNumber version) {
  return (VersionNumber){
      .majorVersion = getUInt32LE(version.majorVersion),
      .minorVersion = getUInt32LE(version.minorVersion),
  };
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Device/CDC.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t),
                           NO_STREAM_CALLBACK);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
      NO_STREAM_CALLBACK);
  Endpoint_ClearIN();
}"
psyc-libpsyc-d16deca/include/psyc/text.h	Initializes the PSYC text state struct with custom opening & closing braces.	2	"psyc_text_state_init_custom(PsycTextState *state, char *tmpl, size_t tmplen,
                            char *buffer, size_t buflen, char *ope,
                            size_t opelen, char *clo, size_t clolen) {
  state->cursor = 0;
  state->written = 0;
  state->tmpl = (PsycString){tmplen, tmpl};
  state->buffer = (PsycString){buflen, buffer};
  state->open = (PsycString){opelen, ope};
  state->close = (PsycString){clolen, clo};
}"
espressif-esp-idf-a121847/components/driver/sdio_slave.c	"Register buffer used for receiving. All buffers should be registered before used, and then can be used (again) in the driver by the handle returned."	2	"sdio_slave_buf_handle_t sdio_slave_recv_register_buf(uint8_t *start) {
  SDIO_SLAVE_CHECK(
      esp_ptr_dma_capable(start) && (uint32_t)start % 4 == 0,
      ""buffer to register should be DMA capable and 32-bit aligned"", NULL);
  buf_desc_t *desc = (buf_desc_t *)malloc(sizeof(buf_desc_t));
  if (desc == NULL) {
    SDIO_SLAVE_LOGE(""cannot allocate lldesc for new buffer"");
    return NULL;
  }

  *desc = (buf_desc_t){
      .size = context.config.recv_buffer_size,
      .buf = start,

  };
  critical_enter_recv();
  TAILQ_INSERT_TAIL(&context.recv_reg_list, desc, te);
  critical_exit_recv();
  return desc;
}"
tsani-tetrefis-02d47ef/basic_types.c	Shifts a rectangle by adding a vector.	2	"rect rect_add(rect r, vec2 p) { return (rect){r.x + p.x, r.y + p.y, r.w, r.h}; }"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Calculates the square root of the lower double-precision value of the second operand and returns it in the lower 64 bits of the result. The upper 64 bits of the result are copied from the upper double-precision value of the first operand.	2	"_mm_sqrt_sd(__m128d __a, __m128d __b) {
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return __extension__(__m128d){__c[0], __a[1]};
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/StillImage.c	"Sends a given PIMA command to the attached device, filling out the PIMA command header's Transaction ID automatically."	0	"uint8_t SImage_Host_SendCommand(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo,
                                const uint16_t Operation,
                                const uint8_t TotalParams, uint32_t *Params) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(TotalParams),
      .Type = CType_CommandBlock,
      .Code = Operation,
  };

  memcpy(&PIMABlock.Params, Params, sizeof(uint32_t) * TotalParams);

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
richardgv-skippy-xd-397216c/src/wm.c	Get a specific attribute of a window. Returns a blank structure if the returned type and format does not match the requested type and format.	2	"wid_get_prop_adv(const session_t *ps, Window w, Atom atom, long offset,
                 long length, Atom rtype, int rformat) {
  Atom type = None;
  int format = 0;
  unsigned long nitems = 0, after = 0;
  unsigned char *data = NULL;

  if (Success == XGetWindowProperty(ps->dpy, w, atom, offset, length, False,
                                    rtype, &type, &format, &nitems, &after,
                                    &data) &&
      nitems && (AnyPropertyType == type || type == rtype) &&
      (!rformat || format == rformat) &&
      (8 == format || 16 == format || 32 == format)) {
    return (winprop_t){
        .data8 = data,
        .nitems = nitems,
        .type = type,
        .format = format,
    };
  }

  sxfree(data);

  return (winprop_t){
      .data8 = NULL, .nitems = 0, .type = AnyPropertyType, .format = 0};
}"
Meulengracht-MollenOS-e48f4ab/librt/include/xmmintrin.h	"Constructs a 128-bit floating-point vector of [4 x float], initialized in reverse order with the specified 32-bit single-precision float-point values. This intrinsic is a utility function and does not correspond to a specific instruction."	2	"_mm_setr_ps(float __z, float __y, float __x, float __w) {
  return __extension__(__m128){__z, __y, __x, __w};
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	Produces a mask (1s and 0s) of the non-zero support of a hard thresholded input vector Multi-dimensional operation with strides Hard thresholding is performed by selection of the k largest elements in input.	2	"void md_zhardthresh_mask2(unsigned int D, const long dim[D], unsigned int k,
                          unsigned int flags, complex float *tmp_norm,
                          const long ostr[D], complex float *optr,
                          const long istr[D], const complex float *iptr) {
  NESTED(void, nary_zhardthresh_mask,
         (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->zhardthresh_mask(data->size, k, ptr[0], ptr[1]);
  };

  if (0 == flags) {

    optimized_twoop_oi(D, dim, ostr, optr, istr, iptr,
                       (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zhardthresh_mask);
    return;
  }

  long norm_dims[D];
  long norm_strs[D];

  md_select_dims(D, ~flags, norm_dims, dim);
  md_calc_strides(D, norm_strs, norm_dims, CFL_SIZE);

  md_zrss(D, dim, flags, tmp_norm, iptr);
  optimized_twoop_oi(D, norm_dims, norm_strs, tmp_norm, norm_strs, tmp_norm,
                     (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zhardthresh_mask);
  md_copy2(D, dim, ostr, optr, norm_strs, tmp_norm, CFL_SIZE);
}"
tsani-tetrefis-02d47ef/basic_types.c	Adds two vectors together.	2	"vec2 vec2_add(vec2 p, vec2 q) { return (vec2){p.x + q.x, p.y + q.y}; }"
Decawave-mynewt-dw1000-core-d4f0971/lib/range/src/dw1000_range.c	"API to initialise various parameters of range instance like status bits, semaphores,callbacks, ext_callbacks, postprocess."	2	"dw1000_range_init(dw1000_dev_instance_t *inst, uint16_t nnodes,
                  uint16_t node_addr[]) {
  assert(inst);
  dw1000_extension_callbacks_t range_cbs;
  if (inst->range == NULL) {
    inst->range = (dw1000_range_instance_t *)malloc(
        sizeof(dw1000_range_instance_t) + nnodes * sizeof(uint16_t) +
        nnodes * sizeof(uint16_t) + nnodes * sizeof(uint16_t));
    assert(inst->range);
    memset(inst->range, 0, sizeof(dw1000_range_instance_t));
    inst->range->status.selfmalloc = 1;
    inst->range->nnodes = nnodes;
    inst->range->idx = 0;
    inst->range->rng_idx_cnt = 0;
    inst->range->pp_idx_cnt = 0;
    inst->range->status.started = 0;
  } else {
    assert(inst->range->nnodes == nnodes);
  }

  os_error_t err = os_sem_init(&inst->range->sem, inst->range->nnodes);
  assert(err == OS_OK);
  inst->range->parent = inst;
  inst->range->period = MYNEWT_VAL(RANGE_PERIOD);
  inst->range->config = (dw1000_range_config_t){
      .postprocess = false,
      .code = DWT_DS_TWR,
  };

  inst->range->node_addr = &inst->range->var_mem_block[0];
  inst->range->rng_idx_list = &inst->range->var_mem_block[nnodes];
  inst->range->pp_idx_list = &inst->range->var_mem_block[nnodes + nnodes];

  dw1000_range_set_nodes(inst, node_addr, nnodes);

  range_cbs.rx_complete_cb = range_complete_cb;
  range_cbs.tx_complete_cb = range_tx_complete_cb;
  range_cbs.rx_timeout_cb = range_error_cb;
  range_cbs.rx_error_cb = range_error_cb;
  range_cbs.tx_error_cb = range_error_cb;
  dw1000_range_set_ext_callbacks(inst, range_cbs);

  range_reg_postprocess(inst, &postprocess);

  inst->range->status.initialized = 1;
  return inst->range;
}"
RT-Thread-packages-nimble-fbccccd/nimble/host/src/ble_hs.c	"Initializes the NimBLE host. This function must be called before the OS is started. The NimBLE stack requires an application task to function. One application task in particular is designated as the ""host parent task"". In addition to application-specific work, the host parent task does work for NimBLE by processing events generated by the host."	4	"ble_hs_init(void) {
  int rc;

  SYSINIT_ASSERT_ACTIVE();

  rc = os_mempool_init(&ble_hs_hci_ev_pool, BLE_HS_HCI_EVT_COUNT,
                       sizeof(struct ble_npl_event), ble_hs_hci_os_event_buf,
                       ""ble_hs_hci_ev_pool"");
  SYSINIT_PANIC_ASSERT(rc == 0);

  ble_hs_reset_reason = 0;
  ble_hs_enabled_state = BLE_HS_ENABLED_STATE_OFF;

  ble_npl_event_init(&ble_hs_ev_tx_notifications, ble_hs_event_tx_notify, NULL);
  ble_npl_event_init(&ble_hs_ev_reset, ble_hs_event_reset, NULL);
  ble_npl_event_init(&ble_hs_ev_start_stage1, ble_hs_event_start_stage1, NULL);
  ble_npl_event_init(&ble_hs_ev_start_stage2, ble_hs_event_start_stage2, NULL);

  ble_hs_hci_init();

  rc = ble_hs_conn_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_l2cap_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_att_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_att_svr_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_gap_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_gattc_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_gatts_init();
  SYSINIT_PANIC_ASSERT(rc == 0);

  ble_hs_stop_init();

  ble_mqueue_init(&ble_hs_rx_q, ble_hs_event_rx_data, NULL);

  rc = stats_init_and_reg(STATS_HDR(ble_hs_stats),
                          STATS_SIZE_INIT_PARMS(ble_hs_stats, STATS_SIZE_32),
                          STATS_NAME_INIT_PARMS(ble_hs_stats), ""ble_hs"");
  SYSINIT_PANIC_ASSERT(rc == 0);

  rc = ble_npl_mutex_init(&ble_hs_mutex);
  SYSINIT_PANIC_ASSERT(rc == 0);

#if MYNEWT_VAL(BLE_HS_DEBUG)
  ble_hs_dbg_mutex_locked = 0;
#endif

  ble_hci_trans_cfg_hs(ble_hs_hci_rx_evt, NULL, ble_hs_rx_data, NULL);

#ifdef MYNEWT
  ble_hs_evq_set((struct ble_npl_eventq *)os_eventq_dflt_get());
#else
  ble_hs_evq_set(nimble_port_get_dflt_eventq());
#endif

#if BLE_MONITOR
  rc = ble_monitor_init();
  SYSINIT_PANIC_ASSERT(rc == 0);
#endif

#if MYNEWT_VAL(BLE_HS_AUTO_START)
#ifdef MYNEWT
  ble_npl_eventq_put((struct ble_npl_eventq *)os_eventq_dflt_get(),
                     &ble_hs_ev_start_stage1);
#else
  ble_npl_eventq_put(nimble_port_get_dflt_eventq(), &ble_hs_ev_start_stage1);
#endif
#endif

#if BLE_MONITOR
  ble_monitor_new_index(0, (uint8_t[6]){}, ""nimble0"");
#endif
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Sends a GET MAX LUN control request to the attached device, retrieving the index of the highest LUN (Logical UNit, a logical drive) in the device. This value can then be used in the other functions of the Mass Storage Host mode Class driver to address a specific LUN within the device."	1	"uint8_t MS_Host_GetMaxLUN(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {
    *MaxLUNIndex = 0;
    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_rate_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  struct clock_device *clock;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 4;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_rate_set, clock_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, flags)] =
        0;
    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, clock_id)] =
        clock_protocol_data.num_clocks;

    clock = &clock_protocol_data.clocks[0];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, rate)] =
        clock->rates[MIN_CLOCK + 1].lower;
    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, rate) + 1] =
        clock->rates[MIN_CLOCK + 1].upper;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, flags)] =
        0;

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      clock = &clock_protocol_data.clocks[clock_id];
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, clock_id)] =
          clock_id;
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, rate)] =
          clock->rates[MIN_CLOCK + 1].lower;
      test_case
          ->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set, rate) + 1] =
          clock->rates[MIN_CLOCK + 1].upper;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        clock->current_rate.lower = test_case->parameters[OFFSET_PARAM(
            struct arm_scmi_clock_rate_set, rate)];
        clock->current_rate.upper =
            test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_rate_set,
                                               rate) +
                                  1];
        clock->rate_set = true;
      }
    }
  }
}"
opticron-libuweave-2e5e385/src/device_crypto.c	Reset the crypto state.	2	"void uw_device_crypto_reset_(UwDeviceCrypto *device_crypto) {
  *device_crypto = (UwDeviceCrypto){};
  save_keys_(device_crypto);
  uw_device_crypto_init_(device_crypto);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the squareroot of a quaternion	2	"LIB_FUNC MATH_FUNC quaternion qsqrt(const quaternion num) {
  return qmid(num, (quaternion){1.0, 0.0, 0.0, 0.0});
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/RNDISEthernet/Lib/TCP.c	"Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission."	2	"void TCP_Task(void) {

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS;
         PTableEntry++) {

      if ((PortStateTable[PTableEntry].Port ==
           ConnectionStateTable[CSTableEntry].Port) &&
          (PortStateTable[PTableEntry].State == TCP_Port_Open)) {
        PortStateTable[PTableEntry].ApplicationHandler(
            &ConnectionStateTable[CSTableEntry],
            &ConnectionStateTable[CSTableEntry].Info.Buffer);
      }
    }
  }

  if (FrameOUT.FrameInBuffer)
    return;

  for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS;
       CSTableEntry++) {

    if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction ==
         TCP_PACKETDIR_OUT) &&
        (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready)) {
      Ethernet_Frame_Header_t *FrameOUTHeader =
          (Ethernet_Frame_Header_t *)&FrameOUT.FrameData;
      IP_Header_t *IPHeaderOUT =
          (IP_Header_t *)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
      TCP_Header_t *TCPHeaderOUT =
          (TCP_Header_t *)&FrameOUT
              .FrameData[sizeof(Ethernet_Frame_Header_t) + sizeof(IP_Header_t)];
      void *TCPDataOUT =
          &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
                              sizeof(IP_Header_t) + sizeof(TCP_Header_t)];

      uint16_t PacketSize =
          ConnectionStateTable[CSTableEntry].Info.Buffer.Length;

      TCPHeaderOUT->SourcePort = ConnectionStateTable[CSTableEntry].Port;
      TCPHeaderOUT->DestinationPort =
          ConnectionStateTable[CSTableEntry].RemotePort;
      TCPHeaderOUT->SequenceNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
      TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(
          ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
      TCPHeaderOUT->DataOffset = (sizeof(TCP_Header_t) / sizeof(uint32_t));
      TCPHeaderOUT->WindowSize = SwapEndian_16(TCP_WINDOW_SIZE);

      TCPHeaderOUT->Flags = TCP_FLAG_ACK;
      TCPHeaderOUT->UrgentPointer = 0;
      TCPHeaderOUT->Checksum = 0;
      TCPHeaderOUT->Reserved = 0;

      memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data,
             PacketSize);

      ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

      TCPHeaderOUT->Checksum =
          TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
                         ConnectionStateTable[CSTableEntry].RemoteAddress,
                         (sizeof(TCP_Header_t) + PacketSize));

      PacketSize += sizeof(TCP_Header_t);

      IPHeaderOUT->TotalLength =
          SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
      IPHeaderOUT->TypeOfService = 0;
      IPHeaderOUT->HeaderLength = (sizeof(IP_Header_t) / sizeof(uint32_t));
      IPHeaderOUT->Version = 4;
      IPHeaderOUT->Flags = 0;
      IPHeaderOUT->FragmentOffset = 0;
      IPHeaderOUT->Identification = 0;
      IPHeaderOUT->HeaderChecksum = 0;
      IPHeaderOUT->Protocol = PROTOCOL_TCP;
      IPHeaderOUT->TTL = DEFAULT_TTL;
      IPHeaderOUT->SourceAddress = ServerIPAddress;
      IPHeaderOUT->DestinationAddress =
          ConnectionStateTable[CSTableEntry].RemoteAddress;

      IPHeaderOUT->HeaderChecksum =
          Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));

      PacketSize += sizeof(IP_Header_t);

      FrameOUTHeader->Source = ServerMACAddress;
      FrameOUTHeader->Destination =
          (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
      FrameOUTHeader->EtherType = SwapEndian_16(ETHERTYPE_IPV4);

      PacketSize += sizeof(Ethernet_Frame_Header_t);

      FrameOUT.FrameLength = PacketSize;
      FrameOUT.FrameInBuffer = true;

      ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

      break;
    }
  }
}"
dzop-emacs-zmq-99c1101/src/poll.c	"Return the socket or file descriptor contained in EVENT as an Emacs value. If EVENT has a socket, the socket from EVENT is matched to one of the sockets in POLLER's list of sockets and returned. Otherwise, the file descriptor is returned."	2	"ezmq_get_poll_trigger(ezmq_obj_t *poller, zmq_poller_event_t event) {
  emacs_value trigger = Qnil;

  if (NONLOCAL_EXIT())
    return NULL;

  if (event.socket) {
    emacs_value socks = ezmq_obj_get_val(poller);
    while (!NILP(socks)) {
      emacs_value esock = CAR(socks);
      EZMQ_EXTRACT_OBJ(sock, EZMQ_SOCKET, esock);
      if (sock->obj == event.socket) {
        trigger = esock;
        break;
      }
      socks = CDR(socks);
    }
  } else
    trigger = INT(event.fd);

  if (EQ(trigger, Qnil)) {

    char *msg = ""Socket not found in poller!"";
    FUNCALL(INTERN(""error""), 1, (emacs_value[]){STRING(msg, strlen(msg))});
  }

  return trigger;
}"
ManagementCenterInnsbruck-Multicopter_LARIX-0d9e18e/Software/LARIX Flightcontroller/DAVE3/Flightcontroller/Dave/Model/USBCDC001/1.0.14/Templates/Drivers/USB/Class/Device/CDC.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber,
                          ENDPOINT_DIR_IN);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"
tsani-tetrefis-02d47ef/text.c	This isn't particularly efficient since a pass is done over the string to determine its width before offsetting it.	2	"bt_render_string_centered(LFB *const dest,
                          bt_renderer_info const *const renderer_info,
                          vec2 const origin, char const *const str,
                          UINT32 length) {

  INT32 w = measure_string_width(renderer_info, str, length);
  bt_render_string(dest, renderer_info, vec2_add(origin, (vec2){-w / 2, 0}),
                   str, length);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the squareroot of a quaternion	2	"LIB_FUNC MATH_FUNC quaternion_float qsqrtf(const quaternion_float num) {
  return qmidf(num, (quaternion_float){1.0F, 0.0F, 0.0F, 0.0F});
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/StillImage.c	Closes an already opened PIMA session with the attached device. This should be used after all session-orientated PIMA commands have been issued to the device.	2	"uint8_t SI_Host_CloseSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = 0x1003,
      .Params = {1},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SIInterfaceInfo->State.IsSessionOpen = false;

  if ((PIMABlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  return PIPE_RWSTREAM_NoError;
}"
yingted-miredo-2ea60a3/libtun6/tun6.c	Tries to allocate a tunnel interface from the kernel.	2	"tun6 *tun6_create(const char *req_name) {
#ifndef ANDROID
  (void)bindtextdomain(PACKAGE_NAME, LOCALEDIR);
#endif
  tun6 *t = (tun6 *)malloc(sizeof(*t));
  if (t == NULL)
    return NULL;
  memset(t, 0, sizeof(*t));

  int reqfd = t->reqfd = socket(AF_INET6, SOCK_DGRAM, 0);
  if (reqfd == -1) {
    free(t);
    return NULL;
  }

  fcntl(reqfd, F_SETFD, FD_CLOEXEC);

#if defined(USE_LINUX)

  static const char tundev[] = DEV_NET_TUN;
  struct ifreq req = {.ifr_flags = IFF_TUN};

  if ((req_name != NULL) && safe_strcpy(req.ifr_name, req_name)) {
    free(t);
    return NULL;
  }

  int fd = open(tundev, O_RDWR);
  if (fd == -1) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), tundev);
    (void)close(reqfd);
    free(t);
    return NULL;
  }

  if (ioctl(fd, TUNSETIFF, (void *)&req)) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""TUNSETIFF"");
    if (errno == EBUSY)
      syslog(LOG_INFO, _(""Please make sure another instance of the program is ""
                         ""not already running.""));
    goto error;
  }

  int id = if_nametoindex(req.ifr_name);
  if (id == 0)
    goto error;
#elif defined(USE_BSD)
#ifdef HAVE_KLDLOAD
  kldload(""if_tun"");
#endif

  int fd = open(""/dev/tun"", O_RDWR);
  if ((fd == -1) && (errno == ENOENT)) {

    int saved_errno = 0;
    for (unsigned i = 0; fd == -1; i++) {
      char tundev[5 + IFNAMSIZ];
      snprintf(tundev, sizeof(tundev), ""/dev/tun%u"", i);

      fd = open(tundev, O_RDWR);
      if ((fd == -1) && (errno == ENOENT))

        break;

      saved_errno = errno;
    }
    errno = saved_errno;
  }

  if (fd == -1) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""/dev/tun*"");
    goto error;
  } else {
    struct stat st;
    fstat(fd, &st);
#ifdef HAVE_DEVNAME_R
    devname_r(st.st_rdev, S_IFCHR, t->orig_name, sizeof(t->orig_name));
#else
    const char *name = devname(st.st_rdev, S_IFCHR);
    if (safe_strcpy(t->orig_name, name))
      goto error;
#endif
  }

  int id = if_nametoindex(t->orig_name);
  if (id == 0) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), t->orig_name);
    goto error;
  }

#ifdef TUNSIFMODE

  (void)ioctl(fd, TUNSIFMODE, &(int){IFF_BROADCAST});
#endif

#if defined(TUNSIFHEAD)

  if (ioctl(fd, TUNSIFHEAD, &(int){1})) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""TUNSIFHEAD"");
#if defined(__APPLE__)
    if (errno == EINVAL)
      syslog(LOG_NOTICE, ""*** Ignoring tun-tap-osx spurious error ***"");
    else
#endif
      goto error;
  }
#elif defined(TUNSLMODE)

  if (ioctl(fd, TUNSLMODE, &(int){0})) {
    syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""TUNSLMODE"");
    goto error;
  }
#endif

  if (req_name != NULL) {
    struct ifreq req;
    memset(&req, 0, sizeof(req));

    if (if_indextoname(id, req.ifr_name) == NULL) {
      syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""if_indextoname"");
      goto error;
    } else if (strcmp(req.ifr_name, req_name)) {
#ifdef SIOCSIFNAME
      char ifname[IFNAMSIZ];
      req.ifr_data = ifname;

      errno = ENAMETOOLONG;
      if (safe_strcpy(ifname, req_name) || ioctl(reqfd, SIOCSIFNAME, &req))
#else
      syslog(LOG_DEBUG, ""Tunnel interface renaming is not supported on your ""
                        ""operating system.\n""
                        ""To run miredo properly, you need to remove the ""
                        ""InterfaceName directive\n""
                        ""from its configuration file.\n"");
      errno = ENOSYS;
#endif
      {
        syslog(LOG_ERR, _(""Tunneling driver error (%s): %m""), ""SIOCSIFNAME"");
        goto error;
      }
    }
  }
#else
#error No tunneling driver implemented on your platform!
#endif

  fcntl(fd, F_SETFD, FD_CLOEXEC);

  t->id = id;
  t->fd = fd;
  return t;

error:
  (void)close(reqfd);
  if (fd != -1)
    (void)close(fd);
  syslog(LOG_ERR, _(""%s tunneling interface creation failure""), os_driver);
  free(t);
  return NULL;
}"
lexborisov-Modest-4b279a3/source/myhtml/myhtml.c	Get raw position for Attribute Value in Incoming Buffer	2	"myhtml_position_t
myhtml_attribute_value_raw_position(myhtml_tree_attr_t *attr) {
  if (attr)
    return (myhtml_position_t){attr->raw_value_begin, attr->raw_value_length};

  return (myhtml_position_t){0, 0};
}"
TangXiaoLv-Android-Sqlite-Fts5-Tokenizer-c7a09a0/sqlite3/src/main/cpp/icu_common_59/unifiedcache.h	"Returns the unused entry count in this cache. For testing only, Regular clients will not need this."	4	"LocaleCacheKey(const Locale &loc) : fLoc(loc){};
LocaleCacheKey(const LocaleCacheKey<T> &other)
    : CacheKey<T>(other), fLoc(other.fLoc) {}
virtual ~LocaleCacheKey() {}"
ARM-software-scmi-tests-24dd373/protocols/sensor/sensor_exe.c	The function is called by the test engine before sending the sensor trip point notify command and testing the received values.	3	"void arm_scmi_custom_tester_sensor_trip_point_notify(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {

  uint32_t idx;
  uint8_t notification_enable = 0;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 2;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_sensor_trip_point_notify,
                           sensor_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_notify,
                                       sensor_id)] =
        sensor_protocol_data.sensor_id[sensor_protocol_data.num_sensors - 1] +
        1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_notify,
                                       sensor_event_control)] =
        sensor_protocol_data.num_sensors;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (idx = 0; idx < sensor_protocol_data.num_sensors; ++idx) {
      snprintf(description, NUM_ELEMS(description), ""\n\t\t\tSENSOR ID %d"",
               sensor_protocol_data.sensor_id[idx]);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_sensor_trip_point_config, sensor_id)] =
          sensor_protocol_data.sensor_id[idx];
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_sensor_trip_point_notify, sensor_event_control)] =
          (0 << 1) + notification_enable;
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  }
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Divide two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qdivl(const quaternion_long_double num1, const quaternion_long_double num2) {
  if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) &&
      (num1.k == num2.k)) {
    return (quaternion_long_double){1.0L, 0.0L, 0.0L, 0.0L};
  }
  const long double tmp_r = (num2.R * num1.R) + (num2.i * num1.i) +
                            (num2.j * num1.j) + (num2.k * num1.k);
  const long double tmp_i = (num2.R * num1.i) - (num2.i * num1.R) -
                            (num2.j * num1.k) + (num2.k * num1.j);
  const long double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) -
                            (num2.j * num1.R) - (num2.k * num1.i);
  const long double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                            (num2.j * num1.i) - (num2.k * num1.R);
  register long double tmp2n =
      squarerootl((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) +
                  (num2.k * num2.k));
  return (quaternion_long_double){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n,
                                  tmp_k / tmp2n};
}"
uber-h3-643d8e4/src/h3lib/lib/algos.c	"Internal: Create a LinkedGeoPolygon from a vertex graph. It is the responsibility of the caller to call destroyLinkedPolygon on the populated linked geo structure, or the memory for that structure will not be freed."	2	"void _vertexGraphToLinkedGeo(VertexGraph *graph, LinkedGeoPolygon *out) {
  *out = (LinkedGeoPolygon){0};
  LinkedGeoLoop *loop;
  VertexNode *edge;
  GeoCoord nextVtx;

  while ((edge = firstVertexNode(graph)) != NULL) {
    loop = addNewLinkedLoop(out);

    do {
      addLinkedCoord(loop, &edge->from);
      nextVtx = edge->to;

      removeVertexNode(graph, edge);
      edge = findNodeForVertex(graph, &nextVtx);
    } while (edge);
  }
}"
ArsMasiuk-qvge-d59b48a/src/3rdParty/ogdf/include/ogdf/external/Minisat.h	read a formula from a DIMACS file	2	"public:
Internal::Solver::SolverStatus solverStatus;

Model(){};
virtual ~Model() { reset(); }"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Creates a timer to run a task at the specified interval. Returns -1 on error.	2	"int fio_run_every(size_t milliseconds, size_t repetitions, void (*task)(void *),
                  void *arg, void (*on_finish)(void *)) {
  if (!task || (milliseconds == 0 && !repetitions))
    return -1;
  fio_timer_s *timer = malloc(sizeof(*timer));
  FIO_ASSERT_ALLOC(timer);
  fio_mark_time();
  *timer = (fio_timer_s){
      .due = fio_timer_calc_due(milliseconds),
      .interval = milliseconds,
      .repetitions = repetitions,
      .task = task,
      .arg = arg,
      .on_finish = on_finish,
  };
  fio_timer_add_order(timer);
  return 0;
}"
dm-vdo-kvdo-8df6805/vdo/kernel/kernelVDO.c	Initialize a VDOActionData structure so that the specified action can be invoked on the specified completion.	2	"static void initializeVDOActionData(VDOActionData *data, VDOAction *action,
                                    VDOCompletion *vdoCompletion) {
  *data = (VDOActionData){
      .action = action,
      .vdoCompletion = vdoCompletion,
  };
}"
gtav-ent-GTAV-EnhancedNativeTrainer-bb5c312/EnhancedNativeTrainer/src/io/config_io.h	Read the user config in from an XML file. Read the XML config file. Currently contains keyboard choices.	2	"static const std::string KEY_TOGGLE_MAIN_MENU;
static const std::string KEY_TOGGLE_AIRBRAKE;

static const std::string KEY_MENU_UP;
static const std::string KEY_MENU_DOWN;
static const std::string KEY_MENU_LEFT;
static const std::string KEY_MENU_RIGHT;
static const std::string KEY_MENU_SELECT;
static const std::string KEY_MENU_BACK;

static const std::string KEY_VEH_BOOST;
static const std::string KEY_VEH_STOP;
static const std::string KEY_VEH_ROCKETS;

static const std::string KEY_AIRBRAKE_UP;
static const std::string KEY_AIRBRAKE_DOWN;
static const std::string KEY_AIRBRAKE_ROTATE_LEFT;
static const std::string KEY_AIRBRAKE_ROTATE_RIGHT;
static const std::string KEY_AIRBRAKE_FORWARD;
static const std::string KEY_AIRBRAKE_BACK;
static const std::string KEY_AIRBRAKE_SPEED;
static const std::string KEY_AIRBRAKE_FREEZE_TIME;
static const std::string KEY_AIRBRAKE_HELP;

static const std::string KEY_OBJECTPLACER_UP;
static const std::string KEY_OBJECTPLACER_DOWN;
static const std::string KEY_OBJECTPLACER_FORWARD;
static const std::string KEY_OBJECTPLACER_BACK;
static const std::string KEY_OBJECTPLACER_ROTATE_LEFT;
static const std::string KEY_OBJECTPLACER_ROTATE_RIGHT;
static const std::string KEY_OBJECTPLACER_SPEED_CYCLE;
static const std::string KEY_OBJECTPLACER_SPEED_UP;
static const std::string KEY_OBJECTPLACER_SPEED_DOWN;
static const std::string KEY_OBJECTPLACER_FREEZE_TIME;
static const std::string KEY_OBJECTPLACER_FREEZE_POSITION;
static const std::string KEY_OBJECTPLACER_HELP;
static const std::string KeyConfig::KEY_OBJECTPLACER_ALT_MOVE;

static const std::string KEY_HOT_AIRBRAKE_THROUGH_DOOR;

static const std::string KEY_HOT_1;
static const std::string KEY_HOT_2;
static const std::string KEY_HOT_3;
static const std::string KEY_HOT_4;
static const std::string KEY_HOT_5;
static const std::string KEY_HOT_6;
static const std::string KEY_HOT_7;
static const std::string KEY_HOT_8;
static const std::string KEY_HOT_9;

inline KeyConfig(int code) { this->keyCode = code; };

int keyCode;
bool modCtrl = false;
bool modAlt = false;
bool modShift = false;
}
;

struct ButtonsWithNames {
  std::string name;
  WORD buttonCode;
  bool isAnalog;
};

class ControllerButtonConfig {
public:
  static const std::string CONTROLLER_BTN_X;
  static const std::string CONTROLLER_BTN_Y;
  static const std::string CONTROLLER_BTN_A;
  static const std::string CONTROLLER_BTN_B;
  static const std::string CONTROLLER_BTN_DPAD_L;
  static const std::string CONTROLLER_BTN_DPAD_R;
  static const std::string CONTROLLER_BTN_DPAD_U;
  static const std::string CONTROLLER_BTN_DPAD_D;
  static const std::string CONTROLLER_BTN_SHOULDER_L;
  static const std::string CONTROLLER_BTN_SHOULDER_R;
  static const std::string CONTROLLER_BTN_TRIGGER_L;
  static const std::string CONTROLLER_BTN_TRIGGER_R;
  static const std::string CONTROLLER_BTN_BACK;
  static const std::string CONTROLLER_BTN_START;
  static const std::string CONTROLLER_LSTICK_L;
  static const std::string CONTROLLER_LSTICK_R;
  static const std::string CONTROLLER_LSTICK_U;
  static const std::string CONTROLLER_LSTICK_D;
  static const std::string CONTROLLER_RSTICK_L;
  static const std::string CONTROLLER_RSTICK_R;
  static const std::string CONTROLLER_RSTICK_U;
  static const std::string CONTROLLER_RSTICK_D;
  static const std::string CONTROLLER_LSTICK_CLICK;
  static const std::string CONTROLLER_RSTICK_CLICK;
  static const std::string CONTROLLER_NOT_BOUND;

  inline ControllerButtonConfig(){};

  void add_button(char *name);

  void add_button(std::string name);

  std::vector<ButtonsWithNames> buttonCodes;
};

class KeyInputConfig {
public:
  KeyInputConfig();

  virtual ~KeyInputConfig();

  std::map<std::string, KeyConfig *> keyConfigs;

  std::map<std::string, ControllerButtonConfig *> controllerConfigs;

  KeyConfig *get_key(std::string function);

  ControllerButtonConfig *get_controller_button(std::string function);

  void set_key(char *function, char *keyName, bool modCtrl = false,
               bool modAlt = false, bool modShift = false);

  void set_control(char *function, ControllerButtonConfig *config);

  bool is_hotkey_assigned(int i);
};

class TrainerConfig {
public:
  TrainerConfig();
  KeyInputConfig *get_key_config() { return keyConfig; }

private:
  KeyInputConfig *keyConfig;
};

extern TrainerConfig *config;

void read_config_file();

inline TrainerConfig *get_config() { return config; }"
dm-vdo-kvdo-8df6805/vdo/base/vdoPageCache.c	"Initialize a VDO Page Completion, requesting a particular page from the cache."	2	"void initVDOPageCompletion(VDOPageCompletion *pageCompletion,
                           VDOPageCache *cache, PhysicalBlockNumber pbn,
                           bool writable, void *parent, VDOAction *callback,
                           VDOAction *errorHandler) {
  ASSERT_LOG_ONLY((pageCompletion->waiter.nextWaiter == NULL),
                  ""New page completion was not already on a wait queue"");

  *pageCompletion = (VDOPageCompletion){
      .pbn = pbn,
      .writable = writable,
      .cache = cache,
  };

  VDOCompletion *completion = &pageCompletion->completion;
  initializeCompletion(completion, VDO_PAGE_COMPLETION, cache->layer);
  prepareCompletion(completion, callback, errorHandler, cache->threadID,
                    parent);
}"
tempesta-tech-tempesta-9bbfee9/tempesta_fw/http.c	Set message body for predefined response with corresponding code.	2	"tfw_http_config_resp_body(int status_code, const char *filename) {
  resp_code_t code;
  size_t cl_sz, b_sz, sz, b_off;
  char *cl, *body;
  TfwStr c_len_hdr = {.chunks =
                          (TfwStr[]){
                              {.data = S_CRLF S_F_CONTENT_LENGTH,
                               .len = SLEN(S_CRLF S_F_CONTENT_LENGTH)},
                              {.data = NULL, .len = 0},
                              {.data = S_CRLF, .len = SLEN(S_CRLF)},
                          },
                      .len = SLEN(S_CRLF S_F_CONTENT_LENGTH S_CRLF),
                      .nchunks = 3};

  if (!(cl = __tfw_http_msg_body_dup(filename, &c_len_hdr, &sz, &b_off)))
    return -EINVAL;

  cl_sz = b_off;
  body = cl + b_off;
  b_sz = sz - b_off;

  if (status_code == HTTP_STATUS_4XX || status_code == HTTP_STATUS_5XX) {
    tfw_http_set_common_body(status_code, cl, cl_sz, body, b_sz);
    return 0;
  }

  code = tfw_http_enum_resp_code(status_code);
  if (code == RESP_NUM) {
    TFW_ERR_NL(""Unexpected status code: [%d]\n"", status_code);
    return -EINVAL;
  }

  tfw_http_set_body(code, cl, cl_sz, body, b_sz);

  return 0;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/inteldlg.c	Update the intelligence dialog for the given player. This is called by the core client code when that player's information changes.	2	"void update_intel_dialog(struct player *p) {
  const struct research *mresearch, *presearch;
  struct intel_dialog *pdialog = get_intel_dialog(p);
  struct widget *pWindow = NULL, *pBuf = NULL, *pLast;
  SDL_Surface *pLogo = NULL, *pTmpSurf = NULL;
  SDL_Surface *pText1, *pInfo, *pText2 = NULL;
  utf8_str *pstr;
  SDL_Rect dst;
  char cBuf[256], plr_buf[4 * MAX_LEN_NAME];
  int n = 0, count = 0, col;
  struct city *pCapital;
  SDL_Rect area;
  struct research *research;

  if (pdialog) {

    if (pdialog->pdialog->pEndWidgetList) {
      pdialog->pos_x = pdialog->pdialog->pEndWidgetList->size.x;
      pdialog->pos_y = pdialog->pdialog->pEndWidgetList->size.y;

      popdown_window_group_dialog(pdialog->pdialog->pBeginWidgetList,
                                  pdialog->pdialog->pEndWidgetList);
    }

    pstr =
        create_utf8_from_char(_(""Foreign Intelligence Report""), adj_font(12));
    pstr->style |= TTF_STYLE_BOLD;

    pWindow = create_window_skeleton(NULL, pstr, 0);

    pWindow->action = intel_window_dlg_callback;
    set_wstate(pWindow, FC_WS_NORMAL);
    pWindow->data.player = p;

    add_to_gui_list(ID_WINDOW, pWindow);
    pdialog->pdialog->pEndWidgetList = pWindow;

    area = pWindow->area;

    pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                            WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
    pBuf->info_label =
        create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
    area.w = MAX(area.w, pBuf->size.w + adj_size(10));
    pBuf->action = exit_intel_dlg_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->data.player = p;
    pBuf->key = SDLK_ESCAPE;

    add_to_gui_list(ID_BUTTON, pBuf);

    pLogo = get_nation_flag_surface(nation_of_player(p));

    {
      double zoom = DEFAULT_ZOOM * 60.0 / pLogo->h;

      pText1 = zoomSurface(pLogo, zoom, zoom, 1);
    }

    pLogo = pText1;

    pBuf = create_icon2(pLogo, pWindow->dst,
                        WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                            WF_FREE_THEME);
    pBuf->action = spaceship_callback;
    set_wstate(pBuf, FC_WS_NORMAL);
    pBuf->data.player = p;
    fc_snprintf(cBuf, sizeof(cBuf),
                _(""Intelligence Information about the %s Spaceship""),
                nation_adjective_for_player(p));
    pBuf->info_label = create_utf8_from_char(cBuf, adj_font(12));

    add_to_gui_list(ID_ICON, pBuf);

    fc_snprintf(cBuf, sizeof(cBuf),
                _(""Intelligence Information for the %s Empire""),
                nation_adjective_for_player(p));

    pstr = create_utf8_from_char(cBuf, adj_font(14));
    pstr->style |= TTF_STYLE_BOLD;
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};

    pText1 = create_text_surf_from_utf8(pstr);
    area.w = MAX(area.w, pText1->w + adj_size(20));
    area.h += pText1->h + adj_size(20);

    pCapital = player_capital(p);
    research = research_get(p);
    change_ptsize_utf8(pstr, adj_font(10));
    pstr->style &= ~TTF_STYLE_BOLD;

    switch (research->researching) {
    case A_UNKNOWN:
    case A_UNSET:
      fc_snprintf(cBuf, sizeof(cBuf),
                  _(""Ruler: %s  Government: %s\n""
                    ""Capital: %s  Gold: %d\n""
                    ""Tax: %d%% Science: %d%% Luxury: %d%%\n""
                    ""Researching: unknown""),
                  ruler_title_for_player(p, plr_buf, sizeof(plr_buf)),
                  government_name_for_player(p),

                  NULL != pCapital ? city_name_get(pCapital) : _(""(unknown)""),
                  p->economic.gold, p->economic.tax, p->economic.science,
                  p->economic.luxury);
      break;
    default:
      fc_snprintf(
          cBuf, sizeof(cBuf),
          _(""Ruler: %s  Government: %s\n""
            ""Capital: %s  Gold: %d\n""
            ""Tax: %d%% Science: %d%% Luxury: %d%%\n""
            ""Researching: %s(%d/%d)""),
          ruler_title_for_player(p, plr_buf, sizeof(plr_buf)),
          government_name_for_player(p),

          NULL != pCapital ? city_name_get(pCapital) : _(""(unknown)""),
          p->economic.gold, p->economic.tax, p->economic.science,
          p->economic.luxury,
          research_advance_name_translation(research, research->researching),
          research->bulbs_researched, research->client.researching_cost);
      break;
    };

    copy_chars_to_utf8_str(pstr, cBuf);
    pInfo = create_text_surf_from_utf8(pstr);
    area.w = MAX(area.w, pLogo->w + adj_size(10) + pInfo->w + adj_size(20));
    area.h += MAX(pLogo->h + adj_size(20), pInfo->h + adj_size(20));

    pTmpSurf = get_tech_icon(A_FIRST);
    col = area.w / (pTmpSurf->w + adj_size(4));
    FREESURFACE(pTmpSurf);
    n = 0;
    pLast = pBuf;
    mresearch = research_get(client_player());
    presearch = research_get(p);
    advance_index_iterate(A_FIRST, i) {
      if (TECH_KNOWN == research_invention_state(presearch, i) &&
          research_invention_reachable(mresearch, i) &&
          TECH_KNOWN != research_invention_state(mresearch, i)) {

        pBuf = create_icon2(get_tech_icon(i), pWindow->dst,
                            WF_RESTORE_BACKGROUND | WF_WIDGET_HAS_INFO_LABEL |
                                WF_FREE_THEME);
        pBuf->action = tech_callback;
        set_wstate(pBuf, FC_WS_NORMAL);

        pBuf->info_label = create_utf8_from_char(
            advance_name_translation(advance_by_number(i)), adj_font(12));

        add_to_gui_list(ID_ICON, pBuf);

        if (n > ((2 * col) - 1)) {
          set_wflag(pBuf, WF_HIDDEN);
        }

        n++;
      }
    }
    advance_index_iterate_end;

    pdialog->pdialog->pBeginWidgetList = pBuf;

    if (n > 0) {
      pdialog->pdialog->pEndActiveWidgetList = pLast->prev;
      pdialog->pdialog->pBeginActiveWidgetList =
          pdialog->pdialog->pBeginWidgetList;
      if (n > 2 * col) {
        pdialog->pdialog->pActiveWidgetList =
            pdialog->pdialog->pEndActiveWidgetList;
        count = create_vertical_scrollbar(pdialog->pdialog, col, 2, TRUE, TRUE);
        area.h += (2 * pBuf->size.h + adj_size(10));
      } else {
        count = 0;
        if (n > col) {
          area.h += pBuf->size.h;
        }
        area.h += (adj_size(10) + pBuf->size.h);
      }

      area.w = MAX(area.w, col * pBuf->size.w + count);

      fc_snprintf(cBuf, sizeof(cBuf), _(""Their techs that we don't have :""));
      copy_chars_to_utf8_str(pstr, cBuf);
      pstr->style |= TTF_STYLE_BOLD;
      pText2 = create_text_surf_from_utf8(pstr);
    }

    FREEUTF8STR(pstr);

    resize_window(pWindow, NULL, NULL,
                  (pWindow->size.w - pWindow->area.w) + area.w,
                  (pWindow->size.h - pWindow->area.h) + area.h);

    area = pWindow->area;

    widget_set_position(
        pWindow,
        (pdialog->pos_x) ? (pdialog->pos_x)
                         : ((main_window_width() - pWindow->size.w) / 2),
        (pdialog->pos_y) ? (pdialog->pos_y)
                         : ((main_window_height() - pWindow->size.h) / 2));

    pBuf = pWindow->prev;
    pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
    pBuf->size.y = pWindow->size.y + adj_size(2);

    dst.x = area.x + (area.w - pText1->w) / 2;
    dst.y = area.y + adj_size(8);

    alphablit(pText1, NULL, pWindow->theme, &dst, 255);
    dst.y += pText1->h + adj_size(10);
    FREESURFACE(pText1);

    pBuf = pBuf->prev;
    dst.x = area.x + (area.w - (pBuf->size.w + adj_size(10) + pInfo->w)) / 2;
    pBuf->size.x = dst.x;
    pBuf->size.y = dst.y;

    dst.x += pBuf->size.w + adj_size(10);
    alphablit(pInfo, NULL, pWindow->theme, &dst, 255);
    dst.y += pInfo->h + adj_size(10);
    FREESURFACE(pInfo);

    if (n) {
      dst.x = area.x + adj_size(5);
      alphablit(pText2, NULL, pWindow->theme, &dst, 255);
      dst.y += pText2->h + adj_size(2);
      FREESURFACE(pText2);

      setup_vertical_widgets_position(col, area.x, dst.y, 0, 0,
                                      pdialog->pdialog->pBeginActiveWidgetList,
                                      pdialog->pdialog->pEndActiveWidgetList);

      if (pdialog->pdialog->pScroll) {
        setup_vertical_scrollbar_area(pdialog->pdialog->pScroll,
                                      area.x + area.w, dst.y,
                                      area.h - (dst.y + 1), TRUE);
      }
    }

    redraw_group(pdialog->pdialog->pBeginWidgetList,
                 pdialog->pdialog->pEndWidgetList, 0);
    widget_mark_dirty(pWindow);

    flush_dirty();
  }
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/dialogs.c	Popup the nation selection dialog.	2	"void popup_races_dialog(struct player *pplayer) {
  SDL_Color bg_color = {255, 255, 255, 128};

  struct widget *pWindow, *pWidget = NULL, *pBuf, *pLast_City_Style;
  utf8_str *pstr;
  int len = 0;
  int w = adj_size(10), h = adj_size(10);
  SDL_Surface *pTmp_Surf, *pTmp_Surf_zoomed = NULL;
  SDL_Surface *pMain_Bg, *pText_Name, *pText_Class;
  SDL_Rect dst;
  float zoom;
  struct NAT *pSetup;
  SDL_Rect area;
  int i;
  struct nation_type *pnat;
  struct widget *nationsets = NULL;
  int natinfo_y, natinfo_h;

#define TARGETS_ROW 5
#define TARGETS_COL 1

  if (pNationDlg) {
    return;
  }

  races_player = pplayer;

  pNationDlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pstr = create_utf8_from_char(_(""What nation will you be?""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window(NULL, pstr, w, h, WF_FREE_DATA);
  pWindow->action = nations_dialog_callback;
  set_wstate(pWindow, FC_WS_NORMAL);
  pSetup = fc_calloc(1, sizeof(struct NAT));
  pWindow->data.ptr = (void *)pSetup;

  pNationDlg->pEndWidgetList = pWindow;
  add_to_gui_list(ID_NATION_WIZARD_WINDOW, pWindow);

  pMain_Bg = create_surf(adj_size(96 * 2), adj_size(64), SDL_SWSURFACE);

  SDL_FillRect(pMain_Bg, NULL, map_rgba(pMain_Bg->format, bg_color));

  create_frame(pMain_Bg, 0, 0, pMain_Bg->w - 1, pMain_Bg->h - 1,
               get_theme_color(COLOR_THEME_NATIONDLG_FRAME));

  pstr = create_utf8_str(NULL, 0, adj_font(12));
  pstr->style |= (SF_CENTER | TTF_STYLE_BOLD);
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};

  pText_Class = NULL;

  nations_iterate(pNation) {
    if (!is_nation_playable(pNation) || !is_nation_pickable(pNation)) {
      continue;
    }

    pTmp_Surf_zoomed = adj_surf(get_nation_flag_surface(pNation));

    pTmp_Surf = crop_rect_from_surface(pMain_Bg, NULL);

    copy_chars_to_utf8_str(pstr, nation_plural_translation(pNation));
    change_ptsize_utf8(pstr, adj_font(12));
    pText_Name =
        create_text_surf_smaller_than_w(pstr, pTmp_Surf->w - adj_size(4));

    if (pNation->legend && *(pNation->legend) != '\0') {
      copy_chars_to_utf8_str(pstr, pNation->legend);
      change_ptsize_utf8(pstr, adj_font(10));
      pText_Class =
          create_text_surf_smaller_than_w(pstr, pTmp_Surf->w - adj_size(4));
    }

    dst.x = (pTmp_Surf->w - pTmp_Surf_zoomed->w) / 2;
    len = pTmp_Surf_zoomed->h + adj_size(10) + pText_Name->h +
          (pText_Class ? pText_Class->h : 0);
    dst.y = (pTmp_Surf->h - len) / 2;
    alphablit(pTmp_Surf_zoomed, NULL, pTmp_Surf, &dst, 255);
    dst.y += (pTmp_Surf_zoomed->h + adj_size(10));

    dst.x = (pTmp_Surf->w - pText_Name->w) / 2;
    alphablit(pText_Name, NULL, pTmp_Surf, &dst, 255);
    dst.y += pText_Name->h;
    FREESURFACE(pText_Name);

    if (pText_Class) {
      dst.x = (pTmp_Surf->w - pText_Class->w) / 2;
      alphablit(pText_Class, NULL, pTmp_Surf, &dst, 255);
      FREESURFACE(pText_Class);
    }

    pWidget = create_icon2(pTmp_Surf, pWindow->dst,
                           (WF_RESTORE_BACKGROUND | WF_FREE_THEME));

    set_wstate(pWidget, FC_WS_NORMAL);

    pWidget->action = nation_button_callback;

    w = MAX(w, pWidget->size.w);
    h = MAX(h, pWidget->size.h);

    add_to_gui_list(MAX_ID - nation_index(pNation), pWidget);

    if (nation_index(pNation) > (TARGETS_ROW * TARGETS_COL - 1)) {
      set_wflag(pWidget, WF_HIDDEN);
    }
  }
  nations_iterate_end;

  FREESURFACE(pMain_Bg);

  pNationDlg->pEndActiveWidgetList = pWindow->prev;
  pNationDlg->pBeginWidgetList = pWidget;
  pNationDlg->pBeginActiveWidgetList = pNationDlg->pBeginWidgetList;

  if (get_playable_nation_count() > TARGETS_ROW * TARGETS_COL) {
    pNationDlg->pActiveWidgetList = pNationDlg->pEndActiveWidgetList;
    create_vertical_scrollbar(pNationDlg, TARGETS_COL, TARGETS_ROW, TRUE, TRUE);
  }

  if (nation_set_count() > 1) {
    utf8_str *natset_str;
    struct option *poption;

    natset_str = create_utf8_from_char(_(""Nation set""), adj_font(12));
    change_ptsize_utf8(natset_str, adj_font(24));
    nationsets = create_iconlabel(NULL, pWindow->dst, natset_str, 0);
    add_to_gui_list(ID_LABEL, nationsets);

    poption = optset_option_by_name(server_optset, ""nationset"");
    pSetup->set = nation_set_by_setting_value(option_str_get(poption));

    natset_str = create_utf8_from_char(nation_set_name_translation(pSetup->set),
                                       adj_font(12));
    change_ptsize_utf8(natset_str, adj_font(24));

    pWidget = create_iconlabel(NULL, pWindow->dst, natset_str, 0);

    add_to_gui_list(ID_LABEL, pWidget);
    pSetup->pset_name = pWidget;

    pWidget = create_themeicon_button(current_theme->R_ARROW_Icon, pWindow->dst,
                                      NULL, 0);
    pWidget->action = next_set_callback;
    if (nation_set_index(pSetup->set) < nation_set_count() - 1) {
      set_wstate(pWidget, FC_WS_NORMAL);
    }
    add_to_gui_list(ID_NATION_NEXT_NATIONSET_BUTTON, pWidget);
    pWidget->size.h = pWidget->next->size.h;
    pSetup->pset_next = pWidget;

    pWidget = create_themeicon_button(current_theme->L_ARROW_Icon, pWindow->dst,
                                      NULL, 0);
    pWidget->action = prev_set_callback;
    if (nation_set_index(pSetup->set) > 0) {
      set_wstate(pWidget, FC_WS_NORMAL);
    }
    add_to_gui_list(ID_NATION_PREV_NATIONSET_BUTTON, pWidget);
    pWidget->size.h = pWidget->next->size.h;
    pSetup->pset_prev = pWidget;
  }

  pSetup->nation = fc_rand(get_playable_nation_count());
  pnat = nation_by_number(pSetup->nation);
  pSetup->nation_style = style_number(style_of_nation(pnat));

  copy_chars_to_utf8_str(pstr, nation_plural_translation(pnat));
  change_ptsize_utf8(pstr, adj_font(24));
  pstr->render = 2;
  pstr->fgcol = *get_theme_color(COLOR_THEME_NATIONDLG_TEXT);

  pTmp_Surf_zoomed = adj_surf(get_nation_flag_surface(pnat));

  pWidget =
      create_iconlabel(pTmp_Surf_zoomed, pWindow->dst, pstr,
                       (WF_ICON_ABOVE_TEXT | WF_ICON_CENTER | WF_FREE_GFX));
  if (nationsets == NULL) {
    pBuf = pWidget;
  } else {
    pBuf = nationsets;
  }

  add_to_gui_list(ID_LABEL, pWidget);

  pWidget = create_edit_from_chars(NULL, pWindow->dst, NULL, adj_font(16),
                                   adj_size(200), 0);
  pWidget->size.h = adj_size(24);

  set_wstate(pWidget, FC_WS_NORMAL);
  pWidget->action = leader_name_edit_callback;
  add_to_gui_list(ID_NATION_WIZARD_LEADER_NAME_EDIT, pWidget);
  pSetup->pName_Edit = pWidget;

  pWidget = create_themeicon_button(current_theme->R_ARROW_Icon, pWindow->dst,
                                    NULL, 0);
  pWidget->action = next_name_callback;
  add_to_gui_list(ID_NATION_WIZARD_NEXT_LEADER_NAME_BUTTON, pWidget);
  pWidget->size.h = pWidget->next->size.h;
  pSetup->pName_Next = pWidget;

  pWidget = create_themeicon_button(current_theme->L_ARROW_Icon, pWindow->dst,
                                    NULL, 0);
  pWidget->action = prev_name_callback;
  add_to_gui_list(ID_NATION_WIZARD_PREV_LEADER_NAME_BUTTON, pWidget);
  pWidget->size.h = pWidget->next->size.h;
  pSetup->pName_Prev = pWidget;

  pWidget = create_icon_button_from_chars(NULL, pWindow->dst, _(""Male""),
                                          adj_font(14), 0);
  pWidget->action = change_sex_callback;
  pWidget->size.w = adj_size(100);
  pWidget->size.h = adj_size(22);
  set_wstate(pWidget, FC_WS_NORMAL);
  pSetup->pChange_Sex = pWidget;

  add_to_gui_list(ID_NATION_WIZARD_CHANGE_SEX_BUTTON, pWidget);

  i = 0;
  zoom = DEFAULT_ZOOM * 1.0;

  len = 0;
  styles_iterate(pstyle) {
    i = basic_city_style_for_style(pstyle);

    pTmp_Surf = get_sample_city_surface(i);

    if (pTmp_Surf->w > 48) {
      zoom = DEFAULT_ZOOM * (48.0 / pTmp_Surf->w);
    }

    pTmp_Surf_zoomed = zoomSurface(get_sample_city_surface(i), zoom, zoom, 0);

    pWidget =
        create_icon2(pTmp_Surf_zoomed, pWindow->dst, WF_RESTORE_BACKGROUND);
    pWidget->action = style_callback;
    if (i != pSetup->nation_style) {
      set_wstate(pWidget, FC_WS_NORMAL);
    }
    len += pWidget->size.w;
    add_to_gui_list(MAX_ID - 1000 - i, pWidget);
  }
  styles_iterate_end;

  pLast_City_Style = pWidget;

  pWidget = create_themeicon_button_from_chars(
      current_theme->CANCEL_Icon, pWindow->dst, _(""Cancel""), adj_font(12), 0);
  pWidget->action = races_dialog_cancel_callback;
  set_wstate(pWidget, FC_WS_NORMAL);

  add_to_gui_list(ID_NATION_WIZARD_DISCONNECT_BUTTON, pWidget);

  pWidget = create_themeicon_button_from_chars(
      current_theme->OK_Icon, pWindow->dst, _(""OK""), adj_font(12), 0);
  pWidget->action = races_dialog_ok_callback;

  set_wstate(pWidget, FC_WS_NORMAL);
  add_to_gui_list(ID_NATION_WIZARD_START_BUTTON, pWidget);
  pWidget->size.w = MAX(pWidget->size.w, pWidget->next->size.w);
  pWidget->next->size.w = pWidget->size.w;

  pNationDlg->pBeginWidgetList = pWidget;

  pMain_Bg = theme_get_background(theme, BACKGROUND_NATIONDLG);
  if (resize_window(pWindow, pMain_Bg, NULL, adj_size(640), adj_size(480))) {
    FREESURFACE(pMain_Bg);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - pWindow->size.w) / 2,
                      (main_window_height() - pWindow->size.h) / 2);

  h = pNationDlg->pEndActiveWidgetList->size.h * TARGETS_ROW;
  i = (area.h - adj_size(43) - h) / 2;
  setup_vertical_widgets_position(
      TARGETS_COL, area.x + adj_size(10), area.y + i - adj_size(4), 0, 0,
      pNationDlg->pBeginActiveWidgetList, pNationDlg->pEndActiveWidgetList);

  if (pNationDlg->pScroll) {
    SDL_Rect area2;

    w = pNationDlg->pEndActiveWidgetList->size.w * TARGETS_COL;
    setup_vertical_scrollbar_area(pNationDlg->pScroll,
                                  area.x + w + adj_size(12),
                                  area.y + i - adj_size(4), h, FALSE);

    area2.x = area.x + w + adj_size(11);
    area2.y = area.y + i - adj_size(4);
    area2.w = pNationDlg->pScroll->pUp_Left_Button->size.w + adj_size(2);
    area2.h = h;
    fill_rect_alpha(pWindow->theme, &area2, &bg_color);

    create_frame(pWindow->theme, area2.x, area2.y - 1, area2.w, area2.h + 1,
                 get_theme_color(COLOR_THEME_NATIONDLG_FRAME));
  }

  if (nationsets != NULL) {

    pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - pBuf->size.w) / 2;
    pBuf->size.y = area.y + adj_size(46);

    natinfo_y = pBuf->size.y;
    natinfo_h = area.h -= pBuf->size.y;

    pBuf = pBuf->prev;
    pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - pBuf->size.w) / 2;
    pBuf->size.y = natinfo_y + adj_size(46);

    natinfo_y += adj_size(46);
    natinfo_h -= adj_size(46);

    pBuf = pBuf->prev;
    pBuf->size.x = pBuf->next->size.x + pBuf->next->size.w;
    pBuf->size.y = pBuf->next->size.y;

    pBuf = pBuf->prev;
    pBuf->size.x = pBuf->next->next->size.x - pBuf->size.w;
    pBuf->size.y = pBuf->next->size.y;

    pBuf = pBuf->prev;
  } else {
    natinfo_y = area.y;
    natinfo_h = area.h;
  }

  pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - pBuf->size.w) / 2;
  pBuf->size.y = natinfo_y + adj_size(46);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - pBuf->size.w) / 2;
  pBuf->size.y = natinfo_y + (natinfo_h - pBuf->size.h) / 2 - adj_size(30);

  pBuf = pBuf->prev;
  pBuf->size.x = pBuf->next->size.x + pBuf->next->size.w;
  pBuf->size.y = pBuf->next->size.y;

  pBuf = pBuf->prev;
  pBuf->size.x = pBuf->next->next->size.x - pBuf->size.w;
  pBuf->size.y = pBuf->next->size.y;

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - pBuf->size.w) / 2;
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h + adj_size(20);

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + area.w / 2 + (area.w / 2 - len) / 2 - adj_size(20);
  pBuf->size.y = pBuf->next->size.y + pBuf->next->size.h + adj_size(20);

  while (pBuf != pLast_City_Style) {
    pBuf = pBuf->prev;
    pBuf->size.x = pBuf->next->size.x + pBuf->next->size.w + adj_size(3);
    pBuf->size.y = pBuf->next->size.y;
  }

  create_line(
      pWindow->theme, area.x,
      natinfo_y + natinfo_h - adj_size(7) - pBuf->prev->size.h - adj_size(10),
      area.w - 1,
      natinfo_y + natinfo_h - adj_size(7) - pBuf->prev->size.h - adj_size(10),
      get_theme_color(COLOR_THEME_NATIONDLG_FRAME));

  pBuf = pBuf->prev;
  pBuf->size.x = area.x + adj_size(10);
  pBuf->size.y = natinfo_y + natinfo_h - adj_size(7) - pBuf->size.h;

  pBuf = pBuf->prev;
  pBuf->size.x = area.w - adj_size(10) - pBuf->size.w;
  pBuf->size.y = pBuf->next->size.y;

  select_random_leader(pSetup->nation);

  redraw_group(pNationDlg->pBeginWidgetList, pWindow, 0);

  widget_flush(pWindow);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/Firmware-Mikrocontroller/CLASS_DUAL_CDC1/CLASS_DUAL_CDC1/src/LUFA/LUFA/Drivers/USB/Class/Host/MassStorageClassHost.c	"Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties."	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Inquiry_Response_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  return MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock, InquiryData);
}"
ARM-software-scmi-tests-24dd373/protocols/clock/clock_exe.c	The function is called by the test engine before sending the clock rate set command and testing the received values.	3	"void arm_scmi_custom_tester_clock_config_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t clock_id;
  struct clock_device *clock;

  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_clock_config_set, clock_id)) {
    test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
    test_case->parameter_count = 2;

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_clock_config_set, clock_id)] =
        clock_protocol_data.num_clocks;

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_config_set,
                                       attributes)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (clock_id = 0; clock_id < clock_protocol_data.num_clocks; ++clock_id) {
      clock = &clock_protocol_data.clocks[clock_id];
      snprintf(description, NUM_ELEMS(description), ""\n\t\tCLOCK ID %d"",
               clock_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_config_set,
                                         clock_id)] = clock_id;

      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);

      if (received.status == SCMI_STATUS_SUCCESS) {
        clock->enabled = arm_scmi_get_norm_bits(
            test_case->parameters[OFFSET_PARAM(struct arm_scmi_clock_config_set,
                                               attributes)],
            CLK_CONFIGSET_ATTR_ENABLED, CLK_CONFIGSET_ATTR_ENABLED);
        clock->enabled_set = true;
      }
    }
  }
}"
ARM-software-scmi-tests-24dd373/protocols/performance/performance_exe.c	The function is called by the test engine before sending the performance limits get command and testing the received values.	2	"void arm_scmi_custom_test_performance_limits_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t rcv_u;
  struct performance_protocol_data *ptr_data = &performance_protocol_data;
  int check_or_print;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 1;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_performance_limits_get, domain_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_get,
                                       domain_id)] =
        ptr_data->num_performance_domains + 1;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    if ((test_case->precondition_indicator == PRECOND_USE) &&
        ((protocol_execution_context->precondition_data.result != CONFORMANT) ||
         (protocol_execution_context->precondition_data.status !=
          SCMI_STATUS_SUCCESS))) {
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, SKIP,
                               ""PRECONDITION STATUS"",
                               ""PRECONDITION NON-CONFORMANT"");
      return;
    }

    check_or_print =
        (test_case->precondition_indicator == PRECOND_USE) ? CHECK : PRINT;

    for (domain_id = 0; domain_id < ptr_data->num_performance_domains;
         ++domain_id) {
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_performance_limits_get,
                                         domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tDOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        continue;

      rcv_u = RETURN_VAL(received, struct arm_scmi_performance_limits_get,
                         range_max);
      arm_scmi_check_and_report_dec(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          ptr_data->domain_runtime_values[domain_id].range_max, rcv_u,
          ""RANGE MAX"");

      rcv_u = RETURN_VAL(received, struct arm_scmi_performance_limits_get,
                         range_min);
      arm_scmi_check_and_report_dec(
          &protocol_execution_context->test_stats, ALL_BITS_SET, check_or_print,
          ptr_data->domain_runtime_values[domain_id].range_min, rcv_u,
          ""RANGE MIN"");
    }
  }
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/solve.c	This routine guarantees that the density and pressure are everywhere positive within the volume using a transformation to the Bezier basis (whose basis functions are positive everywhere) and then applying a scaling to the Bezier basis coefficients.	2	"void enforce_positivity_highorder(struct Solver_Volume *s_vol,
                                  const struct Simulation *sim) {
  if (!test_case_requires_positivity((struct Test_Case *)sim->test_case_rc->tc))
    return;

  struct Multiarray_d *s_coef_b = constructor_s_coef_bezier(s_vol, sim);

  convert_variables(s_coef_b, 'c', 'p');

  const ptrdiff_t n_n = s_coef_b->extents[0], n_vr = s_coef_b->extents[1];

  for (int vr = 0; vr < n_vr; vr += (int)n_vr - 1) {
    double *vr_data = &s_coef_b->data[vr * n_n];

    double vr_avg = average_d(vr_data, n_n);
    if (vr_avg < EPS_PHYS) {
      print_Multiarray_d(s_coef_b);
      EXIT_ERROR(""Average %s approaching 0.0.\n"",
                 (vr == 0 ? ""density"" : ""pressure""));
    }

    const double vr_min = minimum_d(vr_data, n_n);
    if (vr_min < EPS_PHYS) {
      const double p_ho =
          GSL_MAX(0.0, GSL_MIN(1.0, (vr_avg - EPS_PHYS) / (vr_avg - vr_min)));
      correct_coef(s_coef_b, p_ho);
    }
  }
  convert_variables(s_coef_b, 'p', 'c');

  const char op_format = 'd';

  const struct Volume *vol = (struct Volume *)s_vol;
  const struct Solver_Element *s_e = (struct Solver_Element *)vol->element;

  const int p = s_vol->p_ref;
  struct Multiarray_d *s_coef = s_vol->sol_coef;

  const struct Operator *ccBS0_vs_vs =
      get_Multiarray_Operator(s_e->ccBS0_vs_vs, (ptrdiff_t[]){0, 0, p, p});
  mm_NN1C_Operator_Multiarray_d(ccBS0_vs_vs,
                                (struct const_Multiarray_d *)s_coef_b, s_coef,
                                op_format, s_coef_b->order, NULL, NULL);

  destructor_Multiarray_d(s_coef_b);
}"
dm-vdo-kvdo-8df6805/vdo/base/hashZone.c	Get the statistics for this hash zone.	2	"HashLockStatistics getHashZoneStatistics(const HashZone *zone) {
  const AtomicHashLockStatistics *atoms = &zone->statistics;
  return (HashLockStatistics){
      .dedupeAdviceValid = relaxedLoad64(&atoms->dedupeAdviceValid),
      .dedupeAdviceStale = relaxedLoad64(&atoms->dedupeAdviceStale),
      .concurrentDataMatches = relaxedLoad64(&atoms->concurrentDataMatches),
      .concurrentHashCollisions =
          relaxedLoad64(&atoms->concurrentHashCollisions),
  };
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  unsigned frames = 0;
  unsigned size = 0;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (avpriv_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  avio_skip(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1]);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
    v = avio_rb32(s->pb);
    if (v & 0x1)
      frames = avio_rb32(s->pb);
    if (v & 0x2)
      size = avio_rb32(s->pb);
  }

  avio_seek(s->pb, base + 4 + 32, SEEK_SET);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (avio_rb16(s->pb) == 1) {

      avio_skip(s->pb, 4);
      size = avio_rb32(s->pb);
      frames = avio_rb32(s->pb);
    }
  }

  if (!frames && !size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  spf = c.lsf ? 576 : 1152;
  if (frames)
    st->duration =
        av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
  if (size && frames)
    st->codec->bit_rate =
        av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);

  return 0;
}"
dm-vdo-kvdo-8df6805/vdo/base/vdo.c	Get the current error statistics from VDO.	2	"static ErrorStatistics getVDOErrorStatistics(const VDO *vdo) {

  const AtomicErrorStatistics *atoms = &vdo->errorStats;
  return (ErrorStatistics){
      .invalidAdvicePBNCount = relaxedLoad64(&atoms->invalidAdvicePBNCount),
      .noSpaceErrorCount = relaxedLoad64(&atoms->noSpaceErrorCount),
      .readOnlyErrorCount = relaxedLoad64(&atoms->readOnlyErrorCount),
  };
}"
Benoit37000-proxmark3-iceman-91c7a7c/client/cmdhf15.c	Commandline handling: HF15 CMD READMULTI Read multiple blocks at once (not all tags support this)	2	"int CmdHF15CmdReadmulti(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum, pagecount;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[2048] = """";

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(
        ""Usage:  hf 15 cmd readmulti  [options] <uid|s|u|*> <start#> <count#>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           start#:       page number to start 0-255"");
    PrintAndLog(""           count#:       number of pages"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15_CMD_READMULTI}, 1);
  reqlen = c.arg[0];

  pagenum = strtol(cmd, NULL, 0);

  while (*cmd != ' ' && *cmd != '\t')
    cmd++;

  while (*cmd == ' ' || *cmd == '\t')
    cmd++;

  pagecount = strtol(cmd, NULL, 0);
  if (pagecount > 0)
    pagecount--;

  req[reqlen++] = (uint8_t)pagenum;
  req[reqlen++] = (uint8_t)pagecount;

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15_RES_ERROR)) {
        *output = 0;
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%02X "", recv[i]);
        }
        strcat(output, ""   "");
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%c"",
                  recv[i] > 31 && recv[i] < 127 ? recv[i] : '.');
        }
        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[0], TagErrorStr(recv[0]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""no answer"");
  }

  return 0;
}"
smc-Indic-Keyboard-6dcefbb/native/jni/src/suggest/policyimpl/dictionary/utils/trie_map.h	Iterate next entry in a certain level.	2	"mIsValid = result.mIsValid;
mNextLevelBitmapEntryIndex = result.mNextLevelBitmapEntryIndex;
return *this;
}

private:
DISALLOW_DEFAULT_CONSTRUCTOR(TrieMapIterator);
DISALLOW_ASSIGNMENT_OPERATOR(TrieMapIterator);

const TrieMap *const mTrieMap;
std::vector<TrieMap::TableIterationState> mStateStack;
const int mBaseBitmapEntryIndex;
int mKey;
uint64_t mValue;
bool mIsValid;
int mNextLevelBitmapEntryIndex;
}
;

class TrieMapRange {
public:
  TrieMapRange(const TrieMap *const trieMap, const int bitmapEntryIndex)
      : mTrieMap(trieMap), mBaseBitmapEntryIndex(bitmapEntryIndex){};

  TrieMapIterator begin() const {
    return TrieMapIterator(mTrieMap, mBaseBitmapEntryIndex);
  }"
OPM-opm-common-d9c81da/opm/common/OpmLog/TimerLog.hpp	"This is the method subclasses should override. Typically a subclass may filter, change, and output messages based on configuration and the messageFlag."	2	"~TimerLog(){};

protected:
void addMessageUnconditionally(int64_t messageFlag,
                               const std::string &message) override;

private:
clock_t m_start;
std::ostringstream m_work;
}
;

typedef std::shared_ptr<TimerLog> TimerLogPtr;
typedef std::shared_ptr<const TimerLog> TimerLogConstPtr;
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/http2/casper.c	checks if a key is (was) marked as cached at the moment the fuction is invoked	2	"int h2o_http2_casper_lookup(h2o_http2_casper_t *casper, const char *path,
                            size_t path_len, int set) {
  unsigned key = calc_key(casper, path, path_len);
  size_t i;

  for (i = 0; i != casper->keys.size; ++i)
    if (key <= casper->keys.entries[i])
      break;
  if (i != casper->keys.size && key == casper->keys.entries[i])
    return 1;
  if (!set)
    return 0;

  free(casper->cookie_cache.base);
  casper->cookie_cache = (h2o_iovec_t){NULL};
  h2o_vector_reserve(NULL, &casper->keys, casper->keys.size + 1);
  memmove(casper->keys.entries + i + 1, casper->keys.entries + i,
          (casper->keys.size - i) * sizeof(casper->keys.entries[0]));
  ++casper->keys.size;
  casper->keys.entries[i] = key;
  return 0;
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	Try to read metadata on the sites in the input buffer.	2	"MPMarshalInfo *mpw_marshal_read_info(const char *in) {

  MPMarshalInfo *info = malloc(sizeof(MPMarshalInfo));
  *info = (MPMarshalInfo){.format = MPMarshalFormatNone};

  if (in && strlen(in)) {
    if (in[0] == '#') {
      *info = (MPMarshalInfo){.format = MPMarshalFormatFlat};
      mpw_marshal_read_flat_info(in, info);
    } else if (in[0] == '{') {
      *info = (MPMarshalInfo){.format = MPMarshalFormatJSON};
#if MPW_JSON
      mpw_marshal_read_json_info(in, info);
#endif
    }
  }

  return info;
}"
sblanas-pythia-b138eaa/operators/operators.h	"Initializes operator. Called once. Tree structure (eg. nextOp, buildOp, etc.) must have been initialized before this call."	2	"virtual GetNextResultT getNext(unsigned short threadid) = 0;

virtual ResultCode scanStop(unsigned short threadid) = 0;

virtual void threadClose(unsigned short threadid){};

virtual void destroy(){};

virtual void accept(Visitor *v) = 0;

virtual Schema &getOutSchema() { return schema; }"
tkn-tub-ns3-gym-371e85a/utils/print-introspected-doxygen.cc	Print direct Attributes for this TypeId. Only attributes defined directly by this TypeId will be printed.	2	"PrintAttributesTid(std::ostream &os, const TypeId tid) {
  NS_LOG_FUNCTION(tid);
  os << listStart << std::endl;
  for (uint32_t j = 0; j < tid.GetAttributeN(); j++) {
    struct TypeId::AttributeInformation info = tid.GetAttribute(j);
    os << listLineStart << boldStart << info.name << boldStop << "": ""
       << info.help << std::endl;
    os << ""  "" << listStart << std::endl;
    os << ""    "" << listLineStart << ""Set with class: "" << reference
       << info.checker->GetValueTypeName() << listLineStop << std::endl;
    if (info.checker->HasUnderlyingTypeInformation()) {
      os << ""    "" << listLineStart << ""Underlying type: "";

      std::string valType = info.checker->GetValueTypeName();
      std::string underType = info.checker->GetUnderlyingTypeInformation();
      if ((valType != ""ns3::EnumValue"") && (underType != ""std::string"")) {

        bool handled = false;

        if (valType == ""ns3::PointerValue"") {
          const PointerChecker *ptrChecker =
              dynamic_cast<const PointerChecker *>(PeekPointer(info.checker));
          if (ptrChecker != 0) {
            os << reference << ""ns3::Ptr""
               << ""< "" << reference << ptrChecker->GetPointeeTypeId().GetName()
               << "">"";
            handled = true;
          }
        } else if (valType == ""ns3::ObjectPtrContainerValue"") {
          const ObjectPtrContainerChecker *ptrChecker =
              dynamic_cast<const ObjectPtrContainerChecker *>(
                  PeekPointer(info.checker));
          if (ptrChecker != 0) {
            os << reference << ""ns3::Ptr""
               << ""< "" << reference << ptrChecker->GetItemTypeId().GetName()
               << "">"";
            handled = true;
          }
        }

        class StringBeginMatcher {
        public:
          StringBeginMatcher(const std::string s) : m_string(s){};
          bool operator()(const std::string t) {
            std::size_t pos = m_string.find(t);
            return pos == 0;
          };

        private:
          std::string m_string;
        };
        StringBeginMatcher match(underType);

        if (match(""bool"") || match(""double"") || match(""int8_t"") ||
            match(""uint8_t"") || match(""int16_t"") || match(""uint16_t"") ||
            match(""int32_t"") || match(""uint32_t"") || match(""int64_t"") ||
            match(""uint64_t"")) {
          os << underType;
          handled = true;
        }
        if (!handled) {
          os << reference << underType;
        }
      }
      os << listLineStop << std::endl;
    }
    if (info.flags & TypeId::ATTR_CONSTRUCT && info.accessor->HasSetter()) {
      os << ""    "" << listLineStart << ""Initial value: ""
         << info.initialValue->SerializeToString(info.checker) << listLineStop
         << std::endl;
    }
    os << ""    "" << listLineStart << ""Flags: "";
    if (info.flags & TypeId::ATTR_CONSTRUCT && info.accessor->HasSetter()) {
      os << flagSpanStart << ""construct "" << flagSpanStop;
    }
    if (info.flags & TypeId::ATTR_SET && info.accessor->HasSetter()) {
      os << flagSpanStart << ""write "" << flagSpanStop;
    }
    if (info.flags & TypeId::ATTR_GET && info.accessor->HasGetter()) {
      os << flagSpanStart << ""read "" << flagSpanStop;
    }
    os << listLineStop << std::endl;
    os << ""  "" << listStop << "" "" << std::endl;
  }
  os << listStop << std::endl;
}"
nkolban-duktape-esp32-28b4fb1/main/module_os.c	Create a new socket. The is no input to this function.	2	"static duk_ret_t js_os_socket(duk_context *ctx) {
  LOGD("">> js_os_socket"");
  int sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sockfd < 0) {
    LOGE(""Error with socket: %d: %d - %s"", sockfd, errno, strerror(errno));
  } else {
    LOGD(""New socket fd=%d"", sockfd);
  }
  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));

  duk_push_object(ctx);
  duk_push_int(ctx, sockfd);
  duk_put_prop_string(ctx, -2, ""sockfd"");
  LOGD(""<< js_os_socket"");
  return 1;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/chatline.c	Handle chat messages when connection dialog open.	2	"static void add_to_chat_list(char *msg, size_t n_alloc) {
  utf8_str *pstr;
  struct widget *pBuf, *pWindow = pConnDlg->pEndWidgetList;

  fc_assert_ret(msg != NULL);
  fc_assert_ret(n_alloc != 0);

  pstr = create_utf8_str(msg, n_alloc, adj_font(12));

  if (convert_utf8_str_to_const_surface_width(pstr, pConnDlg->text_width -
                                                        adj_size(5))) {
    utf8_str *pstr2;
    int count = 0;
    char **utf8_texts = create_new_line_utf8strs(pstr->text);

    while (utf8_texts[count] != NULL) {
      pstr2 = create_utf8_str(utf8_texts[count], strlen(utf8_texts[count]) + 1,
                              adj_font(12));
      pstr2->bgcol = (SDL_Color){0, 0, 0, 0};
      pBuf = create_themelabel2(
          NULL, pWindow->dst, pstr2, pConnDlg->text_width, 0,
          (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));

      pBuf->size.w = pConnDlg->text_width;
      add_widget_to_vertical_scroll_widget_list(
          pConnDlg->pChat_Dlg, pBuf,
          pConnDlg->pChat_Dlg->pBeginActiveWidgetList, FALSE,
          pWindow->size.x + adj_size(10 + 60 + 10),
          pWindow->size.y + adj_size(14));
      count++;
    }
    redraw_group(pConnDlg->pChat_Dlg->pBeginWidgetList,
                 pConnDlg->pChat_Dlg->pEndWidgetList, TRUE);
    FREEUTF8STR(pstr);
  } else {
    pstr->bgcol = (SDL_Color){0, 0, 0, 0};
    pBuf = create_themelabel2(
        NULL, pWindow->dst, pstr, pConnDlg->text_width, 0,
        (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));

    pBuf->size.w = pConnDlg->text_width;

    if (add_widget_to_vertical_scroll_widget_list(
            pConnDlg->pChat_Dlg, pBuf,
            pConnDlg->pChat_Dlg->pBeginActiveWidgetList, FALSE,
            pWindow->size.x + adj_size(10 + 60 + 10),
            pWindow->size.y + adj_size(14))) {
      redraw_group(pConnDlg->pChat_Dlg->pBeginWidgetList,
                   pConnDlg->pChat_Dlg->pEndWidgetList, TRUE);
    } else {
      widget_redraw(pBuf);
      widget_mark_dirty(pBuf);
    }
  }

  flush_dirty();
}"
Shark-ML-Shark-7a182c7/include/shark/Algorithms/DirectSearch/Operators/Selection/EPTournamentSelection.h	"Returns a sorted range of pairs indicating, how often every individual won. The best individuals are in the front of the range."	2	"std::vector<KeyValuePair<int, InIterator>>
performTournament(rng_type &rng, InIterator it, InIterator itE) {
  std::size_t size = std::distance(it, itE);
  UIntVector selectionProbability(size, 0.0);
  std::vector<KeyValuePair<int, InIterator>> individualPerformance(size);
  Ordering smaller;
  for (std::size_t i = 0; i != size(); ++i) {
    individualPerformance[i].value = it + i;
    for (std::size_t round = 0; round < tournamentSize; round++) {
      std::size_t idx = random::discrete(rng, 0, size - 1);
                                if(smaller(*it, *(it+idx)){
        individualPerformance[i].key -= 1;
				}
    }
  }

  std::sort(individualPerformance.begin(), individualPerformance.end());
  return individualPerformance;
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavcodec/audio_frame_queue.c	Add a frame to the queue.	2	"int ff_af_queue_add(AudioFrameQueue *afq, const AVFrame *f) {
  AudioFrame *new_frame;
  AudioFrame *queue_end = afq->frame_queue;

  while (queue_end && queue_end->next)
    queue_end = queue_end->next;

  if (!(new_frame = av_malloc(sizeof(*new_frame))))
    return AVERROR(ENOMEM);

  new_frame->next = NULL;
  new_frame->duration = f->nb_samples;
  if (f->pts != AV_NOPTS_VALUE) {
    new_frame->pts = av_rescale_q(f->pts, afq->avctx->time_base,
                                  (AVRational){1, afq->avctx->sample_rate});
    afq->next_pts = new_frame->pts + new_frame->duration;
  } else {
    new_frame->pts = AV_NOPTS_VALUE;
    afq->next_pts = AV_NOPTS_VALUE;
  }

  if (!queue_end)
    afq->frame_queue = new_frame;
  else
    queue_end->next = new_frame;

  afq->remaining_samples += f->nb_samples;

#ifdef DEBUG
  af_queue_log_state(afq);
#endif

  return 0;
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	Unmarshall sites in the given input buffer by parsing it using the given marshalling format.	2	"MPMarshalledUser *mpw_marshal_read(const char *in,
                                   const MPMarshalFormat inFormat,
                                   const char *masterPassword,
                                   MPMarshalError *error) {

  switch (inFormat) {
  case MPMarshalFormatNone:
    *error = (MPMarshalError){.type = MPMarshalSuccess};
    return false;
  case MPMarshalFormatFlat:
    return mpw_marshal_read_flat(in, masterPassword, error);
#if MPW_JSON
  case MPMarshalFormatJSON:
    return mpw_marshal_read_json(in, masterPassword, error);
#endif
  default:
    *error =
        (MPMarshalError){MPMarshalErrorFormat,
                         mpw_str(""Unsupported input format: %u"", inFormat)};
    return NULL;
  }
}"
darktable-org-darktable-32fab21/src/iop/rawprepare.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_gui_presets_add_generic(
      _(""passthrough""), self->op, self->version(),
      &(dt_iop_rawprepare_params_t){.crop.array = {0, 0, 0, 0},
                                    .raw_black_level_separate[0] = 0,
                                    .raw_black_level_separate[1] = 0,
                                    .raw_black_level_separate[2] = 0,
                                    .raw_black_level_separate[3] = 0,
                                    .raw_white_point = UINT16_MAX},
      sizeof(dt_iop_rawprepare_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
fohr-castle-36a70e1/kernel/castle_da.c	Read an existing component tree from disk.	2	"static struct castle_component_tree *
castle_da_ct_unmarshall(struct castle_clist_entry *ctm) {
  int i;
  struct castle_double_array *da = castle_da_hash_get(ctm->da_id);
  struct castle_component_tree *ct;

  castle_printk(LOG_DEBUG, ""%s::seq %d\n"", __FUNCTION__, ctm->seq);

  ct = castle_ct_init(da, ctm->nr_data_exts);
  if (!ct)
    return NULL;

  ct->seq = ctm->seq;
  ct->data_age = ctm->data_age;
  atomic64_set(&ct->item_count, ctm->item_count);
  atomic64_set(&ct->nr_bytes, ctm->nr_bytes);
  ct->nr_drained_bytes = ctm->nr_drained_bytes;
  ct->chkpt_nr_bytes = ctm->nr_bytes;
  ct->chkpt_nr_drained_bytes = ctm->nr_drained_bytes;
  ct->btree_type = ctm->btree_type;
  ct->flags = ctm->flags;
  ct->da = da;
  BUG_ON(!ct->da && !TREE_GLOBAL(ct->seq));
  ct->level = ctm->level;
  ct->nr_rwcts = ctm->nr_rwcts;
  atomic_set(&ct->tree_depth, ctm->tree_depth);
  ct->root_node = ctm->root_node;
  atomic64_set(&ct->large_ext_chk_cnt, ctm->large_ext_chk_cnt);
  for (i = 0; i < MAX_BTREE_DEPTH; i++)
    ct->node_sizes[i] = ctm->node_sizes[i];
  ct->max_versions_per_key = ctm->max_versions_per_key;

  castle_ext_freespace_unmarshall(&ct->internal_ext_free,
                                  &ctm->internal_ext_free_bs);
  castle_ext_freespace_unmarshall(&ct->tree_ext_free, &ctm->tree_ext_free_bs);
  castle_ext_freespace_unmarshall(&ct->data_ext_free, &ctm->data_ext_free_bs);
  castle_extent_mark_live(ct->internal_ext_free.ext_id, ctm->da_id);
  castle_extent_mark_live(ct->tree_ext_free.ext_id, ctm->da_id);
  castle_extent_mark_live(ct->data_ext_free.ext_id, ctm->da_id);
  if (CT_BLOOM_EXISTS(ct))
    castle_bloom_unmarshall(&ct->bloom, ctm);

  if (ct->level == 0) {

    uint64_t nr_bytes = atomic64_read(&ct->tree_ext_free.used);
    int chunks = (nr_bytes) ? (CHUNK(nr_bytes - 1) + 1) : 0;

    castle_cache_advise((c_ext_pos_t){ct->tree_ext_free.ext_id, 0},
                        C2_ADV_PREFETCH, USER, chunks);
  }

  atomic64_set(&ct->max_user_timestamp, ctm->max_user_timestamp);
  atomic64_set(&ct->min_user_timestamp, ctm->min_user_timestamp);

  castle_ct_hash_add(ct);

  return ct;
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/bytestrings.c	Creates a new definite byte string	2	"cbor_item_t *cbor_new_definite_bytestring() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_BYTESTRING,
      .metadata = {.bytestring_metadata = {_CBOR_METADATA_DEFINITE, 0}}};
  return item;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/HighLevel/ConfigDescriptor.c	"Retrieves the configuration descriptor data from an attached device via a standard request into a buffer, including validity and size checking to prevent a buffer overflow."	0	"uint8_t USB_Host_GetDeviceConfigDescriptor(uint8_t ConfigNumber,
                                           uint16_t *const ConfigSizePtr,
                                           void *BufferPtr,
                                           uint16_t BufferSize) {
  uint8_t ErrorCode;
  uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetDescriptor,
      .wValue = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
      .wIndex = 0,
      .wLength = sizeof(USB_Descriptor_Configuration_Header_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  *ConfigSizePtr =
      DESCRIPTOR_CAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)
          .TotalConfigurationSize;

  if (*ConfigSizePtr > BufferSize)
    return HOST_GETCONFIG_BuffOverflow;

  USB_ControlRequest.wLength = *ConfigSizePtr;

  if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    return HOST_GETCONFIG_InvalidData;

  return HOST_GETCONFIG_Successful;
}"
lexborisov-Modest-4b279a3/source/myhtml/myhtml.c	Get raw position for Attribute Key in Incoming Buffer	2	"myhtml_position_t myhtml_attribute_key_raw_position(myhtml_tree_attr_t *attr) {
  if (attr)
    return (myhtml_position_t){attr->raw_key_begin, attr->raw_key_length};

  return (myhtml_position_t){0, 0};
}"
Proxmark-proxmark3-fdd9395/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd[],
                   int iso15cmdlen) {
  int temp;
  uint8_t *req = c->d.asBytes;
  uint8_t uid[8] = {0x00};
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15693_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLog(""missing addr"");
    return 0;
    break;
  case 's':
  case 'S':

    req[reqlen++] |= ISO15693_REQ_DATARATE_HIGH | ISO15693_REQ_SELECT;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15693_REQ_DATARATE_HIGH;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case '*':

    req[reqlen++] |= ISO15693_REQ_DATARATE_HIGH | ISO15693_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    if (!getUID(uid)) {
      PrintAndLog(""No Tag found"");
      return 0;
    }
    memcpy(req + reqlen, uid, 8);
    PrintAndLog(""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += 8;
    break;
  default:
    req[reqlen++] |= ISO15693_REQ_DATARATE_HIGH | ISO15693_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLog(""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], &uid[0], 8);
    reqlen += 8;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"
dm-vdo-kvdo-8df6805/vdo/base/volumeGeometry.c	Initialize a VolumeGeometry for a VDO.	2	"int initializeVolumeGeometry(Nonce nonce, UUID uuid, IndexConfig *indexConfig,
                             VolumeGeometry *geometry) {
  BlockCount indexSize = 0;
  if (indexConfig != NULL) {
    int result = computeIndexBlocks(indexConfig, &indexSize);
    if (result != VDO_SUCCESS) {
      return result;
    }
  }

  *geometry = (VolumeGeometry){.releaseVersion = CURRENT_RELEASE_VERSION_NUMBER,
                               .nonce = nonce,
                               .regions = {[INDEX_REGION] =
                                               {
                                                   .id = INDEX_REGION,
                                                   .startBlock = 1,
                                               },
                                           [DATA_REGION] = {
                                               .id = DATA_REGION,
                                               .startBlock = 1 + indexSize,
                                           }}};
  memcpy(geometry->uuid, uuid, sizeof(UUID));
  if (indexSize > 0) {
    memcpy(&geometry->indexConfig, indexConfig, sizeof(IndexConfig));
  }

  return VDO_SUCCESS;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Prevent/Allow Medium Removal command to the attached device, to lock the physical media from being removed. This is a legacy command for SCSI disks with removable storage (such as ZIP disks), but should still be issued before the first read or write command is sent."	1	"uint8_t MassStore_PreventAllowMediumRemoval(const uint8_t LUNIndex,
                                            const bool PreventRemoval) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = 0,
                 .Flags = COMMAND_DIRECTION_DATA_OUT,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 6},

      .SCSICommandData = {SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL, 0x00, 0x00,
                          PreventRemoval, 0x00, 0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_GetReturnedStatus())) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
cisco-system-traffic-generator-trex-core-d48fc67/src/dpdk/drivers/net/mlx5/mlx5_rxtx_vec_neon.h	"Send burst of packets with Enhanced MPW. If it encounters a multi-seg packet, it returns to make it processed by txq_scatter_v(). All the packets in the pkts list should be single segment packets having same offload flags. This must be checked by txq_count_contig_single_seg() and txq_calc_offload()."	2	"txq_burst_v(struct mlx5_txq_data *txq, struct rte_mbuf **pkts, uint16_t pkts_n,
            uint8_t cs_flags) {
  struct rte_mbuf **elts;
  uint16_t elts_head = txq->elts_head;
  const uint16_t elts_n = 1 << txq->elts_n;
  const uint16_t elts_m = elts_n - 1;
  const unsigned int nb_dword_per_wqebb = MLX5_WQE_SIZE / MLX5_WQE_DWORD_SIZE;
  const unsigned int nb_dword_in_hdr =
      sizeof(struct mlx5_wqe) / MLX5_WQE_DWORD_SIZE;
  unsigned int n = 0;
  unsigned int pos;
  uint16_t max_elts;
  uint16_t max_wqe;
  uint32_t comp_req = 0;
  const uint16_t wq_n = 1 << txq->wqe_n;
  const uint16_t wq_mask = wq_n - 1;
  uint16_t wq_idx = txq->wqe_ci & wq_mask;
  volatile struct mlx5_wqe64 *wq =
      &((volatile struct mlx5_wqe64 *)txq->wqes)[wq_idx];
  volatile struct mlx5_wqe *wqe = (volatile struct mlx5_wqe *)wq;
  const uint8x16_t ctrl_shuf_m = {3,  2,  1, 0, 7,  6,  5,  4,
                                  11, 10, 9, 8, 12, 13, 14, 15};
  uint8x16_t *t_wqe;
  uint8_t *dseg;
  uint8x16_t ctrl;

  assert(elts_n > pkts_n);
  mlx5_tx_complete(txq);
  max_elts = (elts_n - (elts_head - txq->elts_tail));
  max_wqe = (1u << txq->wqe_n) - (txq->wqe_ci - txq->wqe_pi);
  pkts_n = RTE_MIN((unsigned int)RTE_MIN(pkts_n, max_wqe), max_elts);
  if (unlikely(!pkts_n))
    return 0;
  elts = &(*txq->elts)[elts_head & elts_m];

  n = RTE_MIN(elts_n - (elts_head & elts_m), pkts_n);
  for (pos = 0; pos < (n & -2); pos += 2)
    vst1q_u64((void *)&elts[pos], vld1q_u64((void *)&pkts[pos]));
  if (n & 1)
    elts[pos] = pkts[pos];

  if (unlikely(n < pkts_n)) {
    elts = &(*txq->elts)[0];
    for (pos = 0; pos < pkts_n - n; ++pos)
      elts[pos] = pkts[n + pos];
  }
  txq->elts_head += pkts_n;

  t_wqe = (uint8x16_t *)wqe;
  dseg = (uint8_t *)(wqe + 1);

  n = RTE_MIN((wq_n - wq_idx) * nb_dword_per_wqebb - nb_dword_in_hdr, pkts_n);

  txq_wr_dseg_v(txq, dseg, pkts, n);

  if (n < pkts_n) {
    dseg = (uint8_t *)txq->wqes;
    txq_wr_dseg_v(txq, dseg, &pkts[n], pkts_n - n);
  }
  if (txq->elts_comp + pkts_n < MLX5_TX_COMP_THRESH) {
    txq->elts_comp += pkts_n;
  } else {

    assert((1u << txq->cqe_n) - (txq->cq_pi++ - txq->cq_ci));

    txq->elts_comp = 0;
    comp_req = 8;
  }

  ctrl = vreinterpretq_u8_u32(
      (uint32x4_t){MLX5_OPC_MOD_ENHANCED_MPSW << 24 | txq->wqe_ci << 8 |
                       MLX5_OPCODE_ENHANCED_MPSW,
                   txq->qp_num_8s | (pkts_n + 2), comp_req, txq->elts_head});
  ctrl = vqtbl1q_u8(ctrl, ctrl_shuf_m);
  vst1q_u8((void *)t_wqe, ctrl);

  vst1q_u8((void *)(t_wqe + 1), ((uint8x16_t){0, 0, 0, 0, cs_flags, 0, 0, 0, 0,
                                              0, 0, 0, 0, 0, 0, 0}));
#ifdef MLX5_PMD_SOFT_COUNTERS
  txq->stats.opackets += pkts_n;
#endif
  txq->wqe_ci += (nb_dword_in_hdr + pkts_n + (nb_dword_per_wqebb - 1)) /
                 nb_dword_per_wqebb;

  mlx5_tx_dbrec_cond_wmb(txq, wqe, pkts_n < MLX5_VPMD_TX_MAX_BURST);
  return pkts_n;
}"
getopenmono-mono_framework-899a582/src/display/ui/progress_bar_view.h	define a new maximum value for the progress indicator	2	"* @endcode
     *
     * Even if the loop ran veeery slow, you will not see a moving progress 
     * indicator. The reason is that the view is only painted in the run-loop,
     * so no screen updates can happen from inside the for-loop!
     *
     * You should use a continous timer, with a callback that increments the
     * progress indicator:
     * 
     * @code
     * void updateProgress(){
       *prgs.setValue(i++);
       *
     }"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	"Moves the 64-bit operand to a 128-bit integer vector, zeroing the upper bits."	2	"_mm_movpi64_epi64(__m64 __a) {
  return __extension__(__m128i)(__v2di){(long long)__a, 0};
}"
osresearch-papercraft-26307b8/tri.c	"Compute the points of intersection for two segments in 2d, and z points. This is a specialized ray intersection algorithm for the hidden wire-frame removal code that computes the intersection points for two rays (in 2D, ""orthographic"") and then computes the Z depth for the intersections along each of the segments. Returns -1 for non-intersecting, otherwise a ratio of how far along the intersection is on the l0."	2	"hidden_intersect(const v3_t *const p0, const v3_t *const p1,
                 const v3_t *const p2, const v3_t *const p3, v3_t *const l0_int,
                 v3_t *const l1_int) {
  const float p0_x = p0->p[0];
  const float p0_y = p0->p[1];
  const float p0_z = p0->p[2];

  const float p1_x = p1->p[0];
  const float p1_y = p1->p[1];
  const float p1_z = p1->p[2];

  const float p2_x = p2->p[0];
  const float p2_y = p2->p[1];
  const float p2_z = p2->p[2];

  const float p3_x = p3->p[0];
  const float p3_y = p3->p[1];
  const float p3_z = p3->p[2];

  const float s1_x = p1_x - p0_x;
  const float s1_y = p1_y - p0_y;

  const float s2_x = p3_x - p2_x;
  const float s2_y = p3_y - p2_y;

  const float d = -s2_x * s1_y + s1_x * s2_y;

  if (-EPS < d && d < EPS)
    return -1;

  const float r0 = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / d;
  const float r1 = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / d;

  if (r0 < 0 || r0 > 1)
    return -1;
  if (r1 < 0 || r1 > 1)
    return -1;

  if (0)
    fprintf(stderr,
            ""collision: %.0f,%.0f,%.0f->%.0f,%.0f,%.0f ""
            ""%.0f,%.0f,%.0f->%.0f,%.0f,%.0f == %.3f,%.3f\n"",
            p0_x, p0_y, p0_z, p1_x, p1_y, p1_z, p2_x, p2_y, p2_z, p3_x, p3_y,
            p2_z, r0, r1);

  if (l0_int) {
    *l0_int =
        (v3_t){{p0_x + r0 * s1_x, p0_y + r0 * s1_y, p0_z + r0 * (p1_z - p0_z)}};
  }

  if (l1_int) {
    *l1_int =
        (v3_t){{p2_x + r1 * s2_x, p2_y + r1 * s2_y, p2_z + r1 * (p3_z - p2_z)}};
  }

  return r0;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	Writes blocks of data to the attached Mass Storage device's medium.	1	"uint8_t
MS_Host_WriteDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          const uint8_t LUNIndex, const uint32_t BlockAddress,
                          const uint8_t Blocks, const uint16_t BlockSize,
                          const void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
seemk-TileSweep-627999b/tilesweep/third_party/h2o/lib/common/multithread.c	registers a receiver for specific type of message	2	"void h2o_multithread_register_receiver(h2o_multithread_queue_t *queue,
                                       h2o_multithread_receiver_t *receiver,
                                       h2o_multithread_receiver_cb cb) {
  receiver->queue = queue;
  receiver->_link = (h2o_linklist_t){NULL};
  h2o_linklist_init_anchor(&receiver->_messages);
  receiver->cb = cb;

  pthread_mutex_lock(&queue->mutex);
  h2o_linklist_insert(&queue->receivers.inactive, &receiver->_link);
  pthread_mutex_unlock(&queue->mutex);
}"
fohr-castle-36a70e1/kernel/castle_da.c	Performs specified amount of merge work. Pins T0s in memory if level 1 merge is being performed.	2	"static int castle_da_merge_unit_do(struct castle_da_merge *merge,
                                   uint64_t max_nr_bytes, int hardpin) {
  int i, ret;

  if (hardpin) {

    for (i = 0; i < merge->nr_trees; i++)
      castle_cache_advise(
          (c_ext_pos_t){merge->in_trees[i]->data_ext_free.ext_id, 0},
          C2_ADV_EXTENT | C2_ADV_HARDPIN, MERGE_IN, 0);
  }

  ret = merge->tv_resolver
            ? castle_da_merge_unit_with_resolver_do(merge, max_nr_bytes)
            : castle_da_merge_unit_without_resolver_do(merge, max_nr_bytes);

  if (hardpin) {

    for (i = 0; i < merge->nr_trees; i++)
      castle_cache_advise_clear(
          (c_ext_pos_t){merge->in_trees[i]->data_ext_free.ext_id, 0},
          C2_ADV_EXTENT | C2_ADV_HARDPIN, 0);
  }

  return ret;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/AudioOutputHost/AudioOutputHost.c	Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully enumerated by the host and is now ready to be used by the application.	0	"void EVENT_USB_Host_DeviceEnumerationComplete(void) {
  puts_P(PSTR(""Getting Config Data.\r\n""));

  uint8_t ErrorCode;

  if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead) {
    if (ErrorCode == ControlError)
      puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
    else
      puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

    printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    return;
  }

  if ((ErrorCode = USB_Host_SetInterfaceAltSetting(
           StreamingInterfaceIndex, StreamingInterfaceAltSetting)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED
                  ""Could not set alternative streaming interface setting.\r\n""
                  "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_ENDPOINT),
      .bRequest = AUDIO_REQ_SetCurrent,
      .wValue = (AUDIO_EPCONTROL_SamplingFreq << 8),
      .wIndex = StreamingEndpointAddress,
      .wLength = sizeof(USB_Audio_SampleFreq_t),
  };

  USB_Audio_SampleFreq_t SampleRate = AUDIO_SAMPLE_FREQ(48000);

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&SampleRate)) !=
      HOST_SENDCONTROL_Successful) {
    printf_P(PSTR(ESC_FG_RED ""Could not set requested Audio sample rate.\r\n""
                             "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
             ErrorCode);

    LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    USB_Host_SetDeviceConfiguration(0);
    return;
  }

  TIMSK0 = (1 << OCIE0A);
  OCR0A = ((F_CPU / 8 / 48000) - 1);
  TCCR0A = (1 << WGM01);
  TCCR0B = (1 << CS01);

  puts_P(PSTR(""Speaker Enumerated.\r\n""));
  LEDs_SetAllLEDs(LEDMASK_USB_READY);
}"
saxbophone-libsxbp-ee49ca0/sxbp/initialise.c	"This is a convenience function, as the struct has many fields. This function will create a spiral struct with all of these fields initialised to 0 or their default 'blank' state. No memory is allocated."	4	"sxbp_spiral_t sxbp_blank_spiral(void) {
  return (sxbp_spiral_t){
      0, NULL, {{NULL, 0}, 0}, false, 0, 0, 0, 0, 0, 0,
  };
}"
ging-isabel-1ec0172/lib/ffmpeg/Win32/src/ffmpeg/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  unsigned frames = 0;
  unsigned size = 0;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (ff_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  avio_seek(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1], SEEK_CUR);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
    v = avio_rb32(s->pb);
    if (v & 0x1)
      frames = avio_rb32(s->pb);
    if (v & 0x2)
      size = avio_rb32(s->pb);
  }

  avio_seek(s->pb, base + 4 + 32, SEEK_SET);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (avio_rb16(s->pb) == 1) {

      avio_seek(s->pb, 4, SEEK_CUR);
      frames = avio_rb32(s->pb);
      size = avio_rb32(s->pb);
    }
  }

  if (!frames && !size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  spf = c.lsf ? 576 : 1152;
  if (frames)
#if __STDC_VERSION >= 1999001L
    st->duration =
        av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
#else
  {
    AVRational bq = {spf, c.sample_rate};

    st->duration = av_rescale_q(frames, bq, st->time_base);
  }
#endif
  if (size && frames)
    st->codec->bit_rate =
        av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);

  return 0;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Read command to the attached device, to read in one or more data blocks from the storage medium into a buffer."	0	"uint8_t MassStore_ReadDeviceBlock(const uint8_t LUNIndex,
                                  const uint32_t BlockAddress,
                                  const uint8_t Blocks,
                                  const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = ((uint32_t)Blocks * BlockSize),
                 .Flags = COMMAND_DIRECTION_DATA_IN,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 10},

      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_WaitForDataReceived()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_SendReceiveData(BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_GetReturnedStatus()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
AVSystem-Anjay-09239b2/src/servers/reload.c	"Schedules reconnection of all servers, and even downloader sockets. This is basically:"	2	"int anjay_schedule_reconnect(anjay_t *anjay) {
  int result = _anjay_schedule_reload_servers(anjay);
  if (result) {
    return result;
  }
  anjay->offline = false;
  AVS_LIST(anjay_server_info_t) server;
  AVS_LIST_FOREACH(server, anjay->servers->servers) {
    _anjay_connection_suspend((anjay_connection_ref_t){
        .server = server, .conn_type = ANJAY_CONNECTION_UNSET});
  }
  result = _anjay_servers_sched_reactivate_all_given_up(anjay);
#ifdef WITH_DOWNLOADER
  if (!result) {
    result = _anjay_downloader_sched_reconnect_all(&anjay->downloader);
  }
#endif
  return result;
}"
renesugar-FileConvert-1f304e1/ThirdParty/librdkafka/src-cpp/rdkafkacpp_int.h	"This is an asynch non-blocking API. NOTE: RK_MSG_FREE and RK_MSG_COPY are mutually exclusive. If the function returns -1 and RK_MSG_FREE was specified, then the memory associated with the payload is still the caller's responsibility."	4	"EventImpl(Type type)
    : type_(type), err_(ERR_NO_ERROR), severity_(EVENT_SEVERITY_EMERG),
      fac_(""""), str_(""""), id_(0), throttle_time_(0){};

Type type() const { return type_; }
ErrorCode err() const { return err_; }
Severity severity() const { return severity_; }
std::string fac() const { return fac_; }
std::string str() const { return str_; }
std::string broker_name() const {
  if (type_ == EVENT_THROTTLE)
    return str_;
  else
    return std::string("""");
}"
HiPhish-XeenTools-ee7c26c/Source/sprite/sprite_tool.c	Read a sprite from file.	2	"int xeen_read_sprite(FILE *fp, long fo, XeenSprite *sp, uint8_t transparent) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    NO_CELLS,
    ALLOC_FAIL,
    FREAD_FAIL,
  } error = SUCCESS;

  uint8_t word[2];

  uint16_t frames = 0;
  uint16_t cell_count = 0;
  uint16_t *cell_offsets = NULL;

  uint16_t(*frame_map)[2] = NULL;

  uint8_t *canvas = NULL, *brush = NULL;

  XeenFrame *cells = NULL;

  fseek(fp, fo, SEEK_SET);

  READ(word, sizeof(uint8_t), 2)
  frames = ((uint16_t)word[1] << 8) + ((uint16_t)word[0] << 0);

  ALLOC(cell_offsets, 2 * frames * sizeof(uint16_t))
  ALLOC(frame_map, frames * sizeof(*frame_map))

  READ(cell_offsets, sizeof(uint8_t), 4 * frames);
  FLIP_BYTES(cell_offsets, 2 * frames)

  for (int i = 0; i < frames; ++i) {
    for (int j = 0; j < 2; ++j) {

      if (cell_offsets[2 * i + j] == 0x000) {

        assert(j == 1);
        frame_map[i][j] = frame_map[i][j - 1];
        continue;
      }

      int known_cell = 0;
      for (int k = 0; k < 2 * i + j; ++k) {
        if (cell_offsets[k] == cell_offsets[2 * i + j]) {
          known_cell = 1;
          frame_map[i][j] = frame_map[k / 2][k % 2];
          break;
        }
      }
      if (known_cell) {
        continue;
      }

      frame_map[i][j] = cell_count++;
    }
  }

  if (cell_count == 0) {
    error = NO_CELLS;
    goto fail;
  }

  ALLOC(cells, cell_count * sizeof(XeenFrame))

  for (int i = 0; i < cell_count; ++i) {
    cells[i] = (XeenFrame){.width = 0, .height = 0, .pixels = NULL};
  }

  for (int i = 0; i < cell_count; ++i) {
#define OFFSET_X h[0]
#define WIDTH h[1]
#define OFFSET_Y h[2]
#define HEIGHT h[3]

    uint16_t offset = 0x0000;

    for (int j = 0; j < frames * 2; ++j) {
      if (frame_map[j / 2][j % 2] == i) {
        offset = cell_offsets[j];
        break;
      }
      assert(j != frames * 2 - 1);
    }
    assert(offset != 0x0000);

    fseek(fp, offset + fo, SEEK_SET);
    uint16_t h[4];
    READ(h, sizeof(uint8_t), 8)
    FLIP_BYTES(h, 4)

    cells[i].width = OFFSET_X + WIDTH;
    cells[i].height = OFFSET_Y + HEIGHT;
#undef WIDTH
#undef HEIGHT

#define SURFACE (cells[i].width * cells[i].height)

    ALLOC(canvas, SURFACE * sizeof(uint8_t))

    for (int j = 0; j < SURFACE; ++j) {
      canvas[j] = transparent;
    }
#undef SURFACE

    for (uint16_t pos_y = OFFSET_Y; pos_y < cells[i].height; ++pos_y) {

      uint16_t bytes = 0;
      uint8_t l[2];

      brush = canvas + cells[i].width * pos_y;

      READ(l, sizeof(uint8_t), 2)

      if (l[0] > 0) {
        ++bytes;

        brush += l[1];

        while (bytes < l[0]) {
          uint8_t opcode, command, length;

          READ(&opcode, sizeof(uint8_t), 1)
          ++bytes;

          command = (opcode & 0xE0) >> 5;
          length = (opcode & 0x1F) >> 0;

          switch (command) {
          case 0:
          case 1:

#define AMOUNT (opcode + 1)
            READ(brush, sizeof(uint8_t), AMOUNT)

            bytes += AMOUNT;
            brush += AMOUNT;
#undef AMOUNT
            break;
          case 2: {
            uint8_t op;
            READ(&op, sizeof(uint8_t), 1)
            ++bytes;
            for (int i = 0; i < length + 3; ++i) {
              *(brush++) = op;
            }
            break;
          }
          case 3: {
            uint16_t offset;
            READ(word, sizeof(uint8_t), 2)
            bytes += 2;
            offset = (word[1] << 8) + (word[0] << 0);

            fseek(fp, -(long)offset, SEEK_CUR);

#define AMOUNT (length + 4)
            READ(brush, sizeof(uint8_t), AMOUNT)
            brush += AMOUNT;

            fseek(fp, (long)offset - AMOUNT, SEEK_CUR);
#undef AMOUNT
            break;
          }
          case 4: {
            READ(word, sizeof(uint8_t), 2)
            bytes += 2;
            for (int i = 0; i < length + 2; ++i) {
              *(brush++) = word[0];
              *(brush++) = word[1];
            }
            break;
          }
          case 5:

            brush += length + 1;
            break;
          case 6:
          case 7: {
            const int patternSteps[] = {0, 1,  1,  1,  2,  2,  3,  3,
                                        0, -1, -1, -1, -2, -2, -3, -3};

            uint8_t key = (opcode >> 2) & 0x0E;
            uint8_t count = (opcode >> 0) & 0x07;
            uint8_t value;

            READ(&value, sizeof(uint8_t), 1)
            ++bytes;
            for (int i = 0; i < count + 3; ++i) {
              *(brush++) = value;
              value += patternSteps[key + (i % 2)];
            }
            break;
          }
          default:
            assert(0);
          }
        }
      } else {

        pos_y += l[1];
      }
    }
#undef OFFSET_X
#undef OFFSET_Y
    cells[i].pixels = canvas;
  }

  free(cell_offsets);
  cell_offsets = NULL;

  *sp = (XeenSprite){
      .frames = frames,
      .cells = cell_count,
      .map = frame_map,
      .cell = cells,
  };

  return error;

fail:
  if (cell_offsets) {
    free(cell_offsets);
  }
  if (frame_map) {
    free(frame_map);
  }
  if (cells) {
    for (int i = 0; i < cell_count; ++i) {
      if (cells[i].pixels) {
        free(cells[i].pixels);
      }
    }
    free(cells);
  }
  if (canvas) {
    free(canvas);
  }
  return error;
}"
AlloSphere-Research-Group-AlloSystem-e51da8e/allocore/examples/graphics/texture3d.cpp	Called upon creation of a window.	2	"void onCreate(const ViewpointWindow &w) {

  data.fill(arrayfiller);

  tex.submit(data, true);

  shader.compile(
      R""(
			varying vec3 texcoord0;
			void main(){
				texcoord0 = vec3(gl_MultiTexCoord0);
				gl_Position = ftransform();
			}
			)"",
      R""(
			uniform sampler3D tex;
			varying vec3 texcoord0;
			void main() {
				vec4 color = texture3D(tex, texcoord0);
				gl_FragColor = color;
			}
			)"");
}"
ventanium-ventanium-e769f5e/src/vtm/sys/unix/net/socket_listener_kqueue.c	Interrupts the listener if he is blocked in waiting for events.	2	"int vtm_socket_listener_interrupt(vtm_socket_listener *li) {
  write(li->cfd[1], (char[]){1}, sizeof(char));
  return VTM_OK;
}"
darktable-org-darktable-32fab21/src/common/image.c	inits basic values to sensible defaults.	2	"void dt_image_init(dt_image_t *img) {
  img->width = img->height = 0;
  img->crop_x = img->crop_y = img->crop_width = img->crop_height = 0;
  img->orientation = ORIENTATION_NULL;
  img->legacy_flip.legacy = 0;
  img->legacy_flip.user_flip = 0;

  img->buf_dsc.filters = 0u;
  img->buf_dsc = (dt_iop_buffer_dsc_t){.channels = 0, .datatype = TYPE_UNKNOWN};
  img->film_id = -1;
  img->group_id = -1;
  img->flags = 0;
  img->id = -1;
  img->version = -1;
  img->loader = LOADER_UNKNOWN;
  img->exif_inited = 0;
  memset(img->exif_maker, 0, sizeof(img->exif_maker));
  memset(img->exif_model, 0, sizeof(img->exif_model));
  memset(img->exif_lens, 0, sizeof(img->exif_lens));
  memset(img->camera_maker, 0, sizeof(img->camera_maker));
  memset(img->camera_model, 0, sizeof(img->camera_model));
  memset(img->camera_alias, 0, sizeof(img->camera_alias));
  memset(img->camera_makermodel, 0, sizeof(img->camera_makermodel));
  memset(img->camera_legacy_makermodel, 0,
         sizeof(img->camera_legacy_makermodel));
  memset(img->filename, 0, sizeof(img->filename));
  g_strlcpy(img->filename, ""(unknown)"", sizeof(img->filename));
  img->exif_model[0] = img->exif_maker[0] = img->exif_lens[0] = '\0';
  g_strlcpy(img->exif_datetime_taken, ""0000:00:00 00:00:00"",
            sizeof(img->exif_datetime_taken));
  img->exif_crop = 1.0;
  img->exif_exposure = 0;
  img->exif_aperture = 0;
  img->exif_iso = 0;
  img->exif_focal_length = 0;
  img->exif_focus_distance = 0;
  img->geoloc.latitude = NAN;
  img->geoloc.longitude = NAN;
  img->geoloc.elevation = NAN;
  img->raw_black_level = 0;
  for (uint8_t i = 0; i < 4; i++)
    img->raw_black_level_separate[i] = 0;
  img->raw_white_point = 16384;
  img->d65_color_matrix[0] = NAN;
  img->profile = NULL;
  img->profile_size = 0;
  img->colorspace = DT_IMAGE_COLORSPACE_NONE;
  img->fuji_rotation_pos = 0;
  img->pixel_aspect_ratio = 1.0f;
  img->wb_coeffs[0] = NAN;
  img->wb_coeffs[1] = NAN;
  img->wb_coeffs[2] = NAN;
  img->wb_coeffs[3] = NAN;
  img->cache_entry = 0;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/ituh263enc.c	Return the 4 bit value that specifies the given aspect ratio. This may be one of the standard aspect ratios or it specifies that the aspect will be stored explicitly later.	2	"av_const int ff_h263_aspect_to_info(AVRational aspect) {
  int i;

  if (aspect.num == 0 || aspect.den == 0)
    aspect = (AVRational){1, 1};

  for (i = 1; i < 6; i++) {
    if (av_cmp_q(ff_h263_pixel_aspect[i], aspect) == 0) {
      return i;
    }
  }

  return FF_ASPECT_EXTENDED;
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m6/amffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t file_size = 0;
  int bit_rate = 0;
  int64_t old_offset = -1;
  int fast_switch = 1;
  float value;
  int64_t streamtype = -1;

  if (am_getconfig_float(""media.libplayer.fastswitch"", &value) == 0) {
    fast_switch = (int)value;
  }

  if ((!strcmp(ic->iformat->name, ""mpegts""))) {
    if (ic->pb && ic->pb->is_slowmedia &&
        am_getconfig_bool(""libplayer.netts.softdemux"")) {
      fast_switch = SOFTDEMUX_PARSE_MODE;
    } else if (am_getconfig_bool(""libplayer.livets.softdemux"")) {
      avio_getinfo(ic->pb, AVCMD_HLS_STREAMTYPE, 0, &streamtype);
      if (ic->pb && ic->pb->is_slowmedia && (streamtype == 0)) {
        fast_switch = SOFTDEMUX_PARSE_MODE;
      }
    }
  }

  av_log(NULL, AV_LOG_INFO,
         ""[%s]iformat->name[%s]fast_switch=%d streamtype=%lld\n"", __FUNCTION__,
         ic->iformat->name, fast_switch, streamtype);

  if (ic->pb != NULL)
    old_offset = avio_tell(ic->pb);
  if (!strcmp(ic->iformat->name, ""DRMdemux"")) {
    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];
      if (st->codec->bit_rate > 0) {
        bit_rate += st->codec->bit_rate;
        if (st->duration != AV_NOPTS_VALUE)
          file_size += (st->duration / AV_TIME_BASE * st->codec->bit_rate) >> 3;
      }
    }
    if (file_size > 0)
      ic->file_size = file_size;
    if (bit_rate > 0)
      ic->bit_rate = bit_rate;
    av_log(NULL, AV_LOG_INFO,
           ""]av_find_stream_info]DRMdemux, do not check stream info ,return ""
           ""directly\n"");
    return 0;
  }
  av_log(NULL, AV_LOG_INFO, ""[%s:%d]fast_switch=%d\n"", __FUNCTION__, __LINE__,
         fast_switch);
  if (fast_switch) {
    for (i = 0; i < ic->nb_streams; i++) {
      ic->streams[i]->need_parsing = AVSTREAM_PARSE_NONE;
    }
  }
  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);

    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec) {
      avcodec_open(st->codec, codec);
    }

    if (!has_codec_parameters_ex(st->codec, fast_switch)) {
      if (codec && !st->codec->codec) {
        avcodec_open(st->codec, codec);
      }
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  int stream_parser_count = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;
      st = ic->streams[i];
      int parse_mode = fast_switch;
      if (ic->pb && ic->pb->is_streamed == 1 &&
          !strcmp(ic->iformat->name, ""mpegts"")) {
        parse_mode = PARSE_MODE_BASE + fast_switch;
      }
      if (!strcmp(ic->iformat->name, ""asf"")) {
        parse_mode = ASF_PARSE_MODE;
        av_log(NULL, AV_LOG_INFO, ""parse_mode=%d\n"", parse_mode);
      }
      if ((parse_mode == WFD_PARSE_MODE) && (st->request_probe >= 0)) {
        parse_mode = SPEED_PARSE_MODE;
      }

      st->codec->durcount = st->info->duration_count;

      if (!has_codec_parameters_ex(st->codec, parse_mode)) {
        break;
      } else {
        stream_parser_count = i + 1;
      }

      if (ic->pb && ic->pb->fastdetectedinfo)
        continue;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (!fast_switch && tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (!fast_switch && st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER) ||
          (fast_switch && ic->nb_streams >= 2) ||
          (2 == fast_switch && 1 == ic->nb_streams)) {

        ret = count;
        av_log(ic, AV_LOG_INFO, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_ERROR,
             ""Probe buffer size limit %d reached, stream %d\n"", ic->probesize,
             ic->nb_streams);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters_ex(st->codec, fast_switch)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }
    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters_ex(st->codec, fast_switch) ||
        (!fast_switch && !has_decode_delay_been_guessed(st))) {
      try_decode_frame(st, pkt);
    }

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }
  ret = av_estimate_timings(ic, old_offset);
  if (ret < 0)
    goto find_stream_info_err;
  compute_chapters_end(ic);
#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  av_log(NULL, AV_LOG_INFO, ""[%s]return\n"", __FUNCTION__);
  return ret;
}"
opticron-libuweave-2e5e385/src/ble_advertising.c	"Get the raw advertising payload for the current device state, exposed for testing."	2	"void uw_ble_advertising_get_data_(UwDevice *device,
                                  UwBleAdvertisingData *data) {
  UwSettings *settings = uw_device_get_settings(device);
  UwDeviceCrypto *device_crypto = &device->device_crypto;
  *data = (UwBleAdvertisingData){};

  uint8_t caps = 0;
  if (settings->supports_wifi_24ghz) {
    caps |= kUwBleAdvertisingFlagWiFi24Ghz;
  }
  if (settings->supports_wifi_50ghz) {
    caps |= kUwBleAdvertisingFlagWiFi50Ghz;
  }
  if (settings->supports_ble_40) {
    caps |= kUwBleAdvertisingFlagBle40;
  }

  uint8_t pos = 0;

  data->bytes[pos] = sizeof(AdvertisingLayout);
  pos++;

  memcpy(&data->bytes[pos],
         &((AdvertisingLayout){
             .privet_tag = kFieldPrivetDataTag_,
             .device_class = {settings->device_class[0],
                              settings->device_class[1]},
             .model_id = {settings->model_id[0], settings->model_id[1],
                          settings->model_id[2]},
             .capabilities = {uw_device_is_setup(device)
                                  ? 0
                                  : kUwBleAdvertisingFlagNeedsWeaveRegistration,
                              caps}}),
         sizeof(AdvertisingLayout));

  pos += sizeof(AdvertisingLayout);
  data->bytes[pos] = sizeof(PublicIdLayout);
  pos++;

  memcpy(&data->bytes[pos],
         &((PublicIdLayout){
             .type = kFieldPublicIdTag_,
             .public_id = {device_crypto->device_id[0],
                           device_crypto->device_id[1],
                           device_crypto->device_id[2],
                           device_crypto->device_id[3]},
         }),
         sizeof(PublicIdLayout));
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/Printer.c	Retrieves the status of the virtual Printer port's inbound status lines. The result can then be masked against the PRNT_PORTSTATUS_* macros to determine the printer port's status.	2	"uint8_t
PRNT_Host_GetPortStatus(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                        uint8_t *const PortStatus) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetPortStatus,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(PortStatus);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a TEST UNIT READY command to the device, to determine if it is ready to accept other SCSI commands."	1	"uint8_t MS_Host_TestUnitReady(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                              const uint8_t LUNIndex) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       NULL)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
NeuroRoboticTech-AnimatLabPublicSource-c5b23f8/Libraries/OsgAnimatSim/OsgLinearPath.h	description: add a control point	2	"{public :

     ControlPointTransformFunctor(){}

 ~ControlPointTransformFunctor(){}

 public :

     virtual osg::Vec3d Transform(const osg::Vec3d p){return p;
}
}
;

public:
typedef std::vector<osg::ref_ptr<ControlPoint>> PointListType;

public:
OsgLinearPath();

~OsgLinearPath();

public:
bool AddControlPoint(const osg::Vec3d point, const double time);

bool AddControlPoint(ControlPoint *p);

void ClearAllControlPoints();

unsigned int GetNumberOfControlPoints() { return m_ControlPoints.size(); }"
blstream-OpenVideoHub-7bb9abf/libav/libavcodec/motion_est.c	compares a block (either a full macroblock or a partition thereof) against a proposed motion-compensated prediction of that block	2	"static av_always_inline int cmp(MpegEncContext *s, const int x, const int y,
                                const int subx, const int suby, const int size,
                                const int h, int ref_index, int src_index,
                                me_cmp_func cmp_func,
                                me_cmp_func chroma_cmp_func, const int flags) {
  MotionEstContext *const c = &s->me;
  const int stride = c->stride;
  const int uvstride = c->uvstride;
  const int qpel = flags & FLAG_QPEL;
  const int chroma = flags & FLAG_CHROMA;
  const int dxy = subx + (suby << (1 + qpel));
  const int hx = subx + (x << (1 + qpel));
  const int hy = suby + (y << (1 + qpel));
  uint8_t *const *const ref = c->ref[ref_index];
  uint8_t *const *const src = c->src[src_index];
  int d;

  if (flags & FLAG_DIRECT) {
    assert(x >= c->xmin && hx <= c->xmax << (qpel + 1) && y >= c->ymin &&
           hy <= c->ymax << (qpel + 1));
    if (x >= c->xmin && hx <= c->xmax << (qpel + 1) && y >= c->ymin &&
        hy <= c->ymax << (qpel + 1)) {
      const int time_pp = s->pp_time;
      const int time_pb = s->pb_time;
      const int mask = 2 * qpel + 1;
      if (s->mv_type == MV_TYPE_8X8) {
        int i;
        for (i = 0; i < 4; i++) {
          int fx = c->direct_basis_mv[i][0] + hx;
          int fy = c->direct_basis_mv[i][1] + hy;
          int bx = hx ? fx - c->co_located_mv[i][0]
                      : c->co_located_mv[i][0] * (time_pb - time_pp) / time_pp +
                            ((i & 1) << (qpel + 4));
          int by = hy ? fy - c->co_located_mv[i][1]
                      : c->co_located_mv[i][1] * (time_pb - time_pp) / time_pp +
                            ((i >> 1) << (qpel + 4));
          int fxy = (fx & mask) + ((fy & mask) << (qpel + 1));
          int bxy = (bx & mask) + ((by & mask) << (qpel + 1));

          uint8_t *dst = c->temp + 8 * (i & 1) + 8 * stride * (i >> 1);
          if (qpel) {
            c->qpel_put[1][fxy](dst, ref[0] + (fx >> 2) + (fy >> 2) * stride,
                                stride);
            c->qpel_avg[1][bxy](dst, ref[8] + (bx >> 2) + (by >> 2) * stride,
                                stride);
          } else {
            c->hpel_put[1][fxy](dst, ref[0] + (fx >> 1) + (fy >> 1) * stride,
                                stride, 8);
            c->hpel_avg[1][bxy](dst, ref[8] + (bx >> 1) + (by >> 1) * stride,
                                stride, 8);
          }
        }
      } else {
        int fx = c->direct_basis_mv[0][0] + hx;
        int fy = c->direct_basis_mv[0][1] + hy;
        int bx = hx ? fx - c->co_located_mv[0][0]
                    : (c->co_located_mv[0][0] * (time_pb - time_pp) / time_pp);
        int by = hy ? fy - c->co_located_mv[0][1]
                    : (c->co_located_mv[0][1] * (time_pb - time_pp) / time_pp);
        int fxy = (fx & mask) + ((fy & mask) << (qpel + 1));
        int bxy = (bx & mask) + ((by & mask) << (qpel + 1));

        if (qpel) {
          c->qpel_put[1][fxy](c->temp, ref[0] + (fx >> 2) + (fy >> 2) * stride,
                              stride);
          c->qpel_put[1][fxy](
              c->temp + 8, ref[0] + (fx >> 2) + (fy >> 2) * stride + 8, stride);
          c->qpel_put[1][fxy](
              c->temp + 8 * stride,
              ref[0] + (fx >> 2) + (fy >> 2) * stride + 8 * stride, stride);
          c->qpel_put[1][fxy](
              c->temp + 8 + 8 * stride,
              ref[0] + (fx >> 2) + (fy >> 2) * stride + 8 + 8 * stride, stride);
          c->qpel_avg[1][bxy](c->temp, ref[8] + (bx >> 2) + (by >> 2) * stride,
                              stride);
          c->qpel_avg[1][bxy](
              c->temp + 8, ref[8] + (bx >> 2) + (by >> 2) * stride + 8, stride);
          c->qpel_avg[1][bxy](
              c->temp + 8 * stride,
              ref[8] + (bx >> 2) + (by >> 2) * stride + 8 * stride, stride);
          c->qpel_avg[1][bxy](
              c->temp + 8 + 8 * stride,
              ref[8] + (bx >> 2) + (by >> 2) * stride + 8 + 8 * stride, stride);
        } else {
          assert((fx >> 1) + 16 * s->mb_x >= -16);
          assert((fy >> 1) + 16 * s->mb_y >= -16);
          assert((fx >> 1) + 16 * s->mb_x <= s->width);
          assert((fy >> 1) + 16 * s->mb_y <= s->height);
          assert((bx >> 1) + 16 * s->mb_x >= -16);
          assert((by >> 1) + 16 * s->mb_y >= -16);
          assert((bx >> 1) + 16 * s->mb_x <= s->width);
          assert((by >> 1) + 16 * s->mb_y <= s->height);

          c->hpel_put[0][fxy](c->temp, ref[0] + (fx >> 1) + (fy >> 1) * stride,
                              stride, 16);
          c->hpel_avg[0][bxy](c->temp, ref[8] + (bx >> 1) + (by >> 1) * stride,
                              stride, 16);
        }
      }
      d = cmp_func(s, c->temp, src[0], stride, 16);
    } else
      d = 256 * 256 * 256 * 32;
  } else {
    int uvdxy;
    if (dxy) {
      if (qpel) {
        c->qpel_put[size][dxy](c->temp, ref[0] + x + y * stride, stride);
        if (chroma) {
          int cx = hx / 2;
          int cy = hy / 2;
          cx = (cx >> 1) | (cx & 1);
          cy = (cy >> 1) | (cy & 1);
          uvdxy = (cx & 1) + 2 * (cy & 1);
        }
      } else {
        c->hpel_put[size][dxy](c->temp, ref[0] + x + y * stride, stride, h);
        if (chroma)
          uvdxy = dxy | (x & 1) | (2 * (y & 1));
      }
      d = cmp_func(s, c->temp, src[0], stride, h);
    } else {
      d = cmp_func(s, src[0], ref[0] + x + y * stride, stride, h);
      if (chroma)
        uvdxy = (x & 1) + 2 * (y & 1);
    }
    if (chroma) {
      uint8_t *const uvtemp = c->temp + 16 * stride;
      c->hpel_put[size + 1][uvdxy](
          uvtemp, ref[1] + (x >> 1) + (y >> 1) * uvstride, uvstride, h >> 1);
      c->hpel_put[size + 1][uvdxy](uvtemp + 8,
                                   ref[2] + (x >> 1) + (y >> 1) * uvstride,
                                   uvstride, h >> 1);
      d += chroma_cmp_func(s, uvtemp, src[1], uvstride, h >> 1);
      d += chroma_cmp_func(s, uvtemp + 8, src[2], uvstride, h >> 1);
    }
  }
#if 0
    if(full_pel){
        const int index= (((y)<<ME_MAP_SHIFT) + (x))&(ME_MAP_SIZE-1);
        score_map[index]= d;
    }

    d += (c->mv_penalty[hx - c->pred_x] + c->mv_penalty[hy - c->pred_y])*c->penalty_factor;
#endif
  return d;
}"
tsani-tetrefis-02d47ef/tetris.c	Converts a grid-local position to an absolute screen position.	2	"vec2 grid_local_to_absolute(game_state const *const s, vec2 p) {
  return (vec2){s->grid_origin.x + s->tile_size.x * p.x,
                s->grid_origin.y + s->tile_size.y * p.y};
}"
darktable-org-darktable-32fab21/src/iop/ashift.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {

  module->default_enabled = 0;

  int isflipped = 0;
  float f_length = DEFAULT_F_LENGTH;
  float crop_factor = 1.0f;

  if (module->dev) {
    const dt_image_t *img = &module->dev->image_storage;

    isflipped = (img->orientation == ORIENTATION_ROTATE_CCW_90_DEG ||
                 img->orientation == ORIENTATION_ROTATE_CW_90_DEG)
                    ? 1
                    : 0;

    f_length = isfinite(img->exif_focal_length) && img->exif_focal_length > 0.0f
                   ? img->exif_focal_length
                   : f_length;

    crop_factor = isfinite(img->exif_crop) && img->exif_crop > 0.0f
                      ? img->exif_crop
                      : crop_factor;
  }

  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){0.0f,
                                                        0.0f,
                                                        0.0f,
                                                        0.0f,
                                                        f_length,
                                                        crop_factor,
                                                        100.0f,
                                                        1.0f,
                                                        ASHIFT_MODE_GENERIC,
                                                        0,
                                                        ASHIFT_CROP_OFF,
                                                        0.0f,
                                                        1.0f,
                                                        0.0f,
                                                        1.0f};
  memcpy(module->params, &tmp, sizeof(dt_iop_ashift_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_ashift_params_t));

  if (module->gui_data) {
    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module->gui_data;

    char string_v[256];
    char string_h[256];

    snprintf(string_v, sizeof(string_v), _(""lens shift (%s)""),
             isflipped ? _(""horizontal"") : _(""vertical""));
    snprintf(string_h, sizeof(string_h), _(""lens shift (%s)""),
             isflipped ? _(""vertical"") : _(""horizontal""));

    dt_bauhaus_widget_set_label(g->lensshift_v, NULL, string_v);
    dt_bauhaus_widget_set_label(g->lensshift_h, NULL, string_h);

    dt_bauhaus_slider_set_default(g->f_length, tmp.f_length);
    dt_bauhaus_slider_set_default(g->crop_factor, tmp.crop_factor);

    dt_pthread_mutex_lock(&g->lock);
    free(g->buf);
    g->buf = NULL;
    g->buf_width = 0;
    g->buf_height = 0;
    g->buf_x_off = 0;
    g->buf_y_off = 0;
    g->buf_scale = 1.0f;
    g->buf_hash = 0;
    g->isflipped = -1;
    g->lastfit = ASHIFT_FIT_NONE;
    dt_pthread_mutex_unlock(&g->lock);

    g->fitting = 0;
    free(g->lines);
    g->lines = NULL;
    g->lines_count = 0;
    g->horizontal_count = 0;
    g->vertical_count = 0;
    g->grid_hash = 0;
    g->lines_hash = 0;
    g->rotation_range = ROTATION_RANGE_SOFT;
    g->lensshift_v_range = LENSSHIFT_RANGE_SOFT;
    g->lensshift_h_range = LENSSHIFT_RANGE_SOFT;
    g->shear_range = SHEAR_RANGE_SOFT;
    g->lines_suppressed = 0;
    g->lines_version = 0;
    g->show_guides = 0;
    g->isselecting = 0;
    g->isdeselecting = 0;
    g->isbounding = ASHIFT_BOUNDING_OFF;
    g->near_delta = 0;
    g->selecting_lines_version = 0;

    free(g->points);
    g->points = NULL;
    free(g->points_idx);
    g->points_idx = NULL;
    g->points_lines_count = 0;
    g->points_version = 0;

    g->jobcode = ASHIFT_JOBCODE_NONE;
    g->jobparams = 0;
    g->adjust_crop = FALSE;
    g->lastx = g->lasty = -1.0f;
    g->crop_cx = g->crop_cy = 1.0f;
  }
}"
CZ-NIC-knot-resolver-3775bbc/lib/cache/api.c	Like key_exact_type() but omits a couple checks not holding for pkt cache.	2	"knot_db_val_t key_exact_type_maypkt(struct key *k, uint16_t type) {
  assert(check_rrtype(type, NULL));
  switch (type) {
  case KNOT_RRTYPE_RRSIG:
    assert(false);
    return (knot_db_val_t){NULL, 0};

  case KNOT_RRTYPE_CNAME:
  case KNOT_RRTYPE_DNAME:
    type = KNOT_RRTYPE_NS;
  default:
    break;
  }

  int name_len = k->buf[0];
  k->buf[name_len + 1] = 0;
  k->buf[name_len + 2] = 'E';
  memcpy(k->buf + name_len + 3, &type, 2);
  k->type = type;

  return (knot_db_val_t){k->buf + 1, name_len + 4};
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/Printer.c	"Retrieves the attached printer device's ID string, formatted according to IEEE 1284. This string is sent as a Unicode string from the device and is automatically converted to an ASCII encoded C string by this function, thus the maximum reportable string length is two less than the size given (to accommodate the Unicode string length bytes which are removed). This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device."	2	"uint8_t
PRNT_Host_GetDeviceID(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                      char *const DeviceIDString, const uint16_t BufferSize) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = PRNT_REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = SwapEndian_16(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Request Sense command to the attached device, to determine the current SCSI sense information. This gives error codes for the last issued SCSI command to the device."	0	"uint8_t
MassStore_RequestSense(const uint8_t LUNIndex,
                       const SCSI_Request_Sense_Response_t *const SensePtr) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
                 .Flags = COMMAND_DIRECTION_DATA_IN,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 6},

      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_WaitForDataReceived()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_SendReceiveData((uint8_t *)SensePtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_GetReturnedStatus()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the scalar portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qscalarl(const quaternion_long_double num) {
  const quaternion_long_double conj_num = (quaternion_long_double){
      num.R, num.i * -1.0L, num.j * -1.0L, num.k * -1.0L};
  return (quaternion_long_double){
      (num.R + conj_num.R) * 0.5L, (num.i + conj_num.i) * 0.5L,
      (num.j + conj_num.j) * 0.5L, (num.k + conj_num.k) * 0.5L};
}"
apache-harmony-drlvm-e4c0736/vm/jitrino/src/shared/ControlFlowGraph.h	Checks if the edge profile is consistent. Checks only reachable nodes and recalculates postorder cache if needed.	2	"protected:
virtual Edge::Kind getEdgeKind(const Edge *edge) const = 0;

virtual void updateControlTransferInst(Node *oldTarget, Node *newTarget) {}

virtual void removeRedundantBranch(){};

protected:
CFGInst() : node(NULL), bcOffset(ILLEGAL_BC_MAPPING_VALUE) {}

Node *node;

uint16 bcOffset;
}
;

class Node {

  friend class ControlFlowGraph;

  friend class ControlFlowGraphFactory;

  friend class CFGInst;

public:
  enum Kind {

    Kind_Block,

    Kind_Dispatch,

    Kind_Exit
  };

  virtual ~Node() {}"
kemadz-monit-9b51725/src/validate.c	Validate a program status. Events are posted according to its configuration. In case of a fatal event false is returned.	2	"State_Type check_program(Service_T s) {
  ASSERT(s);
  ASSERT(s->program);
  State_Type rv = State_Succeeded;
  time_t now = Time_now();
  Process_T P = s->program->P;
  if (P) {
    if (Process_exitStatus(P) < 0) {
      int64_t execution_time = (now - s->program->started) * 1000;
      if (execution_time > s->program->timeout) {
        rv = State_Failed;
        LogError(
            ""'%s' program timed out after %s. Killing program with pid %ld\n"",
            s->name, Str_milliToTime(execution_time, (char[23]){}),
            (long)Process_getPid(P));
        Process_kill(P);
        Process_waitFor(P);

      } else {

        DEBUG(""'%s' status check deferred - waiting on program to exit\n"",
              s->name);
        return State_Init;
      }
    }
    s->program->exitStatus = Process_exitStatus(P);

    StringBuffer_clear(s->program->output);
    _programOutput(Process_getErrorStream(P), s->program->output);
    _programOutput(Process_getInputStream(P), s->program->output);
    StringBuffer_trim(s->program->output);

    for (Status_T status = s->statuslist; status; status = status->next) {
      if (status->operator== Operator_Changed) {
        if (status->initialized) {
          if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                   status->return_value)) {
            Event_post(s, Event_Status, State_Changed, status->action,
                       ""status changed (%d -> %d) -- %s"", status->return_value,
                       s->program->exitStatus,
                       StringBuffer_length(s->program->output)
                           ? StringBuffer_toString(s->program->output)
                           : ""no output"");
            status->return_value = s->program->exitStatus;
          } else {
            Event_post(s, Event_Status, State_ChangedNot, status->action,
                       ""status didn't change (%d) -- %s"",
                       s->program->exitStatus,
                       StringBuffer_length(s->program->output)
                           ? StringBuffer_toString(s->program->output)
                           : ""no output"");
          }
        } else {
          status->initialized = true;
          status->return_value = s->program->exitStatus;
        }
      } else {
        if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                 status->return_value)) {
          rv = State_Failed;
          Event_post(s, Event_Status, State_Failed, status->action,
                     ""status failed (%d) -- %s"", s->program->exitStatus,
                     StringBuffer_length(s->program->output)
                         ? StringBuffer_toString(s->program->output)
                         : ""no output"");
        } else {
          Event_post(s, Event_Status, State_Succeeded, status->action,
                     ""status succeeded (%d) -- %s"", s->program->exitStatus,
                     StringBuffer_length(s->program->output)
                         ? StringBuffer_toString(s->program->output)
                         : ""no output"");
        }
      }
    }
    Process_free(&s->program->P);
  } else {
    rv = State_Init;
  }

  if (!_checkSkip(s) && s->monitor != Monitor_Not) {

    s->program->P = Command_execute(s->program->C);
    if (!s->program->P) {
      rv = State_Failed;
      Event_post(s, Event_Status, State_Failed, s->action_EXEC,
                 ""failed to execute '%s' -- %s"", s->path, STRERROR);
    } else {
      Event_post(s, Event_Status, State_Succeeded, s->action_EXEC,
                 ""program started"");
      s->program->started = now;
    }
  }
  return rv;
}"
cmassiot-vlc-broadcast-de11815/libs/srtp/srtp.c	"Turns a RTCP packet into a SRTCP packet: encrypt it, then computes the authentication tag and appends it."	2	"srtcp_send(srtp_session_t *s, uint8_t *buf, size_t *lenp, size_t bufsize) {
  size_t len = *lenp;
  if (bufsize < (len + 4 + s->tag_len))
    return ENOSPC;

  uint32_t index = ++s->rtcp_index;
  if (index >> 31)
    s->rtcp_index = index = 0;

  if ((s->flags & SRTCP_UNENCRYPTED) == 0)
    index |= 0x80000000;
  memcpy(buf + len, &(uint32_t){htonl(index)}, 4);

  int val = srtcp_crypt(s, buf, len);
  if (val)
    return val;

  len += 4;

  const uint8_t *tag = rtcp_digest(s->rtp.mac, buf, len);
  memcpy(buf + len, tag, s->tag_len);
  *lenp = len + s->tag_len;
  return 0;
}"
google-graphd-e994e88/libgdp/gdp-lexer.c	Consume a token from the input stream.	2	"int gdp_lexer_consume(gdp *parser, gdp_input *in, gdp_token *tok) {
  gdp_token_kind kind = 0;
  char *s, *e;
  bool special;
  int row = 0;
  int col = 0;
  int ch;
  int err;

  special = false;

  while ((err = consume_comments_and_space(in)) == GDP_ERR_AGAIN)
    ;

  if (err)
    return err;

  row = in->in_row;
  col = in->in_col;

  gdp_input_tokbegin(in);

  if ((err = get(in, &ch)))
    goto fail;

  if (is_alnum(ch))
    err = consume_atom_alnum(in, &kind);

  else if (is_num(ch))
    err = consume_atom_num(in, &kind);

  else if (is_sym(ch))
    err = consume_symbol(in, ch, &kind);

  else if (is_str(ch))
    err = consume_string(in, &kind, &special);

  else if (is_var(ch))
    err = consume_variable(in, &kind);

  else if (is_eof(ch))
    err = consume_eof(in, &kind);
  else
    err = GDP_ERR_LEXICAL;
  if (err)
    goto fail;

  if ((err = gdp_input_tokend(in, special, &s, &e)))
    return err;

  if (kind == TOK_STR) {
    s++;
    e--;
    if unlikely (special)
      fix_string(&s, &e);
  }

  if likely (tok != NULL) {
    *tok = (gdp_token){
        .tkn_kind = kind,
        .tkn_start = s,
        .tkn_end = e,
        .tkn_row = row,
        .tkn_col = col,
    };

    if ((kind == TOK_ATOM) && ((*s | 0x20) == 'n'))
      if (gdp_token_matches(tok, ""null"")) {

        tok->tkn_kind = TOK_NULL;
        tok->tkn_start = NULL;
        tok->tkn_end = NULL;
      }

    if unlikely (parser->dbglex)
      gdp_token_printf(parser->dbgf, ""[$n $i]"", tok);
  }

  return 0;

fail:
  if (err == GDP_ERR_LEXICAL) {
    char const *const UNK = ""(unknown)"";

    if (gdp_input_tokend(in, false, &s, &e))
      s = e = NULL;
    *tok = (gdp_token){
        .tkn_kind = TOK_ATOM,
        .tkn_start = s ?: UNK,
        .tkn_end = e ?: UNK + strlen(UNK),
        .tkn_row = row,
        .tkn_col = col,
    };
  }
  return err;
}"
graphitemaster-redroid-9cdd940/string.c	Constructs a managed string object from a C-style string.	2	"string_t *string_create(const char *contents) {
  return memcpy(malloc(sizeof(string_t)),
                &(string_t){.buffer = strdup(contents),
                            .allocated = strlen(contents),
                            .length = strlen(contents)},
                sizeof(string_t));
}"
dm-vdo-kvdo-8df6805/vdo/base/slabJournalInternals.h	Decode the packed representation of a slab block header.	2	"void unpackSlabJournalBlockHeader(const PackedSlabJournalBlockHeader *packed,
                                  SlabJournalBlockHeader *header) {
  *header = (SlabJournalBlockHeader){
      .head = getUInt64LE(packed->fields.head),
      .sequenceNumber = getUInt64LE(packed->fields.sequenceNumber),
      .nonce = getUInt64LE(packed->fields.nonce),
      .entryCount = getUInt16LE(packed->fields.entryCount),
      .metadataType = packed->fields.metadataType,
      .hasBlockMapIncrements = packed->fields.hasBlockMapIncrements,
  };
  unpackJournalPoint(&packed->fields.recoveryPoint, &header->recoveryPoint);
}"
mdhsl-FFmpeg-Pnacl-367670c/pnacl-ffmpeg-3.0.1/ffmpeg-3.0.1/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }

  st->internal = av_mallocz(sizeof(*st->internal));
  if (!st->internal)
    goto fail;

  if (s->iformat) {

    st->codec->bit_rate = 0;

    avpriv_set_pts_info(st, 33, 1, 90000);

    st->cur_dts = RELATIVE_TS_BASE;
  } else {
    st->cur_dts = AV_NOPTS_VALUE;
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  s->streams[s->nb_streams++] = st;
  return st;
fail:
  free_stream(&st);
  return NULL;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/GenericHIDHost/GenericHIDHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and to send reports if desired."	1	"TASK(USB_HID_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""HID Device Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:
    ReadNextReport();

    break;
  }
}"
PJK-libcbor-87f977e/src/cbor/ints.c	Allocates new integer with 1B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int8() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 1);
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_8}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/StillImage.c	Opens a new PIMA session with the attached device. This should be used before any session-orientated PIMA commands are issued to the device. Only one session can be open at the one time.	2	"uint8_t SI_Host_OpenSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SIInterfaceInfo->State.TransactionID = 0;
  SIInterfaceInfo->State.IsSessionOpen = false;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = 0x1002,
      .Params = {1},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((PIMABlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  SIInterfaceInfo->State.IsSessionOpen = true;

  return PIPE_RWSTREAM_NoError;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Divide two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion qdiv(const quaternion num1,
                                   const quaternion num2) {
  if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) &&
      (num1.k == num2.k))
    return (quaternion){1.0, 0.0, 0.0, 0.0};
  const double tmp_r = (num2.R * num1.R) + (num2.i * num1.i) +
                       (num2.j * num1.j) + (num2.k * num1.k);
  const double tmp_i = (num2.R * num1.i) - (num2.i * num1.R) -
                       (num2.j * num1.k) + (num2.k * num1.j);
  const double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) -
                       (num2.j * num1.R) - (num2.k * num1.i);
  const double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                       (num2.j * num1.i) - (num2.k * num1.R);
  register const double tmp2n =
      squareroot((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) +
                 (num2.k * num2.k));
  return (quaternion){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n,
                      tmp_k / tmp2n};
}"
ManiAm-VENTOS_Public-60c5d62/src/MIXIM_veins/connectionManager/BaseConnectionManager.h	Reads init parameters and calculates a maximal interference distance.	2	"public:
GridCoord() : x(0), y(0), z(0){};

GridCoord(int x, int y) : x(x), y(y), z(0){};

GridCoord(int x, int y, int z) : x(x), y(y), z(z){};

GridCoord(const GridCoord &o) {
  x = o.x;
  y = o.y;
  z = o.z;
}

GridCoord(const Coord &c, const Coord &gridCellSize = Coord(1.0, 1.0, 1.0)) {
  x = static_cast<int>(c.x / gridCellSize.x);
  y = static_cast<int>(c.y / gridCellSize.y);
  z = static_cast<int>(c.z / gridCellSize.z);
}

std::string info() const {
  std::stringstream os;
  os << ""("" << x << "","" << y << "","" << z << "")"";
  return os.str();
}

friend bool operator==(const GridCoord &a, const GridCoord &b) {
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

friend bool operator!=(const GridCoord &a, const GridCoord &b) {
  return !(a == b);
}
}
;

class CoordSet {
protected:
  std::vector<GridCoord *> data;

  unsigned maxSize;

  unsigned size;

  unsigned current;

protected:
  void insert(const GridCoord &c, unsigned pos) {
    if (data[pos] == 0) {
      data[pos] = new GridCoord(c);
      size++;
    } else {
      if (*data[pos] != c) {
        insert(c, (pos + 2) % maxSize);
      }
    }
  }

public:
  CoordSet(unsigned sz) : maxSize(sz), size(0), current(0) {
    data.resize(maxSize);
  }"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/Printer.c	"Retrieves the attached printer device's ID string, formatted according to IEEE 1284. This string is sent as a Unicode string from the device and is automatically converted to an ASCII encoded C string by this function, thus the maximum reportable string length is two less than the size given (to accommodate the Unicode string length bytes which are removed). This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device. This string, when supported, contains the model, manufacturer and acceptable printer languages for the attached device."	0	"uint8_t
PRNT_Host_GetDeviceID(USB_ClassInfo_PRNT_Host_t *const PRNTInterfaceInfo,
                      char *DeviceIDString, uint16_t BufferSize) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;
  uint16_t DeviceIDStringLength = 0;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_GetDeviceID,
      .wValue = 0,
      .wIndex = PRNTInterfaceInfo->State.InterfaceNumber,
      .wLength = sizeof(DeviceIDStringLength),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(&DeviceIDStringLength)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  if (!(DeviceIDStringLength)) {
    DeviceIDString[0] = 0x00;
    return HOST_SENDCONTROL_Successful;
  }

  DeviceIDStringLength = SwapEndian_16(DeviceIDStringLength);

  if (DeviceIDStringLength > BufferSize)
    DeviceIDStringLength = BufferSize;

  USB_ControlRequest.wLength = DeviceIDStringLength;

  if ((ErrorCode = USB_Host_SendControlRequest(DeviceIDString)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  memmove(&DeviceIDString[0], &DeviceIDString[2], DeviceIDStringLength - 2);

  DeviceIDString[DeviceIDStringLength - 2] = 0x00;

  return HOST_SENDCONTROL_Successful;
}"
bullno1-lip-89bb88c/src/core/module.c	"A module search pattern is a regular path with one of these special characters: If any error occurs during module loading, the process will be aborted and no change will be made to the runtime system."	2	"lip_load_module(lip_context_t *ctx, lip_string_ref_t name) {
  int ret;
  kh_put(lip_string_ref_set, ctx->loading_modules, name, &ret);
  if (ret == 0) {
    lip_array(char) error_msg_buf =
        lip_array_create(ctx->module_pool, char, 64);
    lip_sprintf(&error_msg_buf, ""Circular dependency around %.*s"",
                (int)name.length, name.ptr);
    lip_array_push(error_msg_buf, '\0');

    ctx->error = (lip_context_error_t){
        .message = {.length = lip_array_len(error_msg_buf) - 1,
                    .ptr = error_msg_buf},
    };
    return false;
  }

  bool result = false;
  bool stacked_error = false;
  lip_ctx_begin_load(ctx);
#define returnVal(X)                                                           \
  do {                                                                         \
    result = X;                                                                \
    goto end;                                                                  \
  } while (0)

  unsigned int num_patterns = ctx->runtime->cfg.num_module_search_patterns;
  const lip_string_ref_t *patterns = ctx->runtime->cfg.module_search_patterns;
  lip_fs_t *fs = ctx->runtime->cfg.fs;
  lip_in_t *file = NULL;
  lip_script_t *script = NULL;
  lip_string_ref_t filename;

  lip_array_clear(ctx->error_records);

  for (unsigned int i = 0; i < num_patterns; ++i) {
    lip_array(char) filename_buf =
        lip_array_create(ctx->module_pool, char, 512);
    lip_string_ref_t pattern = patterns[i];

    for (unsigned int j = 0; j < pattern.length; ++j) {
      char pattern_ch = pattern.ptr[j];
      switch (pattern_ch) {
      case '?':
        for (unsigned int k = 0; k < name.length; ++k) {
          char name_ch = name.ptr[k];
          if (name_ch == '.') {
            name_ch = '/';
          }
          lip_array_push(filename_buf, name_ch);
        }
        break;
      case '!': {
        size_t array_len = lip_array_len(filename_buf);
        lip_array_resize(filename_buf, array_len + name.length);
        memcpy(filename_buf + array_len, name.ptr, name.length);
      } break;
      default:
        lip_array_push(filename_buf, pattern_ch);
        break;
      }
    }

    size_t str_len = lip_array_len(filename_buf);
    lip_array_push(filename_buf, 0);
    filename = (lip_string_ref_t){.length = str_len, .ptr = filename_buf};

    file = fs->begin_read(fs, filename);
    if (file == NULL) {
      lip_string_ref_t error = fs->last_error(fs);
      lip_string_ref_t error_copy =
          lip_copy_string_ref(ctx->module_pool, error);
      lip_error_record_t record = {.filename = filename,
                                   .location = LIP_LOC_NOWHERE,
                                   .message = error_copy};
      lip_array_push(ctx->error_records, record);
    } else {
      break;
    }
  }

  if (file == NULL) {
    lip_array(char) error_msg_buf =
        lip_array_create(ctx->module_pool, char, 64);
    lip_sprintf(&error_msg_buf, ""Could not load module %.*s"", (int)name.length,
                name.ptr);
    lip_array_push(error_msg_buf, '\0');
    ctx->error = (lip_context_error_t){
        .message = {.length = lip_array_len(error_msg_buf) - 1,
                    .ptr = error_msg_buf},
        .num_records = lip_array_len(ctx->error_records),
        .records = ctx->error_records};
    stacked_error = true;
    returnVal(false);
  }

  script = lip_load_script(ctx, filename, file);
  if (script == NULL) {
    returnVal(false);
  }

  if (!lip_link_module_pre_exec(ctx, script->closure->function.lip)) {
    returnVal(false);
  }

  khash_t(lip_module) *module = kh_init(lip_module, ctx->module_pool);
  lip_string_ref_t name_copy = lip_copy_string_ref(ctx->module_pool, name);
  khiter_t itr = kh_put(lip_symtab, ctx->loading_symtab, name_copy, &ret);
  kh_val(ctx->loading_symtab, itr) = module;

  khash_t(lip_module) *previous_module = ctx->current_module;
  ctx->current_module = module;

  lip_vm_t *vm = lip_get_default_vm(ctx);
  lip_reset_vm(vm);
  lip_value_t exec_result;
  lip_exec_status_t status =
      lip_call(vm, &exec_result,
               (lip_value_t){.type = LIP_VAL_FUNCTION,
                             .data = {.reference = script->closure}},
               0);

  ctx->current_module = previous_module;

  if (status == LIP_EXEC_OK) {

    if (!lip_link_module_post_exec(ctx, script->closure->function.lip,
                                   module)) {
      returnVal(false);
    }

    kh_foreach(itr, module) {
      lip_string_ref_t *key = &kh_key(module, itr);
      lip_symbol_t *value = &kh_val(module, itr);

      value->value = lip_copy_closure(ctx->module_pool, value->value);
      *key = lip_copy_string_ref(ctx->module_pool, *key);
    }
    returnVal(true);
  } else {
    lip_traceback(ctx, vm, exec_result);
    lip_array_foreach(lip_error_record_t, record, ctx->error_records) {
      record->message = lip_copy_string_ref(ctx->module_pool, record->message);
      record->filename =
          lip_copy_string_ref(ctx->module_pool, record->filename);
    }
    returnVal(false);
  }

end:
  if (file) {
    fs->end_read(fs, file);
  }
  if (script) {
    lip_unload_script(ctx, script);
  }

  if (!result) {
    if (!stacked_error) {
      lip_array(char) error_msg_buf =
          lip_array_create(ctx->module_pool, char, 64);
      lip_sprintf(&error_msg_buf, ""Could not load module %.*s"",
                  (int)name.length, name.ptr);
      lip_array_push(error_msg_buf, '\0');

      lip_context_error_t *error_copy =
          lip_new(ctx->module_pool, lip_context_error_t);
      *error_copy = ctx->error;
      ctx->error = (lip_context_error_t){
          .message = {.length = lip_array_len(error_msg_buf) - 1,
                      .ptr = error_msg_buf},
          .parent = error_copy};
    }
    lip_ctx_abort_load(ctx);
  }
  lip_ctx_end_load(ctx);
  return result;
}"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Request Sense command to the attached device, to determine the current SCSI sense information. This gives error codes for the last issued SCSI command to the device."	0	"uint8_t MassStore_RequestSense(const uint8_t LUNIndex,
                               SCSI_Request_Sense_Response_t *const SensePtr) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, SensePtr);
}"
captain-mayhem-captainsengine-fe7d76a/extern/ffmpeg/libavfilter/src_movie.c	Try to push a frame to the requested output.	2	"static int movie_push_frame(AVFilterContext *ctx, unsigned out_id) {
  MovieContext *movie = ctx->priv;
  AVPacket *pkt = &movie->pkt;
  enum AVMediaType frame_type;
  MovieStream *st;
  int ret, got_frame = 0, pkt_out_id;
  AVFilterLink *outlink;
  AVFrame *frame;

  if (!pkt->size) {
    if (movie->eof) {
      if (movie->st[out_id].done) {
        if (movie->loop_count != 1) {
          ret = rewind_file(ctx);
          if (ret < 0)
            return ret;
          movie->loop_count -= movie->loop_count > 1;
          av_log(ctx, AV_LOG_VERBOSE, ""Stream finished, looping.\n"");
          return 0;
        }
        return AVERROR_EOF;
      }
      pkt->stream_index = movie->st[out_id].st->index;

    } else {
      ret = av_read_frame(movie->format_ctx, &movie->pkt0);
      if (ret < 0) {
        av_init_packet(&movie->pkt0);
        *pkt = movie->pkt0;
        if (ret == AVERROR_EOF) {
          movie->eof = 1;
          return 0;
        }
        return ret;
      }
      *pkt = movie->pkt0;
    }
  }

  pkt_out_id = pkt->stream_index > movie->max_stream_index
                   ? -1
                   : movie->out_index[pkt->stream_index];
  if (pkt_out_id < 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
    return 0;
  }
  st = &movie->st[pkt_out_id];
  outlink = ctx->outputs[pkt_out_id];

  frame = av_frame_alloc();
  if (!frame)
    return AVERROR(ENOMEM);

  frame_type = st->st->codec->codec_type;
  switch (frame_type) {
  case AVMEDIA_TYPE_VIDEO:
    ret = avcodec_decode_video2(st->st->codec, frame, &got_frame, pkt);
    break;
  case AVMEDIA_TYPE_AUDIO:
    ret = avcodec_decode_audio4(st->st->codec, frame, &got_frame, pkt);
    break;
  default:
    ret = AVERROR(ENOSYS);
    break;
  }
  if (ret < 0) {
    av_log(ctx, AV_LOG_WARNING, ""Decode error: %s\n"", av_err2str(ret));
    av_frame_free(&frame);
    av_packet_unref(&movie->pkt0);
    movie->pkt.size = 0;
    movie->pkt.data = NULL;
    return 0;
  }
  if (!ret || st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
    ret = pkt->size;

  pkt->data += ret;
  pkt->size -= ret;
  if (pkt->size <= 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
  }
  if (!got_frame) {
    if (!ret)
      st->done = 1;
    av_frame_free(&frame);
    return 0;
  }

  frame->pts = av_frame_get_best_effort_timestamp(frame);
  ff_dlog(
      ctx, ""movie_push_frame(): file:'%s' %s\n"", movie->file_name,
      describe_frame_to_str((char[1024]){0}, 1024, frame, frame_type, outlink));

  if (st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
    if (frame->format != outlink->format) {
      av_log(ctx, AV_LOG_ERROR, ""Format changed %s -> %s, discarding frame\n"",
             av_get_pix_fmt_name(outlink->format),
             av_get_pix_fmt_name(frame->format));
      av_frame_free(&frame);
      return 0;
    }
  }
  ret = ff_filter_frame(outlink, frame);

  if (ret < 0)
    return ret;
  return pkt_out_id == out_id;
}"
lintest-myrulib-4aff570/3rdparty/crengine/include/lvtinydom.h	allocate new tiny node	2	"public:
void addWords(const LVArray<ldomWord> &words) {
  for (int i = 0; i < words.length(); i++)
    LVPtrVector<ldomXRange>::add(new ldomXRange(words[i]));
}
ldomXRangeList(const LVArray<ldomWord> &words) { addWords(words); }

ldomXRangeList(ldomXRangeList &srcList, bool splitIntersections);

ldomXRangeList(ldomXRangeList &srcList, ldomXRange &filter);
#if BUILD_LITE != 1

void splitText(ldomMarkedTextList &dst, ldomNode *textNodeToSplit);

void getRanges(ldomMarkedRangeList &dst);
#endif

void split(ldomXRange *r);

ldomXRangeList(){};
}
;

class LVTocItem;
class LVDocView;

class LVTocItem {
  friend class LVDocView;

private:
  LVTocItem *_parent;
  ldomDocument *_doc;
  lInt32 _level;
  lInt32 _index;
  lInt32 _page;
  lInt32 _percent;
  lString16 _name;
  lString16 _path;
  ldomXPointer _position;
  LVPtrVector<LVTocItem> _children;

  LVTocItem(ldomXPointer pos, lString16 path, const lString16 &name)
      : _parent(NULL), _level(0), _index(0), _page(0), _percent(0), _name(name),
        _path(path), _position(pos) {}
  void addChild(LVTocItem *item) {
    item->_level = _level + 1;
    item->_parent = this;
    item->_index = _children.length(), item->_doc = _doc;
    _children.add(item);
  }"
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit integer vector initialized with the specified 32-bit integral values. This intrinsic is a utility function and does not correspond to a specific instruction.	2	"_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3, int __i4, int __i5,
                 int __i6, int __i7) {
  return __extension__(__m256i)(__v8si){__i7, __i6, __i5, __i4,
                                        __i3, __i2, __i1, __i0};
}"
PJK-libcbor-87f977e/src/cbor/strings.c	Creates a new indefinite string	2	"cbor_item_t *cbor_new_indefinite_string() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_STRING,
      .metadata = {.string_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                       .length = 0}},
      .data = _CBOR_MALLOC(sizeof(struct cbor_indefinite_string_data))};
  _CBOR_DEPENDENT_NOTNULL(item, item->data);
  *((struct cbor_indefinite_string_data *)item->data) =
      (struct cbor_indefinite_string_data){
          .chunk_count = 0,
          .chunk_capacity = 0,
          .chunks = NULL,
      };
  return item;
}"
Deadlocked007-EventUp-a067de4/FirebaseFunctions/functions/node_modules/firebase-admin/node_modules/grpc/src/core/ext/transport/chttp2/transport/chttp2_transport.c	"Set the default keepalive configurations, must only be called at initialization"	2	"void grpc_chttp2_config_default_keepalive_args(grpc_channel_args *args,
                                               bool is_client) {
  size_t i;
  if (args) {
    for (i = 0; i < args->num_args; i++) {
      if (0 == strcmp(args->args[i].key, GRPC_ARG_KEEPALIVE_TIME_MS)) {
        const int value = grpc_channel_arg_get_integer(
            &args->args[i],
            (grpc_integer_options){g_default_client_keepalive_time_ms, 1,
                                   INT_MAX});
        if (is_client) {
          g_default_client_keepalive_time_ms = value;
        } else {
          g_default_server_keepalive_time_ms = value;
        }
      } else if (0 ==
                 strcmp(args->args[i].key, GRPC_ARG_KEEPALIVE_TIMEOUT_MS)) {
        const int value = grpc_channel_arg_get_integer(
            &args->args[i],
            (grpc_integer_options){g_default_client_keepalive_timeout_ms, 0,
                                   INT_MAX});
        if (is_client) {
          g_default_client_keepalive_timeout_ms = value;
        } else {
          g_default_server_keepalive_timeout_ms = value;
        }
      } else if (0 == strcmp(args->args[i].key,
                             GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS)) {
        g_default_keepalive_permit_without_calls =
            (uint32_t)grpc_channel_arg_get_integer(
                &args->args[i],
                (grpc_integer_options){g_default_keepalive_permit_without_calls,
                                       0, 1});
      }
    }
  }
}"
PJK-libcbor-87f977e/src/cbor/arrays.c	Create new definite array	2	"cbor_item_t *cbor_new_definite_array(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);
  cbor_item_t **data = _cbor_alloc_multiple(sizeof(cbor_item_t *), size);
  _CBOR_DEPENDENT_NOTNULL(item, data);

  for (size_t i = 0; i < size; i++) {
    data[i] = NULL;
  }

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_DEFINITE,
                                      .allocated = size,
                                      .end_ptr = 0}},
      .data = (unsigned char *)data};

  return item;
}"
StarLabMakerSpace-Nova4Mixly-bed4f4f/nova/hardware/nova/avr/bootloaders/Caterina-ORG/LUFA-111009/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	Issues a Mass Storage class specific request to determine the index of the highest numbered Logical Unit in the attached device.	1	"uint8_t MassStore_GetMaxLUN(uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = 0,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) ==
      HOST_SENDCONTROL_SetupStalled) {

    Pipe_ClearStall();

    *MaxLUNIndex = 0;

    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
daos-stack-daos-956b717/src/tests/daosctl/io-cmds.c	Read data written with the write-pattern command and verify that its correct.	2	"cmd_verify_pattern(int argc, const char **argv, void *ctx) {
  char buf[128];
  int rc = 0;
  struct container_info cinfo;
  struct ioreq req;
  const char dkey[] = ""test_update dkey"";
  const char akey[] = ""test_update akey"";

  struct argp_option options[] = {
      {""server-group"", 's', ""SERVER-GROUP"", 0,
       ""ID of the server group that owns the pool""},
      {""servers"", 'l', ""server rank-list"", 0,
       ""pool service ranks, comma separated, no spaces e.g. -l 1,2""},
      {""p-uuid"", 'i', ""UUID"", 0,
       ""ID of the pool that hosts the container to be read from.""},
      {""c-uuid"", 'c', ""UUID"", 0, ""ID of the container.""},
      {""oid"", 'o', ""OID"", 0, ""ID of the object.""},
      {""size"", 'z', ""size"", 0,
       ""how much to read in bytes or with k/m/g (e.g. 10g)""},
      {""pattern"", 'p', ""pattern"", 0,
       ""which of the available data patterns to verify""},
      {0}};
  daos_obj_id_t oid;
  struct argp argp = {options, parse_cont_args_cb};
  struct io_cmd_options io_options = {""daos_server"", NULL,       NULL, NULL, 0,
                                      &oid,          ""all_zeros""};

  cinfo.server_group = io_options.server_group;
  cinfo.pool_service_list = (d_rank_list_t){NULL, 0};

  argv++;
  argc--;

  argp_parse(&argp, argc, (char **restrict)argv, 0, 0, &io_options);

  if (io_options.pool_uuid == NULL)
    return -EINVAL;
  rc = uuid_parse(io_options.pool_uuid, cinfo.pool_uuid);
  if (io_options.cont_uuid == NULL)
    return -EINVAL;
  rc = uuid_parse(io_options.cont_uuid, cinfo.cont_uuid);

  rc = parse_rank_list(io_options.server_list, &cinfo.pool_service_list);
  if (rc < 0) {
    D_PRINT(""Rank list parameter parsing failed with %i\n"", rc);
    return rc;
  }

  rc = open_container(&cinfo);

  printf(""%"" PRIu64 ""-%"" PRIu64 ""\n"", oid.hi, oid.lo);
  ioreq_init(&req, cinfo.coh, oid, DAOS_IOD_SINGLE);

  memset(buf, 0, sizeof(buf));
  lookup_single(dkey, akey, 0, buf, sizeof(buf), DAOS_TX_NONE, &req);

  printf(""size = %lu\n"", req.iod[0].iod_size);
  if (req.iod[0].iod_size != TEST_PATTERN_SIZE) {
    printf(""sizes don't match\n"");
    exit(1);
  }

  for (int i = 0; i < TEST_PATTERN_SIZE; i++) {
    if (buf[i] != PATTERN_1[i]) {
      printf(""Data mismatch at position %i value %i"", i, buf[i]);
      break;
    }
  }

  ioreq_fini(&req);
  if (cinfo.poh.cookie != 0)
    daos_pool_disconnect(cinfo.poh, NULL);

  return rc;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Add two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_float qaddf(const quaternion_float num1,
                                          const quaternion_float num2) {
  return (quaternion_float){num1.R + num2.R, num1.i + num2.i, num1.j + num2.j,
                            num1.k + num2.k};
}"
utwente-fmt-ltsmin-014b6c4/src/ltsmin-reduce-dist/sig-array.c	This function may wait a long time until returning if it has to wait for additional information to become available. (E.g. all successor ID's of a state have to be known before starting the computation of its signature.)	2	"sig_event_t SigArrayNext(sig_array_t sa) {
  switch (sa->state) {
  case IDLE:
    Fatal(1, error, ""Attempt to fetch an event while idle."");
    break;
  case SEND_ID:
    if (sa->count < sa->my_states) {
      sig_event_t event;
      event.what = ID_READY;
      event.where = sa->count;
      sa->count++;
      return event;
    }
    sa->state = WAIT_ID;
    Debug(""transition to WAIT"");
  case WAIT_ID:
    TQwhile(SLTSgetQueue(sa->lts), &sa->id_count);
    sa->count = 0;
    sa->state = COMPUTE_ID;
    Debug(""transition to COMPUTE"");
  case COMPUTE_ID:
    if (sa->count < sa->my_states) {
      sig_event_t event;
      event.what = SIG_READY;
      event.where = sa->count;
      sa->count++;
      return event;
    }
    if (sa->count == sa->my_states) {
      sa->state = IDLE;
      Debug(""transition to IDLE"");
      return (sig_event_t){.what = COMPLETED};
    }
  }
  Fatal(1, error, ""Internal error: missing case in SigArrayNext"");
  return (sig_event_t){.what = COMPLETED};
}"
Cisco-Talos-pyrebox-037efe8/qemu/block/io.c	Add an active request to the tracked requests list	2	"static void tracked_request_begin(BdrvTrackedRequest *req, BlockDriverState *bs,
                                  int64_t offset, unsigned int bytes,
                                  enum BdrvTrackedRequestType type) {
  *req = (BdrvTrackedRequest){
      .bs = bs,
      .offset = offset,
      .bytes = bytes,
      .type = type,
      .co = qemu_coroutine_self(),
      .serialising = false,
      .overlap_offset = offset,
      .overlap_bytes = bytes,
  };

  qemu_co_queue_init(&req->wait_queue);

  qemu_co_mutex_lock(&bs->reqs_lock);
  QLIST_INSERT_HEAD(&bs->tracked_requests, req, list);
  qemu_co_mutex_unlock(&bs->reqs_lock);
}"
dm-vdo-kvdo-8df6805/vdo/base/dataVIO.h	Get the location that should passed Albireo as the new advice for where to find the data written by this DataVIO.	2	"static inline DataLocation getDataVIONewAdvice(const DataVIO *dataVIO) {
  return (DataLocation){
      .pbn = dataVIO->newMapped.pbn,
      .state = dataVIO->newMapped.state,
  };
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Subtract two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_float qsubf(const quaternion_float num1,
                                          const quaternion_float num2) {
  return (quaternion_float){num1.R - num2.R, num1.i - num2.i, num1.j - num2.j,
                            num1.k - num2.k};
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavfilter/src_movie.c	Try to push a frame to the requested output.	2	"static int movie_push_frame(AVFilterContext *ctx, unsigned out_id) {
  MovieContext *movie = ctx->priv;
  AVPacket *pkt = &movie->pkt;
  enum AVMediaType frame_type;
  MovieStream *st;
  int ret, got_frame = 0, pkt_out_id;
  AVFilterLink *outlink;
  AVFrame *frame;

  if (!pkt->size) {
    if (movie->eof) {
      if (movie->st[out_id].done) {
        if (movie->loop_count != 1) {
          ret = rewind_file(ctx);
          if (ret < 0)
            return ret;
          movie->loop_count -= movie->loop_count > 1;
          av_log(ctx, AV_LOG_VERBOSE, ""Stream finished, looping.\n"");
          return 0;
        }
        return AVERROR_EOF;
      }
      pkt->stream_index = movie->st[out_id].st->index;

    } else {
      ret = av_read_frame(movie->format_ctx, &movie->pkt0);
      if (ret < 0) {
        av_init_packet(&movie->pkt0);
        *pkt = movie->pkt0;
        if (ret == AVERROR_EOF) {
          movie->eof = 1;
          return 0;
        }
        return ret;
      }
      *pkt = movie->pkt0;
    }
  }

  pkt_out_id = pkt->stream_index > movie->max_stream_index
                   ? -1
                   : movie->out_index[pkt->stream_index];
  if (pkt_out_id < 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
    return 0;
  }
  st = &movie->st[pkt_out_id];
  outlink = ctx->outputs[pkt_out_id];

  frame = av_frame_alloc();
  if (!frame)
    return AVERROR(ENOMEM);

  frame_type = st->st->codecpar->codec_type;
  switch (frame_type) {
  case AVMEDIA_TYPE_VIDEO:
    ret = avcodec_decode_video2(st->codec_ctx, frame, &got_frame, pkt);
    break;
  case AVMEDIA_TYPE_AUDIO:
    ret = avcodec_decode_audio4(st->codec_ctx, frame, &got_frame, pkt);
    break;
  default:
    ret = AVERROR(ENOSYS);
    break;
  }
  if (ret < 0) {
    av_log(ctx, AV_LOG_WARNING, ""Decode error: %s\n"", av_err2str(ret));
    av_frame_free(&frame);
    av_packet_unref(&movie->pkt0);
    movie->pkt.size = 0;
    movie->pkt.data = NULL;
    return 0;
  }
  if (!ret || st->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
    ret = pkt->size;

  pkt->data += ret;
  pkt->size -= ret;
  if (pkt->size <= 0) {
    av_packet_unref(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
  }
  if (!got_frame) {
    if (!ret)
      st->done = 1;
    av_frame_free(&frame);
    return 0;
  }

  frame->pts = frame->best_effort_timestamp;
  if (frame->pts != AV_NOPTS_VALUE) {
    if (movie->ts_offset)
      frame->pts += av_rescale_q_rnd(movie->ts_offset, AV_TIME_BASE_Q,
                                     outlink->time_base, AV_ROUND_UP);
    if (st->discontinuity_threshold) {
      if (st->last_pts != AV_NOPTS_VALUE) {
        int64_t diff = frame->pts - st->last_pts;
        if (diff < 0 || diff > st->discontinuity_threshold) {
          av_log(ctx, AV_LOG_VERBOSE,
                 ""Discontinuity in stream:%d diff:%"" PRId64 ""\n"", pkt_out_id,
                 diff);
          movie->ts_offset += av_rescale_q_rnd(-diff, outlink->time_base,
                                               AV_TIME_BASE_Q, AV_ROUND_UP);
          frame->pts -= diff;
        }
      }
    }
    st->last_pts = frame->pts;
  }
  ff_dlog(
      ctx, ""movie_push_frame(): file:'%s' %s\n"", movie->file_name,
      describe_frame_to_str((char[1024]){0}, 1024, frame, frame_type, outlink));

  if (st->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
    if (frame->format != outlink->format) {
      av_log(ctx, AV_LOG_ERROR, ""Format changed %s -> %s, discarding frame\n"",
             av_get_pix_fmt_name(outlink->format),
             av_get_pix_fmt_name(frame->format));
      av_frame_free(&frame);
      return 0;
    }
  }
  ret = ff_filter_frame(outlink, frame);

  if (ret < 0)
    return ret;
  return pkt_out_id == out_id;
}"
ofavre-Breach-e920a2e/src/main.cpp	Called upon a mouse click at a specified position. Currently only affects targets.	2	"void doSelection(int button, int x, int y) {
#define SELECTION_BUFFER_SIZE 512
  GLuint buffer[SELECTION_BUFFER_SIZE];
  GLint viewport[4];
  glGetIntegerv(GL_VIEWPORT, viewport);

  y = viewport[3] - y;

  glSelectBuffer(SELECTION_BUFFER_SIZE, buffer);
  glRenderMode(GL_SELECT);
  glInitNames();

  GLdouble modelMatrix[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
  GLdouble projectionMatrix[16];
  GLdouble objX, objY, objZ;
  glGetDoublev(GL_MODELVIEW_MATRIX, modelMatrix);
  glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);

  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();

  gluPickMatrix((GLdouble)x, (GLdouble)y, 1.0f, 1.0f, viewport);
  gluPerspective(45.0f,
                 (GLfloat)(viewport[2] - viewport[0]) /
                     (GLfloat)(viewport[3] - viewport[1]),
                 0.01f, 10.0f);

  doDisplay(true);

  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);

  SelectionUtil selection = SelectionUtil::finishGlSelection(buffer);
  vector<SelectionUtil::Hit> hits = selection.getHits();

  printf(""%lu hits ! (including walls...)\n"", hits.size());
  if (!hits.empty()) {
    for (vector<SelectionUtil::Hit>::iterator it = hits.begin();
         it < hits.end(); ++it) {
      SelectionUtil::Hit &hit = *it;
      printf("" number of names for hit = %lu\n"", hit.nameHierarchy.size());
      printf(""  z1 is %g"", hit.zMin);
      printf("" z2 is %g\n"", hit.zMax);

      GLdouble currObjX, currObjY, currObjZ;
      if (gluUnProject(x, y, (hit.zMin + hit.zMax) / 2.0f, modelMatrix,
                       projectionMatrix, viewport, &currObjX, &currObjY,
                       &currObjZ) == GL_TRUE) {
        printf(""  unprojection:\n"");
        printf(""   ( %f ; %f ; %f )\n"", currObjX, currObjY, currObjZ);
        if (it == hits.begin()) {
          objX = currObjX;
          objY = currObjY;
          objZ = currObjZ;
        }
      } else {
        printf(""  cannot unproject!\n"");
      }

      printf(""  the name is:"");
      for (vector<GLuint>::iterator itn = hit.nameHierarchy.begin();
           itn < hit.nameHierarchy.end(); ++itn) {
        GLuint name = *itn;
        printf("" %u"", name);
        if (itn == hit.nameHierarchy.begin() && name == 1) {
          printf(""(targets)"");
        } else if (itn == hit.nameHierarchy.begin() && name == 2) {
          printf(""(walls)"");
        }
      }
      printf(""\n"");
    }

    TypedSelectionVisitor<Target> targetSelectionResolver(
        hits[0].nameHierarchy);
    targetsRenderer->accept(targetSelectionResolver);

    if (targetSelectionResolver.isSelectedObjectFound()) {
      Target *shotTarget = targetSelectionResolver.getSelectedObject();
      printf(""Found : %p at (%f, %f, %f)\n"", shotTarget, shotTarget->getX(),
             shotTarget->getY(), shotTarget->getZ());
      if (button == 1)
        shotTarget->setHit();
    } else {
      printf(""No target hit\n"");

      TypedSelectionVisitor<Wall> wallSelectionResolver(hits[0].nameHierarchy);
      wallsRenderer->accept(wallSelectionResolver);

      if (wallSelectionResolver.isSelectedObjectFound()) {
        Wall *shotWall = wallSelectionResolver.getSelectedObject();
        printf(""Found : %p\n"", shotWall);
        Matrix<float, 4, 1> obj =
            Matrix<float, 4, 1>((float[]){objX, objY, objZ, 1});
        Matrix<float, 4, 1> corrected = shotWall->projectOnto(obj);
        Matrix<float, 2, 1> wallC = shotWall->inWallCoordinates(obj);
        printf(""  shotPosition = (%f, %f, %f)\n"", corrected[0], corrected[1],
               corrected[2]);
        printf(""  shotPosition = (%f, %f) in wall coordinates\n"", wallC[0],
               wallC[1]);

        unsigned int index = -1;
        if (button == 0) {
          index = 0;
        } else if (button == 2) {
          index = 1;
        }
        if (index != -1) {
          if (!Breach::shootBreach(index, *shotWall, wallC)) {
            printf(""  Could not shoot the breach!\n"");
          }
        }
      } else
        printf(""No wall hit\n"");
    }
  }
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  avpriv_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  s->streams[s->nb_streams++] = st;
  return st;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/KeyboardHost/KeyboardHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs."	1	"TASK(USB_Keyboard_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Protocol).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    ReadNextReport();

    break;
  }
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server not ready for SNI, and the client sends the known name. The client inquires the peer name and verifies it matches the desired credential."	3	"init_no_server_sni(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;

  major_status = gss_import_name(&minor_status,
                                 &(gss_buffer_desc){
                                     .value = ""/CN=test"",
                                     .length = strlen(""/CN=test""),
                                 },
                                 GSS_C_NO_OID, &target_name);

  if (major_status != GSS_S_COMPLETE) {
    result = false;
    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    major_status =
        gss_inquire_context(&minor_status, init_context, NULL, &peer_name, NULL,
                            NULL, NULL, NULL, NULL);
    if (major_status != GSS_S_COMPLETE) {
      result = false;

      goto fail;
    }

    major_status =
        gss_compare_name(&minor_status, target_name, peer_name, &name_equal);

    if (major_status != GSS_S_COMPLETE) {
      result = false;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
tiglabs-jupiter-1fd7df0/dpdk/drivers/net/mlx5/mlx5_rxtx_vec_neon.h	"Send burst of packets with Enhanced MPW. If it encounters a multi-seg packet, it returns to make it processed by txq_scatter_v(). All the packets in the pkts list should be single segment packets having same offload flags. This must be checked by txq_count_contig_single_seg() and txq_calc_offload()."	2	"txq_burst_v(struct mlx5_txq_data *txq, struct rte_mbuf **pkts, uint16_t pkts_n,
            uint8_t cs_flags) {
  struct rte_mbuf **elts;
  uint16_t elts_head = txq->elts_head;
  const uint16_t elts_n = 1 << txq->elts_n;
  const uint16_t elts_m = elts_n - 1;
  const unsigned int nb_dword_per_wqebb = MLX5_WQE_SIZE / MLX5_WQE_DWORD_SIZE;
  const unsigned int nb_dword_in_hdr =
      sizeof(struct mlx5_wqe) / MLX5_WQE_DWORD_SIZE;
  unsigned int n = 0;
  unsigned int pos;
  uint16_t max_elts;
  uint16_t max_wqe;
  uint32_t comp_req = 0;
  const uint16_t wq_n = 1 << txq->wqe_n;
  const uint16_t wq_mask = wq_n - 1;
  uint16_t wq_idx = txq->wqe_ci & wq_mask;
  volatile struct mlx5_wqe64 *wq =
      &((volatile struct mlx5_wqe64 *)txq->wqes)[wq_idx];
  volatile struct mlx5_wqe *wqe = (volatile struct mlx5_wqe *)wq;
  const uint8x16_t ctrl_shuf_m = {3,  2,  1, 0, 7,  6,  5,  4,
                                  11, 10, 9, 8, 12, 13, 14, 15};
  uint8x16_t *t_wqe;
  uint8_t *dseg;
  uint8x16_t ctrl;

  assert(elts_n > pkts_n);
  mlx5_tx_complete(txq);
  max_elts = (elts_n - (elts_head - txq->elts_tail));

  assert((1u << txq->cqe_n) - (txq->cq_pi - txq->cq_ci));
  max_wqe = (1u << txq->wqe_n) - (txq->wqe_ci - txq->wqe_pi);
  pkts_n = RTE_MIN((unsigned int)RTE_MIN(pkts_n, max_wqe), max_elts);
  if (unlikely(!pkts_n))
    return 0;
  elts = &(*txq->elts)[elts_head & elts_m];

  n = RTE_MIN(elts_n - (elts_head & elts_m), pkts_n);
  for (pos = 0; pos < (n & -2); pos += 2)
    vst1q_u64((void *)&elts[pos], vld1q_u64((void *)&pkts[pos]));
  if (n & 1)
    elts[pos] = pkts[pos];

  if (unlikely(n < pkts_n)) {
    elts = &(*txq->elts)[0];
    for (pos = 0; pos < pkts_n - n; ++pos)
      elts[pos] = pkts[n + pos];
  }
  txq->elts_head += pkts_n;

  t_wqe = (uint8x16_t *)wqe;
  dseg = (uint8_t *)(wqe + 1);

  n = RTE_MIN((wq_n - wq_idx) * nb_dword_per_wqebb - nb_dword_in_hdr, pkts_n);

  txq_wr_dseg_v(txq, dseg, pkts, n);

  if (n < pkts_n) {
    dseg = (uint8_t *)txq->wqes;
    txq_wr_dseg_v(txq, dseg, &pkts[n], pkts_n - n);
  }
  if (txq->elts_comp + pkts_n < MLX5_TX_COMP_THRESH) {
    txq->elts_comp += pkts_n;
  } else {

    txq->elts_comp = 0;
#ifndef NDEBUG
    ++txq->cq_pi;
#endif
    comp_req = 8;
  }

  ctrl = vreinterpretq_u8_u32(
      (uint32x4_t){MLX5_OPC_MOD_ENHANCED_MPSW << 24 | txq->wqe_ci << 8 |
                       MLX5_OPCODE_ENHANCED_MPSW,
                   txq->qp_num_8s | (pkts_n + 2), comp_req, txq->elts_head});
  ctrl = vqtbl1q_u8(ctrl, ctrl_shuf_m);
  vst1q_u8((void *)t_wqe, ctrl);

  vst1q_u8((void *)(t_wqe + 1), ((uint8x16_t){0, 0, 0, 0, cs_flags, 0, 0, 0, 0,
                                              0, 0, 0, 0, 0, 0, 0}));
#ifdef MLX5_PMD_SOFT_COUNTERS
  txq->stats.opackets += pkts_n;
#endif
  txq->wqe_ci += (nb_dword_in_hdr + pkts_n + (nb_dword_per_wqebb - 1)) /
                 nb_dword_per_wqebb;

  mlx5_tx_dbrec_cond_wmb(txq, wqe, pkts_n < MLX5_VPMD_TX_MAX_BURST);
  return pkts_n;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/connectdlg.c	Open connection dialog for either meta or lan scan.	2	"void popup_connection_dialog(bool lan_scan) {
  SDL_Color bg_color = {255, 255, 255, 128};
  char cBuf[512];
  int w = 0, h = 0, count = 0, meta_h;
  struct widget *pNewWidget, *pWindow, *pLabelWindow;
  utf8_str *pstr;
  SDL_Surface *pLogo;
  SDL_Rect area, area2;
  struct srv_list *srvrs;

  queue_flush();
  close_connection_dialog();
  meswin_dialog_popdown();

  pLabelWindow = create_window_skeleton(NULL, NULL, 0);
  add_to_gui_list(ID_WINDOW, pLabelWindow);

  area = pLabelWindow->area;

  fc_snprintf(cBuf, sizeof(cBuf), _(""Creating Server List...""));
  pstr = create_utf8_from_char(cBuf, adj_font(16));
  pstr->style = TTF_STYLE_BOLD;
  pstr->bgcol = (SDL_Color){0, 0, 0, 0};
  pNewWidget =
      create_iconlabel(NULL, pLabelWindow->dst, pstr,
                       (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));
  add_to_gui_list(ID_LABEL, pNewWidget);

  area.w =
      MAX(area.w, pNewWidget->size.w + (adj_size(60) - (pLabelWindow->size.w -
                                                        pLabelWindow->area.w)));
  area.h += pNewWidget->size.h +
            (adj_size(30) - (pLabelWindow->size.w - pLabelWindow->area.w));

  resize_window(pLabelWindow, NULL, &bg_color,
                (pLabelWindow->size.w - pLabelWindow->area.w) + area.w,
                (pLabelWindow->size.h - pLabelWindow->area.h) + area.h);

  area = pLabelWindow->area;

  widget_set_position(pLabelWindow,
                      (main_window_width() - pLabelWindow->size.w) / 2,
                      (main_window_height() - pLabelWindow->size.h) / 2);

  widget_set_area(pNewWidget, area);
  widget_set_position(pNewWidget, area.x + (area.w - pNewWidget->size.w) / 2,
                      area.y + (area.h - pNewWidget->size.h) / 2);

  redraw_group(pNewWidget, pLabelWindow, TRUE);
  flush_dirty();

  srvrs = sdl_create_server_list(lan_scan);

  pServer_list = server_list_new();
  fc_allocate_mutex(&srvrs->mutex);
  server_list_iterate(srvrs->servers, pserver) {
    server_list_append(pServer_list, pserver);
  }
  server_list_iterate_end;
  fc_release_mutex(&srvrs->mutex);

  popdown_window_group_dialog(pNewWidget, pLabelWindow);

  meswin_dialog_popup(TRUE);

  if (!pServer_list) {
    if (lan_scan) {
      output_window_append(ftc_client, _(""No LAN servers found""));
    } else {
      output_window_append(ftc_client, _(""No public servers found""));
    }
    set_client_page(PAGE_NETWORK);
    return;
  }

  pMeta_Server = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pWindow = create_window_skeleton(NULL, NULL, 0);
  pWindow->action = meta_server_window_callback;
  set_wstate(pWindow, FC_WS_NORMAL);
  clear_wflag(pWindow, WF_DRAW_FRAME_AROUND_WIDGET);
  if (lan_scan) {
    add_to_gui_list(ID_LAN_SERVERS_WINDOW, pWindow);
  } else {
    add_to_gui_list(ID_META_SERVERS_WINDOW, pWindow);
  }
  pMeta_Server->pEndWidgetList = pWindow;

  area = pWindow->area;

  pNewWidget = create_themeicon_button_from_chars(
      current_theme->CANCEL_Icon, pWindow->dst, _(""Cancel""), adj_font(14), 0);
  pNewWidget->action = exit_meta_server_dlg_callback;
  set_wstate(pNewWidget, FC_WS_NORMAL);
  add_to_gui_list(ID_BUTTON, pNewWidget);

  server_list_iterate(pServer_list, pServer) {

    fc_snprintf(cBuf, sizeof(cBuf), _(""%s Port %d Ver: %s %s %s %d\n%s""),
                pServer->host, pServer->port, pServer->version,
                _(pServer->state), Q_(""?header:Players""), pServer->nplayers,
                pServer->message);

    pNewWidget = create_iconlabel_from_chars(
        NULL, pWindow->dst, cBuf, adj_font(10),
        WF_FREE_STRING | WF_DRAW_TEXT_LABEL_WITH_SPACE | WF_RESTORE_BACKGROUND);

    pNewWidget->string_utf8->style |= SF_CENTER;
    pNewWidget->string_utf8->bgcol = (SDL_Color){0, 0, 0, 0};

    pNewWidget->action = select_meta_servers_callback;
    set_wstate(pNewWidget, FC_WS_NORMAL);
    pNewWidget->data.ptr = (void *)pServer;

    add_to_gui_list(ID_BUTTON, pNewWidget);

    w = MAX(w, pNewWidget->size.w);
    h = MAX(h, pNewWidget->size.h);
    count++;

    if (count > 10) {
      set_wflag(pNewWidget, WF_HIDDEN);
    }
  }
  server_list_iterate_end;

  if (!count) {
    if (lan_scan) {
      output_window_append(ftc_client, _(""No LAN servers found""));
    } else {
      output_window_append(ftc_client, _(""No public servers found""));
    }
    set_client_page(PAGE_NETWORK);
    return;
  }

  pMeta_Server->pBeginWidgetList = pNewWidget;
  pMeta_Server->pBeginActiveWidgetList = pMeta_Server->pBeginWidgetList;
  pMeta_Server->pEndActiveWidgetList = pMeta_Server->pEndWidgetList->prev->prev;
  pMeta_Server->pActiveWidgetList = pMeta_Server->pEndActiveWidgetList;

  if (count > 10) {
    meta_h = 10 * h;

    count = create_vertical_scrollbar(pMeta_Server, 1, 10, TRUE, TRUE);
    w += count;
  } else {
    meta_h = count * h;
  }

  w += adj_size(20);
  area2.h = meta_h;

  meta_h +=
      pMeta_Server->pEndWidgetList->prev->size.h + adj_size(10) + adj_size(20);

  pLogo = theme_get_background(theme, BACKGROUND_CONNECTDLG);
  if (resize_window(pWindow, pLogo, NULL, w, meta_h)) {
    FREESURFACE(pLogo);
  }

  area = pWindow->area;

  widget_set_position(pWindow, (main_window_width() - w) / 2,
                      (main_window_height() - meta_h) / 2);

  w -= adj_size(20);

  area2.w = w + 1;

  if (pMeta_Server->pScroll) {
    w -= count;
  }

  pNewWidget = pWindow->prev;
  pNewWidget->size.x = area.x + area.w - pNewWidget->size.w - adj_size(10);
  pNewWidget->size.y = area.y + area.h - pNewWidget->size.h - adj_size(10);

  pNewWidget = pNewWidget->prev;

  pNewWidget->size.x = area.x + adj_size(10);
  pNewWidget->size.y = area.y + adj_size(10);
  pNewWidget->size.w = w;
  pNewWidget->size.h = h;
  pNewWidget = convert_iconlabel_to_themeiconlabel2(pNewWidget);

  pNewWidget = pNewWidget->prev;
  while (pNewWidget) {
    pNewWidget->size.w = w;
    pNewWidget->size.h = h;
    pNewWidget->size.x = pNewWidget->next->size.x;
    pNewWidget->size.y = pNewWidget->next->size.y + pNewWidget->next->size.h;
    pNewWidget = convert_iconlabel_to_themeiconlabel2(pNewWidget);

    if (pNewWidget == pMeta_Server->pBeginActiveWidgetList) {
      break;
    }
    pNewWidget = pNewWidget->prev;
  }

  if (pMeta_Server->pScroll) {
    setup_vertical_scrollbar_area(
        pMeta_Server->pScroll, area.x + area.w - adj_size(6),
        pMeta_Server->pEndActiveWidgetList->size.y,
        area.h - adj_size(24) - pWindow->prev->size.h, TRUE);
  }

  widget_redraw(pWindow);

  area2.x = pMeta_Server->pEndActiveWidgetList->size.x;
  area2.y = pMeta_Server->pEndActiveWidgetList->size.y;

  fill_rect_alpha(pWindow->dst->surface, &area2, &bg_color);

  create_frame(pWindow->dst->surface, area2.x - 1, area2.y - 1, area2.w,
               area2.h, get_theme_color(COLOR_THEME_CONNECTDLG_INNERFRAME));

  redraw_group(pMeta_Server->pBeginWidgetList, pWindow->prev, 0);

  create_frame(pWindow->dst->surface, pWindow->size.x, pWindow->size.y,
               area.w - 1, area.h - 1,
               get_theme_color(COLOR_THEME_CONNECTDLG_FRAME));

  widget_flush(pWindow);
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the device sense data, indicating the current device state and error codes for the previously issued command."	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       SenseData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Compute the determinant of the geometry mapping Jacobian.	2	"static void compute_detJV_T(struct const_Multiarray_T *jacobian,
                            struct Multiarray_T *jacobian_det) {
  const int order_j = 3, order_dj = 1;

  const ptrdiff_t *exts_j = jacobian->extents;

  assert(jacobian_det->order == order_dj);
  assert(jacobian->order == order_j);
  assert(exts_j[1] == exts_j[2]);

  const ptrdiff_t n_vals = exts_j[0], d = exts_j[1];

  resize_Multiarray_T(jacobian_det, order_dj, (ptrdiff_t[]){n_vals});
  Type *j_det = jacobian_det->data;

  switch (d) {
  case 1: {
    const Type *x_r = &jacobian->data[compute_index_sub_container(
        order_j, 1, exts_j, (ptrdiff_t[]){0, 0})];
    for (ptrdiff_t i = 0; i < n_vals; ++i)
      j_det[i] = x_r[i];
    break;
  }
  case 2: {
    const Type *x_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 0})],
               *x_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 1})],
               *y_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 0})],
               *y_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 1})];
    for (ptrdiff_t i = 0; i < n_vals; ++i)
      j_det[i] = x_r[i] * y_s[i] - x_s[i] * y_r[i];
    break;
  }
  case 3: {
    const Type *x_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 0})],
               *x_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 1})],
               *x_t = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){0, 2})],
               *y_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 0})],
               *y_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 1})],
               *y_t = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){1, 2})],
               *z_r = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){2, 0})],
               *z_s = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){2, 1})],
               *z_t = &jacobian->data[compute_index_sub_container(
                   order_j, 1, exts_j, (ptrdiff_t[]){2, 2})];
    for (ptrdiff_t i = 0; i < n_vals; ++i) {
      j_det[i] = x_r[i] * (y_s[i] * z_t[i] - y_t[i] * z_s[i]) -
                 x_s[i] * (y_r[i] * z_t[i] - y_t[i] * z_r[i]) +
                 x_t[i] * (y_r[i] * z_s[i] - y_s[i] * z_r[i]);
    }
    break;
  }
  default:
    EXIT_ERROR(""Unsupported: %td\n"", d);
    break;
  }

  for (ptrdiff_t i = 0; i < n_vals; ++i) {
    const bool cond = (real_T(j_det[i]) > 0.0);
#ifndef NDEBUG
    if (!cond)
      print_Multiarray_T(jacobian_det);
#endif
    assert(cond);
  }
}"
Progyan1997-Spell-Checker-a478338/lib/dictionary.c	Loads dictionary into memory. Returns true if successful else false.	2	"bool load(const char *dictionary) {
  FILE *dict = fopen(dictionary, ""r"");
  if (dict == NULL) {
    return false;
  }

  char c;

  root = (node *)malloc(sizeof(node));
  *root = (node){false, {NULL}};

  node *trav = root;
  while ((c = fgetc(dict)) != EOF) {
    if (c != EOL) {
      int key = getkey(c);
      if (!trav->children[key]) {
        trav->children[key] = (node *)malloc(sizeof(node));
        *(trav->children[key]) = (node){false, {NULL}};
      }
      trav = trav->children[key];
    } else {
      trav->is_Word = true;
      trav = root;
      count++;
    }
  }

  fclose(dict);
  return true;
}"
bus1-dbus-broker-b41db8a/src/dbus/message.c	"message_stitch_sender() - stitch in new sender field : message to operate on : sender id to stitch in When the broker forwards messages, it needs to fill in the sender-field reliably. Unfortunately, this requires modifying the fields-array of the D-Bus header. Since we do not want to re-write the entire array, we allow some stitching magic here to happen. This means, we use some nice properties of tuple-arrays in the D-Bus marshalling (namely, they're 8-byte aligned, thus statically discoverable when we know the offset), and simply cut out the existing sender field and append a new one. This function must not be called more than once on any message (it will throw a fatal error). Furthermore, this will cut the message in parts, such that it is no longer readable linearly. However, none of the fields are relocated nor overwritten. That is, any cached pointer stays valid, though maybe no longer part of the actual message."	2	"void message_stitch_sender(Message *message, uint64_t sender_id) {
  size_t n, n_stitch, n_field, n_sender;
  const char *sender;
  void *end, *field;

  assert(message->parsed);
  assert(!message->vecs[1].iov_base && !message->vecs[1].iov_len);
  assert(!message->vecs[2].iov_base && !message->vecs[2].iov_len);

  sender = address_to_string(&(Address)ADDRESS_INIT_ID(sender_id));
  message->metadata.sender_id = sender_id;

  n_sender = strlen(sender);
  n_field = 1 + 3 + 4 + n_sender + 1;
  n_stitch = c_align8(n_field);

  assert(n_stitch <= sizeof(message->patch));
  assert(n_sender <= ADDRESS_ID_STRING_MAX);
  static_assert(1 + 3 + 4 + ADDRESS_ID_STRING_MAX + 1 <= sizeof(message->patch),
                ""Message patch buffer has insufficient size"");
  static_assert(alignof(message->patch) >= 8,
                ""Message patch buffer has insufficient alignment"");

  if (message->original_sender) {

    n = strlen(message->original_sender);
    end = (void *)message->header + c_align8(message->n_header);
    field = message->original_sender - (1 + 3 + 4);

    assert(message->original_sender >= (void *)message->header);
    assert(message->original_sender + n + 1 <= end);

    message->vecs[1].iov_base = field + c_align8(1 + 3 + 4 + n + 1);
    message->vecs[1].iov_len = message->vecs[0].iov_len;
    message->vecs[1].iov_len -=
        message->vecs[1].iov_base - message->vecs[0].iov_base;

    message->vecs[0].iov_len = field - message->vecs[0].iov_base;
  }

  message->vecs[2].iov_base = message->patch;
  message->vecs[2].iov_len = n_stitch;

  message->patch[0] = DBUS_MESSAGE_FIELD_SENDER;
  message->patch[1] = 1;
  message->patch[2] = 's';
  message->patch[3] = 0;
  if (message->big_endian)
    memcpy(message->patch + 4, (uint32_t[1]){htobe32(n_sender)},
           sizeof(uint32_t));
  else
    memcpy(message->patch + 4, (uint32_t[1]){htole32(n_sender)},
           sizeof(uint32_t));
  memcpy(message->patch + 8, sender, n_sender + 1);
  memset(message->patch + 8 + n_sender + 1, 0, n_stitch - n_field);

  message->n_header =
      message->vecs[0].iov_len + message->vecs[1].iov_len + n_field;
  message->n_data = c_align8(message->n_header) + message->n_body;

  if (message->big_endian)
    message->header->n_fields =
        htobe32(message->n_header - sizeof(*message->header));
  else
    message->header->n_fields =
        htole32(message->n_header - sizeof(*message->header));
}"
cnlohr-libsurvive-f26e88d/src/survive_api.c	Gets the velocity of a given object	2	"survive_timecode
survive_simple_object_get_latest_velocity(const SurviveSimpleObject *sao,
                                          SurviveVelocity *velocity) {
  uint32_t timecode = 0;
  OGLockMutex(sao->actx->poll_mutex);

  switch (sao->type) {
  case SurviveSimpleObject_LIGHTHOUSE:
    if (velocity)
      *velocity = (SurviveVelocity){};
    break;
  case SurviveSimpleObject_OBJECT:
    if (velocity)
      *velocity = sao->data.so->velocity;
    timecode = sao->data.so->velocity_timecode;
    break;
  case SurviveSimpleObject_EXTERNAL:
    if (velocity)
      *velocity = sao->data.seo.velocity;
    break;

  default: {
    SurviveContext *ctx = sao->actx->ctx;
    SV_ERROR(""Invalid object type %d"", sao->type);
  }
  }

  OGUnlockMutex(sao->actx->poll_mutex);
  return timecode;
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	"Soft Thresholding for floats (with strides) optr = ST(iptr, lambda)"	2	"void md_softthresh2(unsigned int D, const long dims[D], float lambda,
                    unsigned int flags, const long ostrs[D], float *optr,
                    const long istrs[D], const float *iptr) {
  NESTED(void, nary_softthresh, (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->softthresh(data->size, lambda, ptr[0], ptr[1]);
  };

  if (0 == flags) {

    optimized_twoop_oi(D, dims, ostrs, optr, istrs, iptr,
                       (size_t[2]){FL_SIZE, FL_SIZE}, nary_softthresh);
    return;
  }

  long norm_dims[D];
  md_select_dims(D, ~flags, norm_dims, dims);

  float *tmp_norm = md_alloc_sameplace(D, norm_dims, FL_SIZE, iptr);

  md_softthresh_core2(D, dims, lambda, flags, tmp_norm, ostrs, optr, istrs,
                      iptr);

  md_free(tmp_norm);
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  MPADecodeHeader c;
  int vbrtag_size = 0;
  MP3DecContext *mp3 = s->priv_data;
  int ret;

  ffio_init_checksum(s->pb, ff_crcA001_update, 0);

  v = avio_rb32(s->pb);

  ret = avpriv_mpegaudio_decode_header(&c, v);
  if (ret < 0)
    return ret;
  else if (ret == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  spf = c.lsf ? 576 : 1152;

  mp3->frames = 0;
  mp3->size = 0;

  mp3_parse_info_tag(s, st, &c, spf);
  mp3_parse_vbri_tag(s, st, base);

  if (!mp3->frames && !mp3->size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  if (mp3->frames)
    st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},
                                st->time_base);
  if (mp3->size && mp3->frames && !mp3->is_cbr)
    st->codecpar->bit_rate =
        av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);

  return 0;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the vector portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion qvector(const quaternion num) {
  const quaternion conj_num =
      (quaternion){num.R, num.i * -1.0, num.j * -1.0, num.k * -1.0};
  return (quaternion){(num.R - conj_num.R) * 0.5, (num.i - conj_num.i) * 0.5,
                      (num.j - conj_num.j) * 0.5, (num.k - conj_num.k) * 0.5};
}"
dm-vdo-kvdo-8df6805/vdo/base/readOnlyRebuild.c	"Append an array of recovery journal entries from a journal block sector to the array of numbered mappings in the rebuild completion, numbering each entry in the order they are appended."	2	"static void appendSectorEntries(ReadOnlyRebuildCompletion *rebuild,
                                PackedJournalSector *sector,
                                JournalEntryCount entryCount) {
  for (JournalEntryCount i = 0; i < entryCount; i++) {
    RecoveryJournalEntry entry =
        unpackRecoveryJournalEntry(&sector->entries[i]);
    int result = validateRecoveryJournalEntry(rebuild->vdo, &entry);
    if (result != VDO_SUCCESS) {

      continue;
    }

    if (isIncrementOperation(entry.operation)) {
      rebuild->entries[rebuild->entryCount] = (NumberedBlockMapping){
          .blockMapSlot = entry.slot,
          .blockMapEntry = packPBN(entry.mapping.pbn, entry.mapping.state),
          .number = rebuild->entryCount,
      };
      rebuild->entryCount++;
    }
  }
}"
CANBus-Triple-CANBus-Triple-0637551/avr/bootloaders/caterina/LUFA-111009/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size."	1	"uint8_t
MS_Host_ReadDeviceCapacity(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                           const uint8_t LUNIndex,
                           SCSI_Capacity_t *const DeviceCapacity) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = CPU_TO_LE32(sizeof(SCSI_Capacity_t)),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       DeviceCapacity)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  DeviceCapacity->Blocks = BE32_TO_CPU(DeviceCapacity->Blocks);
  DeviceCapacity->BlockSize = BE32_TO_CPU(DeviceCapacity->BlockSize);

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
GargoyleSoftware-voip-client-ios-134091a/submodules/externals/ffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);
    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open(st->codec, codec);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < 20 &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      if (st->time_base.den > 0 &&
          av_rescale_q(st->info->codec_info_duration, st->time_base,
                       AV_TIME_BASE_Q) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING, ""max_analyze_duration reached\n"");
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))
      try_decode_frame(st, pkt);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample)
        st->codec->codec_tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }

  av_estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
sommer-veins-e2fc63e/src/veins/base/connectionManager/NicEntryDebug.h	"This checks the list of free in gates, if one is available it is returned. Otherwise, a new in gate is added to the nic."	2	"public:
NicEntryDebug(cComponent *owner)
    : NicEntry(owner), inCnt(0), outCnt(0), checkFreeGates(true){};

~NicEntryDebug() override {}

void connectTo(NicEntry *other) override;

void disconnectFrom(NicEntry *other) override;
}
;
}"
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power state notify command and testing the received values.	3	"void arm_scmi_custom_test_power_state_notify(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter != NO_INVALID_PARAM) {

    test_case->parameter_count = 1;

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_state_notify,
                                       domain_id)] =
        power_protocol_data.num_power_domains;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    test_case->parameter_count = 2;

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {

      if (!arm_scmi_get_norm_bits(power_protocol_data.attributes[domain_id],
                                  POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_HIGH,
                                  POWER_DOMAIN_ATTR_STATE_NOTIFICATIONS_LOW))
        continue;
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_state_notify,
                                         domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description),
               ""\n\t\tPOWER DOMAIN ID: %d, NOTIFY ENABLE: %d"", domain_id,
               test_case->parameters[OFFSET_PARAM(
                   struct arm_scmi_power_state_notify, notify_enable)]);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                            test_case, &received);
    }
  }
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the versor the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_float qversorf(const quaternion_float num) {
  const quaternion_float conj_num =
      (quaternion_float){num.R, num.i * -1.0F, num.j * -1.0F, num.k * -1.0F};
  return qdivf(num, conj_num);
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/decode.c	Set various frame properties from the codec context / packet data.	2	"int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame) {
  const AVPacket *pkt = avctx->internal->last_pkt_props;
  int i;
  static const struct {
    enum AVPacketSideDataType packet;
    enum AVFrameSideDataType frame;
  } sd[] = {
      {AV_PKT_DATA_REPLAYGAIN, AV_FRAME_DATA_REPLAYGAIN},
      {AV_PKT_DATA_DISPLAYMATRIX, AV_FRAME_DATA_DISPLAYMATRIX},
      {AV_PKT_DATA_SPHERICAL, AV_FRAME_DATA_SPHERICAL},
      {AV_PKT_DATA_STEREO3D, AV_FRAME_DATA_STEREO3D},
      {AV_PKT_DATA_AUDIO_SERVICE_TYPE, AV_FRAME_DATA_AUDIO_SERVICE_TYPE},
      {AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
       AV_FRAME_DATA_MASTERING_DISPLAY_METADATA},
      {AV_PKT_DATA_CONTENT_LIGHT_LEVEL, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL},
      {AV_PKT_DATA_A53_CC, AV_FRAME_DATA_A53_CC},
  };

  if (pkt) {
    frame->pts = pkt->pts;
#if FF_API_PKT_PTS
    FF_DISABLE_DEPRECATION_WARNINGS
    frame->pkt_pts = pkt->pts;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif
    frame->pkt_pos = pkt->pos;
    frame->pkt_duration = pkt->duration;
    frame->pkt_size = pkt->size;

    for (i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
      int size;
      uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
      if (packet_sd) {
        AVFrameSideData *frame_sd =
            av_frame_new_side_data(frame, sd[i].frame, size);
        if (!frame_sd)
          return AVERROR(ENOMEM);

        memcpy(frame_sd->data, packet_sd, size);
      }
    }
    add_metadata_from_side_data(pkt, frame);

    if (pkt->flags & AV_PKT_FLAG_DISCARD) {
      frame->flags |= AV_FRAME_FLAG_DISCARD;
    } else {
      frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
    }
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (frame->colorspace == AVCOL_SPC_UNSPECIFIED)
    frame->colorspace = avctx->colorspace;
  if (frame->color_range == AVCOL_RANGE_UNSPECIFIED)
    frame->color_range = avctx->color_range;
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    frame->channels = avctx->channels;
    break;
  }
  return 0;
}"
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power state set command and testing the received values.	3	"void arm_scmi_custom_test_power_state_set(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_state_set, domain_id)) {

    test_case->parameter_count = 3;
    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_power_state_set, flags)] =
        0x0;
    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_power_state_set, domain_id)] =
        0;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_state_set,
                                       power_state)] = 0;

    switch (test_case->invalid_parameter) {
    case OFFSET_INVALID_PARAM(struct arm_scmi_power_state_set, domain_id):
      test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_state_set,
                                         domain_id)] =
          power_protocol_data.num_power_domains;
      break;
    }
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  }
}"
shwetasshinde24-Panoply-9a762c2/case-studies/h2o/src/H2oEnclave/h2omain/logconf.cpp	compiles a log configuration	2	"h2o_logconf_t *h2o_logconf_compile(const char *fmt, int escape, char *errbuf) {
  h2o_logconf_t *logconf = h2o_mem_alloc(sizeof(*logconf));
  const char *pt = fmt;
  size_t fmt_len = strlen(fmt);

  *logconf = (h2o_logconf_t){{}, escape};

#define LAST_ELEMENT() (logconf->elements.entries + logconf->elements.size - 1)

#define NEW_ELEMENT(ty)                                                        \
  do {                                                                         \
    h2o_vector_reserve(NULL, &logconf->elements, logconf->elements.size + 1);  \
    logconf->elements.size++;                                                  \
    *LAST_ELEMENT() = {};                                                      \
    LAST_ELEMENT()->type = ty;                                                 \
    LAST_ELEMENT()->suffix.base = h2o_mem_alloc(fmt_len + 1);                  \
  } while (0)

  while (*pt != '\0') {
    if (*pt == '%') {
      ++pt;
      if (*pt == '%') {

      } else if (*pt == '{') {
        const h2o_token_t *token;
        const char *quote_end = strchr(++pt, '}');
        if (quote_end == NULL) {
          sprintf(errbuf,
                  ""failed to compile log format: unterminated header name ""
                  ""starting at: \""%16s\"""",
                  pt);
          goto Error;
        }
        const char modifier = quote_end[1];
        switch (modifier) {
        case 'i':
        case 'o': {
          h2o_iovec_t name = strdup_lowercased(pt, quote_end - pt);
          token = h2o_lookup_token(name.base, name.len);
          if (token != NULL) {
            free(name.base);
            NEW_ELEMENT(modifier == 'i' ? ELEMENT_TYPE_IN_HEADER_TOKEN
                                        : ELEMENT_TYPE_OUT_HEADER_TOKEN);
            LAST_ELEMENT()->data.header_token = token;
          } else {
            NEW_ELEMENT(modifier == 'i' ? ELEMENT_TYPE_IN_HEADER_STRING
                                        : ELEMENT_TYPE_OUT_HEADER_STRING);
            LAST_ELEMENT()->data.name = name;
          }
        } break;
        case 't':
          if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""sec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_SEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""msec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_MSEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""usec""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_USEC_SINCE_EPOCH);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""msec_frac""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_MSEC_FRAC);
          } else if (h2o_memis(pt, quote_end - pt, H2O_STRLIT(""usec_frac""))) {
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_USEC_FRAC);
          } else {
            h2o_iovec_t name = h2o_strdup(NULL, pt, quote_end - pt);
            NEW_ELEMENT(ELEMENT_TYPE_TIMESTAMP_STRFTIME);
            LAST_ELEMENT()->data.name = name;
          }
          break;
        case 'x':
#define MAP_EXT_TO_TYPE(name, id)                                              \
  if (h2o_lcstris(pt, quote_end - pt, H2O_STRLIT(name))) {                     \
    NEW_ELEMENT(id);                                                           \
    goto MAP_EXT_Found;                                                        \
  }
#define MAP_EXT_TO_PROTO(name, cb)                                             \
  if (h2o_lcstris(pt, quote_end - pt, H2O_STRLIT(name))) {                     \
    NEW_ELEMENT(ELEMENT_TYPE_PROTOCOL_SPECIFIC);                               \
    LAST_ELEMENT()->data.protocol_specific_callback_index =                    \
        &((h2o_conn_callbacks_t *)NULL)->log_.cb -                             \
        ((h2o_conn_callbacks_t *)NULL)->log_.callbacks;                        \
    goto MAP_EXT_Found;                                                        \
  }
          MAP_EXT_TO_TYPE(""connection-id"", ELEMENT_TYPE_CONNECTION_ID);
          MAP_EXT_TO_TYPE(""connect-time"", ELEMENT_TYPE_CONNECT_TIME);
          MAP_EXT_TO_TYPE(""request-total-time"",
                          ELEMENT_TYPE_REQUEST_TOTAL_TIME);
          MAP_EXT_TO_TYPE(""request-header-time"",
                          ELEMENT_TYPE_REQUEST_HEADER_TIME);
          MAP_EXT_TO_TYPE(""request-body-time"", ELEMENT_TYPE_REQUEST_BODY_TIME);
          MAP_EXT_TO_TYPE(""process-time"", ELEMENT_TYPE_PROCESS_TIME);
          MAP_EXT_TO_TYPE(""response-time"", ELEMENT_TYPE_RESPONSE_TIME);
          MAP_EXT_TO_TYPE(""duration"", ELEMENT_TYPE_DURATION);
          MAP_EXT_TO_PROTO(""http1.request-index"", http1.request_index);
          MAP_EXT_TO_PROTO(""http2.stream-id"", http2.stream_id);
          MAP_EXT_TO_PROTO(""http2.priority.received"", http2.priority_received);
          MAP_EXT_TO_PROTO(""http2.priority.received.exclusive"",
                           http2.priority_received_exclusive);
          MAP_EXT_TO_PROTO(""http2.priority.received.parent"",
                           http2.priority_received_parent);
          MAP_EXT_TO_PROTO(""http2.priority.received.weight"",
                           http2.priority_received_weight);
          MAP_EXT_TO_PROTO(""http2.priority.actual"", http2.priority_actual);
          MAP_EXT_TO_PROTO(""http2.priority.actual.parent"",
                           http2.priority_actual_parent);
          MAP_EXT_TO_PROTO(""http2.priority.actual.weight"",
                           http2.priority_actual_weight);
          MAP_EXT_TO_PROTO(""ssl.protocol-version"", ssl.protocol_version);
          MAP_EXT_TO_PROTO(""ssl.session-reused"", ssl.session_reused);
          MAP_EXT_TO_PROTO(""ssl.cipher"", ssl.cipher);
          MAP_EXT_TO_PROTO(""ssl.cipher-bits"", ssl.cipher_bits);
          {
            h2o_iovec_t name = strdup_lowercased(pt, quote_end - pt);
            NEW_ELEMENT(ELEMENT_TYPE_EXTENDED_VAR);
            LAST_ELEMENT()->data.name = name;
          }
        MAP_EXT_Found:
#undef MAP_EXT_TO_TYPE
#undef MAP_EXT_TO_PROTO
          break;
        default:
          sprintf(errbuf, ""failed to compile log format: header name is not ""
                          ""followed by either `i`, `o`, `x`"");
          goto Error;
        }
        pt = quote_end + 2;
        continue;
      } else {
        unsigned type = NUM_ELEMENT_TYPES;
        switch (*pt++) {
#define TYPE_MAP(ch, ty)                                                       \
  case ch:                                                                     \
    type = ty;                                                                 \
    break
          TYPE_MAP('A', ELEMENT_TYPE_LOCAL_ADDR);
          TYPE_MAP('b', ELEMENT_TYPE_BYTES_SENT);
          TYPE_MAP('H', ELEMENT_TYPE_PROTOCOL);
          TYPE_MAP('h', ELEMENT_TYPE_REMOTE_ADDR);
          TYPE_MAP('l', ELEMENT_TYPE_LOGNAME);
          TYPE_MAP('m', ELEMENT_TYPE_METHOD);
          TYPE_MAP('p', ELEMENT_TYPE_LOCAL_PORT);
          TYPE_MAP('q', ELEMENT_TYPE_QUERY);
          TYPE_MAP('r', ELEMENT_TYPE_REQUEST_LINE);
          TYPE_MAP('s', ELEMENT_TYPE_STATUS);
          TYPE_MAP('t', ELEMENT_TYPE_TIMESTAMP);
          TYPE_MAP('U', ELEMENT_TYPE_URL_PATH);
          TYPE_MAP('u', ELEMENT_TYPE_REMOTE_USER);
          TYPE_MAP('V', ELEMENT_TYPE_AUTHORITY);
          TYPE_MAP('v', ELEMENT_TYPE_HOSTCONF);
#undef TYPE_MAP
        default:
          sprintf(errbuf,
                  ""failed to compile log format: unknown escape sequence: %%%c"",
                  pt[-1]);
          goto Error;
        }
        NEW_ELEMENT(type);
        continue;
      }
    }

    if (logconf->elements.size == 0)
      NEW_ELEMENT(ELEMENT_TYPE_EMPTY);
    LAST_ELEMENT()->suffix.base[LAST_ELEMENT()->suffix.len++] = *pt++;
  }

  if (logconf->elements.size == 0)
    NEW_ELEMENT(ELEMENT_TYPE_EMPTY);
  LAST_ELEMENT()->suffix.base[LAST_ELEMENT()->suffix.len++] = '\n';

#undef NEW_ELEMENT
#undef LAST_ELEMENT

  return logconf;

Error:
  h2o_logconf_dispose(logconf);
  return NULL;
}"
etri-cicn-nrs-440d6a7/ccnxlibs/libccnx-common/ccnx/common/codec/schema_v1/test/testrig_encoder.c	Finds a row in the truthtable where bodyManifest is FALSE and the indexOrKey equals 'key'.	2	"getTruthTableHeaderExtent(TruthTableEntry *ttentry, int key) {
  for (int i = 0; ttentry[i].indexOrKey != T_INVALID; i++) {
    if (!ttentry[i].bodyManifest && ttentry[i].indexOrKey == key) {
      return ttentry[i].extent;
    }
  }
  return (TlvExtent){0, 0};
}"
madhavanmalolan-ffmpegandroidlibrary-1d80ff9/ffmpegandroidlibrary/src/main/jni/ffmpeg/libavfilter/src_movie.c	Try to push a frame to the requested output.	2	"static int movie_push_frame(AVFilterContext *ctx, unsigned out_id) {
  MovieContext *movie = ctx->priv;
  AVPacket *pkt = &movie->pkt;
  enum AVMediaType frame_type;
  MovieStream *st;
  int ret, got_frame = 0, pkt_out_id;
  AVFilterLink *outlink;
  AVFrame *frame;

  if (!pkt->size) {
    if (movie->eof) {
      if (movie->st[out_id].done) {
        if (movie->loop_count != 1) {
          ret = rewind_file(ctx);
          if (ret < 0)
            return ret;
          movie->loop_count -= movie->loop_count > 1;
          av_log(ctx, AV_LOG_VERBOSE, ""Stream finished, looping.\n"");
          return 0;
        }
        return AVERROR_EOF;
      }
      pkt->stream_index = movie->st[out_id].st->index;

    } else {
      ret = av_read_frame(movie->format_ctx, &movie->pkt0);
      if (ret < 0) {
        av_init_packet(&movie->pkt0);
        *pkt = movie->pkt0;
        if (ret == AVERROR_EOF) {
          movie->eof = 1;
          return 0;
        }
        return ret;
      }
      *pkt = movie->pkt0;
    }
  }

  pkt_out_id = pkt->stream_index > movie->max_stream_index
                   ? -1
                   : movie->out_index[pkt->stream_index];
  if (pkt_out_id < 0) {
    av_free_packet(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
    return 0;
  }
  st = &movie->st[pkt_out_id];
  outlink = ctx->outputs[pkt_out_id];

  frame = av_frame_alloc();
  if (!frame)
    return AVERROR(ENOMEM);

  frame_type = st->st->codec->codec_type;
  switch (frame_type) {
  case AVMEDIA_TYPE_VIDEO:
    ret = avcodec_decode_video2(st->st->codec, frame, &got_frame, pkt);
    break;
  case AVMEDIA_TYPE_AUDIO:
    ret = avcodec_decode_audio4(st->st->codec, frame, &got_frame, pkt);
    break;
  default:
    ret = AVERROR(ENOSYS);
    break;
  }
  if (ret < 0) {
    av_log(ctx, AV_LOG_WARNING, ""Decode error: %s\n"", av_err2str(ret));
    av_frame_free(&frame);
    av_free_packet(&movie->pkt0);
    movie->pkt.size = 0;
    movie->pkt.data = NULL;
    return 0;
  }
  if (!ret || st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
    ret = pkt->size;

  pkt->data += ret;
  pkt->size -= ret;
  if (pkt->size <= 0) {
    av_free_packet(&movie->pkt0);
    pkt->size = 0;
    pkt->data = NULL;
  }
  if (!got_frame) {
    if (!ret)
      st->done = 1;
    av_frame_free(&frame);
    return 0;
  }

  frame->pts = av_frame_get_best_effort_timestamp(frame);
  ff_dlog(
      ctx, ""movie_push_frame(): file:'%s' %s\n"", movie->file_name,
      describe_frame_to_str((char[1024]){0}, 1024, frame, frame_type, outlink));

  if (st->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
    if (frame->format != outlink->format) {
      av_log(ctx, AV_LOG_ERROR, ""Format changed %s -> %s, discarding frame\n"",
             av_get_pix_fmt_name(outlink->format),
             av_get_pix_fmt_name(frame->format));
      av_frame_free(&frame);
      return 0;
    }
  }
  ret = ff_filter_frame(outlink, frame);

  if (ret < 0)
    return ret;
  return pkt_out_id == out_id;
}"
krattai-noo-ebs-00f67fd/ref_code/cjdns/benc/Dict.c	"Insert a Dictionary object into another dictionary. NOTE: This will not copy the given object, only add a pointer to it in the dictionary."	2	"Object *Dict_putDict(Dict *dictionary, const String *key, Dict *value,
                     struct Allocator *allocator) {
  if (key == NULL || value == NULL) {
    return NULL;
  }
  Object *v = Allocator_clone(allocator, (&(Object){.type = Object_DICT,

                                                    .as.dictionary = value}));
  return putObject(dictionary, key, v, allocator);
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Block Write command to the attached device, to write one or more data blocks to the storage medium from a buffer."	0	"uint8_t MassStore_WriteDeviceBlock(const uint8_t LUNIndex,
                                   const uint32_t BlockAddress,
                                   const uint8_t Blocks,
                                   const uint16_t BlockSize, void *BufferPtr) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = ((uint32_t)Blocks * BlockSize),
                 .Flags = COMMAND_DIRECTION_DATA_OUT,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 10},

      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_SendReceiveData(BufferPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_GetReturnedStatus()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
darktable-org-darktable-32fab21/src/iop/colorin.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_colorin_params_t tmp =
      (dt_iop_colorin_params_t){.type = DT_COLORSPACE_ENHANCED_MATRIX,
                                .filename = """",
                                .intent = DT_INTENT_PERCEPTUAL,
                                .normalize = DT_NORMALIZE_OFF,
                                .blue_mapping = 0,
                                .type_work = DT_COLORSPACE_LIN_REC2020,
                                .filename_work = """"};

  if (!module->dev || module->dev->image_storage.id <= 0)
    goto end;

  gboolean use_eprofile = FALSE;

  dt_image_t *img = dt_image_cache_get(darktable.image_cache,
                                       module->dev->image_storage.id, 'w');
  if (!img->profile) {
    char filename[PATH_MAX] = {0};
    gboolean from_cache = TRUE;
    dt_image_full_path(img->id, filename, sizeof(filename), &from_cache);
    const gchar *cc = filename + strlen(filename);
    for (; *cc != '.' && cc > filename; cc--)
      ;
    gchar *ext = g_ascii_strdown(cc + 1, -1);
    if (!strcmp(ext, ""jpg"") || !strcmp(ext, ""jpeg"")) {
      dt_imageio_jpeg_t jpg;
      if (!dt_imageio_jpeg_read_header(filename, &jpg)) {
        img->profile_size = dt_imageio_jpeg_read_profile(&jpg, &img->profile);
        use_eprofile = (img->profile_size > 0);
      }
    }
#ifdef HAVE_OPENJPEG
    else if (!strcmp(ext, ""jp2"") || !strcmp(ext, ""j2k"") ||
             !strcmp(ext, ""j2c"") || !strcmp(ext, ""jpc"")) {
      img->profile_size = dt_imageio_j2k_read_profile(filename, &img->profile);
      use_eprofile = (img->profile_size > 0);
    }
#endif
    else if ((!strcmp(ext, ""tif"") || !strcmp(ext, ""tiff"")) &&
             dt_imageio_is_ldr(filename)) {
      img->profile_size = dt_imageio_tiff_read_profile(filename, &img->profile);
      use_eprofile = (img->profile_size > 0);
    } else if (!strcmp(ext, ""png"")) {
      img->profile_size = dt_imageio_png_read_profile(filename, &img->profile);
      use_eprofile = (img->profile_size > 0);
    }
    g_free(ext);
  } else
    use_eprofile = TRUE;

  if (img->flags & DT_IMAGE_4BAYER)
    tmp.type = DT_COLORSPACE_LIN_REC709;
  else if (use_eprofile)
    tmp.type = DT_COLORSPACE_EMBEDDED_ICC;
  else if (module->dev->image_storage.colorspace == DT_IMAGE_COLORSPACE_SRGB)
    tmp.type = DT_COLORSPACE_SRGB;
  else if (module->dev->image_storage.colorspace ==
           DT_IMAGE_COLORSPACE_ADOBE_RGB)
    tmp.type = DT_COLORSPACE_ADOBERGB;
  else if (dt_image_is_ldr(&module->dev->image_storage))
    tmp.type = DT_COLORSPACE_SRGB;
  else if (!isnan(module->dev->image_storage.d65_color_matrix[0]))
    tmp.type = DT_COLORSPACE_EMBEDDED_MATRIX;

  dt_image_cache_write_release(darktable.image_cache, img,
                               DT_IMAGE_CACHE_RELAXED);

end:
  memcpy(module->params, &tmp, sizeof(dt_iop_colorin_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_colorin_params_t));
}"
Meulengracht-MollenOS-e48f4ab/librt/include/avxintrin.h	Constructs a 256-bit integer vector initialized with the specified 16-bit integral values. This intrinsic is a utility function and does not correspond to a specific instruction.	2	"_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00) {
  return __extension__(__m256i)(__v16hi){
      __w00, __w01, __w02, __w03, __w04, __w05, __w06, __w07,
      __w08, __w09, __w10, __w11, __w12, __w13, __w14, __w15};
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	"Constructs a quaternion from an array of four scalars. Note that the imaginary part of the quaternion comes from array elements 0, 1, and 2, and the real part comes from element 3."	2	"static inline SIMD_NONCONST simd_quatd simd_quaternion(const double xyzr[4]) {
  return (simd_quatd){*(const simd_packed_double4 *)xyzr};
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/testing/unit/test_unit_operators_tp.c	Provides unit tests for the construction of the standard operator from the tensor-product of the sub-operators.	2	"static void test_unit_construct_std_from_tp(struct Test_Info *const test_info,
                                            const char *const e_type) {
  sprintf(test_info->name, ""%s%s%s"", ""Operators - construct std from tp ("",
          e_type, "")"");

  bool pass = false;
  double *tol = NULL;
  bool *differences = NULL;

  const char *const file_name_full =
      set_data_file_name_unit(""operators/operators_tp"");

  char name_ops_tp[STRLEN_MIN] =
      {
          0,
      },
       name_op_std[STRLEN_MIN] = {
           0,
       };

  sprintf(name_ops_tp, ""%s%s"", e_type, ""_ops_tp"");
  sprintf(name_op_std, ""%s%s"", e_type, ""_op_std"");

  const struct const_Multiarray_Matrix_d *ops_tp_r =
      constructor_file_name_const_Multiarray_Matrix_d(name_ops_tp,
                                                      file_name_full);
  const struct const_Matrix_d *op_std_r =
      constructor_file_name_const_Matrix_d(name_op_std, file_name_full);
  const struct const_Matrix_d *op_std_c = constructor_op_std(ops_tp_r);

  destructor_const_Multiarray_Matrix_d(ops_tp_r);

  tol = (double[]){
      EPS,
  };
  differences = (bool[]){
      diff_const_Matrix_d(op_std_r, op_std_c, tol[0]),
  };
  if (check_diff(1, differences, &pass)) {
    if (differences[0])
      print_diff_const_Matrix_d(op_std_r, op_std_c, tol[0]);
  }
  assert_condition(pass);

  destructor_const_Matrix_d(op_std_r);
  destructor_const_Matrix_d(op_std_c);
}"
dm-vdo-kvdo-8df6805/vdo/kernel/errors.c	Register an error code block for stringError and stringErrorName.	2	"int registerErrorBlock(const char *blockName, int firstError,
                       int lastReservedError, const ErrorInfo *infos,
                       size_t infoSize) {
  int result = ASSERT(firstError < lastReservedError, ""bad error block range"");
  if (result != UDS_SUCCESS) {
    return result;
  }

  if (registeredErrors.count == registeredErrors.allocated) {

    return UDS_OVERFLOW;
  }

  for (ErrorBlock *block = registeredErrors.blocks;
       block < registeredErrors.blocks + registeredErrors.count; ++block) {
    if (strcmp(blockName, block->name) == 0) {
      return UDS_DUPLICATE_NAME;
    }

    if ((firstError < block->max) && (lastReservedError > block->base)) {
      return UDS_ALREADY_REGISTERED;
    }
  }

  registeredErrors.blocks[registeredErrors.count++] =
      (ErrorBlock){.name = blockName,
                   .base = firstError,
                   .last = firstError + (infoSize / sizeof(ErrorInfo)),
                   .max = lastReservedError,
                   .infos = infos};

  return UDS_SUCCESS;
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/ints.c	Allocates new integer with 4B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int32() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_32}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/source/update_client_hub.c	"The update client is driven by events in an atomic queue, the user need to call this function periodically to process events in the queue and hence move the client forward."	2	"arm_uc_error_t ARM_UC_HUB_ProcessEvents() {
  ARM_UC_ProcessQueue();

  return (arm_uc_error_t){ERR_NONE};
}"
Devronium-ConceptApplicationServer-22e4c1b/modules/standard.lib.cbor/src/cbor/arrays.c	Create new definite array	2	"cbor_item_t *cbor_new_definite_array(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  if (item == NULL) {
    return NULL;
  }

  cbor_item_t **data = _cbor_alloc_multiple(sizeof(cbor_item_t *), size);
  if (data == NULL) {
    _CBOR_FREE(item);
    return NULL;
  }
  size_t i;
  for (i = 0; i < size; i++)
    data[i] = NULL;

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_ARRAY,
      .metadata = {.array_metadata = {.type = _CBOR_METADATA_DEFINITE,
                                      .allocated = size,
                                      .end_ptr = 0}},
      .data = (unsigned char *)data};

  return item;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/array-list.c	"Creates a new array list whose contents are the given array of the given length. The array is copied, not referenced."	2	"ava_list_value ava_array_list_of_raw(const ava_value *restrict array,
                                     size_t length) {
  ava_array_list *al = ava_array_list_of_array(array, length, length);

  return (ava_list_value){ava_value_with_ulong(al, length)};
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Print the 's'tart/'e'nd of a solution/gradient piece to the file.	2	"(FILE *file, const char sp_type, const char se_type, const int pde_index,
 const struct Volume_Data_Vis *const vdv) {
  assert(sp_type == 's' || sp_type == 'p');
  assert(se_type == 's' || se_type == 'e');

  const struct const_Multiarray_d *sol = (vdv ? vdv->sol_p : NULL);
  const struct const_Multiarray_d *grad = (vdv ? vdv->grad_p : NULL);
  const struct const_Multiarray_d *rhs = (vdv ? vdv->rhs_p : NULL);
  const struct const_Multiarray_d *test_s = (vdv ? vdv->test_s_p : NULL);
  const struct const_Multiarray_d *sol_err_p = (vdv ? vdv->sol_err_p : NULL);
  if (sp_type == 'p') {
    if (se_type == 's') {
      fprint_vtk_Points(file, sp_type, NULL);
      fprintf_tn(file, 1, ""<PCells>"");
      fprintf_tn(file, 2,
                 ""<PDataArray type=\""Int32\"" Name=\""connectivity\"" ""
                 ""format=\""ascii\""/>"");
      fprintf_tn(
          file, 2,
          ""<PDataArray type=\""Int32\"" Name=\""offsets\"" format=\""ascii\""/>"");
      fprintf_tn(
          file, 2,
          ""<PDataArray type=\""UInt8\"" Name=\""types\"" format=\""ascii\""/>"");
      fprintf_tn(file, 1, ""</PCells>"");

      fprintf_tn(file, 1,
                 ""<PPointData Scalars=\""Scalars\"" Vectors=\""Vectors\"">"");
      const struct const_Multiarray_d dummy;
      fprint_vtk_piece_sol_scalar(file, sp_type, &dummy, ""index"");
      fprint_vtk_piece_sol_scalar(file, sp_type, &dummy, ""p_ref"");
      fprint_vtk_piece_sol_scalar(file, sp_type, &dummy, ""ml"");
      switch (pde_index) {
      case PDE_ADVECTION:
        fprint_vtk_piece_sol_scalar(file, sp_type, sol, ""u"");
        break;
      case PDE_DIFFUSION:
        fprint_vtk_piece_sol_scalar(file, sp_type, sol, ""u"");
        fprint_vtk_piece_grad_scalar(file, sp_type, grad);
        break;
      case PDE_EULER:
        fprint_vtk_piece_sol_euler(file, sp_type, sol, 's');
        if (vdv->has_analytical)
          fprint_vtk_piece_sol_euler(file, sp_type, sol_err_p, 'e');
        break;
      case PDE_NAVIER_STOKES:
        fprint_vtk_piece_sol_euler(file, sp_type, sol, 's');
        fprint_vtk_piece_grad_navier_stokes(file, sp_type, sol, grad);
        break;
      case PDE_BURGERS_INVISCID:
        assert(DIM == 1);
        fprint_vtk_piece_sol_scalar(file, sp_type, sol, ""u"");
        break;
      default:
        EXIT_ERROR(""Unsupported: %d\n"", pde_index);
        break;
      }
      if (rhs) {
        switch (pde_index) {
        case PDE_ADVECTION:
        case PDE_BURGERS_INVISCID:
        case PDE_DIFFUSION:
          fprint_vtk_piece_sol_scalar(file, sp_type, rhs, ""rhs_u"");
          break;
        case PDE_EULER:
        case PDE_NAVIER_STOKES:
          fprint_vtk_piece_other_euler(file, sp_type, rhs, ""rhs"");
          break;
        default:
          EXIT_ERROR(""Unsupported: %d\n"", pde_index);
          break;
        }
      }
      if (test_s) {
        switch (pde_index) {
        case PDE_ADVECTION:
        case PDE_BURGERS_INVISCID:
        case PDE_DIFFUSION:
          fprint_vtk_piece_sol_scalar(file, sp_type, test_s, ""test_s_u"");
          break;
        case PDE_EULER:
        case PDE_NAVIER_STOKES:
          fprint_vtk_piece_other_euler(file, sp_type, test_s, ""test_s"");
          break;
        default:
          EXIT_ERROR(""Unsupported: %d\n"", pde_index);
          break;
        }
      }

      fprintf_tn(file, 1, ""</PPointData>"");

      fprintf(file, ""\n"");
    } else if (se_type == 'e') {
      EXIT_UNSUPPORTED;
    }
  } else if (sp_type == 's') {
    if (se_type == 's') {
      const struct const_Multiarray_d *const xyz = vdv->xyz_p;
      const struct const_Plotting_Nodes *const p_nodes = vdv->p_nodes;

      const struct const_Multiarray_Vector_i *connect = p_nodes->connect;
      const struct const_Vector_i *vtk_types = p_nodes->vtk_types;

      fprintf(file, ""\n<Piece NumberOfPoints=\""%td\"" NumberOfCells=\""%td\"">\n"",
              xyz->extents[0], connect->extents[0]);
      fprint_vtk_Points(file, sp_type, xyz);

      fprintf_tn(file, 1, ""<Cells>"");
      fprintf_tn(
          file, 2,
          ""<DataArray type=\""Int32\"" Name=\""connectivity\"" format=\""ascii\"">"");
      fprint_const_Multiarray_Vector_i(file, 2, connect);
      fprintf_tn(file, 2, ""</DataArray>"");

      fprintf_tn(
          file, 2,
          ""<DataArray type=\""Int32\"" Name=\""offsets\"" format=\""ascii\"">"");
      fprint_const_Multiarray_Vector_i_offsets(file, 2, connect);
      fprintf_tn(file, 2, ""</DataArray>"");

      fprintf_tn(file, 2,
                 ""<DataArray type=\""UInt8\"" Name=\""types\"" format=\""ascii\"">"");
      fprint_const_Vector_i(file, 2, vtk_types);
      fprintf_tn(file, 2, ""</DataArray>"");
      fprintf_tn(file, 1, ""</Cells>"");

      fprintf_tn(file, 1,
                 ""<PointData Scalars=\""Scalars\"" Vectors=\""Vectors\"">"");

      struct Multiarray_i *const data_i = constructor_empty_Multiarray_i(
          sol->layout, 2, (ptrdiff_t[]){sol->extents[0], 1});

      set_to_value_Multiarray_i(data_i, vdv->index);
      fprint_vtk_piece_sol_scalar_i(
          file, sp_type, (struct const_Multiarray_i *)data_i, ""index"");

      set_to_value_Multiarray_i(data_i, vdv->p_ref);
      fprint_vtk_piece_sol_scalar_i(
          file, sp_type, (struct const_Multiarray_i *)data_i, ""p_ref"");

      set_to_value_Multiarray_i(data_i, vdv->ml);
      fprint_vtk_piece_sol_scalar_i(file, sp_type,
                                    (struct const_Multiarray_i *)data_i, ""ml"");

      destructor_Multiarray_i(data_i);

      switch (pde_index) {
      case PDE_ADVECTION:
      case PDE_BURGERS_INVISCID:
        fprint_vtk_piece_sol_scalar(file, sp_type, sol, ""u"");
        break;
      case PDE_DIFFUSION:
        fprint_vtk_piece_sol_scalar(file, sp_type, sol, ""u"");
        fprint_vtk_piece_grad_scalar(file, sp_type, grad);
        break;
      case PDE_EULER:
        fprint_vtk_piece_sol_euler(file, sp_type, sol, 's');
        if (vdv->has_analytical)
          fprint_vtk_piece_sol_euler(file, sp_type, sol_err_p, 'e');
        break;
      case PDE_NAVIER_STOKES:
        fprint_vtk_piece_sol_euler(file, sp_type, sol, 's');
        fprint_vtk_piece_grad_navier_stokes(file, sp_type, sol, grad);
        break;
      default:
        EXIT_ERROR(""Unsupported: %d\n"", pde_index);
        break;
      }
      if (rhs) {
        switch (pde_index) {
        case PDE_ADVECTION:
        case PDE_BURGERS_INVISCID:
        case PDE_DIFFUSION:
          fprint_vtk_piece_sol_scalar(file, sp_type, rhs, ""rhs_u"");
          break;
        case PDE_EULER:
        case PDE_NAVIER_STOKES:
          fprint_vtk_piece_other_euler(file, sp_type, rhs, ""rhs"");
          break;
        default:
          EXIT_ERROR(""Unsupported: %d\n"", pde_index);
          break;
        }
      }
      if (test_s) {
        switch (pde_index) {
        case PDE_ADVECTION:
        case PDE_BURGERS_INVISCID:
        case PDE_DIFFUSION:
          fprint_vtk_piece_sol_scalar(file, sp_type, test_s, ""test_u"");
          break;
        case PDE_EULER:
        case PDE_NAVIER_STOKES:
          fprint_vtk_piece_other_euler(file, sp_type, test_s, ""test_s"");
          break;
        default:
          EXIT_ERROR(""Unsupported: %d\n"", pde_index);
          break;
        }
      }
      fprintf_tn(file, 1, ""</PointData>"");
    } else if (se_type == 'e') {
      fprintf_tn(file, 0, ""</Piece>\n"");
    }
  }
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Construct a quaternion that rotates from one vector to another.	2	"static SIMD_NOINLINE simd_quatd simd_quaternion(simd_double3 from,
                                                simd_double3 to) {

  if (simd_dot(from, to) >= 0) {
    return _simd_quaternion_reduced(from, to);
  }

  simd_double3 half = simd_normalize(from + to);

  if (simd_length_squared(half) == 0) {

    simd_double3 abs_from = simd_abs(from);
    if (abs_from.x <= abs_from.y && abs_from.x <= abs_from.z)
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_double3){1, 0, 0})), 0.f);
    else if (abs_from.y <= abs_from.z)
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_double3){0, 1, 0})), 0.f);
    else
      return _simd_quaternion(
          simd_normalize(simd_cross(from, (simd_double3){0, 0, 1})), 0.f);
  }

  return simd_mul(_simd_quaternion_reduced(from, half),
                  _simd_quaternion_reduced(half, to));
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MouseHost/MouseHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process HID reports from the device and display the results onto the board LEDs."	1	"TASK(USB_Mouse_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = REQ_SetProtocol,
        .wValue = 0,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Protocol).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Mouse Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    ReadNextReport();

    break;
  }
}"
dm-vdo-kvdo-8df6805/vdo/base/slabSummary.c	Create a slab summary.	2	"int makeSlabSummary(PhysicalLayer *layer, Partition *partition,
                    const ThreadConfig *threadConfig,
                    unsigned int slabSizeShift,
                    BlockCount maximumFreeBlocksPerSlab,
                    ReadOnlyModeContext *readOnlyContext,
                    SlabSummary **slabSummaryPtr) {
  BlockCount blocksPerZone = getSlabSummaryZoneSize(VDO_BLOCK_SIZE);
  SlabCount entriesPerBlock = MAX_SLABS / blocksPerZone;
  int result = ASSERT((entriesPerBlock * blocksPerZone) == MAX_SLABS,
                      ""block size must be a multiple of entry size"");
  if (result != VDO_SUCCESS) {
    return result;
  }

  if (partition == NULL) {

    return VDO_SUCCESS;
  }

  SlabSummary *summary;
  result = ALLOCATE_EXTENDED(SlabSummary, threadConfig->physicalZoneCount,
                             SlabSummaryZone *, __func__, &summary);
  if (result != VDO_SUCCESS) {
    return result;
  }

  summary->zoneCount = threadConfig->physicalZoneCount;
  summary->readOnlyContext = readOnlyContext;
  summary->hintShift = (slabSizeShift > 6) ? (slabSizeShift - 6) : 0;
  summary->blocksPerZone = blocksPerZone;
  summary->entriesPerBlock = entriesPerBlock;
  initializeCompletion(&summary->completion, SLAB_SUMMARY_COMPLETION, layer);

  size_t totalEntries = MAX_SLABS * MAX_PHYSICAL_ZONES;
  size_t entryBytes = totalEntries * sizeof(SlabSummaryEntry);
  result = layer->allocateIOBuffer(layer, entryBytes, ""summary entries"",
                                   (char **)&summary->entries);
  if (result != VDO_SUCCESS) {
    freeSlabSummary(&summary);
    return result;
  }

  uint8_t hint = computeFullnessHint(summary, maximumFreeBlocksPerSlab);
  for (size_t i = 0; i < totalEntries; i++) {

    summary->entries[i] = (SlabSummaryEntry){
        .tailBlockOffset = 0,
        .fullnessHint = hint,
        .loadRefCounts = false,
        .isDirty = false,
    };
  }

  setSlabSummaryOrigin(summary, partition);
  PhysicalBlockNumber pbn = summary->origin;
  for (ZoneCount zone = 0; zone < summary->zoneCount; zone++) {
    result = makeSlabSummaryZone(summary, layer, zone,
                                 getPhysicalZoneThread(threadConfig, zone), pbn,
                                 summary->entries + (MAX_SLABS * zone));
    if (result != VDO_SUCCESS) {
      freeSlabSummary(&summary);
      return result;
    }
    pbn += blocksPerZone;
  }

  *slabSummaryPtr = summary;
  return VDO_SUCCESS;
}"
Funky-System-Funky-VM-b389879/src/libvm/instructions/instr_mem.c	Load Local Address. Pushes the address of a value relative to the markpointer.	2	"INSTR(ld_lref) {
  AJS_STACK(+1);
  USE_STACK();
  USE_MARK();
  *stack = (vm_value_t){.uint_value = state->mp + (GET_OPERAND_SIGNED() + 1) *
                                                      sizeof(vm_value_t),
                        .type = VM_TYPE_REF};
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/StillImageHost/StillImageHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to print device information through the serial port."	1	"TASK(USB_SImage_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if (USB_Host_SendControlRequest(NULL) != HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control error.\r\n""));

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Still Image Device Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    UpdateStatus(Status_Busy);

    puts_P(PSTR(""Retrieving Device Info...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(0),
        .Type = CType_CommandBlock,
        .Code = PIMA_OPERATION_GETDEVICEINFO,
        .TransactionID = 0x00000000,
        .Params = {},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_RecieveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);
      break;
    }

    uint16_t DeviceInfoSize =
        (PIMA_ReceivedBlock.DataLength - PIMA_COMMAND_SIZE(0));

    uint8_t DeviceInfo[DeviceInfoSize];

    SImage_ReadData(DeviceInfo, DeviceInfoSize);

    Pipe_ClearIN();

    uint8_t *DeviceInfoPos = DeviceInfo;

    DeviceInfoPos += 8;
    DeviceInfoPos += ((*DeviceInfoPos << 1) + 1);
    DeviceInfoPos += 2;
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));

    char Manufacturer[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, Manufacturer);
    printf_P(PSTR(""   Manufacturer: %s\r\n""), Manufacturer);

    DeviceInfoPos += ((*DeviceInfoPos << 1) + 1);

    char Model[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, Model);
    printf_P(PSTR(""   Model: %s\r\n""), Model);

    DeviceInfoPos += ((*DeviceInfoPos << 1) + 1);

    char DeviceVersion[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, DeviceVersion);
    printf_P(PSTR(""   Device Version: %s\r\n""), DeviceVersion);

    if ((ErrorCode = SImage_RecieveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);
      break;
    }

    if ((PIMA_ReceivedBlock.Type != CType_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);
      break;
    }

    puts_P(PSTR(""Opening Session...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(1),
        .Type = CType_CommandBlock,
        .Code = PIMA_OPERATION_OPENSESSION,
        .TransactionID = 0x00000000,
        .Params = {0x00000001},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_RecieveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);
      break;
    }

    if ((PIMA_ReceivedBlock.Type != CType_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);
      break;
    }

    puts_P(PSTR(""Closing Session...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(1),
        .Type = CType_CommandBlock,
        .Code = PIMA_OPERATION_CLOSESESSION,
        .TransactionID = 0x00000001,
        .Params = {0x00000001},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_RecieveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);
      break;
    }

    if ((PIMA_ReceivedBlock.Type != CType_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);
      break;
    }

    puts_P(PSTR(""Done.\r\n""));

    UpdateStatus(Status_USBReady);

    while (USB_IsConnected)
      ;

    break;
  }
}"
swift-nav-piksi_buildroot-ecbe46a/package/libpiksi/libpiksi/src/endpoint.c	Send a message from an endpoint. Create the message and flushes immediately.	2	"int pk_endpoint_send(pk_endpoint_t *pk_ept, const u8 *data,
                     const size_t length) {
  ASSERT_TRACE(pk_ept->type != PK_ENDPOINT_SUB &&
               pk_ept->type != PK_ENDPOINT_SUB_SERVER);

  int rc = -1;

  if (pk_ept->type == PK_ENDPOINT_PUB || pk_ept->type == PK_ENDPOINT_REQ) {
    client_context_t ctx = (client_context_t){
        .ept = pk_ept,
        .handle = pk_ept->sock,
        .poll_handle = NULL,
        .node = NULL,
    };
    rc = send_impl(&ctx, data, length);
  } else if (pk_ept->type == PK_ENDPOINT_PUB_SERVER ||
             pk_ept->type == PK_ENDPOINT_REP) {
    foreach_client(
        pk_ept, &rc,
        NESTED_FN(void,
                  (pk_endpoint_t * pk_ept, client_node_t * node, void *ctx), {
                    int *rc_loc = ctx;
                    *rc_loc = send_impl(&node->val, data, length);
                  }));
  }

  return rc;
}"
opticron-libuweave-2e5e385/src/settings.c	Writes settings to the storage provider.	2	"UwStatus uw_settings_write_to_storage_(UwSettings *settings) {
  uint8_t settings_buf[UW_SETTINGS_STORAGE_BUF_LEN];
  memset(settings_buf, 0, sizeof(settings_buf));

  int settings_count = 0;
  UwMapValue settings_items[1] = {{}};

  size_t name_len = strlen(settings->name);
  if (name_len > 0) {
    settings_items[settings_count++] = (UwMapValue){
        .key = uw_value_int(UW_SETTINGS_STORAGE_KEY_NAME),
        .value = uw_value_utf8_string_with_length(settings->name, name_len)};
  }

  UwValue settings_value = uw_value_map(settings_items, settings_count);

  CborEncoder encoder;
  cbor_encoder_init(&encoder, settings_buf, sizeof(settings_buf), 0);

  UwStatus encoding_status = uw_value_encode_value_(&encoder, &settings_value);
  if (!uw_status_is_success(encoding_status)) {
    UW_LOG_WARN(""Settings encoding failure: %d\n"", encoding_status);
    return encoding_status;
  }

  size_t settings_len = uwp_storage_size_align(encoder.ptr - settings_buf);

  UwStatus store_status =
      uwp_storage_put(kUwStorageFileNameSettings, settings_buf, settings_len);
  if (!uw_status_is_success(store_status)) {
    UW_LOG_WARN(""Error writing settings: %d\n"", store_status);
  }
  return store_status;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/adaptation/adaptation.c	Constructs the children of the current volume.	2	"(struct Adaptive_Solver_Volume *const a_s_vol_p,
 const struct Simulation *const sim) {
  const struct Volume *const vol_p = (struct Volume *)a_s_vol_p;

  const struct Solver_Element *s_e = (struct Solver_Element *)vol_p->element;
  const struct Adaptation_Element *a_e = &s_e->a_e;
  const struct Operator *const vv0_vv_vv =
      get_Multiarray_Operator(a_e->vv0_vv_vv, (ptrdiff_t[]){0, 0, 2, 1});

  const struct const_Multiarray_d *const xyz_ve_p2 =
      constructor_mm_NN1_Operator_const_Multiarray_d(vv0_vv_vv, vol_p->xyz_ve,
                                                     'R', 'd', 2, NULL);

  struct Intrusive_List *volumes_c =
      constructor_empty_IL(IL_VOLUME_SOLVER_ADAPTIVE, NULL);

  const int n_children = get_n_children(vol_p->element);
  for (int n = 1; n <= n_children; ++n) {

    push_back_IL(
        volumes_c,
        (struct Intrusive_Link *)constructor_Adaptive_Solver_Volume_h_ref(
            n, a_s_vol_p, xyz_ve_p2, sim));

    if (n == 1)
      a_s_vol_p->child_0 = volumes_c->first;
  }
  destructor_const_Multiarray_d(xyz_ve_p2);
  destructor_IL(volumes_c, false);
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Multiply two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qmull(const quaternion_long_double num1, const quaternion_long_double num2) {
  const long double tmp_r = (num2.R * num1.R) - (num2.i * num1.i) -
                            (num2.j * num1.j) - (num2.k * num1.k);
  const long double tmp_i = (num2.R * num1.i) + (num2.i * num1.R) -
                            (num2.j * num1.k) + (num2.k * num1.j);
  const long double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) +
                            (num2.j * num1.R) - (num2.k * num1.i);
  const long double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                            (num2.j * num1.i) + (num2.k * num1.R);
  return (quaternion_long_double){tmp_r, tmp_i, tmp_j, tmp_k};
}"
michele-segata-plexe-veins-ad1293a/src/veins/base/connectionManager/BaseConnectionManager.h	Reads init parameters and calculates a maximal interference distance.	2	"GridCoord() : x(0), y(0), z(0){};

GridCoord(int x, int y) : x(x), y(y), z(0){};

GridCoord(int x, int y, int z) : x(x), y(y), z(z){};

GridCoord(const GridCoord &o) {
  x = o.x;
  y = o.y;
  z = o.z;
}

GridCoord(const Coord &c, const Coord &gridCellSize = Coord(1.0, 1.0, 1.0)) {
  x = static_cast<int>(c.x / gridCellSize.x);
  y = static_cast<int>(c.y / gridCellSize.y);
  z = static_cast<int>(c.z / gridCellSize.z);
}

std::string info() const {
  std::stringstream os;
  os << ""("" << x << "","" << y << "","" << z << "")"";
  return os.str();
}

friend bool operator==(const GridCoord &a, const GridCoord &b) {
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

friend bool operator!=(const GridCoord &a, const GridCoord &b) {
  return !(a == b);
}
}
;

class CoordSet {
protected:
  std::vector<GridCoord *> data;

  unsigned maxSize;

  unsigned size;

  unsigned current;

protected:
  void insert(const GridCoord &c, unsigned pos) {
    if (data[pos] == 0) {
      data[pos] = new GridCoord(c);
      size++;
    }"
dm-vdo-kvdo-8df6805/vdo/base/refCounts.c	Reset all reference counts back to RS_FREE.	2	"void resetReferenceCounts(RefCounts *refCounts) {

  STATIC_ASSERT(sizeof(ReferenceCount) == 1);
  memset(refCounts->counters, 0, refCounts->blockCount);
  refCounts->freeBlocks = refCounts->blockCount;
  refCounts->slabJournalPoint = (JournalPoint){
      .sequenceNumber = 0,
      .entryCount = 0,
  };

  for (size_t i = 0; i < refCounts->referenceBlockCount; i++) {
    refCounts->blocks[i].allocatedCount = 0;
  }

  notifyAllWaiters(&refCounts->dirtyBlocks, clearDirtyReferenceBlocks, NULL);
}"
zooko-libzstr-80ce66c/zstr.c	"Read all remaining data from a stream (until EOF) into a zstr. This does nothing with the fp argument except call fread(), feof(), and ferror() on it, therefore it reads from whereever fp is currently set to the end of fp. It does not fclose() fp after it is done. This invokes realloc() multiple times as needed along the way. fp must not be NULL."	2	"z_slurp_stream(FILE *fp) {
  size_t res, bufsiz, space, len;
  zbyte *buf;

  len = 0;
  assert(fp != NULL);

  bufsiz = BUFINCREMENT + 1;
  buf = (zbyte *)malloc(bufsiz);
#ifdef Z_EXHAUST_EXIT
  CHECKMALLOCEXIT(buf);
#else
  if (buf == NULL) {
    return (zstr){0, NULL};
  }
#endif
  while (!feof(fp)) {
    runtime_assert(!ferror(fp), ""file error"");
    space = (bufsiz - 1) - len;
    if (space < (BUFINCREMENT / 2)) {
      bufsiz += BUFINCREMENT;
      buf = (zbyte *)realloc(buf, bufsiz);
#ifdef Z_EXHAUST_EXIT
      CHECKMALLOCEXIT(buf);
#else
      if (buf == NULL) {
        return (zstr){0, NULL};
      }
#endif
      space = (bufsiz - 1) - len;
    }
    res = fread(buf + len, sizeof(zbyte), space, fp);
    len += res;
  }
  assert(len < bufsiz);
  buf = (zbyte *)realloc(buf, len + 1);
#ifdef Z_EXHAUST_EXIT
  CHECKMALLOCEXIT(buf);
#else
  if (buf == NULL) {
    return (zstr){0, NULL};
  }
#endif
  buf[len] = '\0';
  return (zstr){len, buf};
}"
dragons-and-bytecode-magpie-game-4664c71/sources/context_store.c	"Stores the given value at the given key for the context, referenced via the given context id."	2	"void context_write(context_id context, context_key key, context_value value) {
  context_remove(context, key);
  grow_context_if_needed(&my_bags[index(context)]);

  my_bags[index(context)].entries[my_bags[index(context)].size++] =
      (context_entry){.key = key, .value = value};
}"
SiegeEngineers-aoc-builtin-rms-a341e7f/main.c	Parse a <map> XML element.	2	"static parse_map_result_t parse_map(ezxml_t node, custom_map_type_t type) {
  custom_map_t map = {.id = 0,
                      .name = NULL,
                      .string = -1,
                      .description = -1,
                      .ai_const_name = NULL,
                      .ai_symbol_name = NULL,
                      .type = type,
                      .scx_drs_id = -1};
  for (int i = 0; i < 50; i++) {
    map.terrains.terrains[i] = -1;
  }

  const char *id = ezxml_attr(node, ""id"");
  if (id == NULL) {
    return NoId;
  }
  map.id = atoi(id);
  if (map.id < 0) {
    map.id = 255 + (char)map.id;
  }
  if (map.id > 255) {
    return TooBigId;
  }

  const char *name = ezxml_attr(node, ""name"");
  if (name == NULL || strlen(name) < 1) {
    return NoName;
  }
  map.name = calloc(1, strlen(name) + 1);
  strcpy(map.name, name);

  const char *string = ezxml_attr(node, ""string"");
  if (string == NULL) {
    return NoStringId;
  }
  map.string = atoi(string);

  const char *drs_id = ezxml_attr(node, ""drsId"");
  if (drs_id == NULL) {
    return NoDrsId;
  }
  map.drs_id = atoi(drs_id);

  const char *scx_drs_id = ezxml_attr(node, ""scxDrsId"");
  if (scx_drs_id != NULL) {
    map.scx_drs_id = atoi(scx_drs_id);
  }

  const char *description = ezxml_attr(node, ""description"");
  if (description != NULL) {
    map.description = atoi(description);
  }

  const char *override = ezxml_attr(node, ""terrainOverrides"");
  if (override != NULL) {
    int result = parse_map_terrain_overrides(override, &map.terrains);
    if (result != 0) {
      return result;
    }
  }

  char const_name[80];
  char const_pattern[80];
  strcpy(const_pattern, ""%s"");
  if (type == RealWorld) {
    strcpy(const_pattern, ""real-world-%s"");
  } else if (type >= CustomSection) {
    char *prefix = custom_sections[type - CustomSection].ai_const_prefix;
    if (prefix != NULL) {
      sprintf(const_pattern, ""%s-%%s"", prefix);
    }
  }
  int const_len = sprintf(const_name, const_pattern, name);
  CharLowerBuffA(const_name, const_len);
  map.ai_const_name = calloc(1, const_len + 1);
  strcpy(map.ai_const_name, const_name);

  char symbol_name[100];
  char symbol_pattern[80];
  strcpy(symbol_pattern, ""%s"");
  if (type == RealWorld) {
    strcpy(symbol_pattern, ""REAL-WORLD-%s"");
  } else if (type >= CustomSection) {
    char *prefix = custom_sections[type - CustomSection].ai_symbol_prefix;
    if (prefix != NULL) {
      sprintf(symbol_pattern, ""%s-%%s"", prefix);
    }
  }
  int symbol_len = sprintf(symbol_name, symbol_pattern, name);
  CharUpperBuffA(symbol_name, symbol_len);
  map.ai_symbol_name = calloc(1, symbol_len + 1);
  strcpy(map.ai_symbol_name, symbol_name);

  printf(""[aoc-builtin-rms] Add modded map: %s\n"", map.name);
  size_t i = count_custom_maps();
  custom_maps[i] = map;
  custom_maps[i + 1] = (custom_map_t){0};
  return MapOk;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/solution/solution_T.c	Compute the coefficients associated with the values of the volume solution.	2	"(const struct Solver_Volume_T *s_vol, const struct const_Multiarray_T *sol_val,
 struct Multiarray_T *sol_coef) {
  const char op_format = 'd';

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Solution_Element *s_e =
      &((struct Solver_Element *)vol->element)->s_e;

  const int p_ref = s_vol->p_ref;

  const struct Operator *vc0_vs_vs = get_Multiarray_Operator(
      s_e->vc0_vs_vs, (ptrdiff_t[]){0, 0, p_ref, p_ref});

  resize_Multiarray_T(sol_coef, sol_val->order, sol_val->extents);
  mm_NN1C_Operator_Multiarray_T(vc0_vs_vs, sol_val, sol_coef, op_format,
                                sol_coef->order, NULL, NULL);
}"
mdhsl-FFmpeg-Pnacl-367670c/pnacl-ffmpeg-3.0.1/ffmpeg-3.0.1/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
                        &s->internal->parse_queue_end, 1);
    av_packet_unref(&out_pkt);
    if (ret < 0)
      goto fail;
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/numerical_flux/numerical_flux_euler_T.c	Version of compute_Numerical_Flux_fptr_T computing the numerical fluxes using the Lax-Friedrichs method. The implementation was copied from that of [Hesthaven et al.'s Nodal DG code][hest_lf].	2	"(const struct Numerical_Flux_Input_T *num_flux_i,
 struct mutable_Numerical_Flux_T *num_flux) {
  const ptrdiff_t NnTotal = num_flux_i->bv_l.s->extents[0];

  Type const *const nL = num_flux_i->bv_l.normals->data;

  Type const *const WL = num_flux_i->bv_l.s->data, *const WR =
                                                       num_flux_i->bv_r.s->data;

  Type *const nFluxNum = num_flux->nnf->data;

  Type const *rhoL_ptr = &WL[NnTotal * 0], *rhouL_ptr = &WL[NnTotal * 1],
             *EL_ptr = &WL[NnTotal * (DIM + 1)],

             *rhoR_ptr = &WR[NnTotal * 0], *rhouR_ptr = &WR[NnTotal * 1],
             *ER_ptr = &WR[NnTotal * (DIM + 1)];

  Type const *n_ptr = nL;

  struct Flux_Input_T *flux_i = malloc(sizeof *flux_i);
  flux_i->compute_member = num_flux_i->flux_i->compute_member;
  flux_i->s = constructor_move_const_Multiarray_T_T(
      'C', 2, (ptrdiff_t[]){1, NVR}, false, NULL);

  struct mutable_Flux_T flux;
  flux.f = constructor_move_Multiarray_T_T('C', 3, (ptrdiff_t[]){1, DIM, NEQ},
                                           false, NULL);

  Type *nF_ptr[NEQ];
  for (int eq = 0; eq < NEQ; eq++)
    nF_ptr[eq] = &nFluxNum[eq * NnTotal];

  if (DIM == 3) {
    Type const *rhovL_ptr = &WL[NnTotal * 2], *rhowL_ptr = &WL[NnTotal * 3],

               *rhovR_ptr = &WR[NnTotal * 2], *rhowR_ptr = &WR[NnTotal * 3];

    for (ptrdiff_t n = 0; n < NnTotal; n++) {

      Type const rhoL = *rhoL_ptr++, rhouL = *rhouL_ptr++, rhovL = *rhovL_ptr++,
                 rhowL = *rhowL_ptr++, EL = *EL_ptr++,

                 rhoL_inv = 1.0 / rhoL, uL = rhouL * rhoL_inv,
                 vL = rhovL * rhoL_inv, wL = rhowL * rhoL_inv,

                 V2L = uL * uL + vL * vL + wL * wL, VL = sqrt_T(V2L),

                 pL = GM1 * (EL - 0.5 * rhoL * V2L),
                 cL = sqrt_T(GAMMA * pL / rhoL);

      Type const rhoR = *rhoR_ptr++, rhouR = *rhouR_ptr++, rhovR = *rhovR_ptr++,
                 rhowR = *rhowR_ptr++, ER = *ER_ptr++,

                 rhoR_inv = 1.0 / rhoR, uR = rhouR * rhoR_inv,
                 vR = rhovR * rhoR_inv, wR = rhowR * rhoR_inv,

                 V2R = uR * uR + vR * vR + wR * wR, VR = sqrt_T(V2R),

                 pR = GM1 * (ER - 0.5 * rhoR * V2R),
                 cR = sqrt_T(GAMMA * pR / rhoR);

      Type const maxlL = VL + cL, maxlR = VR + cR;

      Type maxV;
      if (real_T(maxlL) > real_T(maxlR))
        maxV = maxlL;
      else
        maxV = maxlR;

      Type const n1 = *n_ptr++, n2 = *n_ptr++, n3 = *n_ptr++;

      Type WLn[] = {rhoL, rhouL, rhovL, rhowL, EL};
      Type FLn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WLn);
      flux.f->data = FLn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FL1_ptr = FLn, *FL2_ptr = FL1_ptr + 1, *FL3_ptr = FL2_ptr + 1;

      Type WRn[] = {rhoR, rhouR, rhovR, rhowR, ER};
      Type FRn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WRn);
      flux.f->data = FRn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FR1_ptr = FRn, *FR2_ptr = FR1_ptr + 1, *FR3_ptr = FR2_ptr + 1;

      for (int eq = 0; eq < NEQ; eq++) {
        *nF_ptr[eq]++ =
            0.5 *
            (n1 * ((*FL1_ptr) + (*FR1_ptr)) + n2 * ((*FL2_ptr) + (*FR2_ptr)) +
             n3 * ((*FL3_ptr) + (*FR3_ptr)) + maxV * (WLn[eq] - WRn[eq]));

        FL1_ptr += DIM;
        FL2_ptr += DIM;
        FL3_ptr += DIM;
        FR1_ptr += DIM;
        FR2_ptr += DIM;
        FR3_ptr += DIM;
      }
    }
  } else if (DIM == 2) {
    Type const *rhovL_ptr = &WL[NnTotal * 2],

               *rhovR_ptr = &WR[NnTotal * 2];

    for (ptrdiff_t n = 0; n < NnTotal; n++) {

      Type const rhoL = *rhoL_ptr++, rhouL = *rhouL_ptr++, rhovL = *rhovL_ptr++,
                 EL = *EL_ptr++,

                 rhoL_inv = 1.0 / rhoL, uL = rhouL * rhoL_inv,
                 vL = rhovL * rhoL_inv,

                 V2L = uL * uL + vL * vL, VL = sqrt_T(V2L),

                 pL = GM1 * (EL - 0.5 * rhoL * V2L),
                 cL = sqrt_T(GAMMA * pL / rhoL);

      Type const rhoR = *rhoR_ptr++, rhouR = *rhouR_ptr++, rhovR = *rhovR_ptr++,
                 ER = *ER_ptr++,

                 rhoR_inv = 1.0 / rhoR, uR = rhouR * rhoR_inv,
                 vR = rhovR * rhoR_inv,

                 V2R = uR * uR + vR * vR, VR = sqrt_T(V2R),

                 pR = GM1 * (ER - 0.5 * rhoR * V2R),
                 cR = sqrt_T(GAMMA * pR / rhoR);

      Type const maxlL = VL + cL, maxlR = VR + cR;

      Type maxV;
      if (real_T(maxlL) > real_T(maxlR))
        maxV = maxlL;
      else
        maxV = maxlR;

      Type const n1 = *n_ptr++, n2 = *n_ptr++;

      Type WLn[] = {rhoL, rhouL, rhovL, EL};
      Type FLn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WLn);
      flux.f->data = FLn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FL1_ptr = FLn, *FL2_ptr = FL1_ptr + 1;

      Type WRn[] = {rhoR, rhouR, rhovR, ER};
      Type FRn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WRn);
      flux.f->data = FRn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FR1_ptr = FRn, *FR2_ptr = FR1_ptr + 1;

      for (int eq = 0; eq < NEQ; eq++) {
        *nF_ptr[eq]++ =
            0.5 * (n1 * ((*FL1_ptr) + (*FR1_ptr)) +
                   n2 * ((*FL2_ptr) + (*FR2_ptr)) + maxV * (WLn[eq] - WRn[eq]));

        FL1_ptr += DIM;
        FL2_ptr += DIM;
        FR1_ptr += DIM;
        FR2_ptr += DIM;
      }
    }
  } else if (DIM == 1) {
    for (ptrdiff_t n = 0; n < NnTotal; n++) {

      Type const rhoL = *rhoL_ptr++, rhouL = *rhouL_ptr++, EL = *EL_ptr++,

                 rhoL_inv = 1.0 / rhoL, uL = rhouL * rhoL_inv,

                 V2L = uL * uL, VL = sqrt_T(V2L),

                 pL = GM1 * (EL - 0.5 * rhoL * V2L),
                 cL = sqrt_T(GAMMA * pL / rhoL);

      Type const rhoR = *rhoR_ptr++, rhouR = *rhouR_ptr++, ER = *ER_ptr++,

                 rhoR_inv = 1.0 / rhoR, uR = rhouR * rhoR_inv,

                 V2R = uR * uR, VR = sqrt_T(V2R),

                 pR = GM1 * (ER - 0.5 * rhoR * V2R),
                 cR = sqrt_T(GAMMA * pR / rhoR);

      Type const maxlL = VL + cL, maxlR = VR + cR;

      Type maxV;
      if (real_T(maxlL) > real_T(maxlR))
        maxV = maxlL;
      else
        maxV = maxlR;

      Type const n1 = *n_ptr++;

      Type WLn[] = {rhoL, rhouL, EL};
      Type FLn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WLn);
      flux.f->data = FLn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FL1_ptr = FLn;

      Type WRn[] = {rhoR, rhouR, ER};
      Type FRn[NEQ * DIM] = {0.0};
      const_cast_T1(&flux_i->s->data, WRn);
      flux.f->data = FRn;
      compute_Flux_T_euler(flux_i, &flux);

      Type const *FR1_ptr = FRn;

      for (int eq = 0; eq < NEQ; eq++) {
        *nF_ptr[eq]++ =
            0.5 * (n1 * ((*FL1_ptr) + (*FR1_ptr)) + maxV * (WLn[eq] - WRn[eq]));

        FL1_ptr += DIM;
        FR1_ptr += DIM;
      }
    }
  }
  destructor_const_Multiarray_T(flux_i->s);
  destructor_Multiarray_T(flux.f);
  free(flux_i);
}"
ARM-software-scmi-tests-24dd373/protocols/base/base_exe.c	The function is called by the test engine just before sending the command and testing the received data.	2	"void arm_scmi_custom_tester_base_disco_list_protocols(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  size_t offset;
  int error_code;
  uint32_t *skip;
  uint8_t index;
  uint8_t check;
  enum test_status res;
  uint32_t protocol_id;
  uint8_t *rcv_protocols;
  uint32_t num_protocols;
  uint32_t total_protocols =
      arm_scmi_base_protocol_data.num_protocols_implemented;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_base_discover_list_protocols,
                           skip)) {

    offset = OFFSET_FROM_INVALID(test_case->invalid_parameter);
    test_case->parameters[offset] = total_protocols + 1;
    error_code = arm_scmi_execute_and_assert_test_case(
        protocol_execution_context, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    offset = OFFSET_PARAM(struct arm_scmi_base_discover_list_protocols, skip);

    skip = &test_case->parameters[offset];
    *skip = 0;
    do {
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if ((error_code != NO_ERROR) || (received.status != SCMI_STATUS_SUCCESS))
        break;
      num_protocols =
          RETURN_VAL(received, struct arm_scmi_base_discover_list_protocols,
                     num_protocols);
      for (index = 0; index < num_protocols; ++index)
        *skip += 1;
    } while (*skip < total_protocols);
    if ((error_code != NO_ERROR) || (received.status != SCMI_STATUS_SUCCESS))
      return;

    res = (num_protocols == total_protocols);
    if (res == FAILED)
      snprintf(description, NUM_ELEMS(description),
               ""Expected: %d, Received: %d"", num_protocols, total_protocols);
    else
      snprintf(description, NUM_ELEMS(description), ""%d"", total_protocols);
    arm_scmi_log_test_result(&protocol_execution_context->test_stats, res,
                             ""NUMBER OF PROTOCOLS"", description);
    check = (LEFT_SHIFT(SUPPORTED_PROTOCOLS) & expected_flags_mask) != 0
                ? CHECK
                : PRINT;
    rcv_protocols = (uint8_t *)(&received.payload[OFFSET_RET(
        struct arm_scmi_base_discover_list_protocols, protocols)]);
    for (index = 0; index < num_protocols; ++index) {
      res = INFO;
      protocol_id = rcv_protocols[index];
      if (check == CHECK) {
        res = (protocol_id == base_expected->supported_protocols[index])
                  ? PASSED
                  : FAILED;
      }
      if (res == FAILED) {
        snprintf(description, NUM_ELEMS(description),
                 ""Expected: %d, Received: %d"",
                 base_expected->supported_protocols[index], protocol_id);
      } else if ((res == PASSED) || (res == INFO)) {
        snprintf(description, NUM_ELEMS(description), ""%d"", protocol_id);
      }
      arm_scmi_base_protocol_data.protocols[index] = protocol_id;
      arm_scmi_log_test_result(&protocol_execution_context->test_stats, res,
                               ""PROTOCOL ID"", description);
    }
  }
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/StillImage.c	Closes an already opened PIMA session with the attached device. This should be used after all session-orientated PIMA commands have been issued to the device.	2	"uint8_t SI_Host_CloseSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = 0x1003,
      .Params = {1},
  };

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SI_Host_ReceiveBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SIInterfaceInfo->State.IsSessionOpen = false;

  if ((PIMABlock.Type != PIMA_CONTAINER_ResponseBlock) ||
      (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  return PIPE_RWSTREAM_NoError;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/dg/compute_face_rlhs_dg.c	Version of compute_rlhs_f_fptr_T computing the lhs terms for 2nd order equations only.	2	"(const struct Numerical_Flux *const num_flux,
 struct DG_Solver_Face *const dg_s_face,
 struct Solver_Storage_Implicit *const ssi) {
  const struct Face *const face = (struct Face *)dg_s_face;

  finalize_lhs_2_f_dg((int[]){0, 0}, num_flux, dg_s_face, ssi);
  if (!face->boundary) {
    finalize_lhs_2_f_dg((int[]){0, 1}, num_flux, dg_s_face, ssi);

    for (int i = 0; i < 2; ++i) {
      const struct Neigh_Info_NF *n_i = &num_flux->neigh_info[i];
      permute_Multiarray_d_fc((struct Multiarray_d *)n_i->dnnf_dg, 'R', 1,
                              (struct Solver_Face *)face);
      scale_Multiarray_d((struct Multiarray_d *)n_i->dnnf_dg, -1.0);
    }

    finalize_lhs_2_f_dg((int[]){1, 0}, num_flux, dg_s_face, ssi);
    finalize_lhs_2_f_dg((int[]){1, 1}, num_flux, dg_s_face, ssi);
  }
}"
ADLINK-IST-opensplice-f7cff58/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c	"The function generates for the provided basic type a copyIn statement. The identification of the source and destination elements must be provided by the caller. Basic type elements, apart from string types, are assigned immediately. Strings are duplicated calling c_stringNew."	2	"idl_basicCaseType(idl_scope scope, const char *name, idl_typeBasic typeBasic,
                  const char *from_id, const char *to_id) {
  c_ulong maxlen;
  c_char *cid;

  cid = idl_cxxId(name);

  switch (idl_typeBasicType(typeBasic)) {
  case idl_short:
  case idl_ushort:
  case idl_long:
  case idl_ulong:
  case idl_longlong:
  case idl_ulonglong:
  case idl_float:
  case idl_double:
  case idl_char:
  case idl_boolean:
  case idl_octet:
    idl_fileOutPrintf(idl_fileCur(), ""        %s%s = (%s)%s%s();\n"", to_id, cid,
                      idl_typeFromTypeSpec(idl_typeSpec(typeBasic)), from_id,
                      cid);
    break;
  case idl_string:
    maxlen = idl_typeBasicMaxlen(typeBasic);

    idl_fileOutPrintf(idl_fileCur(), ""#ifdef %s\n"", BOUNDSCHECK);
    idl_fileOutPrintf(idl_fileCur(), ""    if(%s%s){\n"", from_id, cid);

    if (maxlen != 0) {
      idl_fileOutPrintf(idl_fileCur(), ""        if(strlen(%s%s) <= %u){\n"",
                        from_id, cid, maxlen);
      idl_fileOutPrintf(idl_fileCur(),
                        ""            %s%s = c_stringNew_s(base, %s%s);\n"",
                        to_id, cid, from_id, cid);
      idl_fileOutPrintf(idl_fileCur(), ""            if(%s%s == NULL) {\n"",
                        to_id, cid);
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 4);
      idl_fileOutPrintf(
          idl_fileCur(),
          ""                result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      idl_fileOutPrintf(idl_fileCur(), ""            }\n"");
      idl_fileOutPrintf(idl_fileCur(), ""        } else {\n"");
      idl_fileOutPrintf(idl_fileCur(), ""            "");
      idl_boundsCheckFail(MEMBER, scope, (idl_typeSpec)typeBasic, name);
      idl_fileOutPrintf(idl_fileCur(),
                        ""            result = V_COPYIN_RESULT_INVALID;\n"");
      idl_fileOutPrintf(idl_fileCur(), ""        }\n"");
    } else {
      idl_fileOutPrintf(idl_fileCur(),
                        ""        %s%s = c_stringNew_s(base, %s%s());\n"", to_id,
                        cid, from_id, cid);
      idl_fileOutPrintf(idl_fileCur(), ""        if(%s%s == NULL) {\n"", to_id,
                        cid);
      idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 3);
      idl_fileOutPrintf(
          idl_fileCur(),
          ""            result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
      idl_fileOutPrintf(idl_fileCur(), ""        }\n"");
    }
    idl_fileOutPrintf(idl_fileCur(), ""    } else {\n"");
    idl_fileOutPrintf(idl_fileCur(), ""        "");
    idl_boundsCheckFailNull(MEMBER, scope, (idl_typeSpec)typeBasic, name);
    idl_fileOutPrintf(idl_fileCur(),
                      ""        result = V_COPYIN_RESULT_INVALID;\n"");
    idl_fileOutPrintf(idl_fileCur(), ""    }\n"");
    idl_fileOutPrintf(idl_fileCur(), ""#else\n"");
    idl_fileOutPrintf(idl_fileCur(),
                      ""    %s%s = c_stringNew_s(base, %s%s());\n"", to_id, cid,
                      from_id, cid);
    idl_fileOutPrintf(idl_fileCur(), ""    if(%s%s == NULL) {\n"", to_id, cid);
    idl_memoryAllocFailed(scope, (idl_typeSpec)typeBasic, name, 2);
    idl_fileOutPrintf(idl_fileCur(),
                      ""        result = V_COPYIN_RESULT_OUT_OF_MEMORY;\n"");
    idl_fileOutPrintf(idl_fileCur(), ""    }\n"");
    idl_fileOutPrintf(idl_fileCur(), ""#endif\n"");
    break;
  default:
    printf(""idl_basicCaseType: Unexpected basic type\n"");
    break;
  }

  os_free(cid);
}"
hackpascal-openwrt-rtk-829a1a2/rtk_openwrt_src/target/linux/cns3xxx/files/drivers/usb/dwc/otg_cil.c	This function deactivates an EP. This is done by clearing the USB Active EP bit in the Device EP control register. Note: This function is not used for EP0. EP0 cannot be deactivated.	4	"void dwc_otg_ep_deactivate(dwc_otg_core_if_t *core_if, dwc_ep_t *ep) {
  depctl_data_t depctl = {.d32 = 0};
  volatile uint32_t *addr;
  daint_data_t daintmsk = {.d32 = 0};

  if (ep->is_in == 1) {
    addr = &core_if->dev_if->in_ep_regs[ep->num]->diepctl;
    daintmsk.ep.in = 1 << ep->num;
  } else {
    addr = &core_if->dev_if->out_ep_regs[ep->num]->doepctl;
    daintmsk.ep.out = 1 << ep->num;
  }

  depctl.d32 = dwc_read_reg32(addr);
  if (depctl.b.epena) {
    if (ep->is_in == 1) {
      diepint_data_t diepint;
      dwc_otg_dev_in_ep_regs_t *in_reg = core_if->dev_if->in_ep_regs[ep->num];

      depctl.d32 = dwc_read_reg32(&in_reg->diepctl);
      depctl.b.snak = 1;
      dwc_write_reg32(&in_reg->diepctl, depctl.d32);

      diepint.d32 = dwc_read_reg32(&in_reg->diepint);
      while (!diepint.b.inepnakeff) {
        udelay(1);
        diepint.d32 = dwc_read_reg32(&in_reg->diepint);
      }
      diepint.d32 = 0;
      diepint.b.inepnakeff = 1;
      dwc_write_reg32(&in_reg->diepint, diepint.d32);

      depctl.d32 = dwc_read_reg32(&in_reg->diepctl);
      depctl.b.snak = 1;
      depctl.b.epdis = 1;
      dwc_write_reg32(&in_reg->diepctl, depctl.d32);

      diepint.d32 = dwc_read_reg32(&in_reg->diepint);
      while (!diepint.b.epdisabled) {
        udelay(1);
        diepint.d32 = dwc_read_reg32(&in_reg->diepint);
      }
      diepint.d32 = 0;
      diepint.b.epdisabled = 1;
      dwc_write_reg32(&in_reg->diepint, diepint.d32);

      depctl.d32 = dwc_read_reg32(&in_reg->diepctl);
      depctl.b.epena = 0;
      depctl.b.epdis = 0;
      dwc_write_reg32(&in_reg->diepctl, depctl.d32);
    }
#if 0
 
 
		else {
			doepint_data_t doepint;
			dwc_otg_dev_out_ep_regs_t *out_reg=core_if->dev_if->out_ep_regs[ep->num];
			dctl_data_t dctl;
			gintsts_data_t gintsts;

			 
			dctl.d32 = dwc_read_reg32(&core_if->dev_if->dev_global_regs->dctl);
			dctl.b.sgoutnak=1;
			dwc_write_reg32(&core_if->dev_if->dev_global_regs->dctl,dctl.d32);

			 
			gintsts.d32=dwc_read_reg32(&core_if->core_global_regs->gintsts);
			while(!gintsts.b.goutnakeff){
				udelay(1);
				gintsts.d32=dwc_read_reg32(&core_if->core_global_regs->gintsts);
			}
			gintsts.d32=0;
			gintsts.b.goutnakeff=1;
			dwc_write_reg32 (&core_if->core_global_regs->gintsts, gintsts.d32);

			 
			depctl.d32=dwc_read_reg32(&out_reg->doepctl);
			depctl.b.snak=1;
			depctl.b.epdis=1;
			dwc_write_reg32(&out_reg->doepctl,depctl.d32);

			 
			doepint.d32=dwc_read_reg32(&out_reg->doepint);
			while(!doepint.b.epdisabled){
				udelay(1);
				doepint.d32=dwc_read_reg32(&out_reg->doepint);
			}
			doepint.d32=0;
			doepint.b.epdisabled=1;
			dwc_write_reg32(&out_reg->doepint,doepint.d32);

			 
			depctl.d32=dwc_read_reg32(&out_reg->doepctl);
			depctl.b.epena=0;
			depctl.b.epdis=0;
			dwc_write_reg32(&out_reg->doepctl,depctl.d32);
		}
#endif

    depctl.d32 = 0;
    depctl.b.usbactep = 0;

    if (ep->is_in == 0) {
      if (core_if->dma_enable || core_if->dma_desc_enable)
        depctl.b.epdis = 1;
    }

    dwc_write_reg32(addr, depctl.d32);
  }

  if (core_if->multiproc_int_enable) {
    dwc_modify_reg32(&core_if->dev_if->dev_global_regs->deachintmsk,
                     daintmsk.d32, 0);

    if (ep->is_in == 1) {
      dwc_write_reg32(
          &core_if->dev_if->dev_global_regs->diepeachintmsk[ep->num], 0);
    } else {
      dwc_write_reg32(
          &core_if->dev_if->dev_global_regs->doepeachintmsk[ep->num], 0);
    }
  } else {
    dwc_modify_reg32(&core_if->dev_if->dev_global_regs->daintmsk, daintmsk.d32,
                     0);
  }

  if (ep->is_in == 1) {
    DWC_DEBUGPL(DBG_PCD,
                ""DIEPCTL(%.8x)=%08x DIEPTSIZ=%08x, DIEPINT=%.8x, DIEPDMA=%.8x, ""
                ""DTXFSTS=%.8x\n"",
                (u32)&core_if->dev_if->in_ep_regs[ep->num]->diepctl,
                dwc_read_reg32(&core_if->dev_if->in_ep_regs[ep->num]->diepctl),
                dwc_read_reg32(&core_if->dev_if->in_ep_regs[ep->num]->dieptsiz),
                dwc_read_reg32(&core_if->dev_if->in_ep_regs[ep->num]->diepint),
                dwc_read_reg32(&core_if->dev_if->in_ep_regs[ep->num]->diepdma),
                dwc_read_reg32(&core_if->dev_if->in_ep_regs[ep->num]->dtxfsts));
    DWC_DEBUGPL(DBG_PCD, ""DAINTMSK=%08x GINTMSK=%08x\n"",
                dwc_read_reg32(&core_if->dev_if->dev_global_regs->daintmsk),
                dwc_read_reg32(&core_if->core_global_regs->gintmsk));
  } else {
    DWC_DEBUGPL(
        DBG_PCD,
        ""DOEPCTL(%.8x)=%08x DOEPTSIZ=%08x, DOEPINT=%.8x, DOEPDMA=%.8x\n"",
        (u32)&core_if->dev_if->out_ep_regs[ep->num]->doepctl,
        dwc_read_reg32(&core_if->dev_if->out_ep_regs[ep->num]->doepctl),
        dwc_read_reg32(&core_if->dev_if->out_ep_regs[ep->num]->doeptsiz),
        dwc_read_reg32(&core_if->dev_if->out_ep_regs[ep->num]->doepint),
        dwc_read_reg32(&core_if->dev_if->out_ep_regs[ep->num]->doepdma));

    DWC_DEBUGPL(DBG_PCD, ""DAINTMSK=%08x GINTMSK=%08x\n"",
                dwc_read_reg32(&core_if->dev_if->dev_global_regs->daintmsk),
                dwc_read_reg32(&core_if->core_global_regs->gintmsk));
  }
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/test_case/solution/solution_T.c	Compute the coefficients associated with the values of the volume gradient.	2	"(const struct Solver_Volume_T *s_vol, const struct const_Multiarray_T *grad_val,
 struct Multiarray_T *grad_coef) {
  const char op_format = 'd';

  struct Volume *vol = (struct Volume *)s_vol;
  const struct Solution_Element *s_e =
      &((struct Solver_Element *)vol->element)->s_e;

  const int p_ref = s_vol->p_ref;

  const struct Operator *vc0_vr_vr = get_Multiarray_Operator(
      s_e->vc0_vr_vr, (ptrdiff_t[]){0, 0, p_ref, p_ref});

  resize_Multiarray_T(grad_coef, grad_val->order, grad_val->extents);
  mm_NN1C_Operator_Multiarray_T(vc0_vr_vr, grad_val, grad_coef, op_format,
                                grad_coef->order, NULL, NULL);
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio_tls_openssl.c	Schedules the ALPN protocol callback.	2	"FIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,
                                 void *udata_connection) {
  if (!alpn || !alpn->on_selected)
    return;
  alpn_task_s *t = fio_malloc(sizeof(*t));
  *t = (alpn_task_s){
      .alpn = *alpn,
      .uuid = uuid,
      .udata_connection = udata_connection,
  };
  fio_defer(alpn_select___task, t, NULL);
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavcodec/utils.c	does needed setup of pkt_pts/pos and such for (re)get_buffer();	2	"int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame) {
  AVPacket *pkt = avctx->internal->pkt;

  if (pkt) {
    uint8_t *packet_sd;
    AVFrameSideData *frame_sd;
    int size;
    frame->pkt_pts = pkt->pts;
    av_frame_set_pkt_pos(frame, pkt->pos);
    av_frame_set_pkt_duration(frame, pkt->duration);
    av_frame_set_pkt_size(frame, pkt->size);

    packet_sd = av_packet_get_side_data(pkt, AV_PKT_DATA_REPLAYGAIN, &size);
    if (packet_sd) {
      frame_sd = av_frame_new_side_data(frame, AV_FRAME_DATA_REPLAYGAIN, size);
      if (!frame_sd)
        return AVERROR(ENOMEM);

      memcpy(frame_sd->data, packet_sd, size);
    }

    packet_sd = av_packet_get_side_data(pkt, AV_PKT_DATA_DISPLAYMATRIX, &size);
    if (packet_sd) {
      frame_sd =
          av_frame_new_side_data(frame, AV_FRAME_DATA_DISPLAYMATRIX, size);
      if (!frame_sd)
        return AVERROR(ENOMEM);

      memcpy(frame_sd->data, packet_sd, size);
    }

    packet_sd = av_packet_get_side_data(pkt, AV_PKT_DATA_STEREO3D, &size);
    if (packet_sd) {
      frame_sd = av_frame_new_side_data(frame, AV_FRAME_DATA_STEREO3D, size);
      if (!frame_sd)
        return AVERROR(ENOMEM);

      memcpy(frame_sd->data, packet_sd, size);
    }
  } else {
    frame->pkt_pts = AV_NOPTS_VALUE;
    av_frame_set_pkt_pos(frame, -1);
    av_frame_set_pkt_duration(frame, 0);
    av_frame_set_pkt_size(frame, -1);
  }
  frame->reordered_opaque = avctx->reordered_opaque;

  if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
    frame->color_primaries = avctx->color_primaries;
  if (frame->color_trc == AVCOL_TRC_UNSPECIFIED)
    frame->color_trc = avctx->color_trc;
  if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)
    av_frame_set_colorspace(frame, avctx->colorspace);
  if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)
    av_frame_set_color_range(frame, avctx->color_range);
  if (frame->chroma_location == AVCHROMA_LOC_UNSPECIFIED)
    frame->chroma_location = avctx->chroma_sample_location;

  switch (avctx->codec->type) {
  case AVMEDIA_TYPE_VIDEO:
    frame->format = avctx->pix_fmt;
    if (!frame->sample_aspect_ratio.num)
      frame->sample_aspect_ratio = avctx->sample_aspect_ratio;

    if (frame->width && frame->height &&
        av_image_check_sar(frame->width, frame->height,
                           frame->sample_aspect_ratio) < 0) {
      av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",
             frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den);
      frame->sample_aspect_ratio = (AVRational){0, 1};
    }

    break;
  case AVMEDIA_TYPE_AUDIO:
    if (!frame->sample_rate)
      frame->sample_rate = avctx->sample_rate;
    if (frame->format < 0)
      frame->format = avctx->sample_fmt;
    if (!frame->channel_layout) {
      if (avctx->channel_layout) {
        if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
            avctx->channels) {
          av_log(avctx, AV_LOG_ERROR,
                 ""Inconsistent channel ""
                 ""configuration.\n"");
          return AVERROR(EINVAL);
        }

        frame->channel_layout = avctx->channel_layout;
      } else {
        if (avctx->channels > FF_SANE_NB_CHANNELS) {
          av_log(avctx, AV_LOG_ERROR, ""Too many channels: %d.\n"",
                 avctx->channels);
          return AVERROR(ENOSYS);
        }
      }
    }
    av_frame_set_channels(frame, avctx->channels);
    break;
  }
  return 0;
}"
NVIDIA-AI-IOT-deepstream_reference_apps-3a8957b/yolo/plugins/gst-yoloplugin-tegra/gstyoloplugin.cpp	Attach metadata for the full frame. We will be adding a new metadata.	2	"attach_metadata_full_frame(GstYoloPlugin *yoloplugin, GstBuffer *inbuf,
                           gdouble scale_ratio, YoloPluginOutput *output,
                           guint batch_id) {
  NvDsMeta *dsmeta;
  NvDsFrameMeta *bbparams = (NvDsFrameMeta *)g_malloc0(sizeof(NvDsFrameMeta));

  bbparams->obj_params = (NvDsObjectParams *)g_malloc0(
      sizeof(NvDsObjectParams) * output->numObjects);

  bbparams->gie_type = 3;

  bbparams->nvosd_mode = MODE_HW;
  bbparams->batch_id = batch_id;

  static gchar font_name[] = ""Arial"";
  GST_DEBUG_OBJECT(yoloplugin, ""Attaching metadata %d\n"", output->numObjects);

  for (gint i = 0; i < output->numObjects; i++) {
    YoloPluginObject *obj = &output->object[i];
    NvDsObjectParams *obj_param = &bbparams->obj_params[i];
    NvOSD_RectParams &rect_params = obj_param->rect_params;
    NvOSD_TextParams &text_params = obj_param->text_params;

    rect_params.left = obj->left;
    rect_params.top = obj->top;
    rect_params.width = obj->width;
    rect_params.height = obj->height;

    rect_params.has_bg_color = 0;
    rect_params.bg_color = (NvOSD_ColorParams){1, 1, 0, 0.4};

    rect_params.border_width = 3;
    rect_params.border_color = (NvOSD_ColorParams){1, 0, 0, 1};

    rect_params.left /= scale_ratio;
    rect_params.top /= scale_ratio;
    rect_params.width /= scale_ratio;
    rect_params.height /= scale_ratio;
    GST_DEBUG_OBJECT(yoloplugin,
                     ""Attaching rect%d of batch%u""
                     ""  left->%u top->%u width->%u""
                     "" height->%u label->%s\n"",
                     i, batch_id, rect_params.left, rect_params.top,
                     rect_params.width, rect_params.height, obj->label);

    bbparams->num_rects++;

    obj_param->has_new_info = TRUE;

    strcpy(obj_param->attr_info[yoloplugin->unique_id].attr_label, obj->label);

    obj_param->attr_info[yoloplugin->unique_id].is_attr_label = 1;

    obj_param->tracking_id = -1;

    text_params.display_text = g_strdup(obj->label);

    text_params.x_offset = rect_params.left;
    text_params.y_offset = rect_params.top - 10;

    text_params.set_bg_clr = 1;
    text_params.text_bg_clr = (NvOSD_ColorParams){0, 0, 0, 1};

    text_params.font_params.font_name = font_name;
    text_params.font_params.font_size = 11;
    text_params.font_params.font_color = (NvOSD_ColorParams){1, 1, 1, 1};
    bbparams->num_strings++;
  }

  dsmeta = gst_buffer_add_nvds_meta(inbuf, bbparams, free_ds_meta);
  dsmeta->meta_type = NVDS_META_FRAME_INFO;
}"
dm-vdo-kvdo-8df6805/vdo/base/vioWrite.c	Continue the write path for a DataVIO now that block allocation is complete (the DataVIO may or may not have actually received an allocation). This callback is registered in continueWriteWithBlockMapSlot().	2	"static void continueWriteAfterAllocation(AllocatingVIO *allocatingVIO) {
  DataVIO *dataVIO = allocatingVIOAsDataVIO(allocatingVIO);
  if (abortOnError(dataVIOAsCompletion(dataVIO)->result, dataVIO,
                   NOT_READ_ONLY)) {
    return;
  }

  if (!hasAllocation(dataVIO)) {
    prepareForDedupe(dataVIOAsCompletion(dataVIO));
    return;
  }

  atomicStoreBool(&dataVIO->hasAllocation, true);
  dataVIO->newMapped = (ZonedPBN){
      .zone = allocatingVIO->zone,
      .pbn = allocatingVIO->allocation,
      .state = MAPPING_STATE_UNCOMPRESSED,
  };

  if (!isAsync(dataVIO)) {
    writeBlock(dataVIO);
    return;
  }

  setAllocatedZoneCallback(dataVIO, prepareForDedupe, THIS_LOCATION(NULL));
  if (vioRequiresFlushAfter(allocatingVIOAsVIO(allocatingVIO))) {
    invokeCallback(dataVIOAsCompletion(dataVIO));
    return;
  }

  acknowledgeWrite(dataVIO);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/structops.c	"The S.static, S.Static, and S.STATIC control macros. static sxt name [linkage-name] {option}* {option} ::= ""-n"" array-length | ""-t"" tail-length | ""-thread-local"" sxt is a bareword which must identify a struct symbol. name is a bareword. linkage-name is an A-string. array-length and tail-length are both barewords parsable as non-negative integers. array-length and tail-length cannot be specified together, and tail-length requires that the referenced structure has a tail field. linkage-name cannot be given for the private form. Semantics: A constant variable with the given name is defined. On read, it produces a strangelet referencing a statically-allocated (as per the S-bss, S-bss-a, and S-bss-t) instance or array of instances of sxt. The visibility is passed to the macro via the macro userdata."	4	"AVA_DEF_MACRO_SUBST(ava_intr_S_static_subst) {
  const ava_parse_unit *sxt_unit = NULL, *name_unit = NULL;
  const ava_parse_unit *linkage_name_unit = NULL;
  const ava_parse_unit *option_unit, *length_unit;
  ava_string sxt = AVA_ABSENT_STRING, name = AVA_ABSENT_STRING;
  ava_string linkage_name = AVA_ABSENT_STRING, option, length_str;
  ava_intr_S_static_type array_type;
  ava_intr_S_static *node;

  node = AVA_NEW(ava_intr_S_static);

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN {
      AVA_MACRO_ARG_CURRENT_UNIT(sxt_unit, ""struct"");
      AVA_MACRO_ARG_BAREWORD(sxt, ""struct"");

      node->struct_sym = ava_intr_structop_look_struct_sym_up(
          context, sxt, &sxt_unit->location);
      if (!node->struct_sym)
        return ava_macsub_silent_error_result(&provoker->location);

      AVA_MACRO_ARG_CURRENT_UNIT(name_unit, ""name"");
      AVA_MACRO_ARG_BAREWORD(name, ""name"");

      if (AVA_MACRO_ARG_HAS_ARG()) {
        AVA_MACRO_ARG_CURRENT_UNIT(linkage_name_unit, ""linkage-name"");
        if (ava_put_astring != linkage_name_unit->type) {
          linkage_name_unit = NULL;
        } else {
          linkage_name = linkage_name_unit->v.string;
          AVA_MACRO_ARG_CONSUME();
        }
      }

      while (AVA_MACRO_ARG_HAS_ARG()) {
        AVA_MACRO_ARG_CURRENT_UNIT(option_unit, ""option"");
        AVA_MACRO_ARG_BAREWORD(option, ""option"");

        if (ava_string_equal(ava_intr_S_static_thread_local_option, option)) {
          if (node->thr_local) {
            ava_macsub_record_error(context,
                                    ava_error_macro_arg_given_more_than_once(
                                        &option_unit->location,
                                        ava_intr_S_static_thread_local_option));
          } else {
            node->thr_local = ava_true;
          }
        } else if (ava_string_equal(AVA_ASCII9_STRING(""-n""), option) ||
                   ava_string_equal(AVA_ASCII9_STRING(""-t""), option)) {
          AVA_MACRO_ARG_CURRENT_UNIT(length_unit, ""length"");
          AVA_MACRO_ARG_BAREWORD(length_str, ""length"");

          if (ava_string_equal(AVA_ASCII9_STRING(""-n""), option))
            array_type = ava_isst_array;
          else
            array_type = ava_isst_tail;

          if (!node->struct_sym->v.sxt.def->is_composable &&
              ava_isst_array == array_type) {
            ava_macsub_record_error(
                context,
                ava_error_cannot_operate_array_of_noncomposable(
                    &option_unit->location, node->struct_sym->full_name));
          } else if (!ava_intr_structop_has_tail(node->struct_sym->v.sxt.def) &&
                     ava_isst_tail == array_type) {
            ava_macsub_record_error(
                context,
                ava_error_tail_operation_on_struct_without_tail(
                    &option_unit->location, node->struct_sym->full_name));
          } else if (array_type == node->type) {
            ava_macsub_record_error(
                context, ava_error_macro_arg_given_more_than_once(
                             &option_unit->location, option_unit->v.string));
          } else if (!ava_integer_try_parse(&node->array_length, length_str,
                                            -1) ||
                     node->array_length < 0 ||
                     node->array_length !=
                         (ava_integer)(size_t)node->array_length) {
            ava_macsub_record_error(context, ava_error_macro_arg_not_an_integer(
                                                 &length_unit->location,
                                                 AVA_ASCII9_STRING(""length"")));
          } else {
            node->type = array_type;
          }
        } else {
          AVA_STATIC_STRING(expected_options,
                            ""one of -thread-local, -t, or -n"");
          return ava_macsub_error_result(
              context, ava_error_bad_macro_keyword(&option_unit->location,
                                                   self->full_name, option,
                                                   expected_options));
        }
      }
    }
  }

  if (linkage_name_unit &&
      ava_v_private == *(const ava_visibility *)self->v.macro.userdata) {
    ava_macsub_record_error(context, ava_error_linkage_name_on_non_linked(
                                         &linkage_name_unit->location));
  }

  node->header.v = &ava_intr_S_static_vtable;
  node->header.context = context;
  node->header.location = provoker->location;
  node->var_sym = AVA_NEW(ava_symbol);
  node->var_sym->type = ava_st_global_variable;
  node->var_sym->level = ava_macsub_get_level(context);
  node->var_sym->visibility = *(const ava_visibility *)self->v.macro.userdata;
  node->var_sym->definer = (ava_ast_node *)node;
  node->var_sym->full_name = ava_macsub_apply_prefix(context, name);
  node->var_sym->v.var.is_mutable = ava_false;
  if (ava_string_is_present(linkage_name)) {
    node->var_sym->v.var.name.scheme = ava_nms_none;
    node->var_sym->v.var.name.name = linkage_name;
  } else {
    node->var_sym->v.var.name.scheme = ava_nms_ava;
    node->var_sym->v.var.name.name = node->var_sym->full_name;
  }

  ava_macsub_put_symbol(context, node->var_sym, &name_unit->location);

  return (ava_macro_subst_result){.status = ava_mss_done,
                                  .v.node = (ava_ast_node *)node};
}"
CloudVPS-opticon-f5fdbd7/src/libopticon/notify.c	Allocate and initialize a notification object	2	"notification *notification_create(void) {
  notification *res = (notification *)malloc(sizeof(notification));
  res->next = res->prev = NULL;
  res->status[0] = 0;
  res->isproblem = false;
  res->notified = false;
  res->hostid = (uuid){0ULL, 0ULL};
  res->lastchange = time(NULL);
  return res;
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m3/amffmpeg/libavformat/mp3dec.c	Try to find Xing/Info/VBRI tags and compute duration from info therein	2	"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base) {
  uint32_t v, spf;
  unsigned frames = 0;
  unsigned size = 0;
  const int64_t xing_offtbl[2][2] = {{32, 17}, {17, 9}};
  MPADecodeHeader c;
  int vbrtag_size = 0;

  v = avio_rb32(s->pb);
  if (ff_mpa_check_header(v) < 0)
    return -1;

  if (ff_mpegaudio_decode_header(&c, v) == 0)
    vbrtag_size = c.frame_size;
  if (c.layer != 3)
    return -1;

  avio_skip(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1]);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {
    v = avio_rb32(s->pb);
    if (v & 0x1)
      frames = avio_rb32(s->pb);
    if (v & 0x2)
      size = avio_rb32(s->pb);
  }

  avio_seek(s->pb, base + 4 + 32, SEEK_SET);
  v = avio_rb32(s->pb);
  if (v == MKBETAG('V', 'B', 'R', 'I')) {

    if (avio_rb16(s->pb) == 1) {

      avio_skip(s->pb, 4);
      size = avio_rb32(s->pb);
      frames = avio_rb32(s->pb);
    }
  }

  if (!frames && !size)
    return -1;

  avio_seek(s->pb, base + vbrtag_size, SEEK_SET);

  spf = c.lsf ? 576 : 1152;
  if (frames)
    st->duration =
        av_rescale_q(frames, (AVRational){spf, c.sample_rate}, st->time_base);
  if (size && frames)
    st->codec->bit_rate =
        av_rescale(size, 8 * c.sample_rate, frames * (int64_t)spf);

  return 0;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/StillImage.c	"Sends a given PIMA command to the attached device, filling out the PIMA command header's Transaction ID automatically."	0	"uint8_t SI_Host_SendCommand(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo,
                            const uint16_t Operation, const uint8_t TotalParams,
                            uint32_t *const Params) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return PIPE_RWSTREAM_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(TotalParams),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = Operation,
  };

  memcpy(&PIMABlock.Params, Params, sizeof(uint32_t) * TotalParams);

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
cochrane-GLLara-91ed369/shared_simd/simd_matrix.h	"Berechnet das Matrix-Produkt zweier Matrizen  Berechnet a*b im klassischen Sinne. Die Funktion geht davon aus, dass die Matrix in Column-Major-Order gespeichert ist. Falls nicht, muss die Ausfhrungsreihenfolge umgedreht werden."	2	"static inline mat_float16 simd_mat_mul(const mat_float16 a,
                                       const mat_float16 b) {
  return (mat_float16){simd_mat_vecmul(a, b.x), simd_mat_vecmul(a, b.y),
                       simd_mat_vecmul(a, b.z), simd_mat_vecmul(a, b.w)};
}"
boazsegev-iodine-b6bdf50/ext/iodine/http.c	Defers the request / response handling for later.	2	"void http_pause(http_s *h, void (*task)(http_pause_handle_s *http)) {
  if (HTTP_INVALID_HANDLE(h)) {
    return;
  }
  http_fio_protocol_s *p = (http_fio_protocol_s *)h->private_data.flag;
  http_vtable_s *vtbl = (http_vtable_s *)h->private_data.vtbl;
  http_pause_handle_s *http = fio_malloc(sizeof(*http));
  *http = (http_pause_handle_s){
      .uuid = p->uuid,
      .h = h,
      .udata = h->udata,
  };
  vtbl->http_on_pause(h, p);
  fio_defer(http_pause_wrapper, http, (void *)((uintptr_t)task));
}"
michele-segata-plexe-veins-ad1293a/src/veins/base/modules/BaseMobility.h	"Creates a random position for a host if the position is not given as a parameter in ""omnetpp.ini"". If the speed of the host is bigger than 0 a first MOVE_HOST self message is scheduled in stage 1"	2	"enum BorderPolicy { REFLECT, WRAP, PLACERANDOMLY, RAISEERROR };

enum BaseMobilityMsgKinds {
  MOVE_HOST = 21311,
  MOVE_TO_BORDER,

  LAST_BASE_MOBILITY_KIND,
};

enum BorderHandling {
  NOWHERE,
  X_SMALLER,
  X_BIGGER,
  Y_SMALLER,
  Y_BIGGER,
  Z_SMALLER,
  Z_BIGGER
};

protected:
BaseWorldUtility *world;

Move move;

const static simsignalwrap_t mobilityStateChangedSignal;

simtime_t updateInterval;

cMessage *moveMsg;

bool coreDebug;

bool scaleNodeByDepth;

double playgroundScaleX;

double playgroundScaleY;

double origDisplayWidth;

double origDisplayHeight;

double origIconSize;

public:
BaseMobility();
BaseMobility(unsigned stacksize);

virtual void handleMessage(cMessage *msg);

virtual void initialize(int);

virtual void finish(){};

virtual Coord getCurrentPosition() const { return move.getStartPos(); }

virtual Coord getCurrentOrientation() const { return move.getOrientation(); }"
boazsegev-iodine-b6bdf50/ext/iodine/fio_cli.c	Sets the argument's value as a NUL terminated C String (no copy!).	2	"void fio_cli_set(char const *name, char const *value) {
  cstr_s n = (cstr_s){.data = name, .len = strlen(name)};
  fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/floats_ctrls.c	Constructs a new float item The width cannot be changed once the item is created	2	"cbor_item_t *cbor_new_float4() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 4);
  *item = (cbor_item_t){
      .type = CBOR_TYPE_FLOAT_CTRL,
      .data = (unsigned char *)item + sizeof(cbor_item_t),
      .refcount = 1,
      .metadata = {.float_ctrl_metadata = {.width = CBOR_FLOAT_32}}};
  return item;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Sends a GET MAX LUN control request to the attached device, retrieving the index of the highest LUN (Logical UNit, a logical drive) in the device. This value can then be used in the other functions of the Mass Storage Host mode Class driver to address a specific LUN within the device."	1	"uint8_t MS_Host_GetMaxLUN(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          uint8_t *const MaxLUNIndex) {
  uint8_t ErrorCode = HOST_SENDCONTROL_Successful;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = MS_REQ_GetMaxLUN,
      .wValue = 0,
      .wIndex = MSInterfaceInfo->State.InterfaceNumber,
      .wLength = 1,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if ((ErrorCode = USB_Host_SendControlRequest(MaxLUNIndex)) !=
      HOST_SENDCONTROL_Successful) {
    *MaxLUNIndex = 0;
    ErrorCode = HOST_SENDCONTROL_Successful;
  }

  return ErrorCode;
}"
darktable-org-darktable-32fab21/src/iop/highlights.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *module) {
  dt_iop_highlights_params_t tmp =
      (dt_iop_highlights_params_t){.mode = DT_IOP_HIGHLIGHTS_CLIP,
                                   .blendL = 1.0,
                                   .blendC = 0.0,
                                   .blendh = 0.0,
                                   .clip = 1.0};

  if (!module->dev)
    goto end;

  if (dt_image_is_raw(&module->dev->image_storage))
    module->default_enabled = 1;
  else
    module->default_enabled = 0;

end:
  memcpy(module->params, &tmp, sizeof(dt_iop_highlights_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_highlights_params_t));
}"
tiglabs-jupiter-1fd7df0/dpdk/drivers/net/mlx5/mlx5_rxtx_vec_neon.h	Fill in buffer descriptors in a multi-packet send descriptor.	2	"txq_wr_dseg_v(struct mlx5_txq_data *txq, uint8_t *dseg, struct rte_mbuf **pkts,
              unsigned int n) {
  unsigned int pos;
  uintptr_t addr;
  const uint8x16_t dseg_shuf_m = {3,  2,  1,  0,  4,  5,  6, 7,
                                  15, 14, 13, 12, 11, 10, 9, 8};
#ifdef MLX5_PMD_SOFT_COUNTERS
  uint32_t tx_byte = 0;
#endif

  for (pos = 0; pos < n; ++pos, dseg += MLX5_WQE_DWORD_SIZE) {
    uint8x16_t desc;
    struct rte_mbuf *pkt = pkts[pos];

    addr = rte_pktmbuf_mtod(pkt, uintptr_t);
    desc = vreinterpretq_u8_u32(
        (uint32x4_t){DATA_LEN(pkt), mlx5_tx_mb2mr(txq, pkt), addr, addr >> 32});
    desc = vqtbl1q_u8(desc, dseg_shuf_m);
    vst1q_u8(dseg, desc);
#ifdef MLX5_PMD_SOFT_COUNTERS
    tx_byte += DATA_LEN(pkt);
#endif
  }
#ifdef MLX5_PMD_SOFT_COUNTERS
  txq->stats.obytes += tx_byte;
#endif
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the Mass Storage device's inquiry data for the specified LUN, indicating the device characteristics and properties."	0	"uint8_t MS_Host_GetInquiryData(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                               const uint8_t LUNIndex,
                               SCSI_Inquiry_Response_t *const InquiryData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Inquiry_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_INQUIRY, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Inquiry_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       InquiryData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Multiply two quaternion numbers	2	"LIB_FUNC MATH_FUNC quaternion qmul(const quaternion num1,
                                   const quaternion num2) {
  const double tmp_r = (num2.R * num1.R) - (num2.i * num1.i) -
                       (num2.j * num1.j) - (num2.k * num1.k);
  const double tmp_i = (num2.R * num1.i) + (num2.i * num1.R) -
                       (num2.j * num1.k) + (num2.k * num1.j);
  const double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) +
                       (num2.j * num1.R) - (num2.k * num1.i);
  const double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) +
                       (num2.j * num1.i) + (num2.k * num1.R);
  return (quaternion){tmp_r, tmp_i, tmp_j, tmp_k};
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	"Parses the URI returning it's components and their lengths (no decoding performed, doesn't accept decoded URIs). The returned string are NOT NUL terminated, they are merely locations within the original string. This function expects any of the following formats: Invalid formats might produce unexpected results. No error testing performed."	2	"fio_url_s fio_url_parse(const char *url, size_t length) {

  const char *end = url + length;
  const char *pos = url;
  fio_url_s r = {.scheme = {.data = (char *)url}};
  if (length == 0) {
    goto finish;
  }

  if (pos[0] == '/') {

    goto start_path;
  }

  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@' &&
         pos[0] != '#' && pos[0] != '?')
    ++pos;

  if (pos == end) {

    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    goto finish;
  }
  switch (pos[0]) {
  case '@':

    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    goto start_host;
  case '/':

    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    goto start_path;
  case '?':

    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    goto start_query;
  case '#':

    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    goto start_target;
  case ':':
    if (pos + 2 <= end && pos[1] == '/' && pos[2] == '/') {

      r.scheme.len = pos - url;
      pos += 3;
    } else {

      r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};
      ++pos;
      goto start_password;
    }
    break;
  }

  url = pos;
  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@')
    ++pos;

  if (pos >= end) {
    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    goto finish;
  }

  switch (pos[0]) {
  case '/':

    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    goto start_path;
  case '@':

    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    goto start_host;
  case ':':

    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    break;
  }

start_password:
  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != '@')
    ++pos;

  if (pos >= end) {

    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    r.host = r.user;
    r.user.len = 0;
    goto finish;
    ;
  }

  switch (pos[0]) {
  case '/':
    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    r.host = r.user;
    r.user.len = 0;
    goto start_path;
  case '@':
    r.password = (fio_str_info_s){.data = (char *)url, .len = pos - url};
    ++pos;
    break;
  }

start_host:
  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != ':' && pos[0] != '#' &&
         pos[0] != '?')
    ++pos;

  r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};
  if (pos >= end) {
    goto finish;
  }
  switch (pos[0]) {
  case '/':

    goto start_path;
  case '?':

    ++pos;
    goto start_query;
  case '#':

    ++pos;
    goto start_target;
  }
  ++pos;

  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != '#' && pos[0] != '?')
    ++pos;

  r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};

  if (pos >= end) {

    goto finish;
  }
  switch (pos[0]) {
  case '?':

    ++pos;
    goto start_query;
  case '#':

    ++pos;
    goto start_target;
  }

start_path:
  url = pos;
  while (pos < end && pos[0] != '#' && pos[0] != '?')
    ++pos;

  r.path = (fio_str_info_s){.data = (char *)url, .len = pos - url};

  if (pos >= end) {
    goto finish;
  }
  ++pos;
  if (pos[-1] == '#')
    goto start_target;

start_query:
  url = pos;
  while (pos < end && pos[0] != '#')
    ++pos;

  r.query = (fio_str_info_s){.data = (char *)url, .len = pos - url};
  ++pos;

  if (pos >= end)
    goto finish;

start_target:
  r.target = (fio_str_info_s){.data = (char *)pos, .len = end - pos};

finish:

  if (!r.scheme.len)
    r.scheme.data = NULL;
  if (!r.user.len)
    r.user.data = NULL;
  if (!r.password.len)
    r.password.data = NULL;
  if (!r.host.len)
    r.host.data = NULL;
  if (!r.port.len)
    r.port.data = NULL;
  if (!r.path.len)
    r.path.data = NULL;
  if (!r.query.len)
    r.query.data = NULL;
  if (!r.target.len)
    r.target.data = NULL;

  return r;
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/gfx.c	Print error message to screen and wait for button	2	"void gfx_error(char *message) {
  gfx_fill_screen(COLOR_RED);
  gfx_font_set(font_medium);
  gfx_cursor_set((cursor_coord_t){0, 0});
  gfx_color_set(COLOR_BLACK);
  gfx_print(message);
  gfx_push_screen_buffer();
  btn_wait();
  DELAY(200);
  btn_clear();
}"
globus-globus-toolkit-3f00bce/gsi/gss_assist/source/read_vhost_cred_dir.c	"This function loads all of the credentials available in the vhost credential directory and returns them in its output parameters. The credentials directory is expected to contain a directory for each credential, with the directory containing cert.pem and privkey.pem files."	2	"globus_gss_assist_read_vhost_cred_dir(

    OM_uint32 *minor_status,

    const char *dir,

    gss_cred_id_t **output_credentials_array,

    size_t *output_credentials_array_size) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  void *credential_buffer = NULL;
  size_t credential_buffer_len = 0;
  gss_cred_id_t *credential_array = NULL;
  size_t credential_array_count = 0;
  size_t credential_array_size = 0;
  char *dirname = NULL;
  DIR *dir_handle = NULL;
  struct dirent *dir_entry = NULL;
  int rc = 0;

  if (output_credentials_array == NULL ||
      output_credentials_array_size == NULL) {
    major_status = GSS_S_FAILURE | GSS_S_CALL_INACCESSIBLE_WRITE;
    *minor_status = GLOBUS_FAILURE;

    goto invalid_parameter;
  }

  if (dir == NULL) {
    *minor_status = GLOBUS_GSI_SYSCONFIG_GET_VHOST_CRED_DIR(&dirname);
    if (*minor_status != GLOBUS_SUCCESS) {
      major_status = GSS_S_FAILURE;

      goto no_dir;
    }
  } else {
    dirname = (char *)dir;
  }

  if (dirname == NULL) {
    major_status = GSS_S_FAILURE;
    *minor_status = GLOBUS_FAILURE;

    goto no_dir;
  }

  dir_handle = opendir(dirname);
  if (dir_handle == NULL) {
    major_status = GSS_S_FAILURE;
    *minor_status = GLOBUS_FAILURE;

    goto opendir_fail;
  }

  while ((rc = globus_libc_readdir_r(dir_handle, &dir_entry)) == 0 &&
         dir_entry != NULL) {
    char full_path[strlen(dir_entry->d_name) + strlen(dirname) + 2];
    char import_name[strlen(dir_entry->d_name) + strlen(dirname) + 4];
    struct stat st;

    if (strcmp(dir_entry->d_name, ""."") == 0 ||
        strcmp(dir_entry->d_name, "".."") == 0) {
      goto skip_entry;
    }

    sprintf(full_path, ""%s/%s"", dirname, dir_entry->d_name);
    rc = stat(full_path, &st);
    if (rc != 0) {
      goto skip_entry;
    }

    if ((st.st_mode & S_IFDIR) == 0) {
      goto skip_entry;
    }

    sprintf(import_name, ""p=%s/%s"", dirname, dir_entry->d_name);

    if (credential_array_count == credential_array_size) {
      gss_cred_id_t *tmp = NULL;

      tmp = realloc(credential_array,
                    2 * (credential_array_size ? credential_array_size : 1) *
                        sizeof(gss_cred_id_t));

      if (tmp == NULL) {
        major_status = GSS_S_FAILURE;
        *minor_status = GLOBUS_FAILURE;

        goto realloc_credential_fail;
      }
      credential_array = tmp;
      credential_array_size =
          2 * (credential_array_size ? credential_array_size : 1);
    }
    major_status =
        gss_import_cred(minor_status, &credential_array[credential_array_count],
                        GSS_C_NO_OID, 1,
                        &(gss_buffer_desc){
                            .value = import_name,
                            .length = strlen(import_name),
                        },
                        0, NULL);

    free(credential_buffer);
    credential_buffer = NULL;
    credential_buffer_len = 0;

    if (major_status != GSS_S_COMPLETE) {
      goto import_cred_fail;
    }
    credential_array_count++;
  skip_entry:
    free(dir_entry);
    dir_entry = NULL;
  }
  if (major_status != GSS_S_COMPLETE) {
  import_cred_fail:
  realloc_credential_fail:
  no_data:
  read_file_fail:
    free(credential_buffer);
    credential_buffer = NULL;
    credential_buffer_len = 0;

    for (size_t i = 0; i < credential_array_count; i++) {
      gss_release_cred(minor_status, &credential_array[i]);
    }
    free(credential_array);

    credential_array_count = 0;
    credential_array_size = 0;
    credential_array = NULL;
  }
  if (dir_entry != NULL) {
    free(dir_entry);
    dir_entry = NULL;
  }
  closedir(dir_handle);
  dir_handle = NULL;

opendir_fail:
  if (dir == NULL) {
    free(dirname);
    dirname = NULL;
  }
no_dir:
  *output_credentials_array = credential_array;
  *output_credentials_array_size =
      credential_array_count * sizeof(gss_cred_id_t);
invalid_parameter:
  return major_status;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	Writes blocks of data to the attached Mass Storage device's medium.	1	"uint8_t
MS_Host_WriteDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                          const uint8_t LUNIndex, const uint32_t BlockAddress,
                          const uint8_t Blocks, const uint16_t BlockSize,
                          void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = COMMAND_DIRECTION_DATA_OUT,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_WRITE_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/plrdlg.c	Popup (or raise) the short player list dialog version.	2	"void popup_players_nations_dialog(void) {
  struct widget *pWindow = NULL, *pBuf = NULL;
  SDL_Surface *pLogo = NULL;
  utf8_str *pstr;
  char cBuf[128], *state;
  int n = 0, w = 0, units_h = 0;
  const struct player_diplstate *pDS;
  SDL_Rect area;

  if (pShort_Players_Dlg) {
    return;
  }

  pShort_Players_Dlg = fc_calloc(1, sizeof(struct ADVANCED_DLG));

  pstr = create_utf8_from_char(_(""Nations""), adj_font(12));
  pstr->style |= TTF_STYLE_BOLD;

  pWindow = create_window_skeleton(NULL, pstr, 0);

  pWindow->action = players_nations_window_dlg_callback;
  set_wstate(pWindow, FC_WS_NORMAL);

  add_to_gui_list(ID_WINDOW, pWindow);
  pShort_Players_Dlg->pEndWidgetList = pWindow;

  area = pWindow->area;

  pBuf = create_themeicon(current_theme->Small_CANCEL_Icon, pWindow->dst,
                          WF_WIDGET_HAS_INFO_LABEL | WF_RESTORE_BACKGROUND);
  pBuf->info_label =
      create_utf8_from_char(_(""Close Dialog (Esc)""), adj_font(12));
  area.w = MAX(area.w, pBuf->size.w + adj_size(10));
  pBuf->action = exit_players_nations_dlg_callback;
  set_wstate(pBuf, FC_WS_NORMAL);
  pBuf->key = SDLK_ESCAPE;

  add_to_gui_list(ID_BUTTON, pBuf);

  players_iterate(pPlayer) {
    if (pPlayer != client.conn.playing) {
      if (!pPlayer->is_alive || is_barbarian(pPlayer)) {
        continue;
      }

      pDS = player_diplstate_get(client.conn.playing, pPlayer);

      if (is_ai(pPlayer)) {
        state = _(""AI"");
      } else {
        if (pPlayer->is_connected) {
          if (pPlayer->phase_done) {
            state = _(""done"");
          } else {
            state = _(""moving"");
          }
        } else {
          state = _(""disconnected"");
        }
      }

      if (pDS->type == DS_CEASEFIRE) {
        fc_snprintf(cBuf, sizeof(cBuf), ""%s(%s) - %d %s"",
                    nation_adjective_for_player(pPlayer), state,
                    pDS->turns_left, PL_(""turn"", ""turns"", pDS->turns_left));
      } else {
        fc_snprintf(cBuf, sizeof(cBuf), ""%s(%s)"",
                    nation_adjective_for_player(pPlayer), state);
      }

      pstr = create_utf8_from_char(cBuf, adj_font(10));
      pstr->style |= TTF_STYLE_BOLD;

      pLogo = get_nation_flag_surface(nation_of_player(pPlayer));

      pBuf = create_iconlabel(
          pLogo, pWindow->dst, pstr,
          (WF_RESTORE_BACKGROUND | WF_DRAW_TEXT_LABEL_WITH_SPACE));

      switch (pDS->type) {
      case DS_ARMISTICE:
        pBuf->string_utf8->fgcol =
            *get_theme_color(COLOR_THEME_PLRDLG_ARMISTICE);
        set_wstate(pBuf, FC_WS_NORMAL);
        break;
      case DS_WAR:
        if (can_meet_with_player(pPlayer) || can_intel_with_player(pPlayer)) {
          set_wstate(pBuf, FC_WS_NORMAL);
          pBuf->string_utf8->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_WAR);
        } else {
          pBuf->string_utf8->fgcol =
              *(get_theme_color(COLOR_THEME_PLRDLG_WAR_RESTRICTED));
        }
        break;
      case DS_CEASEFIRE:
        pBuf->string_utf8->fgcol =
            *get_theme_color(COLOR_THEME_PLRDLG_CEASEFIRE);
        set_wstate(pBuf, FC_WS_NORMAL);
        break;
      case DS_PEACE:
        pBuf->string_utf8->fgcol = *get_theme_color(COLOR_THEME_PLRDLG_PEACE);
        set_wstate(pBuf, FC_WS_NORMAL);
        break;
      case DS_ALLIANCE:
        pBuf->string_utf8->fgcol =
            *get_theme_color(COLOR_THEME_PLRDLG_ALLIANCE);
        set_wstate(pBuf, FC_WS_NORMAL);
        break;
      case DS_NO_CONTACT:
        pBuf->string_utf8->fgcol =
            *(get_theme_color(COLOR_THEME_WIDGET_DISABLED_TEXT));
        break;
      default:
        set_wstate(pBuf, FC_WS_NORMAL);
        break;
      }

      pBuf->string_utf8->bgcol = (SDL_Color){0, 0, 0, 0};

      pBuf->data.player = pPlayer;

      pBuf->action = player_nation_callback;

      add_to_gui_list(ID_LABEL, pBuf);

      area.w = MAX(w, pBuf->size.w);
      area.h += pBuf->size.h;

      if (n > 19) {
        set_wflag(pBuf, WF_HIDDEN);
      }

      n++;
    }
  }
  players_iterate_end;
  pShort_Players_Dlg->pBeginWidgetList = pBuf;
  pShort_Players_Dlg->pBeginActiveWidgetList =
      pShort_Players_Dlg->pBeginWidgetList;
  pShort_Players_Dlg->pEndActiveWidgetList = pWindow->prev->prev;
  pShort_Players_Dlg->pActiveWidgetList =
      pShort_Players_Dlg->pEndActiveWidgetList;

  if (n > 20) {
    units_h = create_vertical_scrollbar(pShort_Players_Dlg, 1, 20, TRUE, TRUE);
    pShort_Players_Dlg->pScroll->count = n;

    n = units_h;
    area.w += n;

    units_h = 20 * pBuf->size.h;

  } else {
    units_h = area.h;
  }

  area.h = units_h;

  resize_window(pWindow, NULL, NULL,
                (pWindow->size.w - pWindow->area.w) + area.w,
                (pWindow->size.h + pWindow->area.h) + area.h);

  area = pWindow->area;

  widget_set_position(
      pWindow,
      ((Main.event.motion.x + pWindow->size.w + adj_size(10) <
        main_window_width())
           ? (Main.event.motion.x + adj_size(10))
           : (main_window_width() - pWindow->size.w - adj_size(10))),
      ((Main.event.motion.y - adj_size(2) + pWindow->size.h <
        main_window_height())
           ? (Main.event.motion.y - adj_size(2))
           : (main_window_height() - pWindow->size.h - adj_size(10))));

  w = area.w;

  if (pShort_Players_Dlg->pScroll) {
    w -= n;
  }

  pBuf = pWindow->prev;
  pBuf->size.x = area.x + area.w - pBuf->size.w - 1;
  pBuf->size.y = pWindow->size.y + adj_size(2);

  pBuf = pBuf->prev;
  setup_vertical_widgets_position(1, area.x, area.y, w, 0,
                                  pShort_Players_Dlg->pBeginActiveWidgetList,
                                  pBuf);

  if (pShort_Players_Dlg->pScroll) {
    setup_vertical_scrollbar_area(pShort_Players_Dlg->pScroll, area.x + area.w,
                                  area.y, area.h, TRUE);
  }

  redraw_group(pShort_Players_Dlg->pBeginWidgetList, pWindow, 0);
  widget_mark_dirty(pWindow);

  flush_dirty();
}"
PJK-libcbor-87f977e/src/cbor/maps.c	Create a new definite map	2	"cbor_item_t *cbor_new_definite_map(size_t size) {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = size,
                                    .type = _CBOR_METADATA_DEFINITE,
                                    .end_ptr = 0}},
      .data = _cbor_alloc_multiple(sizeof(struct cbor_pair), size)};
  _CBOR_DEPENDENT_NOTNULL(item, item->data);

  return item;
}"
HiPhish-XeenTools-ee7c26c/Source/cc_tool/cc_tool.c	Get the decrypted TOC entry stored in a CC file.	2	"int xeen_cc_get_toc_entry(FILE *fp, const int index, XeenCCTocEntry *entry) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    FSEEK_FAIL,
    FREAD_FAIL,
  } error = SUCCESS;

  if (!fp || !entry) {
    error = INVALID_ARGS;
    goto end;
  }

  uint8_t raw[8];

  uint8_t ah = 0xAC + index * 8 * 0x67;

  if (fseek(fp, 2 + 8 * index, SEEK_SET) != 0) {

    error = FSEEK_FAIL;
    goto end;
  }

  if (fread(raw, sizeof(uint8_t), 8, fp) != 8) {

    error = FREAD_FAIL;
    goto end;
  }

  for (int i = 0; i < 8; ++i) {

    raw[i] = ((raw[i] & 0x3F) << 2) | ((raw[i] & 0xC0) >> 6);

    raw[i] = (uint8_t)((raw[i] + ah) & 0xFF);

    ah += 0x67;
  }

  assert(raw[7] == 0);

  *entry = (XeenCCTocEntry){
      .file_id = ((uint16_t)raw[1] << 8) + ((uint16_t)raw[0] << 0),
      .file_offset = ((uint32_t)raw[4] << 16) + ((uint32_t)raw[3] << 8) +
                     ((uint32_t)raw[2] << 0),
      .file_length = ((uint16_t)raw[6] << 8) + ((uint16_t)raw[5] << 0),
  };

end:
  return error;
}"
boazsegev-iodine-b6bdf50/ext/iodine/http1.c	"Upgrades an HTTP connection to an EventSource (SSE) connection. On HTTP/1.1 connections, this will preclude future requests using the same connection."	2	"static int http1_upgrade2sse(http_s *h, http_sse_s *sse) {
  const intptr_t uuid = handle2pr(h)->p.uuid;

  h->status = 200;
  http_set_header(h, HTTP_HEADER_CONTENT_TYPE, fiobj_dup(HTTP_HVALUE_SSE_MIME));
  http_set_header(h, HTTP_HEADER_CACHE_CONTROL,
                  fiobj_dup(HTTP_HVALUE_NO_CACHE));
  http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,
                  fiobj_str_new(""identity"", 8));
  handle2pr(h)->stop = 1;
  htt1p_finish(h);

  http1_sse_fio_protocol_s *sse_pr = fio_malloc(sizeof(*sse_pr));
  if (!sse_pr)
    goto failed;
  *sse_pr = (http1_sse_fio_protocol_s){
      .p =
          {
              .on_ready = http1_sse_on_ready,
              .on_shutdown = http1_sse_on_shutdown,
              .on_close = http1_sse_on_close,
              .ping = http1_sse_ping,
          },
      .sse = fio_malloc(sizeof(*(sse_pr->sse))),
  };

  if (!sse_pr->sse)
    goto failed;

  http_sse_init(sse_pr->sse, uuid, &HTTP1_VTABLE, sse);
  fio_timeout_set(uuid, handle2pr(h)->p.settings->ws_timeout);
  if (sse->on_open)
    sse->on_open(&sse_pr->sse->sse);
  fio_attach(uuid, &sse_pr->p);
  return 0;

failed:
  fio_close(handle2pr(h)->p.uuid);
  if (sse->on_close)
    sse->on_close(sse);
  return -1;
  (void)sse;
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	Adds a callback to the list of callbacks to be called for the event.	2	"void fio_state_callback_add(callback_type_e c_type, void (*func)(void *),
                            void *arg) {
  if (c_type == FIO_CALL_ON_INITIALIZE && fio_data) {
    func(arg);
    return;
  }
  if (!func || (int)c_type < 0 || c_type > FIO_CALL_NEVER)
    return;
  fio_lock(&callback_collection[c_type].lock);
  fio_state_callback_ensure(&callback_collection[c_type]);
  callback_data_s *tmp = malloc(sizeof(*tmp));
  FIO_ASSERT_ALLOC(tmp);
  *tmp = (callback_data_s){.func = func, .arg = arg};
  fio_ls_embd_push(&callback_collection[c_type].callbacks, &tmp->node);
  fio_unlock(&callback_collection[c_type].lock);
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/vaapi_h264.c	Initialize and start decoding a frame with VA API.	2	"static int vaapi_h264_start_frame(AVCodecContext *avctx,
                                  av_unused const uint8_t *buffer,
                                  av_unused uint32_t size) {
  const H264Context *h = avctx->priv_data;
  VAAPIDecodePicture *pic = h->cur_pic_ptr->hwaccel_picture_private;
  const PPS *pps = h->ps.pps;
  const SPS *sps = h->ps.sps;
  VAPictureParameterBufferH264 pic_param;
  VAIQMatrixBufferH264 iq_matrix;
  int err;

  pic->output_surface = ff_vaapi_get_surface_id(h->cur_pic_ptr->f);

  pic_param = (VAPictureParameterBufferH264){
      .picture_width_in_mbs_minus1 = h->mb_width - 1,
      .picture_height_in_mbs_minus1 = h->mb_height - 1,
      .bit_depth_luma_minus8 = sps->bit_depth_luma - 8,
      .bit_depth_chroma_minus8 = sps->bit_depth_chroma - 8,
      .num_ref_frames = sps->ref_frame_count,
      .seq_fields.bits =
          {
              .chroma_format_idc = sps->chroma_format_idc,
              .residual_colour_transform_flag =
                  sps->residual_color_transform_flag,
              .gaps_in_frame_num_value_allowed_flag =
                  sps->gaps_in_frame_num_allowed_flag,
              .frame_mbs_only_flag = sps->frame_mbs_only_flag,
              .mb_adaptive_frame_field_flag = sps->mb_aff,
              .direct_8x8_inference_flag = sps->direct_8x8_inference_flag,
              .MinLumaBiPredSize8x8 = sps->level_idc >= 31,
              .log2_max_frame_num_minus4 = sps->log2_max_frame_num - 4,
              .pic_order_cnt_type = sps->poc_type,
              .log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_poc_lsb - 4,
              .delta_pic_order_always_zero_flag =
                  sps->delta_pic_order_always_zero_flag,
          },
      .num_slice_groups_minus1 = pps->slice_group_count - 1,
      .slice_group_map_type = pps->mb_slice_group_map_type,
      .slice_group_change_rate_minus1 = 0,
      .pic_init_qp_minus26 = pps->init_qp - 26,
      .pic_init_qs_minus26 = pps->init_qs - 26,
      .chroma_qp_index_offset = pps->chroma_qp_index_offset[0],
      .second_chroma_qp_index_offset = pps->chroma_qp_index_offset[1],
      .pic_fields.bits =
          {
              .entropy_coding_mode_flag = pps->cabac,
              .weighted_pred_flag = pps->weighted_pred,
              .weighted_bipred_idc = pps->weighted_bipred_idc,
              .transform_8x8_mode_flag = pps->transform_8x8_mode,
              .field_pic_flag = h->picture_structure != PICT_FRAME,
              .constrained_intra_pred_flag = pps->constrained_intra_pred,
              .pic_order_present_flag = pps->pic_order_present,
              .deblocking_filter_control_present_flag =
                  pps->deblocking_filter_parameters_present,
              .redundant_pic_cnt_present_flag = pps->redundant_pic_cnt_present,
              .reference_pic_flag = h->nal_ref_idc != 0,
          },
      .frame_num = h->poc.frame_num,
  };

  fill_vaapi_pic(&pic_param.CurrPic, h->cur_pic_ptr, h->picture_structure);
  err = fill_vaapi_ReferenceFrames(&pic_param, h);
  if (err < 0)
    goto fail;

  err = ff_vaapi_decode_make_param_buffer(
      avctx, pic, VAPictureParameterBufferType, &pic_param, sizeof(pic_param));
  if (err < 0)
    goto fail;

  memcpy(iq_matrix.ScalingList4x4, pps->scaling_matrix4,
         sizeof(iq_matrix.ScalingList4x4));
  memcpy(iq_matrix.ScalingList8x8[0], pps->scaling_matrix8[0],
         sizeof(iq_matrix.ScalingList8x8[0]));
  memcpy(iq_matrix.ScalingList8x8[1], pps->scaling_matrix8[3],
         sizeof(iq_matrix.ScalingList8x8[0]));

  err = ff_vaapi_decode_make_param_buffer(avctx, pic, VAIQMatrixBufferType,
                                          &iq_matrix, sizeof(iq_matrix));
  if (err < 0)
    goto fail;

  return 0;

fail:
  ff_vaapi_decode_cancel(avctx, pic);
  return err;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/gui_mouse.c	Draw current cursor.	2	"void draw_mouse_cursor(void) {
  int cursor_x = 0;
  int cursor_y = 0;
  static SDL_Rect area = {0, 0, 0, 0};

  if (gui_options.gui_sdl2_use_color_cursors) {

    if (area.w != 0) {
      flush_rect(&area, TRUE);
    }

    if (current_color_cursor.cursor != NULL) {
      SDL_GetMouseState(&cursor_x, &cursor_y);
      area.x = cursor_x - current_color_cursor.hot_x;
      area.y = cursor_y - current_color_cursor.hot_y;
      area.w = current_color_cursor.cursor->w;
      area.h = current_color_cursor.cursor->h;

      screen_blit(current_color_cursor.cursor, NULL, &area, 255);

      update_main_screen();
#if 0
      SDL_UpdateRect(Main.screen, area.x, area.y, area.w, area.h);
#endif
    } else {
      area = (SDL_Rect){0, 0, 0, 0};
    }
  }
}"
Decawave-mynewt-dw1000-core-d4f0971/lib/provision/src/provision.c	API to allocate resources on TAG & Anchor for provisioning can be freed on TAG & ANCHOR on once provision have been completed.	2	"dw1000_provision_init(dw1000_dev_instance_t *inst,
                      dw1000_provision_config_t config) {
  assert(inst);
  if (inst->provision == NULL) {
    inst->provision = (dw1000_provision_instance_t *)malloc(
        sizeof(dw1000_provision_instance_t) +
        config.max_node_count * sizeof(uint16_t));
    assert(inst->provision);
    memset(inst->provision, 0, sizeof(dw1000_provision_instance_t));
    inst->provision->status.selfmalloc = 1;
  }
  dw1000_provision_instance_t *provision = inst->provision;
  assert(provision != NULL);

  provision->parent = inst;
  provision->idx = 0x0;
  provision->nframes = 2;
  memcpy(&provision->config, &config, sizeof(dw1000_provision_config_t));
  inst->provision->cbs = (dw1000_mac_interface_t){
      .id = DW1000_PROVISION,
      .tx_complete_cb = provision_tx_complete_cb,
      .rx_complete_cb = provision_rx_complete_cb,
      .rx_timeout_cb = provision_rx_timeout_cb,
      .rx_error_cb = provision_rx_error_cb,
      .tx_error_cb = provision_tx_error_cb,
  };
  dw1000_mac_append_interface(inst, &inst->provision->cbs);

  provision->status.provision_status = PROVISION_INVALID;
  os_error_t err = os_sem_init(&inst->provision->sem, 0x1);
  assert(err == OS_OK);

  dw1000_provision_set_postprocess(inst, &provision_postprocess);
  inst->provision->status.initialized = 1;
  return inst->provision;
}"
RosettaCommons-binder-a9cfcdc/source/class.cpp	Generate code for binding default constructor.	4	"string bind_default_constructor(ConstructorBindingInfo const &CBI) {

  if (CBI.C->isAbstract())
    return ""\tcl.def( pybind11::init( [](){{ return new {0}(); }} ) );\n""_format(
        CBI.trampoline_qualified_name);
  else if (CBI.trampoline)
    return ""\tcl.def( pybind11::init( [](){{ return new {0}(); }}, [](){{ return new {1}(); }} ) );\n""_format(
        CBI.class_qualified_name, CBI.trampoline_qualified_name);
  else
    return ""\tcl.def( pybind11::init( [](){{ return new {0}(); }} ) );\n""_format(
        CBI.class_qualified_name);
}"
intel-iot-devkit-zmraa-f8c045d/source/aio.c	"Initialise an Analog input device, connected to the specified pin"	2	"mraa_aio_init(unsigned int pin) {
  mraa_board_t *board = plat;
  if (board == NULL) {
    return NULL;
  }

  if (pin < 0 || pin >= board->phy_pin_count) {
    return NULL;
  }

  struct device *pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
  if (pinmux_dev == NULL) {
    printf(""Failed to get binding for pinmux\n"");
    return NULL;
  }

#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
  d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);

  if (pin == 7) {
    pinmux_pin_set(d2k_pinmux_dev, 8, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 7, 8, ""IO7"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  } else if (pin == 8) {
    pinmux_pin_set(d2k_pinmux_dev, 9, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 8, 9, ""IO8"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  } else if (pin == 10) {
    pinmux_pin_set(d2k_pinmux_dev, 0, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 10, 0, ""IO10"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  } else if (pin == 11) {
    pinmux_pin_set(d2k_pinmux_dev, 17, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 11, 17, ""IO11"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  } else if (pin == 12) {
    pinmux_pin_set(d2k_pinmux_dev, 18, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 12, 18, ""IO12"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  } else if (pin == 13) {
    pinmux_pin_set(d2k_pinmux_dev, 16, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 13, 16, ""IO13"",
                     (mraa_pincapabilities_t){1, 1, 0, 0, 0, 0, 1, 0});
  }

  if (pin >= 0 && pin <= 5) {
    pin = pin + 14;
  }
#endif
#if defined(CONFIG_BOARD_ARDUINO_101_SSS)
  if (pin == 0) {
    pinmux_pin_set(pinmux_dev, 10, PINMUX_FUNC_B);
  } else if (pin == 1) {
    pinmux_pin_set(pinmux_dev, 11, PINMUX_FUNC_B);
  } else if (pin == 2) {
    pinmux_pin_set(pinmux_dev, 12, PINMUX_FUNC_B);
  } else if (pin == 3) {
    pinmux_pin_set(pinmux_dev, 13, PINMUX_FUNC_B);
  } else if (pin == 4) {
    pinmux_pin_set(pinmux_dev, 14, PINMUX_FUNC_B);
  } else if (pin == 5) {
    pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_B);
  } else if (pin == 10) {
    pinmux_pin_set(pinmux_dev, 0, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 10, 0, ""A8"",
                     (mraa_pincapabilities_t){1, 0, 0, 0, 0, 0, 1, 0});
  } else if (pin == 11) {
    pinmux_pin_set(pinmux_dev, 3, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 11, 3, ""A9"",
                     (mraa_pincapabilities_t){1, 0, 0, 0, 0, 0, 1, 0});
  } else if (pin == 12) {
    pinmux_pin_set(pinmux_dev, 1, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 12, 1, ""A10"",
                     (mraa_pincapabilities_t){1, 0, 0, 0, 0, 0, 1, 0});
  } else if (pin == 13) {
    pinmux_pin_set(pinmux_dev, 2, PINMUX_FUNC_B);
    mraa_set_pininfo(board, 13, 2, ""A11"",
                     (mraa_pincapabilities_t){1, 0, 0, 0, 0, 0, 1, 0});
  } else {
    printf(""Pin %d not enabled/Can't be enabled\n"", pin);
    return NULL;
  }
#endif

  if (board->pins[pin].capabilites.aio != 1) {
    return NULL;
  }

  mraa_aio_context dev = (mraa_aio_context)malloc(sizeof(struct _aio));
  dev->phy_pin = board->pins[pin].aio.pinmap;
  dev->zdev = device_get_binding(ADC_DEVICE_NAME);
  if (dev->zdev == NULL)
    return NULL;

  dev->value_bit = DEFAULT_BITS;

  adc_seq_entry_ptr sample =
      (adc_seq_entry_ptr)malloc(sizeof(struct adc_seq_entry));
  adc_seq_table_ptr table =
      (adc_seq_table_ptr)malloc(sizeof(struct adc_seq_table));
  sample->sampling_delay = 12;
  sample->channel_id = dev->phy_pin;
  sample->buffer_length = 4;
  uint8_t *seq_buffer;
  seq_buffer = (uint8_t *)malloc(sizeof(uint8_t) * 4);
  sample->buffer = seq_buffer;
  table->entries = sample;
  table->num_entries = 1;
  dev->table = table;
  adc_enable(dev->zdev);
  dev->pin = pin;

  raw_bits = mraa_adc_raw_bits();

  return dev;
}"
satlab-bluebox-aa8bce8/software/firmware/LUFA/Drivers/USB/Core/HostStandardReq.c	"Sends a GET CONFIGURATION standard request to the attached device, to retrieve the currently selected device configuration index."	0	"uint8_t USB_Host_GetDeviceConfiguration(uint8_t *const ConfigNumber) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
      .bRequest = REQ_GetConfiguration,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(uint8_t),
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(ConfigNumber);
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	Multiply complex array with a scalar and save to output (with strides) optr = iptr * val	2	"void md_zsmul2(unsigned int D, const long dims[D], const long ostr[D],
               complex float *optr, const long istr[D],
               const complex float *iptr, complex float val) {
  if (0. == cimagf(val)) {

    long dimsR[D + 1];
    long ostrR[D + 1];
    long istrR[D + 1];

    real_from_complex_dims(D, dimsR, dims);
    real_from_complex_strides(D, ostrR, ostr);
    real_from_complex_strides(D, istrR, istr);

    md_smul2(D + 1, dimsR, ostrR, (float *)optr, istrR, (const float *)iptr,
             crealf(val));
    return;
  }

#if 0
	make_z3op_scalar(md_zmul2, D, dims, ostr, optr, istr, iptr, val);
#else

  NESTED(void, nary_zsmul, (struct nary_opt_data_s * data, void *ptr[])) {
    data->ops->zsmul(data->size, val, ptr[0], ptr[1]);
  };

  optimized_twoop_oi(D, dims, ostr, optr, istr, iptr,
                     (size_t[2]){CFL_SIZE, CFL_SIZE}, nary_zsmul);
#endif
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/GenericHIDHost/GenericHIDHost.c	Writes a report to the attached device.	1	"void WriteNextReport(uint8_t *ReportOUTData, uint8_t ReportIndex,
                     uint8_t ReportType, uint16_t ReportLength) {

  Pipe_SelectPipe(HID_DATA_OUT_PIPE);

  if (Pipe_IsConfigured()) {
    Pipe_Unfreeze();

    if (!(Pipe_IsOUTReady())) {

      Pipe_Freeze();

      return;
    }

    if (ReportIndex)
      Pipe_Write_Byte(ReportIndex);

    Pipe_Write_Stream_LE(ReportOUTData, ReportLength);

    Pipe_ClearOUT();

    Pipe_Freeze();
  } else {

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
        .bRequest = REQ_SetReport,
        .wValue = ((ReportType << 8) | ReportIndex),
        .wIndex = 0,
        .wLength = ReportLength,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    USB_Host_SendControlRequest(ReportOUTData);
  }
}"
dm-vdo-kvdo-8df6805/vdo/base/slabDepot.c	"Configure the SlabDepot for the specified storage capacity, finding the number of data blocks that will fit and still leave room for the depot metadata, then return the saved state for that configuration."	2	"static int configureState(BlockCount blockCount, PhysicalBlockNumber firstBlock,
                          SlabConfig slabConfig, ZoneCount zoneCount,
                          SlabDepotState2_0 *state) {
  BlockCount slabSize = slabConfig.slabBlocks;
  logDebug(""slabDepot configureState(blockCount=%"" PRIu64
           "", firstBlock=%"" PRIu64 "", slabSize=%"" PRIu64 "", zoneCount=%u)"",
           blockCount, firstBlock, slabSize, zoneCount);

  size_t slabCount = (blockCount / slabSize);
  if (slabCount == 0) {
    return VDO_NO_SPACE;
  }

  if (slabCount > MAX_SLABS) {
    return VDO_TOO_MANY_SLABS;
  }

  BlockCount totalSlabBlocks = slabCount * slabConfig.slabBlocks;
  BlockCount totalDataBlocks = slabCount * slabConfig.dataBlocks;
  PhysicalBlockNumber lastBlock = firstBlock + totalSlabBlocks;

  *state = (SlabDepotState2_0){
      .slabConfig = slabConfig,
      .firstBlock = firstBlock,
      .lastBlock = lastBlock,
      .zoneCount = zoneCount,
  };

  logDebug(""slabDepot lastBlock=%"" PRIu64 "", totalDataBlocks=%"" PRIu64
           "", slabCount=%zu, leftOver=%"" PRIu64,
           lastBlock, totalDataBlocks, slabCount,
           blockCount - (lastBlock - firstBlock));

  return VDO_SUCCESS;
}"
goodform-RediSearch-7e30faf/src/aggregate/aggregate_request.c	Note that this does not initialize the structure; use	4	"int AggregateRequest_Start(AggregateRequest *req, RedisSearchCtx *sctx,
                           const AggregateRequestSettings *settings,
                           RedisModuleString **argv, int argc, char **err) {

  req->args = Aggregate_ParseRequest(argv, argc, (char **)err);
  if (!req->args) {
    SET_ERR(err, ""Could not parse aggregate request"");
    return REDISMODULE_ERR;
  }

  req->ap = (AggregatePlan){};
  if (!AggregatePlan_Build(&req->ap, req->args, (char **)err)) {
    SET_ERR(err, ""Could not build aggregate plan"");
    return REDISMODULE_ERR;
  }

  RedisModuleCtx *ctx = sctx->redisCtx;

  CmdString *str = &CMDARG_STR(CmdArg_FirstOf(req->args, ""query""));

  RSSearchOptions opts = RS_DEFAULT_SEARCHOPTS;

  opts.flags |= Search_AggregationQuery;

  if (req->ap.verbatim) {
    opts.flags |= Search_Verbatim;
  }
  if (settings->flags & AGGREGATE_REQUEST_NO_CONCURRENT) {
    opts.concurrentMode = 0;
  }
  if (settings->flags & AGGREGATE_REQUEST_NO_PARSE_QUERY) {
    req->parseCtx = NULL;
  } else {
    req->parseCtx = NewQueryParseCtx(sctx, str->str, str->len, &opts);

    if (!Query_Parse(req->parseCtx, (char **)err)) {
      SET_ERR(err, ""Unknown error"");
      return REDISMODULE_ERR;
    }

    if (!req->ap.verbatim) {
      Query_Expand(req->parseCtx, opts.expander);
    }
  }
  req->plan = Query_BuildPlan(sctx, req->parseCtx, &opts, settings->pcb,
                              &req->ap, (char **)err);
  if (!req->plan) {
    SET_ERR(err, QUERY_ERROR_INTERNAL_STR);
    return REDISMODULE_ERR;
  }

  if (req->ap.withSchema) {
    AggregateSchema sc =
        AggregatePlan_GetSchema(&req->ap, SEARCH_CTX_SORTABLES(req->plan->ctx));
    QueryPlan_SetHook(req->plan, QueryPlanHook_Pre, AggregatePlan_DumpSchema,
                      sc, array_free);
  }
  return REDISMODULE_OK;
}"
Luxoft-SDLP2-3b0e33b/SDL_Core/src/components/profile_manager/include/profile_manager/ipc/pm_receiver_zmq_socket.h	"Invoked when the socket receives a correct message. A response is sent automatically. Data payload of the message (if there is any) is deallocated after this callback, so you should copy it if you intend to keep it for later use."	2	"virtual ~IPMSocketListener() {}
virtual void handlePmMessage(ZmqMessageHeader header, const char *data) = 0;
}
;

class PMReceiverZmqSocket : public NsUtils::ReceiverZmqSocket,
                            public NsUtils::IReceiverSocketListener {
public:
  PMReceiverZmqSocket(void *zmqContext, std::string const &address,
                      NsUtils::SocketConnectionType type,
                      IPMSocketListener *listener);
  virtual ~PMReceiverZmqSocket(){};

protected:
  virtual void handleMessage(NsUtils::tSizedMessage msg);

private:
  IPMSocketListener *mPmListener;
};
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/keysym.c	"The keysym, Keysym, and KEYSYM control macros. Semantics: Creates a keysym in the current scope with the given simple name. The macro's userdata is a pointer to the ava_visibility of the symbol it defines."	2	"AVA_DEF_MACRO_SUBST(ava_intr_defkeysym_subst) {
  const ava_parse_unit *top_subst, *keysym_kw, *keysym_name_unit;
  ava_string keysym_name;
  ava_intr_defkeysym *node;

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN { AVA_MACRO_ARG_UNIT(top_subst, ""keysym""); }
  }

  if (ava_put_substitution != top_subst->type)
    goto invalid_syntax;
  if (!TAILQ_FIRST(&top_subst->v.statements))
    goto invalid_syntax;
  if (TAILQ_NEXT(TAILQ_FIRST(&top_subst->v.statements), next))
    goto invalid_syntax;

  keysym_kw = TAILQ_FIRST(&TAILQ_FIRST(&top_subst->v.statements)->units);
  if (!keysym_kw)
    goto invalid_syntax;
  if (ava_put_bareword != keysym_kw->type)
    goto invalid_syntax;
  if (!ava_string_equal(AVA_ASCII9_STRING(""#keysym#""), keysym_kw->v.string))
    goto invalid_syntax;

  keysym_name_unit = TAILQ_NEXT(keysym_kw, next);
  if (!keysym_name_unit)
    goto invalid_syntax;
  if (ava_put_bareword != keysym_name_unit->type)
    goto invalid_syntax;
  if (TAILQ_NEXT(keysym_name_unit, next))
    goto invalid_syntax;

  keysym_name = keysym_name_unit->v.string;
  node = AVA_NEW(ava_intr_defkeysym);
  node->header.v = &ava_intr_defkeysym_vtable;
  node->header.location = provoker->location;
  node->header.context = context;
  node->sym = AVA_NEW(ava_symbol);
  node->sym->type = ava_st_keysym;
  node->sym->level = ava_macsub_get_level(context);
  node->sym->visibility = *(const ava_visibility *)self->v.macro.userdata;
  node->sym->full_name = ava_macsub_apply_prefix(context, keysym_name);
  node->sym->v.keysym = node->sym->full_name;
  ava_macsub_put_symbol(context, node->sym, &keysym_name_unit->location);

  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v.node = (ava_ast_node *)node,
  };

invalid_syntax:
  return ava_macsub_error_result(
      context, ava_error_defkeysym_invalid_syntax(&top_subst->location));
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);
  int orig_nb_streams = ic->nb_streams;
  int flush_codecs = 1;

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    AVDictionary *thread_opt = NULL;
    st = ic->streams[i];

    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    codec = st->codec->codec ? st->codec->codec
                             : avcodec_find_decoder(st->codec->codec_id);

    av_dict_set(options ? &options[i] : &thread_opt, ""threads"", ""1"", 0);

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open2(st->codec, codec, options ? &options[i] : &thread_opt);

    if (!has_codec_parameters(st)) {
      if (codec && !st->codec->codec)
        avcodec_open2(st->codec, codec, options ? &options[i] : &thread_opt);
    }
    if (!options)
      av_dict_free(&thread_opt);
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (ff_check_interrupt(&ic->interrupt_callback)) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;

      st = ic->streams[i];
      if (!has_codec_parameters(st))
        break;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE &&
          (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
           st->codec->codec_type == AVMEDIA_TYPE_AUDIO))
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        flush_codecs = 0;
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = read_frame_internal(ic, &pkt1);
    if (ret == AVERROR(EAGAIN))
      continue;

    if (ret < 0) {

      break;
    }

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t = 0;
      if (st->time_base.den > 0)
        t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                         AV_TIME_BASE_Q);
      if (st->avg_frame_rate.num > 0)
        t = FFMAX(t, av_rescale_q(st->codec_info_nb_frames,
                                  (AVRational){st->avg_frame_rate.den,
                                               st->avg_frame_rate.num},
                                  AV_TIME_BASE_Q));

      if (t >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          pkt->dts > last) {
        double dts =
            (is_relative(pkt->dts) ? pkt->dts - RELATIVE_TS_BASE : pkt->dts) *
            av_q2d(st->time_base);
        int64_t duration = pkt->dts - last;

        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error[0][0]); i++) {
          int framerate = get_std_framerate(i);
          double sdts = dts * framerate / (1001 * 12);
          for (j = 0; j < 2; j++) {
            int ticks = lrintf(sdts + j * 0.5);
            double error = sdts - ticks + j * 0.5;
            st->info->duration_error[j][0][i] += error;
            st->info->duration_error[j][1][i] += error * error;
          }
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i > 0 && i < FF_MAX_EXTRADATA_SIZE) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        if (!st->codec->extradata)
          return AVERROR(ENOMEM);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    try_decode_frame(st, pkt,
                     (options && i < orig_nb_streams) ? &options[i] : NULL);

    st->codec_info_nb_frames++;
    count++;
  }

  if (flush_codecs) {
    AVPacket empty_pkt = {0};
    int err = 0;
    av_init_packet(&empty_pkt);

    ret = -1;
    for (i = 0; i < ic->nb_streams; i++) {
      st = ic->streams[i];

      if (st->info->found_decoder == 1) {
        do {
          err = try_decode_frame(st, &empty_pkt,
                                 (options && i < orig_nb_streams) ? &options[i]
                                                                  : NULL);
        } while (err > 0 && !has_codec_parameters(st));

        if (err < 0) {
          av_log(ic, AV_LOG_INFO, ""decoding for stream %d failed\n"", st->index);
        }
      }

      if (!has_codec_parameters(st)) {
        char buf[256];
        avcodec_string(buf, sizeof(buf), st->codec, 0);
        av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
               buf);
      } else {
        ret = 0;
      }
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
          st->info->codec_info_duration)
        av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                  (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                  st->info->codec_info_duration * (int64_t)st->time_base.num,
                  60000);

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 0.01;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error[0][0]); j++) {
          int k;

          if (st->info->codec_info_duration &&
              st->info->codec_info_duration * av_q2d(st->time_base) <
                  (1001 * 12.0) / get_std_framerate(j))
            continue;
          if (!st->info->codec_info_duration &&
              1.0 < (1001 * 12.0) / get_std_framerate(j))
            continue;
          for (k = 0; k < 2; k++) {
            int n = st->info->duration_count;
            double a = st->info->duration_error[k][0][j] / n;
            double error = st->info->duration_error[k][1][j] / n - a * a;

            if (error < best_error && best_error > 0.000000001) {
              best_error = error;
              num = get_std_framerate(j);
            }
            if (error < 0.02)
              av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f\n"",
                     get_std_framerate(j) / 12.0 / 1001, error);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }

  estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++) {
    if (ic->streams[i]->codec)
      ic->streams[i]->codec->thread_count = 0;
    av_freep(&ic->streams[i]->info);
  }
  return ret;
}"
kemadz-monit-9b51725/src/validate.c	Test the connection and protocol	2	"static State_Type _checkConnection(Service_T s, Port_T p) {
  ASSERT(s);
  ASSERT(p);
  volatile int retry_count = p->retry;
  volatile State_Type rv = State_Succeeded;
  char buf[STRLEN];
  char report[STRLEN] = {};
retry:
  TRY {
    Socket_test(p);
    rv = State_Succeeded;
    DEBUG(""'%s' succeeded testing protocol [%s] at %s [response time %s]\n"",
          s->name, p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
          Str_milliToTime(p->response, (char[23]){}));
  }
  ELSE {
    rv = State_Failed;
    snprintf(report, STRLEN, ""failed protocol test [%s] at %s -- %s"",
             p->protocol->name, Util_portDescription(p, buf, sizeof(buf)),
             Exception_frame.message);
  }
  END_TRY;
  if (rv == State_Failed) {
    if (retry_count-- > 1) {
      DEBUG(""'%s' %s (attempt %d/%d)\n"", s->name, report,
            p->retry - retry_count, p->retry);
      goto retry;
    }
    Event_post(s, Event_Connection, State_Failed, p->action, ""%s"", report);
  } else {
    Event_post(s, Event_Connection, State_Succeeded, p->action,
               ""connection succeeded to %s"",
               Util_portDescription(p, buf, sizeof(buf)));
  }
  if (p->target.net.ssl.options.flags &&
      p->target.net.ssl.certificate.minimumDays > 0) {
    if (p->target.net.ssl.certificate.validDays <
        p->target.net.ssl.certificate.minimumDays) {
      Event_post(
          s, Event_Timestamp, State_Failed, p->action,
          ""certificate expiry in %d days matches check limit [valid > %d days]"",
          p->target.net.ssl.certificate.validDays,
          p->target.net.ssl.certificate.minimumDays);
      rv = State_Failed;
    } else {
      Event_post(s, Event_Timestamp, State_Succeeded, p->action,
                 ""certificate valid days test succeeded [valid for %d days]"",
                 p->target.net.ssl.certificate.validDays);
    }
  }
  return rv;
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/chip8.c	Called by sub menu when a game is picked. Read associated .cfg file for settings and start the game.	2	"void chip8_run(chip8_game_t *p_game) {
  ESP_LOGD(TAG, ""%s Playing %s"", __func__, p_game->name);

  ui_allow_interrupt(false);

  chip8_t *p_c8 = util_heap_alloc_ext(sizeof(chip8_t));
  __init(p_c8, p_game);

  gfx_color_set(COLOR_GREEN);
  gfx_fill_screen(COLOR_BLACK);
  gfx_cursor_area_reset();
  gfx_font_set(font_medium);
  gfx_cursor_set((cursor_coord_t){0, 0});
  gfx_print(p_game->name);
  gfx_print(""\n"");
  gfx_font_set(font_small);
  gfx_print(""~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"");
  gfx_print(p_game->note);
  gfx_push_screen_buffer();
  btn_wait();
  btn_clear();

  util_heap_stats_dump();
  gfx_fill_screen(COLOR_BLACK);
  gfx_push_screen_buffer();

  char task_name[32];
  sprintf(task_name, ""CHIP-8 %s"", p_game->name);
  static StaticTask_t task;
  util_task_create(__chip8_task, task_name, 4096, p_c8, TASK_PRIORITY_MEDIUM,
                   &task);

  while (!p_c8->exit_flag) {
    DELAY(100);
  }

  ui_allow_interrupt(true);
  free(p_c8);
  util_heap_stats_dump();
  btn_clear();
}"
opticron-libuweave-2e5e385/src/macaroon.c	Creates a new macaroon with a new caveat. The buffer must be large enough to hold the count of caveats in the old_macaroon plus one.	2	"bool uw_macaroon_extend_(const UwMacaroon *old_macaroon,
                         UwMacaroon *new_macaroon,
                         const UwMacaroonContext *context,
                         const UwMacaroonCaveat *additional_caveat,
                         uint8_t *buffer, size_t buffer_size) {
  if (old_macaroon == NULL || new_macaroon == NULL || context == NULL ||
      additional_caveat == NULL || buffer == NULL || buffer_size == 0) {
    return false;
  }

  if (new_macaroon != old_macaroon) {
    *new_macaroon = (UwMacaroon){};
  }

  const size_t old_count = old_macaroon->num_caveats;
  const size_t new_count = old_count + 1;

  new_macaroon->num_caveats = new_count;

  if (new_count * sizeof(new_macaroon->caveats[0]) > buffer_size) {

    return false;
  }
  const UwMacaroonCaveat **extended_list = (const UwMacaroonCaveat **)buffer;
  if (extended_list != old_macaroon->caveats) {
    memcpy(extended_list, old_macaroon->caveats,
           old_count * sizeof(old_macaroon->caveats[0]));
  }
  extended_list[old_count] = additional_caveat;
  new_macaroon->caveats = (const UwMacaroonCaveat *const *)extended_list;

  return create_mac_tag_(old_macaroon->mac_tag, UW_MACAROON_MAC_LEN, context,
                         new_macaroon->caveats + old_count, 1,
                         new_macaroon->mac_tag);
}"
wizzie-io-n2kafka-bd4606e/src/decoder/zz_http2k/zz_http2k_parser_json.c	Generate kafka message.	0	"static void zz_parse_generate_rdkafka_message(struct zz_session *sess,
                                              rd_kafka_message_t *msg) {
  assert(sess);
  assert(msg);
  const char *end_msg =
      sess->json_session.http_chunk.in_buffer +
      yajl_get_bytes_consumed(sess->json_session.yajl_handler);
  assert(end_msg > sess->json_session.http_chunk.last_open_map);
  *msg = (rd_kafka_message_t){
      .payload = const_cast(sess->json_session.http_chunk.last_open_map),
      .len = (size_t)(end_msg - sess->json_session.http_chunk.last_open_map),
  };
}"
blstream-OpenVideoHub-7bb9abf/libav/libavcodec/tiffenc.c	Put n values to buffer	2	"static void tnput(uint8_t **p, int n, const uint8_t *val, enum TiffTypes type,
                  int flip) {
  int i;
#ifdef WORDS_BIGENDIAN
  flip ^= ((int[]){0, 0, 0, 1, 3, 3})[type];
#endif
  for (i = 0; i < n * type_sizes2[type]; i++)
    *(*p)++ = val[i ^ flip];
}"
tempesta-tech-tempesta-9bbfee9/tempesta_fw/http.c	"Compose Content-Type header field from scratch. A POST-request with multipart/form-data payload need a boundary, which is supplied by a parameter in the Content-Type header field. There are strict instructions on how to parse that parameter (see RFC 7231 and RFC 7230), but application servers parse it in a non-standard way. For example, PHP checks whenever parameter name contains substring ""boundary"", and thus happily takes ""xxboundaryxx"". Such quirks are used to bypass web application firewalls. To make evasions harder, this function composes value of the Content-Type field from the parsed data. All parameters other than ""boundary"" are dropped."	4	"tfw_http_recreate_content_type_multipart_hdr(TfwHttpReq *req) {
  TfwStr replacement = {
      .chunks =
          (TfwStr[]){
              TFW_STR_STRING(""Content-Type""),
              TFW_STR_STRING("": ""),
              TFW_STR_STRING(""multipart/form-data; boundary=""),
              req->multipart_boundary_raw,
          },
      .nchunks = 4,
  };
  TfwStr *c = replacement.chunks;

  BUG_ON(!TFW_STR_PLAIN(&req->multipart_boundary_raw));
  replacement.len = c[0].len + c[1].len + c[2].len + c[3].len;
  return tfw_http_msg_hdr_xfrm_str((TfwHttpMsg *)req, &replacement,
                                   TFW_HTTP_HDR_CONTENT_TYPE, false);
}"
valarauca-car-8a5d720/car_compress/algo/xz2-rs/lzma-sys/xz-5.2.2/src/xz/file_io.c	Open the source file.	2	"io_open_src(const char *src_name) {
  if (is_empty_filename(src_name))
    return NULL;

  static file_pair pair;

  pair = (file_pair){
      .src_name = src_name,
      .dest_name = NULL,
      .src_fd = -1,
      .dest_fd = -1,
      .src_eof = false,
      .dest_try_sparse = false,
      .dest_pending_sparse = 0,
  };

  signals_block();
  const bool error = io_open_src_real(&pair);
  signals_unblock();

  return error ? NULL : &pair;
}"
libfirm-cparser-be2d414/src/parser/preprocessor.c	Switch input to another file/stream. Assume input_name is identified in the string hash.	2	"static void switch_input(input_t *const decoder, char const *const input_name,
                         searchpath_entry_t *const path,
                         bool const is_system_header) {
  utf32 *const buf = XMALLOCN(utf32, BUFSIZE + MAX_PUTBACK);
  utf32 *const end = buf + MAX_PUTBACK;
  input = (pp_input_t){
      .input = decoder,
      .buf = buf,
      .bufend = end,
      .bufpos = end,
      .output_line = 0,
      .real_name = input_name,
      .pos =
          {
              .input_name = input_name,
              .lineno = 1,
              .is_system_header = is_system_header,
          },
      .path = path,
  };

  const char *line_flag;
  if (input_stack == NULL) {

    base_inputname = input_name;
    counter = 0;
    line_flag = NULL;
  } else {
    line_flag = ""1"";
  }
  print_line_directive(&input.pos, line_flag);

  input.pos.lineno = 0;
  input.c = '\n';

  if (input_name != builtin_position.input_name) {
    bool new_dep = pset_new_insert(&includeset, (void *)input_name);
    if (new_dep) {
      include_t *include = OALLOC(&pp_obstack, include_t);
      include->next = NULL;
      include->filename = input_name;
      include->is_system_header = is_system_header;
      if (last_include != NULL) {
        last_include->next = include;
      } else {
        includes = include;
      }
      last_include = include;
    }
  }
}"
Samsung-RT-OCF-fd41fc4/security/tools/json2cbor_src/src/strings.c	Creates a new indefinite string	2	"cbor_item_t *cbor_new_indefinite_string() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_STRING,
      .metadata = {.string_metadata = {.type = _CBOR_METADATA_INDEFINITE,
                                       .length = 0}},
      .data = _CBOR_MALLOC(sizeof(struct cbor_indefinite_string_data))};
  *((struct cbor_indefinite_string_data *)item->data) =
      (struct cbor_indefinite_string_data){
          .chunk_count = 0,
          .chunk_capacity = 0,
          .chunks = NULL,
      };
  return item;
}"
mntmn-reform-fbb44d1/reform-keyboard-fw/lufa-master/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Read Capacity command to the attached device, to determine the capacity of the given Logical Unit within the device."	2	"uint8_t MassStore_ReadCapacity(const uint8_t LUNIndex,
                               SCSI_Capacity_t *const CapacityPtr) {
  uint8_t ErrorCode = PIPE_RWSTREAM_NoError;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Capacity_t),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  if ((ErrorCode = MassStore_SendCommand(&SCSICommandBlock, CapacityPtr)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  CapacityPtr->Blocks = SwapEndian_32(CapacityPtr->Blocks);
  CapacityPtr->BlockSize = SwapEndian_32(CapacityPtr->BlockSize);

  return ErrorCode;
}"
Deadlocked007-EventUp-a067de4/Pods/gRPC-Core/src/core/ext/transport/chttp2/transport/chttp2_transport.c	"Set the default keepalive configurations, must only be called at initialization"	2	"void grpc_chttp2_config_default_keepalive_args(grpc_channel_args *args,
                                               bool is_client) {
  size_t i;
  if (args) {
    for (i = 0; i < args->num_args; i++) {
      if (0 == strcmp(args->args[i].key, GRPC_ARG_KEEPALIVE_TIME_MS)) {
        const int value = grpc_channel_arg_get_integer(
            &args->args[i],
            (grpc_integer_options){g_default_client_keepalive_time_ms, 1,
                                   INT_MAX});
        if (is_client) {
          g_default_client_keepalive_time_ms = value;
        } else {
          g_default_server_keepalive_time_ms = value;
        }
      } else if (0 ==
                 strcmp(args->args[i].key, GRPC_ARG_KEEPALIVE_TIMEOUT_MS)) {
        const int value = grpc_channel_arg_get_integer(
            &args->args[i],
            (grpc_integer_options){g_default_client_keepalive_timeout_ms, 0,
                                   INT_MAX});
        if (is_client) {
          g_default_client_keepalive_timeout_ms = value;
        } else {
          g_default_server_keepalive_timeout_ms = value;
        }
      } else if (0 == strcmp(args->args[i].key,
                             GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS)) {
        g_default_keepalive_permit_without_calls =
            (uint32_t)grpc_channel_arg_get_integer(
                &args->args[i],
                (grpc_integer_options){g_default_keepalive_permit_without_calls,
                                       0, 1});
      } else if (0 ==
                 strcmp(args->args[i].key, GRPC_ARG_HTTP2_MAX_PING_STRIKES)) {
        g_default_max_ping_strikes = grpc_channel_arg_get_integer(
            &args->args[i],
            (grpc_integer_options){g_default_max_ping_strikes, 0, INT_MAX});
      } else if (0 == strcmp(args->args[i].key,
                             GRPC_ARG_HTTP2_MAX_PINGS_WITHOUT_DATA)) {
        g_default_max_pings_without_data = grpc_channel_arg_get_integer(
            &args->args[i], (grpc_integer_options){
                                g_default_max_pings_without_data, 0, INT_MAX});
      } else if (0 ==
                 strcmp(
                     args->args[i].key,
                     GRPC_ARG_HTTP2_MIN_SENT_PING_INTERVAL_WITHOUT_DATA_MS)) {
        g_default_min_sent_ping_interval_without_data_ms =
            grpc_channel_arg_get_integer(
                &args->args[i],
                (grpc_integer_options){
                    g_default_min_sent_ping_interval_without_data_ms, 0,
                    INT_MAX});
      } else if (0 ==
                 strcmp(
                     args->args[i].key,
                     GRPC_ARG_HTTP2_MIN_RECV_PING_INTERVAL_WITHOUT_DATA_MS)) {
        g_default_min_recv_ping_interval_without_data_ms =
            grpc_channel_arg_get_integer(
                &args->args[i],
                (grpc_integer_options){
                    g_default_min_recv_ping_interval_without_data_ms, 0,
                    INT_MAX});
      }
    }
  }
}"
ARM-software-scmi-tests-24dd373/protocols/power/power_exe.c	The function is called by the test engine before sending the power state get command and testing the received values.	3	"void arm_scmi_custom_test_power_state_get(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {
  uint32_t domain_id;
  int error_code;
  uint32_t power_state;

  test_case->parameter_count = 1;
  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_power_state_get, domain_id)) {

    test_case
        ->parameters[OFFSET_PARAM(struct arm_scmi_power_state_get, domain_id)] =
        power_protocol_data.num_power_domains;
    error_code = arm_scmi_execute_and_assert_test_case(
        protocol_execution_context, test_case, &received);
  } else if (test_case->parameter_discovery_driven) {

    for (domain_id = 0; domain_id < power_protocol_data.num_power_domains;
         ++domain_id) {

      test_case->parameters[OFFSET_PARAM(struct arm_scmi_power_state_get,
                                         domain_id)] = domain_id;
      snprintf(description, NUM_ELEMS(description), ""\n\t\tPOWER DOMAIN ID %d"",
               domain_id);
      arm_scmi_log(&protocol_execution_context->test_stats, description);
      error_code = arm_scmi_execute_and_assert_test_case(
          protocol_execution_context, test_case, &received);
      if (arm_scmi_skip_return_values(error_code, received.status))
        break;
      power_state =
          RETURN_VAL(received, struct arm_scmi_power_state_get, power_state);
      arm_scmi_check_and_report_hex(&protocol_execution_context->test_stats,
                                    ALL_BITS_SET, PRINT, 0, power_state,
                                    ""POWER STATE"");
    }
  }
}"
dm-vdo-vdo-bebf98e/utils/vdo/user/blockMapUtils.c	Find and decode a particular slot from a block map page.	2	"static int readSlotFromPage(VDO *vdo, PhysicalBlockNumber pbn, SlotNumber slot,
                            PhysicalBlockNumber *mappedPBNPtr,
                            BlockMappingState *mappedStatePtr) {
  BlockMapPage *page;
  int result = vdo->layer->allocateIOBuffer(vdo->layer, VDO_BLOCK_SIZE,
                                            ""page buffer"", (char **)&page);
  if (result != VDO_SUCCESS) {
    return result;
  }

  result = readBlockMapPage(vdo->layer, pbn, vdo->nonce, page);
  if (result != VDO_SUCCESS) {
    FREE(page);
    return result;
  }

  DataLocation mapped;
  if (isBlockMapPageInitialized(page)) {
    mapped = unpackBlockMapEntry(&page->entries[slot]);
  } else {
    mapped = (DataLocation){
        .state = MAPPING_STATE_UNMAPPED,
        .pbn = ZERO_BLOCK,
    };
  }

  *mappedStatePtr = mapped.state;
  *mappedPBNPtr = mapped.pbn;

  FREE(page);
  return VDO_SUCCESS;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Host/MassStorage.c	Reads blocks of data from the attached Mass Storage device's medium.	1	"uint8_t MS_Host_ReadDeviceBlocks(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                                 const uint8_t LUNIndex,
                                 const uint32_t BlockAddress,
                                 const uint8_t Blocks, const uint16_t BlockSize,
                                 void *BlockBuffer) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = ((uint32_t)Blocks * BlockSize),
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_10, 0x00, (BlockAddress >> 24),
                          (BlockAddress >> 16), (BlockAddress >> 8),
                          (BlockAddress & 0xFF), 0x00, 0x00, Blocks, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       BlockBuffer)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
s1s0-toped-f40ef95/tpd_GL/trendat.h	A pointer to the OpenGL object tesselator.	2	"TrxCnvx(pdata, psize), _tdata(NULL) {}
virtual ~TrxNcvx(){};
void setTeselData(const TessellPoly *tdata) { _tdata = tdata; }
virtual void drctDrawFill();
virtual const TeselChain *tdata() { return _tdata->tdata(); }"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/StillImage.c	Closes an already opened PIMA session with the attached device. This should be used after all session-orientated PIMA commands have been issued to the device.	2	"uint8_t
SImage_Host_CloseSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(0),
      .Type = CType_CommandBlock,
      .Code = 0x1003,
      .Params = {},
  };

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SImage_Host_ReceiveBlockHeader(
           SIInterfaceInfo, &PIMABlock)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SIInterfaceInfo->State.IsSessionOpen = false;

  if ((PIMABlock.Type != CType_ResponseBlock) || (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  return PIPE_RWSTREAM_NoError;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/KeyboardHostWithParser/KeyboardHostWithParser.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process the HID report descriptor and HID reports from the device and display the results onto the board LEDs."	1	"TASK(USB_Keyboard_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Processing HID Report.\r\n""));

    UpdateStatus(Status_Busy);

    if ((ErrorCode = GetHIDReportData()) != ParseSuccessful) {
      puts_P(PSTR(""Report Parse Error.\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    UpdateStatus(Status_USBReady);

    puts_P(PSTR(""Keyboard Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    Pipe_SelectPipe(KEYBOARD_DATAPIPE);
    Pipe_Unfreeze();

    if (Pipe_IsINReceived()) {

      if (Pipe_IsReadWriteAllowed()) {

        uint8_t KeyboardReport[Pipe_BytesInPipe()];

        Pipe_Read_Stream_LE(KeyboardReport, Pipe_BytesInPipe());

        ProcessKeyboardReport(KeyboardReport);
      }

      Pipe_ClearIN();
    }

    Pipe_Freeze();
    break;
  }
}"
ARM-software-scmi-tests-24dd373/protocols/sensor/sensor_exe.c	The function is called by the test engine before sending the sensor trip point config command and testing the received values.	3	"void arm_scmi_custom_tester_sensor_trip_point_config(
    struct arm_scmi_protocol_execution_context *protocol_execution_context,
    arm_scmi_test_case_t *test_case) {

  uint32_t idx;
  struct arm_scmi_protocol_test_stats *test_stats =
      &protocol_execution_context->test_stats;
  int trip_idx;

  test_case->parameters = (uint32_t[MAX_PARAMETERS_SIZE]){};
  test_case->parameter_count = 4;
  if (test_case->invalid_parameter ==
      OFFSET_INVALID_PARAM(struct arm_scmi_sensor_trip_point_config,
                           sensor_id)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       sensor_id)] =
        sensor_protocol_data.sensor_id[sensor_protocol_data.num_sensors - 1] +
        1;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_ev_ctrl)] =
        sensor_protocol_data.snsr_trip_points_supported[0];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_val_low)] = 0;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_val_high)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else if (test_case->invalid_parameter ==
             OFFSET_INVALID_PARAM(struct arm_scmi_sensor_trip_point_config,
                                  trip_point_ev_ctrl)) {

    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       sensor_id)] =
        sensor_protocol_data.sensor_id[0];
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_ev_ctrl)] =
        (sensor_protocol_data
             .snsr_trip_points_supported[test_case->parameters[OFFSET_PARAM(
                 struct arm_scmi_sensor_trip_point_config, sensor_id)]] +
         1)
        << SNR_TRIP_POINT_ID_LOW;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_val_low)] = 0;
    test_case->parameters[OFFSET_PARAM(struct arm_scmi_sensor_trip_point_config,
                                       trip_point_val_high)] = 0;
    arm_scmi_execute_and_assert_test_case(protocol_execution_context, test_case,
                                          &received);
  } else {

    for (idx = 0; idx < sensor_protocol_data.num_sensors; ++idx) {
      test_case->parameters[OFFSET_PARAM(
          struct arm_scmi_sensor_trip_point_config, sensor_id)] =
          sensor_protocol_data.sensor_id[idx];
      for (trip_idx = 0;
           trip_idx < sensor_protocol_data.snsr_trip_points_supported[idx];
           trip_idx++) {

        snprintf(description, NUM_ELEMS(description),
                 ""\n\t\t\tSENSOR ID %d, TRIP ID %d"",
                 sensor_protocol_data.sensor_id[idx], trip_idx);
        arm_scmi_log(test_stats, description);
        test_case->parameters[OFFSET_PARAM(
            struct arm_scmi_sensor_trip_point_config, trip_point_ev_ctrl)] =
            trip_idx << SNR_TRIP_POINT_ID_LOW;
        test_case->parameters[OFFSET_PARAM(
            struct arm_scmi_sensor_trip_point_config, trip_point_val_low)] = 0;
        test_case->parameters[OFFSET_PARAM(
            struct arm_scmi_sensor_trip_point_config, trip_point_val_high)] = 0;
        arm_scmi_execute_and_assert_test_case(protocol_execution_context,
                                              test_case, &received);
      }
    }
  }
}"
ANDnXOR-ANDnXOR_DC26_Badge-877161b/Firmware/components/skifree.c	Draw ski free game	2	"static void __draw(ski_state_t *p_state) {

  gfx_fill_screen(SKI_BG);
  gfx_color_set(SKI_FG);

  for (uint8_t i = 0; i < SKI_SPRITE_COUNT; i++) {
    sprite_t s = p_state->sprites[i];
    gfx_fill_rect(s.x - s.dx - 1, s.y - s.dy - 1, SKI_SPRITE_W + 2,
                  SKI_SPRITE_H + 2, SKI_BG);
    gfx_draw_raw(s.x, s.y, SKI_SPRITE_W, SKI_SPRITE_H,
                 p_state->sprite_raw[s.sprite_index]);
  }

  switch (p_state->angle) {
  case -45:
    gfx_draw_raw(SKI_X, SKI_Y, SKI_W, SKI_H, p_state->left_raw);
    break;
  case 0:
    gfx_draw_raw(SKI_X, SKI_Y, SKI_W, SKI_H, p_state->down_raw);
    break;
  case 45:
    gfx_draw_raw(SKI_X, SKI_Y, SKI_W, SKI_H, p_state->right_raw);
    break;
  }

  char dist[32];
  sprintf(dist, ""%dm"", (int)p_state->distance);
  gfx_cursor_set((cursor_coord_t){0, 0});

  gfx_fill_rect(0, 0, 30, gfx_font_height(), SKI_BG);
  gfx_print(dist);
  gfx_push_screen_buffer();
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the negative quaternion	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qnegl(const quaternion_long_double qnum) {
  return (quaternion_long_double){(-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k)};
}"
DelusionalLogic-NeoComp-271e784/src/compton.c	Get a specific attribute of a window. Returns a blank structure if the returned type and format does not match the requested type and format.	2	"wid_get_prop_adv(struct X11Context *xcontext, Window w, Atom atom, long offset,
                 long length, Atom rtype, int rformat) {
  Atom type = None;
  int format = 0;
  unsigned long nitems = 0, after = 0;
  unsigned char *data = NULL;

  if (Success == XGetWindowProperty(xcontext->display, w, atom, offset, length,
                                    False, rtype, &type, &format, &nitems,
                                    &after, &data) &&
      nitems && (AnyPropertyType == type || type == rtype) &&
      (!rformat || format == rformat) &&
      (8 == format || 16 == format || 32 == format)) {
    return (winprop_t){
        .data.p8 = data,
        .nitems = nitems,
        .type = type,
        .format = format,
    };
  }

  cxfree(data);

  return (winprop_t){
      .data.p8 = NULL, .nitems = 0, .type = AnyPropertyType, .format = 0};
}"
Cisco-Talos-pyrebox-037efe8/qemu/exec.c	": the flat view that we want to translate on : the address to be translated in above address space : the translated address offset within memory region. It cannot be . : valid read/write length of the translated address. It can be  when we don't care about it. : page mask for the translated address. This should only be meaningful for IOMMU translated addresses, since there may be huge pages that this bit would tell. It can be  if we don't care about it. : whether the translation operation is for write : whether this can be MMIO, set true if it can This function is called from RCU critical section"	2	"static MemoryRegionSection flatview_do_translate(FlatView *fv, hwaddr addr,
                                                 hwaddr *xlat, hwaddr *plen_out,
                                                 hwaddr *page_mask_out,
                                                 bool is_write, bool is_mmio,
                                                 AddressSpace **target_as) {
  IOMMUTLBEntry iotlb;
  MemoryRegionSection *section;
  IOMMUMemoryRegion *iommu_mr;
  IOMMUMemoryRegionClass *imrc;
  hwaddr page_mask = (hwaddr)(-1);
  hwaddr plen = (hwaddr)(-1);

  if (plen_out) {
    plen = *plen_out;
  }

  for (;;) {
    section = address_space_translate_internal(flatview_to_dispatch(fv), addr,
                                               &addr, &plen, is_mmio);

    iommu_mr = memory_region_get_iommu(section->mr);
    if (!iommu_mr) {
      break;
    }
    imrc = memory_region_get_iommu_class_nocheck(iommu_mr);

    iotlb = imrc->translate(iommu_mr, addr, is_write ? IOMMU_WO : IOMMU_RO);
    addr =
        ((iotlb.translated_addr & ~iotlb.addr_mask) | (addr & iotlb.addr_mask));
    page_mask &= iotlb.addr_mask;
    plen = MIN(plen, (addr | iotlb.addr_mask) - addr + 1);
    if (!(iotlb.perm & (1 << is_write))) {
      goto translate_fail;
    }

    fv = address_space_to_flatview(iotlb.target_as);
    *target_as = iotlb.target_as;
  }

  *xlat = addr;

  if (page_mask == (hwaddr)(-1)) {

    page_mask = ~TARGET_PAGE_MASK;
  }

  if (page_mask_out) {
    *page_mask_out = page_mask;
  }

  if (plen_out) {
    *plen_out = plen;
  }

  return *section;

translate_fail:
  return (MemoryRegionSection){.mr = &io_mem_unassigned};
}"
liunianhuaguoyanxi-ZWlibstdc--3eae2e8/4/include/simd/quaternion.h	Constructs a quaternion from four scalar values.	2	"static inline SIMD_CFUNC simd_quatf simd_quaternion(float ix, float iy,
                                                    float iz, float r) {
  return (simd_quatf){{ix, iy, iz, r}};
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size."	1	"uint8_t
MS_Host_ReadDeviceCapacity(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                           const uint8_t LUNIndex,
                           SCSI_Capacity_t *const DeviceCapacity) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .DataTransferLength = sizeof(SCSI_Capacity_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       DeviceCapacity)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SwapEndian_n(&DeviceCapacity->Blocks, sizeof(DeviceCapacity->Blocks));
  SwapEndian_n(&DeviceCapacity->BlockSize, sizeof(DeviceCapacity->BlockSize));

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
mrirecon-bart-47fce6b/src/num/flpmath.c	Calculate inner product between two complex arrays (with strides) return iptr1^H * iptr2	2	"complex float md_zscalar2(unsigned int D, const long dim[D], const long str1[D],
                          const complex float *ptr1, const long str2[D],
                          const complex float *ptr2) {
  complex double ret = 0.;
  complex double *retp = &ret;

#ifdef USE_CUDA
  if (cuda_ondevice(ptr1)) {

    complex float *tmp = md_alloc_gpu(D, dim, CFL_SIZE);

    long strs[D];
    md_calc_strides(D, strs, dim, CFL_SIZE);
    md_clear(D, dim, tmp, CFL_SIZE);

    md_zfmacc2(D, dim, strs, tmp, str1, ptr1, str2, ptr2);

    gpu_ops.zsum(md_calc_size(D, dim), tmp);

    complex float ret = 0.;
    md_copy(1, (long[1]){1}, &ret, tmp, CFL_SIZE);
    md_free(tmp);

    return ret;
  }
#endif

#ifdef USE_CUDA
  if (cuda_ondevice(ptr1))
    retp = gpu_constant(&ret, CDL_SIZE);
#endif

  long stro[D];
  md_singleton_strides(D, stro);

  md_zfmaccD2(D, dim, stro, retp, str1, ptr1, str2, ptr2);

#ifdef USE_CUDA
  if (cuda_ondevice(ptr1)) {

    md_copy(1, (long[1]){1}, &ret, retp, CDL_SIZE);
    md_free(retp);
  }
#endif

  return (complex float)ret;
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the conjugate of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qconjugatel(const quaternion_long_double num) {
  return (quaternion_long_double){num.R, num.i * -1.0L, num.j * -1.0L,
                                  num.k * -1.0L};
}"
mansoncui-monit-1d7cce1/src/validate.c	Validate a program status. Events are posted according to its configuration. In case of a fatal event false is returned.	2	"State_Type check_program(Service_T s) {
  ASSERT(s);
  ASSERT(s->program);
  State_Type rv = State_Succeeded;
  time_t now = Time_now();
  Process_T P = s->program->P;
  if (P) {

    _programOutput(Process_getErrorStream(P), s->program->inprogressOutput);
    _programOutput(Process_getInputStream(P), s->program->inprogressOutput);

    if (Process_exitStatus(P) < 0) {
      int64_t execution_time = (now - s->program->started) * 1000;
      if (execution_time > s->program->timeout) {
        rv = State_Failed;
        LogError(
            ""'%s' program timed out after %s. Killing program with pid %ld\n"",
            s->name, Str_time2str(execution_time, (char[11]){}),
            (long)Process_getPid(P));
        Process_kill(P);
        Process_waitFor(P);

      } else {

        DEBUG(""'%s' status check deferred - waiting on program to exit\n"",
              s->name);
        return State_Init;
      }
    }
    s->program->exitStatus = Process_exitStatus(P);
    StringBuffer_trim(s->program->inprogressOutput);

    StringBuffer_clear(s->program->lastOutput);
    StringBuffer_append(s->program->lastOutput, ""%s"",
                        StringBuffer_toString(s->program->inprogressOutput));

    const char *output =
        StringBuffer_length(s->program->inprogressOutput)
            ? StringBuffer_toString(s->program->inprogressOutput)
            : ""no output"";
    for (Status_T status = s->statuslist; status; status = status->next) {
      if (status->operator== Operator_Changed) {
        if (status->initialized) {
          if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                   status->return_value)) {
            Event_post(s, Event_Status, State_Changed, status->action,
                       ""status changed (%d -> %d) -- %s"", status->return_value,
                       s->program->exitStatus, output);
            status->return_value = s->program->exitStatus;
          } else {
            Event_post(s, Event_Status, State_ChangedNot, status->action,
                       ""status didn't change (%d) -- %s"",
                       s->program->exitStatus, output);
          }
        } else {
          status->initialized = true;
          status->return_value = s->program->exitStatus;
        }
      } else {
        if (Util_evalQExpression(status->operator, s->program->exitStatus,
                                 status->return_value)) {
          rv = State_Failed;
          Event_post(s, Event_Status, State_Failed, status->action,
                     ""status failed (%d) -- %s"", s->program->exitStatus,
                     output);
        } else {
          Event_post(s, Event_Status, State_Succeeded, status->action,
                     ""status succeeded (%d) -- %s"", s->program->exitStatus,
                     output);
        }
      }
    }
    Process_free(&s->program->P);
  } else {
    rv = State_Init;
  }

  if (!_checkSkip(s) && s->monitor != Monitor_Not) {

    StringBuffer_clear(s->program->inprogressOutput);
    s->program->P = Command_execute(s->program->C);
    if (!s->program->P) {
      rv = State_Failed;
      Event_post(s, Event_Status, State_Failed, s->action_EXEC,
                 ""failed to execute '%s' -- %s"", s->path, STRERROR);
    } else {
      Event_post(s, Event_Status, State_Succeeded, s->action_EXEC,
                 ""program started"");
      s->program->started = now;
    }
  }
  return rv;
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavcodec/dirac.c	Dirac Specification -> 10.3 Parse Source Parameters. source_parameters(base_video_format)	2	"static int parse_source_parameters(AVCodecContext *avctx, GetBitContext *gb,
                                   dirac_source_params *source) {
  AVRational frame_rate = (AVRational){0, 0};
  unsigned luma_depth = 8, luma_offset = 16;
  int idx;

  if (get_bits1(gb)) {
    source->width = svq3_get_ue_golomb(gb);
    source->height = svq3_get_ue_golomb(gb);
  }

  if (get_bits1(gb))
    source->chroma_format = svq3_get_ue_golomb(gb);
  if (source->chroma_format > 2U) {
    av_log(avctx, AV_LOG_ERROR, ""Unknown chroma format %d\n"",
           source->chroma_format);
    return -1;
  }

  if (get_bits1(gb))
    source->interlaced = svq3_get_ue_golomb(gb);
  if (source->interlaced > 1U)
    return -1;

  if (get_bits1(gb)) {
    source->frame_rate_index = svq3_get_ue_golomb(gb);

    if (source->frame_rate_index > 10U)
      return -1;

    if (!source->frame_rate_index) {
      frame_rate.num = svq3_get_ue_golomb(gb);
      frame_rate.den = svq3_get_ue_golomb(gb);
    }
  }
  if (source->frame_rate_index > 0) {
    if (source->frame_rate_index <= 8)
      frame_rate = avpriv_frame_rate_tab[source->frame_rate_index];
    else
      frame_rate = dirac_frame_rate[source->frame_rate_index - 9];
  }
  av_reduce(&avctx->time_base.num, &avctx->time_base.den, frame_rate.den,
            frame_rate.num, 1 << 30);

  if (get_bits1(gb)) {
    source->aspect_ratio_index = svq3_get_ue_golomb(gb);

    if (source->aspect_ratio_index > 6U)
      return -1;

    if (!source->aspect_ratio_index) {
      avctx->sample_aspect_ratio.num = svq3_get_ue_golomb(gb);
      avctx->sample_aspect_ratio.den = svq3_get_ue_golomb(gb);
    }
  }
  if (source->aspect_ratio_index > 0)
    avctx->sample_aspect_ratio =
        dirac_preset_aspect_ratios[source->aspect_ratio_index - 1];

  if (get_bits1(gb)) {
    source->clean_width = svq3_get_ue_golomb(gb);
    source->clean_height = svq3_get_ue_golomb(gb);
    source->clean_left_offset = svq3_get_ue_golomb(gb);
    source->clean_right_offset = svq3_get_ue_golomb(gb);
  }

  if (get_bits1(gb)) {
    source->pixel_range_index = svq3_get_ue_golomb(gb);

    if (source->pixel_range_index > 4U)
      return -1;

    if (!source->pixel_range_index) {
      luma_offset = svq3_get_ue_golomb(gb);
      luma_depth = av_log2(svq3_get_ue_golomb(gb)) + 1;
      svq3_get_ue_golomb(gb);
      svq3_get_ue_golomb(gb);

      avctx->color_range = luma_offset ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG;
    }
  }
  if (source->pixel_range_index > 0) {
    idx = source->pixel_range_index - 1;
    luma_depth = pixel_range_presets[idx].bitdepth;
    avctx->color_range = pixel_range_presets[idx].color_range;
  }

  if (luma_depth > 8)
    av_log(avctx, AV_LOG_WARNING, ""Bitdepth greater than 8"");

  avctx->pix_fmt = dirac_pix_fmt[!luma_offset][source->chroma_format];

  if (get_bits1(gb)) {
    idx = source->color_spec_index = svq3_get_ue_golomb(gb);

    if (source->color_spec_index > 4U)
      return -1;

    avctx->color_primaries = dirac_color_presets[idx].color_primaries;
    avctx->colorspace = dirac_color_presets[idx].colorspace;
    avctx->color_trc = dirac_color_presets[idx].color_trc;

    if (!source->color_spec_index) {

      if (get_bits1(gb)) {
        idx = svq3_get_ue_golomb(gb);
        if (idx < 3U)
          avctx->color_primaries = dirac_primaries[idx];
      }

      if (get_bits1(gb)) {
        idx = svq3_get_ue_golomb(gb);
        if (!idx)
          avctx->colorspace = AVCOL_SPC_BT709;
        else if (idx == 1)
          avctx->colorspace = AVCOL_SPC_BT470BG;
      }

      if (get_bits1(gb) && !svq3_get_ue_golomb(gb))
        avctx->color_trc = AVCOL_TRC_BT709;
    }
  } else {
    idx = source->color_spec_index;
    avctx->color_primaries = dirac_color_presets[idx].color_primaries;
    avctx->colorspace = dirac_color_presets[idx].colorspace;
    avctx->color_trc = dirac_color_presets[idx].color_trc;
  }

  return 0;
}"
mansoncui-monit-1d7cce1/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVhB"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""id"", no_argument, NULL, 'i'},
                              {""help"", no_argument, NULL, 'h'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""batch"", no_argument, NULL, 'B'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""version"", no_argument, NULL, 'V'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.files.control = Str_dup(f);
      break;
    }
    case 'd': {
      Run.flags |= Run_Daemon;
      if (sscanf(optarg, ""%d"", &Run.polltime) != 1 || Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.files.log = Str_dup(optarg);
      if (IS(Run.files.log, ""syslog""))
        Run.flags |= Run_UseSyslog;
      Run.flags |= Run_Log;
      break;
    }
    case 'p': {
      Run.files.pid = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.files.state = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.flags |= Run_Foreground;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case 'B': {
      Run.flags |= Run_Batch;
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/N]> "");
    if (tolower(getchar()) == 'y') {
      File_delete(Run.files.id);
      Util_monitId(Run.files.id);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"
boazsegev-iodine-b6bdf50/ext/iodine/fio.c	This allows engines that lost their connection to their Pub/Sub service to resubscribe all the currently active channels with the new connection. CAUTION: This is an evented task... try not to free the engine's memory while resubscriptions are under way...	2	"void fio_pubsub_reattach(fio_pubsub_engine_s *eng) {
  fio_lock(&fio_postoffice.pubsub.lock);
  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {
    if (!pos->hash)
      continue;
    eng->subscribe(
        eng,
        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},
        NULL);
  }
  fio_unlock(&fio_postoffice.pubsub.lock);
  fio_lock(&fio_postoffice.patterns.lock);
  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {
    if (!pos->hash)
      continue;
    eng->subscribe(
        eng,
        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},
        pos->obj->match);
  }
  fio_unlock(&fio_postoffice.patterns.lock);
}"
legatoproject-legato-af-231fbd8/framework/liblegato/timer.c	Get the time remaining until the next scheduled expiry.	2	"(le_timer_Ref_t timerRef)

{
  Timer_t *timerPtr = GetTimer(timerRef);
  LE_FATAL_IF(NULL == timerPtr, ""Invalid timer reference %p."", timerRef);

  if (timerPtr->isActive == false) {
    return (le_clk_Time_t){0, 0};
  }

  le_clk_Time_t timeRemaining = le_clk_Sub(
      timerPtr->expiryTime, clk_GetRelativeTime(timerPtr->isWakeupEnabled));

  if (timeRemaining.sec < 0) {
    return (le_clk_Time_t){0, 0};
  }

  return timeRemaining;
}"
hhool-ffplayer-8016a4a/jni/libffmpeg/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int av_find_stream_info(AVFormatContext *ic) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC) {
      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);
    codec = avcodec_find_decoder(st->codec->codec_id);

    if (codec && codec->capabilities & CODEC_CAP_CHANNEL_CONF)
      st->codec->channels = 0;

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open(st->codec, codec);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open(st->codec, codec);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb(NULL)) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;

      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = av_read_frame_internal(ic, &pkt1);
    if (ret < 0 && ret != AVERROR(EAGAIN)) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    if (ret == AVERROR(EAGAIN))
      continue;

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))
      try_decode_frame(st, pkt);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }

  av_estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
ventanium-ventanium-e769f5e/src/vtm/net/socket_dgram_server.c	Runs the server. This method blocks until the server is stopped or if an error occurs.	2	"int vtm_socket_dgram_srv_run(vtm_socket_dgram_srv *srv,
                             struct vtm_socket_dgram_srv_opts *opts) {
  int rc;

  vtm_spinlock_lock(&srv->stop_lock);

  srv->cbs = opts->cbs;

  srv->socket = vtm_socket_new(opts->addr.family, VTM_SOCK_TYPE_DGRAM);
  if (!srv->socket) {
    rc = vtm_err_get_code();
    goto unlock;
  }

  rc = vtm_socket_bind(srv->socket, opts->addr.host, opts->addr.port);
  if (rc != VTM_OK)
    goto clean_socket;

  rc = vtm_socket_set_opt(srv->socket, VTM_SOCK_OPT_NONBLOCKING, (bool[]){true},
                          sizeof(bool));
  if (rc != VTM_OK)
    goto clean_socket;

  srv->listener = vtm_socket_listener_new(1);
  if (!srv->listener) {
    rc = vtm_err_get_code();
    goto clean_socket;
  }

  vtm_socket_set_state(srv->socket, VTM_SOCK_STAT_NBL_READ);
  rc = vtm_socket_listener_add(srv->listener, srv->socket);
  if (rc != VTM_OK)
    goto clean_listener;

  if (opts->threads > 0) {
    VTM_SQUEUE_INIT(srv->dgrams);
    srv->dgrams_mtx = vtm_mutex_new();
    if (!srv->dgrams_mtx) {
      rc = vtm_err_get_code();
      goto clean;
    }

    srv->dgrams_cond_not_empty = vtm_cond_new();
    srv->dgrams_cond_not_full = vtm_cond_new();
    if (!srv->dgrams_cond_not_empty || !srv->dgrams_cond_not_full) {
      rc = vtm_err_get_code();
      goto clean;
    }

    srv->dgrams_limit = opts->queue_limit;
    if (srv->dgrams_limit == 0)
      srv->dgrams_limit = opts->threads * 2;
  }

  vtm_atomic_flag_set(srv->running);
  rc = vtm_socket_dgram_srv_workers_span(srv, opts->threads);
  if (rc != VTM_OK)
    goto clean;

  if (srv->cbs.server_ready)
    srv->cbs.server_ready(srv, opts);

  vtm_spinlock_unlock(&srv->stop_lock);

  vtm_socket_dgram_srv_main_run(srv);

  vtm_socket_dgram_srv_workers_interrupt(srv);
  vtm_socket_dgram_srv_workers_join(srv);
  vtm_socket_dgram_srv_workers_free(srv);

  vtm_spinlock_lock(&srv->stop_lock);

clean:
  if (opts->threads > 0)
    VTM_SQUEUE_CLEAR(srv->dgrams, struct vtm_socket_dgram_srv_entry, free);

  vtm_cond_free(srv->dgrams_cond_not_empty);
  vtm_cond_free(srv->dgrams_cond_not_full);
  vtm_mutex_free(srv->dgrams_mtx);

clean_listener:
  vtm_socket_listener_remove(srv->listener, srv->socket);
  vtm_socket_listener_free(srv->listener);
  srv->listener = NULL;

clean_socket:
  vtm_socket_close(srv->socket);
  vtm_socket_free(srv->socket);

unlock:
  vtm_spinlock_unlock(&srv->stop_lock);

  return rc;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_setr_epi32(int __i0, int __i1, int __i2, int __i3, int __i4, int __i5,
                  int __i6, int __i7) {
  return (__m256i)(__v8si){__i0, __i1, __i2, __i3, __i4, __i5, __i6, __i7};
}"
boazsegev-iodine-b6bdf50/ext/iodine/websockets.c	Returns a subscription ID on success and 0 on failure.	2	"uintptr_t websocket_subscribe(struct websocket_subscribe_s args) {
  if (!args.ws || !fio_is_valid(args.ws->fd))
    goto error;
  websocket_sub_data_s *d = malloc(sizeof(*d));
  FIO_ASSERT_ALLOC(d);
  *d = (websocket_sub_data_s){
      .udata = args.udata,
      .on_message = args.on_message,
      .on_unsubscribe = args.on_unsubscribe,
  };
  void (*handler)(fio_msg_s *) = websocket_on_pubsub_message;
  if (!args.on_message) {
    intptr_t br_type;
    if (args.force_binary) {
      br_type = WEBSOCKET_OPTIMIZE_PUBSUB_BINARY;
      handler = websocket_on_pubsub_message_direct_bin;
    } else if (args.force_text) {
      br_type = WEBSOCKET_OPTIMIZE_PUBSUB_TEXT;
      handler = websocket_on_pubsub_message_direct_txt;
    } else {
      br_type = WEBSOCKET_OPTIMIZE_PUBSUB;
      handler = websocket_on_pubsub_message_direct;
    }
    websocket_optimize4broadcasts(br_type, 1);
    d->on_message =
        (void (*)(ws_s *, fio_str_info_s, fio_str_info_s, void *))br_type;
  }
  subscription_s *sub =
      fio_subscribe(.channel = args.channel, .match = args.match,
                    .on_unsubscribe = websocket_on_unsubscribe,
                    .on_message = handler, .udata1 = (void *)args.ws->fd,
                    .udata2 = d);
  if (!sub) {

    return 0;
  }
  fio_ls_s *pos;
  fio_lock(&args.ws->sub_lock);
  pos = fio_ls_push(&args.ws->subscriptions, sub);
  fio_unlock(&args.ws->sub_lock);

  return (uintptr_t)pos;
error:
  if (args.on_unsubscribe)
    args.on_unsubscribe(args.udata);
  return 0;
}"
PJK-libcbor-87f977e/src/cbor/ints.c	Allocates new integer with 8B width The width cannot be changed once allocated	2	"cbor_item_t *cbor_new_int64() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t) + 8);
  _CBOR_NOTNULL(item);
  *item = (cbor_item_t){.data = (unsigned char *)item + sizeof(cbor_item_t),
                        .refcount = 1,
                        .metadata = {.int_metadata = {.width = CBOR_INT_64}},
                        .type = CBOR_TYPE_UINT};
  return item;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Creates a 128-bit integer vector initialized to zero.	2	"_mm_setzero_si128(void) { return __extension__(__m128i)(__v2di){0LL, 0LL}; }"
GaiaMagic-monit-bc382b9/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVhB"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""id"", no_argument, NULL, 'i'},
                              {""help"", no_argument, NULL, 'h'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""batch"", no_argument, NULL, 'B'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""version"", no_argument, NULL, 'V'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.files.control = Str_dup(f);
      break;
    }
    case 'd': {
      Run.flags |= Run_Daemon;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.files.log = Str_dup(optarg);
      if (IS(Run.files.log, ""syslog""))
        Run.flags |= Run_UseSyslog;
      Run.flags |= Run_Log;
      break;
    }
    case 'p': {
      Run.files.pid = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.files.state = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.flags |= Run_Foreground;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case 'B': {
      Run.flags |= Run_Batch;
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.files.id);
      Util_monitId(Run.files.id);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"
opticron-libuweave-2e5e385/src/session.c	Marks a new session as valid.	2	"void uw_session_start_valid_(UwSession *session) {
  *session = (UwSession){
      .device = session->device, .valid = true, .role = kUwRoleUnspecified};
}"
OPENDAP-hdf5_handler-21f6449/HDF5CF.h	"Retrieve DDS information from the HDF5 file. The reason to separate reading DDS from DAS is: DAP needs to hold all values of attributes in the memory, building DDS doesn't need the attributes. So to reduce huge memory allocation for some HDF5 files, we separate the access of DAS from DDS although internally they still share common routines."	4	"string newname;
bool unlimited_dim;

friend class EOS5File;
friend class GMFile;
friend class File;
friend class Var;
friend class CVar;
friend class GMCVar;
friend class EOS5CVar;
friend class GMSPVar;
}
;

class Attribute {

public:
  Attribute() : dtype(H5UNSUPTYPE), count(0), fstrsize(0){};
  ~Attribute();

public:
  const string &getName() const { return this->name; }

  const string &getNewName() const { return this->newname; }

  H5DataType getType() const { return this->dtype; }

  hsize_t getCount() const { return this->count; }

  size_t getBufSize() const { return (this->value).size(); }

  const std::vector<char> &getValue() const { return this->value; }

  const std::vector<size_t> &getStrSize() const { return this->strsize; }"
wuzhiyi-CLRS-solution-c5a699a/Chapter08/P_8-7.c	"The basic column sort implementation. It does a copy of the array for steps 3 and 5. It also does not sort the half-columns in the beginning and the end, since that is not necessary for the correctness of the algorithm."	2	"void columnsort(number *A, size_t r, size_t s, column_sorter sort_columns) {
  size_t size = r * s;
  number *copy;
  column_t columns[s];

  check_dimensions(r, s);

  copy = calloc(size, sizeof(number));

  for (size_t i = 0; i < s; i++) {
    columns[i] = (column_t){i * r, r};
  }

  sort_columns(A, columns, s);

  for (size_t i = 0; i < size; i++) {
    copy[(i % s) * r + i / s] = A[i];
  }

  sort_columns(copy, columns, s);

  for (size_t i = 0; i < size; i++) {
    A[i] = copy[(i % s) * r + i / s];
  }

  sort_columns(A, columns, s);

  for (size_t i = 0; i < s - 1; i++) {
    columns[i] = (column_t){i * r + r / 2, r};
  }

  sort_columns(A, columns, s - 1);

  free(copy);
}"
cochrane-GLLara-91ed369/shared_simd/simd_matrix.h	Die Identitaetsmatrix  Kann man immer mal brauchen.	2	"static inline mat_float16 simd_mat_identity() {
  return (mat_float16){{1.0f, 0.0f, 0.0f, 0.0f},
                       {0.0f, 1.0f, 0.0f, 0.0f},
                       {0.0f, 0.0f, 1.0f, 0.0f},
                       {0.0f, 0.0f, 0.0f, 1.0f}};
}"
cascadeo-monit-8857544/src/monit.c	Handle program options - Options set from the commandline takes precedence over those found in the control file	2	"static void handle_options(int argc, char **argv) {
  int opt;
  int deferred_opt = 0;
  opterr = 0;
  Run.mygroup = NULL;
  const char *shortopts = ""c:d:g:l:p:s:HIirtvVh"";
#ifdef HAVE_GETOPT_LONG
  struct option longopts[] = {{""conf"", required_argument, NULL, 'c'},
                              {""daemon"", required_argument, NULL, 'd'},
                              {""group"", required_argument, NULL, 'g'},
                              {""logfile"", required_argument, NULL, 'l'},
                              {""pidfile"", required_argument, NULL, 'p'},
                              {""statefile"", required_argument, NULL, 's'},
                              {""hash"", optional_argument, NULL, 'H'},
                              {""interactive"", no_argument, NULL, 'I'},
                              {""id"", no_argument, NULL, 'i'},
                              {""resetid"", no_argument, NULL, 'r'},
                              {""test"", no_argument, NULL, 't'},
                              {""verbose"", no_argument, NULL, 'v'},
                              {""version"", no_argument, NULL, 'V'},
                              {""help"", no_argument, NULL, 'h'},
                              {0}};
  while ((opt = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1)
#else
  while ((opt = getopt(argc, argv, shortopts)) != -1)
#endif
  {
    switch (opt) {
    case 'c': {
      char *f = optarg;
      if (f[0] != SEPARATOR_CHAR)
        f = File_getRealPath(optarg, (char[PATH_MAX]){});
      if (!f)
        THROW(AssertException, ""The control file '%s' does not exist at %s"",
              Str_trunc(optarg, 80), Dir_cwd((char[STRLEN]){}, STRLEN));
      if (!File_isFile(f))
        THROW(AssertException, ""The control file '%s' is not a file"",
              Str_trunc(f, 80));
      if (!File_isReadable(f))
        THROW(AssertException, ""The control file '%s' is not readable"",
              Str_trunc(f, 80));
      Run.files.control = Str_dup(f);
      break;
    }
    case 'd': {
      Run.flags |= Run_Daemon;
      sscanf(optarg, ""%d"", &Run.polltime);
      if (Run.polltime < 1) {
        LogError(""Option -%c requires a natural number\n"", opt);
        exit(1);
      }
      break;
    }
    case 'g': {
      Run.mygroup = Str_dup(optarg);
      break;
    }
    case 'l': {
      Run.files.log = Str_dup(optarg);
      if (IS(Run.files.log, ""syslog""))
        Run.flags |= Run_UseSyslog;
      Run.flags |= Run_Log;
      break;
    }
    case 'p': {
      Run.files.pid = Str_dup(optarg);
      break;
    }
    case 's': {
      Run.files.state = Str_dup(optarg);
      break;
    }
    case 'I': {
      Run.flags |= Run_Foreground;
      break;
    }
    case 'i': {
      deferred_opt = 'i';
      break;
    }
    case 'r': {
      deferred_opt = 'r';
      break;
    }
    case 't': {
      deferred_opt = 't';
      break;
    }
    case 'v': {
      Run.debug++;
      break;
    }
    case 'H': {
      if (argc > optind)
        Util_printHash(argv[optind]);
      else
        Util_printHash(NULL);
      exit(0);
      break;
    }
    case 'V': {
      version();
      exit(0);
      break;
    }
    case 'h': {
      help();
      exit(0);
      break;
    }
    case '?': {
      switch (optopt) {
      case 'c':
      case 'd':
      case 'g':
      case 'l':
      case 'p':
      case 's': {
        LogError(""Option -- %c requires an argument\n"", optopt);
        break;
      }
      default: {
        LogError(""Invalid option -- %c  (-h will show valid options)\n"",
                 optopt);
      }
      }
      exit(1);
    }
    }
  }

  switch (deferred_opt) {
  case 't': {
    do_init();
    printf(""Control file syntax OK\n"");
    exit(0);
    break;
  }
  case 'r': {
    do_init();
    assert(Run.id);
    printf(""Reset Monit Id? [y/n]> "");
    if (getchar() == 'y') {
      File_delete(Run.files.id);
      Util_monitId(Run.files.id);
      kill_daemon(SIGHUP);
    }
    exit(0);
    break;
  }
  case 'i': {
    do_init();
    assert(Run.id);
    printf(""Monit ID: %s\n"", Run.id);
    exit(0);
    break;
  }
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_set_ps(float __a, float __b, float __c, float __d, float __e, float __f,
              float __g, float __h) {
  return (__m256){__h, __g, __f, __e, __d, __c, __b, __a};
}"
HiPhish-XeenTools-ee7c26c/Source/sprite/sprite_tool.c	Get a frame of animation from a sprite.	2	"int xeen_get_frame(XeenSprite sprite, XeenFrame *frame, uint16_t index,
                   uint8_t transparent) {
  enum {
    SUCCESS,
    INVALID_ARGS,
    ALLOC_FAIL,
  } error = SUCCESS;

  uint8_t *pixels = NULL;

  if (!sprite.cell || !sprite.map || !frame) {
    error = INVALID_ARGS;
    goto fail;
  } else if (frame->pixels != NULL || frame->width != 0 || frame->height != 0) {
    error = INVALID_ARGS;
    goto fail;
  }

  int i[2] = {
      sprite.map[index][0],
      sprite.map[index][1],
  };

  int surface[2] = {
      sprite.cell[i[0]].width * sprite.cell[i[0]].height,
      sprite.cell[i[1]].width * sprite.cell[i[1]].height,
  };

  uint16_t width = sprite.cell[i[0]].width > sprite.cell[i[1]].width
                       ? sprite.cell[i[0]].width
                       : sprite.cell[i[1]].width;
  uint16_t height = sprite.cell[i[0]].height > sprite.cell[i[1]].height
                        ? sprite.cell[i[0]].height
                        : sprite.cell[i[1]].height;

  ALLOC(pixels, sizeof(uint8_t) * width * height)

  memcpy(pixels, sprite.cell[i[0]].pixels, surface[0] * sizeof(uint8_t));

  if (i[0] == i[1]) {
    goto end;
  }

  if (sprite.cell[i[0]].height < height) {
    for (int i = surface[0]; i < width * height; ++i) {
      pixels[i] = transparent;
    }
  }

  for (int j = 0; j < surface[1]; ++j) {
    if (sprite.cell[i[1]].pixels[j] == transparent) {
      continue;
    }
    pixels[j] = sprite.cell[i[1]].pixels[j];
  }

end:
  *frame = (XeenFrame){
      .width = width,
      .height = height,
      .pixels = pixels,
  };

  return error;

fail:
  if (pixels) {
    free(pixels);
  }
  return error;
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->input_count; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink = link->src->input_count ? link->src->inputs[0] : NULL;

    if (!link)
      continue;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->input_count != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0)
        return ret;

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink) {
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->sample_rate)
            link->sample_rate = inlink->sample_rate;
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        } else if (!link->sample_rate) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Audio source filters must set their output link's ""
                 ""sample_rate\n"");
          return AVERROR(EINVAL);
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0)
          return ret;

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/HID.c	"Switches the attached HID device's reporting protocol over to the Boot Report protocol mode, on supported devices."	1	"uint8_t
HID_Host_SetBootProtocol(USB_ClassInfo_HID_Host_t *const HIDInterfaceInfo) {
  uint8_t ErrorCode;

  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = REQ_SetProtocol,
      .wValue = 0,
      .wIndex = HIDInterfaceInfo->State.InterfaceNumber,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  if (!(HIDInterfaceInfo->State.SupportsBootProtocol))
    return HID_ERROR_LOGICAL;

  if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
      HOST_SENDCONTROL_Successful)
    return ErrorCode;

  HIDInterfaceInfo->State.LargestReportSize = 8;
  HIDInterfaceInfo->State.UsingBootProtocol = true;

  return HOST_SENDCONTROL_Successful;
}"
globus-globus-toolkit-3f00bce/gsi/gssapi/source/test/sni-test.c	"In this test case, establish a security context, with server ready for SNI, and the client sends a name that only matches the wildcard name. The SNI callback should respond with the wildcard credential. The client inquires the peer name and verifies it matches the desired credential."	3	"init_sni_wildcard(void) {
  OM_uint32 major_status = GSS_S_COMPLETE;
  OM_uint32 minor_status = GLOBUS_SUCCESS;
  gss_ctx_id_t init_context = GSS_C_NO_CONTEXT;
  gss_ctx_id_t accept_context = GSS_C_NO_CONTEXT;
  gss_name_t target_name = GSS_C_NO_NAME;
  gss_name_t peer_name = GSS_C_NO_NAME;
  gss_buffer_desc init_generated_token = {0};
  gss_buffer_desc accept_generated_token = {0};
  bool result = true;
  int name_equal = false;
  OM_uint32 ignore_minor_status = 0;

  major_status = gss_set_sec_context_option(&minor_status, &accept_context,
                                            GSS_SNI_CREDENTIALS,
                                            &(gss_buffer_desc){
                                                .value = creds,
                                                .length = sizeof(creds),
                                            });
  if (major_status != GSS_S_COMPLETE) {
    result = false;

    goto fail;
  }

  major_status =
      gss_import_name(&minor_status,
                      &(gss_buffer_desc){
                          .value = ""wildcard.example.globus.org"",
                          .length = strlen(""wildcard.example.globus.org""),
                      },
                      GLOBUS_GSS_C_NT_HOST_IP, &target_name);

  if (major_status != GSS_S_COMPLETE) {
    result = false;
    goto fail;
  }
  do {
    major_status = gss_init_sec_context(
        &minor_status, GSS_C_NO_CREDENTIAL, &init_context, target_name,
        GSS_C_NO_OID, 0, 0, GSS_C_NO_CHANNEL_BINDINGS, &accept_generated_token,
        NULL, &init_generated_token, NULL, NULL);

    gss_release_buffer(&ignore_minor_status, &accept_generated_token);

    if (GSS_ERROR(major_status)) {
      result = false;
      break;
    }

    if (init_generated_token.length > 0) {
      major_status = gss_accept_sec_context(
          &minor_status, &accept_context, GSS_C_NO_CREDENTIAL,
          &init_generated_token, GSS_C_NO_CHANNEL_BINDINGS, NULL, NULL,
          &accept_generated_token, NULL, NULL, NULL);
      gss_release_buffer(&ignore_minor_status, &init_generated_token);

      if (GSS_ERROR(major_status)) {
        result = false;
      }
    }
  } while (major_status == GSS_S_CONTINUE_NEEDED);

  if (major_status == GSS_S_COMPLETE) {
    major_status =
        gss_inquire_context(&minor_status, init_context, NULL, &peer_name, NULL,
                            NULL, NULL, NULL, NULL);
    if (major_status != GSS_S_COMPLETE) {
      result = false;

      goto fail;
    }

    major_status =
        gss_compare_name(&minor_status, target_name, peer_name, &name_equal);

    if (major_status != GSS_S_COMPLETE) {
      result = false;
    }
  }

fail:
  if (major_status != GSS_S_COMPLETE) {
    globus_gsi_gssapi_test_print_error(stderr, major_status, minor_status);
  }

  if (init_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &init_context, NULL);
  }
  if (accept_context != GSS_C_NO_CONTEXT) {
    gss_delete_sec_context(&ignore_minor_status, &accept_context, NULL);
  }
  if (peer_name != GSS_C_NO_NAME) {
    gss_release_name(&ignore_minor_status, &peer_name);
  }
  if (init_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &init_generated_token);
  }
  if (accept_generated_token.length != 0) {
    gss_release_buffer(&ignore_minor_status, &accept_generated_token);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }
  if (target_name != GSS_C_NO_NAME) {
    gss_release_name(&minor_status, &target_name);
  }

  return result;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Read Capacity command to the attached device, to determine the capacity of the given Logical Unit within the device."	2	"uint8_t MassStore_ReadCapacity(const uint8_t LUNIndex,
                               SCSI_Capacity_t *const CapacityPtr) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = sizeof(SCSI_Capacity_t),
                 .Flags = COMMAND_DIRECTION_DATA_IN,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 10},

      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_WaitForDataReceived()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  if ((ReturnCode = MassStore_SendReceiveData(CapacityPtr)) !=
      PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  CapacityPtr->Blocks = SwapEndian_32(CapacityPtr->Blocks);
  CapacityPtr->BlockSize = SwapEndian_32(CapacityPtr->BlockSize);

  if ((ReturnCode = MassStore_GetReturnedStatus()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libpostproc/postprocess_template.c	Filter array of bytes (Y or U or V values)	2	"static void RENAME(postProcess)(const uint8_t src[], int srcStride,
                                uint8_t dst[], int dstStride, int width,
                                int height, const QP_STORE_T QPs[],
                                int QPStride, int isColor, PPContext *c2) {
  DECLARE_ALIGNED(8, PPContext, c) = *c2;
  int x, y;
#ifdef TEMPLATE_PP_TIME_MODE
  const int mode = TEMPLATE_PP_TIME_MODE;
#else
  const int mode = isColor ? c.ppMode.chromMode : c.ppMode.lumMode;
#endif
  int black = 0, white = 255;
  int QPCorrecture = 256 * 256;

  int copyAhead;
#if TEMPLATE_PP_MMX
  int i;
#endif

  const int qpHShift = isColor ? 4 - c.hChromaSubSample : 4;
  const int qpVShift = isColor ? 4 - c.vChromaSubSample : 4;

  uint64_t *const yHistogram = c.yHistogram;
  uint8_t *const tempSrc =
      srcStride > 0 ? c.tempSrc : c.tempSrc - 23 * srcStride;
  uint8_t *const tempDst =
      (dstStride > 0 ? c.tempDst : c.tempDst - 23 * dstStride) + 32;

  if (mode & VISUALIZE) {
    if (!(mode & (V_A_DEBLOCK | H_A_DEBLOCK)) || TEMPLATE_PP_MMX) {
      av_log(c2, AV_LOG_WARNING,
             ""Visualization is currently only supported with the accurate ""
             ""deblock filter without SIMD\n"");
    }
  }

#if TEMPLATE_PP_MMX
  for (i = 0; i < 57; i++) {
    int offset = ((i * c.ppMode.baseDcDiff) >> 8) + 1;
    int threshold = offset * 2 + 1;
    c.mmxDcOffset[i] = 0x7F - offset;
    c.mmxDcThreshold[i] = 0x7F - threshold;
    c.mmxDcOffset[i] *= 0x0101010101010101LL;
    c.mmxDcThreshold[i] *= 0x0101010101010101LL;
  }
#endif

  if (mode & CUBIC_IPOL_DEINT_FILTER)
    copyAhead = 16;
  else if ((mode & LINEAR_BLEND_DEINT_FILTER) || (mode & FFMPEG_DEINT_FILTER) ||
           (mode & LOWPASS5_DEINT_FILTER))
    copyAhead = 14;
  else if ((mode & V_DEBLOCK) || (mode & LINEAR_IPOL_DEINT_FILTER) ||
           (mode & MEDIAN_DEINT_FILTER) || (mode & V_A_DEBLOCK))
    copyAhead = 13;
  else if (mode & V_X1_FILTER)
    copyAhead = 11;

  else if (mode & DERING)
    copyAhead = 9;
  else
    copyAhead = 8;

  copyAhead -= 8;

  if (!isColor) {
    uint64_t sum = 0;
    int i;
    uint64_t maxClipped;
    uint64_t clipped;
    AVRational scale;

    c.frameNum++;

    if (c.frameNum == 1)
      yHistogram[0] = width * (uint64_t)height / 64 * 15 / 256;

    for (i = 0; i < 256; i++) {
      sum += yHistogram[i];
    }

    maxClipped = av_rescale(sum, c.ppMode.maxClippedThreshold.num,
                            c.ppMode.maxClippedThreshold.den);

    clipped = sum;
    for (black = 255; black > 0; black--) {
      if (clipped < maxClipped)
        break;
      clipped -= yHistogram[black];
    }

    clipped = sum;
    for (white = 0; white < 256; white++) {
      if (clipped < maxClipped)
        break;
      clipped -= yHistogram[white];
    }

    scale = (AVRational){c.ppMode.maxAllowedY - c.ppMode.minAllowedY,
                         white - black};

#if TEMPLATE_PP_MMXEXT
    c.packedYScale = (uint16_t)av_rescale(scale.num, 256, scale.den);
    c.packedYOffset =
        (((black * c.packedYScale) >> 8) - c.ppMode.minAllowedY) & 0xFFFF;
#else
    c.packedYScale = (uint16_t)av_rescale(scale.num, 1024, scale.den);
    c.packedYOffset = (black - c.ppMode.minAllowedY) & 0xFFFF;
#endif

    c.packedYOffset |= c.packedYOffset << 32;
    c.packedYOffset |= c.packedYOffset << 16;

    c.packedYScale |= c.packedYScale << 32;
    c.packedYScale |= c.packedYScale << 16;

    if (mode & LEVEL_FIX)
      QPCorrecture = (int)av_rescale(scale.num, 256 * 256, scale.den);
    else
      QPCorrecture = 256 * 256;
  } else {
    c.packedYScale = 0x0100010001000100LL;
    c.packedYOffset = 0;
    QPCorrecture = 256 * 256;
  }

  y = -BLOCK_SIZE;
  {
    const uint8_t *srcBlock = &(src[y * srcStride]);
    uint8_t *dstBlock = tempDst + dstStride;

    for (x = 0; x < width; x += BLOCK_SIZE) {
      RENAME(prefetchnta)
      (srcBlock + (((x >> 2) & 6) + copyAhead) * srcStride + 32);
      RENAME(prefetchnta)
      (srcBlock + (((x >> 2) & 6) + copyAhead + 1) * srcStride + 32);
      RENAME(prefetcht0)
      (dstBlock + (((x >> 2) & 6) + copyAhead) * dstStride + 32);
      RENAME(prefetcht0)
      (dstBlock + (((x >> 2) & 6) + copyAhead + 1) * dstStride + 32);

      RENAME(blockCopy)
      (dstBlock + dstStride * 8, dstStride, srcBlock + srcStride * 8, srcStride,
       mode & LEVEL_FIX, &c.packedYOffset);

      RENAME(duplicate)(dstBlock + dstStride * 8, dstStride);

      if (mode & LINEAR_IPOL_DEINT_FILTER)
        RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
      else if (mode & LINEAR_BLEND_DEINT_FILTER)
        RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
      else if (mode & MEDIAN_DEINT_FILTER)
        RENAME(deInterlaceMedian)(dstBlock, dstStride);
      else if (mode & CUBIC_IPOL_DEINT_FILTER)
        RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
      else if (mode & FFMPEG_DEINT_FILTER)
        RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
      else if (mode & LOWPASS5_DEINT_FILTER)
        RENAME(deInterlaceL5)
        (dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);

      dstBlock += 8;
      srcBlock += 8;
    }
    if (width == FFABS(dstStride))
      linecpy(dst, tempDst + 9 * dstStride, copyAhead, dstStride);
    else {
      int i;
      for (i = 0; i < copyAhead; i++) {
        memcpy(dst + i * dstStride, tempDst + (9 + i) * dstStride, width);
      }
    }
  }

  for (y = 0; y < height; y += BLOCK_SIZE) {

    const uint8_t *srcBlock = &(src[y * srcStride]);
    uint8_t *dstBlock = &(dst[y * dstStride]);
#if TEMPLATE_PP_MMX
    uint8_t *tempBlock1 = c.tempBlocks;
    uint8_t *tempBlock2 = c.tempBlocks + 8;
#endif
    const int8_t *QPptr = &QPs[(y >> qpVShift) * QPStride];
    int8_t *nonBQPptr = &c.nonBQPTable[(y >> qpVShift) * FFABS(QPStride)];
    int QP = 0, nonBQP = 0;

    if (y + 15 >= height) {
      int i;

      linecpy(tempSrc + srcStride * copyAhead, srcBlock + srcStride * copyAhead,
              FFMAX(height - y - copyAhead, 0), srcStride);

      for (i = FFMAX(height - y, 8); i < copyAhead + 8; i++)
        memcpy(tempSrc + srcStride * i, src + srcStride * (height - 1),
               FFABS(srcStride));

      linecpy(tempDst, dstBlock - dstStride,
              FFMIN(height - y + 1, copyAhead + 1), dstStride);

      for (i = height - y + 1; i <= copyAhead; i++)
        memcpy(tempDst + dstStride * i, dst + dstStride * (height - 1),
               FFABS(dstStride));

      dstBlock = tempDst + dstStride;
      srcBlock = tempSrc;
    }

    for (x = 0; x < width;) {
      int startx = x;
      int endx = FFMIN(width, x + 32);
      uint8_t *dstBlockStart = dstBlock;
      const uint8_t *srcBlockStart = srcBlock;
      int qp_index = 0;
      for (qp_index = 0; qp_index < (endx - startx) / BLOCK_SIZE; qp_index++) {
        QP = QPptr[(x + qp_index * BLOCK_SIZE) >> qpHShift];
        nonBQP = nonBQPptr[(x + qp_index * BLOCK_SIZE) >> qpHShift];
        if (!isColor) {
          QP = (QP * QPCorrecture + 256 * 128) >> 16;
          nonBQP = (nonBQP * QPCorrecture + 256 * 128) >> 16;
          yHistogram[(srcBlock + qp_index * 8)[srcStride * 12 + 4]]++;
        }
        c.QP_block[qp_index] = QP;
        c.nonBQP_block[qp_index] = nonBQP;
#if TEMPLATE_PP_MMX
        __asm__ volatile(""movd %1, %%mm7         \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""packuswb %%mm7, %%mm7  \n\t""
                         ""movq %%mm7, %0         \n\t""
                         : ""=m""(c.pQPb_block[qp_index])
                         : ""r""(QP));
#endif
      }
      for (; x < endx; x += BLOCK_SIZE) {
        RENAME(prefetchnta)
        (srcBlock + (((x >> 2) & 6) + copyAhead) * srcStride + 32);
        RENAME(prefetchnta)
        (srcBlock + (((x >> 2) & 6) + copyAhead + 1) * srcStride + 32);
        RENAME(prefetcht0)
        (dstBlock + (((x >> 2) & 6) + copyAhead) * dstStride + 32);
        RENAME(prefetcht0)
        (dstBlock + (((x >> 2) & 6) + copyAhead + 1) * dstStride + 32);

        RENAME(blockCopy)
        (dstBlock + dstStride * copyAhead, dstStride,
         srcBlock + srcStride * copyAhead, srcStride, mode & LEVEL_FIX,
         &c.packedYOffset);

        if (mode & LINEAR_IPOL_DEINT_FILTER)
          RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
        else if (mode & LINEAR_BLEND_DEINT_FILTER)
          RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
        else if (mode & MEDIAN_DEINT_FILTER)
          RENAME(deInterlaceMedian)(dstBlock, dstStride);
        else if (mode & CUBIC_IPOL_DEINT_FILTER)
          RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
        else if (mode & FFMPEG_DEINT_FILTER)
          RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
        else if (mode & LOWPASS5_DEINT_FILTER)
          RENAME(deInterlaceL5)
          (dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);

        dstBlock += 8;
        srcBlock += 8;
      }

      dstBlock = dstBlockStart;
      srcBlock = srcBlockStart;

      for (x = startx, qp_index = 0; x < endx; x += BLOCK_SIZE, qp_index++) {
        const int stride = dstStride;

        c.QP = c.QP_block[qp_index];
        c.nonBQP = c.nonBQP_block[qp_index];
        c.pQPb = c.pQPb_block[qp_index];
        c.pQPb2 = c.pQPb2_block[qp_index];

        if (y + 8 < height) {
          if (mode & V_X1_FILTER)
            RENAME(vertX1Filter)(dstBlock, stride, &c);
          else if (mode & V_DEBLOCK) {
            const int t = RENAME(vertClassify)(dstBlock, stride, &c);

            if (t == 1)
              RENAME(doVertLowPass)(dstBlock, stride, &c);
            else if (t == 2)
              RENAME(doVertDefFilter)(dstBlock, stride, &c);
          } else if (mode & V_A_DEBLOCK) {
            RENAME(do_a_deblock)(dstBlock, stride, 1, &c, mode);
          }
        }

        dstBlock += 8;
        srcBlock += 8;
      }

      dstBlock = dstBlockStart;
      srcBlock = srcBlockStart;

      for (x = startx, qp_index = 0; x < endx; x += BLOCK_SIZE, qp_index++) {
        const int stride = dstStride;
        av_unused uint8_t *tmpXchg;
        c.QP = c.QP_block[qp_index];
        c.nonBQP = c.nonBQP_block[qp_index];
        c.pQPb = c.pQPb_block[qp_index];
        c.pQPb2 = c.pQPb2_block[qp_index];
#if TEMPLATE_PP_MMX
        RENAME(transpose1)(tempBlock1, tempBlock2, dstBlock, dstStride);
#endif

        if (x - 8 >= 0) {
#if TEMPLATE_PP_MMX
          if (mode & H_X1_FILTER)
            RENAME(vertX1Filter)(tempBlock1, 16, &c);
          else if (mode & H_DEBLOCK) {
            const int t = RENAME(vertClassify)(tempBlock1, 16, &c);
            if (t == 1)
              RENAME(doVertLowPass)(tempBlock1, 16, &c);
            else if (t == 2)
              RENAME(doVertDefFilter)(tempBlock1, 16, &c);
          } else if (mode & H_A_DEBLOCK) {
            RENAME(do_a_deblock)(tempBlock1, 16, 1, &c, mode);
          }

          RENAME(transpose2)(dstBlock - 4, dstStride, tempBlock1 + 4 * 16);

#else
          if (mode & H_X1_FILTER)
            horizX1Filter(dstBlock - 4, stride, c.QP);
          else if (mode & H_DEBLOCK) {
#if TEMPLATE_PP_ALTIVEC
            DECLARE_ALIGNED(16, unsigned char, tempBlock)[272];
            int t;
            transpose_16x8_char_toPackedAlign_altivec(
                tempBlock, dstBlock - (4 + 1), stride);

            t = vertClassify_altivec(tempBlock - 48, 16, &c);
            if (t == 1) {
              doVertLowPass_altivec(tempBlock - 48, 16, &c);
              transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1),
                                                          tempBlock, stride);
            } else if (t == 2) {
              doVertDefFilter_altivec(tempBlock - 48, 16, &c);
              transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1),
                                                          tempBlock, stride);
            }
#else
            const int t = RENAME(horizClassify)(dstBlock - 4, stride, &c);

            if (t == 1)
              RENAME(doHorizLowPass)(dstBlock - 4, stride, &c);
            else if (t == 2)
              RENAME(doHorizDefFilter)(dstBlock - 4, stride, &c);
#endif
          } else if (mode & H_A_DEBLOCK) {
            RENAME(do_a_deblock)(dstBlock - 8, 1, stride, &c, mode);
          }
#endif
          if (mode & DERING) {

            if (y > 0)
              RENAME(dering)(dstBlock - stride - 8, stride, &c);
          }

          if (mode & TEMP_NOISE_FILTER) {
            RENAME(tempNoiseReducer)
            (dstBlock - 8, stride, c.tempBlurred[isColor] + y * dstStride + x,
             c.tempBlurredPast[isColor] + (y >> 3) * 256 + (x >> 3) + 256,
             c.ppMode.maxTmpNoise);
          }
        }

        dstBlock += 8;
        srcBlock += 8;

#if TEMPLATE_PP_MMX
        tmpXchg = tempBlock1;
        tempBlock1 = tempBlock2;
        tempBlock2 = tmpXchg;
#endif
      }
    }

    if (mode & DERING) {
      if (y > 0)
        RENAME(dering)(dstBlock - dstStride - 8, dstStride, &c);
    }

    if ((mode & TEMP_NOISE_FILTER)) {
      RENAME(tempNoiseReducer)
      (dstBlock - 8, dstStride, c.tempBlurred[isColor] + y * dstStride + x,
       c.tempBlurredPast[isColor] + (y >> 3) * 256 + (x >> 3) + 256,
       c.ppMode.maxTmpNoise);
    }

    if (y + 15 >= height) {
      uint8_t *dstBlock = &(dst[y * dstStride]);
      if (width == FFABS(dstStride))
        linecpy(dstBlock, tempDst + dstStride, height - y, dstStride);
      else {
        int i;
        for (i = 0; i < height - y; i++) {
          memcpy(dstBlock + i * dstStride, tempDst + (i + 1) * dstStride,
                 width);
        }
      }
    }
  }
#if TEMPLATE_PP_3DNOW
  __asm__ volatile(""femms"");
#elif TEMPLATE_PP_MMX
  __asm__ volatile(""emms"");
#endif

#ifdef DEBUG_BRIGHTNESS
  if (!isColor) {
    int max = 1;
    int i;
    for (i = 0; i < 256; i++)
      if (yHistogram[i] > max)
        max = yHistogram[i];

    for (i = 1; i < 256; i++) {
      int x;
      int start = yHistogram[i - 1] / (max / 256 + 1);
      int end = yHistogram[i] / (max / 256 + 1);
      int inc = end > start ? 1 : -1;
      for (x = start; x != end + inc; x += inc)
        dst[i * dstStride + x] += 128;
    }

    for (i = 0; i < 100; i += 2) {
      dst[(white)*dstStride + i] += 128;
      dst[(black)*dstStride + i] += 128;
    }
  }
#endif

  *c2 = c;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Device/LowLevel/MIDI/MIDI.c	"Task to handle the generation of MIDI note change events in response to presses of the board joystick, and send them to the host."	0	"void MIDI_Task(void) {
  static uint8_t PrevJoystickStatus;

  if (USB_DeviceState != DEVICE_STATE_Configured)
    return;

  Endpoint_SelectEndpoint(MIDI_STREAM_IN_EPNUM);

  if (Endpoint_IsINReady()) {
    uint8_t MIDICommand = 0;
    uint8_t MIDIPitch;

    uint8_t JoystickStatus = Joystick_GetStatus();
    uint8_t JoystickChanges = (JoystickStatus ^ PrevJoystickStatus);

    uint8_t Channel =
        ((Buttons_GetStatus() & BUTTONS_BUTTON1) ? MIDI_CHANNEL(10)
                                                 : MIDI_CHANNEL(1));

    if (JoystickChanges & JOY_LEFT) {
      MIDICommand = ((JoystickStatus & JOY_LEFT) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3C;
    }

    if (JoystickChanges & JOY_UP) {
      MIDICommand = ((JoystickStatus & JOY_UP) ? MIDI_COMMAND_NOTE_ON
                                               : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3D;
    }

    if (JoystickChanges & JOY_RIGHT) {
      MIDICommand = ((JoystickStatus & JOY_RIGHT) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3E;
    }

    if (JoystickChanges & JOY_DOWN) {
      MIDICommand = ((JoystickStatus & JOY_DOWN) ? MIDI_COMMAND_NOTE_ON
                                                 : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3F;
    }

    if (JoystickChanges & JOY_PRESS) {
      MIDICommand = ((JoystickStatus & JOY_PRESS) ? MIDI_COMMAND_NOTE_ON
                                                  : MIDI_COMMAND_NOTE_OFF);
      MIDIPitch = 0x3B;
    }

    if (MIDICommand) {
      MIDI_EventPacket_t MIDIEvent = (MIDI_EventPacket_t){
          .CableNumber = 0,
          .Command = (MIDICommand >> 4),

          .Data1 = MIDICommand | Channel,
          .Data2 = MIDIPitch,
          .Data3 = MIDI_STANDARD_VELOCITY,
      };

      Endpoint_Write_Stream_LE(&MIDIEvent, sizeof(MIDIEvent));

      Endpoint_ClearIN();
    }

    PrevJoystickStatus = JoystickStatus;
  }

  Endpoint_SelectEndpoint(MIDI_STREAM_OUT_EPNUM);

  if (Endpoint_IsOUTReceived()) {
    MIDI_EventPacket_t MIDIEvent;

    Endpoint_Read_Stream_LE(&MIDIEvent, sizeof(MIDIEvent));

    if ((MIDIEvent.Command == (MIDI_COMMAND_NOTE_ON >> 4)) &&
        (MIDIEvent.Data3 > 0)) {

      LEDs_SetAllLEDs(MIDIEvent.Data2 > 64 ? LEDS_LED1 : LEDS_LED2);
    } else {

      LEDs_SetAllLEDs(LEDS_NO_LEDS);
    }

    if (!(Endpoint_BytesInEndpoint())) {

      Endpoint_ClearOUT();
    }
  }
}"
blchinezu-pocketbook-coolreader-654f294/crengine/include/lvtinydom.h	allocate new tiny node	2	"ldomXRangeList(ldomXRangeList &srcList, ldomXRange &filter);
#if BUILD_LITE != 1

void splitText(ldomMarkedTextList &dst, ldomNode *textNodeToSplit);

void getRanges(ldomMarkedRangeList &dst);
#endif

void split(ldomXRange *r);

ldomXRangeList(){};
}
;

class LVTocItem;
class LVDocView;

class LVTocItem {
  friend class LVDocView;

private:
  LVTocItem *_parent;
  ldomDocument *_doc;
  lInt32 _level;
  lInt32 _index;
  lInt32 _page;
  lInt32 _percent;
  lString16 _name;
  lString16 _path;
  ldomXPointer _position;
  LVPtrVector<LVTocItem> _children;

  LVTocItem(ldomXPointer pos, lString16 path, const lString16 &name)
      : _parent(NULL), _level(0), _index(0), _page(0), _percent(0), _name(name),
        _path(path), _position(pos) {}
  void addChild(LVTocItem *item) {
    item->_level = _level + 1;
    item->_parent = this;
    item->_index = _children.length(), item->_doc = _doc;
    _children.add(item);
  }

  void setPage(int n) { _page = n; }
  void setPercent(int n) { _percent = n; }

public:
  bool serialize(SerialBuf &buf);

  bool deserialize(ldomDocument *doc, SerialBuf &buf);

  int getPage() { return _page; }

  int getPercent() { return _percent; }

  LVTocItem *getParent() const { return _parent; }"
w4ilun-pocket-keyboard-d87c861/firmware/tmk_core/protocol/lufa/LUFA-git/Demos/Host/LowLevel/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Test Unit Ready command to the attached device, to determine if the device is ready to accept other commands."	1	"uint8_t MassStore_TestUnitReady(const uint8_t LUNIndex) {

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = MS_CBW_SIGNATURE,
      .DataTransferLength = 0,
      .Flags = MS_COMMAND_DIR_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  return MassStore_SendCommand(&SCSICommandBlock, NULL);
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

  st->codec = avcodec_alloc_context3(c);
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = s->iformat ? RELATIVE_TS_BASE : 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  avpriv_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  s->streams[s->nb_streams++] = st;
  return st;
}"
zooko-libzstr-80ce66c/zstr.c	(You should use cs_as_cz() instead of cs_as_z() if the argument is a string literal.)	2	"cs_as_cz(const char *const cs) {
  assert(cs != NULL);
  return (czstr){strlen(cs), (const zbyte *)cs};
}"
dm-vdo-kvdo-8df6805/vdo/base/heap.c	Initialize an binary heap by wrapping it around an array of elements. The heap will not own the array it wraps. Use buildHeap() subsequently to arrange any elements contained in the array into a valid heap.	2	"void initializeHeap(Heap *heap, HeapComparator *comparator, void *array,
                    size_t capacity, size_t elementSize) {
  *heap = (Heap){
      .comparator = comparator,
      .capacity = capacity,
      .elementSize = elementSize,
  };
  if (array != NULL) {

    heap->array = ((byte *)array - elementSize);
  }
}"
JayDT-XUI-69a9c43/dep/G3D/prompt.cpp	"Prints a prompt to stdout and waits for user input. The return value is the number of the user's choice (the first is 0, if there are no choices, returns 0)."	2	"int prompt(const char *windowTitle, const char *prompt, const char **choice,
           int numChoices, bool useGui) {
#if 0
#ifdef G3D_WIN32
        if (useGui) {
             
            return guiPrompt(windowTitle, prompt, choice, numChoices);
        }
#endif

#ifdef G3D_OSX
                if (useGui){
                         
                        return guiPrompt(windowTitle, prompt, choice, numChoices);
                }
#endif
#endif
  return textPrompt(windowTitle, prompt, choice, numChoices);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/manifest-manager/source/arm_uc_mmGetLatestTimestamp.c	Processes through the getLatestManifestTimestamp state machine in response to received events	1	"arm_uc_error_t getLatestManifestTimestampFSM(uint32_t event) {
  return (arm_uc_error_t){ERR_NONE};
}"
RT-Thread-packages-nimble-fbccccd/apps/bleprph/src/bleprph.c	Enables advertising with the following parameters: o General discoverable mode. o Undirected connectable mode.	2	"bleprph_advertise(void) {
  uint8_t own_addr_type;
  struct ble_gap_adv_params adv_params;
  struct ble_hs_adv_fields fields;
  const char *name;
  int rc;

  rc = ble_hs_id_infer_auto(0, &own_addr_type);
  if (rc != 0) {
    MODLOG_DFLT(ERROR, ""error determining address type; rc=%d\n"", rc);
    return;
  }

  memset(&fields, 0, sizeof fields);

  fields.flags = BLE_HS_ADV_F_DISC_GEN | BLE_HS_ADV_F_BREDR_UNSUP;

  fields.tx_pwr_lvl_is_present = 1;
  fields.tx_pwr_lvl = BLE_HS_ADV_TX_PWR_LVL_AUTO;

  name = ble_svc_gap_device_name();
  fields.name = (uint8_t *)name;
  fields.name_len = strlen(name);
  fields.name_is_complete = 1;

  fields.uuids16 = (ble_uuid16_t[]){BLE_UUID16_INIT(GATT_SVR_SVC_ALERT_UUID)};
  fields.num_uuids16 = 1;
  fields.uuids16_is_complete = 1;

  rc = ble_gap_adv_set_fields(&fields);
  if (rc != 0) {
    MODLOG_DFLT(ERROR, ""error setting advertisement data; rc=%d\n"", rc);
    return;
  }

  memset(&adv_params, 0, sizeof adv_params);
  adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
  adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
  rc = ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params,
                         bleprph_gap_event, NULL);
  if (rc != 0) {
    MODLOG_DFLT(ERROR, ""error enabling advertisement; rc=%d\n"", rc);
    return;
  }
}"
dm-vdo-kvdo-8df6805/vdo/base/packer.c	"Implements WaiterCallback. Updates the DataVIO waiter to refer to its slot in the compressed block, gives the DataVIO a share of the PBN lock on that block, and reserves a reference count increment on the lock."	2	"static void shareCompressedBlock(Waiter *waiter, void *context) {
  DataVIO *dataVIO = waiterAsDataVIO(waiter);
  OutputBin *bin = context;

  dataVIO->newMapped = (ZonedPBN){
      .pbn = bin->writer->allocation,
      .zone = bin->writer->zone,
      .state = getStateForSlot(dataVIO->compression.slot),
  };
  dataVIOAsVIO(dataVIO)->physical = dataVIO->newMapped.pbn;

  shareCompressedWriteLock(dataVIO, bin->writer->allocationLock);

  int result = enqueueWaiter(&bin->outgoing, waiter);

  ASSERT_LOG_ONLY(result == VDO_SUCCESS, ""impossible enqueueWaiter error"");
}"
yingted-miredo-2ea60a3/libteredo/discovery.c	Creates and starts threads for the Teredo local client discovery procedure. A list of interfaces suitable for the exchange of multicast local discovery bubbles will be assembled for later use by SendDiscoveryBubble().	2	"teredo_discovery_start(const teredo_discovery_params *params, int fd,
                       const struct in6_addr *src, teredo_iothread_proc proc,
                       void *opaque) {
  struct ifaddrs *ifaddrs, *ifa;
  int r, ifno;

  teredo_discovery *d = malloc(sizeof(teredo_discovery));
  if (d == NULL) {
    return NULL;
  }

  d->refcnt = 1;

  r = getifaddrs(&ifaddrs);
  if (r < 0) {
    debug(""Could not enumerate interfaces for local discovery"");
    free(d);
    return NULL;
  }

  d->ifaces = NULL;
  ifno = 0;

  for (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {
    struct teredo_discovery_interface *list = d->ifaces;
    struct sockaddr_in *sa = (struct sockaddr_in *)ifa->ifa_addr;
    struct sockaddr_in *ma = (struct sockaddr_in *)ifa->ifa_netmask;

    if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != AF_INET)
      continue;
    if (!(ifa->ifa_flags & IFF_MULTICAST))
      continue;

    if (!params->forced && is_ipv4_global_unicast(sa->sin_addr.s_addr))
      continue;
    if (params->ifname_re &&
        regexec(params->ifname_re, ifa->ifa_name, 0, NULL, 0) != 0)
      continue;

    list = realloc(list, (ifno + 2) * sizeof(*d->ifaces));
    if (list == NULL) {
      debug(""Out of memory."");
      break;
    }

    d->ifaces = list;
    d->ifaces[ifno].addr = sa->sin_addr.s_addr;
    d->ifaces[ifno].mask = ma->sin_addr.s_addr;
    ifno++;
  }

  freeifaddrs(ifaddrs);

  if (d->ifaces == NULL) {
    debug(""No suitable interfaces found for local discovery"");
    free(d);
    return NULL;
  }
  d->ifaces[ifno].addr = 0;

  int sk = teredo_socket(0, htons(IPPORT_TEREDO));
  if (sk < 0) {
    debug(""Could not create the local discovery socket"");
    free(d->ifaces);
    free(d);
    return NULL;
  }

  for (ifno = 0; d->ifaces[ifno].addr; ifno++)
    teredo_discovery_joinmcast(sk, d->ifaces[ifno].addr);

  d->recv = teredo_iothread_start(proc, opaque, sk);

  memcpy(&d->src, src, sizeof d->src);
  setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, &(int){0}, sizeof(int));

  d->send = teredo_iothread_start(teredo_sendmcast_thread, d, fd);

  return d;
}"
google-graphd-e994e88/libgdp/gdp-parse.c	"Parse the compact form of a type constraint expression, in which the `type' identifier and the equal operator (`=') are omitted."	2	"static int parse_con_type(gdp_context *ctx, gdp_token const *tok1) {
  gdp_ast_ops const *ast = &ctx->ctx_out->out_ops;
  gdp_strset_t *value;
  gdp_token dummy;
  bool allow_multi;
  int err;

  cl_assert(ctx->ctx_parser->cl, (tok1->tkn_kind == TOK_STR));

  allow_multi = is_read_request(ctx->ctx_cmd);

  if ((err = parse_stringset(ctx, 0, &value)))
    return err;

  char const *image = ""type"";
  dummy = (gdp_token){
      .tkn_kind = TOK_ATOM,
      .tkn_start = &image[0],
      .tkn_end = &image[4],
      .tkn_row = tok1->tkn_row,
      .tkn_col = tok1->tkn_col,
  };

  if ((err = ast->conlist_add_string(ctx->ctx_out, ctx->ctx_conlist, &dummy,
                                     GRAPHD_OP_EQ, value, allow_multi)))
    goto fail_multi;

  return 0;

fail_multi:
  return notify_error(ctx, err, tok1,
                      ""duplicate 'type' constraint declaration"");
}"
cmassiot-vlc-broadcast-de11815/modules/services_discovery/udev.c	Removes a udev device (if present).	2	"static void RemoveDevice(services_discovery_t *sd, struct udev_device *dev) {
  services_discovery_sys_t *p_sys = sd->p_sys;

  dev_t num = udev_device_get_devnum(dev);
  struct device **dp = tfind(&(dev_t){num}, &p_sys->root, cmpdev);
  if (dp == NULL)
    return;

  struct device *d = *dp;
  tdelete(d, &p_sys->root, cmpdev);
  DestroyDevice(d);
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/utils.c	Check that the provided sample aspect ratio is valid and set it on the codec context.	2	"int ff_set_sar(AVCodecContext *avctx, AVRational sar) {
  int ret = av_image_check_sar(avctx->width, avctx->height, sar);

  if (ret < 0) {
    av_log(avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %d/%d\n"", sar.num,
           sar.den);
    avctx->sample_aspect_ratio = (AVRational){0, 1};
    return ret;
  } else {
    avctx->sample_aspect_ratio = sar;
  }
  return 0;
}"
ArcticaProject-vcxsrv-8e5ce00/mesalib/src/glsl/nir/nir_normalize_cubemap_coords.c	This file implements a NIR lowering pass to perform the normalization of the cubemap coordinates to have the largest magnitude component be -1.0 or 1.0. This is based on the old GLSL IR based pass by Eric.	2	"channel(nir_builder *b, nir_ssa_def *def, int c) {
  return nir_swizzle(b, def, (unsigned[4]){c, c, c, c}, 1, false);
}"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_numbers.c	"Converts a number to a temporary, thread safe, C string object"	4	"fio_str_info_s fio_ltocstr(long i) {
  return (fio_str_info_s){.data = num_buffer,
                          .len = fio_ltoa(num_buffer, i, 10)};
}"
AprilRobotics-apriltags-7955e00/apriltag_pose.c	Given a local minima of the pose error tries to find the other minima.	2	"matd_t *fix_pose_ambiguities(matd_t **v, matd_t **p, matd_t *t, matd_t *R,
                             int n_points) {
  matd_t *I3 = matd_identity(3);

  matd_t *R_t_3 = matd_vec_normalize(t);

  matd_t *e_x = matd_create(3, 1);
  MATD_EL(e_x, 0, 0) = 1;
  matd_t *R_t_1_tmp = matd_op(""M-(M'*M)*M"", e_x, e_x, R_t_3, R_t_3);
  matd_t *R_t_1 = matd_vec_normalize(R_t_1_tmp);
  matd_destroy(e_x);
  matd_destroy(R_t_1_tmp);

  matd_t *R_t_2 = matd_crossproduct(R_t_3, R_t_1);

  matd_t *R_t =
      matd_create_data(3, 3,
                       (double[]){MATD_EL(R_t_1, 0, 0), MATD_EL(R_t_1, 0, 1),
                                  MATD_EL(R_t_1, 0, 2), MATD_EL(R_t_2, 0, 0),
                                  MATD_EL(R_t_2, 0, 1), MATD_EL(R_t_2, 0, 2),
                                  MATD_EL(R_t_3, 0, 0), MATD_EL(R_t_3, 0, 1),
                                  MATD_EL(R_t_3, 0, 2)});
  matd_destroy(R_t_1);
  matd_destroy(R_t_2);
  matd_destroy(R_t_3);

  matd_t *R_1_prime = matd_multiply(R_t, R);
  double r31 = MATD_EL(R_1_prime, 2, 0);
  double r32 = MATD_EL(R_1_prime, 2, 1);
  double hypotenuse = sqrt(r31 * r31 + r32 * r32);
  if (hypotenuse < 1e-100) {
    r31 = 1;
    r32 = 0;
    hypotenuse = 1;
  }
  matd_t *R_z = matd_create_data(3, 3,
                                 (double[]){r31 / hypotenuse, -r32 / hypotenuse,
                                            0, r32 / hypotenuse,
                                            r31 / hypotenuse, 0, 0, 0, 1});

  matd_t *R_trans = matd_multiply(R_1_prime, R_z);
  double sin_gamma = -MATD_EL(R_trans, 0, 1);
  double cos_gamma = MATD_EL(R_trans, 1, 1);
  matd_t *R_gamma = matd_create_data(
      3, 3,
      (double[]){cos_gamma, -sin_gamma, 0, sin_gamma, cos_gamma, 0, 0, 0, 1});

  double sin_beta = -MATD_EL(R_trans, 2, 0);
  double cos_beta = MATD_EL(R_trans, 2, 2);
  double t_initial = atan2(sin_beta, cos_beta);
  matd_destroy(R_trans);

  matd_t *v_trans[n_points];
  matd_t *p_trans[n_points];
  matd_t *F_trans[n_points];
  matd_t *avg_F_trans = matd_create(3, 3);
  for (int i = 0; i < n_points; i++) {
    p_trans[i] = matd_op(""M'*M"", R_z, p[i]);
    v_trans[i] = matd_op(""M*M"", R_t, v[i]);
    F_trans[i] = calculate_F(v_trans[i]);
    matd_add_inplace(avg_F_trans, F_trans[i]);
  }
  matd_scale_inplace(avg_F_trans, 1.0 / n_points);

  matd_t *G = matd_op(""(M-M)^-1"", I3, avg_F_trans);
  matd_scale_inplace(G, 1.0 / n_points);

  matd_t *M1 = matd_create_data(3, 3, (double[]){0, 0, 2, 0, 0, 0, -2, 0, 0});
  matd_t *M2 = matd_create_data(3, 3, (double[]){-1, 0, 0, 0, 1, 0, 0, 0, -1});

  matd_t *b0 = matd_create(3, 1);
  matd_t *b1 = matd_create(3, 1);
  matd_t *b2 = matd_create(3, 1);
  for (int i = 0; i < n_points; i++) {
    matd_t *op_tmp1 = matd_op(""(M-M)MM"", F_trans[i], I3, R_gamma, p_trans[i]);
    matd_t *op_tmp2 =
        matd_op(""(M-M)MMM"", F_trans[i], I3, R_gamma, M1, p_trans[i]);
    matd_t *op_tmp3 =
        matd_op(""(M-M)MMM"", F_trans[i], I3, R_gamma, M2, p_trans[i]);

    matd_add_inplace(b0, op_tmp1);
    matd_add_inplace(b1, op_tmp2);
    matd_add_inplace(b2, op_tmp3);

    matd_destroy(op_tmp1);
    matd_destroy(op_tmp2);
    matd_destroy(op_tmp3);
  }
  matd_t *b0_ = matd_multiply(G, b0);
  matd_t *b1_ = matd_multiply(G, b1);
  matd_t *b2_ = matd_multiply(G, b2);

  double a0 = 0;
  double a1 = 0;
  double a2 = 0;
  double a3 = 0;
  double a4 = 0;
  for (int i = 0; i < n_points; i++) {
    matd_t *c0 =
        matd_op(""(M-M)(MM+M)"", I3, F_trans[i], R_gamma, p_trans[i], b0_);
    matd_t *c1 =
        matd_op(""(M-M)(MMM+M)"", I3, F_trans[i], R_gamma, M1, p_trans[i], b1_);
    matd_t *c2 =
        matd_op(""(M-M)(MMM+M)"", I3, F_trans[i], R_gamma, M2, p_trans[i], b2_);

    a0 += matd_to_double(matd_op(""M'M"", c0, c0));
    a1 += matd_to_double(matd_op(""2M'M"", c0, c1));
    a2 += matd_to_double(matd_op(""M'M+2M'M"", c1, c1, c0, c2));
    a3 += matd_to_double(matd_op(""2M'M"", c1, c2));
    a4 += matd_to_double(matd_op(""M'M"", c2, c2));

    matd_destroy(c0);
    matd_destroy(c1);
    matd_destroy(c2);
  }

  matd_destroy(b0);
  matd_destroy(b1);
  matd_destroy(b2);
  matd_destroy(b0_);
  matd_destroy(b1_);
  matd_destroy(b2_);

  for (int i = 0; i < n_points; i++) {
    matd_destroy(p_trans[i]);
    matd_destroy(v_trans[i]);
    matd_destroy(F_trans[i]);
  }
  matd_destroy(avg_F_trans);
  matd_destroy(G);

  double p0 = a1;
  double p1 = 2 * a2 - 4 * a0;
  double p2 = 3 * a3 - 3 * a1;
  double p3 = 4 * a4 - 2 * a2;
  double p4 = -a3;

  double roots[4];
  int n_roots;
  solve_poly_approx((double[]){p0, p1, p2, p3, p4}, 4, roots, &n_roots);

  double minima[4];
  int n_minima = 0;
  for (int i = 0; i < n_roots; i++) {
    double t1 = roots[i];
    double t2 = t1 * t1;
    double t3 = t1 * t2;
    double t4 = t1 * t3;
    double t5 = t1 * t4;

    if (a2 - 2 * a0 + (3 * a3 - 6 * a1) * t1 +
            (6 * a4 - 8 * a2 + 10 * a0) * t2 + (-8 * a3 + 6 * a1) * t3 +
            (-6 * a4 + 3 * a2) * t4 + a3 * t5 >=
        0) {

      double t = 2 * atan(roots[i]);

      if (fabs(t - t_initial) > 0.1) {
        minima[n_minima++] = roots[i];
      }
    }
  }

  matd_t *ret = NULL;
  if (n_minima == 1) {
    double t = minima[0];
    matd_t *R_beta = matd_copy(M2);
    matd_scale_inplace(R_beta, t);
    matd_add_inplace(R_beta, M1);
    matd_scale_inplace(R_beta, t);
    matd_add_inplace(R_beta, I3);
    matd_scale_inplace(R_beta, 1 / (1 + t * t));
    ret = matd_op(""M'MMM'"", R_t, R_gamma, R_beta, R_z);
    matd_destroy(R_beta);
  } else if (n_minima > 1) {

    fprintf(stderr, ""Error, more than one new minima found.\n"");
  }
  matd_destroy(I3);
  matd_destroy(M1);
  matd_destroy(M2);
  matd_destroy(R_t);
  matd_destroy(R_gamma);
  matd_destroy(R_z);
  matd_destroy(R_1_prime);
  return ret;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MouseHostWithParser/MouseHostWithParser.c	"Task to set the configuration of the attached device after it has been enumerated, and to read and process the HID report descriptor and HID reports from the device and display the results onto the board LEDs."	1	"TASK(USB_Mouse_Host) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:

    USB_ControlRequest = (USB_Request_Header_t){
        .bmRequestType =
            (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE),
        .bRequest = REQ_SetConfiguration,
        .wValue = 1,
        .wIndex = 0,
        .wLength = 0,
    };

    Pipe_SelectPipe(PIPE_CONTROLPIPE);

    if ((ErrorCode = USB_Host_SendControlRequest(NULL)) !=
        HOST_SENDCONTROL_Successful) {
      puts_P(PSTR(""Control Error (Set Configuration).\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    puts_P(PSTR(""Processing HID Report.\r\n""));

    UpdateStatus(Status_Busy);

    if ((ErrorCode = GetHIDReportData()) != ParseSuccessful) {
      puts_P(PSTR(""Report Parse Error.\r\n""));
      printf_P(PSTR("" -- Error Code: %d\r\n""), ErrorCode);

      UpdateStatus(Status_EnumerationError);

      while (USB_IsConnected)
        ;
      break;
    }

    UpdateStatus(Status_USBReady);

    puts_P(PSTR(""Mouse Enumerated.\r\n""));

    USB_HostState = HOST_STATE_Ready;
    break;
  case HOST_STATE_Ready:

    Pipe_SelectPipe(MOUSE_DATAPIPE);
    Pipe_Unfreeze();

    if (Pipe_IsINReceived()) {

      if (Pipe_IsReadWriteAllowed()) {

        uint8_t MouseReport[Pipe_BytesInPipe()];

        Pipe_Read_Stream_LE(MouseReport, Pipe_BytesInPipe());

        ProcessMouseReport(MouseReport);
      }

      Pipe_ClearIN();
    }

    Pipe_Freeze();
    break;
  }
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the conjugate of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion qconjugate(const quaternion num) {
  return (quaternion){num.R, num.i * -1.0, num.j * -1.0, num.k * -1.0};
}"
BarrelfishOS-barrelfish-60a7758/lib/devif/backends/net/mlx4/include/linux/ktime.h	ktime_set - Set a ktime_t variable from a seconds/nanoseconds value : seconds to set : nanoseconds to set Return the ktime_t representation of the value	2	"static inline ktime_t ktime_set(const long secs, const unsigned long nsecs) {
#if (BITS_PER_LONG == 64)
  if (unlikely(secs >= KTIME_SEC_MAX))
    return (ktime_t){.tv64 = KTIME_MAX};
#endif
  return (ktime_t){.tv64 = (s64)secs * NSEC_PER_SEC + (s64)nsecs};
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavutil/opt.c	Check if given option is set to its default value.	2	"int av_opt_is_set_to_default(void *obj, const AVOption *o) {
  int64_t i64;
  double d, d2;
  float f;
  AVRational q;
  int ret, w, h;
  char *str;
  void *dst;

  if (!o || !obj)
    return AVERROR(EINVAL);

  dst = ((uint8_t *)obj) + o->offset;

  switch (o->type) {
  case AV_OPT_TYPE_CONST:
    return 1;
  case AV_OPT_TYPE_BOOL:
  case AV_OPT_TYPE_FLAGS:
  case AV_OPT_TYPE_PIXEL_FMT:
  case AV_OPT_TYPE_SAMPLE_FMT:
  case AV_OPT_TYPE_INT:
  case AV_OPT_TYPE_CHANNEL_LAYOUT:
  case AV_OPT_TYPE_DURATION:
  case AV_OPT_TYPE_INT64:
  case AV_OPT_TYPE_UINT64:
    read_number(o, dst, NULL, NULL, &i64);
    return o->default_val.i64 == i64;
  case AV_OPT_TYPE_STRING:
    str = *(char **)dst;
    if (str == o->default_val.str)
      return 1;
    if (!str || !o->default_val.str)
      return 0;
    return !strcmp(str, o->default_val.str);
  case AV_OPT_TYPE_DOUBLE:
    read_number(o, dst, &d, NULL, NULL);
    return o->default_val.dbl == d;
  case AV_OPT_TYPE_FLOAT:
    read_number(o, dst, &d, NULL, NULL);
    f = o->default_val.dbl;
    d2 = f;
    return d2 == d;
  case AV_OPT_TYPE_RATIONAL:
    q = av_d2q(o->default_val.dbl, INT_MAX);
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_BINARY: {
    struct {
      uint8_t *data;
      int size;
    } tmp = {0};
    int opt_size = *(int *)((void **)dst + 1);
    void *opt_ptr = *(void **)dst;
    if (!opt_size && (!o->default_val.str || !strlen(o->default_val.str)))
      return 1;
    if (!opt_size || !o->default_val.str || !strlen(o->default_val.str))
      return 0;
    if (opt_size != strlen(o->default_val.str) / 2)
      return 0;
    ret = set_string_binary(NULL, NULL, o->default_val.str, &tmp.data);
    if (!ret)
      ret = !memcmp(opt_ptr, tmp.data, tmp.size);
    av_free(tmp.data);
    return ret;
  }
  case AV_OPT_TYPE_DICT:

    return !!(*(void **)dst);
  case AV_OPT_TYPE_IMAGE_SIZE:
    if (!o->default_val.str || !strcmp(o->default_val.str, ""none""))
      w = h = 0;
    else if ((ret = av_parse_video_size(&w, &h, o->default_val.str)) < 0)
      return ret;
    return (w == *(int *)dst) && (h == *((int *)dst + 1));
  case AV_OPT_TYPE_VIDEO_RATE:
    q = (AVRational){0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_video_rate(&q, o->default_val.str)) < 0)
        return ret;
    }
    return !av_cmp_q(*(AVRational *)dst, q);
  case AV_OPT_TYPE_COLOR: {
    uint8_t color[4] = {0, 0, 0, 0};
    if (o->default_val.str) {
      if ((ret = av_parse_color(color, o->default_val.str, -1, NULL)) < 0)
        return ret;
    }
    return !memcmp(color, dst, sizeof(color));
  }
  default:
    av_log(obj, AV_LOG_WARNING,
           ""Not supported option type: %d, option name: %s\n"", o->type,
           o->name);
    break;
  }
  return AVERROR_PATCHWELCOME;
}"
CZ-NIC-knot-resolver-3775bbc/lib/generic/map.h	Creates an new empty critbit map. Pass NULL for malloc+free.	2	"static inline map_t map_make(struct knot_mm *pool) {
  return (map_t){.root = NULL, .pool = pool};
}"
OpenGP-htrack-7cfef03/cudax/functors/SkeletonJacobian.h	Last argument accesses THREE rows!	4	"void operator()(const int joint_id, const glm::vec3 &pos, J_row *sub_J) {
  J_row &J0 = *(sub_J + 0);
  J_row &J1 = *(sub_J + 1);
  J_row &J2 = *(sub_J + 2);

  for (int i_column = 0; i_column < CHAIN_MAX_LENGTH; i_column++) {
    printf(""i_column => jointinfo_id: %d %d\n"", chains[joint_id]);

#if 0       
            int jointinfo_id = chains[joint_id].data[i_column];
            printf(""i_column => jointinfo_id: %d %d\n"", i_column, jointinfo_id);
            if(jointinfo_id==-1) break;
            const CustomJointInfo& jinfo = jointinfos[jointinfo_id];
            glm::vec3& axis = jointinfos[jointinfo_id].axis;           
            
            glm::vec3 col;
            switch(jinfo.type){
                case 1  : 
                {
                    col = glm::vec3( jointinfos[jointinfo_id].mat * glm::vec4( axis, 1 ) ); 
                    break;
                }
                case 0  : 
                {
                    glm::vec3 t(jointinfos[jointinfo_id].mat[3][0],jointinfos[jointinfo_id].mat[3][1],jointinfos[jointinfo_id].mat[3][2]);
                    glm::vec3 a = glm::vec3(jointinfos[jointinfo_id].mat * glm::vec4( axis, 1 )) - t;
                    col = glm::cross(a, pos - t);                    
                    break;
                }
            }
            J0.data[jinfo.index] = col[0];
            J1.data[jinfo.index] = col[1];
            J2.data[jinfo.index] = col[2];
#endif
  }
}"
vyos-legacy-vyatta-strongswan-92dd80c/src/pki/commands/self.c	Register the command.	2	"static void __attribute__((constructor)) reg() {
  command_register((command_t){
      self,
      's',
      ""self"",
      ""create a self signed certificate"",
      {""[--in file | --keyid hex] [--type rsa|ecdsa]"",
       "" --dn distinguished-name [--san subjectAltName]+"",
       ""[--lifetime days] [--serial hex] [--ca] [--ocsp uri]+"",
       ""[--flag serverAuth|clientAuth|crlSign|ocspSigning]+"",
       ""[--nc-permitted name] [--nc-excluded name]"",
       ""[--cert-policy oid [--cps-uri uri] [--user-notice text] ]+"",
       ""[--policy-map issuer-oid:subject-oid]"",
       ""[--policy-explicit len] [--policy-inhibit len] [--policy-any len]"",
       ""[--digest md5|sha1|sha224|sha256|sha384|sha512] [--outform der|pem]""},
      {
          {""help"", 'h', 0, ""show usage information""},
          {""in"", 'i', 1, ""private key input file, default: stdin""},
          {""keyid"", 'x', 1, ""keyid on smartcard of private key""},
          {""type"", 't', 1, ""type of input key, default: rsa""},
          {""dn"", 'd', 1, ""subject and issuer distinguished name""},
          {""san"", 'a', 1, ""subjectAltName to include in certificate""},
          {""lifetime"", 'l', 1, ""days the certificate is valid, default: 1095""},
          {""serial"", 's', 1, ""serial number in hex, default: random""},
          {""ca"", 'b', 0, ""include CA basicConstraint, default: no""},
          {""pathlen"", 'p', 1, ""set path length constraint""},
          {""nc-permitted"", 'n', 1, ""add permitted NameConstraint""},
          {""nc-excluded"", 'N', 1, ""add excluded NameConstraint""},
          {""cert-policy"", 'P', 1, ""certificatePolicy OID to include""},
          {""cps-uri"", 'C', 1,
           ""Certification Practice statement URI for certificatePolicy""},
          {""user-notice"", 'U', 1, ""user notice for certificatePolicy""},
          {""policy-mapping"", 'M', 1,
           ""policyMapping from issuer to subject OID""},
          {""policy-explicit"", 'E', 1, ""requireExplicitPolicy constraint""},
          {""policy-inhibit"", 'H', 1, ""inhibitPolicyMapping constraint""},
          {""policy-any"", 'A', 1, ""inhibitAnyPolicy constraint""},
          {""flag"", 'e', 1, ""include extendedKeyUsage flag""},
          {""ocsp"", 'o', 1, ""OCSP AuthorityInfoAccess URI to include""},
          {""digest"", 'g', 1, ""digest for signature creation, default: sha1""},
          {""outform"", 'f', 1, ""encoding of generated cert, default: der""},
      }});
}"
darktable-org-darktable-32fab21/src/iop/cacorrect.c	"this is the chance to update default parameters, after the full raw is loaded."	2	"void reload_defaults(dt_iop_module_t *module) {

  dt_iop_cacorrect_params_t tmp = (dt_iop_cacorrect_params_t){.keep = 50};

  if (!module->dev)
    goto end;

  dt_image_t *img = &module->dev->image_storage;

  if (dt_image_is_raw(img) && (img->buf_dsc.filters != 9u) &&
      !dt_image_is_monochrome(img))
    module->hide_enable_button = 0;
  else
    module->hide_enable_button = 1;
  module->default_enabled = 0;

end:
  memcpy(module->params, &tmp, sizeof(dt_iop_cacorrect_params_t));
  memcpy(module->default_params, &tmp, sizeof(dt_iop_cacorrect_params_t));
}"
fohr-castle-36a70e1/kernel/castle_bloom.c	Read an existing bloom filter from disk.	2	"void castle_bloom_unmarshall(castle_bloom_t *bf,
                             struct castle_clist_entry *ctm) {
  bf->num_hashes = ctm->bloom_num_hashes;
  bf->block_size_pages = ctm->bloom_block_size_pages;
  bf->num_chunks = ctm->bloom_num_chunks;
  bf->chunks_offset = ctm->bloom_chunks_offset;
  bf->btree = castle_btree_type_get(ctm->btree_type);
  bf->ext_id = ctm->bloom_ext_id;
  atomic_set(&bf->num_btree_nodes, ctm->bloom_num_btree_nodes);

  castle_printk(LOG_DEBUG,
                ""%s: bf=%p ext_id=%llu num_chunks=%u ""
                ""chunks_offset=%llu num_btree_nodes=%u\n"",
                __FUNCTION__, bf, bf->ext_id, bf->num_chunks, bf->chunks_offset,
                atomic_read(&bf->num_btree_nodes));

  castle_extent_mark_live(bf->ext_id, ctm->da_id);

  bf->private = NULL;

  if (bf->num_chunks && bf->num_chunks <= BLOOM_MAX_PREFETCH_CHUNKS) {

    int chunks =
        CHUNK(bf->chunks_offset + bf->num_chunks * BLOOM_CHUNK_SIZE) + 1;
    castle_cache_advise((c_ext_pos_t){bf->ext_id, 0}, C2_ADV_PREFETCH, USER,
                        chunks);
  }

#ifdef CASTLE_BLOOM_FP_STATS
  atomic64_set(&bf->queries, 0);
  atomic64_set(&bf->false_positives, 0);
#endif
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the device sense data, indicating the current device state and error codes for the previously issued command."	0	"uint8_t MS_Host_RequestSense(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                             const uint8_t LUNIndex,
                             SCSI_Request_Sense_Response_t *const SenseData) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Request_Sense_Response_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 6,
      .SCSICommandData = {SCSI_CMD_REQUEST_SENSE, 0x00, 0x00, 0x00,
                          sizeof(SCSI_Request_Sense_Response_t), 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       SenseData)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
darktable-org-darktable-32fab21/src/iop/dither.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""BEGIN"", NULL, NULL,
                        NULL);

  dt_iop_dither_params_t tmp = (dt_iop_dither_params_t){
      DITHER_FSAUTO, 0, {0.0f, {0.0f, 0.0f, 1.0f, 1.0f}, -200.0f}};

  dt_gui_presets_add_generic(_(""dither""), self->op, self->version(), &tmp,
                             sizeof(dt_iop_dither_params_t), 1);

  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), ""COMMIT"", NULL, NULL,
                        NULL);
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set_epi64(__m64 __q1, __m64 __q0) {
  return (__m128i){(long long)__q0, (long long)__q1};
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration = 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt);

    if ((s->iformat->flags & AVFMT_GENERIC_INDEX) &&
        out_pkt.flags & AV_PKT_FLAG_KEY) {
      ff_reduce_index(s, st->index);
      av_add_index_entry(st, st->parser->frame_offset, out_pkt.dts, 0, 0,
                         AVINDEX_KEYFRAME);
    }

    if ((ret = add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
                             &s->internal->parse_queue_end, 1))) {
      av_packet_unref(&out_pkt);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"
makestuff-neroJtag-b7f0313/LUFA-110528/LUFA/Drivers/USB/Class/Device/CDC.c	"Sends a Serial Control Line State Change notification to the host. This should be called when the virtual serial control lines (DCD, DSR, etc.) have changed states, or to give BREAK notifications to the host. Line states persist until they are cleared via a second notification. This should be called each time the CDC class driver's ControlLineStates.DeviceToHost value is updated to push the new states to the USB host."	2	"void CDC_Device_SendControlLineStateChange(
    USB_ClassInfo_CDC_Device_t *const CDCInterfaceInfo) {
  if ((USB_DeviceState != DEVICE_STATE_Configured) ||
      !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
    return;

  Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.NotificationEndpointNumber);

  USB_Request_Header_t Notification = (USB_Request_Header_t){
      .bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
      .bRequest = CDC_NOTIF_SerialState,
      .wValue = 0,
      .wIndex = 0,
      .wLength = sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost),
  };

  Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
  Endpoint_Write_Stream_LE(
      &CDCInterfaceInfo->State.ControlLineStates.DeviceToHost,
      sizeof(CDCInterfaceInfo->State.ControlLineStates.DeviceToHost), NULL);
  Endpoint_ClearIN();
}"
3drobotics-ardupilot-solo-rebase-e5f2337/Tools/ArduPPM/ATMega32U2/LUFA/Drivers/USB/Class/Host/StillImage.c	Closes an already opened PIMA session with the attached device. This should be used after all session-orientated PIMA commands have been issued to the device.	2	"uint8_t
SImage_Host_CloseSession(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  SI_PIMA_Container_t PIMABlock = (SI_PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(1),
      .Type = CType_CommandBlock,
      .Code = 0x1003,
      .Params = {1},
  };

  if ((ErrorCode = SImage_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  if ((ErrorCode = SImage_Host_ReceiveBlockHeader(
           SIInterfaceInfo, &PIMABlock)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  SIInterfaceInfo->State.IsSessionOpen = false;

  if ((PIMABlock.Type != CType_ResponseBlock) || (PIMABlock.Code != 0x2001))
    return SI_ERROR_LOGICAL_CMD_FAILED;

  return PIPE_RWSTREAM_NoError;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/string.c	Produces a string containing the values of both strings concatenated. Complexity: Amortized O(1)	2	"ava_string ava_strcat(ava_string a, ava_string b) {
  size_t alen, blen;
  ava_string ret;

  if (ava_string_is_ascii9(a) && ava_string_is_ascii9(b) &&
      ava_ascii9_length(a.ascii9) + ava_ascii9_length(b.ascii9) <= 9)
    return (ava_string){.ascii9 = ava_ascii9_concat(a.ascii9, b.ascii9)};

  alen = ava_strlen(a);
  blen = ava_strlen(b);

  if (0 == alen)
    return b;
  if (0 == blen)
    return a;

  ret.ascii9 = 0;

  if (ava_string_is_ascii9(a) && ava_string_is_ascii9(b)) {
    ava_twine *restrict twine = ava_twine_alloc(alen + blen);
    char *restrict dst = (char *)&twine->tail;
    ava_str_tmpbuff second;

    ava_ascii9_decode((ava_ulong *)dst, a.ascii9);
    ava_ascii9_decode(second, b.ascii9);
    memcpy(dst + alen, second, blen);
    ret.twine = twine;
  } else if (ava_string_is_ascii9(a)) {
    ava_twine twine;

    twine.body = ava_twine_pack_body(ava_tt_tacnoc, b.twine);
    twine.length = alen + blen;
    twine.tail.overhead = sizeof(ava_twine) + ava_twine_get_overhead(b.twine);
    twine.tail.other.string = a;
    ret.twine = ava_twine_maybe_force(&twine);
  } else {
    ava_twine twine;

    twine.body = ava_twine_pack_body(ava_tt_concat, a.twine);
    twine.length = alen + blen;
    twine.tail.overhead = sizeof(ava_twine) + ava_twine_get_overhead(a.twine);
    if (!ava_string_is_ascii9(b))
      twine.tail.overhead += ava_twine_get_overhead(b.twine);
    twine.tail.other.string = b;
    ret.twine = ava_twine_maybe_force(&twine);
  }

  return ret;
}"
freeciv-freeciv-e4ead30/client/gui-sdl2/canvas.c	Draw the text onto the canvas in the given color and font. The canvas position does not account for the ascent of the text; this function must take care of this manually. The text will not be NULL but may be empty.	2	"void canvas_put_text(struct canvas *pcanvas, int canvas_x, int canvas_y,
                     enum client_font font, struct color *pcolor,
                     const char *text) {
  SDL_Surface *ptmp;
  utf8_str *ptext = create_utf8_str(NULL, 0, *client_font_sizes[font]);

  copy_chars_to_utf8_str(ptext, text);

  ptext->fgcol = *pcolor->color;
  ptext->bgcol = (SDL_Color){0, 0, 0, 0};

  ptmp = create_text_surf_from_utf8(ptext);

  blit_entire_src(ptmp, pcanvas->surf, canvas_x, canvas_y);

  FREEUTF8STR(ptext);
  FREESURFACE(ptmp);
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

#if FF_API_LAVF_AVCTX
  FF_DISABLE_DEPRECATION_WARNINGS
  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  FF_ENABLE_DEPRECATION_WARNINGS
#endif

  st->internal = av_mallocz(sizeof(*st->internal));
  if (!st->internal)
    goto fail;

  st->codecpar = avcodec_parameters_alloc();
  if (!st->codecpar)
    goto fail;

  st->internal->avctx = avcodec_alloc_context3(NULL);
  if (!st->internal->avctx)
    goto fail;

  if (s->iformat) {
#if FF_API_LAVF_AVCTX
    FF_DISABLE_DEPRECATION_WARNINGS

    st->codec->bit_rate = 0;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif

    avpriv_set_pts_info(st, 33, 1, 90000);

    st->cur_dts = RELATIVE_TS_BASE;
  } else {
    st->cur_dts = AV_NOPTS_VALUE;
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  st->internal->need_context_update = 1;

  s->streams[s->nb_streams++] = st;
  return st;
fail:
  free_stream(&st);
  return NULL;
}"
Metaswitch-clearwater-monit-043c17f/src/validate.c	Validate timestamps of a service s	2	"static State_Type _checkTimestamp(Service_T s, time_t timestamp) {
  ASSERT(s);
  if (timestamp > 0) {
    State_Type rv = State_Succeeded;
    if (s->timestamplist) {
      time_t now = Time_now();
      for (Timestamp_T t = s->timestamplist; t; t = t->next) {
        if (t->test_changes) {
          if (!t->initialized) {
            t->initialized = true;
            t->timestamp = timestamp;
          } else {
            if (t->timestamp != timestamp) {
              rv = State_Changed;
              Event_post(s, Event_Timestamp, State_Changed, t->action,
                         ""timestamp for %s changed from %s to %s"", s->path,
                         t->timestamp ? Time_string(t->timestamp, (char[26]){})
                                      : ""N/A"",
                         Time_string(timestamp, (char[26]){}));
              t->timestamp = timestamp;
            } else {
              Event_post(s, Event_Timestamp, State_ChangedNot, t->action,
                         ""timestamp was not changed for %s"", s->path);
            }
          }
        } else {

          if (Util_evalQExpression(t->operator, now - timestamp, t->time)) {
            rv = State_Failed;
            Event_post(s, Event_Timestamp, State_Failed, t->action,
                       ""timestamp for %s failed -- current timestamp is %s"",
                       s->path, Time_string(timestamp, (char[26]){}));
          } else {
            Event_post(
                s, Event_Timestamp, State_Succeeded, t->action,
                ""timestamp test succeeded for %s [current timestamp is %s]"",
                s->path, Time_string(timestamp, (char[26]){}));
          }
        }
      }
    }
    return rv;
  } else {
    return State_Init;
  }
}"
aybe-dosbox-svn-daum-bd7891d/src/libs/gui_tk/gui_tk.h	Paint button.	2	"Font(){};

virtual void drawChar(Drawable *d, const Char c) const = 0;

virtual void drawString(Drawable *d, const String &s, Size start,
                        Size len) const {
  if (len > s.size() - start)
    len = (Size)(s.size() - start);
  len += start;
  while (start < len)
    drawChar(d, s[start++]);
}

public:
static const Font *getFont(const char *name) {
  std::map<const char *, Font *, ltstr>::iterator i = registry.find(name);
  if (i == registry.end())
    return (strcmp(name, ""default"") ? getFont(""default"") : NULL);
  return (*i).second;
}

static void registry_freeall() {
  std::map<const char *, Font *, ltstr>::iterator it;

  while ((it = registry.begin()) != registry.end()) {
    delete it->second;
    it->second = NULL;
    registry.erase(it);
  }
}

static void addFont(const char *name, Font *font) {
  std::map<const char *, Font *, ltstr>::iterator i = registry.find(name);
  if (i != registry.end())
    delete (*i).second;
  registry[name] = font;
}"
krmarien-Proxmark-b16dac4/client/cmdhf15.c	parses common HF 15 CMD parameters and prepares some data structures Parameters: **cmd command line	2	"int prepareHF15Cmd(char **cmd, UsbCommand *c, uint8_t iso15cmd[],
                   int iso15cmdlen) {
  int temp;
  uint8_t *req = c->d.asBytes, uid[8];
  uint32_t reqlen = 0;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-2"") == *cmd) {
    c->arg[1] = 0;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  if (strstr(*cmd, ""-o"") == *cmd) {
    req[reqlen] = ISO15_REQ_OPTION;
    (*cmd) += 2;
  }

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  switch (**cmd) {
  case 0:
    PrintAndLog(""missing addr"");
    return 0;
    break;
  case 's':
  case 'S':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_SELECT;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case 'u':
  case 'U':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    break;
  case '*':

    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;
    if (!getUID(uid)) {
      PrintAndLog(""No Tag found"");
      return 0;
    }
    memcpy(req + reqlen, uid, 8);
    PrintAndLog(""Detected UID %s"", sprintUID(NULL, uid));
    reqlen += 8;
    break;
  default:
    req[reqlen++] |= ISO15_REQ_SUBCARRIER_SINGLE | ISO15_REQ_DATARATE_HIGH |
                     ISO15_REQ_NONINVENTORY | ISO15_REQ_ADDRESS;
    memcpy(&req[reqlen], &iso15cmd[0], iso15cmdlen);
    reqlen += iso15cmdlen;

    for (int i = 0; i < 8 && (*cmd)[i * 2] && (*cmd)[i * 2 + 1]; i++) {
      sscanf((char[]){(*cmd)[i * 2], (*cmd)[i * 2 + 1], 0}, ""%X"", &temp);
      uid[7 - i] = temp & 0xff;
    }

    PrintAndLog(""Using UID %s"", sprintUID(NULL, uid));
    memcpy(&req[reqlen], &uid[0], 8);
    reqlen += 8;
  }

  while (**cmd != ' ' && **cmd != '\t')
    (*cmd)++;

  while (**cmd == ' ' || **cmd == '\t')
    (*cmd)++;

  c->arg[0] = reqlen;
  return 1;
}"
EmbER-Dev-EmbER-3c7eb3b/package/amlogic/libamplayer/src-m1/amffmpeg/libavformat/utils.c	"Add a new stream to a media file. Can only be called in the read_header() function. If the flag AVFMTCTX_NOHEADER is in the format context, then new streams can be added in read_packet too."	2	"AVStream *av_new_stream(AVFormatContext *s, int id) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= INT_MAX / sizeof(*streams))
    return NULL;
  streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }

  st->codec = avcodec_alloc_context();
  if (s->iformat) {

    st->codec->bit_rate = 0;
  }
  st->index = s->nb_streams;
  st->id = id;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;

  st->cur_dts = 0;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  av_set_pts_info(st, 33, 1, 90000);
  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;
  st->reference_dts = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  s->streams[s->nb_streams++] = st;
  return st;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/geometry/geometry_T.c	Compute the face normal vectors at the nodes corresponding to the given face metrics.	2	"(const int ind_lf, const struct const_Multiarray_R *normals_ref,
 const struct const_Multiarray_T *metrics_f, struct Multiarray_T *normals_f) {
  const int order_n = 2, order_m = 3;

  const ptrdiff_t *exts_m = metrics_f->extents;

  assert(normals_ref->order == order_n);
  assert(metrics_f->order == order_m);
  assert(exts_m[1] == exts_m[2]);
  assert(normals_f->order == order_n);
  assert(metrics_f->layout == 'C');

  const ptrdiff_t n_vals = exts_m[0], d = exts_m[1];

  resize_Multiarray_T(normals_f, order_n, (ptrdiff_t[]){n_vals, d});
  set_to_value_Multiarray_T(normals_f, 0.0);

  Type *normals_d = normals_f->data;
  const Real *normal_ref = get_row_const_Multiarray_R(ind_lf, normals_ref);
  const Type *metrics_d = metrics_f->data;
  for (ptrdiff_t dim_0 = 0; dim_0 < d; ++dim_0) {
    for (ptrdiff_t n = 0; n < n_vals; ++n) {
      for (ptrdiff_t dim_1 = 0; dim_1 < d; ++dim_1)
        *normals_d +=
            normal_ref[dim_1] * metrics_d[n_vals * (dim_0 + d * dim_1) + n];
      ++normals_d;
    }
  }
  normals_f->layout = 'C';

  transpose_Multiarray_T(normals_f, true);
}"
tsani-tetrefis-02d47ef/screen.c	Prepares the linear frame buffer by finding the GOP and setting the video mode. Unconditionally sets *_status. The return value is undefined if EFI_ERROR(*_status) is true.	2	"load_lfb(EFI_STATUS *status) {
  *status = EFI_SUCCESS;
  return (LFB){.pixels = mock_vram.data,
               .buffer = SCREEN_BUFFER.data,
               .width = SCREEN_WIDTH,
               .height = SCREEN_HEIGHT,
               .pixels_per_scanline = 1};
}"
epik-wAMP-b1b1c58/plugin/include/libavformat/utils.c	Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.	2	"int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options) {
  int i, count, ret, read_size, j;
  AVStream *st;
  AVPacket pkt1, *pkt;
  int64_t old_offset = avio_tell(ic->pb);
  int orig_nb_streams = ic->nb_streams;

  for (i = 0; i < ic->nb_streams; i++) {
    AVCodec *codec;
    st = ic->streams[i];
    if (st->codec->codec_id == CODEC_ID_AAC && st->codec->extradata_size) {

      st->codec->sample_rate = 0;
      st->codec->frame_size = 0;
      st->codec->channels = 0;
    }

    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO ||
        st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {

      if (!st->codec->time_base.num)
        st->codec->time_base = st->time_base;
    }

    if (!st->parser && !(ic->flags & AVFMT_FLAG_NOPARSE)) {
      st->parser = av_parser_init(st->codec->codec_id);
      if (st->need_parsing == AVSTREAM_PARSE_HEADERS && st->parser) {
        st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
      }
    }
    assert(!st->codec->codec);
    codec = avcodec_find_decoder(st->codec->codec_id);

    if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE && codec &&
        !st->codec->codec)
      avcodec_open2(st->codec, codec, options ? &options[i] : NULL);

    if (!has_codec_parameters(st->codec)) {
      if (codec && !st->codec->codec)
        avcodec_open2(st->codec, codec, options ? &options[i] : NULL);
    }
  }

  for (i = 0; i < ic->nb_streams; i++) {
    ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
  }

  count = 0;
  read_size = 0;
  for (;;) {
    if (url_interrupt_cb()) {
      ret = AVERROR_EXIT;
      av_log(ic, AV_LOG_DEBUG, ""interrupted\n"");
      break;
    }

    for (i = 0; i < ic->nb_streams; i++) {
      int fps_analyze_framecount = 20;

      st = ic->streams[i];
      if (!has_codec_parameters(st->codec))
        break;

      if (av_q2d(st->time_base) > 0.0005)
        fps_analyze_framecount *= 2;
      if (ic->fps_probe_size >= 0)
        fps_analyze_framecount = ic->fps_probe_size;

      if (tb_unreliable(st->codec) &&
          !(st->r_frame_rate.num && st->avg_frame_rate.num) &&
          st->info->duration_count < fps_analyze_framecount &&
          st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        break;
      if (st->parser && st->parser->parser->split && !st->codec->extradata)
        break;
      if (st->first_dts == AV_NOPTS_VALUE)
        break;
    }
    if (i == ic->nb_streams) {

      if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {

        ret = count;
        av_log(ic, AV_LOG_DEBUG, ""All info found\n"");
        break;
      }
    }

    if (read_size >= ic->probesize) {
      ret = count;
      av_log(ic, AV_LOG_DEBUG, ""Probe buffer size limit %d reached\n"",
             ic->probesize);
      break;
    }

    ret = read_frame_internal(ic, &pkt1);
    if (ret == AVERROR(EAGAIN))
      continue;

    if (ret < 0) {

      ret = -1;
      for (i = 0; i < ic->nb_streams; i++) {
        st = ic->streams[i];
        if (!has_codec_parameters(st->codec)) {
          char buf[256];
          avcodec_string(buf, sizeof(buf), st->codec, 0);
          av_log(ic, AV_LOG_WARNING, ""Could not find codec parameters (%s)\n"",
                 buf);
        } else {
          ret = 0;
        }
      }
      break;
    }

    pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
    if ((ret = av_dup_packet(pkt)) < 0)
      goto find_stream_info_err;

    read_size += pkt->size;

    st = ic->streams[pkt->stream_index];
    if (st->codec_info_nb_frames > 1) {
      int64_t t;
      if (st->time_base.den > 0 &&
          (t = av_rescale_q(st->info->codec_info_duration, st->time_base,
                            AV_TIME_BASE_Q)) >= ic->max_analyze_duration) {
        av_log(ic, AV_LOG_WARNING,
               ""max_analyze_duration %d reached at %"" PRId64 ""\n"",
               ic->max_analyze_duration, t);
        break;
      }
      st->info->codec_info_duration += pkt->duration;
    }
    {
      int64_t last = st->info->last_dts;
      int64_t duration = pkt->dts - last;

      if (pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE &&
          duration > 0) {
        double dur = duration * av_q2d(st->time_base);

        if (st->info->duration_count < 2)
          memset(st->info->duration_error, 0, sizeof(st->info->duration_error));
        for (i = 1; i < FF_ARRAY_ELEMS(st->info->duration_error); i++) {
          int framerate = get_std_framerate(i);
          int ticks = lrintf(dur * framerate / (1001 * 12));
          double error = dur - ticks * 1001 * 12 / (double)framerate;
          st->info->duration_error[i] += error * error;
        }
        st->info->duration_count++;

        if (st->info->duration_count > 3)
          st->info->duration_gcd = av_gcd(st->info->duration_gcd, duration);
      }
      if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
        st->info->last_dts = pkt->dts;
    }
    if (st->parser && st->parser->parser->split && !st->codec->extradata) {
      int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
      if (i) {
        st->codec->extradata_size = i;
        st->codec->extradata =
            av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
      }
    }

    try_decode_frame(st, pkt,
                     (options && i < orig_nb_streams) ? &options[i] : NULL);

    st->codec_info_nb_frames++;
    count++;
  }

  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec->codec)
      avcodec_close(st->codec);
  }
  for (i = 0; i < ic->nb_streams; i++) {
    st = ic->streams[i];
    if (st->codec_info_nb_frames > 2 && !st->avg_frame_rate.num &&
        st->info->codec_info_duration)
      av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
                (st->codec_info_nb_frames - 2) * (int64_t)st->time_base.den,
                st->info->codec_info_duration * (int64_t)st->time_base.num,
                60000);
    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
      if (st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag &&
          !st->codec->bits_per_coded_sample) {
        uint32_t tag = avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);
        if (ff_find_pix_fmt(ff_raw_pix_fmt_tags, tag) == st->codec->pix_fmt)
          st->codec->codec_tag = tag;
      }

      if (tb_unreliable(st->codec) && st->info->duration_count > 15 &&
          st->info->duration_gcd >
              FFMAX(1, st->time_base.den / (500LL * st->time_base.num)) &&
          !st->r_frame_rate.num)
        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,
                  st->time_base.den, st->time_base.num * st->info->duration_gcd,
                  INT_MAX);
      if (st->info->duration_count && !st->r_frame_rate.num &&
          tb_unreliable(st->codec)) {
        int num = 0;
        double best_error = 2 * av_q2d(st->time_base);
        best_error =
            best_error * best_error * st->info->duration_count * 1000 * 12 * 30;

        for (j = 1; j < FF_ARRAY_ELEMS(st->info->duration_error); j++) {
          double error = st->info->duration_error[j] * get_std_framerate(j);

          if (error < best_error) {
            best_error = error;
            num = get_std_framerate(j);
          }
        }

        if (num &&
            (!st->r_frame_rate.num ||
             (double)num / (12 * 1001) < 1.01 * av_q2d(st->r_frame_rate)))
          av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num,
                    12 * 1001, INT_MAX);
      }

      if (!st->r_frame_rate.num) {
        if (st->codec->time_base.den * (int64_t)st->time_base.num <=
            st->codec->time_base.num * st->codec->ticks_per_frame *
                (int64_t)st->time_base.den) {
          st->r_frame_rate.num = st->codec->time_base.den;
          st->r_frame_rate.den =
              st->codec->time_base.num * st->codec->ticks_per_frame;
        } else {
          st->r_frame_rate.num = st->time_base.den;
          st->r_frame_rate.den = st->time_base.num;
        }
      }
    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (!st->codec->bits_per_coded_sample)
        st->codec->bits_per_coded_sample =
            av_get_bits_per_sample(st->codec->codec_id);

      switch (st->codec->audio_service_type) {
      case AV_AUDIO_SERVICE_TYPE_EFFECTS:
        st->disposition = AV_DISPOSITION_CLEAN_EFFECTS;
        break;
      case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
        st->disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
        st->disposition = AV_DISPOSITION_HEARING_IMPAIRED;
        break;
      case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
        st->disposition = AV_DISPOSITION_COMMENT;
        break;
      case AV_AUDIO_SERVICE_TYPE_KARAOKE:
        st->disposition = AV_DISPOSITION_KARAOKE;
        break;
      }
    }
  }

  estimate_timings(ic, old_offset);

  compute_chapters_end(ic);

#if 0
     
    for(i=0;i<ic->nb_streams;i++) {
        st = ic->streams[i];
        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
            if(b-frames){
                ppktl = &ic->packet_buffer;
                while(ppkt1){
                    if(ppkt1->stream_index != i)
                        continue;
                    if(ppkt1->pkt->dts < 0)
                        break;
                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)
                        break;
                    ppkt1->pkt->dts -= delta;
                    ppkt1= ppkt1->next;
                }
                if(ppkt1)
                    continue;
                st->cur_dts -= delta;
            }
        }
    }
#endif

find_stream_info_err:
  for (i = 0; i < ic->nb_streams; i++)
    av_freep(&ic->streams[i]->info);
  return ret;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/avxintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00) {
  return (__m256i)(__v16hi){__w00, __w01, __w02, __w03, __w04, __w05,
                            __w06, __w07, __w08, __w09, __w10, __w11,
                            __w12, __w13, __w14, __w15};
}"
psyc-libpsyc-d16deca/src/packet.c	Initialize a list.	2	"psyc_list_init(PsycList *list, PsycElem *elems, size_t num_elems) {
  *list = (PsycList){
      .num_elems = num_elems,
      .elems = elems,
  };
  psyc_list_length_set(list);
}"
Funky-System-Funky-VM-b389879/src/libvm/instructions/instr_mem.c	Load Stack Address. Pushes the address of a value relative to the stackpointer.	2	"INSTR(ld_sref) {
  AJS_STACK(+1);
  USE_STACK();
  *stack = (vm_value_t){.uint_value = state->sp + (GET_OPERAND_SIGNED() - 1) *
                                                      sizeof(vm_value_t),
                        .type = VM_TYPE_REF};
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the vector portion of the quaternion number	2	"LIB_FUNC MATH_FUNC quaternion_long_double
qvectorl(const quaternion_long_double num) {
  const quaternion_long_double conj_num = (quaternion_long_double){
      num.R, num.i * -1.0L, num.j * -1.0L, num.k * -1.0L};
  return (quaternion_long_double){
      (num.R - conj_num.R) * 0.5L, (num.i - conj_num.i) * 0.5L,
      (num.j - conj_num.j) * 0.5L, (num.k - conj_num.k) * 0.5L};
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;
  AVStream **streams;

  if (s->nb_streams >= FFMIN(s->max_streams, INT_MAX / sizeof(*streams))) {
    if (s->max_streams < INT_MAX / sizeof(*streams))
      av_log(s, AV_LOG_ERROR,
             ""Number of streams exceeds max_streams parameter (%d), see the ""
             ""documentation if you wish to increase it\n"",
             s->max_streams);
    return NULL;
  }
  streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));
  if (!streams)
    return NULL;
  s->streams = streams;

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }
  st->info->last_dts = AV_NOPTS_VALUE;

#if FF_API_LAVF_AVCTX
  FF_DISABLE_DEPRECATION_WARNINGS
  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  FF_ENABLE_DEPRECATION_WARNINGS
#endif

  st->internal = av_mallocz(sizeof(*st->internal));
  if (!st->internal)
    goto fail;

  st->codecpar = avcodec_parameters_alloc();
  if (!st->codecpar)
    goto fail;

  st->internal->avctx = avcodec_alloc_context3(NULL);
  if (!st->internal->avctx)
    goto fail;

  if (s->iformat) {
#if FF_API_LAVF_AVCTX
    FF_DISABLE_DEPRECATION_WARNINGS

    st->codec->bit_rate = 0;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif

    avpriv_set_pts_info(st, 33, 1, 90000);

    st->cur_dts = RELATIVE_TS_BASE;
  } else {
    st->cur_dts = AV_NOPTS_VALUE;
  }

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;
  st->pts_wrap_reference = AV_NOPTS_VALUE;
  st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;

  st->last_IP_pts = AV_NOPTS_VALUE;
  st->last_dts_for_order_check = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

#if FF_API_R_FRAME_RATE
  st->info->last_dts = AV_NOPTS_VALUE;
#endif
  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

  st->inject_global_side_data = s->internal->inject_global_side_data;

  st->internal->need_context_update = 1;

  s->streams[s->nb_streams++] = st;
  return st;
fail:
  free_stream(&st);
  return NULL;
}"
alidili-FFmpeg4Android-ee1266c/ffmpeg-4.0/libavcodec/vaapi_h264.c	Decode the given H.264 slice with VA API.	2	"static int vaapi_h264_decode_slice(AVCodecContext *avctx, const uint8_t *buffer,
                                   uint32_t size) {
  const H264Context *h = avctx->priv_data;
  VAAPIDecodePicture *pic = h->cur_pic_ptr->hwaccel_picture_private;
  const H264SliceContext *sl = &h->slice_ctx[0];
  VASliceParameterBufferH264 slice_param;
  int err;

  slice_param = (VASliceParameterBufferH264){
      .slice_data_size = size,
      .slice_data_offset = 0,
      .slice_data_flag = VA_SLICE_DATA_FLAG_ALL,
      .slice_data_bit_offset = get_bits_count(&sl->gb),
      .first_mb_in_slice =
          (sl->mb_y >> FIELD_OR_MBAFF_PICTURE(h)) * h->mb_width + sl->mb_x,
      .slice_type = ff_h264_get_slice_type(sl),
      .direct_spatial_mv_pred_flag =
          sl->slice_type == AV_PICTURE_TYPE_B ? sl->direct_spatial_mv_pred : 0,
      .num_ref_idx_l0_active_minus1 =
          sl->list_count > 0 ? sl->ref_count[0] - 1 : 0,
      .num_ref_idx_l1_active_minus1 =
          sl->list_count > 1 ? sl->ref_count[1] - 1 : 0,
      .cabac_init_idc = sl->cabac_init_idc,
      .slice_qp_delta = sl->qscale - h->ps.pps->init_qp,
      .disable_deblocking_filter_idc = sl->deblocking_filter < 2
                                           ? !sl->deblocking_filter
                                           : sl->deblocking_filter,
      .slice_alpha_c0_offset_div2 = sl->slice_alpha_c0_offset / 2,
      .slice_beta_offset_div2 = sl->slice_beta_offset / 2,
      .luma_log2_weight_denom = sl->pwt.luma_log2_weight_denom,
      .chroma_log2_weight_denom = sl->pwt.chroma_log2_weight_denom,
  };

  fill_vaapi_RefPicList(slice_param.RefPicList0, sl->ref_list[0],
                        sl->list_count > 0 ? sl->ref_count[0] : 0);
  fill_vaapi_RefPicList(slice_param.RefPicList1, sl->ref_list[1],
                        sl->list_count > 1 ? sl->ref_count[1] : 0);

  fill_vaapi_plain_pred_weight_table(
      h, 0, &slice_param.luma_weight_l0_flag, slice_param.luma_weight_l0,
      slice_param.luma_offset_l0, &slice_param.chroma_weight_l0_flag,
      slice_param.chroma_weight_l0, slice_param.chroma_offset_l0);
  fill_vaapi_plain_pred_weight_table(
      h, 1, &slice_param.luma_weight_l1_flag, slice_param.luma_weight_l1,
      slice_param.luma_offset_l1, &slice_param.chroma_weight_l1_flag,
      slice_param.chroma_weight_l1, slice_param.chroma_offset_l1);

  err = ff_vaapi_decode_make_slice_buffer(avctx, pic, &slice_param,
                                          sizeof(slice_param), buffer, size);
  if (err) {
    ff_vaapi_decode_cancel(avctx, pic);
    return err;
  }

  return 0;
}"
Lyndir-MasterPassword-10be587/core/c/src/mpw-marshal.c	"Create a new site attached to the given user object, ready for marshalling."	2	"MPMarshalledSite *mpw_marshal_site(MPMarshalledUser *user, const char *siteName,
                                   const MPResultType resultType,
                                   const MPCounterValue siteCounter,
                                   const MPAlgorithmVersion algorithmVersion) {

  if (!siteName || !mpw_realloc(&user->sites, NULL,
                                sizeof(MPMarshalledSite) * ++user->sites_count))
    return NULL;

  MPMarshalledSite *site = &user->sites[user->sites_count - 1];
  *site = (MPMarshalledSite){
      .name = mpw_strdup(siteName),
      .content = NULL,
      .type = resultType,
      .counter = siteCounter,
      .algorithm = algorithmVersion,

      .loginContent = NULL,
      .loginType = MPResultTypeTemplateName,

      .url = NULL,
      .uses = 0,
      .lastUsed = 0,

      .questions_count = 0,
      .questions = NULL,
  };
  return site;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/DualSerial/LUFA_100219/LUFA/Drivers/USB/Class/Host/MassStorage.c	"Retrieves the total capacity of the attached USB Mass Storage device, in blocks, and block size."	1	"uint8_t
MS_Host_ReadDeviceCapacity(USB_ClassInfo_MS_Host_t *const MSInterfaceInfo,
                           const uint8_t LUNIndex,
                           SCSI_Capacity_t *const DeviceCapacity) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(MSInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  MS_CommandBlockWrapper_t SCSICommandBlock = (MS_CommandBlockWrapper_t){
      .Signature = CBW_SIGNATURE,
      .DataTransferLength = sizeof(SCSI_Capacity_t),
      .Flags = COMMAND_DIRECTION_DATA_IN,
      .LUN = LUNIndex,
      .SCSICommandLength = 10,
      .SCSICommandData = {SCSI_CMD_READ_CAPACITY_10, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00}};

  MS_CommandStatusWrapper_t SCSICommandStatus;

  if ((ErrorCode = MS_Host_SendCommand(MSInterfaceInfo, &SCSICommandBlock,
                                       DeviceCapacity)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  DeviceCapacity->Blocks = SwapEndian_32(DeviceCapacity->Blocks);
  DeviceCapacity->BlockSize = SwapEndian_32(DeviceCapacity->BlockSize);

  if ((ErrorCode = MS_Host_GetReturnedStatus(
           MSInterfaceInfo, &SCSICommandStatus)) != PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
mkiol-Jupii-2fdeaeb/libs/libav/src/libavformat/utils.c	"Add a new stream to a media file. When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in read_packet()."	2	"AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c) {
  AVStream *st;
  int i;

  if (av_reallocp_array(&s->streams, s->nb_streams + 1, sizeof(*s->streams)) <
      0) {
    s->nb_streams = 0;
    return NULL;
  }

  st = av_mallocz(sizeof(AVStream));
  if (!st)
    return NULL;
  if (!(st->info = av_mallocz(sizeof(*st->info)))) {
    av_free(st);
    return NULL;
  }

#if FF_API_LAVF_AVCTX
  FF_DISABLE_DEPRECATION_WARNINGS
  st->codec = avcodec_alloc_context3(c);
  if (!st->codec) {
    av_free(st->info);
    av_free(st);
    return NULL;
  }
  FF_ENABLE_DEPRECATION_WARNINGS
#endif

  st->internal = av_mallocz(sizeof(*st->internal));
  if (!st->internal)
    goto fail;

  if (s->iformat) {
#if FF_API_LAVF_AVCTX
    FF_DISABLE_DEPRECATION_WARNINGS

    st->codec->bit_rate = 0;
    FF_ENABLE_DEPRECATION_WARNINGS
#endif

    avpriv_set_pts_info(st, 33, 1, 90000);

    st->cur_dts = 0;
  } else {
    st->cur_dts = AV_NOPTS_VALUE;
  }

  st->codecpar = avcodec_parameters_alloc();
  if (!st->codecpar)
    goto fail;

  st->internal->avctx = avcodec_alloc_context3(NULL);
  if (!st->internal->avctx)
    goto fail;

  st->index = s->nb_streams;
  st->start_time = AV_NOPTS_VALUE;
  st->duration = AV_NOPTS_VALUE;
  st->first_dts = AV_NOPTS_VALUE;
  st->probe_packets = MAX_PROBE_PACKETS;

  st->last_IP_pts = AV_NOPTS_VALUE;
  for (i = 0; i < MAX_REORDER_DELAY + 1; i++)
    st->pts_buffer[i] = AV_NOPTS_VALUE;

  st->sample_aspect_ratio = (AVRational){0, 1};

  st->info->fps_first_dts = AV_NOPTS_VALUE;
  st->info->fps_last_dts = AV_NOPTS_VALUE;

#if FF_API_LAVF_AVCTX
  st->internal->need_codec_update = 1;
#endif

  s->streams[s->nb_streams++] = st;
  return st;
fail:
  free_stream(&st);
  return NULL;
}"
debuti-PebbleNotepad-6bf3a43/src/main.c	"If enabled, goes to fake clock (tm)"	2	"void select_multi_click_note_window_handler(ClickRecognizerRef recognizer,
                                            void *context) {
  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0,
          ""###select_multi_click_note_window_handler: Entering###"");

#if ALLOW_FAKE_CLOCK == 1

  clock_window = window_create();
  window_set_fullscreen(clock_window, true);

  window_set_window_handlers(clock_window, (WindowHandlers){
                                               .load = clock_window_load,
                                               .unload = clock_window_unload,
                                           });

  window_stack_push(clock_window, true);
#endif

  app_log(APP_LOG_LEVEL_DEBUG, ""main.c"", 0,
          ""###select_multi_click_note_window_handler: Exiting###"");
}"
loretoparisi-EssentiaTouch-263f778/EssentiaTouch/algorithms/tonal/pitchsaliencefunction.h	"Do the actual computation once that everything is set and configured. The recommended use for this function is to first get the inputs and outputs into local ref variables (const for the inputs) and then do the processing. This allow you also to write a ""classic"" function call with parameters which you would just wrap with the parameterless function."	2	"public:
PitchSalienceFunction() {
  declareInput(_frequencies, ""frequencies"",
               ""the frequencies of the spectral peaks [Hz]"");
  declareInput(_magnitudes, ""magnitudes"",
               ""the magnitudes of the spectral peaks"");
  declareOutput(_salienceFunction, ""salienceFunction"",
                ""array of the quantized pitch salience values"");
}

~PitchSalienceFunction(){};

void declareParameters() {
  declareParameter(""binResolution"", ""salience function bin resolution [cents]"",
                   ""(0,inf)"", 10.0);
  declareParameter(""referenceFrequency"",
                   ""the reference frequency for Hertz to cent convertion [Hz], ""
                   ""corresponding to the 0th cent bin"",
                   ""(0,inf)"", 55.0);
  declareParameter(""magnitudeThreshold"",
                   ""peak magnitude threshold (maximum allowed difference from ""
                   ""the highest peak in dBs)"",
                   ""[0,inf)"", 40.0);
  declareParameter(""magnitudeCompression"",
                   ""magnitude compression parameter (=0 for maximum ""
                   ""compression, =1 for no compression)"",
                   ""(0,1]"", 1.0);
  declareParameter(""numberHarmonics"", ""number of considered harmonics"",
                   ""[1,inf)"", 20);
  declareParameter(""harmonicWeight"",
                   ""harmonic weighting parameter (weight decay ratio between ""
                   ""two consequent harmonics, =1 for no decay)"",
                   ""(0,1)"", 0.8);
}

void configure();
void compute();

static const char *name;
static const char *version;
static const char *description;
}
;
}
}

#include ""streamingalgorithmwrapper.h""

namespace essentia {
namespace streaming {

class PitchSalienceFunction : public StreamingAlgorithmWrapper {

protected:
  Sink<std::vector<Real>> _frequencies;
  Sink<std::vector<Real>> _magnitudes;
  Source<std::vector<Real>> _salienceFunction;

public:
  PitchSalienceFunction() {
    declareAlgorithm(""PitchSalienceFunction"");
    declareInput(_frequencies, TOKEN, ""frequencies"");
    declareInput(_magnitudes, TOKEN, ""magnitudes"");
    declareOutput(_salienceFunction, TOKEN, ""salienceFunction"");
  }
};

}
}"
Proxmark-proxmark3-fdd9395/client/cmdhf15.c	Commandline handling: HF15 CMD READMULTI Read multiple blocks at once (not all tags support this)	2	"int CmdHF15CmdReadmulti(const char *Cmd) {
  UsbCommand resp;
  uint8_t *recv;
  UsbCommand c = {CMD_ISO_15693_COMMAND, {0, 1, 1}};
  uint8_t *req = c.d.asBytes;
  int reqlen = 0, pagenum, pagecount;
  char cmdbuf[100];
  char *cmd = cmdbuf;
  char output[2048] = """";

  strncpy(cmd, Cmd, 99);

  if (strlen(cmd) < 3) {
    PrintAndLog(
        ""Usage:  hf 15 cmd readmulti  [options] <uid|s|u|*> <start#> <count#>"");
    PrintAndLog(""           options:"");
    PrintAndLog(""               -2        use slower '1 out of 256' mode"");
    PrintAndLog(""           uid (either): "");
    PrintAndLog(""               <8B hex>  full UID eg E011223344556677"");
    PrintAndLog(""               s         selected tag"");
    PrintAndLog(""               u         unaddressed mode"");
    PrintAndLog(""               *         scan for tag"");
    PrintAndLog(""           start#:       page number to start 0-255"");
    PrintAndLog(""           count#:       number of pages"");
    return 0;
  }

  prepareHF15Cmd(&cmd, &c, (uint8_t[]){ISO15693_READ_MULTI_BLOCK}, 1);
  reqlen = c.arg[0];

  pagenum = strtol(cmd, NULL, 0);

  while (*cmd != ' ' && *cmd != '\t')
    cmd++;

  while (*cmd == ' ' || *cmd == '\t')
    cmd++;

  pagecount = strtol(cmd, NULL, 0);
  if (pagecount > 0)
    pagecount--;

  req[reqlen++] = (uint8_t)pagenum;
  req[reqlen++] = (uint8_t)pagecount;

  reqlen = AddCrc(req, reqlen);

  c.arg[0] = reqlen;

  SendCommand(&c);

  if (WaitForResponseTimeout(CMD_ACK, &resp, 1000) && resp.arg[0] > 2) {
    recv = resp.d.asBytes;
    if (ISO15693_CRC_CHECK == Crc(recv, resp.arg[0])) {
      if (!(recv[0] & ISO15693_RES_ERROR)) {
        *output = 0;
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%02X "", recv[i]);
        }
        strcat(output, ""   "");
        for (int i = 1; i < resp.arg[0] - 2; i++) {
          sprintf(output + strlen(output), ""%c"",
                  recv[i] > 31 && recv[i] < 127 ? recv[i] : '.');
        }
        PrintAndLog(""%s"", output);
      } else {
        PrintAndLog(""Tag returned Error %i: %s"", recv[0], TagErrorStr(recv[0]));
      }
    } else {
      PrintAndLog(""CRC failed"");
    }
  } else {
    PrintAndLog(""no answer"");
  }

  return 0;
}"
Davion8948-AndroidVideoPlayer-3f492c5/jni/ffmpeg-2.0.1/libavfilter/avfilter.c	"Negotiate the media format, dimensions, etc of all inputs to a filter."	2	"int avfilter_config_links(AVFilterContext *filter) {
  int (*config_link)(AVFilterLink *);
  unsigned i;
  int ret;

  for (i = 0; i < filter->nb_inputs; i++) {
    AVFilterLink *link = filter->inputs[i];
    AVFilterLink *inlink;

    if (!link)
      continue;

    inlink = link->src->nb_inputs ? link->src->inputs[0] : NULL;
    link->current_pts = AV_NOPTS_VALUE;

    switch (link->init_state) {
    case AVLINK_INIT:
      continue;
    case AVLINK_STARTINIT:
      av_log(filter, AV_LOG_INFO, ""circular filter chain detected\n"");
      return 0;
    case AVLINK_UNINIT:
      link->init_state = AVLINK_STARTINIT;

      if ((ret = avfilter_config_links(link->src)) < 0)
        return ret;

      if (!(config_link = link->srcpad->config_props)) {
        if (link->src->nb_inputs != 1) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Source filters and filters ""
                 ""with more than one input ""
                 ""must set config_props() ""
                 ""callbacks on all outputs\n"");
          return AVERROR(EINVAL);
        }
      } else if ((ret = config_link(link)) < 0) {
        av_log(link->src, AV_LOG_ERROR,
               ""Failed to configure output pad on %s\n"", link->src->name);
        return ret;
      }

      switch (link->type) {
      case AVMEDIA_TYPE_VIDEO:
        if (!link->time_base.num && !link->time_base.den)
          link->time_base = inlink ? inlink->time_base : AV_TIME_BASE_Q;

        if (!link->sample_aspect_ratio.num && !link->sample_aspect_ratio.den)
          link->sample_aspect_ratio =
              inlink ? inlink->sample_aspect_ratio : (AVRational){1, 1};

        if (inlink && !link->frame_rate.num && !link->frame_rate.den)
          link->frame_rate = inlink->frame_rate;

        if (inlink) {
          if (!link->w)
            link->w = inlink->w;
          if (!link->h)
            link->h = inlink->h;
        } else if (!link->w || !link->h) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Video source filters must set their output link's ""
                 ""width and height\n"");
          return AVERROR(EINVAL);
        }
        break;

      case AVMEDIA_TYPE_AUDIO:
        if (inlink) {
          if (!link->time_base.num && !link->time_base.den)
            link->time_base = inlink->time_base;
        }

        if (!link->time_base.num && !link->time_base.den)
          link->time_base = (AVRational){1, link->sample_rate};
      }

      if ((config_link = link->dstpad->config_props))
        if ((ret = config_link(link)) < 0) {
          av_log(link->src, AV_LOG_ERROR,
                 ""Failed to configure input pad on %s\n"", link->dst->name);
          return ret;
        }

      link->init_state = AVLINK_INIT;
    }
  }

  return 0;
}"
asogor-thrift-as3-d2691bd/compiler/cpp/src/generate/t_js_generator.cc	Generates the read() method for a struct	2	"void t_js_generator::generate_js_struct_reader(ofstream &out,
                                               t_struct *tstruct) {
  const vector<t_field *> &fields = tstruct->get_members();
  vector<t_field *>::const_iterator f_iter;

  out << js_namespace(tstruct->get_program()) << tstruct->get_name()
      << "".prototype.read = function(input){ "" << endl;

  indent_up();

  indent(out) << ""var ret = input.readStructBegin()"" << endl;

  indent(out) << ""while (1) "" << endl;

  scope_up(out);

  indent(out) << ""var ret = input.readFieldBegin()"" << endl;
  indent(out) << ""var fname = ret.fname"" << endl;
  indent(out) << ""var ftype = ret.ftype"" << endl;
  indent(out) << ""var fid   = ret.fid"" << endl;

  indent(out) << ""if (ftype == Thrift.Type.STOP) "" << endl;
  indent_up();
  indent(out) << ""break"" << endl;
  indent_down();

  indent(out) << ""switch(fid)"" << endl;

  scope_up(out);

  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {

    indent(out) << ""case "" << (*f_iter)->get_key() << "":"";
    indent(out) << ""if (ftype == "" << type_to_enum((*f_iter)->get_type())
                << "") {"" << endl;

    indent_up();
    generate_deserialize_field(out, *f_iter, ""this."");
    indent_down();

    indent(out) << ""} else {"" << endl;

    indent(out) << ""  input.skip(ftype)"" << endl;

    out << indent() << ""}"" << endl << indent() << ""break"" << endl;
  }

  indent(out) << ""default:"" << endl;
  indent(out) << ""  input.skip(ftype)"" << endl;

  scope_down(out);

  indent(out) << ""input.readFieldEnd()"" << endl;

  scope_down(out);

  indent(out) << ""input.readStructEnd()"" << endl;

  indent(out) << ""return"" << endl;

  indent_down();
  out << indent() << ""}"" << endl << endl;
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/MassStorageHost/Lib/MassStoreCommands.c	"Issues a SCSI Device Test Unit Ready command to the attached device, to determine if the device is ready to accept other commands."	1	"uint8_t MassStore_TestUnitReady(const uint8_t LUNIndex) {
  uint8_t ReturnCode = PIPE_RWSTREAM_NoError;

  SCSICommandBlock = (CommandBlockWrapper_t){
      .Header = {.Signature = CBW_SIGNATURE,
                 .Tag = MassStore_Tag,
                 .DataTransferLength = 0,
                 .Flags = COMMAND_DIRECTION_DATA_IN,
                 .LUN = LUNIndex,
                 .SCSICommandLength = 6},

      .SCSICommandData = {SCSI_CMD_TEST_UNIT_READY, 0x00, 0x00, 0x00, 0x00,
                          0x00}};

  MassStore_SendCommand();

  if ((ReturnCode = MassStore_GetReturnedStatus()) != PIPE_RWSTREAM_NoError) {
    Pipe_Freeze();
    return ReturnCode;
  }

  return PIPE_RWSTREAM_NoError;
}"
cmassiot-vlc-broadcast-de11815/src/text/unicode.c	"Look for an UTF-8 string within another one in a case-insensitive fashion. Beware that this is quite slow. Contrary to strcasestr(), this function works regardless of the system character encoding, and handles multibyte code points correctly."	2	"char *vlc_strcasestr(const char *haystack, const char *needle) {
  ssize_t s;

  do {
    const char *h = haystack, *n = needle;

    for (;;) {
      uint32_t cph, cpn;

      s = vlc_towc(n, &cpn);
      if (s == 0)
        return (char *)haystack;
      if (unlikely(s < 0))
        return NULL;
      n += s;

      s = vlc_towc(h, &cph);
      if (s <= 0 || towlower(cph) != towlower(cpn))
        break;
      h += s;
    }

    s = vlc_towc(haystack, &(uint32_t){0});
    haystack += s;
  } while (s != 0);

  return NULL;
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/LUFA/Drivers/USB/Class/Host/StillImage.c	"Sends a given PIMA command to the attached device, filling out the PIMA command header's Transaction ID automatically."	0	"uint8_t SI_Host_SendCommand(USB_ClassInfo_SI_Host_t *const SIInterfaceInfo,
                            const uint16_t Operation, const uint8_t TotalParams,
                            uint32_t *const Params) {
  if ((USB_HostState != HOST_STATE_Configured) ||
      !(SIInterfaceInfo->State.IsActive))
    return HOST_SENDCONTROL_DeviceDisconnected;

  uint8_t ErrorCode;

  PIMA_Container_t PIMABlock = (PIMA_Container_t){
      .DataLength = PIMA_COMMAND_SIZE(TotalParams),
      .Type = PIMA_CONTAINER_CommandBlock,
      .Code = Operation,
  };

  memcpy(&PIMABlock.Params, Params, sizeof(uint32_t) * TotalParams);

  if ((ErrorCode = SI_Host_SendBlockHeader(SIInterfaceInfo, &PIMABlock)) !=
      PIPE_RWSTREAM_NoError)
    return ErrorCode;

  return PIPE_RWSTREAM_NoError;
}"
ossimlabs-ossim-e455b84/include/ossim/parallel/ossimJobThreadQueue.h	Sets the shared queue that this thread will be pulling jobs from	2	"*ossimJobThreadQueue allows one to instantiate a thread with a shared *queue
     .the thread will block if the queue is empty and will continue *to pop jobs
         off the queue calling the start method on the job
     .Once it *finishes the job it is disguarded and then the next job will be
         popped off the *queue.**@code *class TestJob : public ossimJob * {
  *public : *TestJob(){} * protected : *virtual void run() * {
    *ossim::Thread::sleepInSeconds(2);
    *
  }"
BurntSushi-openbox-multihead-4e7c884/obt/xqueue.c	"Begin listening for X events in the default GMainContext, and feed them to the registered callback functions, added with xqueue_add_callback()."	2	"void xqueue_listen(void) {
  GSource *source = g_source_new(&x_source_funcs, sizeof(struct x_source));
  struct x_source *x_source = (struct x_source *)source;
  GPollFD *pfd = &x_source->pfd;

  *pfd = (GPollFD){ConnectionNumber(obt_display), G_IO_IN, G_IO_IN};
  g_source_add_poll(source, pfd);
  g_source_attach(source, NULL);
}"
randyrossi-bmc64-c645676/third_party/vice-3.2/src/lib/libffmpeg/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration = 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt);

    if (out_pkt.data == pkt->data && out_pkt.size == pkt->size) {
      out_pkt.buf = pkt->buf;
      pkt->buf = NULL;
#if FF_API_DESTRUCT_PACKET
      FF_DISABLE_DEPRECATION_WARNINGS
      out_pkt.destruct = pkt->destruct;
      pkt->destruct = NULL;
      FF_ENABLE_DEPRECATION_WARNINGS
#endif
    }
    if ((ret = av_dup_packet(&out_pkt)) < 0)
      goto fail;

    if (!add_to_pktbuf(&s->parse_queue, &out_pkt, &s->parse_queue_end)) {
      av_free_packet(&out_pkt);
      ret = AVERROR(ENOMEM);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_free_packet(pkt);
  return ret;
}"
field-FieldKit.cpp-a2e9d4f/include/fieldkit/math/Line.h	Calculates intersection and checks for parallel lines. Also checks that the intersection point is actually on the line segment p1 - p2	2	"Line2f() {
  p1 = Vec2f::zero();
  p2 = Vec2f::zero();
};

Line2f(Vec2f from, Vec2f to) : p1(from), p2(to){};

~Line2f(){};

bool findIntersection(Line2f const &line, Vec2f *result = NULL);

void set(Vec2f from, Vec2f to);

Vec2f getP1() { return p1; }
void setP1(Vec2f point) { p1 = point; }

Vec2f getP2() { return p2; }
void setP2(Vec2f point) { p2 = point; }

protected:
}
;
}"
PJK-libcbor-87f977e/src/cbor/maps.c	Create a new indefinite map	2	"cbor_item_t *cbor_new_indefinite_map() {
  cbor_item_t *item = _CBOR_MALLOC(sizeof(cbor_item_t));
  _CBOR_NOTNULL(item);

  *item = (cbor_item_t){
      .refcount = 1,
      .type = CBOR_TYPE_MAP,
      .metadata = {.map_metadata = {.allocated = 0,
                                    .type = _CBOR_METADATA_INDEFINITE,
                                    .end_ptr = 0}},
      .data = NULL};

  return item;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/visualization/visualization.c	Output the visualization of the specified computational element geometry in vtk xml format.	2	"(const char geom_type, const struct Simulation *sim,
 const bool use_test_case_path) {
  static char output_part[4 * STRLEN_MAX] = {
      0,
  };
  if (!use_test_case_path) {
    sprintf(output_part, ""%s%c"", ""geom_"", geom_type);
  } else {
    sprintf(output_part, ""%s%c%s%c%s%s"", sim->pde_name, '/', sim->pde_spec, '/',
            ""geom_e__"", extract_name(sim->ctrl_name_full, true));
  }

  const char *const output_name =
      set_output_name(VIS_SOFTWARE_PARAVIEW, output_part);

  static char *extension_part = ""vtu"";
  if (sim->mpi_rank == 0) {
    FILE *p_file =
        fopen_sp_output_file('p', output_name, extension_part, sim->mpi_rank);

    fprint_vtk_header_footer(p_file, true, 'h', ""UnstructuredGrid"");

    fprint_vtk_piece_geom(p_file, 'p', 's', geom_type, NULL, NULL);

    for (int i = 0; i < sim->mpi_size; ++i)
      fprintf(p_file, ""<Piece Source=\""%s_%d.vtu\""/>\n"",
              extract_name(output_part, false), i);
    fprintf(p_file, ""\n"");

    fprint_vtk_header_footer(p_file, true, 'f', ""UnstructuredGrid"");

    fclose(p_file);
  }

  FILE *s_file =
      fopen_sp_output_file('s', output_name, extension_part, sim->mpi_rank);

  fprint_vtk_header_footer(s_file, false, 'h', ""UnstructuredGrid"");
  for (struct Intrusive_Link *curr = sim->volumes->first; curr;
       curr = curr->next) {
    struct Volume *vol = (struct Volume *)curr;
    struct Solver_Volume *s_vol = (struct Solver_Volume *)curr;

    const struct Solver_Element *s_e = (struct Solver_Element *)vol->element;
    const struct Plotting_Element *p_e = &s_e->p_e;

    const int p = s_vol->p_ref;
    const struct Operator *cv0_vg_vp =
        (!vol->curved ? get_Multiarray_Operator(p_e->cv0_vgs_vp,
                                                (ptrdiff_t[]){0, 0, p, 1})
                      : get_Multiarray_Operator(p_e->cv0_vgc_vp,
                                                (ptrdiff_t[]){0, 0, p, p}));

    const struct const_Multiarray_d *g_coef = s_vol->geom_coef;
    const struct const_Multiarray_d *xyz_p =
        constructor_mm_NN1_Operator_const_Multiarray_d(
            cv0_vg_vp, g_coef, 'R', 'd', g_coef->order, NULL);

    fprint_vtk_piece_geom(s_file, 's', 's', geom_type, xyz_p, p_e->p_nodes[p]);
    fprint_vtk_piece_geom(s_file, 's', 'e', geom_type, NULL, NULL);

    destructor_const_Multiarray_d(xyz_p);
  }
  fprint_vtk_header_footer(s_file, false, 'f', ""UnstructuredGrid"");

  fclose(s_file);
}"
ARMmbed-mbed-cloud-client-377c6b8/update-client-hub/modules/manifest-manager/source/manifest-manager-api.c	The event handler is shared among all asynchronous calls. Walks the most recent manifest tree for validity of the tree and presence of the associated images	2	"arm_uc_error_t ARM_UC_mmInit(arm_uc_mmContext_t **mmCtx,
                             void (*event_handler)(uintptr_t),
                             const arm_pal_key_value_api *api) {
  arm_uc_error_t err = {ERR_NONE};
  if (mmCtx == NULL || *mmCtx == NULL) {
    return (arm_uc_error_t){MFST_ERR_NULL_PTR};
  }

  arm_uc_mmPersistentContext.ctx = mmCtx;
  arm_uc_mmPersistentContext.applicationEventHandler = event_handler;
  arm_uc_mmPersistentContext.testFSM = NULL;

  arm_uc_mmPersistentContext.applicationCallbackStorage.lock = 0;

  ARM_UC_PostCallback(&arm_uc_mmPersistentContext.applicationCallbackStorage,
                      event_handler, ARM_UC_MM_RC_DONE);

#if 0
    ARM_UC_mmCfStoreInit(api);

     
    arm_uc_mmContext_t *ctx = *mmCtx;
    ctx->init.state = ARM_UC_MM_INIT_BEGIN;

    err = ARM_UC_mmSetState(ARM_UC_MM_STATE_INIT);
    if (err.code != ERR_NONE) {
        return err;
    }
     
    ARM_UC_PostCallback(&ctx->init.callbackStorage, ARM_UC_mmCallbackFSMEntry, ARM_UC_MM_EVENT_BEGIN);
#endif
  return err;
}"
brenns10-cbot-2f21c1a/plugin/karma.c	"This function will locate an existing word in the karma array and return its index. If the word doesn't exist, it will copy it, add it to the karma array, set its karma to zero, and return its index."	2	"static size_t find_or_create_karma(const char *word) {
  ssize_t idx;
  if (karma == NULL) {
    karma = calloc(karma_alloc, sizeof(karma_t));
  }
  idx = find_karma(word);
  if (idx < 0) {
    if (nkarma == karma_alloc) {
      karma_alloc *= 2;
      karma = realloc(karma, karma_alloc * sizeof(karma_t));
    }
    idx = nkarma++;
    karma[idx] = (karma_t){.word = copy_string(word), .karma = 0};
  }
  return idx;
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/avalanche/value.h	Returns the datum of the given ava_value interpreted as a string.	2	"static inline ava_string ava_value_str(ava_value v) {
  return (ava_string){.ascii9 = AVA_VALUE_SUB(v, 1)};
}"
darktable-org-darktable-32fab21/src/iop/splittoning.c	construct widget.	2	"void gui_init(struct dt_iop_module_t *self) {
  self->gui_data = malloc(sizeof(dt_iop_splittoning_gui_data_t));
  dt_iop_splittoning_gui_data_t *g =
      (dt_iop_splittoning_gui_data_t *)self->gui_data;
  dt_iop_splittoning_params_t *p = (dt_iop_splittoning_params_t *)self->params;

  int line = 0;
  self->widget = gtk_grid_new();
  GtkGrid *grid = GTK_GRID(self->widget);
  gtk_grid_set_row_spacing(grid, DT_BAUHAUS_SPACE);
  gtk_grid_set_column_spacing(grid, DT_BAUHAUS_SPACE);
  gtk_grid_set_column_homogeneous(grid, FALSE);
  dt_gui_add_help_link(self->widget, dt_get_help_url(self->op));

  float rgb[3];

  hsl2rgb(rgb, p->shadow_hue, p->shadow_saturation, 0.5f);
  GdkRGBA sh_color =
      (GdkRGBA){.red = rgb[0], .green = rgb[1], .blue = rgb[2], .alpha = 1.0};
  line = gui_init_tab(self, line, _(""shadows""), &g->colorpick1, &sh_color,
                      &g->gslider1, &g->gslider2);

  hsl2rgb(rgb, p->highlight_hue, p->highlight_saturation, 0.5f);
  GdkRGBA hi_color =
      (GdkRGBA){.red = rgb[0], .green = rgb[1], .blue = rgb[2], .alpha = 1.0};
  line = gui_init_tab(self, line, _(""highlights""), &g->colorpick2, &hi_color,
                      &g->gslider3, &g->gslider4);

  g->scale1 = dt_bauhaus_slider_new_with_range_and_feedback(
      self, 0.0, 100.0, 0.1, p->balance * 100.0, 2, 0);
  dt_bauhaus_slider_set_format(g->scale1, ""%.2f"");
  dt_bauhaus_slider_set_stop(g->scale1, 0.0f, 0.5f, 0.5f, 0.5f);
  dt_bauhaus_slider_set_stop(g->scale1, 1.0f, 0.5f, 0.5f, 0.5f);
  dt_bauhaus_widget_set_label(g->scale1, NULL, _(""balance""));
  gtk_widget_set_margin_top(g->scale1, 6 * DT_BAUHAUS_SPACE);
  gtk_grid_attach(grid, g->scale1, 0, line++, 2, 1);

  g->scale2 =
      dt_bauhaus_slider_new_with_range(self, 0.0, 100.0, 1.0, p->compress, 2);
  dt_bauhaus_slider_set_format(g->scale2, ""%.2f%%"");
  dt_bauhaus_widget_set_label(g->scale2, NULL, _(""compress""));
  gtk_grid_attach(grid, g->scale2, 0, line++, 2, 1);

  gtk_widget_set_tooltip_text(g->scale1,
                              _(""the balance of center of splittoning""));
  gtk_widget_set_tooltip_text(
      g->scale2,
      _(""compress the effect on highlights/shadows and\npreserve midtones""));

  g_signal_connect(G_OBJECT(g->gslider1), ""value-changed"",
                   G_CALLBACK(hue_callback), self);
  g_signal_connect(G_OBJECT(g->gslider3), ""value-changed"",
                   G_CALLBACK(hue_callback), self);

  g_signal_connect(G_OBJECT(g->gslider2), ""value-changed"",
                   G_CALLBACK(saturation_callback), self);
  g_signal_connect(G_OBJECT(g->gslider4), ""value-changed"",
                   G_CALLBACK(saturation_callback), self);

  g_signal_connect(G_OBJECT(g->scale1), ""value-changed"",
                   G_CALLBACK(balance_callback), self);
  g_signal_connect(G_OBJECT(g->scale2), ""value-changed"",
                   G_CALLBACK(compress_callback), self);

  g_signal_connect(G_OBJECT(g->colorpick1), ""color-set"",
                   G_CALLBACK(colorpick_callback), self);
  g_signal_connect(G_OBJECT(g->colorpick2), ""color-set"",
                   G_CALLBACK(colorpick_callback), self);

  dt_iop_init_picker(&g->color_picker, self, DT_COLOR_PICKER_POINT,
                     _iop_color_picker_get_set, _iop_color_picker_apply,
                     _iop_color_picker_update);
}"
AltSysrq-avalanche-a3f4bfd/bootstrap-runtime/src/runtime/-intrinsics/pasta.c	"Syntax: goto label label is a bareword. Semantics: Control immediately transfers into the block immediately following the matching label, which must be a symbol defined by a pasta structure which encloses the goto and is in the same function."	2	"ava_macro_subst_result ava_intr_goto_subst(
    const struct ava_symbol_s *self, ava_macsub_context *context,
    const ava_parse_statement *statement, const ava_parse_unit *provoker,
    ava_bool *consumed_other_statements) {
  ava_intr_goto *this;
  const ava_parse_unit *target_unit = NULL;
  ava_string target_name;

  AVA_MACRO_ARG_PARSE {
    AVA_MACRO_ARG_FROM_RIGHT_BEGIN {
      AVA_MACRO_ARG_CURRENT_UNIT(target_unit, ""target"");
      AVA_MACRO_ARG_BAREWORD(target_name, ""target"");
    }
  }

  this = AVA_NEW(ava_intr_goto);
  this->header.v = &ava_intr_goto_vtable;
  this->header.location = provoker->location;
  this->header.context = context;
  this->target_name = target_name;
  this->target_location = target_unit->location;

  return (ava_macro_subst_result){
      .status = ava_mss_done,
      .v = {.node = (ava_ast_node *)this},
  };
}"
trep-opentrep-0b6b813/opentrep/command/RequestInterpreter.cpp	Return the list of locations/places corresponding to the given IATA/ICAO codes or Geonames IDs.	2	"NbOfMatches_T getLocationList(const DBType &iSQLDBType,
                              const SQLDBConnectionString_T &iSQLDBConnStr,
                              const WordList_T &iCodeList,
                              LocationList_T &ioLocationList,
                              WordList_T &ioWordList) {
  NbOfMatches_T oNbOfMatches = 0;

  soci::session *lSociSession_ptr =
      DBManager::initSQLDBSession(iSQLDBType, iSQLDBConnStr);
  if (lSociSession_ptr == NULL) {
    std::ostringstream oStr;
    oStr << ""The "" << iSQLDBType.describe()
         << "" database is not accessible. Connection string: "" << iSQLDBConnStr
         << std::endl
         << ""Hint: launch the 'opentrep-dbmgr' program and ""
         << ""see the 'tutorial' command."";
    OPENTREP_LOG_ERROR(oStr.str());
    throw SQLDatabaseImpossibleConnectionException(oStr.str());
  }
  assert(lSociSession_ptr != NULL);

  for (WordList_T::const_iterator itWord = iCodeList.begin();
       itWord != iCodeList.end(); ++itWord) {
    const std::string &lWord = *itWord;

    const boost::regex lIATACodeExp(""^[[:alpha:]]{3}$"");
    const bool lMatchesWithIATACode = regex_match(lWord, lIATACodeExp);
    if (lMatchesWithIATACode == true) {

      const IATACode_T lIATACode(lWord);
      const bool lUniqueEntry = true;
      const NbOfDBEntries_T &lNbOfEntries = DBManager::getPORByIATACode(
          *lSociSession_ptr, lIATACode, ioLocationList, lUniqueEntry);
      oNbOfMatches += lNbOfEntries;
      continue;
    }

    const boost::regex lICAOCodeExp(""^([[:alpha:]]|[[:digit:]]){4}$"");
    const bool lMatchesWithICAOCode = regex_match(lWord, lICAOCodeExp);
    if (lMatchesWithICAOCode == true) {

      const ICAOCode_T lICAOCode(lWord);
      const NbOfDBEntries_T &lNbOfEntries = DBManager::getPORByICAOCode(
          *lSociSession_ptr, lICAOCode, ioLocationList);
      oNbOfMatches += lNbOfEntries;
      continue;
    }

    const boost::regex lGeoIDCodeExp(""^[[:digit:]]{1,11}$"");
    const bool lMatchesWithGeoID = regex_match(lWord, lGeoIDCodeExp);
    if (lMatchesWithGeoID == true) {
      try {

        const GeonamesID_T lGeonamesID =
            boost::lexical_cast<GeonamesID_T>(lWord);

        const NbOfDBEntries_T &lNbOfEntries = DBManager::getPORByGeonameID(
            *lSociSession_ptr, lGeonamesID, ioLocationList);
        oNbOfMatches += lNbOfEntries;

      } catch (boost::bad_lexical_cast &eCast) {
        OPENTREP_LOG_ERROR(""The Geoname ID ('"" << lWord
                                               << ""') cannot be understood."");
      }
    }
  }

  return oNbOfMatches;
}"
PhilipZwanenburg-DPGSolver-b48e04b/src/simulation/solvers/numerical_flux/numerical_flux_central_T.c	Set any normal numerical flux members which are provided directly from the boundary conditions.	2	"(const struct Numerical_Flux_Input_T *const num_flux_i,
 struct mutable_Numerical_Flux_T *const num_flux) {
  const bool *const c_m = num_flux_i->flux_i->compute_member;

  assert(c_m[0]);
  set_Numerical_Flux_Energy_member(num_flux->nnf, num_flux_i->bv_r.nf_E,
                                   (int[]){1, 1});

  const_cast_b(&num_flux_i->bv_r.nf_E_provided, false);
}"
cochrane-GLLara-91ed369/shared_simd/simd_functions.h	"Verteilt einen Float auf alle Elemente eines Vektors  Vor allem fr dynamische Daten, fr konstante Daten kann es sein, dass dies langsamer ist als (vec_float4) {a, a, a, a}"	2	"static inline vec_float4 simd_splatf(float a) {
#if defined(__PPU__)

  return vec_splat(a);
#elif defined(__SPU__)
  return spu_splat(a);
#elif defined(__NEON__)
  return vdupq_n_f32(a);
#elif defined(__SSE__)
  return _mm_set1_ps(a);
#else

  return (vec_float4){a, a, a, a};
#endif
}"
jperfetto-OpenPCR-1585d96/usb/LUFA101122/Demos/Host/LowLevel/StillImageHost/StillImageHost.c	"Task to set the configuration of the attached device after it has been enumerated, and to print device information through the serial port."	1	"void StillImage_Task(void) {
  uint8_t ErrorCode;

  switch (USB_HostState) {
  case HOST_STATE_Addressed:
    puts_P(PSTR(""Getting Config Data.\r\n""));

    if ((ErrorCode = ProcessConfigurationDescriptor()) !=
        SuccessfulConfigRead) {
      if (ErrorCode == ControlError)
        puts_P(PSTR(ESC_FG_RED ""Control Error (Get Configuration).\r\n""));
      else
        puts_P(PSTR(ESC_FG_RED ""Invalid Device.\r\n""));

      printf_P(PSTR("" -- Error Code: %d\r\n"" ESC_FG_WHITE), ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((ErrorCode = USB_Host_SetDeviceConfiguration(1)) !=
        HOST_SENDCONTROL_Successful) {
      printf_P(PSTR(ESC_FG_RED ""Control Error (Set Configuration).\r\n""
                               "" -- Error Code: %d\r\n"" ESC_FG_WHITE),
               ErrorCode);

      LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Still Image Device Enumerated.\r\n""));
    USB_HostState = HOST_STATE_Configured;
    break;
  case HOST_STATE_Configured:

    LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

    puts_P(PSTR(""Retrieving Device Info...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(0),
        .Type = PIMA_CONTAINER_CommandBlock,
        .Code = PIMA_OPERATION_GETDEVICEINFO,
        .TransactionID = 0x00000000,
        .Params = {},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    uint16_t DeviceInfoSize =
        (PIMA_ReceivedBlock.DataLength - PIMA_COMMAND_SIZE(0));

    uint8_t DeviceInfo[DeviceInfoSize];

    SImage_ReadData(DeviceInfo, DeviceInfoSize);

    Pipe_ClearIN();

    uint8_t *DeviceInfoPos = DeviceInfo;

    DeviceInfoPos += 8;
    DeviceInfoPos += (1 + UNICODE_STRING_LENGTH(*DeviceInfoPos));
    DeviceInfoPos += 2;
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));
    DeviceInfoPos += (4 + (*(uint32_t *)DeviceInfoPos << 1));

    char Manufacturer[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, Manufacturer);
    printf_P(PSTR(""   Manufacturer: %s\r\n""), Manufacturer);

    DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);

    char Model[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, Model);
    printf_P(PSTR(""   Model: %s\r\n""), Model);

    DeviceInfoPos += 1 + UNICODE_STRING_LENGTH(*DeviceInfoPos);

    char DeviceVersion[*DeviceInfoPos];
    UnicodeToASCII(DeviceInfoPos, DeviceVersion);
    printf_P(PSTR(""   Device Version: %s\r\n""), DeviceVersion);

    if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Opening Session...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(1),
        .Type = PIMA_CONTAINER_CommandBlock,
        .Code = PIMA_OPERATION_OPENSESSION,
        .TransactionID = 0x00000000,
        .Params = {0x00000001},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Closing Session...\r\n""));

    PIMA_SendBlock = (PIMA_Container_t){
        .DataLength = PIMA_COMMAND_SIZE(1),
        .Type = PIMA_CONTAINER_CommandBlock,
        .Code = PIMA_OPERATION_CLOSESESSION,
        .TransactionID = 0x00000001,
        .Params = {0x00000001},
    };

    SImage_SendBlockHeader();

    if ((ErrorCode = SImage_ReceiveBlockHeader()) != PIPE_RWSTREAM_NoError) {
      ShowCommandError(ErrorCode, false);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    if ((PIMA_ReceivedBlock.Type != PIMA_CONTAINER_ResponseBlock) ||
        (PIMA_ReceivedBlock.Code != PIMA_RESPONSE_OK)) {
      ShowCommandError(PIMA_ReceivedBlock.Code, true);

      USB_HostState = HOST_STATE_WaitForDeviceRemoval;
      break;
    }

    puts_P(PSTR(""Done.\r\n""));

    LEDs_SetAllLEDs(LEDMASK_USB_READY);

    USB_HostState = HOST_STATE_WaitForDeviceRemoval;
    break;
  }
}"
dm7h-fpga-event-recorder-4e53bab/src/Logikanalysator/USB-TPLE/Microcontroller_Firmware/LUFA_Based/estick_firmware/LUFA090605/Demos/Host/StillImageHost/Lib/StillImageCommands.c	Clears the stall condition in the attached device on the nominated endpoint number.	0	"uint8_t SImage_ClearPipeStall(const uint8_t EndpointNum) {
  USB_ControlRequest = (USB_Request_Header_t){
      .bmRequestType =
          (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT),
      .bRequest = REQ_ClearFeature,
      .wValue = FEATURE_ENDPOINT_HALT,
      .wIndex = EndpointNum,
      .wLength = 0,
  };

  Pipe_SelectPipe(PIPE_CONTROLPIPE);

  return USB_Host_SendControlRequest(NULL);
}"
metalll-voip-rtsp_IOS-ec4f363/ffmpeg-3.2/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue."	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;
    int64_t next_pts = pkt->pts;
    int64_t next_dts = pkt->dts;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->internal->avctx, &out_pkt.data,
                           &out_pkt.size, data, size, pkt->pts, pkt->dts,
                           pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;
    pkt->pos = -1;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    if (pkt->side_data) {
      out_pkt.side_data = pkt->side_data;
      out_pkt.side_data_elems = pkt->side_data_elems;
      pkt->side_data = NULL;
      pkt->side_data_elems = 0;
    }

    out_pkt.duration =
        (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;
    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->internal->avctx->sample_rate > 0) {
        out_pkt.duration =
            av_rescale_q_rnd(st->parser->duration,
                             (AVRational){1, st->internal->avctx->sample_rate},
                             st->time_base, AV_ROUND_DOWN);
      }
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)
      out_pkt.pos = st->parser->frame_offset;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    if (st->parser->key_frame == -1 &&
        st->parser->pict_type == AV_PICTURE_TYPE_NONE &&
        (pkt->flags & AV_PKT_FLAG_KEY))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);

    ret = add_to_pktbuf(&s->internal->parse_queue, &out_pkt,
                        &s->internal->parse_queue_end, 1);
    av_packet_unref(&out_pkt);
    if (ret < 0)
      goto fail;
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_packet_unref(pkt);
  return ret;
}"
LibtraceTeam-libtrace-90709c5/lib/trace_parallel.c	Similar to delay_tracetime but send messages to all threads periodically	2	"static void *reporter_entry(void *data) {
  libtrace_message_t message = {0, {.uint64 = 0}, NULL};
  libtrace_t *trace = (libtrace_t *)data;
  libtrace_thread_t *t = &trace->reporter_thread;

  ASSERT_RET(pthread_mutex_lock(&trace->libtrace_lock), == 0);
  if (trace->state == STATE_ERROR) {
    thread_change_state(trace, t, THREAD_FINISHED, false);
    ASSERT_RET(pthread_mutex_unlock(&trace->libtrace_lock), == 0);
    pthread_exit(NULL);
  }
  ASSERT_RET(pthread_mutex_unlock(&trace->libtrace_lock), == 0);

  if (trace->format->pregister_thread) {
    trace->format->pregister_thread(trace, t, false);
  }

  send_message(trace, t, MESSAGE_STARTING, (libtrace_generic_t){0}, t);
  send_message(trace, t, MESSAGE_RESUMING, (libtrace_generic_t){0}, t);

  while (!trace_has_finished(trace)) {
    if (trace->config.reporter_polling) {
      if (libtrace_message_queue_try_get(&t->messages, &message) ==
          LIBTRACE_MQ_FAILED)
        message.code = MESSAGE_POST_REPORTER;
    } else {
      libtrace_message_queue_get(&t->messages, &message);
    }
    switch (message.code) {

    case MESSAGE_POST_REPORTER:
      trace->combiner.read(trace, &trace->combiner);
      break;
    case MESSAGE_DO_PAUSE:
      if (trace->combiner.pause) {
        trace->combiner.pause(trace, &trace->combiner);
      }
      send_message(trace, t, MESSAGE_PAUSING, (libtrace_generic_t){0}, t);
      trace_thread_pause(trace, t);
      send_message(trace, t, MESSAGE_RESUMING, (libtrace_generic_t){0}, t);
      break;
    default:
      send_message(trace, t, message.code, message.data, message.sender);
    }
  }

  trace->combiner.read_final(trace, &trace->combiner);

  send_message(trace, t, MESSAGE_PAUSING, (libtrace_generic_t){0}, t);
  send_message(trace, t, MESSAGE_STOPPING, (libtrace_generic_t){0}, t);

  thread_change_state(trace, &trace->reporter_thread, THREAD_FINISHED, true);
  print_memory_stats();
  pthread_exit(NULL);
}"
arkanis-lagrange-77d0420/bootstrap-compiler/asm.c	Write the code and data in the assembler buffer into an ELF binary. Program headers as well as section headers for code and data are written. This way inspection via objdump automatically works.	2	"void as_save_elf(asm_p as, size_t code_vaddr, size_t data_vaddr,
                 const char *filename) {
  Elf64_Ehdr elf_header = (Elf64_Ehdr){
      .e_ident = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3, ELFCLASS64, ELFDATA2LSB,
                  EV_CURRENT, ELFOSABI_SYSV, 0, 0, 0, 0, 0, 0, 0, 0},
      .e_type = ET_EXEC,
      .e_machine = EM_X86_64,
      .e_version = EV_CURRENT,
      .e_entry = code_vaddr,
      .e_phoff = sizeof(Elf64_Ehdr),
      .e_shoff = sizeof(Elf64_Ehdr) + 2 * sizeof(Elf64_Phdr),
      .e_flags = 0,
      .e_ehsize = sizeof(Elf64_Ehdr),
      .e_phentsize = sizeof(Elf64_Phdr),
      .e_phnum = 2,
      .e_shentsize = sizeof(Elf64_Shdr),
      .e_shnum = 4,
      .e_shstrndx = 3};

  Elf64_Phdr code_prog_header = (Elf64_Phdr){.p_type = PT_LOAD,
                                             .p_flags = PF_X | PF_R,

                                             .p_offset = 4096,
                                             .p_filesz = as->code_len,

                                             .p_vaddr = code_vaddr,
                                             .p_memsz = as->code_len,

                                             .p_align = 4096,
                                             .p_paddr = 0};
  uint64_t code_segment_end =
      code_prog_header.p_offset + code_prog_header.p_filesz;

  Elf64_Phdr data_prog_header = (Elf64_Phdr){
      .p_type = PT_LOAD,
      .p_flags = PF_R,

      .p_offset = code_segment_end + 4096 - (code_segment_end % 4096),
      .p_filesz = as->data_len,

      .p_vaddr = data_vaddr,
      .p_memsz = as->data_len,

      .p_align = 4096,
      .p_paddr = 0};
  uint64_t data_segment_end =
      data_prog_header.p_offset + data_prog_header.p_filesz;

  const char *string_table_ptr = ""\0.text\0.data\0.shstrtab\0"";
  size_t string_table_size = 23;

  Elf64_Shdr code_section_header =
      (Elf64_Shdr){.sh_name = 1,
                   .sh_type = SHT_PROGBITS,
                   .sh_flags = SHF_ALLOC | SHF_EXECINSTR,

                   .sh_addr = code_prog_header.p_vaddr,
                   .sh_offset = code_prog_header.p_offset,
                   .sh_size = code_prog_header.p_filesz,

                   .sh_link = 0,
                   .sh_info = 0,
                   .sh_addralign = code_prog_header.p_align,
                   .sh_entsize = 0};
  Elf64_Shdr data_section_header =
      (Elf64_Shdr){.sh_name = 7,
                   .sh_type = SHT_PROGBITS,
                   .sh_flags = SHF_ALLOC,

                   .sh_addr = data_prog_header.p_vaddr,
                   .sh_offset = data_prog_header.p_offset,
                   .sh_size = data_prog_header.p_filesz,

                   .sh_link = 0,
                   .sh_info = 0,
                   .sh_addralign = data_prog_header.p_align,
                   .sh_entsize = 0};
  Elf64_Shdr strtab_section_header = (Elf64_Shdr){
      .sh_name = 13,
      .sh_type = SHT_STRTAB,
      .sh_flags = SHF_STRINGS,

      .sh_addr = 0,
      .sh_offset = data_segment_end + 4096 - (data_segment_end % 4096),
      .sh_size = string_table_size,

      .sh_link = 0,
      .sh_info = 0,
      .sh_addralign = data_prog_header.p_align,
      .sh_entsize = 0};

  FILE *f = fopen(filename, ""wb"");
  if (!f) {
    perror(""as_save_elf(): fopen()"");
    abort();
  }

  fwrite(&elf_header, 1, sizeof(elf_header), f);
  fwrite(&code_prog_header, 1, sizeof(code_prog_header), f);
  fwrite(&data_prog_header, 1, sizeof(data_prog_header), f);

  fseek(f, sizeof(Elf64_Shdr), SEEK_CUR);
  fwrite(&code_section_header, 1, sizeof(code_section_header), f);
  fwrite(&data_section_header, 1, sizeof(data_section_header), f);
  fwrite(&strtab_section_header, 1, sizeof(strtab_section_header), f);

  fseek(f, code_prog_header.p_offset, SEEK_SET);
  fwrite(as->code_ptr, 1, as->code_len, f);
  fseek(f, data_prog_header.p_offset, SEEK_SET);
  fwrite(as->data_ptr, 1, as->data_len, f);
  fseek(f, strtab_section_header.sh_offset, SEEK_SET);
  fwrite(string_table_ptr, 1, string_table_size, f);

  fclose(f);
}"
solus-project-brisk-menu-6892d32/src/lib/key-binder.c	Bind a shortcut with the appropriate callback	2	"gboolean brisk_key_binder_bind(BriskKeyBinder *self, const gchar *shortcut,
                               BinderFunc func, gpointer v) {
  guint keysym;
  GdkModifierType mod;
  Display *display = NULL;
  Window id;
  KeyCode key;
  KeyBinding *bind = NULL;

  if (g_hash_table_contains(self->bindings, shortcut)) {
    return FALSE;
  }

  gtk_accelerator_parse(shortcut, &keysym, &mod);
  display = GDK_WINDOW_XDISPLAY(self->root_window);
  id = GDK_WINDOW_XID(self->root_window);

  key = XKeysymToKeycode(display, keysym);
  if (key == 0) {
    return FALSE;
  }

  bind = g_new0(KeyBinding, 1);
  *bind = (KeyBinding){.accelerator = shortcut,
                       .keycode = key,
                       .mods = mod,
                       .func = func,
                       .udata = v};

  g_hash_table_insert(self->bindings, g_strdup(shortcut), bind);

  gdk_error_trap_push();
  for (size_t i = 0; i < G_N_ELEMENTS(_modifiers); i++) {
    GdkModifierType m = _modifiers[i];
    XGrabKey(display, key, mod | m, id, TRUE, GrabModeAsync, GrabModeAsync);
  }
  gdk_flush();

  return TRUE;
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
              char __b6, char __b7, char __b8, char __b9, char __b10,
              char __b11, char __b12, char __b13, char __b14, char __b15) {
  return (__m128i)(__v16qi){__b0,  __b1,  __b2,  __b3, __b4,  __b5,
                            __b6,  __b7,  __b8,  __b9, __b10, __b11,
                            __b12, __b13, __b14, __b15};
}"
Vizaxo-dtlang-db98f59/rts/closures.c	"This is the constant function (. . x). It is a function of one argument (x), and it returns a closure where x is bound in the environment."	2	"void *a(void *x, void **env) {
  void **benv = malloc(sizeof(void *) * 1);
  benv[0] = x;
  closure *ret = malloc(sizeof(closure));

  *ret = (closure){.f = *b, .env = benv};

  return ret;
}"
darktable-org-darktable-32fab21/src/iop/invert.c	"this is the chance to update default parameters, after the full raw is loaded. this will be called to init new defaults if a new image is loaded from film strip mode."	2	"void reload_defaults(dt_iop_module_t *self) {
  dt_iop_invert_params_t tmp = (dt_iop_invert_params_t){{1.0f, 1.0f, 1.0f}};
  memcpy(self->params, &tmp, sizeof(dt_iop_invert_params_t));
  memcpy(self->default_params, &tmp, sizeof(dt_iop_invert_params_t));

  self->default_enabled = 0;
  self->hide_enable_button = 0;

  if (!self->dev)
    return;

  if (dt_image_is_monochrome(&self->dev->image_storage))
    self->hide_enable_button = 1;
  else if (self->dev->image_storage.flags & DT_IMAGE_4BAYER && self->gui_data) {
    dt_iop_invert_gui_data_t *g = self->gui_data;

    const char *camera = self->dev->image_storage.camera_makermodel;

    if (!dt_colorspaces_conversion_matrices_rgb(camera, g->RGB_to_CAM,
                                                g->CAM_to_RGB, NULL)) {
      fprintf(stderr, ""[invert] `%s' color matrix not found for 4bayer image\n"",
              camera);
      dt_control_log(_(""`%s' color matrix not found for 4bayer image""), camera);
    }
  }
}"
JohnCoatesOSS-Limitless-7246efd/External/oclint/lib/clang/5.0.0/include/emmintrin.h	This intrinsic is a utility function and does not correspond to a specific instruction.	4	"_mm_set1_epi32(int __i) { return (__m128i)(__v4si){__i, __i, __i, __i}; }"
boazsegev-iodine-b6bdf50/ext/iodine/fiobj_data.c	The C string object will be invalidate the next time a function call to the IO object is made.	2	"fio_str_info_s fiobj_data_read(FIOBJ io, intptr_t length) {
  if (!io || !FIOBJ_TYPE_IS(io, FIOBJ_T_DATA)) {
    errno = EFAULT;
    return (fio_str_info_s){.data = NULL, .len = 0};
  }
  errno = 0;
  switch (obj2io(io)->fd) {
  case -1:
    return fiobj_data_read_str(io, length);
    break;
  case -2:
    return fiobj_data_read_slice(io, length);
    break;
  default:
    return fiobj_data_read_file(io, length);
  }
}"
darktable-org-darktable-32fab21/src/iop/borders.c	"this initializes static, hardcoded presets for this module and is called only once per run of dt."	2	"void init_presets(dt_iop_module_so_t *self) {
  dt_iop_borders_params_t p = (dt_iop_borders_params_t){{1.0f, 1.0f, 1.0f},
                                                        3.0f / 2.0f,
                                                        ""3:2"",
                                                        0,
                                                        0.1f,
                                                        0.5f,
                                                        ""1/2"",
                                                        0.5f,
                                                        ""1/2"",
                                                        0.0f,
                                                        0.5f,
                                                        {0.0f, 0.0f, 0.0f},
                                                        TRUE};
  dt_gui_presets_add_generic(_(""15:10 postcard white""), self->op,
                             self->version(), &p, sizeof(p), 1);
  p.color[0] = p.color[1] = p.color[2] = 0.0f;
  p.frame_color[0] = p.frame_color[1] = p.frame_color[2] = 1.0f;
  dt_gui_presets_add_generic(_(""15:10 postcard black""), self->op,
                             self->version(), &p, sizeof(p), 1);
}"
Deadlocked007-EventUp-a067de4/FirebaseFunctions/functions/node_modules/firebase-admin/node_modules/grpc/src/core/ext/filters/client_channel/subchannel.c	create a subchannel given a connector	2	"grpc_subchannel *grpc_subchannel_create(grpc_exec_ctx *exec_ctx,
                                        grpc_connector *connector,
                                        const grpc_subchannel_args *args) {
  grpc_subchannel_key *key = grpc_subchannel_key_create(args);
  grpc_subchannel *c = grpc_subchannel_index_find(exec_ctx, key);
  if (c) {
    grpc_subchannel_key_destroy(exec_ctx, key);
    return c;
  }

  c = gpr_zalloc(sizeof(*c));
  c->key = key;
  gpr_atm_no_barrier_store(&c->ref_pair, 1 << INTERNAL_REF_BITS);
  c->connector = connector;
  grpc_connector_ref(c->connector);
  c->num_filters = args->filter_count;
  if (c->num_filters > 0) {
    c->filters = gpr_malloc(sizeof(grpc_channel_filter *) * c->num_filters);
    memcpy((void *)c->filters, args->filters,
           sizeof(grpc_channel_filter *) * c->num_filters);
  } else {
    c->filters = NULL;
  }
  c->pollset_set = grpc_pollset_set_create();
  grpc_resolved_address *addr = gpr_malloc(sizeof(*addr));
  grpc_get_subchannel_address_arg(exec_ctx, args->args, addr);
  grpc_resolved_address *new_address = NULL;
  grpc_channel_args *new_args = NULL;
  if (grpc_proxy_mappers_map_address(exec_ctx, addr, args->args, &new_address,
                                     &new_args)) {
    GPR_ASSERT(new_address != NULL);
    gpr_free(addr);
    addr = new_address;
  }
  static const char *keys_to_remove[] = {GRPC_ARG_SUBCHANNEL_ADDRESS};
  grpc_arg new_arg = grpc_create_subchannel_address_arg(addr);
  gpr_free(addr);
  c->args = grpc_channel_args_copy_and_add_and_remove(
      new_args != NULL ? new_args : args->args, keys_to_remove,
      GPR_ARRAY_SIZE(keys_to_remove), &new_arg, 1);
  gpr_free(new_arg.value.string);
  if (new_args != NULL)
    grpc_channel_args_destroy(exec_ctx, new_args);
  c->root_external_state_watcher.next = c->root_external_state_watcher.prev =
      &c->root_external_state_watcher;
  GRPC_CLOSURE_INIT(&c->connected, subchannel_connected, c,
                    grpc_schedule_on_exec_ctx);
  grpc_connectivity_state_init(&c->state_tracker, GRPC_CHANNEL_IDLE,
                               ""subchannel"");
  int initial_backoff_ms =
      GRPC_SUBCHANNEL_INITIAL_CONNECT_BACKOFF_SECONDS * 1000;
  int min_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MIN_BACKOFF_SECONDS * 1000;
  int max_backoff_ms = GRPC_SUBCHANNEL_RECONNECT_MAX_BACKOFF_SECONDS * 1000;
  bool fixed_reconnect_backoff = false;
  if (c->args) {
    for (size_t i = 0; i < c->args->num_args; i++) {
      if (0 == strcmp(c->args->args[i].key,
                      ""grpc.testing.fixed_reconnect_backoff_ms"")) {
        fixed_reconnect_backoff = true;
        initial_backoff_ms = min_backoff_ms = max_backoff_ms =
            grpc_channel_arg_get_integer(
                &c->args->args[i],
                (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MIN_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        min_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){min_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_MAX_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        max_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){max_backoff_ms, 100, INT_MAX});
      } else if (0 == strcmp(c->args->args[i].key,
                             GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS)) {
        fixed_reconnect_backoff = false;
        initial_backoff_ms = grpc_channel_arg_get_integer(
            &c->args->args[i],
            (grpc_integer_options){initial_backoff_ms, 100, INT_MAX});
      }
    }
  }
  gpr_backoff_init(
      &c->backoff_state, initial_backoff_ms,
      fixed_reconnect_backoff ? 1.0
                              : GRPC_SUBCHANNEL_RECONNECT_BACKOFF_MULTIPLIER,
      fixed_reconnect_backoff ? 0.0 : GRPC_SUBCHANNEL_RECONNECT_JITTER,
      min_backoff_ms, max_backoff_ms);
  gpr_mu_init(&c->mu);

  return grpc_subchannel_index_register(exec_ctx, key, c);
}"
salsaman-LiVES-8bbb226/lives-plugins/plugins/playback/video/libav_stream.c	ready the screen to play (optional)	2	"boolean init_screen(int width, int height, boolean fullscreen,
                    uint64_t window_id, int argc, char **argv) {
  AVCodec *codec, *acodec;

  const char *fmtstring;

  char uri[PATH_MAX];

  int vcodec_id;
  int acodec_id;
  int ret;

  fprintf(stderr, ""init_screen %d x %d %d\n"", width, height, argc);

  ostv.frame = osta.frame = NULL;
  vStream = aStream = NULL;

  ostv.sws_ctx = NULL;
  osta.swr_ctx = NULL;

  if (mypalette == WEED_PALETTE_END) {
    fprintf(stderr, ""libav stream plugin error: No palette was set !\n"");
    return FALSE;
  }

  fmtstring = ""flv"";
  vcodec_id = AV_CODEC_ID_H264;

  acodec_id = AV_CODEC_ID_MP3;
  maxvbitrate = 3000000;

  if (argc > 0) {
    switch (atoi(argv[0])) {
    case 0:
      fmtstring = ""flv"";
      vcodec_id = AV_CODEC_ID_H264;
      acodec_id = AV_CODEC_ID_MP3;
      break;
    case 1:
      fmtstring = ""ogg"";
      vcodec_id = AV_CODEC_ID_THEORA;
      acodec_id = AV_CODEC_ID_VORBIS;
      break;
    default:
      return FALSE;
    }

    maxvbitrate = atoi(argv[1]);

    switch (intent) {
    case 0:
      stream_encode = TRUE;
      snprintf(uri, PATH_MAX, ""udp://%s.%s.%s.%s:%s"", argv[5], argv[6], argv[7],
               argv[8], argv[9]);
      break;
    case 1:
      stream_encode = FALSE;
      snprintf(uri, PATH_MAX, ""%s"", argv[5]);
      break;
    default:
      break;
    }
  }

  if (strlen(uri) == 0) {
    fprintf(stderr, ""No output location set\n"");
    return FALSE;
  }

  ret = avformat_alloc_output_context2(&fmtctx, NULL, fmtstring, uri);
  if (ret < 0) {
    fprintf(stderr, ""Could not open fmt '%s': %s\n"", fmtstring,
            av_err2str(ret));
  }

  if (!fmtctx) {
    printf(
        ""Could not deduce output format from file extension %s: using flv.\n"",
        fmtstring);
    avformat_alloc_output_context2(&fmtctx, NULL, ""flv"", uri);
  }
  if (!fmtctx)
    return FALSE;

  add_stream(&ostv, fmtctx, &codec, vcodec_id);
  vStream = ostv.st;
  ostv.codec = codec;

  ostv.enc = encctx = vStream->codec;

#ifdef API_3_1

  ret = avcodec_parameters_from_context(vStream->codecpar, encctx);
  if (ret < 0) {
    fprintf(stderr, ""avcodec_decoder: avparms from context failed\n"");
    return FALSE;
  }
#endif

  vStream->time_base = (AVRational){1, target_fps};
  vStream->codec->time_base = vStream->time_base;

  vStream->codec->width = width;
  vStream->codec->height = height;
  vStream->codec->pix_fmt = avpalette;

  vStream->codec->bit_rate = maxvbitrate;

  av_opt_set(encctx->priv_data, ""preset"", ""ultrafast"", 0);
  av_opt_set(encctx->priv_data, ""crf"", ""0"", 0);
  av_opt_set(encctx->priv_data, ""qscale"", ""1"", 0);

  vStream->codec->gop_size = 10;

  if (vcodec_id == AV_CODEC_ID_MPEG2VIDEO) {

    vStream->codec->max_b_frames = 2;
  }
  if (vcodec_id == AV_CODEC_ID_MPEG1VIDEO) {

    vStream->codec->mb_decision = 2;
  }

  fprintf(stderr, ""init_screen2 %d x %d %d\n"", width, height, argc);

  if (avcodec_open2(encctx, codec, NULL) < 0) {
    fprintf(stderr, ""Could not open codec\n"");
    return FALSE;
  }

  if (in_sample_rate > 0) {
    add_stream(&osta, fmtctx, &acodec, acodec_id);
    osta.codec = acodec;
    aStream = osta.st;
    osta.enc = aencctx = aStream->codec;

#ifdef API_3_1
    ret = avcodec_parameters_from_context(aStream->codecpar, aencctx);
    if (ret < 0) {
      fprintf(stderr, ""avcodec_decoder: avparms from context failed\n"");
      return FALSE;
    }
#endif

    out_nchans = 2;
    out_sample_rate = 44100;
    maxabitrate = 320000;

    if (argc > 0) {
      out_nchans = atoi(argv[2]) + 1;
      switch (atoi(argv[3])) {
      case 0:
        out_sample_rate = 22050;
        break;
      case 1:
        out_sample_rate = 44100;
        break;
      case 2:
        out_sample_rate = 48000;
        break;
      default:
        break;
      }
      maxabitrate = atoi(argv[4]);
    }
    fprintf(stderr, ""added audio stream\n"");
    open_audio();
  }

  av_dump_format(fmtctx, 0, uri, 1);

  if (!(fmtctx->oformat->flags & AVFMT_NOFILE)) {
    fprintf(stderr, ""opening file %s\n"", uri);
    ret = avio_open(&fmtctx->pb, uri, AVIO_FLAG_WRITE);
    if (ret < 0) {
      fprintf(stderr, ""Could not open '%s': %s\n"", uri, av_err2str(ret));
      return FALSE;
    }

    ret = avformat_write_header(fmtctx, NULL);
    if (ret < 0) {
      fprintf(stderr, ""Error occurred when writing header: %s\n"",
              av_err2str(ret));
      return FALSE;
    }
  }

  ostv.frame = alloc_picture(avpalette, width, height);
  if (ostv.frame == NULL) {
    fprintf(stderr, ""Could not allocate video frame\n"");
    return FALSE;
  }

  ostv.next_pts = osta.next_pts = 0;
  return TRUE;
}"
Meulengracht-MollenOS-e48f4ab/librt/include/emmintrin.h	Loads a 64-bit integer value to the low element of a 128-bit integer vector and clears the upper element.	2	"_mm_loadu_si64(void const *__a) {
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((struct __loadu_si64 *)__a)->__v;
  return __extension__(__m128i)(__v2di){__u, 0LL};
}"
DevynCJohnson-Pybooster-ab88c0c/include/MACROS_MATH.h	Return the negative quaternion	2	"LIB_FUNC MATH_FUNC quaternion qneg(const quaternion qnum) {
  return (quaternion){(-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k)};
}"
artclarke-xuggle-xuggler-993c84e/captive/ffmpeg/csrc/libavformat/utils.c	"Parse a packet, add all split parts to parse_queue"	2	"static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index) {
  AVPacket out_pkt = {0}, flush_pkt = {0};
  AVStream *st = s->streams[stream_index];
  uint8_t *data = pkt ? pkt->data : NULL;
  int size = pkt ? pkt->size : 0;
  int ret = 0, got_output = 0;

  if (!pkt) {
    av_init_packet(&flush_pkt);
    pkt = &flush_pkt;
    got_output = 1;
  } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

    compute_pkt_fields(s, st, st->parser, pkt);
  }

  while (size > 0 || (pkt == &flush_pkt && got_output)) {
    int len;

    av_init_packet(&out_pkt);
    len = av_parser_parse2(st->parser, st->codec, &out_pkt.data, &out_pkt.size,
                           data, size, pkt->pts, pkt->dts, pkt->pos);

    pkt->pts = pkt->dts = AV_NOPTS_VALUE;

    data += len;
    size -= len;

    got_output = !!out_pkt.size;

    if (!out_pkt.size)
      continue;

    out_pkt.duration = 0;
    if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
      if (st->codec->sample_rate > 0) {
        out_pkt.duration = av_rescale_q_rnd(
            st->parser->duration, (AVRational){1, st->codec->sample_rate},
            st->time_base, AV_ROUND_DOWN);
      }
    } else if (st->codec->time_base.num != 0 && st->codec->time_base.den != 0) {
      out_pkt.duration =
          av_rescale_q_rnd(st->parser->duration, st->codec->time_base,
                           st->time_base, AV_ROUND_DOWN);
    }

    out_pkt.stream_index = st->index;
    out_pkt.pts = st->parser->pts;
    out_pkt.dts = st->parser->dts;
    out_pkt.pos = st->parser->pos;

    if (st->parser->key_frame == 1 ||
        (st->parser->key_frame == -1 &&
         st->parser->pict_type == AV_PICTURE_TYPE_I))
      out_pkt.flags |= AV_PKT_FLAG_KEY;

    compute_pkt_fields(s, st, st->parser, &out_pkt);

    if ((s->iformat->flags & AVFMT_GENERIC_INDEX) &&
        out_pkt.flags & AV_PKT_FLAG_KEY) {
      int64_t pos = (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES)
                        ? out_pkt.pos
                        : st->parser->frame_offset;
      ff_reduce_index(s, st->index);
      av_add_index_entry(st, pos, out_pkt.dts, 0, 0, AVINDEX_KEYFRAME);
    }

    if (out_pkt.data == pkt->data && out_pkt.size == pkt->size) {
      out_pkt.destruct = pkt->destruct;
      pkt->destruct = NULL;
    }
    if ((ret = av_dup_packet(&out_pkt)) < 0)
      goto fail;

    if (!add_to_pktbuf(&s->parse_queue, &out_pkt, &s->parse_queue_end)) {
      av_free_packet(&out_pkt);
      ret = AVERROR(ENOMEM);
      goto fail;
    }
  }

  if (pkt == &flush_pkt) {
    av_parser_close(st->parser);
    st->parser = NULL;
  }

fail:
  av_free_packet(pkt);
  return ret;
}"
256dpi-lwmqtt-d9dbe5e/src/string.c	Returns a string object for the passed C string.	2	"lwmqtt_string_t lwmqtt_string(const char *str) {

  if (str == NULL) {
    return (lwmqtt_string_t){0, NULL};
  }

  uint16_t len = (uint16_t)strlen(str);

  if (len == 0) {
    return (lwmqtt_string_t){0, NULL};
  }

  return (lwmqtt_string_t){len, (char *)str};
}"
