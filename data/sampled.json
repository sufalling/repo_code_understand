[{"comment_all": {"comment": "/* NB: limited line length */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 166}, "comment_text": "/* NB: limited line length */", "comment_tokens": ["NB", ":", "limited", "line", "length"], "ccode": ["\n", "void\n", "do_file(fname)\n", "char * fname;\n", "{\n", "   filename = fname;\n", "   prline = lineno = 0;\n", "   fd = fopen(fname, \"r\");\n", "   if( fd == 0 )\n", "      fatal(\"Cannot open file\");\n", "\n", "   if( cuttype == 1 ) \n", "      printf(\"#line 1 \\\"%s\\\"\\n\", filename);\n", "\n", "   /* NB: limited line length */\n", "   while( fgets(linebuf, sizeof(linebuf), fd) != 0 )\n", "   {\n", "      int f = 1;\n", "      char * p = linebuf;\n", "      lineno++;\n", "      while(isspace(*p)) p++;\n", "      if( *p == '#' )\n", "\t f = do_hashcom();\n", "      if(f)\n", "      {\n", "         if( keeptext )\n", "         {\n", "\t    if( cuttype == 1 ) set_line(lineno);\n", "\t    printf(\"%s\", linebuf);\n", "         }\n", "         else\n", "\t {\n", "\t    if( cuttype == 0 ) printf(\"\\n\");\n", "\t    if( cuttype == 2 ) printf(\"%s %s\", commentstr, linebuf);\n", "         }\n", "      }\n", "   }\n", "   fclose(fd);\n", "   if( iflevel != 0 ) fatal(\"Not enough endif's\");\n", "}\n"], "project": "bin86", "file": "ifdef.pkl", "function": "do_file"}, {"comment_all": {"comment": "/* TODO: add success details as an option */", "depth": 1, "reading_ease": 64.37, "reading_grade": 6.0, "line": 58}, "comment_text": "/* TODO: add success details as an option */", "comment_tokens": ["TODO", ":", "add", "success", "details", "as", "an", "option"], "ccode": ["\n", "\n", "void\n", "subunit_test_pass(char const * const name)\n", "{\n", "  /* TODO: add success details as an option */\n", "  subunit_send_event(\"success\", name, NULL);\n", "}\n"], "project": "libcppunit-subunit-dev", "file": "child.pkl", "function": "subunit_test_pass"}, {"comment_all": {"comment": "/*\n * delete early clobber liveness. Only interesting on regs.\n */", "depth": 0, "reading_ease": 42.04, "reading_grade": 8.4, "line": 959}, "comment_text": "/*\n * delete early clobber liveness. Only interesting on regs.\n */", "comment_tokens": ["delete", "early", "clobber", "liveness", ".", "Only", "interesting", "on", "regs", "."], "ccode": ["\n", "/*\n", " * delete early clobber liveness. Only interesting on regs.\n", " */\n", "static void\n", "delcl(NODE *p)\n", "{\n", "\tint cw;\n", "\n", "\tif (p->n_op == ICON && p->n_type == STRTY)\n", "\t\treturn;\n", "\tcw = xasmcode(p->n_name);\n", "\tif ((cw & XASMCONSTR) == 0 || !XASMISOUT(cw))\n", "\t\treturn;\n", "\tif (XASMVAL(cw) != 'r')\n", "\t\treturn;\n", "\tLIVEDEL(regno(p->n_left));\n", "}\n"], "project": "pcc", "file": "regs.pkl", "function": "delcl"}, {"comment_all": {"comment": "/* This test is just to be used with valgrind */", "depth": 0, "reading_ease": 104.64, "reading_grade": 0.9, "line": 5}, "comment_text": "/* This test is just to be used with valgrind */", "comment_tokens": ["This", "test", "is", "just", "to", "be", "used", "with", "valgrind"], "ccode": ["#include <glib.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include \"test.h\"\n", "\n", "/* This test is just to be used with valgrind */\n", "static RESULT\n", "test_strfreev (void)\n", "{\n", "\tgchar **array = g_new (gchar *, 4);\n", "\tarray [0] = g_strdup (\"one\");\n", "\tarray [1] = g_strdup (\"two\");\n", "\tarray [2] = g_strdup (\"three\");\n", "\tarray [3] = NULL;\n", "\t\n", "\tg_strfreev (array);\n", "\tg_strfreev (NULL);\n", "\n", "\treturn OK;\n", "}\n"], "project": "libmono-relaxng4.0-cil", "file": "string-util.pkl", "function": "test_strfreev"}, {"comment_all": {"comment": "/* No tag for this data, probably a temporary data not to be communicated */", "depth": 2, "reading_ease": 41.36, "reading_grade": 10.7, "line": 81}, "comment_text": "/* No tag for this data, probably a temporary data not to be communicated */", "comment_tokens": ["No", "tag", "for", "this", "data", ",", "probably", "a", "temporary", "data", "not", "to", "be", "communicated"], "ccode": ["\n", "void _starpu_mpi_tag_data_register(starpu_data_handle_t handle, starpu_mpi_tag_t data_tag)\n", "{\n", "\tif (data_tag == -1)\n", "\t{\n", "\t\t/* No tag for this data, probably a temporary data not to be communicated */\n", "\t\treturn;\n", "\t}\n", "\n", "\tstruct handle_tag_entry *entry;\n", "\t_STARPU_MPI_MALLOC(entry, sizeof(*entry));\n", "\n", "\tSTARPU_ASSERT_MSG(!(_starpu_mpi_tag_get_data_handle_from_tag(data_tag)),\n", "\t\t\t  \"There is already a data handle %p registered with the tag %ld\\n\", _starpu_mpi_tag_get_data_handle_from_tag(data_tag), data_tag);\n", "\n", "\t_STARPU_MPI_DEBUG(42, \"Adding handle %p with tag %\"PRIi64\" in hashtable\\n\", handle, data_tag);\n", "\n", "\tentry->handle = handle;\n", "\tentry->data_tag = data_tag;\n", "\n", "\t_starpu_spin_lock(&registered_tag_handles_lock);\n", "#ifndef STARPU_NO_ASSERT\n", "\tstruct handle_tag_entry *old;\n", "\tHASH_FIND(hh, registered_tag_handles, &data_tag, sizeof(entry->data_tag), old);\n", "\tSTARPU_ASSERT_MSG(!old, \"tag %\"PRIi64\" being registered for data %p, but is already used by data %p!\\n\", data_tag, handle, old?old->handle:NULL);\n", "#endif\n", "\tHASH_ADD(hh, registered_tag_handles, data_tag, sizeof(entry->data_tag), entry);\n", "\t_starpu_spin_unlock(&registered_tag_handles_lock);\n", "}\n"], "project": "starpu-examples", "file": "starpu_mpi_tag.pkl", "function": "_starpu_mpi_tag_data_register"}, {"comment_all": {"comment": "/*\nCopyright (c) 2007-2010 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/", "depth": 0, "reading_ease": 14.64, "reading_grade": 25.1, "line": 0}, "comment_text": "/*\nCopyright (c) 2007-2010 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/", "comment_tokens": ["Copyright", "(", "c", ")", "2007-2010", "by", "Juliusz", "Chroboczek", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/*\n", "Copyright (c) 2007-2010 by Juliusz Chroboczek\n", "\n", "Permission is hereby granted, free of charge, to any person obtaining a copy\n", "of this software and associated documentation files (the \"Software\"), to deal\n", "in the Software without restriction, including without limitation the rights\n", "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n", "copies of the Software, and to permit persons to whom the Software is\n", "furnished to do so, subject to the following conditions:\n", "\n", "The above copyright notice and this permission notice shall be included in\n", "all copies or substantial portions of the Software.\n", "\n", "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n", "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n", "THE SOFTWARE.\n", "*/\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <netinet/in.h>\n", "#include <arpa/inet.h>\n", "#include <sys/socket.h>\n", "\n", "#include \"prefix.h\"\n", "\n", "void\n", "free_prefix_list(struct prefix_list *l)\n", "{\n", "    free(l);\n", "}\n"], "project": "ahcpd", "file": "prefix.pkl", "function": "free_prefix_list"}, {"comment_all": {"comment": "/* Do not pass unneeded T_EOL to the parser. */", "depth": 3, "reading_ease": 80.28, "reading_grade": 4.1, "line": 4209}, "comment_text": "/* Do not pass unneeded T_EOL to the parser. */", "comment_tokens": ["Do", "not", "pass", "unneeded", "T_EOL", "to", "the", "parser", "."], "ccode": ["\n", "#define YYTABLES_NAME \"yytables\"\n", "\n", "/* second stage lexer */\n", "int yylex(void)\n", "{\n", "\tint token;\n", "\n", "repeat:\n", "\ttoken = yylex1();\n", "\n", "\tif (prev_token == T_EOL || prev_token == T_HELPTEXT) {\n", "\t\tif (token == T_EOL) {\n", "\t\t\t/* Do not pass unneeded T_EOL to the parser. */\n", "\t\t\tgoto repeat;\n", "\t\t} else {\n", "\t\t\t/*\n", "\t\t\t * For the parser, update file/lineno at the first token\n", "\t\t\t * of each statement. Generally, \\n is a statement\n", "\t\t\t * terminator in Kconfig, but it is not always true\n", "\t\t\t * because \\n could be escaped by a backslash.\n", "\t\t\t */\n", "\t\t\tcurrent_pos.file = current_file;\n", "\t\t\tcurrent_pos.lineno = yylineno;\n", "\t\t}\n", "\t}\n", "\n", "\tif (prev_prev_token == T_EOL && prev_token == T_WORD &&\n", "\t    (token == T_EQUAL || token == T_COLON_EQUAL || token == T_PLUS_EQUAL))\n", "\t\tBEGIN(ASSIGN_VAL);\n", "\n", "\tprev_prev_token = prev_token;\n", "\tprev_token = token;\n", "\n", "\treturn token;\n", "}\n"], "project": "linux-buildinfo-5.8.0-55-lowlatency", "file": "lexer.lex.pkl", "function": "yylex"}, {"comment_all": {"comment": "/* check if memory is accessible */", "depth": 3, "reading_ease": 32.56, "reading_grade": 10.0, "line": 125}, "comment_text": "/* check if memory is accessible */", "comment_tokens": ["check", "if", "memory", "is", "accessible"], "ccode": ["#endif\n", "\n", "int\n", "main(int argc, char * * argv)\n", "{\n", "  int  count;\n", "  int  duration = TEST_DURATION;\n", "\n", "#ifdef DUMA_EXPLICIT_INIT\n", "  duma_init();\n", "#endif\n", "\n", "  if ( argc >= 2 )\n", "    duration = atoi(argv[1]);\n", "\n", "  for ( count = 0; count < POOL_SIZE; count++ )\n", "  {\n", "    pool[count].addr = (void*)0;\n", "    pool[count].size = (size_t)0;\n", "  }\n", "\n", "  for ( count = 0; count < duration; count++ )\n", "  {\n", "    int                 pool_idx;\n", "    struct POOL_ELEM  * element;\n", "    size_t              size;\n", "\n", "    pool_idx =(int)(drand48() * POOL_SIZE);\n", "    if (pool_idx >=0 && pool_idx<POOL_SIZE)\n", "    {\n", "      element  = &pool[pool_idx];\n", "      size     = (size_t)(drand48() * (LARGEST_BUFFER + 1));\n", "\n", "      if ( element->addr )\n", "      {\n", "        /* check if memory is accessible */\n", "        memset( element->addr, 0, element->size );\n", "        free( element->addr );\n", "        element->addr = (void*)0;\n", "      }\n", "\n", "      if ( size > 0 )\n", "      {\n", "#ifdef ALIGNMENT\n", "        element->addr = memalign(ALIGNMENT,size);\n", "#else\n", "        element->addr = malloc(size);\n", "#endif\n", "        element->size = size;\n", "        /* really use it, so that the system has to use real memory */\n", "        memset( element->addr, -1, size );\n", "      }\n", "    }\n", "  }\n", "\n", "#if 1\n", "  /* don't forget to free the allocated memory, else the\n", "     confidence test won't pass - without having set\n", "     \"EF_NO_LEAKDETECTION\" preprocessor definition\n", "  */\n", "  for ( count = 0; count < POOL_SIZE; count++ )\n", "  {\n", "    if ( pool[count].addr )\n", "    {\n", "      /* check if memory is accessible */\n", "      memset( pool[count].addr, 0, pool[count].size );\n", "      free( pool[count].addr );\n", "    }\n", "  }\n", "#endif\n", "\n", "  return 0;\n", "}\n"], "project": "duma", "file": "tstheap.pkl", "function": "main"}, {"comment_all": {"comment": "/* XXX This might have to return NO_DATA sometimes. */", "depth": 1, "reading_ease": 71.82, "reading_grade": 5.2, "line": 378}, "comment_text": "/* XXX This might have to return NO_DATA sometimes. */", "comment_tokens": ["XXX", "This", "might", "have", "to", "return", "NO_DATA", "sometimes", "."], "ccode": ["\n", "SPF_dns_server_t *\n", "SPF_dns_zone_new(SPF_dns_server_t *layer_below,\n", "\t\t\t\tconst char *name, int debug)\n", "{\n", "\tSPF_dns_server_t\t\t*spf_dns_server;\n", "    SPF_dns_zone_config_t\t*spfhook;\n", "\n", "    spf_dns_server = malloc(sizeof(SPF_dns_server_t));\n", "    if (spf_dns_server == NULL)\n", "\t\treturn NULL;\n", "\tmemset(spf_dns_server, 0, sizeof(SPF_dns_server_t));\n", "\n", "    spf_dns_server->hook = malloc(sizeof(SPF_dns_zone_config_t));\n", "    if (spf_dns_server->hook == NULL) {\n", "\t\tfree(spf_dns_server);\n", "\t\treturn NULL;\n", "    }\n", "\tmemset(spf_dns_server->hook, 0, sizeof(SPF_dns_zone_config_t));\n", "\n", "    if (name ==  NULL)\n", "\t\tname = \"zone\";\n", "\n", "    spf_dns_server->destroy      = SPF_dns_zone_free;\n", "    spf_dns_server->lookup       = SPF_dns_zone_lookup;\n", "    spf_dns_server->get_spf      = NULL;\n", "    spf_dns_server->get_exp      = NULL;\n", "    spf_dns_server->add_cache    = NULL;\n", "    spf_dns_server->layer_below  = layer_below;\n", "\tspf_dns_server->name         = name;\n", "\tspf_dns_server->debug        = debug;\n", "\n", "    spfhook = SPF_voidp2spfhook(spf_dns_server->hook);\n", "\n", "    spfhook->zone_buf_len = 32;\n", "    spfhook->num_zone = 0;\n", "    spfhook->zone = calloc(spfhook->zone_buf_len, sizeof(*spfhook->zone));\n", "\n", "    if (spfhook->zone == NULL) {\n", "\t\tfree(spfhook);\n", "\t\tfree(spf_dns_server);\n", "\t\treturn NULL;\n", "    }\n", "\n", "\t/* XXX This might have to return NO_DATA sometimes. */\n", "    spfhook->nxdomain = SPF_dns_rr_new_init(spf_dns_server,\n", "\t\t\t\t\t\"\", ns_t_any, 24 * 60 * 60, HOST_NOT_FOUND);\n", "\tif (spfhook->nxdomain == NULL) {\n", "\t\tfree(spfhook->zone);\n", "\t\tfree(spfhook);\n", "\t\tfree(spf_dns_server);\n", "\t\treturn NULL;\n", "\t}\n", "\n", "    return spf_dns_server;\n", "}\n"], "project": "libspf2-2", "file": "spf_dns_zone.pkl", "function": "SPF_dns_zone_new"}, {"comment_all": {"comment": "/* STRING_PRINT(\"    -R   --recursive     Recursive directory search\\n\"); */", "depth": 1, "reading_ease": 6.17, "reading_grade": 13.9, "line": 357}, "comment_text": "/* STRING_PRINT(\"    -R   --recursive     Recursive directory search\\n\"); */", "comment_tokens": ["STRING_PRINT", "(", "``", "-R", "--", "recursive", "Recursive", "directory", "search\\n", "''", ")", ";"], "ccode": ["\n", "\n", "\n", "void PRINT_HELP(void){\n", "STRING_PRINT(\"[HELP]\\n\");\n", "STRING_PRINT(\"USAGE: aaphoto [options] [source files]\\n\");\n", "STRING_PRINT(\"\\n\");\n", "STRING_PRINT(\"The following image types are supported (thanks to JPEG and PNG):\\n\");\n", "STRING_PRINT(\"bmp, jpg, png\\n\");\n", "STRING_PRINT(\"\\n\");\n", "STRING_PRINT(\"Quality settings can be applied only to jpg format\\n\");\n", "STRING_PRINT(\"\\n\");\n", "STRING_PRINT(\"The following options are supported:\\n\");\n", "STRING_PRINT(\"    -h   --help          Print this help\\n\");\n", "STRING_PRINT(\"    -v   --version       Print version information\\n\");\n", "STRING_PRINT(\"    -a   --autoadjust    Auto adjust the colors of the image\\n\");\n", "STRING_PRINT(\"    -o   --output        Set output directory\\n\");\n", "STRING_PRINT(\"         --overwrite     Overwrite mode, the original source file is replaced\\n\");\n", "STRING_PRINT(\"         --jpg           JPEG image output\\n\");\n", "STRING_PRINT(\"         --png           PNG image output with alpha channel support\\n\");\n", "STRING_PRINT(\"         --bmp           BMP image output\\n\");\n", "STRING_PRINT(\"    -r   --resize        Resize image taking the longer side in % or pixels\\n\");\n", "STRING_PRINT(\"         --rotate90      Rotate image with 90 degrees clockwise\\n\");\n", "STRING_PRINT(\"         --rotate180     Rotate image with 180 degrees\\n\");\n", "STRING_PRINT(\"         --rotate270     Rotate image with 90 degrees counter-clockwise\\n\");\n", "STRING_PRINT(\"         --flipx         Mirror image horizontally\\n\");\n", "STRING_PRINT(\"         --flipy         Mirror image vertically\\n\");\n", "STRING_PRINT(\"         --noexif        Save image without EXIF info\\n\");\n", "STRING_PRINT(\"    -q   --quality       Set image quality from 1 to 100\\n\");\n", "STRING_PRINT(\"    -t   --threads       Set number of working threads (default: autodetect)\\n\");\n", "STRING_PRINT(\"    -s   --silent        Silent mode, no information printed during operation\\n\");\n", "STRING_PRINT(\"         --quiet         ...same as above\\n\");\n", "STRING_PRINT(\"    -V   --verbose       Print verbose information about processing\\n\");\n", "/* STRING_PRINT(\"    -R   --recursive     Recursive directory search\\n\"); */\n", "STRING_PRINT(\"         --test          Print detailed test information into image\\n\");\n", "STRING_PRINT(\"\\n\");\n", "STRING_PRINT(\"EXAMPLES:\\n\");\n", "STRING_PRINT(\"     aaphoto image.jpg\\n\");\n", "STRING_PRINT(\"     aaphoto -a -r600 -q85 *.jpg\\n\");\n", "STRING_PRINT(\"     aaphoto mydir\\n\");\n", "STRING_PRINT(\"     aaphoto -V --resize70% image.png\\n\");\n", "STRING_PRINT(\"     aaphoto --quality60 image.jpg\\n\");\n", "STRING_PRINT(\"\\n\");\n", "STRING_PRINT(\"REMARKS:\\n\");\n", "STRING_PRINT(\"- auto adjust parameter is set by default without any other parameters\\n\");\n", "STRING_PRINT(\"- _new file name will be generated without --overwrite parameter\\n\");\n", "STRING_PRINT(\"- every file is processed on directory input but not recursively\\n\");\n", "STRING_PRINT(\"- order of parameters does not matter\\n\");\n", "STRING_PRINT(\"- resize value can be set in percentage too\\n\");\n", "STRING_PRINT(\"- resize parameter should be less or equal than original\\n\");\n", "STRING_PRINT(\"- resize uses the best (and slowest) resampling method\\n\");\n", "STRING_PRINT(\"- default jpeg compression quality is 95%\\n\");\n", "STRING_PRINT(\"- EXIF information is restored in jpeg images by default\\n\");\n", "STRING_PRINT(\"- number of threads is set to the number of online processors by default\\n\");\n", "STRING_PRINT(\"\\n\");\n", "}\n"], "project": "aaphoto", "file": "aaphoto.pkl", "function": "PRINT_HELP"}, {"comment_all": {"comment": "/* convert an internet sockaddr into a hostname or ip number */", "depth": 0, "reading_ease": 44.41, "reading_grade": 9.6, "line": 99}, "comment_text": "/* convert an internet sockaddr into a hostname or ip number */", "comment_tokens": ["convert", "an", "internet", "sockaddr", "into", "a", "hostname", "or", "ip", "number"], "ccode": ["\n", "\n", "/* convert an internet sockaddr into a hostname or ip number */\n", "char *addrname(struct sockaddr_in a) {\n", "  struct hostent *he;\n", "  he = gethostbyaddr((char *)&a.sin_addr, sizeof(a.sin_addr), AF_INET);\n", "  if (he) return he->h_name; else return (inet_ntoa(a.sin_addr));\n", "}\n"], "project": "empire-hub", "file": "hub.pkl", "function": "addrname"}, {"comment_all": {"comment": "/*\n\t * set Node and session id for this request\n\t */", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 71}, "comment_text": "/*\n\t * set Node and session id for this request\n\t */", "comment_tokens": ["set", "Node", "and", "session", "id", "for", "this", "request"], "ccode": ["/*****************************************************************************\\\n", " *  submit.c - submit a job with supplied contraints\n", " *****************************************************************************\n", " *  Copyright (C) 2002 The Regents of the University of California.\n", " *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).\n", " *  Written by Morris Jette <jette1@llnl.gov>.\n", " *  CODE-OCEC-09-009. All rights reserved.\n", " *\n", " *  This file is part of Slurm, a resource management program.\n", " *  For details, see <https://slurm.schedmd.com/>.\n", " *  Please also read the included file: DISCLAIMER.\n", " *\n", " *  Slurm is free software; you can redistribute it and/or modify it under\n", " *  the terms of the GNU General Public License as published by the Free\n", " *  Software Foundation; either version 2 of the License, or (at your option)\n", " *  any later version.\n", " *\n", " *  In addition, as a special exception, the copyright holders give permission\n", " *  to link the code of portions of this program with the OpenSSL library under\n", " *  certain conditions as described in each individual source file, and\n", " *  distribute linked combinations including the two. You must obey the GNU\n", " *  General Public License in all respects for all of the code used other than\n", " *  OpenSSL. If you modify file(s) with this exception, you may extend this\n", " *  exception to your version of the file(s), but you are not obligated to do\n", " *  so. If you do not wish to do so, delete this exception statement from your\n", " *  version.  If you delete this exception statement from all source files in\n", " *  the program, then also delete it here.\n", " *\n", " *  Slurm is distributed in the hope that it will be useful, but WITHOUT ANY\n", " *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n", " *  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n", " *  details.\n", " *\n", " *  You should have received a copy of the GNU General Public License along\n", " *  with Slurm; if not, write to the Free Software Foundation, Inc.,\n", " *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA.\n", "\\*****************************************************************************/\n", "\n", "#include <errno.h>\n", "#include <stdio.h>\n", "#include <sys/types.h>\n", "#include <unistd.h>\n", "\n", "#ifndef __USE_XOPEN_EXTENDED\n", "extern pid_t getsid(pid_t pid);\t\t/* missing from <unistd.h> */\n", "#endif\n", "\n", "#include \"slurm/slurm.h\"\n", "\n", "#include \"src/common/read_config.h\"\n", "#include \"src/common/slurm_protocol_api.h\"\n", "#include \"src/common/xmalloc.h\"\n", "#include \"src/common/xstring.h\"\n", "\n", "/*\n", " * slurm_submit_batch_job - issue RPC to submit a job for later execution\n", " * NOTE: free the response using slurm_free_submit_response_response_msg\n", " * IN job_desc_msg - description of batch job request\n", " * OUT resp - response to request\n", " * RET SLURM_SUCCESS on success, otherwise return SLURM_ERROR with errno set\n", " */\n", "extern int slurm_submit_batch_job(job_desc_msg_t *req,\n", "\t\t\t\t  submit_response_msg_t **resp)\n", "{\n", "\tint rc;\n", "\tslurm_msg_t req_msg;\n", "\tslurm_msg_t resp_msg;\n", "\n", "\tslurm_msg_t_init(&req_msg);\n", "\tslurm_msg_t_init(&resp_msg);\n", "\n", "\t/*\n", "\t * set Node and session id for this request\n", "\t */\n", "\tif (req->alloc_sid == NO_VAL)\n", "\t\treq->alloc_sid = getsid(0);\n", "\n", "\treq_msg.msg_type = REQUEST_SUBMIT_BATCH_JOB;\n", "\treq_msg.data     = req;\n", "\n", "\trc = slurm_send_recv_controller_msg(&req_msg, &resp_msg,\n", "\t\t\t\t\t    working_cluster_rec);\n", "\tif (rc == SLURM_ERROR)\n", "\t\treturn SLURM_ERROR;\n", "\n", "\tswitch (resp_msg.msg_type) {\n", "\tcase RESPONSE_SLURM_RC:\n", "\t\trc = ((return_code_msg_t *) resp_msg.data)->return_code;\n", "\t\tif (rc)\n", "\t\t\tslurm_seterrno_ret(rc);\n", "\t\t*resp = NULL;\n", "\t\tbreak;\n", "\tcase RESPONSE_SUBMIT_BATCH_JOB:\n", "\t\t*resp = (submit_response_msg_t *) resp_msg.data;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tslurm_seterrno_ret(SLURM_UNEXPECTED_MSG_ERROR);\n", "\t}\n", "\n", "\treturn SLURM_SUCCESS;\n", "}\n"], "project": "slurm-wlm-emulator", "file": "submit.pkl", "function": "slurm_submit_batch_job"}, {"comment_all": {"comment": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */", "depth": 0, "reading_ease": 73.64, "reading_grade": 4.5, "line": 3622}, "comment_text": "/** Allocate and initialize an input buffer state.\n * @param file A readable stream.\n * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n * \n * @return the allocated buffer state.\n */", "comment_tokens": ["Allocate", "and", "initialize", "an", "input", "buffer", "state", ".", "@", "param", "file", "A", "readable", "stream", ".", "@", "param", "size", "The", "character", "buffer", "size", "in", "bytes", ".", "When", "in", "doubt", ",", "use", "@", "c", "YY_BUF_SIZE", ".", "@", "return", "the", "allocated", "buffer", "state", "."], "ccode": ["\n", "/** Allocate and initialize an input buffer state.\n", " * @param file A readable stream.\n", " * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n", " * \n", " * @return the allocated buffer state.\n", " */\n", "    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "    \n", "\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n", "\n", "\tb->yy_buf_size = size;\n", "\n", "\t/* yy_ch_buf has to be 2 characters longer than the size given because\n", "\t * we need to put in 2 end-of-buffer characters.\n", "\t */\n", "\tb->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );\n", "\tif ( ! b->yy_ch_buf )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n", "\n", "\tb->yy_is_our_buffer = 1;\n", "\n", "\tyy_init_buffer( b, file );\n", "\n", "\treturn b;\n", "}\n"], "project": "linux-buildinfo-5.11.0-1028-oracle", "file": "lexer.lex.pkl", "function": "yy_create_buffer"}, {"comment_all": {"comment": "/* hyperlink.c : Glue for overriding vms of AtkHyperlink\n *\n * Author: Mike Gorse <mgorse@novell.com>\n * \n * Copyright (c) 2008 Novell, Inc.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the Lesser GNU General \n * Public License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 53.81, "reading_grade": 10.1, "line": 0}, "comment_text": "/* hyperlink.c : Glue for overriding vms of AtkHyperlink\n *\n * Author: Mike Gorse <mgorse@novell.com>\n * \n * Copyright (c) 2008 Novell, Inc.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the Lesser GNU General \n * Public License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["hyperlink.c", ":", "Glue", "for", "overriding", "vms", "of", "AtkHyperlink", "Author", ":", "Mike", "Gorse", "<", "mgorse", "@", "novell.com", ">", "Copyright", "(", "c", ")", "2008", "Novell", ",", "Inc", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "version", "2", "of", "the", "Lesser", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/* hyperlink.c : Glue for overriding vms of AtkHyperlink\n", " *\n", " * Author: Mike Gorse <mgorse@novell.com>\n", " * \n", " * Copyright (c) 2008 Novell, Inc.\n", " *\n", " * This program is free software; you can redistribute it and/or\n", " * modify it under the terms of version 2 of the Lesser GNU General \n", " * Public License as published by the Free Software Foundation.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this program; if not, write to the\n", " * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "\n", "#include <atk/atk.h>\n", "\n", "\n", "void atksharp_hyperlink_override_get_uri (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_get_object (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_get_end_index (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_get_start_index (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_is_valid (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_get_n_anchors (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_link_state (GType gtype, gpointer cb);\n", "\n", "void atksharp_hyperlink_override_is_selected_link (GType gtype, gpointer cb);\n", "\n", "\n", "void\n", "atksharp_hyperlink_override_get_uri (GType gtype, gpointer cb)\n", "{\n", "\tAtkHyperlinkClass *klass = g_type_class_peek (gtype);\n", "\tif (!klass)\n", "\t\tklass = g_type_class_ref (gtype);\n", "\t((AtkHyperlinkClass *) klass)->get_uri = cb;\n", "}\n"], "project": "gtk-sharp2-gapi", "file": "hyperlink.pkl", "function": "atksharp_hyperlink_override_get_uri"}, {"comment_all": {"comment": "/***************************************************************************\n *   (C) Copyright 2006, 2007 Alastair Poole.  <alastairpoole@gmail.com>   *   \n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n ***************************************************************************/", "depth": 0, "reading_ease": 47.12, "reading_grade": 12.7, "line": 0}, "comment_text": "/***************************************************************************\n *   (C) Copyright 2006, 2007 Alastair Poole.  <alastairpoole@gmail.com>   *   \n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n ***************************************************************************/", "comment_tokens": ["(", "C", ")", "Copyright", "2006", ",", "2007", "Alastair", "Poole", ".", "<", "alastairpoole", "@", "gmail.com", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", "."], "ccode": ["/***************************************************************************\n", " *   (C) Copyright 2006, 2007 Alastair Poole.  <alastairpoole@gmail.com>   *   \n", " *                                                                         *\n", " *   This program is free software; you can redistribute it and/or modify  *\n", " *   it under the terms of the GNU General Public License as published by  *\n", " *   the Free Software Foundation; either version 2 of the License, or     *\n", " *   (at your option) any later version.                                   *\n", " ***************************************************************************/\n", "\n", "#include \"of_api.h\"\n", "\n", "#include <errno.h>\n", "\n", "struct device_node *_of_return_nodes(struct device_node **array, int *idx,\n", "\t\t\t\t     int *sem, int type)\n", "{\n", "\twhile (*idx >= 0) {\n", "\n", "\t\tif (*idx == 0 || type == 0)\n", "\t\t\t*sem = 0;\n", "\n", "\t\treturn *idx > 0 ? array[(*idx)--] : NULL;\n", "\t}\n", "\t\n", "\treturn NULL;\n", "}\n"], "project": "libofapi-dev", "file": "of_internals.pkl", "function": "_of_return_nodes"}, {"comment_all": {"comment": "/** Set the input stream. This does not discard the current\n * input buffer.\n * @param _in_str A readable stream.\n * \n * @see yy_switch_to_buffer\n */", "depth": 0, "reading_ease": 73.54, "reading_grade": 4.6, "line": 4070}, "comment_text": "/** Set the input stream. This does not discard the current\n * input buffer.\n * @param _in_str A readable stream.\n * \n * @see yy_switch_to_buffer\n */", "comment_tokens": ["Set", "the", "input", "stream", ".", "This", "does", "not", "discard", "the", "current", "input", "buffer", ".", "@", "param", "_in_str", "A", "readable", "stream", ".", "@", "see", "yy_switch_to_buffer"], "ccode": ["\n", "/** Set the input stream. This does not discard the current\n", " * input buffer.\n", " * @param _in_str A readable stream.\n", " * \n", " * @see yy_switch_to_buffer\n", " */\n", "void yyset_in (FILE *  _in_str )\n", "{\n", "        yyin = _in_str ;\n", "}\n"], "project": "linux-buildinfo-5.8.0-53-generic", "file": "lexer.lex.pkl", "function": "yyset_in"}, {"comment_all": {"comment": "/*------------------------------------------------------------------.\n| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n| TOP (included).                                                   |\n`------------------------------------------------------------------*/", "depth": 0, "reading_ease": 75.2, "reading_grade": 6.0, "line": 937}, "comment_text": "/*------------------------------------------------------------------.\n| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n| TOP (included).                                                   |\n`------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", ".", "|", "yy_stack_print", "--", "Print", "the", "state", "stack", "from", "its", "BOTTOM", "up", "to", "its", "|", "|", "TOP", "(", "included", ")", ".", "|", "`", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["\n", "/*------------------------------------------------------------------.\n", "| yy_stack_print -- Print the state stack from its BOTTOM up to its |\n", "| TOP (included).                                                   |\n", "`------------------------------------------------------------------*/\n", "\n", "static void\n", "yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)\n", "{\n", "  YYFPRINTF (stderr, \"Stack now\");\n", "  for (; yybottom <= yytop; yybottom++)\n", "    {\n", "      int yybot = *yybottom;\n", "      YYFPRINTF (stderr, \" %d\", yybot);\n", "    }\n", "  YYFPRINTF (stderr, \"\\n\");\n", "}\n"], "project": "linux-buildinfo-5.11.0-1023-aws", "file": "parser.tab.pkl", "function": "yy_stack_print"}, {"comment_all": {"comment": "/* Not sure if we should pop here. */", "depth": 1, "reading_ease": 115.13, "reading_grade": -1.2, "line": 3741}, "comment_text": "/* Not sure if we should pop here. */", "comment_tokens": ["Not", "sure", "if", "we", "should", "pop", "here", "."], "ccode": ["\n", "/** Destroy the buffer.\n", " * @param b a buffer created with yy_create_buffer()\n", " * \n", " */\n", "    void yy_delete_buffer (YY_BUFFER_STATE  b )\n", "{\n", "    \n", "\tif ( ! b )\n", "\t\treturn;\n", "\n", "\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n", "\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n", "\n", "\tif ( b->yy_is_our_buffer )\n", "\t\tyyfree( (void *) b->yy_ch_buf  );\n", "\n", "\tyyfree( (void *) b  );\n", "}\n"], "project": "linux-buildinfo-5.8.0-53-lowlatency", "file": "lexer.lex.pkl", "function": "yy_delete_buffer"}, {"comment_all": {"comment": "/*\n * A generic implementation of binary search for the Linux kernel\n *\n * Copyright (C) 2008-2009 Ksplice, Inc.\n * Author: Tim Abbott <tabbott@ksplice.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; version 2.\n */", "depth": 0, "reading_ease": 46.47, "reading_grade": 10.8, "line": 0}, "comment_text": "/*\n * A generic implementation of binary search for the Linux kernel\n *\n * Copyright (C) 2008-2009 Ksplice, Inc.\n * Author: Tim Abbott <tabbott@ksplice.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; version 2.\n */", "comment_tokens": ["A", "generic", "implementation", "of", "binary", "search", "for", "the", "Linux", "kernel", "Copyright", "(", "C", ")", "2008-2009", "Ksplice", ",", "Inc", ".", "Author", ":", "Tim", "Abbott", "<", "tabbott", "@", "ksplice.com", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "version", "2", "."], "ccode": ["/*\n", " * A generic implementation of binary search for the Linux kernel\n", " *\n", " * Copyright (C) 2008-2009 Ksplice, Inc.\n", " * Author: Tim Abbott <tabbott@ksplice.com>\n", " *\n", " * This program is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU General Public License as\n", " * published by the Free Software Foundation; version 2.\n", " */\n", "\n", "#include <xen/lib.h>\n", "\n", "/*\n", " * bsearch - binary search an array of elements\n", " * @key: pointer to item being searched for\n", " * @base: pointer to first element to search\n", " * @num: number of elements\n", " * @size: size of each element\n", " * @cmp: pointer to comparison function\n", " *\n", " * This function does a binary search on the given array.  The\n", " * contents of the array should already be in ascending sorted order\n", " * under the provided comparison function.\n", " *\n", " * Note that the key need not have the same type as the elements in\n", " * the array, e.g. key could be a string and the comparison function\n", " * could compare the string with the struct's name field.  However, if\n", " * the key and elements in the array are of the same type, you can use\n", " * the same comparison function for both sort() and bsearch().\n", " */\n", "void *bsearch(const void *key, const void *base, size_t num, size_t size,\n", "\t      int (*cmp)(const void *key, const void *elt))\n", "{\n", "\tsize_t start = 0, end = num;\n", "\tint result;\n", "\n", "\twhile (start < end) {\n", "\t\tsize_t mid = start + (end - start) / 2;\n", "\n", "\t\tresult = cmp(key, base + mid * size);\n", "\t\tif (result < 0)\n", "\t\t\tend = mid;\n", "\t\telse if (result > 0)\n", "\t\t\tstart = mid + 1;\n", "\t\telse\n", "\t\t\treturn (void *)base + mid * size;\n", "\t}\n", "\n", "\treturn NULL;\n", "}\n"], "project": "xen-hypervisor-4.11-amd64", "file": "bsearch.pkl", "function": "bsearch"}, {"comment_all": {"comment": "/* check whether enough characters are available */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 146}, "comment_text": "/* check whether enough characters are available */", "comment_tokens": ["check", "whether", "enough", "characters", "are", "available"], "ccode": ["\n", "void parse_date(char *buffer, char *end, struct date_body *db)\n", "{\n", "\tdb->error=PARSE_ERROR;\n", "\n", "\t/* check whether enough characters are available */\n", "\tif (end - buffer < RFC1123DATELENGTH)\n", "\t\tgoto error;\n", "\n", "\tif (rfc1123totm(buffer,&db->date))\n", "\t\tgoto error;\n", "\n", "\tdb->error=PARSE_OK;\n", "\treturn ;\n", "error:\n", "\tLM_ERR(\"parse error\\n\");\n", "\treturn ;\n", "}\n"], "project": "kamailio-mysql-modules", "file": "parse_date.pkl", "function": "parse_date"}, {"comment_all": {"comment": "/**\n * Build the SHA1 hash of pubkey(info) ASN.1 data\n */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 109}, "comment_text": "/**\n * Build the SHA1 hash of pubkey(info) ASN.1 data\n */", "comment_tokens": ["Build", "the", "SHA1", "hash", "of", "pubkey", "(", "info", ")", "ASN.1", "data"], "ccode": ["\n", "/**\n", " * Build the SHA1 hash of pubkey(info) ASN.1 data\n", " */\n", "static bool hash_pubkey(chunk_t pubkey, chunk_t *hash)\n", "{\n", "\thasher_t *hasher;\n", "\n", "\thasher = lib->crypto->create_hasher(lib->crypto, HASH_SHA1);\n", "\tif (!hasher || !hasher->allocate_hash(hasher, pubkey, hash))\n", "\t{\n", "\t\tDESTROY_IF(hasher);\n", "\t\tchunk_free(&pubkey);\n", "\t\tDBG1(DBG_LIB, \"SHA1 hash algorithm not supported, \"\n", "\t\t\t \"fingerprinting failed\");\n", "\t\treturn FALSE;\n", "\t}\n", "\thasher->destroy(hasher);\n", "\tchunk_free(&pubkey);\n", "\treturn TRUE;\n", "}\n"], "project": "strongswan-tnc-base", "file": "pkcs1_encoder.pkl", "function": "hash_pubkey"}, {"comment_all": {"comment": "/* TZO specific response validator. */", "depth": 0, "reading_ease": 8.2, "reading_grade": 13.1, "line": 859}, "comment_text": "/* TZO specific response validator. */", "comment_tokens": ["TZO", "specific", "response", "validator", "."], "ccode": ["\n", "/* TZO specific response validator. */\n", "static RC_TYPE is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, HTTP_TRANSACTION *p_tr, int infnr)\n", "{\n", "\t(void)p_self;\n", "\t(void)infnr;\n", "\n", "\tRC_TYPE rc;\n", "\tif ((rc = is_http_status_code_ok(p_tr->status)) != RC_OK)\n", "\t\treturn rc;\n", "\n", "\tint code = -1;\n", "\tsscanf(p_tr->p_rsp_body, \"%d \", &code);\n", "\n", "\tswitch (code) {\n", "\t\tcase 200:\n", "\t\tcase 304:\n", "\t\t\treturn RC_OK;\n", "\t\tcase 414:\n", "\t\tcase 500:\n", "\t\t\treturn RC_DYNDNS_RSP_RETRY_LATER;\n", "\t\tdefault:\n", "\t\t\treturn RC_DYNDNS_RSP_NOTOK;\n", "\t}\n", "}\n"], "project": "inadyn", "file": "dyndns.pkl", "function": "is_tzo_server_rsp_ok"}, {"comment_all": {"comment": "/* Free old list as it's malloc'd by xdo_search_windows */", "depth": 1, "reading_ease": 80.28, "reading_grade": 4.1, "line": 201}, "comment_text": "/* Free old list as it's malloc'd by xdo_search_windows */", "comment_tokens": ["Free", "old", "list", "as", "it", "'s", "malloc", "'d", "by", "xdo_search_windows"], "ccode": ["#include \"xdo_cmd.h\"\n", "#include <string.h>\n", "\n", "int cmd_search(context_t *context) {\n", "  Window *list = NULL;\n", "  xdo_search_t search;\n", "  unsigned int nwindows;\n", "  unsigned int i;\n", "  int c;\n", "  int op_sync = False;\n", "\n", "  int search_title = 0;\n", "  int search_name = 0;\n", "  int out_shell = 0;\n", "  char out_prefix[17] = {'\\0'};\n", "  int search_class = 0;\n", "  int search_classname = 0;\n", "  typedef enum {\n", "    opt_unused, opt_title, opt_onlyvisible, opt_name, opt_shell, opt_prefix, opt_class, opt_maxdepth,\n", "    opt_pid, opt_help, opt_any, opt_all, opt_screen, opt_classname, opt_desktop,\n", "    opt_limit, opt_sync\n", "  } optlist_t;\n", "  struct option longopts[] = {\n", "    { \"all\", no_argument, NULL, opt_all },\n", "    { \"any\", no_argument, NULL, opt_any },\n", "    { \"class\", no_argument, NULL, opt_class },\n", "    { \"classname\", no_argument, NULL, opt_classname },\n", "    { \"help\", no_argument, NULL, opt_help },\n", "    { \"maxdepth\", required_argument, NULL, opt_maxdepth },\n", "    { \"name\", no_argument, NULL, opt_name },\n", "    { \"shell\", no_argument, NULL, opt_shell },\n", "    { \"prefix\", required_argument, NULL, opt_prefix },\n", "    { \"onlyvisible\", 0, NULL, opt_onlyvisible },\n", "    { \"pid\", required_argument, NULL, opt_pid },\n", "    { \"screen\", required_argument, NULL, opt_screen },\n", "    { \"title\", no_argument, NULL, opt_title },\n", "    { \"desktop\", required_argument, NULL, opt_desktop },\n", "    { \"limit\", required_argument, NULL, opt_limit },\n", "    { \"sync\", no_argument, NULL, opt_sync },\n", "    { 0, 0, 0, 0 },\n", "  };\n", "  static const char *usage =\n", "      \"Usage: xdotool %s \"\n", "      \"[options] regexp_pattern\\n\"\n", "      \"--class         check regexp_pattern against the window class\\n\"\n", "      \"--classname     check regexp_pattern against the window classname\\n\"\n", "      \"--maxdepth N    set search depth to N. Default is infinite.\\n\"\n", "      \"                -1 also means infinite.\\n\"\n", "      \"--onlyvisible   matches only windows currently visible\\n\"\n", "      \"--pid PID       only show windows belonging to specific process\\n\"\n", "      \"                Not supported by all X11 applications\\n\"\n", "      \"--screen N      only search a specific screen. Default is all screens\\n\"\n", "      \"--desktop N     only search a specific desktop number\\n\"\n", "      \"--limit N       break search after N results\\n\"\n", "      \"--name          check regexp_pattern against the window name\\n\"\n", "      \"--shell         print results as shell array WINDOWS=( ... )\\n\"\n", "      \"--prefix STR    use prefix (max 16 chars) for array name STRWINDOWS\\n\"\n", "      \"--title         DEPRECATED. Same as --name.\\n\"\n", "      \"--all           Require all conditions match a window. Default is --any\\n\"\n", "      \"--any           Windows matching any condition will be reported\\n\"\n", "      \"--sync          Wait until a search result is found.\\n\"\n", "      \"-h, --help      show this help output\\n\"\n", "      \"\\n\"\n", "      \"If none of --name, --classname, or --class are specified, the \\n\"\n", "      \"defaults are: --name --classname --class\\n\";\n", "\n", "  memset(&search, 0, sizeof(xdo_search_t));\n", "  search.max_depth = -1;\n", "  search.require = SEARCH_ANY;\n", "\n", "  char *cmd = *context->argv;\n", "  int option_index;\n", "\n", "  while ((c = getopt_long_only(context->argc, context->argv, \"+h\",\n", "                               longopts, &option_index)) != -1) {\n", "    switch (c) {\n", "      case 0:\n", "        break;\n", "      case 'h':\n", "      case opt_help:\n", "        printf(usage, cmd);\n", "        consume_args(context, context->argc);\n", "        return EXIT_SUCCESS;\n", "      case opt_maxdepth:\n", "        search.max_depth = strtol(optarg, NULL, 0);\n", "        break;\n", "      case opt_pid:\n", "        search.pid = atoi(optarg);\n", "        search.searchmask |= SEARCH_PID;\n", "        break;\n", "      case opt_any:\n", "        search.require = SEARCH_ANY;\n", "        break;\n", "      case opt_all:\n", "        search.require = SEARCH_ALL;\n", "        break;\n", "      case opt_screen:\n", "        search.screen = strtoul(optarg, NULL, 0);\n", "        search.searchmask |= SEARCH_SCREEN;\n", "        break;\n", "      case opt_onlyvisible:\n", "        search.only_visible = True;\n", "        search.searchmask |= SEARCH_ONLYVISIBLE;\n", "        break;\n", "      case opt_class:\n", "        search_class = True;\n", "        break;\n", "      case opt_classname:\n", "        search_classname = True;\n", "        break;\n", "      case opt_title:\n", "        fprintf(stderr, \"This flag is deprecated. Assuming you mean --name (the\"\n", "                \" window name).\\n\");\n", "        /* fall through */\n", "      case opt_name:\n", "        search_name = True;\n", "        break;\n", "      case opt_shell:\n", "        out_shell = True;\n", "        break;\n", "      case opt_prefix:\n", "        strncpy(out_prefix, optarg, sizeof(out_prefix)-1);\n", "        out_prefix[ sizeof(out_prefix)-1 ] = '\\0'; //just in case\n", "        break;\n", "      case opt_desktop:\n", "        search.desktop = strtol(optarg, NULL, 0);\n", "        search.searchmask |= SEARCH_DESKTOP;\n", "        break;\n", "      case opt_limit:\n", "        search.limit = atoi(optarg);\n", "        break;\n", "      case opt_sync:\n", "        op_sync = True;\n", "        break;\n", "      default:\n", "        fprintf(stderr, \"Invalid usage\\n\");\n", "        fprintf(stderr, usage, cmd);\n", "        return EXIT_FAILURE;\n", "    }\n", "  }\n", "\n", "  consume_args(context, optind);\n", "\n", "  /* We require a pattern or a pid to search for */\n", "  if (context->argc < 1 && search.pid == 0) {\n", "    fprintf(stderr, usage, cmd);\n", "    return EXIT_FAILURE;\n", "  }\n", "\n", "  if (context->argc > 0) {\n", "    if (!search_title && !search_name && !search_class && !search_classname) {\n", "      fprintf(stderr, \"Defaulting to search window name, class, and classname\\n\");\n", "      search.searchmask |= (SEARCH_NAME | SEARCH_CLASS | SEARCH_CLASSNAME);\n", "      search_name = 1;\n", "      search_class = 1;\n", "      search_classname = 1;\n", "    }\n", "\n", "    if (search_title) {\n", "      search.searchmask |= SEARCH_NAME;\n", "      search.winname = context->argv[0];\n", "    }\n", "    if (search_name) {\n", "      search.searchmask |= SEARCH_NAME;\n", "      search.winname = context->argv[0];\n", "    }\n", "    if (search_class) {\n", "      search.searchmask |= SEARCH_CLASS;\n", "      search.winclass = context->argv[0];\n", "    }\n", "    if (search_classname) {\n", "      search.searchmask |= SEARCH_CLASSNAME;\n", "      search.winclassname = context->argv[0];\n", "    }\n", "    consume_args(context, 1);\n", "  }\n", "\n", "  do {\n", "    if (list != NULL) {\n", "      free(list);\n", "    }\n", "\n", "    xdo_search_windows(context->xdo, &search, &list, &nwindows);\n", "\n", "    if ( (context->argc == 0) || out_shell ) {\n", "      /* only print if we're the last command or printing to shell*/\n", "      if (out_shell) printf(\"%s%s\", out_prefix, \"WINDOWS=(\");\n", "      for (i = 0; i < nwindows; i++) {\n", "        window_print(list[i]);\n", "      }\n", "      if (out_shell) printf(\"%s\",\")\\n\");\n", "    }\n", "\n", "    if (op_sync && nwindows == 0) {\n", "      xdotool_debug(context, \"No search results, still waiting...\");\n", "\n", "      /* TODO(sissel): Make this tunable */\n", "      usleep(500000);\n", "    }\n", "  } while (op_sync && nwindows == 0);\n", "\n", "  /* Free old list as it's malloc'd by xdo_search_windows */\n", "  if (context->windows != NULL) {\n", "    free(context->windows);\n", "  }\n", "  context->windows = list;\n", "  context->nwindows = nwindows;\n", "\n", "  /* error if number of windows found is zero (behave like grep) \n", "  but return success when being used inside eval (--shell option)*/\n", "  return (nwindows || out_shell ? EXIT_SUCCESS : EXIT_FAILURE);\n", "}\n"], "project": "libxdo3", "file": "cmd_search.pkl", "function": "cmd_search"}, {"comment_all": {"comment": "/*\n     * clean up the hanging dragContext \n     */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 257}, "comment_text": "/*\n     * clean up the hanging dragContext \n     */", "comment_tokens": ["clean", "up", "the", "hanging", "dragContext"], "ccode": ["\n", "static void \n", "Destroy(\n", "        Widget w )\n", "{\n", "    XmDropTransferObject new_w = (XmDropTransferObject) w;\n", "    Cardinal \t\t i;\n", "    XmDragContext\t dc;\n", "\n", "    /*\n", "     * clean up the hanging dragContext \n", "     */\n", "    dc = (XmDragContext)XmGetDragContext((Widget)new_w, \n", "\t\t\t\t\t new_w->dropTransfer.timestamp);\n", "    if (dc && dc->drag.sourceIsExternal)\n", "      XtDestroyWidget((Widget)dc);\n", "\n", "    for (i = 0; i < new_w->dropTransfer.num_drop_transfer_lists; i++)\n", "      {\n", "\t  XmDropTransferList\tcurrEntry =\n", "\t    &(new_w->dropTransfer.drop_transfer_lists[i]);\n", "\t  \n", "\t  XtFree((char *)currEntry->transfer_list);\n", "      }\n", "    XtFree((char *)new_w->dropTransfer.drop_transfer_lists);\n", "}\n"], "project": "libmrm4", "file": "DropTrans.pkl", "function": "Destroy"}, {"comment_all": {"comment": "/* go to the source's dir */", "depth": 1, "reading_ease": 117.16, "reading_grade": -1.9, "line": 113}, "comment_text": "/* go to the source's dir */", "comment_tokens": ["go", "to", "the", "source", "'s", "dir"], "ccode": ["/*\n", " *  binfmt_misc C Interpreter\n", " *  Copyright (C) 2005 Junichi Uekawa\n", " *\n", " *  This program is free software; you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation; either version 2 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  This program is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License\n", " *  along with this program; if not, write to the Free Software\n", " *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", " *\n", " * Interepreter for binfmt_misc C compilation.\n", " *\n", " */\n", "#define _GNU_SOURCE\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <string.h>\n", "#include <ctype.h>\n", "#include <sys/wait.h>\n", "#include \"binfmtc.h\"\n", "\n", "#define BINFMTC_MAGIC_LEN strlen(binfmtc_magic)\n", "#define BINFMTC_DEBUG (getenv(\"BINFMTC_DEBUG\"))\n", "\n", "char* compile_source(const char *sourcename)\n", "{\n", "  char* origdir = getcwd(NULL, 0);\n", "  char* path = strdup (sourcename);\n", "  char* path_delimiter;\n", "  char* tempfilename = NULL; \n", "  char* s = NULL;\n", "  char* gcccommandline = NULL;\n", "  size_t size;\n", "  FILE* f;\n", "  int i;\n", "  \n", "  asprintf(&tempfilename, \"%s/binfmtcXXXXXX\",\n", "\t   getenv(\"BINFMTCTMPDIR\")?:\n", "\t   getenv(\"TMPDIR\")?:\n", "\t   getenv(\"TEMPDIR\")?:\n", "\t   \"/tmp\"\n", "\t   );\n", "  \n", "  if (NULL==(path_delimiter=strrchr(path, '/')))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Could not determine the directory name of source %s\\n\", \n", "\t      sourcename);\n", "      return NULL;\n", "    }\n", "  \n", "  *path_delimiter=0;/* obtain the dirname */\n", "  close(mkstemp(tempfilename)); /* get temporary filename */\n", "  if (!(f=fopen(sourcename,\"rt\")))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Could not open file %s for read\\n\", \n", "\t      sourcename);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "\n", "  if (!getline (&s, &size, f))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Could not read file %s\\n\", \n", "\t      sourcename);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "\n", "  /* compare with magic */\n", "  if (size < BINFMTC_MAGIC_LEN || \n", "      (memcmp(binfmtc_magic, s, BINFMTC_MAGIC_LEN)))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: %s magic invalid \\n\", \n", "\t      sourcename);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "  fclose(f);\n", "\n", "  /* make the newlines removed */\n", "  for(i=strlen(s)-1; i; --i)\n", "    {\n", "      if (!isspace (s[i]))\n", "        break;\n", "      else\n", "\ts[i]=0;\n", "    }\n", "\n", "  asprintf (&gcccommandline,\n", "\t    \"%s -o %s %s %s %s \\\"%s\\\"\",\n", "\t    compiler_name(),\n", "\t    tempfilename,\n", "\t    gcc_x,\n", "\t    s+BINFMTC_MAGIC_LEN,\n", "\t    default_options(),\n", "\t    basename(sourcename));\n", "\n", "  if (BINFMTC_DEBUG)\n", "    fprintf(stderr, \"binfmtc: Execute command-line: %s\\n\", gcccommandline);\n", "\n", "  if (chdir(path))\t\t\t/* go to the source's dir */\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Cannot chdir to directory where source is: %s \\n\", \n", "\t      path);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "  \n", "  if (system(gcccommandline))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Compilation failed for %s, see above messages for details\\n\", \n", "\t      sourcename);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "  \n", "  if (chdir(origdir))\n", "    {\n", "      fprintf(stderr, \n", "\t      \"binfmtc: Cannot chdir to original working directory: %s \\n\", \n", "\t      path);\n", "      unlink(tempfilename);\n", "      return NULL;\n", "    }\n", "\n", "  free(origdir);\n", "  free(path);\n", "  free(s);\n", "  free(gcccommandline);\n", "  return tempfilename;\n", "}\n"], "project": "binfmtc", "file": "binfmtc-interpreter.pkl", "function": "compile_source"}, {"comment_all": {"comment": "/* cvm/client_setugid.c - CVM client standard setuid/setgid call\n * Copyright (C) 2010  Bruce Guenter <bruce@untroubled.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "depth": 0, "reading_ease": 50.36, "reading_grade": 11.4, "line": 0}, "comment_text": "/* cvm/client_setugid.c - CVM client standard setuid/setgid call\n * Copyright (C) 2010  Bruce Guenter <bruce@untroubled.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "comment_tokens": ["cvmclient_setugid.c", "-", "CVM", "client", "standard", "setuidsetgid", "call", "Copyright", "(", "C", ")", "2010", "Bruce", "Guenter", "<", "bruce", "@", "untroubled.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/* cvm/client_setugid.c - CVM client standard setuid/setgid call\n", " * Copyright (C) 2010  Bruce Guenter <bruce@untroubled.org>\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", " */\n", "#include <sys/types.h>\n", "#include <unistd.h>\n", "#include \"v1client.h\"\n", "\n", "int cvm_client_setugid(void)\n", "{\n", "  if (setgid(cvm_fact_groupid) == -1) return 0;\n", "  if (setuid(cvm_fact_userid) == -1) return 0;\n", "  if (chdir(cvm_fact_directory) == -1) return 0;\n", "  return 1;\n", "}\n"], "project": "cvm-mysql", "file": "client_setugid.pkl", "function": "cvm_client_setugid"}, {"comment_all": {"comment": "/* arbitrary grow size */", "depth": 2, "reading_ease": 59.97, "reading_grade": 5.6, "line": 1737}, "comment_text": "/* Increase the buffer to prepare for a possible push. */\n/* arbitrary grow size */\n", "comment_tokens": ["Increase", "the", "buffer", "to", "prepare", "for", "a", "possible", "push", ".", "arbitrary", "grow", "size"], "ccode": ["\n", "/* Allocates the stack if it does not exist.\n", " *  Guarantees space for at least one push.\n", " */\n", "static void yyensure_buffer_stack (void)\n", "{\n", "\tyy_size_t num_to_alloc;\n", "    \n", "\tif (!(yy_buffer_stack)) {\n", "\n", "\t\t/* First allocation is just for 2 elements, since we don't know if this\n", "\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n", "\t\t * immediate realloc on the next call.\n", "         */\n", "      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n", "\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n", "\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t\t(yy_buffer_stack_top) = 0;\n", "\t\treturn;\n", "\t}\n", "\n", "\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n", "\n", "\t\t/* Increase the buffer to prepare for a possible push. */\n", "\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n", "\n", "\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n", "\t\t\t\t\t\t\t\t((yy_buffer_stack),\n", "\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\t/* zero only the new slots.*/\n", "\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t}\n", "}\n"], "project": "pdns-backend-pgsql", "file": "bindlexer.pkl", "function": "yyensure_buffer_stack"}, {"comment_all": {"comment": "/*\n  Utilities used in rzip\n\n  tridge, June 1996\n  */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 18}, "comment_text": "/*\n  Utilities used in rzip\n\n  tridge, June 1996\n  */", "comment_tokens": ["Utilities", "used", "in", "rzip", "tridge", ",", "June", "1996"], "ccode": ["/* \n", "   Copyright (C) Andrew Tridgell 1998\n", "   \n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2 of the License, or\n", "   (at your option) any later version.\n", "   \n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "   \n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software\n", "   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", "*/\n", "\n", "/*\n", "  Utilities used in rzip\n", "\n", "  tridge, June 1996\n", "  */\n", "#include \"rzip.h\"\n", "\n", "\n", "void *Realloc(void *p, int size)\n", "{\n", "\tif (!p) return (void *)malloc(size);\n", "\treturn (void *)realloc(p, size);\n", "}\n"], "project": "rzip", "file": "util.pkl", "function": "Realloc"}, {"comment_all": {"comment": "/* we're screwed if we don't have this */", "depth": 1, "reading_ease": 115.13, "reading_grade": -1.2, "line": 641}, "comment_text": "/* we're screwed if we don't have this */", "comment_tokens": ["we", "'re", "screwed", "if", "we", "do", "n't", "have", "this"], "ccode": ["\n", "static void\n", "stb_dispatcher_init (StbDispatcher *dispatcher)\n", "{\n", "  StbDispatcherPrivate *priv;\n", "\n", "  priv = STB_DISPATCHER_GET_PRIVATE (dispatcher);\n", "  dispatcher->_priv = priv;\n", "\n", "  setup_connection (dispatcher);\n", "\n", "  /* we're screwed if we don't have this */\n", "  g_assert (priv->connection != NULL);\n", "\n", "  priv->polkit_authority = polkit_authority_get ();\n", "\n", "#ifdef HAVE_GIO\n", "  priv->file_monitor = stb_file_monitor_new ();\n", "\n", "  g_signal_connect_swapped (priv->file_monitor, \"object_changed\",\n", "\t\t\t    G_CALLBACK (object_changed_cb), dispatcher);\n", "#endif\n", "}\n"], "project": "system-tools-backends-dev", "file": "dispatcher.pkl", "function": "stb_dispatcher_init"}, {"comment_all": {"comment": "/*\n\t * Get buffer from device to guest\n\t */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 95}, "comment_text": "/*\n\t * Get buffer from device to guest\n\t */", "comment_tokens": ["Get", "buffer", "from", "device", "to", "guest"], "ccode": ["\n", "struct uip_buf *uip_buf_clone(struct uip_tx_arg *arg)\n", "{\n", "\tstruct uip_buf *buf;\n", "\tstruct uip_eth *eth2;\n", "\tstruct uip_info *info;\n", "\n", "\tinfo = arg->info;\n", "\n", "\t/*\n", "\t * Get buffer from device to guest\n", "\t */\n", "\tbuf = uip_buf_get_free(info);\n", "\n", "\t/*\n", "\t * Clone buffer\n", "\t */\n", "\tmemcpy(buf->vnet, arg->vnet, arg->vnet_len);\n", "\tmemcpy(buf->eth, arg->eth, arg->eth_len);\n", "\tbuf->vnet_len\t= arg->vnet_len;\n", "\tbuf->eth_len\t= arg->eth_len;\n", "\n", "\teth2\t\t= (struct uip_eth *)buf->eth;\n", "\teth2->src\t= info->host_mac;\n", "\teth2->dst\t= arg->eth->src;\n", "\n", "\treturn buf;\n", "}\n"], "project": "kvmtool", "file": "buf.pkl", "function": "uip_buf_clone"}, {"comment_all": {"comment": "/* channels */", "depth": 1, "reading_ease": 36.62, "reading_grade": 8.4, "line": 122}, "comment_text": "/* identifier */\n/* version */\n/* channels */\n/* pre-skip */\n/* original sample rate */\n/* gain */\n/* channel mapping family */\n", "comment_tokens": ["identifier", "version", "channels", "pre-skip", "original", "sample", "rate", "gain", "channel", "mapping", "family"], "ccode": ["\n", "\n", "/* manufacture a generic OpusHead packet */\n", "ogg_packet *op_opushead(void)\n", "{\n", "  int size = 19;\n", "  unsigned char *data = malloc(size);\n", "  ogg_packet *op = malloc(sizeof(*op));\n", "\n", "  if (!data) {\n", "    fprintf(stderr, \"Couldn't allocate data buffer.\\n\");\n", "    free(op);\n", "    return NULL;\n", "  }\n", "  if (!op) {\n", "    fprintf(stderr, \"Couldn't allocate Ogg packet.\\n\");\n", "    free(data);\n", "    return NULL;\n", "  }\n", "\n", "  memcpy(data, \"OpusHead\", 8);  /* identifier */\n", "  data[8] = 1;                  /* version */\n", "  data[9] = 2;                  /* channels */\n", "  le16(data+10, 0);             /* pre-skip */\n", "  le32(data + 12, 48000);       /* original sample rate */\n", "  le16(data + 16, 0);           /* gain */\n", "  data[18] = 0;                 /* channel mapping family */\n", "\n", "  op->packet = data;\n", "  op->bytes = size;\n", "  op->b_o_s = 1;\n", "  op->e_o_s = 0;\n", "  op->granulepos = 0;\n", "  op->packetno = 0;\n", "\n", "  return op;\n", "}\n"], "project": "opus-tools", "file": "opusrtp.pkl", "function": "op_opushead"}, {"comment_all": {"comment": "/* Test 24-bit images with JPEG compression */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 1236}, "comment_text": "/* Test 24-bit images with JPEG compression */", "comment_tokens": ["Test", "24-bit", "images", "with", "JPEG", "compression"], "ccode": ["\n", "void test_GRgetcomptype(); /* in \"tdfr8.c\" */\n", "static VOID check_im_pal(int32 oldx, int32 oldy, int32 newx, int32 newy,\n", "             uint8 *oldim, uint8 *newim, uint8 *oldpal, uint8 *newpal);\n", "\n", "/* These two functions are in tusejpegfuncs.c.  They use JPEG functions directly\n", "   to compress and decompress the same data as in test_r24_jpeg, to verify that\n", "   the DFR24 API work correctly regardless which JPEG library is used */\n", "intn comp_using_jpeglib(char *filename, long *file_offset, int im_height,\n", "        int im_width, int im_ncomps, int quality, uint8 *written_buffer);\n", "intn decomp_using_jpeglib(char *filename, long file_offset, int im_height,\n", "        int im_width, int im_ncomps, uint8 *read_buffer);\n", "void test_r24_jpeg(void);\n", "\n", "/* ------------------------------- test_r24 ------------------------------- */\n", "\n", "void\n", "test_r24(void)\n", "{\n", "    int32       xd, yd;\n", "    intn        il;\n", "    int         Error;\n", "    char        buf[YSIZE][XSIZE][3];\n", "    char        buf1[YSIZE][3][XSIZE];\n", "    char        buf2[3][YSIZE][XSIZE];\n", "    char        in[YSIZE][XSIZE][3];\n", "    char        in1[YSIZE][3][XSIZE];\n", "    char        in2[3][YSIZE][XSIZE];\n", "    int         i, j, ret;\n", "    uint16      ref0, ref1, ref2;\n", "    uint8      *jpeg_24bit_temp;\n", "\n", "    jpeg_24bit_temp = (uint8 *) HDmalloc(JPEGX * JPEGY * 3);\n", "    if (!jpeg_24bit_temp)\n", "      {\n", "          fprintf(stderr, \"Out of memory!\\n\");\n", "          exit(1);\n", "      }\n", "\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "          {\n", "              buf[i][j][0] = buf[i][j][1] = buf[i][j][2] = (char) (i + j);\n", "              buf1[i][0][j] = buf1[i][1][j] = buf1[i][2][j] = (char) (i | j);\n", "              buf2[0][i][j] = buf2[1][i][j] = buf2[2][i][j] = (char) (i ^ j);\n", "          }\n", "\n", "    MESSAGE(5, printf(\"Writing 24bit images with differing interlacing\\n\");\n", "        );\n", "\n", "    ret = DF24setil(DFIL_PIXEL);\n", "    RESULT(\"DF24setil\");\n", "    ret = DF24putimage(TESTFILE, &(buf[0][0][0]), XSIZE, YSIZE);\n", "    RESULT(\"DF24putimage\");\n", "    ref0 = DF24lastref();\n", "\n", "    ret = DF24setil(DFIL_LINE);\n", "    RESULT(\"DF24setil\");\n", "    ret = DF24addimage(TESTFILE, &(buf1[0][0][0]), XSIZE, YSIZE);\n", "    RESULT(\"DF24addimage\");\n", "    ref1 = DF24lastref();\n", "\n", "    ret = DF24setil(DFIL_PLANE);\n", "    RESULT(\"DF24setil\");\n", "    ret = DF24addimage(TESTFILE, &(buf2[0][0][0]), XSIZE, YSIZE);\n", "    RESULT(\"DF24addimage\");\n", "    ref2 = DF24lastref();\n", "\n", "    if ((ret = DF24nimages(TESTFILE)) != 3)\n", "      {\n", "          fprintf(stderr, \"  >>> DF24nimages() gives wrong number: %d <<<\\n\", ret);\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 0 */\n", "\n", "    MESSAGE(5, printf(\"Reading and verifying 24bit images\\n\");\n", "        );\n", "\n", "    ret = DF24restart();\n", "    RESULT(\"DF24restart\");\n", "    ret = DF24reqil(DFIL_PIXEL);\n", "    RESULT(\"DF24reqil\");\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "    if (ret == FAIL)\n", "        HEprint(stderr, 0);\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 0)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 0\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in[i][j][0] != buf[i][j][0]\n", "                || in[i][j][1] != buf[i][j][1]\n", "                || in[i][j][2] != buf[i][j][2])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          printf(\"in:\\n\");\n", "          for (i = 0; i < YSIZE; i++)\n", "            {\n", "                for (j = 0; j < XSIZE; j++)\n", "                    printf(\"(%d,%d,%d)\", (int) in[i][j][0], (int) in[i][j][1], (int) in[i][j][2]);\n", "                printf(\"\\n\");\n", "            }\n", "          printf(\"buf:\\n\");\n", "          for (i = 0; i < YSIZE; i++)\n", "            {\n", "                for (j = 0; j < XSIZE; j++)\n", "                    printf(\"(%d,%d,%d)\", (int) buf[i][j][0], (int) buf[i][j][1], (int) buf[i][j][2]);\n", "                printf(\"\\n\");\n", "            }\n", "          fprintf(stderr, \"Image 0 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    if (ref0 != DF24lastref())\n", "      {\n", "          fprintf(stderr, \"Bogus lastref for image 0\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 1 */\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 1)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 1\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in[i][j][0] != buf1[i][0][j]\n", "                || in[i][j][1] != buf1[i][1][j]\n", "                || in[i][j][2] != buf1[i][2][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 1 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    if (ref1 != DF24lastref())\n", "      {\n", "          fprintf(stderr, \"Bogus lastref for image 1\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 2 */\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 2)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 2\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in[i][j][0] != buf2[0][i][j]\n", "                || in[i][j][1] != buf2[1][i][j]\n", "                || in[i][j][2] != buf2[2][i][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 2 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    if (ref2 != DF24lastref())\n", "      {\n", "          fprintf(stderr, \"Bogus lastref for image 2\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24restart();\n", "    RESULT(\"DF24restart\");\n", "\n", "    /* read image 3 */\n", "\n", "    ret = DF24reqil(DFIL_LINE);\n", "    RESULT(\"DF24reqil\");\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 0)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 3\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in1, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in1[i][0][j] != buf[i][j][0]\n", "                || in1[i][1][j] != buf[i][j][1]\n", "                || in1[i][2][j] != buf[i][j][2])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 3 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 4 */\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 1)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 4\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in1, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in1[i][0][j] != buf1[i][0][j]\n", "                || in1[i][1][j] != buf1[i][1][j]\n", "                || in1[i][2][j] != buf1[i][2][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 4 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 5 */\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 2)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 5\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in1, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in1[i][0][j] != buf2[0][i][j]\n", "                || in1[i][1][j] != buf2[1][i][j]\n", "                || in1[i][2][j] != buf2[2][i][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 5 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 6 */\n", "\n", "    ret = DF24restart();\n", "    RESULT(\"DF24restart\");\n", "\n", "    ret = DF24reqil(DFIL_PLANE);\n", "    RESULT(\"DF24reqil\");\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 0)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 6\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in2, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in2[0][i][j] != buf[i][j][0]\n", "                || in2[1][i][j] != buf[i][j][1]\n", "                || in2[2][i][j] != buf[i][j][2])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 6 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 7 */\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 1)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 7\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in2, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in2[0][i][j] != buf1[i][0][j]\n", "                || in2[1][i][j] != buf1[i][1][j]\n", "                || in2[2][i][j] != buf1[i][2][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 7 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    /* read image 8 */\n", "\n", "    ret = DF24getdims(TESTFILE, &xd, &yd, &il);\n", "    RESULT(\"DF24getdims\");\n", "\n", "    if ((xd != XSIZE) || (yd != YSIZE) || il != 2)\n", "      {\n", "          fprintf(stderr, \"Returned meta-data is wrong for image 8\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    ret = DF24getimage(TESTFILE, in2, XSIZE, YSIZE);\n", "    RESULT(\"DF24getimage\");\n", "    Error = FALSE;\n", "    for (i = 0; i < YSIZE; i++)\n", "        for (j = 0; j < XSIZE; j++)\n", "            if (in2[0][i][j] != buf2[0][i][j]\n", "                || in2[1][i][j] != buf2[1][i][j]\n", "                || in2[2][i][j] != buf2[2][i][j])\n", "              {\n", "                  Error = TRUE;\n", "              }\n", "\n", "    if (Error)\n", "      {\n", "          fprintf(stderr, \"Image 8 was incorrect\\n\");\n", "          num_errs++;\n", "      }\n", "\n", "    HDfree(jpeg_24bit_temp);\n", "\n", "    /* Test 24-bit images with JPEG compression */\n", "    test_r24_jpeg();\n", "}\n"], "project": "libhdf4-doc", "file": "rig.pkl", "function": "test_r24"}, {"comment_all": {"comment": "// If autoconf run (allnoconfig and such), reset bool and tristates:\n", "depth": 1, "reading_ease": 52.87, "reading_grade": 8.4, "line": 85}, "comment_text": "// If autoconf run (allnoconfig and such), reset bool and tristates:\n// \"select ITEM\" sets ITEM=y and then parent item might have been\n// reset to \"n\" later. Try to set ITEM to \"n\" on the second run.\n", "comment_tokens": ["If", "autoconf", "run", "(", "allnoconfig", "and", "such", ")", ",", "reset", "bool", "and", "tristates", ":", "``", "select", "ITEM", "''", "sets", "ITEM=y", "and", "then", "parent", "item", "might", "have", "been", "reset", "to", "``", "n", "''", "later", ".", "Try", "to", "set", "ITEM", "to", "``", "n", "''", "on", "the", "second", "run", "."], "ccode": ["\n", "static void conf_askvalue(struct symbol *sym, const char *def)\n", "{\n", "\tenum symbol_type type = sym_get_type(sym);\n", "\ttristate val;\n", "\n", "\tif (!sym_has_value(sym))\n", "\t\tprintf(\"(NEW) \");\n", "\n", "\tline[0] = '\\n';\n", "\tline[1] = 0;\n", "\tline[2] = 0;\n", "\n", "\tif (!sym_is_changable(sym)) {\n", "\t\tprintf(\"%s\\n\", def);\n", "\t\treturn;\n", "\t}\n", "\n", "\t// If autoconf run (allnoconfig and such), reset bool and tristates:\n", "\t// \"select ITEM\" sets ITEM=y and then parent item might have been\n", "\t// reset to \"n\" later. Try to set ITEM to \"n\" on the second run.\n", "\tif (type == S_BOOLEAN || type == S_TRISTATE) {\n", "\t\tswitch (input_mode) {\n", "\t\tcase set_yes:\n", "\t\t\tif (sym_tristate_within_range(sym, yes)) {\n", "\t\t\t\tline[0] = 'y';\n", "\t\t\t\tline[1] = '\\n';\n", "\t\t\t\tprintf(\"%s\", line);\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\tcase set_mod:\n", "\t\t\tif (type == S_TRISTATE) {\n", "\t\t\t\tif (sym_tristate_within_range(sym, mod)) {\n", "\t\t\t\t\tline[0] = 'm';\n", "\t\t\t\t\tline[1] = '\\n';\n", "\t\t\t\t\tprintf(\"%s\", line);\n", "\t\t\t\t\treturn;\n", "\t\t\t\t}\n", "\t\t\t} else {\n", "\t\t\t\tif (sym_tristate_within_range(sym, yes)) {\n", "\t\t\t\t\tline[0] = 'y';\n", "\t\t\t\t\tline[1] = '\\n';\n", "\t\t\t\t\tprintf(\"%s\", line);\n", "\t\t\t\t\treturn;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\tcase set_no:\n", "\t\t\tif (sym_tristate_within_range(sym, no)) {\n", "\t\t\t\tline[0] = 'n';\n", "\t\t\t\tline[1] = '\\n';\n", "\t\t\t\tprintf(\"%s\", line);\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\tdefault: // placate compiler\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\tswitch (input_mode) {\n", "\tcase set_no:\n", "\tcase set_mod:\n", "\tcase set_yes:\n", "\tcase set_random:\n", "\t\tif (sym_has_value(sym)) {\n", "\t\t\tprintf(\"%s\\n\", def);\n", "\t\t\treturn;\n", "\t\t}\n", "\t\tbreak;\n", "\tcase ask_new:\n", "\tcase ask_silent:\n", "\t\tif (sym_has_value(sym)) {\n", "\t\t\tprintf(\"%s\\n\", def);\n", "\t\t\treturn;\n", "\t\t}\n", "\t\tcheck_stdin();\n", "\tcase ask_all:\n", "\t\tfflush(stdout);\n", "\t\tfgets(line, 128, stdin);\n", "\t\treturn;\n", "\tcase set_default:\n", "\t\tprintf(\"%s\\n\", def);\n", "\t\treturn;\n", "\tdefault:\n", "\t\tbreak;\n", "\t}\n", "\n", "\tswitch (type) {\n", "\tcase S_INT:\n", "\tcase S_HEX:\n", "\tcase S_STRING:\n", "\t\tprintf(\"%s\\n\", def);\n", "\t\treturn;\n", "\tdefault:\n", "\t\t;\n", "\t}\n", "\tswitch (input_mode) {\n", "\tcase set_yes:\n", "\t\tif (sym_tristate_within_range(sym, yes)) {\n", "\t\t\tline[0] = 'y';\n", "\t\t\tline[1] = '\\n';\n", "\t\t\tline[2] = 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\tcase set_mod:\n", "\t\tif (type == S_TRISTATE) {\n", "\t\t\tif (sym_tristate_within_range(sym, mod)) {\n", "\t\t\t\tline[0] = 'm';\n", "\t\t\t\tline[1] = '\\n';\n", "\t\t\t\tline[2] = 0;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\tif (sym_tristate_within_range(sym, yes)) {\n", "\t\t\t\tline[0] = 'y';\n", "\t\t\t\tline[1] = '\\n';\n", "\t\t\t\tline[2] = 0;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\tcase set_no:\n", "\t\tif (sym_tristate_within_range(sym, no)) {\n", "\t\t\tline[0] = 'n';\n", "\t\t\tline[1] = '\\n';\n", "\t\t\tline[2] = 0;\n", "\t\t\tbreak;\n", "\t\t}\n", "\tcase set_random:\n", "\t\tdo {\n", "\t\t\tval = (tristate)(random() % 3);\n", "\t\t} while (!sym_tristate_within_range(sym, val));\n", "\t\tswitch (val) {\n", "\t\tcase no: line[0] = 'n'; break;\n", "\t\tcase mod: line[0] = 'm'; break;\n", "\t\tcase yes: line[0] = 'y'; break;\n", "\t\t}\n", "\t\tline[1] = '\\n';\n", "\t\tline[2] = 0;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tbreak;\n", "\t}\n", "\tprintf(\"%s\", line);\n", "}\n"], "project": "busybox-initramfs", "file": "conf.pkl", "function": "conf_askvalue"}, {"comment_all": {"comment": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * \n */", "depth": 0, "reading_ease": 49.48, "reading_grade": 7.6, "line": 3653}, "comment_text": "/** Destroy the buffer.\n * @param b a buffer created with yy_create_buffer()\n * \n */", "comment_tokens": ["Destroy", "the", "buffer", ".", "@", "param", "b", "a", "buffer", "created", "with", "yy_create_buffer", "(", ")"], "ccode": ["\n", "/** Destroy the buffer.\n", " * @param b a buffer created with yy_create_buffer()\n", " * \n", " */\n", "    void yy_delete_buffer (YY_BUFFER_STATE  b )\n", "{\n", "    \n", "\tif ( ! b )\n", "\t\treturn;\n", "\n", "\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n", "\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n", "\n", "\tif ( b->yy_is_our_buffer )\n", "\t\tyyfree( (void *) b->yy_ch_buf  );\n", "\n", "\tyyfree( (void *) b  );\n", "}\n"], "project": "linux-headers-5.10.0-1017-oem", "file": "lexer.lex.pkl", "function": "yy_delete_buffer"}, {"comment_all": {"comment": "/* Most of the time we don't get button releases from 4/5 */", "depth": 1, "reading_ease": 85.69, "reading_grade": 4.0, "line": 85}, "comment_text": "/* Most of the time we don't get button releases from 4/5 */", "comment_tokens": ["Most", "of", "the", "time", "we", "do", "n't", "get", "button", "releases", "from", "45"], "ccode": ["\n", "void vterm_mouse_button(VTerm *vt, int button, bool pressed, VTermModifier mod)\n", "{\n", "  VTermState *state = vt->state;\n", "\n", "  int old_buttons = state->mouse_buttons;\n", "\n", "  if(button > 0 && button <= 3) {\n", "    if(pressed)\n", "      state->mouse_buttons |= (1 << (button-1));\n", "    else\n", "      state->mouse_buttons &= ~(1 << (button-1));\n", "  }\n", "\n", "  /* Most of the time we don't get button releases from 4/5 */\n", "  if(state->mouse_buttons == old_buttons && button < 4)\n", "    return;\n", "\n", "  if(button < 4) {\n", "    output_mouse(state, button-1, pressed, mod, state->mouse_col, state->mouse_row);\n", "  }\n", "  else if(button < 6) {\n", "    output_mouse(state, button-4 + 0x40, pressed, mod, state->mouse_col, state->mouse_row);\n", "  }\n", "}\n"], "project": "libvterm-dev", "file": "mouse.pkl", "function": "vterm_mouse_button"}, {"comment_all": {"comment": "/* +2 since 1st two chars are for something else(?) */", "depth": 4, "reading_ease": 104.64, "reading_grade": 0.9, "line": 167}, "comment_text": "/* +2 since 1st two chars are for something else(?) */", "comment_tokens": ["+2", "since", "1st", "two", "chars", "are", "for", "something", "else", "(", "?", ")"], "ccode": ["\n", "int get_baseboard_data(struct cim_baseboard *data) {\n", "\n", "  memset(data,0,sizeof(struct cim_baseboard));\n", "\n", "#if defined (INTEL) || defined (X86_64) || defined (IA64) || defined (GENERIC)\n", "\n", "  DMI_BIOSPRODUCT *biosproduct;\n", "\n", "  cimdmi_init();\n", "  biosproduct=cimdmi_getBiosProduct();\n", "  if (biosproduct) {\n", "    data->vendor = strdup(biosproduct->dmi_Vendor);\n", "    if(strcasecmp(biosproduct->dmi_Vendor,\"IBM\") == 0) {\n", "      data->model = calloc(1,5);\n", "      strncpy(data->model,biosproduct->dmi_Name,4);\n", "      data->type = calloc(1,strlen(biosproduct->dmi_Name+4)+1);\n", "      strcpy(data->type,biosproduct->dmi_Name+4);\n", "    }\n", "    data->serialNumber = strdup(biosproduct->dmi_IdentifyingNumber);\n", "  }\n", "  else { return -1; }\n", "  cimdmi_term();\n", "\n", "#endif\n", "\n", "#if defined (S390)\n", "\n", "  FILE *fhd = NULL;\n", "  char vendor[255];\n", "  char model[255];\n", "  char type[255];\n", "  char serial[255];\n", "\n", "  if( (fhd=fopen(SYSINFO,\"r\")) != NULL ) {\n", "    fscanf(fhd,\"%*s %s %*s %s %*s %s %*s %*s %s\",vendor,type,model,serial);\n", "    data->vendor = strdup(vendor);\n", "    data->model = strdup(model);\n", "    data->type = strdup(type);\n", "    data->serialNumber = strdup(serial);\n", "    fclose(fhd);\n", "  } else { return -1; }\n", "\n", "#endif\n", "\n", "#if defined (PPC)\n", "\n", "  FILE *fhd = NULL;\n", "  char *ptr = NULL;\n", "  char *str = NULL;\n", "  char buffer[255];\n", "\n", "  if( (fhd=fopen(MODEL,\"r\")) != NULL ) {\n", "    fscanf(fhd,\"%s\",buffer);\n", "    if( !(ptr=strchr(buffer,',')) ) {\n", "      data->model = calloc(1,strlen(buffer)+1);\n", "      strcpy(data->model,buffer);\n", "    } else {\n", "      data->vendor = calloc(1,strlen(buffer)-strlen(ptr)+1);\n", "      strncpy(data->vendor,buffer,strlen(buffer)-strlen(ptr));\n", "      ptr+=1;\n", "      if( !(str=strchr(ptr,'-')) ) {\n", "\tdata->type = calloc(1,5);\n", "\tstrncpy(data->type,ptr,4);\n", "\tptr+=4;\n", "\tdata->model = calloc(1,strlen(ptr)+1);\n", "\tstrcpy(data->model,ptr);\n", "      } else {\n", "\tdata->type = calloc(1,strlen(ptr)-strlen(str)+1);\n", "\tstrncpy(data->type,ptr,strlen(ptr)-strlen(str));\n", "\tstr+=1;\n", "\tdata->model = calloc(1,strlen(str)+1);\n", "\tstrcpy(data->model,str);\n", "      }\n", "    }\n", "    fclose(fhd);\n", "    memset(buffer,0,sizeof(buffer));\n", "\n", "    if( (fhd=fopen(SYSTEMID,\"r\")) != NULL ) {\n", "      fscanf(fhd,\"%s\",buffer);\n", "      if( !(ptr=strchr(buffer,',')) ) {\n", "\tdata->serialNumber = calloc(1,strlen(buffer)+1);\n", "\tstrcpy(data->serialNumber,buffer);\n", "      } else {\n", "\tptr+=1;\n", "\tdata->serialNumber = calloc(1,strlen(ptr)+1);\n", "\tstrcpy(data->serialNumber,ptr+2); /* +2 since 1st two chars are for something else(?) */\n", "      }\n", "      fclose(fhd);\n", "    }\n", "  } else { return -1; }\n", "\n", "#endif\n", "\n", "  if(_create_tag(data)) { return -1; }\n", "\n", "  return 0;\n", "}\n"], "project": "sblim-cmpi-base", "file": "OSBase_BaseBoard.pkl", "function": "get_baseboard_data"}, {"comment_all": {"comment": "/* hours and mins always shown as positive (w/o minus sign!) even if secs < 0 */", "depth": 2, "reading_ease": 89.75, "reading_grade": 2.5, "line": 456}, "comment_text": "/* hours and mins always shown as positive (w/o minus sign!) even if secs < 0 */", "comment_tokens": ["hours", "and", "mins", "always", "shown", "as", "positive", "(", "wo", "minus", "sign", "!", ")", "even", "if", "secs", "<", "0"], "ccode": ["\n", "/*\n", " *\tShow one line of information on screen\n", " */\n", "static int list(const struct last_control *ctl, struct utmpx *p, time_t logout_time, int what)\n", "{\n", "\ttime_t\t\tsecs, utmp_time;\n", "\tchar\t\tlogintime[LAST_TIMESTAMP_LEN];\n", "\tchar\t\tlogouttime[LAST_TIMESTAMP_LEN];\n", "\tchar\t\tlength[LAST_TIMESTAMP_LEN];\n", "\tchar\t\tfinal[512];\n", "\tchar\t\tutline[sizeof(p->ut_line) + 1];\n", "\tchar\t\tdomain[256];\n", "\tchar\t\t*s;\n", "\tint\t\tmins, hours, days;\n", "\tint\t\tr, len;\n", "\tstruct last_timefmt *fmt;\n", "\n", "\t/*\n", "\t *\tuucp and ftp have special-type entries\n", "\t */\n", "\tutline[0] = 0;\n", "\tstrncat(utline, p->ut_line, sizeof(utline) - 1);\n", "\tif (strncmp(utline, \"ftp\", 3) == 0 && isdigit(utline[3]))\n", "\t\tutline[3] = 0;\n", "\tif (strncmp(utline, \"uucp\", 4) == 0 && isdigit(utline[4]))\n", "\t\tutline[4] = 0;\n", "\n", "\t/*\n", "\t *\tIs this something we want to show?\n", "\t */\n", "\tif (ctl->show) {\n", "\t\tchar **walk;\n", "\t\tfor (walk = ctl->show; *walk; walk++) {\n", "\t\t\tif (strncmp(p->ut_user, *walk, sizeof(p->ut_user)) == 0 ||\n", "\t\t\t    strcmp(utline, *walk) == 0 ||\n", "\t\t\t    (strncmp(utline, \"tty\", 3) == 0 &&\n", "\t\t\t     strcmp(utline + 3, *walk) == 0)) break;\n", "\t\t}\n", "\t\tif (*walk == NULL) return 0;\n", "\t}\n", "\n", "\t/*\n", "\t *\tCalculate times\n", "\t */\n", "\tfmt = &timefmts[ctl->time_fmt];\n", "\n", "\tutmp_time = p->ut_tv.tv_sec;\n", "\n", "\tif (ctl->present) {\n", "\t\tif (ctl->present < utmp_time)\n", "\t\t\treturn 0;\n", "\t\tif (0 < logout_time && logout_time < ctl->present)\n", "\t\t\treturn 0;\n", "\t}\n", "\n", "\t/* log-in time */\n", "\tif (time_formatter(fmt->in_fmt, logintime,\n", "\t\t\t   sizeof(logintime), &utmp_time) < 0)\n", "\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n", "\n", "\t/* log-out time */\n", "\tsecs  = logout_time - utmp_time; /* Under strange circumstances, secs < 0 can happen */\n", "\tmins  = (secs / 60) % 60;\n", "\thours = (secs / 3600) % 24;\n", "\tdays  = secs / 86400;\n", "\n", "\tstrcpy(logouttime, \"- \");\n", "\tif (time_formatter(fmt->out_fmt, logouttime + 2,\n", "\t\t\t   sizeof(logouttime) - 2, &logout_time) < 0)\n", "\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n", "\n", "\tif (logout_time == currentdate) {\n", "\t\tif (ctl->time_fmt > LAST_TIMEFTM_SHORT) {\n", "\t\t\tsprintf(logouttime, \"  still running\");\n", "\t\t\tlength[0] = 0;\n", "\t\t} else {\n", "\t\t\tsprintf(logouttime, \"  still\");\n", "\t\t\tsprintf(length, \"running\");\n", "\t\t}\n", "\t} else if (days) {\n", "\t\tsprintf(length, \"(%d+%02d:%02d)\", days, abs(hours), abs(mins)); /* hours and mins always shown as positive (w/o minus sign!) even if secs < 0 */\n", "\t} else if (hours) {\n", "\t\tsprintf(length, \" (%02d:%02d)\", hours, abs(mins));  /* mins always shown as positive (w/o minus sign!) even if secs < 0 */\n", "\t} else if (secs >= 0) {\n", "\t\tsprintf(length, \" (%02d:%02d)\", hours, mins); \n", "\t} else {\n", "\t\tsprintf(length, \" (-00:%02d)\", abs(mins));  /* mins always shown as positive (w/o minus sign!) even if secs < 0 */\n", "\t}\n", "\n", "\tswitch(what) {\n", "\t\tcase R_CRASH:\n", "\t\t\tsprintf(logouttime, \"- crash\");\n", "\t\t\tbreak;\n", "\t\tcase R_DOWN:\n", "\t\t\tsprintf(logouttime, \"- down \");\n", "\t\t\tbreak;\n", "\t\tcase R_NOW:\n", "\t\t\tif (ctl->time_fmt > LAST_TIMEFTM_SHORT) {\n", "\t\t\t\tsprintf(logouttime, \"  still logged in\");\n", "\t\t\t\tlength[0] = 0;\n", "\t\t\t} else {\n", "\t\t\t\tsprintf(logouttime, \"  still\");\n", "\t\t\t\tsprintf(length, \"logged in\");\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase R_PHANTOM:\n", "\t\t\tif (ctl->time_fmt > LAST_TIMEFTM_SHORT) {\n", "\t\t\t\tsprintf(logouttime, \"  gone - no logout\");\n", "\t\t\t\tlength[0] = 0;\n", "\t\t\t} else if (ctl->time_fmt == LAST_TIMEFTM_SHORT) {\n", "\t\t\t\tsprintf(logouttime, \"   gone\");\n", "\t\t\t\tsprintf(length, \"- no logout\");\n", "\t\t\t} else {\n", "\t\t\t\tlogouttime[0] = 0;\n", "\t\t\t\tsprintf(length, \"no logout\");\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase R_TIMECHANGE:\n", "\t\t\tlogouttime[0] = 0;\n", "\t\t\tlength[0] = 0;\n", "\t\t\tbreak;\n", "\t\tcase R_NORMAL:\n", "\t\tcase R_REBOOT:\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tabort();\n", "\t}\n", "\n", "\t/*\n", "\t *\tLook up host with DNS if needed.\n", "\t */\n", "\tr = -1;\n", "\tif (ctl->usedns || ctl->useip)\n", "\t\tr = dns_lookup(domain, sizeof(domain), ctl->useip, (int32_t*)p->ut_addr_v6);\n", "\tif (r < 0)\n", "\t\tmem2strcpy(domain, p->ut_host, sizeof(p->ut_host), sizeof(domain));\n", "\n", "\tif (ctl->showhost) {\n", "\t\tif (!ctl->altlist) {\n", "\t\t\tlen = snprintf(final, sizeof(final),\n", "\t\t\t\t\"%-8.*s %-12.12s %-16.*s %-*.*s %-*.*s %s\\n\",\n", "\t\t\t\tctl->name_len, p->ut_user, utline,\n", "\t\t\t\tctl->domain_len, domain,\n", "\t\t\t\tfmt->in_len, fmt->in_len, logintime, fmt->out_len, fmt->out_len,\n", "\t\t\t\tlogouttime, length);\n", "\t\t} else {\n", "\t\t\tlen = snprintf(final, sizeof(final),\n", "\t\t\t\t\"%-8.*s %-12.12s %-*.*s %-*.*s %-12.12s %s\\n\",\n", "\t\t\t\tctl->name_len, p->ut_user, utline,\n", "\t\t\t\tfmt->in_len, fmt->in_len, logintime, fmt->out_len, fmt->out_len,\n", "\t\t\t\tlogouttime, length, domain);\n", "\t\t}\n", "\t} else\n", "\t\tlen = snprintf(final, sizeof(final),\n", "\t\t\t\"%-8.*s %-12.12s %-*.*s %-*.*s %s\\n\",\n", "\t\t\tctl->name_len, p->ut_user, utline,\n", "\t\t\tfmt->in_len, fmt->in_len, logintime, fmt->out_len, fmt->out_len,\n", "\t\t\tlogouttime, length);\n", "\n", "#if defined(__GLIBC__)\n", "#  if (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)\n", "\tfinal[sizeof(final)-1] = '\\0';\n", "#  endif\n", "#endif\n", "\n", "\ttrim_trailing_spaces(final);\n", "\t/*\n", "\t *\tPrint out \"final\" string safely.\n", "\t */\n", "\tfor (s = final; *s; s++)\n", "\t\tfputc_careful(*s, stdout, '*');\n", "\n", "\tif (len < 0 || (size_t)len >= sizeof(final))\n", "\t\tputchar('\\n');\n", "\n", "\trecsdone++;\n", "\tif (ctl->maxrecs && ctl->maxrecs <= recsdone)\n", "\t\treturn 1;\n", "\n", "\treturn 0;\n", "}\n"], "project": "libblkid-dev", "file": "last.pkl", "function": "list"}, {"comment_all": {"comment": "/* if we didn't ref the channel, disconnecting the signal could\n     * destroy it */", "depth": 1, "reading_ease": 59.3, "reading_grade": 8.0, "line": 195}, "comment_text": "/* if we didn't ref the channel, disconnecting the signal could\n     * destroy it */", "comment_tokens": ["if", "we", "did", "n't", "ref", "the", "channel", ",", "disconnecting", "the", "signal", "could", "destroy", "it"], "ccode": ["\n", "static void\n", "ready_to_request_cb (McdRequest *request,\n", "                     McdChannel *channel)\n", "{\n", "    GError *error = _mcd_request_dup_failure (request);\n", "\n", "    /* if we didn't ref the channel, disconnecting the signal could\n", "     * destroy it */\n", "    g_object_ref (channel);\n", "    g_signal_handlers_disconnect_by_func (request, ready_to_request_cb,\n", "                                          channel);\n", "\n", "    if (error != NULL)\n", "    {\n", "        g_message (\"request denied by plugin: %s\", error->message);\n", "        mcd_channel_take_error (channel, error);\n", "    }\n", "    else\n", "    {\n", "        DEBUG (\"Starting online request\");\n", "        /* Put the account online if necessary, and when that's finished,\n", "         * make the actual request. (The callback releases this reference.) */\n", "        _mcd_account_online_request (_mcd_request_get_account (request),\n", "                                     online_request_cb,\n", "                                     g_object_ref (channel));\n", "    }\n", "\n", "    g_object_unref (channel);\n", "}\n"], "project": "libmission-control-plugins-doc", "file": "mcd-account-requests.pkl", "function": "ready_to_request_cb"}, {"comment_all": {"comment": "/* hdr (str type) */", "depth": 2, "reading_ease": 119.19, "reading_grade": -2.7, "line": 159}, "comment_text": "/* hdr (str type) */", "comment_tokens": ["hdr", "(", "str", "type", ")"], "ccode": ["\n", "\n", "\n", "static inline struct via_body* via_body_cloner( char* new_buf,\n", "\t\t\t\t\tchar *org_buf, struct via_body *param_org_via, char **p)\n", "{\n", "\tstruct via_body *new_via;\n", "\tstruct via_body *first_via, *last_via;\n", "\tstruct via_body *org_via;\n", "\n", "\tfirst_via = last_via = 0;\n", "\torg_via = param_org_via;\n", "\n", "\tdo\n", "\t{\n", "\t\t/* clones the via_body structure */\n", "\t\tnew_via = (struct via_body*)(*p);\n", "\t\tmemcpy( new_via , org_via , sizeof( struct via_body) );\n", "\t\t(*p) += ROUND4(sizeof( struct via_body ));\n", "\n", "\t\t/* hdr (str type) */\n", "\t\tnew_via->hdr.s=translate_pointer(new_buf,org_buf,org_via->hdr.s);\n", "\t\t/* name (str type) */\n", "\t\tnew_via->name.s=translate_pointer(new_buf,org_buf,org_via->name.s);\n", "\t\t/* version (str type) */\n", "\t\tnew_via->version.s=\n", "\t\t\ttranslate_pointer(new_buf,org_buf,org_via->version.s);\n", "\t\t/* transport (str type) */\n", "\t\tnew_via->transport.s=\n", "\t\t\ttranslate_pointer(new_buf,org_buf,org_via->transport.s);\n", "\t\t/* host (str type) */\n", "\t\tnew_via->host.s=translate_pointer(new_buf,org_buf,org_via->host.s);\n", "\t\t/* port_str (str type) */\n", "\t\tnew_via->port_str.s=\n", "\t\t\ttranslate_pointer(new_buf,org_buf,org_via->port_str.s);\n", "\t\t/* params (str type) */\n", "\t\tnew_via->params.s=translate_pointer(new_buf,org_buf,org_via->params.s);\n", "\t\t/* transaction id */\n", "\t\tnew_via->tid.s=\n", "\t\t\ttranslate_pointer(new_buf, org_buf, org_via->tid.s);\n", "\t\t/* comment (str type) */\n", "\t\tnew_via->comment.s=\n", "\t\t\ttranslate_pointer(new_buf,org_buf,org_via->comment.s);\n", "\n", "\t\tif ( org_via->param_lst )\n", "\t\t{\n", "\t\t\tstruct via_param *vp, *new_vp, *last_new_vp;\n", "\t\t\tfor( vp=org_via->param_lst, last_new_vp=0 ; vp ; vp=vp->next )\n", "\t\t\t{\n", "\t\t\t\tnew_vp = (struct via_param*)(*p);\n", "\t\t\t\tmemcpy( new_vp , vp , sizeof(struct via_param));\n", "\t\t\t\t(*p) += ROUND4(sizeof(struct via_param));\n", "\t\t\t\tnew_vp->name.s=translate_pointer(new_buf,org_buf,vp->name.s);\n", "\t\t\t\tnew_vp->value.s=translate_pointer(new_buf,org_buf,vp->value.s);\n", "\t\t\t\tnew_vp->start=translate_pointer(new_buf,org_buf,vp->start);\n", "\n", "\t\t\t\t/* \"translate\" the shortcuts */\n", "\t\t\t\tswitch(new_vp->type){\n", "\t\t\t\t\tcase PARAM_BRANCH:\n", "\t\t\t\t\t\t\tnew_via->branch = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase PARAM_RECEIVED:\n", "\t\t\t\t\t\t\tnew_via->received = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase PARAM_RPORT:\n", "\t\t\t\t\t\t\tnew_via->rport = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase PARAM_I:\n", "\t\t\t\t\t\t\tnew_via->i = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase PARAM_ALIAS:\n", "\t\t\t\t\t\t\tnew_via->alias = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "\n", "#ifdef USE_COMP\n", "\t\t\t\t\tcase PARAM_COMP:\n", "\t\t\t\t\t\t\tnew_via->comp = new_vp;\n", "\t\t\t\t\t\t\tbreak;\n", "#endif\n", "\t\t\t\t}\n", "\n", "\t\t\t\tif (last_new_vp)\n", "\t\t\t\t\tlast_new_vp->next = new_vp;\n", "\t\t\t\telse\n", "\t\t\t\t\tnew_via->param_lst = new_vp;\n", "\n", "\t\t\t\tlast_new_vp = new_vp;\n", "\t\t\t\tlast_new_vp->next = NULL;\n", "\t\t\t}\n", "\t\t\tnew_via->last_param = new_vp;\n", "\t\t}/*end if via has params */\n", "\n", "\t\tif (last_via)\n", "\t\t\tlast_via->next = new_via;\n", "\t\telse\n", "\t\t\tfirst_via = new_via;\n", "\t\tlast_via = new_via;\n", "\t\torg_via = org_via->next;\n", "\t}while(org_via);\n", "\n", "\treturn first_via;\n", "}\n"], "project": "kamailio-utils-modules", "file": "sip_msg_clone.pkl", "function": "via_body_cloner"}, {"comment_all": {"comment": "/* hum... big problem... */", "depth": 2, "reading_ease": 93.81, "reading_grade": 0.9, "line": 99}, "comment_text": "/* hum... big problem... */", "comment_tokens": ["hum", "...", "big", "problem", "..."], "ccode": ["\n", "void save_rc_file()\n", "{\n", "    FILE *out;\n", "    struct passwd *pw;\n", "    char st[128];\n", "\n", "    if (NULL == (pw = getpwuid(getuid()))) {\n", "\t/* hum... big problem... */\n", "        return;\n", "    } else {\n", "        sprintf(st, \"%s/.ascdrc\", pw->pw_dir);\n", "        if ((out = fopen(st, \"w\"))) {\n", "            fprintf(out, \"#### generated by AScd version %s ####\\n\", VERSION);\n", "#ifndef NO_D_DEVICE\n", "\t    fprintf(out, \"CD_DEVICE=%s\\n\", cd_device);\n", "#endif\t   \n", "\t    fprintf(out, \"THEME=%s\\n\", theme);\n", "\t    fprintf(out, \"VISU=%s\\n\", xv);\n", "            fprintf(out, \"AUTOREPEAT=%d\\n\", autorepeat);\n", "            fprintf(out, \"AUTOPLAY=%d\\n\", autoplay);\n", "            fprintf(out, \"AUTOPROBE=%d\\n\", autoprobe);\n", "            fprintf(out, \"CUE_TIME=%d\\n\", cue_time);\n", "            fprintf(out, \"TI=%d\\n\", text_timeout);\n", "            fprintf(out, \"VOLUME=%d\\n\", volume);\n", "            fprintf(out, \"MAX_VOL=%d\\n\", max_volume);\n", "            fprintf(out, \"MIN_VOL=%d\\n\", min_volume);\n", "            fprintf(out, \"MUT_VOL=%d\\n\", muted_volume);\n", "            fprintf(out, \"FADE_STEP=%d\\n\", fade_step);\n", "\t    fprintf(out, \"TIMEMODE=%d\\n\", time_mode);\n", "            fprintf(out, \"IGNORE_AVOID=%d\\n\", ignore_avoid);\n", "\t    if (withdrawn) {\n", "\t\tfprintf(out, \"WITHDRAWN\\n\");\n", "\t    }\n", "\t    if (show_db) {\n", "\t\tfprintf(out, \"SHOWDB\\n\");\n", "\t    }\n", "\t    if (show_artist) {\n", "\t\tfprintf(out, \"SHOWARTIST\\n\");\n", "\t    }\n", "\t    if (force_upper) {\n", "\t\tfprintf(out, \"UPPERCASE\\n\");\n", "\t    }\n", "\n", "            fclose(out);\n", "            return;\n", "        } else {\n", "            return;\n", "        }\n", "    }\n", "}\n"], "project": "ascd", "file": "misc.pkl", "function": "save_rc_file"}, {"comment_all": {"comment": "/* free(cl); */", "depth": 3, "reading_ease": 121.22, "reading_grade": -3.5, "line": 149}, "comment_text": "/* free(cl); */\n/* memory leak fix: SMJ, 4/24/2002 */\n/* free(cl); */\n/* memory leak fix: SMJ, 4/24/2002 */\n", "comment_tokens": ["free", "(", "cl", ")", ";", "memory", "leak", "fix", ":", "SMJ", ",", "4242002", "free", "(", "cl", ")", ";", "memory", "leak", "fix", ":", "SMJ", ",", "4242002"], "ccode": ["\n", "/**\n", " * Cons: Concatenate two s-expressions together, without references to the\n", " * originals.\n", " */\n", "sexp_t *cons_sexp(sexp_t *r, sexp_t *l) {\n", "  sexp_t *cr, *cl, *t;\n", "\n", "  cr = copy_sexp(r);\n", "  if (cr->ty == SEXP_VALUE) {\n", "    fprintf(stderr,\"Cannot cons non-lists.\\n\");\n", "    destroy_sexp(cr);\n", "    return NULL;\n", "  } else {\n", "    t = cr->list;\n", "    while (t != NULL && t->next != NULL) t = t->next;\n", "  }\n", "\n", "  cl = copy_sexp(l);\n", "\n", "  if (cl->ty == SEXP_LIST) {\n", "    if (t != NULL && cl != NULL) {\n", "      t->next = cl->list;\n", "      /* free(cl); */ /* memory leak fix: SMJ, 4/24/2002 */\n", "      sexp_t_deallocate(cl);\n", "    }\n", "  } else {\n", "    fprintf(stderr,\"Cannot cons non-lists.\\n\");\n", "    destroy_sexp(cr);\n", "    destroy_sexp(cl);\n", "    return NULL;\n", "  }\n", "\n", "  return cr;\n", "}\n"], "project": "orbital-eunuchs-sniper", "file": "sexp_ops.pkl", "function": "cons_sexp"}, {"comment_all": {"comment": "/* \n    Ringbuffer Implementation for gtvscreen\n\n    Copyright (C) 2000 Marcus Metzler (mocm@metzlerbros.de)\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "depth": 0, "reading_ease": 50.97, "reading_grade": 11.2, "line": 0}, "comment_text": "/* \n    Ringbuffer Implementation for gtvscreen\n\n    Copyright (C) 2000 Marcus Metzler (mocm@metzlerbros.de)\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "comment_tokens": ["Ringbuffer", "Implementation", "for", "gtvscreen", "Copyright", "(", "C", ")", "2000", "Marcus", "Metzler", "(", "mocm", "@", "metzlerbros.de", ")", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/* \n", "    Ringbuffer Implementation for gtvscreen\n", "\n", "    Copyright (C) 2000 Marcus Metzler (mocm@metzlerbros.de)\n", "\n", "    This program is free software; you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation; either version 2 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "\n", "    You should have received a copy of the GNU General Public License\n", "    along with this program; if not, write to the Free Software\n", "    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", "*/\n", "\n", "#include \"ringbuffy.h\"\n", "\n", "int ring_init (ringbuffy *rbuf, int size)\n", "{\n", "\tif (size > 0){\n", "\t\trbuf->size = size;\n", "\t\tif( !(rbuf->buffy = (char *) malloc(sizeof(char)*size)) ){\n", "\t\t\tfprintf(stderr,\"Not enough memory for ringbuffy\\n\");\n", "\t\t\treturn -1;\n", "\t\t}\n", "\t} else {\n", "\t\tfprintf(stderr,\"Wrong size for ringbuffy\\n\");\n", "\t\treturn -1;\n", "\t}\n", "\trbuf->read_pos = 0;\t\n", "\trbuf->write_pos = 0;\n", "\treturn 0;\n", "}\n"], "project": "dvbstream", "file": "ringbuffy.pkl", "function": "ring_init"}, {"comment_all": {"comment": "/* vim: set sw=2 et: */", "depth": 0, "reading_ease": 118.18, "reading_grade": -2.3, "line": 0}, "comment_text": "/* vim: set sw=2 et: */", "comment_tokens": ["vim", ":", "set", "sw=2", "et", ":"], "ccode": ["/* vim: set sw=2 et: */\n", "\n", "#include <gtk/gtk.h>\n", "\n", "static void\n", "set_urgent (GtkWidget *window,\n", "            gboolean   urgent)\n", "{\n", "  GtkWidget *label;\n", "\n", "  label = gtk_bin_get_child (GTK_BIN (window));\n", "\n", "  if (urgent)\n", "    {\n", "      gtk_window_set_urgency_hint (GTK_WINDOW (window), TRUE);\n", "      gtk_window_set_title (GTK_WINDOW (window), \"Test Window - Urgent\");\n", "      gtk_label_set_text (GTK_LABEL (label), \"I am urgent!\");\n", "    }\n", "  else\n", "    {\n", "      gtk_window_set_urgency_hint (GTK_WINDOW (window), FALSE);\n", "      gtk_window_set_title (GTK_WINDOW (window), \"Test Window\");\n", "      gtk_label_set_text (GTK_LABEL (label), \"I'm not urgent.\");\n", "    }\n", "}\n"], "project": "libwnck-doc", "file": "test-urgent.pkl", "function": "set_urgent"}, {"comment_all": {"comment": "/* Advance 'str' to after the expanded initial portion of the string */", "depth": 1, "reading_ease": 68.77, "reading_grade": 6.4, "line": 483}, "comment_text": "/* Advance 'str' to after the expanded initial portion of the string */", "comment_tokens": ["Advance", "'str", "'", "to", "after", "the", "expanded", "initial", "portion", "of", "the", "string"], "ccode": ["\n", "/*\n", " * Expand a string that follows '$'\n", " *\n", " * For example, if the input string is\n", " *     ($(FOO)$($(BAR)))$(BAZ)\n", " * this helper evaluates\n", " *     $($(FOO)$($(BAR)))\n", " * and returns a new string containing the expansion (note that the string is\n", " * recursively expanded), also advancing 'str' to point to the next character\n", " * after the corresponding closing parenthesis, in this case, *str will be\n", " *     $(BAR)\n", " */\n", "static char *expand_dollar_with_args(const char **str, int argc, char *argv[])\n", "{\n", "\tconst char *p = *str;\n", "\tconst char *q;\n", "\tint nest = 0;\n", "\n", "\t/*\n", "\t * In Kconfig, variable/function references always start with \"$(\".\n", "\t * Neither single-letter variables as in $A nor curly braces as in ${CC}\n", "\t * are supported.  '$' not followed by '(' loses its special meaning.\n", "\t */\n", "\tif (*p != '(') {\n", "\t\t*str = p;\n", "\t\treturn xstrdup(\"$\");\n", "\t}\n", "\n", "\tp++;\n", "\tq = p;\n", "\twhile (*q) {\n", "\t\tif (*q == '(') {\n", "\t\t\tnest++;\n", "\t\t} else if (*q == ')') {\n", "\t\t\tif (nest-- == 0)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\tq++;\n", "\t}\n", "\n", "\tif (!*q)\n", "\t\tpperror(\"unterminated reference to '%s': missing ')'\", p);\n", "\n", "\t/* Advance 'str' to after the expanded initial portion of the string */\n", "\t*str = q + 1;\n", "\n", "\treturn eval_clause(p, q - p, argc, argv);\n", "}\n"], "project": "linux-gcp-5.11-tools-5.11.0-1009", "file": "preprocess.pkl", "function": "expand_dollar_with_args"}, {"comment_all": {"comment": "/* Get list of \"local equivalent\" realms.  Meaning the list of realms\n\t * where john@REALM.A is considered the same user as john@REALM.B\n\t * If not specified, default to upper-case of local domain name */", "depth": 1, "reading_ease": 63.86, "reading_grade": 6.2, "line": 251}, "comment_text": "/* Get list of \"local equivalent\" realms.  Meaning the list of realms\n\t * where john@REALM.A is considered the same user as john@REALM.B\n\t * If not specified, default to upper-case of local domain name */", "comment_tokens": ["Get", "list", "of", "``", "local", "equivalent", "''", "realms", ".", "Meaning", "the", "list", "of", "realms", "where", "john", "@", "REALM.A", "is", "considered", "the", "same", "user", "as", "john", "@", "REALM.B", "If", "not", "specified", ",", "default", "to", "upper-case", "of", "local", "domain", "name"], "ccode": ["\n", "int nfs4_init_name_mapping(char *conffile)\n", "{\n", "\tint ret = -ENOENT;\n", "\tint dflt = 0;\n", "\tstruct conf_list *nfs4_methods, *gss_methods;\n", "\n", "\t/* XXX: need to be able to reload configurations... */\n", "\tif (nfs4_plugins) /* already succesfully initialized */\n", "\t\treturn 0;\n", "\tif (conffile)\n", "\t\tconf_path = conffile;\n", "\telse\n", "\t\tconf_path = PATH_IDMAPDCONF;\n", "\tconf_init();\n", "\tdefault_domain = conf_get_str(\"General\", \"Domain\");\n", "\tif (default_domain == NULL) {\n", "\t\tdflt = 1;\n", "\t\tret = domain_from_dns(&default_domain);\n", "\t\tif (ret) {\n", "\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Unable to determine \"\n", "\t\t\t\t  \"the NFSv4 domain; Using '%s' as the NFSv4 domain \"\n", "\t\t\t\t  \"which means UIDs will be mapped to the 'Nobody-User' \"\n", "\t\t\t\t  \"user defined in %s\\n\", \n", "\t\t\t\t  IDMAPD_DEFAULT_DOMAIN, PATH_IDMAPDCONF));\n", "\t\t\tdefault_domain = IDMAPD_DEFAULT_DOMAIN;\n", "\t\t}\n", "\t}\n", "\tIDMAP_LOG(1, (\"libnfsidmap: using%s domain: %s\",\n", "\t\t(dflt ? \" (default)\" : \"\"), default_domain));\n", "\n", "\t/* Get list of \"local equivalent\" realms.  Meaning the list of realms\n", "\t * where john@REALM.A is considered the same user as john@REALM.B\n", "\t * If not specified, default to upper-case of local domain name */\n", "\tlocal_realms = conf_get_list(\"General\", \"Local-Realms\");\n", "\tif (local_realms == NULL) {\n", "\t\tstruct conf_list_node *node;\n", "\n", "\t\tlocal_realms = malloc(sizeof *local_realms);\n", "\t\tif (local_realms == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\tlocal_realms->cnt = 0;\n", "\t\tTAILQ_INIT(&local_realms->fields);\n", "\n", "\t\tnode = calloc(1, sizeof *node);\n", "\t\tif (node == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\tnode->field = strdup(get_default_domain());\n", "\t\tif (node->field == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\ttoupper_str(node->field);\n", "\n", "\t\tTAILQ_INSERT_TAIL(&local_realms->fields, node, link);\n", "\t\tlocal_realms->cnt++;\n", "\t}\n", "\n", "\tif (idmap_verbosity >= 1) {\n", "\t\tstruct conf_list_node *r;\n", "\t\tchar *buf = NULL;\n", "\t\tint siz=0;\n", "\n", "\t\tif (local_realms) {\n", "\t\t\tTAILQ_FOREACH(r, &local_realms->fields, link) {\n", "\t\t\t\tsiz += (strlen(r->field)+4);\n", "\t\t\t}\n", "\t\t\tbuf = malloc(siz);\n", "\t\t\tif (buf) {\n", "\t\t\t\tTAILQ_FOREACH(r, &local_realms->fields, link) {\n", "\t\t\t\t\tsprintf(buf, \"'%s' \", r->field);\n", "\t\t\t\t}\n", "\t\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Realms list: %s\", buf));\n", "\t\t\t\tfree(buf);\n", "\t\t\t}\n", "\t\t} else \n", "\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Realms list: <NULL> \"));\n", "\t}\n", "\n", "\tnfs4_methods = conf_get_list(\"Translation\", \"Method\");\n", "\tif (nfs4_methods) {\n", "\t\tIDMAP_LOG(1, (\"libnfsidmap: processing 'Method' list\"));\n", "\t\tif (load_plugins(nfs4_methods, &nfs4_plugins) == -1)\n", "\t\t\treturn -ENOENT;\n", "\t} else {\n", "\t\tstruct conf_list list;\n", "\t\tstruct conf_list_node node;\n", "\n", "\t\tTAILQ_INIT(&list.fields);\n", "\t\tlist.cnt = 1;\n", "\t\tnode.field = \"nsswitch\";\n", "\t\tTAILQ_INSERT_TAIL (&list.fields, &node, link);\n", "\n", "\t\tif (load_plugins(&list, &nfs4_plugins) == -1)\n", "\t\t\treturn -ENOENT;\n", "\t}\n", "\n", "\tgss_methods = conf_get_list(\"Translation\", \"GSS-Methods\");\n", "\tif (gss_methods) {\n", "\t\tIDMAP_LOG(1, (\"libnfsidmap: processing 'GSS-Methods' list\"));\n", "\t\tif (load_plugins(gss_methods, &gss_plugins) == -1)\n", "\t\t\tgoto out;\n", "\t}\n", "\tret = 0;\n", "out:\n", "\tif (ret) {\n", "\t\tif (nfs4_plugins)\n", "\t\t\tunload_plugins(nfs4_plugins);\n", "\t\tif (gss_plugins)\n", "\t\t\tunload_plugins(gss_plugins);\n", "\t\tnfs4_plugins = gss_plugins = NULL;\n", "\t}\n", "\n", "\treturn ret ? -ENOENT: 0;\n", "}\n"], "project": "libnfsidmap-dev", "file": "libnfsidmap.pkl", "function": "nfs4_init_name_mapping"}, {"comment_all": {"comment": "/**\n * Initializes the wordbreak internals.  It currently does nothing, but\n * it may in the future.\n */", "depth": 0, "reading_ease": 64.37, "reading_grade": 6.0, "line": 61}, "comment_text": "/**\n * Initializes the wordbreak internals.  It currently does nothing, but\n * it may in the future.\n */", "comment_tokens": ["Initializes", "the", "wordbreak", "internals", ".", "It", "currently", "does", "nothing", ",", "but", "it", "may", "in", "the", "future", "."], "ccode": ["/* vim: set tabstop=4 shiftwidth=4: */\n", "\n", "/*\n", " * Word breaking in a Unicode sequence.  Designed to be used in a\n", " * generic text renderer.\n", " *\n", " * Copyright (C) 2013 Tom Hacohen <tom@stosb.com>\n", " *\n", " * This software is provided 'as-is', without any express or implied\n", " * warranty.  In no event will the author be held liable for any damages\n", " * arising from the use of this software.\n", " *\n", " * Permission is granted to anyone to use this software for any purpose,\n", " * including commercial applications, and to alter it and redistribute\n", " * it freely, subject to the following restrictions:\n", " *\n", " * 1. The origin of this software must not be misrepresented; you must\n", " *    not claim that you wrote the original software.  If you use this\n", " *    software in a product, an acknowledgement in the product\n", " *    documentation would be appreciated but is not required.\n", " * 2. Altered source versions must be plainly marked as such, and must\n", " *    not be misrepresented as being the original software.\n", " * 3. This notice may not be removed or altered from any source\n", " *    distribution.\n", " *\n", " * The main reference is Unicode Standard Annex 29 (UAX #29):\n", " *\t\t<URL:http://unicode.org/reports/tr29>\n", " *\n", " * When this library was designed, this annex was at Revision 17, for\n", " * Unicode 6.0.0:\n", " *\t\t<URL:http://www.unicode.org/reports/tr29/tr29-17.html>\n", " *\n", " * This library has been updated according to Revision 21, for\n", " * Unicode 6.2.0:\n", " *\t\t<URL:http://www.unicode.org/reports/tr29/tr29-21.html>\n", " *\n", " * The Unicode Terms of Use are available at\n", " *\t\t<URL:http://www.unicode.org/copyright.html>\n", " */\n", "\n", "/**\n", " * @file\twordbreak.c\n", " *\n", " * Implementation of the word breaking algorithm as described in Unicode\n", " * Standard Annex 29.\n", " *\n", " * @version\t2.4, 2013/09/28\n", " * @author\tTom Hacohen\n", " */\n", "\n", "#include <assert.h>\n", "#include <stddef.h>\n", "#include <string.h>\n", "#include \"linebreak.h\"\n", "#include \"linebreakdef.h\"\n", "\n", "#include \"wordbreak.h\"\n", "#include \"wordbreakdata.c\"\n", "\n", "#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))\n", "\n", "/**\n", " * Initializes the wordbreak internals.  It currently does nothing, but\n", " * it may in the future.\n", " */\n", "void init_wordbreak(void)\n", "{\n", "}\n"], "project": "libunibreak-doc", "file": "wordbreak.pkl", "function": "init_wordbreak"}, {"comment_all": {"comment": "/** Get the current token.\n * @param yyscanner The scanner object.\n */", "depth": 0, "reading_ease": 66.91, "reading_grade": 5.0, "line": 2464}, "comment_text": "/** Get the current token.\n * @param yyscanner The scanner object.\n */", "comment_tokens": ["Get", "the", "current", "token", ".", "@", "param", "yyscanner", "The", "scanner", "object", "."], "ccode": ["\n", "/** Get the current token.\n", " * @param yyscanner The scanner object.\n", " */\n", "\n", "char *turtle_lexer_get_text  (yyscan_t yyscanner)\n", "{\n", "    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n", "    return yytext;\n", "}\n"], "project": "libraptor2-dev", "file": "turtle_lexer.pkl", "function": "turtle_lexer_get_text"}, {"comment_all": {"comment": "/* Compare two attributes structures.  */", "depth": 0, "reading_ease": 50.5, "reading_grade": 7.2, "line": 456}, "comment_text": "/* Compare two attributes structures.  */", "comment_tokens": ["Compare", "two", "attributes", "structures", "."], "ccode": ["\n", "/* Compare two attributes structures.  */\n", "\n", "static const char *\n", "simple_object_coff_attributes_merge (void *todata, void *fromdata, int *err)\n", "{\n", "  struct simple_object_coff_attributes *to =\n", "    (struct simple_object_coff_attributes *) todata;\n", "  struct simple_object_coff_attributes *from =\n", "    (struct simple_object_coff_attributes *) fromdata;\n", "\n", "  if (to->magic != from->magic || to->is_big_endian != from->is_big_endian)\n", "    {\n", "      *err = 0;\n", "      return \"COFF object format mismatch\";\n", "    }\n", "  return NULL;\n", "}\n"], "project": "binutils-sh4-linux-gnu-dbg", "file": "simple-object-coff.pkl", "function": "simple_object_coff_attributes_merge"}, {"comment_all": {"comment": "// otherwise ignore the trigger\n", "depth": 4, "reading_ease": 33.58, "reading_grade": 9.6, "line": 284}, "comment_text": "// start a conversion only if it's not running\n// otherwise ignore the trigger\n", "comment_tokens": ["start", "a", "conversion", "only", "if", "it", "'s", "not", "running", "otherwise", "ignore", "the", "trigger"], "ccode": ["\n", "static void\n", "avr_adc_irq_notify(\n", "\t\tstruct avr_irq_t * irq, uint32_t value, void * param)\n", "{\n", "\tavr_adc_t * p = (avr_adc_t *)param;\n", "\tavr_t * avr = p->io.avr;\n", "\n", "\tswitch (irq->irq) {\n", "\t\tcase ADC_IRQ_ADC0 ... ADC_IRQ_ADC7: {\n", "\t\t\tp->adc_values[irq->irq] = value;\n", "\t\t} \tbreak;\n", "\t\tcase ADC_IRQ_TEMP: {\n", "\t\t\tp->temp = value;\n", "\t\t}\tbreak;\n", "\t\tcase ADC_IRQ_IN_TRIGGER: {\n", "\t\t\tif (avr_regbit_get(avr, p->adate)) {\n", "\t\t\t\t// start a conversion only if it's not running\n", "\t\t\t\t// otherwise ignore the trigger\n", "\t\t\t\tif(!avr_regbit_get(avr, p->adsc) ) {\n", "\t\t\t  \t\tuint8_t addr = p->adsc.reg;\n", "\t\t\t\t\tif (addr) {\n", "\t\t\t\t\t\tuint8_t val = avr->data[addr] | (1 << p->adsc.bit);\n", "\t\t\t\t\t\t// write ADSC to ADCSRA\n", "\t\t\t\t\t\tavr_adc_write_adcsra(avr, addr, val, param);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\tbreak;\n", "\t}\n", "}\n"], "project": "libsimavr-examples", "file": "avr_adc.pkl", "function": "avr_adc_irq_notify"}, {"comment_all": {"comment": "/**\n                 * All profile classes are defined as strings\n                 * in format that is command line friendly.\n                 *\n                 * This effectively simulates series of -e command\n                 * line options. \"llc:\" is glued to each of the strings\n                 * so that profile class definitions don't have to\n                 * include it.\n                 */", "depth": 2, "reading_ease": 66.03, "reading_grade": 7.5, "line": 366}, "comment_text": "/**\n                 * All profile classes are defined as strings\n                 * in format that is command line friendly.\n                 *\n                 * This effectively simulates series of -e command\n                 * line options. \"llc:\" is glued to each of the strings\n                 * so that profile class definitions don't have to\n                 * include it.\n                 */", "comment_tokens": ["All", "profile", "classes", "are", "defined", "as", "strings", "in", "format", "that", "is", "command", "line", "friendly", ".", "This", "effectively", "simulates", "series", "of", "-e", "command", "line", "options", ".", "``", "llc", ":", "''", "is", "glued", "to", "each", "of", "the", "strings", "so", "that", "profile", "class", "definitions", "do", "n't", "have", "to", "include", "it", "."], "ccode": ["\n", "int\n", "profile_l3ca_apply(const char *name,\n", "                   const struct pqos_capability *cap_l3ca)\n", "{\n", "        unsigned cnum = 0;\n", "        const char * const *cptr = NULL;\n", "\n", "        if (cap_l3ca != NULL &&\n", "            profile_l3ca_get(name, cap_l3ca->u.l3ca, &cnum,\n", "                             &cptr) == PQOS_RETVAL_OK) {\n", "                /**\n", "                 * All profile classes are defined as strings\n", "                 * in format that is command line friendly.\n", "                 *\n", "                 * This effectively simulates series of -e command\n", "                 * line options. \"llc:\" is glued to each of the strings\n", "                 * so that profile class definitions don't have to\n", "                 * include it.\n", "                 */\n", "                char cb[64];\n", "                unsigned i = 0, offset = 0;\n", "\n", "                memset(cb, 0, sizeof(cb));\n", "                strcpy(cb, \"llc:\");\n", "                offset = (unsigned)strlen(\"llc:\");\n", "\n", "                for (i = 0; i < cnum; i++) {\n", "                        strncpy(cb+offset, cptr[i],\n", "                                sizeof(cb)-1-offset);\n", "                        selfn_allocation_class(cb);\n", "                }\n", "        } else {\n", "                printf(\"Allocation profile '%s' not found or \"\n", "                       \"cache allocation not supported!\\n\",\n", "                       name);\n", "                return -1;\n", "        }\n", "\n", "        return 0;\n", "}\n"], "project": "intel-cmt-cat", "file": "profiles.pkl", "function": "profile_l3ca_apply"}, {"comment_all": {"comment": "/* LibTomCrypt, modular cryptographic library -- Tom St Denis\n *\n * LibTomCrypt is a library that provides various cryptographic\n * algorithms in a highly modular and flexible manner.\n *\n * The library is free for all purposes without any express\n * guarantee it works.\n */", "depth": 0, "reading_ease": 27.83, "reading_grade": 13.9, "line": 0}, "comment_text": "/* LibTomCrypt, modular cryptographic library -- Tom St Denis\n *\n * LibTomCrypt is a library that provides various cryptographic\n * algorithms in a highly modular and flexible manner.\n *\n * The library is free for all purposes without any express\n * guarantee it works.\n */", "comment_tokens": ["LibTomCrypt", ",", "modular", "cryptographic", "library", "--", "Tom", "St", "Denis", "LibTomCrypt", "is", "a", "library", "that", "provides", "various", "cryptographic", "algorithms", "in", "a", "highly", "modular", "and", "flexible", "manner", ".", "The", "library", "is", "free", "for", "all", "purposes", "without", "any", "express", "guarantee", "it", "works", "."], "ccode": ["/* LibTomCrypt, modular cryptographic library -- Tom St Denis\n", " *\n", " * LibTomCrypt is a library that provides various cryptographic\n", " * algorithms in a highly modular and flexible manner.\n", " *\n", " * The library is free for all purposes without any express\n", " * guarantee it works.\n", " */\n", "\n", "#include \"tomcrypt.h\"\n", "\n", "#ifdef LTC_BLAKE2SMAC\n", "\n", "/**\n", "   BLAKE2S MAC a block of memory to produce the authentication tag\n", "   @param key       The secret key\n", "   @param keylen    The length of the secret key (octets)\n", "   @param in        The data to BLAKE2S MAC\n", "   @param inlen     The length of the data to BLAKE2S MAC (octets)\n", "   @param mac       [out] Destination of the authentication tag\n", "   @param maclen    [in/out] Max size and resulting size of authentication tag\n", "   @return CRYPT_OK if successful\n", "*/\n", "int blake2smac_memory(const unsigned char *key, unsigned long keylen, const unsigned char *in, unsigned long inlen, unsigned char *mac, unsigned long *maclen)\n", "{\n", "   blake2smac_state st;\n", "   int err;\n", "\n", "   LTC_ARGCHK(key    != NULL);\n", "   LTC_ARGCHK(in     != NULL);\n", "   LTC_ARGCHK(mac    != NULL);\n", "   LTC_ARGCHK(maclen != NULL);\n", "\n", "   if ((err = blake2smac_init(&st, *maclen, key, keylen))  != CRYPT_OK) { goto LBL_ERR; }\n", "   if ((err = blake2smac_process(&st, in, inlen)) != CRYPT_OK) { goto LBL_ERR; }\n", "   err = blake2smac_done(&st, mac, maclen);\n", "LBL_ERR:\n", "#ifdef LTC_CLEAN_STACK\n", "   zeromem(&st, sizeof(blake2smac_state));\n", "#endif\n", "   return err;\n", "}\n"], "project": "libtomcrypt-dev", "file": "blake2smac_memory.pkl", "function": "blake2smac_memory"}, {"comment_all": {"comment": "/*\nHelper functions specific to alttab.\n\nCopyright 2017-2018 Alexander Kulak.\nThis file is part of alttab program.\n\nalttab is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nalttab is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with alttab.  If not, see <http://www.gnu.org/licenses/>.\n*/", "depth": 0, "reading_ease": 57.27, "reading_grade": 8.8, "line": 17}, "comment_text": "/*\nHelper functions specific to alttab.\n\nCopyright 2017-2018 Alexander Kulak.\nThis file is part of alttab program.\n\nalttab is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nalttab is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with alttab.  If not, see <http://www.gnu.org/licenses/>.\n*/", "comment_tokens": ["Helper", "functions", "specific", "to", "alttab", ".", "Copyright", "2017-2018", "Alexander", "Kulak", ".", "This", "file", "is", "part", "of", "alttab", "program", ".", "alttab", "is", "free", "software", ":", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ",", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "alttab", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "alttab", ".", "If", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", "Helper functions specific to alttab.\n", "\n", "Copyright 2017-2018 Alexander Kulak.\n", "This file is part of alttab program.\n", "\n", "alttab is free software: you can redistribute it and/or modify\n", "it under the terms of the GNU General Public License as published by\n", "the Free Software Foundation, either version 3 of the License, or\n", "(at your option) any later version.\n", "\n", "alttab is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with alttab.  If not, see <http://www.gnu.org/licenses/>.\n", "*/\n", "\n", "#include \"alttab.h\"\n", "extern Globals g;\n", "//extern Display* dpy;\n", "//extern int scr;\n", "//extern Window root;\n", "\n", "// PUBLIC\n", "\n", "//\n", "// diagnostic message\n", "//\n", "void msg(int lvl, const char *format, ...)\n", "{\n", "    if (g.debug > lvl) {\n", "        if (lvl == -1) {\n", "            fprintf(stderr, MSGPREFIX);\n", "        }\n", "        va_list ap;\n", "        va_start(ap, format);\n", "        vfprintf(stderr, format, ap);\n", "        va_end(ap);\n", "    }\n", "}\n"], "project": "alttab", "file": "autil.pkl", "function": "msg"}, {"comment_all": {"comment": "/* Call a user function for each allocated item in a bitmap */", "depth": 0, "reading_ease": 68.77, "reading_grade": 6.4, "line": 418}, "comment_text": "/* Call a user function for each allocated item in a bitmap */", "comment_tokens": ["Call", "a", "user", "function", "for", "each", "allocated", "item", "in", "a", "bitmap"], "ccode": ["\n", "/* Call a user function for each allocated item in a bitmap */\n", "void vmfs_bitmap_foreach(vmfs_bitmap_t *b,vmfs_bitmap_foreach_cbk_t cbk,\n", "                         void *opt_arg)\n", "{\n", "   u_int i;\n", "   \n", "   for(i=0;i<b->bmh.area_count;i++)\n", "      vmfs_bitmap_area_foreach(b,i,cbk,opt_arg);\n", "}\n"], "project": "vmfs6-tools", "file": "vmfs_bitmap.pkl", "function": "vmfs_bitmap_foreach"}, {"comment_all": {"comment": "/* The terminal can't scroll forward... */", "depth": 4, "reading_ease": 66.4, "reading_grade": 5.2, "line": 1803}, "comment_text": "/* The terminal can't scroll forward... */", "comment_tokens": ["The", "terminal", "ca", "n't", "scroll", "forward", "..."], "ccode": ["/* he_scroll_down */\n", "\n", "  void\n", "he_scroll_up(struct he_s *hedit, int count)\n", "{\n", "  if (!count) return;\n", "  assert(count > 0);\n", "  while (count--) {\n", "    if (hedit->position < hedit->screen_offset + 16) break;\n", "    hedit->screen_offset += 16;\n", "    if (!hedit->refresh.flag) {\n", "      if (tio_scroll_up(1, 0, hx_lines - 2)) {\n", "        /* The terminal can't scroll forward... */\n", "        hedit->refresh.flag = 1;\n", "        hedit->refresh.first[0] = 0;\n", "        hedit->refresh.last[0] = -1;\n", "        hedit->refresh.parts = 1;\n", "      }\n", "      tio_goto_line(hx_lines - 2);\n", "      tio_return();\n", "      tio_display(he_line(hedit, hedit->screen_offset + (hx_lines - 2) * 16), 0);\n", "    } else {\n", "      hedit->refresh.first[0] = 0;\n", "      hedit->refresh.last[0] = -1;\n", "      hedit->refresh.parts = 1;\n", "    }\n", "  }\n", "}\n"], "project": "hexer", "file": "edit.pkl", "function": "he_scroll_up"}, {"comment_all": {"comment": "/*\n * Scan the files in a configuration directory.\n */", "depth": 0, "reading_ease": 30.53, "reading_grade": 10.7, "line": 294}, "comment_text": "/*\n * Scan the files in a configuration directory.\n */", "comment_tokens": ["Scan", "the", "files", "in", "a", "configuration", "directory", "."], "ccode": ["\n", "/*****************************************************************************/\n", "/*\n", " * Scan the files in a configuration directory.\n", " */\n", "static void scan_conf_dir(struct parameters *params, const char *confdir)\n", "{\n", "\tstruct dirent *d;\n", "\tDIR *dir;\n", "\tint l;\n", "\n", "\tdebug(\"__ SCAN %s __\\n\", confdir);\n", "\n", "\tdir = opendir(confdir);\n", "\tif (!dir) {\n", "\t\tif (errno == ENOENT)\n", "\t\t\treturn;\n", "\t\terror(\"Cannot open %s: %m\\n\", confdir);\n", "\t}\n", "\n", "\twhile ((d = readdir(dir))) {\n", "\t\tif (d->d_name[0] == '.')\n", "\t\t\tcontinue;\n", "\t\tif (d->d_type != DT_UNKNOWN && d->d_type != DT_REG)\n", "\t\t\tcontinue;\n", "\t\tl = strlen(d->d_name);\n", "\t\tif (l < 5)\n", "\t\t\tcontinue;\n", "\t\tif (memcmp(d->d_name + l - 5, \".conf\", 5) != 0)\n", "\t\t\tcontinue;\n", "\t\tscan_conf_file(params, dirfd(dir), d->d_name);\n", "\t}\n", "\n", "\tclosedir(dir);\n", "}\n"], "project": "keyutils", "file": "request-key.pkl", "function": "scan_conf_dir"}, {"comment_all": {"comment": "/* Load and parse the resource file if it exists.  */", "depth": 0, "reading_ease": 96.18, "reading_grade": 2.1, "line": 76}, "comment_text": "/* Load and parse the resource file if it exists.  */", "comment_tokens": ["Load", "and", "parse", "the", "resource", "file", "if", "it", "exists", "."], "ccode": ["/* rcfile.c\n", "\n", "   Functions for use with the XML resource file facility.\n", "\n", "   Copyright (C) 2002 Tim Stadelmann\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software Foundation,\n", "   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n", "\f\n", "\n", "\n", "/** HEADERS **/\n", "\n", "/* autoconf header */\n", "#if HAVE_CONFIG_H\n", "#  include <config.h>\n", "#endif\n", "\n", "/* ISO C headers */\n", "#include <errno.h>\n", "#include <string.h>\n", "\n", "/* POSIX headers */\n", "#include <sys/types.h>\n", "#include <sys/wait.h>\n", "\n", "/* UNIX headers */\n", "#include <iconv.h>\n", "#include <langinfo.h>\n", "\n", "/* XML headers */\n", "#include <libxml/parser.h>\n", "#include <libxml/tree.h>\n", "\n", "/* program headers */\n", "#include \"hotswap.h\"\n", "#include \"rcfile.h\"\n", "\n", "#if ENABLE_NLS\n", "#  include <libintl.h>\n", "#  define _(Text) gettext (Text)\n", "#else\n", "#  define _(Text) Text\n", "#endif\n", "\n", "/* the path of the resource file */\n", "#ifndef RCFILE\n", "#define RCFILE \"/etc/hotswaprc\"\n", "#endif /* RCFILE */\n", "\f\n", "\n", "\n", "/** GLOBAL VARIABLES **/\n", "\n", "static xmlDocPtr doc;\t        /* a pointer to the document structure */\n", "static xmlNodePtr root;\t\t/* a pointer to the root node */\n", "static iconv_t descriptor;\t/* for data set conversion */\n", "static char *buffer = NULL;     /* a buffer for charset conversion */\n", "static size_t size = 0;\t\t/* the buffer size */\n", "static const size_t block = 256; /* the allocation block size */\n", "\f\n", "\n", "\n", "/** FUNCTIONS **/\n", "\n", "/* Load and parse the resource file if it exists.  */\n", "\n", "void\n", "init_rcfile ()\n", "{\n", "  /* Open a descriptor for converting from UTF-8 to the current\n", "     character set.  */\n", "  descriptor = iconv_open (nl_langinfo (CODESET), \"UTF-8\");\n", "\n", "  if (settings.verbose)\n", "    {\n", "      printf (\"%s: \", program_name);\n", "      printf (_(\"trying to open the resource file (%s)\\n\"), RCFILE);\n", "    }\n", "\n", "  /* Try to open the resource file.  */\n", "  doc = xmlParseFile (RCFILE);\n", "\n", "  if (doc)\n", "    {\n", "      if (settings.verbose)\n", "\t{\n", "\t  printf (\"%s: \", program_name);\n", "\t  puts (_(\"reading the resource file\"));\n", "\t}\n", "      root = xmlDocGetRootElement (doc);\n", "    }\n", "}\n"], "project": "hotswap-text", "file": "rcfile.pkl", "function": "init_rcfile"}, {"comment_all": {"comment": "/* Read the next character, return EOF if none available.\n   Assume that STREAM is positioned so that the next byte read\n   is at address ADDRESS in the file.\n\n   If STREAM is NULL, do not read from it.\n   The caller can supply a buffer of characters\n   to be processed before the data in STREAM.\n   MAGIC is the address of the buffer and\n   MAGICCOUNT is how many characters are in it.  */", "depth": 0, "reading_ease": 74.59, "reading_grade": 6.2, "line": 444}, "comment_text": "/* Read the next character, return EOF if none available.\n   Assume that STREAM is positioned so that the next byte read\n   is at address ADDRESS in the file.\n\n   If STREAM is NULL, do not read from it.\n   The caller can supply a buffer of characters\n   to be processed before the data in STREAM.\n   MAGIC is the address of the buffer and\n   MAGICCOUNT is how many characters are in it.  */", "comment_tokens": ["Read", "the", "next", "character", ",", "return", "EOF", "if", "none", "available", ".", "Assume", "that", "STREAM", "is", "positioned", "so", "that", "the", "next", "byte", "read", "is", "at", "address", "ADDRESS", "in", "the", "file", ".", "If", "STREAM", "is", "NULL", ",", "do", "not", "read", "from", "it", ".", "The", "caller", "can", "supply", "a", "buffer", "of", "characters", "to", "be", "processed", "before", "the", "data", "in", "STREAM", ".", "MAGIC", "is", "the", "address", "of", "the", "buffer", "and", "MAGICCOUNT", "is", "how", "many", "characters", "are", "in", "it", "."], "ccode": ["\f\n", "/* Read the next character, return EOF if none available.\n", "   Assume that STREAM is positioned so that the next byte read\n", "   is at address ADDRESS in the file.\n", "\n", "   If STREAM is NULL, do not read from it.\n", "   The caller can supply a buffer of characters\n", "   to be processed before the data in STREAM.\n", "   MAGIC is the address of the buffer and\n", "   MAGICCOUNT is how many characters are in it.  */\n", "\n", "static long\n", "get_char (FILE *stream, file_ptr *address, int *magiccount, char **magic)\n", "{\n", "  int c, i;\n", "  long r = 0;\n", "\n", "  for (i = 0; i < encoding_bytes; i++)\n", "    {\n", "      if (*magiccount)\n", "\t{\n", "\t  (*magiccount)--;\n", "\t  c = *(*magic)++;\n", "\t}\n", "      else\n", "\t{\n", "\t  if (stream == NULL)\n", "\t    return EOF;\n", "\n", "\t  /* Only use getc_unlocked if we found a declaration for it.\n", "\t     Otherwise, libc is not thread safe by default, and we\n", "\t     should not use it.  */\n", "\n", "#if defined(HAVE_GETC_UNLOCKED) && HAVE_DECL_GETC_UNLOCKED\n", "\t  c = getc_unlocked (stream);\n", "#else\n", "\t  c = getc (stream);\n", "#endif\n", "\t  if (c == EOF)\n", "\t    return EOF;\n", "\t}\n", "\n", "      (*address)++;\n", "      r = (r << 8) | (c & 0xff);\n", "    }\n", "\n", "  switch (encoding)\n", "    {\n", "    default:\n", "      break;\n", "    case 'l':\n", "      r = ((r & 0xff) << 8) | ((r & 0xff00) >> 8);\n", "      break;\n", "    case 'L':\n", "      r = (((r & 0xff) << 24) | ((r & 0xff00) << 8)\n", "\t   | ((r & 0xff0000) >> 8) | ((r & 0xff000000) >> 24));\n", "      break;\n", "    }\n", "\n", "  return r;\n", "}\n"], "project": "binutils-powerpc64le-linux-gnu-dbg", "file": "strings.pkl", "function": "get_char"}, {"comment_all": {"comment": "/* Callback function for AVL tree functions. */", "depth": 0, "reading_ease": 73.85, "reading_grade": 4.5, "line": 56}, "comment_text": "/* Callback function for AVL tree functions. */", "comment_tokens": ["Callback", "function", "for", "AVL", "tree", "functions", "."], "ccode": ["\n", "/* Variables. ===============================================================*/\n", "\n", "static avln_node_t *symbol_tree; /* The symbol table, sorted by names.\n", "\t\t\t\t  * This is actually a symbol_node_t. */\n", "static avl_node_t *atoms_tree; /* The symbol table, sorted by atoms.\n", "\t\t\t\t* This is actually a atoms_node_t. */\n", "\n", "static pool_t symbol_pool; /* Symbol entries. */\n", "static pool_t value_pool; /* Lists of atomic symbols. */\n", "static pool_t string_pool; /* Symbol names. */\n", "\n", "/* Functions. ===============================================================*/\n", "\n", "static int_t \n", "compare_by_atoms( avl_node_t *node1, avl_node_t *node2 )\n", "/* Callback function for AVL tree functions. */\n", "{\n", "  return compare_atom_lists( ((atoms_node_t *) node1)->atoms,\n", "                             ((atoms_node_t *) node2)->atoms );\n", "}\n"], "project": "libmalaga-dev", "file": "sym_compiler.pkl", "function": "compare_by_atoms"}, {"comment_all": {"comment": "/* all new prefs must be created first */", "depth": 1, "reading_ease": 89.75, "reading_grade": 2.5, "line": 591}, "comment_text": "/* all new prefs must be created first */", "comment_tokens": ["all", "new", "prefs", "must", "be", "created", "first"], "ccode": ["\n", "static gboolean\n", "plugin_load(\n", "    PurplePlugin * plugin)\n", "{\n", "    GList *iter;\n", "    PurplePlugin *prpl;\n", "    PurplePluginProtocolInfo *prpl_info;\n", "    PurpleAccountOption *option;\n", "\n", "    purple_prefs_add_none(\"/plugins\");\n", "    purple_prefs_add_none(\"/plugins/core\");\n", "    purple_prefs_add_none(\"/plugins/core/\" PLUGIN_ID);\n", "\n", "    purple_prefs_add_string(\"/plugins/core/\" PLUGIN_ID \"/question\", _(\"How do you spell the number 10?\"));\n", "    purple_prefs_add_string(\"/plugins/core/\" PLUGIN_ID \"/answer\", _(\"ten\"));\n", "\n", "    purple_prefs_add_bool(\"/plugins/core/\" PLUGIN_ID \"/auto_add_permit\", FALSE);\n", "    purple_prefs_add_bool(\"/plugins/core/\" PLUGIN_ID \"/auto_add_buddy\", FALSE);\n", "\n", "#if ( PURPLE_MAJOR_VERSION == 2 && PURPLE_MINOR_VERSION >= 3 ) || PURPLE_MAJOR_VERSION > 2\n", "    purple_prefs_add_int(\"/plugins/core/\" PLUGIN_ID \"/auth_policy\", auth_choice_PROMPT);\n", "#endif\n", "\n", "    /* all new prefs must be created first */\n", "    purple_prefs_rename(\"/plugins/core/gaim_bs\", \"/plugins/core/\" PLUGIN_ID);\n", "    purple_prefs_rename(\"/plugins/core/pidgin_bs\", \"/plugins/core/\" PLUGIN_ID);\n", "\n", "    /* enable bot sentry account by account */\n", "    for (iter = purple_plugins_get_protocols(); iter; iter = iter->next) {\n", "        prpl = iter->data;\n", "        if (NULL == prpl) {\n", "            return FALSE;\n", "        }\n", "        prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);\n", "        if (NULL == prpl_info) {\n", "            return FALSE;\n", "        }\n", "        option = purple_account_option_bool_new(_(\"Use Bot Sentry with this account\"), PLUGIN_ID \"-enabled\", TRUE);\n", "        prpl_info->protocol_options = g_list_append(prpl_info->protocol_options, option);\n", "    }\n", "\n", "    purple_signal_connect(purple_conversations_get_handle(), \"receiving-im-msg\", plugin, PURPLE_CALLBACK(receiving_im_msg_cb), NULL);\n", "\n", "#if ( PURPLE_MAJOR_VERSION == 2 && PURPLE_MINOR_VERSION >= 3 ) || PURPLE_MAJOR_VERSION > 2\n", "    purple_signal_connect(purple_accounts_get_handle(), \"account-authorization-requested\", plugin, PURPLE_CALLBACK(account_authorization_requested_cb), NULL);\n", "#endif\n", "\n", "    purple_signal_connect(purple_plugins_get_handle(), \"plugin-load\", plugin, PURPLE_CALLBACK(plugin_load_cb), NULL);\n", "\n", "    callback_id = purple_prefs_connect_callback(purple_prefs_get_handle(), \"/plugins/core/psychic/buddies_only\", plugin_prefs_cb, NULL);\n", "\n", "    fix_psychic_settings();\n", "\n", "    return TRUE;\n", "}\n"], "project": "pidgin-bot-sentry", "file": "bot-sentry.pkl", "function": "plugin_load"}, {"comment_all": {"comment": "/*\n**  Open a file in append mode.  Since not all fopen's set the O_APPEND\n**  flag, we do it by hand.\n*/", "depth": 0, "reading_ease": 104.13, "reading_grade": 1.1, "line": 10}, "comment_text": "/*\n**  Open a file in append mode.  Since not all fopen's set the O_APPEND\n**  flag, we do it by hand.\n*/", "comment_tokens": ["Open", "a", "file", "in", "append", "mode", ".", "Since", "not", "all", "fopen", "'s", "set", "the", "O_APPEND", "flag", ",", "we", "do", "it", "by", "hand", "."], "ccode": ["/*  $Revision: 1.2 $\n", "**\n", "*/\n", "#include <stdio.h>\n", "#include <sys/types.h>\n", "#include \"configdata.h\"\n", "#include \"clibrary.h\"\n", "#include <fcntl.h>\n", "\n", "\n", "/*\n", "**  Open a file in append mode.  Since not all fopen's set the O_APPEND\n", "**  flag, we do it by hand.\n", "*/\n", "FILE *\n", "xfopena(p)\n", "    char\t*p;\n", "{\n", "    int\t\tfd;\n", "\n", "    /* We can't trust stdio to really use O_APPEND, so open, then fdopen. */\n", "    fd = open(p, O_WRONLY | O_APPEND | O_CREAT, 0666);\n", "    return fd >= 0 ? fdopen(fd, \"a\") : NULL;\n", "}\n"], "project": "inn", "file": "xfopena.pkl", "function": "xfopena"}, {"comment_all": {"comment": "/*-------------------------------------------------------------------------\n\tIndexing\n-------------------------------------------------------------------------*/", "depth": 0, "reading_ease": -47.99, "reading_grade": 20.2, "line": 178}, "comment_text": "/*-------------------------------------------------------------------------\n\tIndexing\n-------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "Indexing", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "\n", "/*-------------------------------------------------------------------------\n", "\tIndexing\n", "-------------------------------------------------------------------------*/\n", "\n", "VMM_Mode *vmm_FindMode(int id)\n", "{\n", "\tVMM_Mode *m = vmm_First();\n", "\twhile(m)\n", "\t{\n", "\t\tif(m->id == id)\n", "\t\t\treturn m;\n", "\t\tm = vmm_Next(m);\n", "\t}\n", "\treturn NULL;\n", "}\n"], "project": "kobodeluxe", "file": "vidmodes.pkl", "function": "vmm_FindMode"}, {"comment_all": {"comment": "/*\n   * Find out the masks for the NumLock and ScrollLock modifiers,\n   * so that we can bind the grabs for when they are enabled too.\n   */", "depth": 1, "reading_ease": 73.51, "reading_grade": 8.7, "line": 52}, "comment_text": "/*\n   * Find out the masks for the NumLock and ScrollLock modifiers,\n   * so that we can bind the grabs for when they are enabled too.\n   */", "comment_tokens": ["Find", "out", "the", "masks", "for", "the", "NumLock", "and", "ScrollLock", "modifiers", ",", "so", "that", "we", "can", "bind", "the", "grabs", "for", "when", "they", "are", "enabled", "too", "."], "ccode": ["/***************************************************************************\n", "        xbindkeys : a program to bind keys to commands under X11.\n", "                           -------------------\n", "    begin                : Sat Oct 13 14:11:34 CEST 2001\n", "    copyright            : (C) 2001 by Philippe Brochard\n", "    email                : hocwp@free.fr\n", " ***************************************************************************/\n", "\n", "/***************************************************************************\n", " *                                                                         *\n", " *   This program is free software; you can redistribute it and/or modify  *\n", " *   it under the terms of the GNU General Public License as published by  *\n", " *   the Free Software Foundation; either version 2 of the License, or     *\n", " *   (at your option) any later version.                                   *\n", " *                                                                         *\n", " ***************************************************************************/\n", "\n", "#include <X11/Xlib.h>\n", "#include <X11/keysym.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include \"xbindkeys.h\"\n", "#include \"grab_key.h\"\n", "#include \"options.h\"\n", "#include \"keys.h\"\n", "\n", "\n", "unsigned int numlock_mask = 0;\n", "unsigned int scrolllock_mask = 0;\n", "unsigned int capslock_mask = 0;\n", "\n", "\n", "\n", "static void my_grab_key (Display * dpy, KeyCode keycode,\n", "\t\t\t unsigned int modifier, Window win);\n", "\n", "\n", "\n", "void\n", "get_offending_modifiers (Display * dpy)\n", "{\n", "  int i;\n", "  XModifierKeymap *modmap;\n", "  KeyCode nlock, slock;\n", "  static int mask_table[8] = {\n", "    ShiftMask, LockMask, ControlMask, Mod1Mask,\n", "    Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask\n", "  };\n", "\n", "  nlock = XKeysymToKeycode (dpy, XK_Num_Lock);\n", "  slock = XKeysymToKeycode (dpy, XK_Scroll_Lock);\n", "\n", "  /*\n", "   * Find out the masks for the NumLock and ScrollLock modifiers,\n", "   * so that we can bind the grabs for when they are enabled too.\n", "   */\n", "  modmap = XGetModifierMapping (dpy);\n", "\n", "  if (modmap != NULL && modmap->max_keypermod > 0)\n", "    {\n", "      for (i = 0; i < 8 * modmap->max_keypermod; i++)\n", "\t{\n", "\t  if (modmap->modifiermap[i] == nlock && nlock != 0)\n", "\t    numlock_mask = mask_table[i / modmap->max_keypermod];\n", "\t  else if (modmap->modifiermap[i] == slock && slock != 0)\n", "\t    scrolllock_mask = mask_table[i / modmap->max_keypermod];\n", "\t}\n", "    }\n", "\n", "  capslock_mask = LockMask;\n", "\n", "  if (modmap)\n", "    XFreeModifiermap (modmap);\n", "}\n"], "project": "xbindkeys", "file": "grab_key.pkl", "function": "get_offending_modifiers"}, {"comment_all": {"comment": "/* Function:  esl_cpu_has_sse4()\n * Synopsis:  Check if processor supports x86 <= SSE4.1\n * Incept:    SRE, Wed Jun  6 11:49:46 2018 [OdjBox, Otto Croy]\n *\n * Purpose:   Returns TRUE if our code has an available SSE4 vector\n *            implementation compiled in, and the processor we're\n *            running on can support it (i.e. has SSE+SSE2+SSE4.1).\n *            Else returns FALSE.\n */", "depth": 0, "reading_ease": 63.7, "reading_grade": 8.4, "line": 78}, "comment_text": "/* Function:  esl_cpu_has_sse4()\n * Synopsis:  Check if processor supports x86 <= SSE4.1\n * Incept:    SRE, Wed Jun  6 11:49:46 2018 [OdjBox, Otto Croy]\n *\n * Purpose:   Returns TRUE if our code has an available SSE4 vector\n *            implementation compiled in, and the processor we're\n *            running on can support it (i.e. has SSE+SSE2+SSE4.1).\n *            Else returns FALSE.\n */", "comment_tokens": ["Function", ":", "esl_cpu_has_sse4", "(", ")", "Synopsis", ":", "Check", "if", "processor", "supports", "x86", "<", "=", "SSE4.1", "Incept", ":", "SRE", ",", "Wed", "Jun", "6", "11:49:46", "2018", "[", "OdjBox", ",", "Otto", "Croy", "]", "Purpose", ":", "Returns", "TRUE", "if", "our", "code", "has", "an", "available", "SSE4", "vector", "implementation", "compiled", "in", ",", "and", "the", "processor", "we're", "running", "on", "can", "support", "it", "(", "i.e", ".", "has", "SSE+SSE2+SSE4.1", ")", ".", "Else", "returns", "FALSE", "."], "ccode": ["\n", "\n", "/* Function:  esl_cpu_has_sse4()\n", " * Synopsis:  Check if processor supports x86 <= SSE4.1\n", " * Incept:    SRE, Wed Jun  6 11:49:46 2018 [OdjBox, Otto Croy]\n", " *\n", " * Purpose:   Returns TRUE if our code has an available SSE4 vector\n", " *            implementation compiled in, and the processor we're\n", " *            running on can support it (i.e. has SSE+SSE2+SSE4.1).\n", " *            Else returns FALSE.\n", " */\n", "int\n", "esl_cpu_has_sse4(void)\n", "{\n", "#ifdef eslENABLE_SSE4\n", "  static int sse4_support = -1;\n", "  if (sse4_support < 0)\n", "    sse4_support = cpu_has_sse4();\n", "  return sse4_support;\n", "#else\n", "  return 0;\n", "#endif\n", "}\n"], "project": "infernal-doc", "file": "esl_cpu.pkl", "function": "esl_cpu_has_sse4"}, {"comment_all": {"comment": "/*\n * Copyright (c) 2015-2016 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Jan Friesse (jfriesse@redhat.com)\n *\n * This software licensed under BSD license, the text of which follows:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the Red Hat, Inc. nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */", "depth": 0, "reading_ease": 36.22, "reading_grade": 14.8, "line": 0}, "comment_text": "/*\n * Copyright (c) 2015-2016 Red Hat, Inc.\n *\n * All rights reserved.\n *\n * Author: Jan Friesse (jfriesse@redhat.com)\n *\n * This software licensed under BSD license, the text of which follows:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the Red Hat, Inc. nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */", "comment_tokens": ["Copyright", "(", "c", ")", "2015-2016", "Red", "Hat", ",", "Inc.", "All", "rights", "reserved", ".", "Author", ":", "Jan", "Friesse", "(", "jfriesse", "@", "redhat.com", ")", "This", "software", "licensed", "under", "BSD", "license", ",", "the", "text", "of", "which", "follows", ":", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "-", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "-", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "-", "Neither", "the", "name", "of", "the", "Red", "Hat", ",", "Inc.", "nor", "the", "names", "of", "its", "contributors", "may", "be", "used", "to", "endorse", "or", "promote", "products", "derived", "from", "this", "software", "without", "specific", "prior", "written", "permission", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "COPYRIGHT", "HOLDERS", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "COPYRIGHT", "OWNER", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", "."], "ccode": ["/*\n", " * Copyright (c) 2015-2016 Red Hat, Inc.\n", " *\n", " * All rights reserved.\n", " *\n", " * Author: Jan Friesse (jfriesse@redhat.com)\n", " *\n", " * This software licensed under BSD license, the text of which follows:\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions are met:\n", " *\n", " * - Redistributions of source code must retain the above copyright notice,\n", " *   this list of conditions and the following disclaimer.\n", " * - Redistributions in binary form must reproduce the above copyright notice,\n", " *   this list of conditions and the following disclaimer in the documentation\n", " *   and/or other materials provided with the distribution.\n", " * - Neither the name of the Red Hat, Inc. nor the names of its\n", " *   contributors may be used to endorse or promote products derived from this\n", " *   software without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n", " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n", " * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n", " * THE POSSIBILITY OF SUCH DAMAGE.\n", " */\n", "\n", "#include <sys/socket.h>\n", "#include <sys/un.h>\n", "\n", "#include <errno.h>\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "\n", "#include \"unix-socket.h\"\n", "#include \"utils.h\"\n", "\n", "int\n", "unix_socket_server_create(const char *path, int non_blocking, int backlog)\n", "{\n", "\tint s;\n", "\tstruct sockaddr_un sun;\n", "\n", "\tif (strlen(path) >= sizeof(sun.sun_path)) {\n", "\t\terrno = ENAMETOOLONG;\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tmemset(&sun, 0, sizeof(sun));\n", "\tsun.sun_family = AF_UNIX;\n", "\n", "\tstrncpy(sun.sun_path, path, sizeof(sun.sun_path) - 1);\n", "\tunlink(path);\n", "\tif (bind(s, (struct sockaddr *)&sun, SUN_LEN(&sun)) != 0) {\n", "\t\tclose(s);\n", "\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tif (non_blocking) {\n", "\t\tif (utils_fd_set_non_blocking(s) != 0) {\n", "\t\t\tclose(s);\n", "\n", "\t\t\treturn (-1);\n", "\t\t}\n", "\t}\n", "\n", "\tif (listen(s, backlog) != 0) {\n", "\t\tclose(s);\n", "\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\treturn (s);\n", "}\n"], "project": "corosync-qdevice", "file": "unix-socket.pkl", "function": "unix_socket_server_create"}, {"comment_all": {"comment": "/* Copyright (c) 2013 Intel Corporation */", "depth": 0, "reading_ease": 32.56, "reading_grade": 10.0, "line": 0}, "comment_text": "/* Copyright (c) 2013 Intel Corporation */", "comment_tokens": ["Copyright", "(", "c", ")", "2013", "Intel", "Corporation"], "ccode": ["/* Copyright (c) 2013 Intel Corporation */\n", "#include <stdio.h>\n", "#include \"internal.h\"\n", "\n", "int\n", "ixgbevf_dump_regs(struct ethtool_drvinfo *info maybe_unused,\n", "\t\t  struct ethtool_regs *regs)\n", "{\n", "\tu32 *regs_buff = (u32 *)regs->data;\n", "\tu8 version = (u8)(regs->version >> 24);\n", "\tu8 i;\n", "\n", "\tif (version == 0)\n", "\t\treturn -1;\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00000: VFCTRL      (VF Control Register) (Write Only) N/A\\n\");\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00008: VFSTATUS    (VF Status Register)               0x%08X\\n\",\n", "\t\tregs_buff[1]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00010: VFLINKS     (VF Link Status Register)          0x%08X\\n\",\n", "\t\tregs_buff[2]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x03190: VFRXMEMWRAP (Rx Packet Buffer Flush Detect)    0x%08X\\n\",\n", "\t\tregs_buff[3]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00048: VFFRTIMER   (VF Free Running Timer)            0x%08X\\n\",\n", "\t\tregs_buff[4]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00100: VFEICR      (VF Extended Interrupt Cause)      0x%08X\\n\",\n", "\t\tregs_buff[5]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00104: VFEICS      (VF Extended Interrupt Cause Set)  0x%08X\\n\",\n", "\t\tregs_buff[6]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00108: VFEIMS      (VF Extended Interrupt Mask Set)   0x%08X\\n\",\n", "\t\tregs_buff[7]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x0010C: VFEIMC      (VF Extended Interrupt Mask Clear) 0x%08X\\n\",\n", "\t\tregs_buff[8]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00110: VFEIAC      (VF Extended Interrupt Auto Clear) 0x%08X\\n\",\n", "\t\tregs_buff[9]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00114: VFEIAM      (VF Extended Interrupt Auto Mask)  0x%08X\\n\",\n", "\t\tregs_buff[10]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00820: VFEITR(0)   (VF Extended Interrupt Throttle)   0x%08X\\n\",\n", "\t\tregs_buff[11]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00120: VFIVAR(0)   (VF Interrupt Vector Allocation)   0x%08X\\n\",\n", "\t\tregs_buff[12]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00140: VFIVAR_MISC (VF Interrupt Vector Misc)         0x%08X\\n\",\n", "\t\tregs_buff[13]);\n", "\n", "\tfprintf(stdout,\n", "\t\t\"0x00104: VFPSRTYPE   (VF Replication Packet Split Type) 0x%08X\\n\",\n", "\t\tregs_buff[28]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDBAL(%d)  (VF Rx Desc. Base Addr Low %d)      0x%08X\\n\",\n", "\t\t\t0x1000 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[14+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDBAH(%d)  (VF Rx Desc. Base Addr High %d)     0x%08X\\n\",\n", "\t\t\t0x1004 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[16+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDLEN(%d)  (VF Rx Desc. Length %d)             0x%08X\\n\",\n", "\t\t\t0x1008 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[18+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDH(%d)    (VF Rx Desc. Head %d)               0x%08X\\n\",\n", "\t\t\t0x1010 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[20+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDT(%d)    (VF Rx Desc. Tail %d)               0x%08X\\n\",\n", "\t\t\t0x1018 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[22+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFRDT(%d)    (VF Rx Desc. Control %d),           0x%08X\\n\",\n", "\t\t\t0x1028 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[24+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFSRRCTL(%d) (VF Split Rx Control %d)            0x%08X\\n\",\n", "\t\t\t0x1014 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[26+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDBAL(%d)  (VF Tx Desc. Base Addr Low %d)      0x%08X\\n\",\n", "\t\t\t0x2000 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[29+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDBAH(%d)  (VF Tx Desc. Base Addr High %d)     0x%08X\\n\",\n", "\t\t\t0x2004 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[31+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDLEN(%d)  (VF Tx Desc. Length %d)             0x%08X\\n\",\n", "\t\t\t0x2008 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[33+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDH(%d)    (VF Tx Desc. Head %d)               0x%08X\\n\",\n", "\t\t\t0x2010 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[35+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDT(%d)    (VF Tx Desc. Tail %d)               0x%08X\\n\",\n", "\t\t\t0x2018 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[37+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDT(%d)    (VF Tx Desc. Control %d)            0x%08X\\n\",\n", "\t\t\t0x2028 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[39+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDWBAL(%d) (VF Tx Desc. Write Back Addr Lo %d) 0x%08X\\n\",\n", "\t\t\t0x2038 + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[41+i]);\n", "\n", "\tfor (i = 0; i < 2; i++)\n", "\t\tfprintf(stdout,\n", "\t\t\t\"0x%05x: VFTDWBAH(%d) (VF Tx Desc. Write Back Addr Hi %d) 0x%08X\\n\",\n", "\t\t\t0x203C + 0x40*i,\n", "\t\t\ti, i,\n", "\t\t\tregs_buff[43+i]);\n", "\n", "\treturn 0;\n", "}\n"], "project": "ethtool", "file": "ixgbevf.pkl", "function": "ixgbevf_dump_regs"}, {"comment_all": {"comment": "/* First -d, turn off defaults. */", "depth": 2, "reading_ease": 100.24, "reading_grade": 0.5, "line": 239}, "comment_text": "/* First -d, turn off defaults. */", "comment_tokens": ["First", "-d", ",", "turn", "off", "defaults", "."], "ccode": ["\n", "/* Symbols to be defined as true for use in Jambase */\n", "\n", "static const char *othersyms[] = { OSMAJOR, OSMINOR, OSPLAT, JAMVERSYM, 0 } ;\n", "\n", "/* Known for sure: \n", " *\tmac needs arg_enviro\n", " *\tOS2 needs extern environ\n", " */\n", "\n", "# ifdef OS_MAC\n", "# define use_environ arg_environ\n", "# ifdef MPW\n", "QDGlobals qd;\n", "# endif\n", "# endif\n", "\n", "# ifndef use_environ\n", "# define use_environ environ\n", "# if !defined( __WATCOM__ ) && !defined( OS_OS2 ) && !defined( OS_NT ) \n", "extern char **environ;\n", "# endif\n", "# endif\n", "\n", "main( int argc, char **argv, char **arg_environ )\n", "{\n", "\tint\t\tn;\n", "\tconst char\t*s;\n", "\tstruct option\toptv[N_OPTS];\n", "\tconst char\t*all = \"all\";\n", "\tint\t\tanyhow = 0;\n", "\tint\t\tstatus;\n", "\n", "# ifdef OS_MAC\n", "\tInitGraf(&qd.thePort);\n", "# endif\n", "\n", "\targc--, argv++;\n", "\n", "\tif( ( n = getoptions( argc, argv, \"d:j:f:gs:t:ano:qv\", optv ) ) < 0 )\n", "\t{\n", "\t    printf( \"\\nusage: jam [ options ] targets...\\n\\n\" );\n", "\n", "            printf( \"-a      Build all targets, even if they are current.\\n\" );\n", "            printf( \"-dx     Display (a)actions (c)causes (d)dependencies\\n\" );\n", "\t    printf( \"        (m)make tree (x)commands (0-9) debug levels.\\n\" );\n", "            printf( \"-fx     Read x instead of Jambase.\\n\" );\n", "\t    printf( \"-g      Build from newest sources first.\\n\" );\n", "            printf( \"-jx     Run up to x shell commands concurrently.\\n\" );\n", "            printf( \"-n      Don't actually execute the updating actions.\\n\" );\n", "            printf( \"-ox     Write the updating actions to file x.\\n\" );\n", "            printf( \"-q      Quit quickly as soon as a target fails.\\n\" );\n", "\t    printf( \"-sx=y   Set variable x=y, overriding environment.\\n\" );\n", "            printf( \"-tx     Rebuild x, even if it is up-to-date.\\n\" );\n", "            printf( \"-v      Print the version of jam and exit.\\n\\n\" );\n", "\n", "\t    exit( EXITBAD );\n", "\t}\n", "\n", "\targc -= n, argv += n;\n", "\n", "\t/* Version info. */\n", "\n", "\tif( ( s = getoptval( optv, 'v', 0 ) ) )\n", "\t{\n", "\t    printf( \"Jam %s. %s. \", VERSION, OSMINOR );\n", "\t    if( *OSPLAT ) printf( \"%s. \", OSPLAT );\n", "\t    printf( \"Copyright 1993-2010 Christopher Seiwald.\\n\" );\n", "\n", "\t    return EXITOK;\n", "\t}\n", "\n", "\t/* Pick up interesting options */\n", "\n", "\tif( ( s = getoptval( optv, 'n', 0 ) ) )\n", "\t    globs.noexec++, DEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 1; \n", "\n", "\tif( ( s = getoptval( optv, 'q', 0 ) ) )\n", "\t    globs.quitquick = 1;\n", "\n", "\tif( ( s = getoptval( optv, 'a', 0 ) ) )\n", "\t    anyhow++;\n", "\n", "\tif( ( s = getoptval( optv, 'j', 0 ) ) )\n", "\t    globs.jobs = atoi( s );\n", "\n", "\tif( ( s = getoptval( optv, 'g', 0 ) ) )\n", "\t    globs.newestfirst = 1;\n", "\n", "\t/* Turn on/off debugging */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'd', n ); n++ )\n", "\t{\n", "\t    int i = atoi( s );\n", "\n", "\t    /* First -d, turn off defaults. */\n", "\n", "\t    if( !n )\n", "\t\tDEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 0;\n", "\n", "\t    /* n turns on levels 1-n */\n", "\t    /* +n turns on level n */\n", "\t    /* c turns on named display c */\n", "\n", "\t    if( i < 0 || i >= DEBUG_MAX )\n", "\t    {\n", "\t\tprintf( \"Invalid debug level '%s'.\\n\", s );\n", "\t    }\n", "\t    else if( *s == '+' )\n", "\t    {\n", "\t\tglobs.debug[i] = 1;\n", "\t    }\n", "\t    else if( i ) while( i )\n", "\t    {\n", "\t\tglobs.debug[i--] = 1;\n", "\t    }\n", "\t    else while( *s ) switch( *s++ )\n", "\t    {\n", "\t    case 'a': DEBUG_MAKE = DEBUG_MAKEQ = 1; break;\n", "\t    case 'c': DEBUG_CAUSES = 1; break;\n", "\t    case 'd': DEBUG_DEPENDS = 1; break;\n", "\t    case 'm': DEBUG_MAKEPROG = 1; break;\n", "\t    case 'r': DEBUG_COMPILE = 1; break;\n", "\t    case 'x': DEBUG_EXEC = 1; break;\n", "\t    case '0': break;\n", "\t    default: printf( \"Invalid debug flag '%c'.\\n\", s[-1] );\n", "\t    }\n", "\t}\n", "\n", "\t/* Set JAMDATE first */\n", "\n", "\t{\n", "\t    char buf[ 128 ];\n", "\t    time_t clock;\n", "\t    time( &clock );\n", "\t    strcpy( buf, ctime( &clock ) );\n", "\n", "\t    /* Trim newline from date */\n", "\n", "\t    if( strlen( buf ) == 25 )\n", "\t\tbuf[ 24 ] = 0;\n", "\n", "\t    var_set( \"JAMDATE\", list_new( L0, buf, 0 ), VAR_SET );\n", "\t}\n", "\n", "\t/* And JAMUNAME */\n", "# ifdef unix\n", "\t{\n", "\t    struct utsname u;\n", "\n", "\t    if( uname( &u ) >= 0 )\n", "\t    {\n", "\t\tLIST *l = L0;\n", "\t\tl = list_new( l, u.machine, 0 );\n", "\t\tl = list_new( l, u.version, 0 );\n", "\t\tl = list_new( l, u.release, 0 );\n", "\t\tl = list_new( l, u.nodename, 0 );\n", "\t\tl = list_new( l, u.sysname, 0 );\n", "\t\tvar_set( \"JAMUNAME\", l, VAR_SET );\n", "\t    }\n", "\t}\n", "# endif /* unix */\n", "\n", "\t/*\n", "\t * Jam defined variables OS, OSPLAT\n", "\t */\n", "\n", "\tvar_defines( othersyms );\n", "\n", "\t/* load up environment variables */\n", "\n", "\tvar_defines( (const char **)use_environ );\n", "\n", "\t/* Load up variables set on command line. */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 's', n ); n++ )\n", "\t{\n", "\t    const char *symv[2];\n", "\t    symv[0] = s;\n", "\t    symv[1] = 0;\n", "\t    var_defines( symv );\n", "\t}\n", "\n", "\t/* Initialize built-in rules */\n", "\n", "\tload_builtins();\n", "\n", "\t/* Parse ruleset */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'f', n ); n++ )\n", "\t    parse_file( s );\n", "\n", "\tif( !n )\n", "\t    parse_file( \"+\" );\n", "\n", "\tstatus = yyanyerrors();\n", "\n", "\t/* Manually touch -t targets */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 't', n ); n++ )\n", "\t    touchtarget( s );\n", "\n", "\t/* If an output file is specified, set globs.cmdout to that */\n", "\n", "\tif( s = getoptval( optv, 'o', 0 ) )\n", "\t{\n", "\t    if( !( globs.cmdout = fopen( s, \"w\" ) ) )\n", "\t    {\n", "\t\tprintf( \"Failed to write to '%s'\\n\", s );\n", "\t\texit( EXITBAD );\n", "\t    }\n", "\t    globs.noexec++;\n", "\t}\n", "\n", "\t/* Now make target */\n", "\n", "\tif( !argc )\n", "\t    status |= make( 1, &all, anyhow );\n", "\telse\n", "\t    status |= make( argc, (const char **)argv, anyhow );\n", "\n", "\t/* Widely scattered cleanup */\n", "\n", "\tvar_done();\n", "\tdonerules();\n", "\tdonestamps();\n", "\tdonestr();\n", "\n", "\t/* close cmdout */\n", "\n", "\tif( globs.cmdout )\n", "\t    fclose( globs.cmdout );\n", "\n", "\treturn status ? EXITBAD : EXITOK;\n", "}\n"], "project": "jam", "file": "jam.pkl", "function": "main"}, {"comment_all": {"comment": "/* free, not destroy, as we never touched the filesystem */", "depth": 2, "reading_ease": 87.72, "reading_grade": 3.3, "line": 146}, "comment_text": "/* free, not destroy, as we never touched the filesystem */", "comment_tokens": ["free", ",", "not", "destroy", ",", "as", "we", "never", "touched", "the", "filesystem"], "ccode": ["\n", "struct tmp_objdir *tmp_objdir_create(void)\n", "{\n", "\tstatic int installed_handlers;\n", "\tstruct tmp_objdir *t;\n", "\n", "\tif (the_tmp_objdir)\n", "\t\tBUG(\"only one tmp_objdir can be used at a time\");\n", "\n", "\tt = xmalloc(sizeof(*t));\n", "\tstrbuf_init(&t->path, 0);\n", "\targv_array_init(&t->env);\n", "\n", "\tstrbuf_addf(&t->path, \"%s/incoming-XXXXXX\", get_object_directory());\n", "\n", "\t/*\n", "\t * Grow the strbuf beyond any filename we expect to be placed in it.\n", "\t * If tmp_objdir_destroy() is called by a signal handler, then\n", "\t * we should be able to use the strbuf to remove files without\n", "\t * having to call malloc.\n", "\t */\n", "\tstrbuf_grow(&t->path, 1024);\n", "\n", "\tif (!mkdtemp(t->path.buf)) {\n", "\t\t/* free, not destroy, as we never touched the filesystem */\n", "\t\ttmp_objdir_free(t);\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tthe_tmp_objdir = t;\n", "\tif (!installed_handlers) {\n", "\t\tatexit(remove_tmp_objdir);\n", "\t\tsigchain_push_common(remove_tmp_objdir_on_signal);\n", "\t\tinstalled_handlers++;\n", "\t}\n", "\n", "\tif (setup_tmp_objdir(t->path.buf)) {\n", "\t\ttmp_objdir_destroy(t);\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tenv_append(&t->env, ALTERNATE_DB_ENVIRONMENT,\n", "\t\t   absolute_path(get_object_directory()));\n", "\tenv_replace(&t->env, DB_ENVIRONMENT, absolute_path(t->path.buf));\n", "\tenv_replace(&t->env, GIT_QUARANTINE_ENVIRONMENT,\n", "\t\t    absolute_path(t->path.buf));\n", "\n", "\treturn t;\n", "}\n"], "project": "git-mediawiki", "file": "tmp-objdir.pkl", "function": "tmp_objdir_create"}, {"comment_all": {"comment": "/* blowfish expects two 32 bit blocks */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 75}, "comment_text": "/* blowfish expects two 32 bit blocks */", "comment_tokens": ["blowfish", "expects", "two", "32", "bit", "blocks"], "ccode": ["\n", "/*\tblowfish-encrypt/hex-encode string\n", " *\t@param gcrypt handle\n", " *\t@param encrypt this\n", " *\t@return encrypted, hex-encoded string\n", " */\n", "char *PianoEncryptString (gcry_cipher_hd_t h, const char *s) {\n", "\tunsigned char *paddedInput, *hexOutput;\n", "\tsize_t inputLen = strlen (s);\n", "\t/* blowfish expects two 32 bit blocks */\n", "\tsize_t paddedInputLen = (inputLen % 8 == 0) ? inputLen : inputLen + (8-inputLen%8);\n", "\tgcry_error_t gret;\n", "\n", "\tpaddedInput = calloc (paddedInputLen+1, sizeof (*paddedInput));\n", "\tmemcpy (paddedInput, s, inputLen);\n", "\n", "\tgret = gcry_cipher_encrypt (h, paddedInput, paddedInputLen, NULL, 0);\n", "\tif (gret) {\n", "\t\tfree (paddedInput);\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\thexOutput = calloc (paddedInputLen*2+1, sizeof (*hexOutput));\n", "\tfor (size_t i = 0; i < paddedInputLen; i++) {\n", "\t\tsnprintf ((char * restrict) &hexOutput[i*2], 3, \"%02x\", paddedInput[i]);\n", "\t}\n", "\n", "\tfree (paddedInput);\n", "\n", "\treturn (char *) hexOutput;\n", "}\n"], "project": "libpiano-dev", "file": "crypt.pkl", "function": "PianoEncryptString"}, {"comment_all": {"comment": "/**\n * up_exported_kbd_backlight_skeleton_new:\n *\n * Creates a skeleton object for the D-Bus interface <link linkend=\"gdbus-interface-org-freedesktop-UPower-KbdBacklight.top_of_page\">org.freedesktop.UPower.KbdBacklight</link>.\n *\n * Returns: (transfer full) (type UpExportedKbdBacklightSkeleton): The skeleton object.\n */", "depth": 0, "reading_ease": -90.46, "reading_grade": 28.2, "line": 1573}, "comment_text": "/**\n * up_exported_kbd_backlight_skeleton_new:\n *\n * Creates a skeleton object for the D-Bus interface <link linkend=\"gdbus-interface-org-freedesktop-UPower-KbdBacklight.top_of_page\">org.freedesktop.UPower.KbdBacklight</link>.\n *\n * Returns: (transfer full) (type UpExportedKbdBacklightSkeleton): The skeleton object.\n */", "comment_tokens": ["up_exported_kbd_backlight_skeleton_new", ":", "Creates", "a", "skeleton", "object", "for", "the", "D-Bus", "interface", "<", "link", "linkend=", "''", "gdbus-interface-org-freedesktop-UPower-KbdBacklight.top_of_page", "''", ">", "org.freedesktop.UPower.KbdBacklight", "<", "link", ">", ".", "Returns", ":", "(", "transfer", "full", ")", "(", "type", "UpExportedKbdBacklightSkeleton", ")", ":", "The", "skeleton", "object", "."], "ccode": ["\n", "/**\n", " * up_exported_kbd_backlight_skeleton_new:\n", " *\n", " * Creates a skeleton object for the D-Bus interface <link linkend=\"gdbus-interface-org-freedesktop-UPower-KbdBacklight.top_of_page\">org.freedesktop.UPower.KbdBacklight</link>.\n", " *\n", " * Returns: (transfer full) (type UpExportedKbdBacklightSkeleton): The skeleton object.\n", " */\n", "UpExportedKbdBacklight *\n", "up_exported_kbd_backlight_skeleton_new (void)\n", "{\n", "  return UP_EXPORTED_KBD_BACKLIGHT (g_object_new (UP_TYPE_EXPORTED_KBD_BACKLIGHT_SKELETON, NULL));\n", "}\n"], "project": "libupower-glib3", "file": "up-kbd-backlight-generated.pkl", "function": "up_exported_kbd_backlight_skeleton_new"}, {"comment_all": {"comment": "/* Free memory acquired for installed libraries */", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 111}, "comment_text": "/* Free memory acquired for installed libraries */", "comment_tokens": ["Free", "memory", "acquired", "for", "installed", "libraries"], "ccode": ["\n", "/*\n", "** 'release_heap' is called at the end of the interpreter's run to\n", "** return all memory to the OS\n", "*/\n", "void release_heap(void) {\n", "  library *lp, *lp2;\n", "  lp = basicvars.installist;\t/* Free memory acquired for installed libraries */\n", "  while (lp!=NIL) {\n", "    lp2 = lp->libflink;\n", "    free(lp->libname);\n", "    free(lp);\n", "    lp = lp2;\n", "  }\n", "  release_workspace();\n", "  free(basicvars.stringwork);\n", "  if (basicvars.loadpath!=NIL) free(basicvars.loadpath);\n", "}\n"], "project": "brandy", "file": "heap.pkl", "function": "release_heap"}, {"comment_all": {"comment": "/*\n * os_unlink -- unlink abstraction layer\n */", "depth": 0, "reading_ease": -8.73, "reading_grade": 15.5, "line": 115}, "comment_text": "/*\n * os_unlink -- unlink abstraction layer\n */", "comment_tokens": ["os_unlink", "--", "unlink", "abstraction", "layer"], "ccode": ["\n", "/*\n", " * os_unlink -- unlink abstraction layer\n", " */\n", "int\n", "os_unlink(const char *pathname)\n", "{\n", "\treturn unlink(pathname);\n", "}\n"], "project": "libvmem1", "file": "os_posix.pkl", "function": "os_unlink"}, {"comment_all": {"comment": "/* Return a newly allocated time zone for NAME, or NULL on failure.\n   A null NAME stands for wall clock time (which is like unset TZ).  */", "depth": 0, "reading_ease": 84.17, "reading_grade": 4.6, "line": 91}, "comment_text": "/* Return a newly allocated time zone for NAME, or NULL on failure.\n   A null NAME stands for wall clock time (which is like unset TZ).  */", "comment_tokens": ["Return", "a", "newly", "allocated", "time", "zone", "for", "NAME", ",", "or", "NULL", "on", "failure", ".", "A", "null", "NAME", "stands", "for", "wall", "clock", "time", "(", "which", "is", "like", "unset", "TZ", ")", "."], "ccode": ["\n", "/* Return a newly allocated time zone for NAME, or NULL on failure.\n", "   A null NAME stands for wall clock time (which is like unset TZ).  */\n", "timezone_t\n", "tzalloc (char const *name)\n", "{\n", "  size_t name_size = name ? strlen (name) + 1 : 0;\n", "  size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n", "  timezone_t tz = malloc (FLEXSIZEOF (struct tm_zone, abbrs, abbr_size));\n", "  if (tz)\n", "    {\n", "      tz->next = NULL;\n", "#if HAVE_TZNAME && !HAVE_TM_ZONE\n", "      tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n", "#endif\n", "      tz->tz_is_set = !!name;\n", "      tz->abbrs[0] = '\\0';\n", "      if (name)\n", "        extend_abbrs (tz->abbrs, name, name_size);\n", "    }\n", "  return tz;\n", "}\n"], "project": "clisp-module-berkeley-db", "file": "time_rz.pkl", "function": "tzalloc"}, {"comment_all": {"comment": "/*\n * Try to open specified file with following names:\n * ./name\n * $(srctree)/name\n * The latter is used when srctree is separate from objtree\n * when compiling the kernel.\n * Return NULL if file is not found.\n */", "depth": 0, "reading_ease": 69.48, "reading_grade": 6.1, "line": 4298}, "comment_text": "/*\n * Try to open specified file with following names:\n * ./name\n * $(srctree)/name\n * The latter is used when srctree is separate from objtree\n * when compiling the kernel.\n * Return NULL if file is not found.\n */", "comment_tokens": ["Try", "to", "open", "specified", "file", "with", "following", "names", ":", ".name", "$", "(", "srctree", ")", "name", "The", "latter", "is", "used", "when", "srctree", "is", "separate", "from", "objtree", "when", "compiling", "the", "kernel", ".", "Return", "NULL", "if", "file", "is", "not", "found", "."], "ccode": ["\n", "/*\n", " * Try to open specified file with following names:\n", " * ./name\n", " * $(srctree)/name\n", " * The latter is used when srctree is separate from objtree\n", " * when compiling the kernel.\n", " * Return NULL if file is not found.\n", " */\n", "FILE *zconf_fopen(const char *name)\n", "{\n", "\tchar *env, fullname[PATH_MAX+1];\n", "\tFILE *f;\n", "\n", "\tf = fopen(name, \"r\");\n", "\tif (!f && name != NULL && name[0] != '/') {\n", "\t\tenv = getenv(SRCTREE);\n", "\t\tif (env) {\n", "\t\t\tsnprintf(fullname, sizeof(fullname),\n", "\t\t\t\t \"%s/%s\", env, name);\n", "\t\t\tf = fopen(fullname, \"r\");\n", "\t\t}\n", "\t}\n", "\treturn f;\n", "}\n"], "project": "linux-cloud-tools-5.8.0-63-lowlatency", "file": "lexer.lex.pkl", "function": "zconf_fopen"}, {"comment_all": {"comment": "/*\n\t\t\t * Except in oldaskconfig mode, we show only menus that\n\t\t\t * contain new symbols.\n\t\t\t */", "depth": 3, "reading_ease": 76.22, "reading_grade": 5.6, "line": 362}, "comment_text": "/*\n\t\t\t * Except in oldaskconfig mode, we show only menus that\n\t\t\t * contain new symbols.\n\t\t\t */", "comment_tokens": ["Except", "in", "oldaskconfig", "mode", ",", "we", "show", "only", "menus", "that", "contain", "new", "symbols", "."], "ccode": ["\n", "static void conf(struct menu *menu)\n", "{\n", "\tstruct symbol *sym;\n", "\tstruct property *prop;\n", "\tstruct menu *child;\n", "\n", "\tif (!menu_is_visible(menu))\n", "\t\treturn;\n", "\n", "\tsym = menu->sym;\n", "\tprop = menu->prompt;\n", "\tif (prop) {\n", "\t\tconst char *prompt;\n", "\n", "\t\tswitch (prop->type) {\n", "\t\tcase P_MENU:\n", "\t\t\t/*\n", "\t\t\t * Except in oldaskconfig mode, we show only menus that\n", "\t\t\t * contain new symbols.\n", "\t\t\t */\n", "\t\t\tif (input_mode != oldaskconfig && rootEntry != menu) {\n", "\t\t\t\tcheck_conf(menu);\n", "\t\t\t\treturn;\n", "\t\t\t}\n", "\t\t\t/* fall through */\n", "\t\tcase P_COMMENT:\n", "\t\t\tprompt = menu_get_prompt(menu);\n", "\t\t\tif (prompt)\n", "\t\t\t\tprintf(\"%*c\\n%*c %s\\n%*c\\n\",\n", "\t\t\t\t\tindent, '*',\n", "\t\t\t\t\tindent, '*', prompt,\n", "\t\t\t\t\tindent, '*');\n", "\t\tdefault:\n", "\t\t\t;\n", "\t\t}\n", "\t}\n", "\n", "\tif (!sym)\n", "\t\tgoto conf_childs;\n", "\n", "\tif (sym_is_choice(sym)) {\n", "\t\tconf_choice(menu);\n", "\t\tif (sym->curr.tri != mod)\n", "\t\t\treturn;\n", "\t\tgoto conf_childs;\n", "\t}\n", "\n", "\tswitch (sym->type) {\n", "\tcase S_INT:\n", "\tcase S_HEX:\n", "\tcase S_STRING:\n", "\t\tconf_string(menu);\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tconf_sym(menu);\n", "\t\tbreak;\n", "\t}\n", "\n", "conf_childs:\n", "\tif (sym)\n", "\t\tindent += 2;\n", "\tfor (child = menu->list; child; child = child->next)\n", "\t\tconf(child);\n", "\tif (sym)\n", "\t\tindent -= 2;\n", "}\n"], "project": "linux-buildinfo-5.6.0-1039-oem", "file": "conf.pkl", "function": "conf"}, {"comment_all": {"comment": "/*  an - Anagram generator\n    Copyright (C) 2012  Paul Martin <pm@debian.org>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/", "depth": 0, "reading_ease": 59.33, "reading_grade": 10.0, "line": 0}, "comment_text": "/*  an - Anagram generator\n    Copyright (C) 2012  Paul Martin <pm@debian.org>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/", "comment_tokens": ["an", "-", "Anagram", "generator", "Copyright", "(", "C", ")", "2012", "Paul", "Martin", "<", "pm", "@", "debian.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA", "."], "ccode": ["/*  an - Anagram generator\n", "    Copyright (C) 2012  Paul Martin <pm@debian.org>\n", "\n", "    This program is free software; you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation; either version 2 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "\n", "    You should have received a copy of the GNU General Public License along\n", "    with this program; if not, write to the Free Software Foundation, Inc.,\n", "    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", "*/\n", "\n", "/* Safe allocation */\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include \"malloc.h\"\n", "\n", "void *\n", "safe_calloc(size_t nmemb, size_t size)\n", "{\n", "    void *ret = calloc(nmemb, size);\n", "    if (ret == NULL) {\n", "        fprintf(stderr, \"Out of memory in calloc()\\n\");\n", "        exit(99);\n", "    }\n", "    return ret;\n", "}\n"], "project": "an", "file": "malloc.pkl", "function": "safe_calloc"}, {"comment_all": {"comment": "/* Save here parameter addresses. */", "depth": 1, "reading_ease": 8.2, "reading_grade": 13.1, "line": 167}, "comment_text": "/* Save here parameter addresses. */", "comment_tokens": ["Save", "here", "parameter", "addresses", "."], "ccode": ["/***************************************************************************\n", " Routine to access the command line argument and interpret them:       \n", " Return ARG_OK (0) is case of successful parsing, error code else...       \n", "***************************************************************************/\n", "bool\n", "GAGetArgs(int argc,\n", "        char **argv,\n", "        char *CtrlStr, ...) {\n", "\n", "    int i, ParamCount = 0;\n", "    void *Parameters[MAX_PARAM];     /* Save here parameter addresses. */\n", "    char CtrlStrCopy[CTRL_STR_MAX_LEN];\n", "    char **argv_end = argv + argc;\n", "    va_list ap;\n", "\n", "    strncpy(CtrlStrCopy, CtrlStr, sizeof(CtrlStrCopy)-1);\n", "    GASetParamCount(CtrlStr, strlen(CtrlStr), &ParamCount);\n", "    va_start(ap, CtrlStr);\n", "    for (i = 1; i <= ParamCount; i++)\n", "        Parameters[i - 1] = va_arg(ap, void *);\n", "    va_end(ap);\n", "\n", "    argv++;    /* Skip the program name (first in argv/c list). */\n", "    while (argv < argv_end) {\n", "\tbool Error = false;\n", "        if (!GAOptionExists(argv_end, argv))\n", "            break;    /* The loop. */\n", "        char *Option = *argv++;\n", "        if ((Error = GAUpdateParameters(Parameters, &ParamCount, Option,\n", "                                        CtrlStrCopy, CtrlStr, argv_end,\n", "                                        &argv)) != false)\n", "            return Error;\n", "    }\n", "    /* Check for results and update trail of command line: */\n", "    return GATestAllSatis(CtrlStrCopy, CtrlStr, argv_end, &argv, Parameters,\n", "                          &ParamCount) != ARG_OK;\n", "}\n"], "project": "giflib-tools", "file": "getarg.pkl", "function": "GAGetArgs"}, {"comment_all": {"comment": "/*\n\t * Jam defined variables OS, OSPLAT\n\t */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 307}, "comment_text": "/*\n\t * Jam defined variables OS, OSPLAT\n\t */", "comment_tokens": ["Jam", "defined", "variables", "OS", ",", "OSPLAT"], "ccode": ["\n", "/* Symbols to be defined as true for use in Jambase */\n", "\n", "static const char *othersyms[] = { OSMAJOR, OSMINOR, OSPLAT, JAMVERSYM, 0 } ;\n", "\n", "/* Known for sure: \n", " *\tmac needs arg_enviro\n", " *\tOS2 needs extern environ\n", " */\n", "\n", "# ifdef OS_MAC\n", "# define use_environ arg_environ\n", "# ifdef MPW\n", "QDGlobals qd;\n", "# endif\n", "# endif\n", "\n", "# ifndef use_environ\n", "# define use_environ environ\n", "# if !defined( __WATCOM__ ) && !defined( OS_OS2 ) && !defined( OS_NT ) \n", "extern char **environ;\n", "# endif\n", "# endif\n", "\n", "main( int argc, char **argv, char **arg_environ )\n", "{\n", "\tint\t\tn;\n", "\tconst char\t*s;\n", "\tstruct option\toptv[N_OPTS];\n", "\tconst char\t*all = \"all\";\n", "\tint\t\tanyhow = 0;\n", "\tint\t\tstatus;\n", "\n", "# ifdef OS_MAC\n", "\tInitGraf(&qd.thePort);\n", "# endif\n", "\n", "\targc--, argv++;\n", "\n", "\tif( ( n = getoptions( argc, argv, \"d:j:f:gs:t:ano:qv\", optv ) ) < 0 )\n", "\t{\n", "\t    printf( \"\\nusage: jam [ options ] targets...\\n\\n\" );\n", "\n", "            printf( \"-a      Build all targets, even if they are current.\\n\" );\n", "            printf( \"-dx     Display (a)actions (c)causes (d)dependencies\\n\" );\n", "\t    printf( \"        (m)make tree (x)commands (0-9) debug levels.\\n\" );\n", "            printf( \"-fx     Read x instead of Jambase.\\n\" );\n", "\t    printf( \"-g      Build from newest sources first.\\n\" );\n", "            printf( \"-jx     Run up to x shell commands concurrently.\\n\" );\n", "            printf( \"-n      Don't actually execute the updating actions.\\n\" );\n", "            printf( \"-ox     Write the updating actions to file x.\\n\" );\n", "            printf( \"-q      Quit quickly as soon as a target fails.\\n\" );\n", "\t    printf( \"-sx=y   Set variable x=y, overriding environment.\\n\" );\n", "            printf( \"-tx     Rebuild x, even if it is up-to-date.\\n\" );\n", "            printf( \"-v      Print the version of jam and exit.\\n\\n\" );\n", "\n", "\t    exit( EXITBAD );\n", "\t}\n", "\n", "\targc -= n, argv += n;\n", "\n", "\t/* Version info. */\n", "\n", "\tif( ( s = getoptval( optv, 'v', 0 ) ) )\n", "\t{\n", "\t    printf( \"Jam %s. %s. \", VERSION, OSMINOR );\n", "\t    if( *OSPLAT ) printf( \"%s. \", OSPLAT );\n", "\t    printf( \"Copyright 1993-2010 Christopher Seiwald.\\n\" );\n", "\n", "\t    return EXITOK;\n", "\t}\n", "\n", "\t/* Pick up interesting options */\n", "\n", "\tif( ( s = getoptval( optv, 'n', 0 ) ) )\n", "\t    globs.noexec++, DEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 1; \n", "\n", "\tif( ( s = getoptval( optv, 'q', 0 ) ) )\n", "\t    globs.quitquick = 1;\n", "\n", "\tif( ( s = getoptval( optv, 'a', 0 ) ) )\n", "\t    anyhow++;\n", "\n", "\tif( ( s = getoptval( optv, 'j', 0 ) ) )\n", "\t    globs.jobs = atoi( s );\n", "\n", "\tif( ( s = getoptval( optv, 'g', 0 ) ) )\n", "\t    globs.newestfirst = 1;\n", "\n", "\t/* Turn on/off debugging */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'd', n ); n++ )\n", "\t{\n", "\t    int i = atoi( s );\n", "\n", "\t    /* First -d, turn off defaults. */\n", "\n", "\t    if( !n )\n", "\t\tDEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 0;\n", "\n", "\t    /* n turns on levels 1-n */\n", "\t    /* +n turns on level n */\n", "\t    /* c turns on named display c */\n", "\n", "\t    if( i < 0 || i >= DEBUG_MAX )\n", "\t    {\n", "\t\tprintf( \"Invalid debug level '%s'.\\n\", s );\n", "\t    }\n", "\t    else if( *s == '+' )\n", "\t    {\n", "\t\tglobs.debug[i] = 1;\n", "\t    }\n", "\t    else if( i ) while( i )\n", "\t    {\n", "\t\tglobs.debug[i--] = 1;\n", "\t    }\n", "\t    else while( *s ) switch( *s++ )\n", "\t    {\n", "\t    case 'a': DEBUG_MAKE = DEBUG_MAKEQ = 1; break;\n", "\t    case 'c': DEBUG_CAUSES = 1; break;\n", "\t    case 'd': DEBUG_DEPENDS = 1; break;\n", "\t    case 'm': DEBUG_MAKEPROG = 1; break;\n", "\t    case 'r': DEBUG_COMPILE = 1; break;\n", "\t    case 'x': DEBUG_EXEC = 1; break;\n", "\t    case '0': break;\n", "\t    default: printf( \"Invalid debug flag '%c'.\\n\", s[-1] );\n", "\t    }\n", "\t}\n", "\n", "\t/* Set JAMDATE first */\n", "\n", "\t{\n", "\t    char buf[ 128 ];\n", "\t    time_t clock;\n", "\t    time( &clock );\n", "\t    strcpy( buf, ctime( &clock ) );\n", "\n", "\t    /* Trim newline from date */\n", "\n", "\t    if( strlen( buf ) == 25 )\n", "\t\tbuf[ 24 ] = 0;\n", "\n", "\t    var_set( \"JAMDATE\", list_new( L0, buf, 0 ), VAR_SET );\n", "\t}\n", "\n", "\t/* And JAMUNAME */\n", "# ifdef unix\n", "\t{\n", "\t    struct utsname u;\n", "\n", "\t    if( uname( &u ) >= 0 )\n", "\t    {\n", "\t\tLIST *l = L0;\n", "\t\tl = list_new( l, u.machine, 0 );\n", "\t\tl = list_new( l, u.version, 0 );\n", "\t\tl = list_new( l, u.release, 0 );\n", "\t\tl = list_new( l, u.nodename, 0 );\n", "\t\tl = list_new( l, u.sysname, 0 );\n", "\t\tvar_set( \"JAMUNAME\", l, VAR_SET );\n", "\t    }\n", "\t}\n", "# endif /* unix */\n", "\n", "\t/*\n", "\t * Jam defined variables OS, OSPLAT\n", "\t */\n", "\n", "\tvar_defines( othersyms );\n", "\n", "\t/* load up environment variables */\n", "\n", "\tvar_defines( (const char **)use_environ );\n", "\n", "\t/* Load up variables set on command line. */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 's', n ); n++ )\n", "\t{\n", "\t    const char *symv[2];\n", "\t    symv[0] = s;\n", "\t    symv[1] = 0;\n", "\t    var_defines( symv );\n", "\t}\n", "\n", "\t/* Initialize built-in rules */\n", "\n", "\tload_builtins();\n", "\n", "\t/* Parse ruleset */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'f', n ); n++ )\n", "\t    parse_file( s );\n", "\n", "\tif( !n )\n", "\t    parse_file( \"+\" );\n", "\n", "\tstatus = yyanyerrors();\n", "\n", "\t/* Manually touch -t targets */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 't', n ); n++ )\n", "\t    touchtarget( s );\n", "\n", "\t/* If an output file is specified, set globs.cmdout to that */\n", "\n", "\tif( s = getoptval( optv, 'o', 0 ) )\n", "\t{\n", "\t    if( !( globs.cmdout = fopen( s, \"w\" ) ) )\n", "\t    {\n", "\t\tprintf( \"Failed to write to '%s'\\n\", s );\n", "\t\texit( EXITBAD );\n", "\t    }\n", "\t    globs.noexec++;\n", "\t}\n", "\n", "\t/* Now make target */\n", "\n", "\tif( !argc )\n", "\t    status |= make( 1, &all, anyhow );\n", "\telse\n", "\t    status |= make( argc, (const char **)argv, anyhow );\n", "\n", "\t/* Widely scattered cleanup */\n", "\n", "\tvar_done();\n", "\tdonerules();\n", "\tdonestamps();\n", "\tdonestr();\n", "\n", "\t/* close cmdout */\n", "\n", "\tif( globs.cmdout )\n", "\t    fclose( globs.cmdout );\n", "\n", "\treturn status ? EXITBAD : EXITOK;\n", "}\n"], "project": "jam", "file": "jam.pkl", "function": "main"}, {"comment_all": {"comment": "/* Enumerate through standard types of LNB's until NULL returned.\n * Increment curno each time\n */", "depth": 0, "reading_ease": 73.34, "reading_grade": 4.6, "line": 59}, "comment_text": "/* Enumerate through standard types of LNB's until NULL returned.\n * Increment curno each time\n */", "comment_tokens": ["Enumerate", "through", "standard", "types", "of", "LNB", "'s", "until", "NULL", "returned", ".", "Increment", "curno", "each", "time"], "ccode": ["\n", "/* Enumerate through standard types of LNB's until NULL returned.\n", " * Increment curno each time\n", " */\n", "\n", "struct lnb_types_st *\n", "lnb_enum(int curno)\n", "{\n", "        if (curno >= (int) (sizeof(lnbs) / sizeof(lnbs[0])))\n", "                return (struct lnb_types_st *)NULL;\n", "        return &lnbs[curno];\n", "}\n"], "project": "w-scan", "file": "lnb.pkl", "function": "lnb_enum"}, {"comment_all": {"comment": "/*\n\t\t\t\t * This is a process with the same name\n\t\t\t\t * as another, but a different PID.\n\t\t\t\t *\n\t\t\t\t * We'll store a reference in the PID\n\t\t\t\t * tree...\n\t\t\t\t */", "depth": 4, "reading_ease": 85.69, "reading_grade": 4.0, "line": 178}, "comment_text": "/*\n\t\t\t\t * This is a process with the same name\n\t\t\t\t * as another, but a different PID.\n\t\t\t\t *\n\t\t\t\t * We'll store a reference in the PID\n\t\t\t\t * tree...\n\t\t\t\t */", "comment_tokens": ["This", "is", "a", "process", "with", "the", "same", "name", "as", "another", ",", "but", "a", "different", "PID", ".", "We", "'ll", "store", "a", "reference", "in", "the", "PID", "tree", "..."], "ccode": ["\n", "struct p_info *find_process(__u32 pid, char *name)\n", "{\n", "\tstruct p_info *pip;\n", "\n", "\tif (pid != ((__u32)-1)) {\n", "\t\tif ((pip = __find_process_pid(pid)) != NULL)\n", "\t\t\treturn pip;\n", "\t\telse if (name) {\n", "\t\t\tpip = __find_process_name(name);\n", "\n", "\t\t\tif (pip && pid != pip->pid) {\n", "\t\t\t\t/*\n", "\t\t\t\t * This is a process with the same name\n", "\t\t\t\t * as another, but a different PID.\n", "\t\t\t\t *\n", "\t\t\t\t * We'll store a reference in the PID\n", "\t\t\t\t * tree...\n", "\t\t\t\t */\n", "\t\t\t\tinsert_pid(pip, pid);\n", "\t\t\t}\n", "\t\t\treturn pip;\n", "\t\t}\n", "\n", "\t\t/*\n", "\t\t * We're here because we have a pid, and no name, but\n", "\t\t * we didn't find a process ...\n", "\t\t *\n", "\t\t * We'll craft one using the pid...\n", "\t\t */\n", "\n", "\t\tname = alloca(256);\n", "\t\tsprintf(name, \"pid%09u\", pid);\n", "\t\tprocess_alloc(pid, name);\n", "\t\treturn __find_process_pid(pid);\n", "\t}\n", "\n", "\treturn __find_process_name(name);\n", "}\n"], "project": "blktrace", "file": "proc.pkl", "function": "find_process"}, {"comment_all": {"comment": "/**\n\t * GsfOutputIconv:fallback:\n\t *\n\t * Either NULL or a UTF-8 string (representable in the target encoding)\n\t * to convert and output in place of characters that cannot be represented\n\t * in the target encoding.  NULL means use \\u1234 or \\U12345678 format.\n\t */", "depth": 1, "reading_ease": 45.25, "reading_grade": 11.3, "line": 302}, "comment_text": "/**\n\t * GsfOutputIconv:fallback:\n\t *\n\t * Either NULL or a UTF-8 string (representable in the target encoding)\n\t * to convert and output in place of characters that cannot be represented\n\t * in the target encoding.  NULL means use \\u1234 or \\U12345678 format.\n\t */", "comment_tokens": ["GsfOutputIconv", ":", "fallback", ":", "Either", "NULL", "or", "a", "UTF-8", "string", "(", "representable", "in", "the", "target", "encoding", ")", "to", "convert", "and", "output", "in", "place", "of", "characters", "that", "can", "not", "be", "represented", "in", "the", "target", "encoding", ".", "NULL", "means", "use", "\\u1234", "or", "\\U12345678", "format", "."], "ccode": ["\n", "static void\n", "gsf_output_iconv_class_init (GObjectClass *gobject_class)\n", "{\n", "\tGsfOutputClass *output_class = GSF_OUTPUT_CLASS (gobject_class);\n", "\n", "\tgobject_class->finalize     = gsf_output_iconv_finalize;\n", "\tgobject_class->set_property = gsf_output_iconv_set_property;\n", "\tgobject_class->get_property = gsf_output_iconv_get_property;\n", "\toutput_class->Write\t    = gsf_output_iconv_write;\n", "\toutput_class->Seek\t    = gsf_output_iconv_seek;\n", "\toutput_class->Close\t    = gsf_output_iconv_close;\n", "\n", "\tg_object_class_install_property\n", "\t\t(gobject_class,\n", "\t\t PROP_SINK,\n", "\t\t g_param_spec_object (\"sink\",\n", "\t\t\t\t      _(\"Sink\"),\n", "\t\t\t\t      _(\"Where the converted data is written\"),\n", "\t\t\t\t      GSF_OUTPUT_TYPE,\n", "\t\t\t\t      GSF_PARAM_STATIC |\n", "\t\t\t\t      G_PARAM_READWRITE |\n", "\t\t\t\t      G_PARAM_CONSTRUCT_ONLY));\n", "\n", "\tg_object_class_install_property\n", "\t\t(gobject_class,\n", "\t\t PROP_INPUT_CHARSET,\n", "\t\t g_param_spec_string (\"input-charset\",\n", "\t\t\t\t      _(\"Input Charset\"),\n", "\t\t\t\t      _(\"The character set to convert from\"),\n", "\t\t\t\t      \"UTF-8\",\n", "\t\t\t\t      GSF_PARAM_STATIC |\n", "\t\t\t\t      G_PARAM_READWRITE |\n", "\t\t\t\t      G_PARAM_CONSTRUCT_ONLY));\n", "\tg_object_class_install_property\n", "\t\t(gobject_class,\n", "\t\t PROP_OUTPUT_CHARSET,\n", "\t\t g_param_spec_string (\"output-charset\",\n", "\t\t\t\t      _(\"Output Charset\"),\n", "\t\t\t\t      _(\"The character set to convert to\"),\n", "\t\t\t\t      \"UTF-8\",\n", "\t\t\t\t      GSF_PARAM_STATIC |\n", "\t\t\t\t      G_PARAM_READWRITE |\n", "\t\t\t\t      G_PARAM_CONSTRUCT_ONLY));\n", "\t/**\n", "\t * GsfOutputIconv:fallback:\n", "\t *\n", "\t * Either NULL or a UTF-8 string (representable in the target encoding)\n", "\t * to convert and output in place of characters that cannot be represented\n", "\t * in the target encoding.  NULL means use \\u1234 or \\U12345678 format.\n", "\t */\n", "\tg_object_class_install_property\n", "\t\t(gobject_class,\n", "\t\t PROP_FALLBACK,\n", "\t\t g_param_spec_string (\"fallback\",\n", "\t\t\t\t      _(\"Fallback\"),\n", "\t\t\t\t      _(\"The string to use for invalid characters\"),\n", "\t\t\t\t      NULL,\n", "\t\t\t\t      GSF_PARAM_STATIC |\n", "\t\t\t\t      G_PARAM_READWRITE));\n", "\n", "\tparent_class = g_type_class_peek_parent (gobject_class);\n", "}\n"], "project": "libgsf-1-114", "file": "gsf-output-iconv.pkl", "function": "gsf_output_iconv_class_init"}, {"comment_all": {"comment": "/* write_pid\n *\n * Writes the pid to the specified file. If that fails 0 is\n * returned, otherwise the pid.\n */", "depth": 0, "reading_ease": 88.23, "reading_grade": 3.1, "line": 84}, "comment_text": "/* write_pid\n *\n * Writes the pid to the specified file. If that fails 0 is\n * returned, otherwise the pid.\n */", "comment_tokens": ["write_pid", "Writes", "the", "pid", "to", "the", "specified", "file", ".", "If", "that", "fails", "0", "is", "returned", ",", "otherwise", "the", "pid", "."], "ccode": ["\n", "/* write_pid\n", " *\n", " * Writes the pid to the specified file. If that fails 0 is\n", " * returned, otherwise the pid.\n", " */\n", "int write_pid (char *pidfile)\n", "{\n", "  FILE *f;\n", "  int fd;\n", "  int pid;\n", "\n", "  if ( ((fd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1)\n", "       || ((f = fdopen(fd, \"r+\")) == NULL) ) {\n", "      fprintf(stderr, \"Can't open or create %s.\\n\", pidfile ? pidfile : \"(null)\");\n", "      return 0;\n", "  }\n", "  \n", "#ifdef HAVE_FLOCK\n", "  if (flock(fd, LOCK_EX|LOCK_NB) == -1) {\n", "      fscanf(f, \"%d\", &pid);\n", "      fclose(f);\n", "      printf(\"Can't lock, lock is held by pid %d.\\n\", pid);\n", "      return 0;\n", "  }\n", "#endif\n", "\n", "  pid = getpid();\n", "  if (!fprintf(f,\"%d\\n\", pid)) {\n", "      printf(\"Can't write pid , %s.\\n\", strerror(errno));\n", "      close(fd);\n", "      return 0;\n", "  }\n", "  fflush(f);\n", "\n", "#ifdef HAVE_FLOCK\n", "  if (flock(fd, LOCK_UN) == -1) {\n", "      printf(\"Can't unlock pidfile %s, %s.\\n\", pidfile, strerror(errno));\n", "      close(fd);\n", "      return 0;\n", "  }\n", "#endif\n", "  close(fd);\n", "\n", "  return pid;\n", "}\n"], "project": "gvpe", "file": "pidfile.pkl", "function": "write_pid"}, {"comment_all": {"comment": "/* computed brush */", "depth": 2, "reading_ease": 35.61, "reading_grade": 8.8, "line": 137}, "comment_text": "/* computed brush */\n/* FIXME: support it! */\n", "comment_tokens": ["computed", "brush", "FIXME", ":", "support", "it", "!"], "ccode": ["\n", "GbrBrush *\n", "abr_brush_load(FILE *abr)\n", "{\n", "\tAbrBrushHeader abr_brush_hdr;\n", "\tGbrBrush *gbr = NULL;\n", "\n", "\tg_return_val_if_fail ( abr != NULL, NULL );\n", "\n", "\tabr_brush_hdr.type = abr_read_short(abr);\n", "\tabr_brush_hdr.size = abr_read_long(abr);\n", "\tg_print(\" + BRUSH\\n | << type: %d  block size: %d bytes\\n\",\n", "\t\tabr_brush_hdr.type, abr_brush_hdr.size);\n", "\n", "\tswitch (abr_brush_hdr.type) {\n", "\tcase 1: /* computed brush */\n", "\t\t/* FIXME: support it! */\n", "\t\tg_print(\"WARNING: computed brush unsupported, skipping.\\n\");\n", "\t\tfseek(abr, abr_brush_hdr.size, SEEK_CUR);\n", "\t\tbreak;\n", "\tcase 2: /* sampled brush */\n", "\t\t{\n", "\t\t\tAbrSampledBrushHeader abr_sampled_brush_hdr;\n", "\t\t\tgint width, height;\n", "\t\t\tgint size;\n", "\t\t\tgint i = 0;\n", "\n", "\t\t\tabr_sampled_brush_hdr.misc\t\t\t\t\t= abr_read_long(abr);\n", "\t\t\tabr_sampled_brush_hdr.spacing\t\t\t\t= abr_read_short(abr);\n", "\t\t\tabr_sampled_brush_hdr.antialiasing\t= abr_read_char(abr);\n", "\n", "\t\t\tfor (i = 0; i < 4; i++)\n", "\t\t\t\tabr_sampled_brush_hdr.bounds[i] = abr_read_short(abr);\n", "\t\t\tfor (i = 0; i < 4; i++) {\n", "\t\t\t\tabr_sampled_brush_hdr.bounds_long[i] = abr_read_long(abr);\n", "\t\t\t}\n", "\t\t\tabr_sampled_brush_hdr.depth\t\t\t\t\t= abr_read_short(abr);\n", "\n", "\t\t\theight = abr_sampled_brush_hdr.bounds_long[2] - \n", "\t\t\t\tabr_sampled_brush_hdr.bounds_long[0]; /* bottom - top */\n", "\t\t\twidth = abr_sampled_brush_hdr.bounds_long[3] -\n", "\t\t\t\tabr_sampled_brush_hdr.bounds_long[1]; /* right - left */\n", "\t\t\tsize = width * (abr_sampled_brush_hdr.depth >> 3) * height;\n", "\n", "\t\t\t/* FIXME: support wide brushes */\n", "\t\t\tabr_sampled_brush_hdr.wide = height > 16384;\n", "\t\t\tif (abr_sampled_brush_hdr.wide)\n", "\t\t\t\tg_print(\"WARING: wide brushes not supported\\n\");\n", "\n", "\t\t\tgbr = g_new0(GbrBrush, 1);\n", "\t\t\tgbr->header.version\t\t\t\t= g_htonl(2);\n", "\t\t\tgbr->header.width\t\t\t\t\t= g_htonl(width);\n", "\t\t\tgbr->header.height\t\t\t\t= g_htonl(height);\n", "\t\t\tgbr->header.depth\t\t\t\t\t= g_htonl(abr_sampled_brush_hdr.depth >> 3);\n", "\t\t\tgbr->header.magic_number\t= g_htonl(GBRUSH_MAGIC);\n", "\t\t\tgbr->header.spacing\t\t\t\t= g_htonl(abr_sampled_brush_hdr.spacing);\n", "\t\t\tgbr->data\t\t\t\t\t\t\t\t\t= g_new0(gchar, size);\n", "\t\t\tgbr->size\t\t\t\t\t\t\t\t\t= size;\n", "\n", "\t\t\t/* data decoding */\n", "\t\t\t{\n", "\t\t\t\tgshort comp;\n", "\n", "\t\t\t\tcomp = abr_read_char(abr);\n", "\t\t\t\tg_print(\" | << size: %dx%d %d bit (%d bytes) %s\\n\",\n", "\t\t\t\t\twidth, height, abr_sampled_brush_hdr.depth, size,\n", "\t\t\t\t\tcomp ? \"compressed\" : \"raw\");\n", "\t\t\t\tif (!comp) {\n", "\t\t\t\t\tfread(gbr->data, size, 1, abr);\n", "\t\t\t\t} else {\n", "\t\t\t\t\tgint32 n;\n", "\t\t\t\t\tgchar ch;\n", "\t\t\t\t\tgint i, j, c;\n", "\t\t\t\t\tgshort *cscanline_len;\n", "\t\t\t\t\tgchar *data = gbr->data;\n", "\n", "\t\t\t\t\t/* read compressed size foreach scanline */\n", "\t\t\t\t\tcscanline_len = g_new0(gshort, height);\n", "\t\t\t\t\tfor (i = 0; i < height; i++)\n", "\t\t\t\t\t\tcscanline_len[i] = abr_read_short(abr);\n", "\t\t\t\t\t\t\n", "\t\t\t\t\t/* unpack each scanline data */\n", "\t\t\t\t\tfor (i = 0; i < height; i++) {\n", "\t\t\t\t\t\tfor (j = 0; j < cscanline_len[i];) {\n", "\t\t\t\t\t\t\tn = abr_read_char(abr);\n", "\t\t\t\t\t\t\tj++;\n", "\t\t\t\t\t\t\tif (n >= 128)\t\t\t/* force sign */\n", "\t\t\t\t\t\t\t\tn -= 256;\n", "\t\t\t\t\t\t\tif (n < 0) {\t\t\t/* copy the following char -n + 1 times */\n", "\t\t\t\t\t\t\t\tif (n == -128)\t/* it's a nop */\n", "\t\t\t\t\t\t\t\t\tcontinue;\n", "\t\t\t\t\t\t\t\tn = -n + 1;\n", "\t\t\t\t\t\t\t\tch = abr_read_char(abr);\n", "\t\t\t\t\t\t\t\tj++;\n", "\t\t\t\t\t\t\t\tfor (c = 0; c < n; c++, data++)\n", "\t\t\t\t\t\t\t\t\t*data = ch;\n", "\t\t\t\t\t\t\t} else {\t\t\t\t\t/* read the following n + 1 chars (no compr) */\n", "\t\t\t\t\t\t\t\tfor (c = 0; c < n + 1; c++, j++, data++)\n", "\t\t\t\t\t\t\t\t\t*data = (guchar)abr_read_char(abr);\n", "\t\t\t\t\t\t\t}\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t}\n", "\t\t\t\t\tg_free(cscanline_len);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tg_print(\"WARNING: unknown brush type, skipping.\\n\");\n", "\t\tfseek(abr, abr_brush_hdr.size, SEEK_CUR);\n", "\t}\n", "\n", "\treturn gbr;\n", "}\n"], "project": "abr2gbr", "file": "abr2gbr.pkl", "function": "abr_brush_load"}, {"comment_all": {"comment": "/*------------------------------------------------------------------------\nProcedure:     LOGGER_set_wrap ID:1\nPurpose:       Set log output wrapping to on or off\nInput:         int level: 0 = no wrap, > 0 = wrap.\nOutput:\nErrors:\n------------------------------------------------------------------------*/", "depth": 0, "reading_ease": 57.61, "reading_grade": 10.7, "line": 139}, "comment_text": "/*------------------------------------------------------------------------\nProcedure:     LOGGER_set_wrap ID:1\nPurpose:       Set log output wrapping to on or off\nInput:         int level: 0 = no wrap, > 0 = wrap.\nOutput:\nErrors:\n------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "Procedure", ":", "LOGGER_set_wrap", "ID:1", "Purpose", ":", "Set", "log", "output", "wrapping", "to", "on", "or", "off", "Input", ":", "int", "level", ":", "0", "=", "no", "wrap", ",", ">", "0", "=", "wrap", ".", "Output", ":", "Errors", ":", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["\n", "/*------------------------------------------------------------------------\n", "Procedure:     LOGGER_set_wrap ID:1\n", "Purpose:       Set log output wrapping to on or off\n", "Input:         int level: 0 = no wrap, > 0 = wrap.\n", "Output:\n", "Errors:\n", "------------------------------------------------------------------------*/\n", "int LOGGER_set_wrap( int level )\n", "{\n", "\tif ( level >= 0 )\n", "\t{\n", "\t\tLOGGER_glb.wrap = level;\n", "\t}\n", "\n", "\treturn LOGGER_glb.wrap;\n", "}\n"], "project": "altermime", "file": "logger.pkl", "function": "LOGGER_set_wrap"}, {"comment_all": {"comment": "/* TrueColor 24-bit plot->color mode */", "depth": 1, "reading_ease": 33.58, "reading_grade": 9.6, "line": 66}, "comment_text": "/* TrueColor 24-bit plot->color mode */", "comment_tokens": ["TrueColor", "24-bit", "plot-", ">", "color", "mode"], "ccode": ["/*\n", " * $Id: gp_cairo_helpers.c,v 1.3 2009/10/31 05:24:18 sfeam Exp $\n", " */\n", "\n", "/* GNUPLOT - gp_cairo_helpers.c */\n", "\n", "/*[\n", " * Copyright 2009   Timothee Lecomte\n", " *\n", " * Permission to use, copy, and distribute this software and its\n", " * documentation for any purpose with or without fee is hereby granted,\n", " * provided that the above copyright notice appear in all copies and\n", " * that both that copyright notice and this permission notice appear\n", " * in supporting documentation.\n", " *\n", " * Permission to modify the software is granted, but not the right to\n", " * distribute the complete modified source code.  Modifications are to\n", " * be distributed as patches to the released version.  Permission to\n", " * distribute binaries produced by compiling modified sources is granted,\n", " * provided you\n", " *   1. distribute the corresponding source modifications from the\n", " *    released version in the form of a patch file along with the binaries,\n", " *   2. add special version identification to distinguish your version\n", " *    in addition to the base release version number,\n", " *   3. provide your name and address as the primary contact for the\n", " *    support of your modified version, and\n", " *   4. retain our contact information in regard to use of the base\n", " *    software.\n", " * Permission to distribute the released version of the source code along\n", " * with corresponding source modifications in the form of a patch file is\n", " * granted with same provisions 2 through 4 for binary distributions.\n", " *\n", " * This software is provided \"as is\" without express or implied warranty\n", " * to the extent permitted by applicable law.\n", " *\n", " *\n", " * Alternatively, the contents of this file may be used under the terms of the\n", " * GNU General Public License Version 2 or later (the \"GPL\"), in which case the\n", " * provisions of GPL are applicable instead of those above. If you wish to allow\n", " * use of your version of this file only under the terms of the GPL and not\n", " * to allow others to use your version of this file under the above gnuplot\n", " * license, indicate your decision by deleting the provisions above and replace\n", " * them with the notice and other provisions required by the GPL. If you do not\n", " * delete the provisions above, a recipient may use your version of this file\n", " * under either the GPL or the gnuplot license.\n", "]*/\n", "\n", "#include \"gp_cairo_helpers.h\"\n", "\n", "#include \"alloc.h\"\n", "/* for rgb functions */\n", "# include \"getcolor.h\"\n", "\n", "unsigned int * gp_cairo_helper_coordval_to_chars(coordval* image, int M, int N, t_imagecolor color_mode)\n", "{\n", "\tint m,n;\n", "\tunsigned int *image255, *image255copy;\n", "\trgb_color rgb1;\n", "\trgb255_color rgb255;\n", "\n", "\t/* cairo image buffer, upper bits are alpha, then r, g and b\n", "\t * Depends on endianess */\n", "\timage255 = (unsigned int*) malloc(M*N*sizeof(unsigned int));\n", "\tif (!image255) { fprintf(stderr,\"cairo terminal: out of memory!\\n\"); gp_exit(EXIT_FAILURE);}\n", "\timage255copy = image255;\n", "\n", "\t/* TrueColor 24-bit plot->color mode */\n", "\tif (color_mode == IC_RGB) {\n", "\t\tfor (n=0; n<N; n++) {\n", "\t\tfor (m=0; m<M; m++) {\n", "\t\t\trgb1.r = *image++;\n", "\t\t\trgb1.g = *image++;\n", "\t\t\trgb1.b = *image++;\n", "\t\t\trgb255_from_rgb1( rgb1, &rgb255 );\n", "\t\t\t*image255copy++ = (0xFF<<24) + (rgb255.r<<16) + (rgb255.g<<8) + rgb255.b;\n", "\t\t}\n", "\t\t}\n", "\t} else if (color_mode == IC_RGBA) {\n", "\t\tunsigned char alpha255;\n", "\t\tdouble alpha1;\n", "\t\tfor (n=0; n<N; n++) {\n", "\t\tfor (m=0; m<M; m++) {\n", "\t\t\talpha255 = *(image+3);\n", "\t\t\talpha1 = (float)alpha255 / 255.;\n", "\t\t\trgb1.r = alpha1 * (*image++);\n", "\t\t\trgb1.g = alpha1 * (*image++);\n", "\t\t\trgb1.b = alpha1 * (*image++);\n", "\t\t\timage++;\n", "\t\t\trgb255_from_rgb1( rgb1, &rgb255 );\n", "\t\t\t*image255copy++ = (alpha255<<24)\n", "\t\t\t\t\t+ (rgb255.r<<16) + (rgb255.g<<8) + rgb255.b;\n", "\t\t}\n", "\t\t}\n", "\t/* Palette plot->color lookup from gray value */\n", "\t} else {\n", "\t\tfor (n=0; n<N; n++) {\n", "\t\tfor (m=0; m<M; m++) {\n", "\t\t\tif (isnan(*image)) {\n", "\t\t\t\timage++;\n", "\t\t\t\t*image255copy++ = 0x00000000;\n", "\t\t\t} else {\n", "\t\t\t\trgb255maxcolors_from_gray( *image++, &rgb255 );\n", "\t\t\t\t*image255copy++ = (0xFF<<24) + (rgb255.r<<16) + (rgb255.g<<8) + rgb255.b;\n", "\t\t\t}\n", "\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\treturn image255;\n", "}\n"], "project": "gnuplot-x11", "file": "gp_cairo_helpers.pkl", "function": "gp_cairo_helper_coordval_to_chars"}, {"comment_all": {"comment": "/* we must parse it completely, apply our changes, */", "depth": 1, "reading_ease": 80.28, "reading_grade": 4.1, "line": 501}, "comment_text": "/* due to the structure of the `name' table, */\n/* we must parse it completely, apply our changes, */\n/* and rebuild it from scratch */\n", "comment_tokens": ["due", "to", "the", "structure", "of", "the", "`", "name", "'", "table", ",", "we", "must", "parse", "it", "completely", ",", "apply", "our", "changes", ",", "and", "rebuild", "it", "from", "scratch"], "ccode": ["\n", "\n", "/* we handle the `name' table as optional; */\n", "/* if there are problems not related to allocation, */\n", "/* simply return (or continue, if possible) without signaling an error, */\n", "/* and the original `name' table is not modified */\n", "\n", "FT_Error\n", "TA_sfnt_update_name_table(SFNT* sfnt,\n", "                          FONT* font)\n", "{\n", "  FT_Error error;\n", "\n", "  SFNT_Table* name_table;\n", "  FT_Byte* buf;\n", "  FT_ULong buf_len;\n", "\n", "  Naming_Table n;\n", "\n", "  FT_Byte* p;\n", "  FT_Byte* startp;\n", "  FT_Byte* endp;\n", "\n", "  FT_UShort i;\n", "\n", "\n", "  if (sfnt->name_idx == MISSING)\n", "    return TA_Err_Ok;\n", "\n", "  name_table = &font->tables[sfnt->name_idx];\n", "  buf = name_table->buf;\n", "  buf_len = name_table->len;\n", "\n", "  if (name_table->processed)\n", "    return TA_Err_Ok;\n", "\n", "  p = buf;\n", "\n", "  error = parse_name_header(&p, &n, buf_len, &startp, &endp);\n", "  if (error)\n", "    return TA_Err_Ok;\n", "\n", "  /* due to the structure of the `name' table, */\n", "  /* we must parse it completely, apply our changes, */\n", "  /* and rebuild it from scratch */\n", "  error = parse_name_records(&p, &n, buf, startp, endp, font);\n", "  if (error)\n", "    goto Exit;\n", "\n", "  error = parse_lang_tag_records(&p, &n, buf, startp, endp);\n", "  if (error)\n", "    goto Exit;\n", "\n", "  error = build_name_table(&n, name_table);\n", "  if (error)\n", "    goto Exit;\n", "\n", "  name_table->checksum = TA_table_compute_checksum(name_table->buf,\n", "                                                   name_table->len);\n", "\n", "Exit:\n", "  for (i = 0; i < n.name_count; i++)\n", "    font->deallocate(n.name_records[i].str);\n", "  for (i = 0; i < n.lang_tag_count; i++)\n", "    free(n.lang_tag_records[i].str);\n", "\n", "  free(n.name_records);\n", "  free(n.lang_tag_records);\n", "\n", "  name_table->processed = 1;\n", "\n", "  return error;\n", "}\n"], "project": "ttfautohint", "file": "taname.pkl", "function": "TA_sfnt_update_name_table"}, {"comment_all": {"comment": "/** Set the current line number.\n * @param _line_number line number\n * \n */", "depth": 0, "reading_ease": 83.83, "reading_grade": 2.7, "line": 3981}, "comment_text": "/** Set the current line number.\n * @param _line_number line number\n * \n */", "comment_tokens": ["Set", "the", "current", "line", "number", ".", "@", "param", "_line_number", "line", "number"], "ccode": ["\n", "/** Set the current line number.\n", " * @param _line_number line number\n", " * \n", " */\n", "void yyset_lineno (int  _line_number )\n", "{\n", "    \n", "    yylineno = _line_number;\n", "}\n"], "project": "linux-cloud-tools-5.11.0-1015-azure", "file": "lexer.lex.pkl", "function": "yyset_lineno"}, {"comment_all": {"comment": "/* End of \"debugging only\" */", "depth": 1, "reading_ease": 50.5, "reading_grade": 7.2, "line": 159}, "comment_text": "/* End of \"debugging only\" */", "comment_tokens": ["End", "of", "``", "debugging", "only", "''"], "ccode": ["/****************************************************************\n", "Copyright 1990-1996, 1999-2001 by AT&T, Lucent Technologies and Bellcore.\n", "\n", "Permission to use, copy, modify, and distribute this software\n", "and its documentation for any purpose and without fee is hereby\n", "granted, provided that the above copyright notice appear in all\n", "copies and that both that the copyright notice and this\n", "permission notice and warranty disclaimer appear in supporting\n", "documentation, and that the names of AT&T, Bell Laboratories,\n", "Lucent or Bellcore or any of their entities not be used in\n", "advertising or publicity pertaining to distribution of the\n", "software without specific, written prior permission.\n", "\n", "AT&T, Lucent and Bellcore disclaim all warranties with regard to\n", "this software, including all implied warranties of\n", "merchantability and fitness.  In no event shall AT&T, Lucent or\n", "Bellcore be liable for any special, indirect or consequential\n", "damages or any damages whatsoever resulting from loss of use,\n", "data or profits, whether in an action of contract, negligence or\n", "other tortious action, arising out of or in connection with the\n", "use or performance of this software.\n", "****************************************************************/\n", "\n", "/* Format.c -- this file takes an intermediate file (generated by pass 1\n", "   of the translator) and some state information about the contents of that\n", "   file, and generates C program text. */\n", "\n", "#include \"defs.h\"\n", "#include \"p1defs.h\"\n", "#include \"format.h\"\n", "#include \"output.h\"\n", "#include \"names.h\"\n", "#include \"iob.h\"\n", "\n", "int c_output_line_length = DEF_C_LINE_LENGTH;\n", "\n", "int last_was_label;\t/* Boolean used to generate semicolons\n", "\t\t\t\t   when a label terminates a block */\n", "static char this_proc_name[52];\t/* Name of the current procedure.  This is\n", "\t\t\t\t   probably too simplistic to handle\n", "\t\t\t\t   multiple entry points */\n", "\n", "static tagptr do_format Argdcl((FILEP, FILEP));\n", "static void do_p1_1while Argdcl((FILEP));\n", "static void do_p1_2while Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_addr Argdcl((FILEP, FILEP));\n", "static void do_p1_asgoto Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_charp Argdcl((FILEP));\n", "static void do_p1_comment Argdcl((FILEP, FILEP));\n", "static void do_p1_comp_goto Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_const Argdcl((FILEP));\n", "static void do_p1_elif Argdcl((FILEP, FILEP));\n", "static void do_p1_else Argdcl((FILEP));\n", "static void do_p1_elseifstart Argdcl((FILEP));\n", "static void do_p1_end_for Argdcl((FILEP));\n", "static void do_p1_endelse Argdcl((FILEP));\n", "static void do_p1_endif Argdcl((FILEP));\n", "static tagptr do_p1_expr Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_extern Argdcl((FILEP));\n", "static void do_p1_for Argdcl((FILEP, FILEP));\n", "static void do_p1_fortran Argdcl((FILEP, FILEP));\n", "static void do_p1_goto Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_head Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_ident Argdcl((FILEP));\n", "static void do_p1_if Argdcl((FILEP, FILEP));\n", "static void do_p1_label Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_list Argdcl((FILEP, FILEP));\n", "static tagptr do_p1_literal Argdcl((FILEP));\n", "static tagptr do_p1_name_pointer Argdcl((FILEP));\n", "static void do_p1_set_line Argdcl((FILEP));\n", "static void do_p1_subr_ret Argdcl((FILEP, FILEP));\n", "static int get_p1_token Argdcl((FILEP));\n", "static int p1get_const Argdcl((FILEP, int, Constp*));\n", "static int p1getd Argdcl((FILEP, long int*));\n", "static int p1getf Argdcl((FILEP, char**));\n", "static int p1getn Argdcl((FILEP, int, char**));\n", "static int p1gets Argdcl((FILEP, char*, int));\n", "static void proto Argdcl((FILEP, Argtypes*, char*));\n", "\n", "extern chainp assigned_fmts;\n", "char filename[P1_FILENAME_MAX];\n", "extern int gflag, sharp_line, trapuv;\n", "extern int typeconv[];\n", "int gflag1;\n", "extern char *parens;\n", "\n", " void\n", "start_formatting(Void)\n", "{\n", "    FILE *infile;\n", "    static int wrote_one = 0;\n", "    extern int usedefsforcommon;\n", "    extern char *p1_file, *p1_bakfile;\n", "\n", "    this_proc_name[0] = '\\0';\n", "    last_was_label = 0;\n", "    ei_next = ei_first;\n", "    wh_next = wh_first;\n", "\n", "    (void) fclose (pass1_file);\n", "    if ((infile = fopen (p1_file, binread)) == NULL)\n", "\tFatal(\"start_formatting:  couldn't open the intermediate file\\n\");\n", "\n", "    if (wrote_one)\n", "\tnice_printf (c_file, \"\\n\");\n", "\n", "    while (!feof (infile)) {\n", "\texpptr this_expr;\n", "\n", "\tthis_expr = do_format (infile, c_file);\n", "\tif (this_expr) {\n", "\t    out_and_free_statement (c_file, this_expr);\n", "\t} /* if this_expr */\n", "    } /* while !feof infile */\n", "\n", "    (void) fclose (infile);\n", "\n", "    if (last_was_label)\n", "\tnice_printf (c_file, \";\\n\");\n", "\n", "    prev_tab (c_file);\n", "    gflag1 = sharp_line = 0;\n", "    if (this_proc_name[0])\n", "\tnice_printf (c_file, \"} /* %s */\\n\", this_proc_name);\n", "\n", "\n", "/* Write the #undefs for common variable reference */\n", "\n", "    if (usedefsforcommon) {\n", "\tExtsym *ext;\n", "\tint did_one = 0;\n", "\n", "\tfor (ext = extsymtab; ext < nextext; ext++)\n", "\t    if (ext -> extstg == STGCOMMON && ext -> used_here) {\n", "\t\text -> used_here = 0;\n", "\t\tif (!did_one)\n", "\t\t    nice_printf (c_file, \"\\n\");\n", "\t\twr_abbrevs(c_file, 0, ext->extp);\n", "\t\tdid_one = 1;\n", "\t\text -> extp = CHNULL;\n", "\t    } /* if */\n", "\n", "\tif (did_one)\n", "\t    nice_printf (c_file, \"\\n\");\n", "    } /* if usedefsforcommon */\n", "\n", "    other_undefs(c_file);\n", "\n", "    wrote_one = 1;\n", "\n", "/* For debugging only */\n", "\n", "    if (debugflag && (pass1_file = fopen (p1_bakfile, binwrite)))\n", "\tif (infile = fopen (p1_file, binread)) {\n", "\t    ffilecopy (infile, pass1_file);\n", "\t    fclose (infile);\n", "\t    fclose (pass1_file);\n", "\t} /* if infile */\n", "\n", "/* End of \"debugging only\" */\n", "\n", "    scrub(p1_file);\t/* optionally unlink */\n", "\n", "    if ((pass1_file = fopen (p1_file, binwrite)) == NULL)\n", "\terr (\"start_formatting:  couldn't reopen the pass1 file\");\n", "\n", "} /* start_formatting */\n"], "project": "f2c", "file": "format.pkl", "function": "start_formatting"}, {"comment_all": {"comment": "/* IN A parsing can't fail */", "depth": 3, "reading_ease": 100.24, "reading_grade": 0.5, "line": 499}, "comment_text": "/* IN A parsing can't fail */", "comment_tokens": ["IN", "A", "parsing", "ca", "n't", "fail"], "ccode": ["\t\t     \n", "void ruli_parse_addr_rr(ruli_addr_t *addr, const ruli_rr_t *rr, long options)\n", "{\n", "  assert(ruli_rr_type_is_address(options, rr->type));\n", "\n", "  switch (rr->type) {\n", "  case RULI_RR_TYPE_A:\n", "    {\n", "      int result = ruli_parse_rr_a(&addr->addr.ipv4, \n", "\t\t\t\t   rr->rdata, rr->rdlength);\n", "      assert(!result); /* IN A parsing can't fail */\n", "    }\n", "    ruli_addr_init(addr, PF_INET);\n", "    break;\n", "    \n", "  case RULI_RR_TYPE_AAAA:\n", "    {\n", "      int result = ruli_parse_rr_aaaa(&addr->addr.ipv6, \n", "\t\t\t\t      rr->rdata, rr->rdlength);\n", "      assert(!result); /* IN AAAA parsing can't fail */\n", "    }\n", "    ruli_addr_init(addr, PF_INET6);\n", "    break;\n", "    \n", "  default:\n", "    /* Previous ruli_rr_type_is_address() call ensures\n", "     * RR type is either IN_A or IN_AAAA, thus we can\n", "     * panic otherwise.\n", "     */\n", "    assert(0);\n", "  }\n", "\n", "#ifdef RULI_RES_DEBUG\n", "  fprintf(stderr, \"DEBUG: ruli_parse_addr_rr(): addr=\");\n", "  ruli_addr_print(stderr, addr);\n", "  fprintf(stderr, \"\\n\");\n", "#endif\n", "}\n"], "project": "libruli-bin", "file": "ruli_parse.pkl", "function": "ruli_parse_addr_rr"}, {"comment_all": {"comment": "// Else (if head < tail), there is enough space only if dtbuf->tail is far\n", "depth": 1, "reading_ease": 92.12, "reading_grade": 3.6, "line": 47}, "comment_text": "// When dtbuf->head >= dtbuf->capacity, it \"cycles\" (reset to 0) if and\n// only if there is enough space at the start for a full chunk.\n// Thus, if dtbuf->head has not cycled while it is after capacity, then the\n// buffer is full.\n// Else, if head >= tail, there is always enough space (by design).\n// Else (if head < tail), there is enough space only if dtbuf->tail is far\n// enough (ie we can put a full chunk at the start).\n", "comment_tokens": ["When", "dtbuf-", ">", "head", ">", "=", "dtbuf-", ">", "capacity", ",", "it", "``", "cycles", "''", "(", "reset", "to", "0", ")", "if", "and", "only", "if", "there", "is", "enough", "space", "at", "the", "start", "for", "a", "full", "chunk", ".", "Thus", ",", "if", "dtbuf-", ">", "head", "has", "not", "cycled", "while", "it", "is", "after", "capacity", ",", "then", "the", "buffer", "is", "full", ".", "Else", ",", "if", "head", ">", "=", "tail", ",", "there", "is", "always", "enough", "space", "(", "by", "design", ")", ".", "Else", "(", "if", "head", "<", "tail", ")", ",", "there", "is", "enough", "space", "only", "if", "dtbuf-", ">", "tail", "is", "far", "enough", "(", "ie", "we", "can", "put", "a", "full", "chunk", "at", "the", "start", ")", "."], "ccode": ["\n", "int dtbuf_is_full(struct dtbuf *dtbuf)\n", "{\n", "    // When dtbuf->head >= dtbuf->capacity, it \"cycles\" (reset to 0) if and\n", "    // only if there is enough space at the start for a full chunk.\n", "    // Thus, if dtbuf->head has not cycled while it is after capacity, then the\n", "    // buffer is full.\n", "    // Else, if head >= tail, there is always enough space (by design).\n", "    // Else (if head < tail), there is enough space only if dtbuf->tail is far\n", "    // enough (ie we can put a full chunk at the start).\n", "    return dtbuf->head >= dtbuf->capacity || (dtbuf->head < dtbuf->tail\n", "                                              && dtbuf->tail - dtbuf->head <=\n", "                                              DTBUF_CHUNK_SIZE);\n", "}\n"], "project": "delay", "file": "dtbuf.pkl", "function": "dtbuf_is_full"}, {"comment_all": {"comment": "// This is to test the regression introduced by Levi for the Windows support\n", "depth": 1, "reading_ease": 66.74, "reading_grade": 7.2, "line": 104}, "comment_text": "// This is to test the regression introduced by Levi for the Windows support\n// that code errouneously read below the allowed area (in this case dir [-1]).\n// and caused all kinds of random errors.\n", "comment_tokens": ["This", "is", "to", "test", "the", "regression", "introduced", "by", "Levi", "for", "the", "Windows", "support", "that", "code", "errouneously", "read", "below", "the", "allowed", "area", "(", "in", "this", "case", "dir", "[", "-1", "]", ")", ".", "and", "caused", "all", "kinds", "of", "random", "errors", "."], "ccode": ["#include <config.h>\n", "#include <glib.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#ifdef HAVE_UNISTD_H\n", "#include <unistd.h>\n", "#endif\n", "#ifdef G_OS_UNIX\n", "#include <pthread.h>\n", "#endif\n", "#include \"test.h\"\n", "\n", "#ifdef G_OS_WIN32\n", "#include <direct.h>\n", "#define chdir _chdir\n", "#endif\n", "\n", "/* This test is just to be used with valgrind */\n", "static RESULT\n", "test_buildpath (void)\n", "{\n", "\tchar *s;\n", "\tconst char *buffer = \"var/private\";\n", "\tconst char *dir = \"/\";\n", "\t\n", "\ts = g_build_path (\"/\", \"hola///\", \"//mundo\", (const char*)NULL);\n", "\tif (strcmp (s, \"hola/mundo\") != 0)\n", "\t\treturn FAILED (\"1 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"/\", \"hola/\", \"/mundo\", (const char*)NULL);\n", "\tif (strcmp (s, \"hola/mundo\") != 0)\n", "\t\treturn FAILED (\"2 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"/\", \"hola/\", \"mundo\", (const char*)NULL);\n", "\tif (strcmp (s, \"hola/mundo\") != 0)\n", "\t\treturn FAILED (\"3 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"/\", \"hola\", \"/mundo\", (const char*)NULL);\n", "\tif (strcmp (s, \"hola/mundo\") != 0)\n", "\t\treturn FAILED (\"4 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"/\", \"/hello\", \"world/\", (const char*)NULL);\n", "\tif (strcmp (s, \"/hello/world/\") != 0)\n", "\t\treturn FAILED (\"5 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\t\n", "\t/* Now test multi-char-separators */\n", "\ts = g_build_path (\"**\", \"hello\", \"world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello**world\") != 0)\n", "\t\treturn FAILED (\"6 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"**\", \"hello**\", \"world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello**world\") != 0)\n", "\t\treturn FAILED (\"7 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"**\", \"hello**\", \"**world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello**world\") != 0)\n", "\t\treturn FAILED (\"8 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\t\n", "\ts = g_build_path (\"**\", \"hello**\", \"**world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello**world\") != 0)\n", "\t\treturn FAILED (\"9 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"1234567890\", \"hello\", \"world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello1234567890world\") != 0)\n", "\t\treturn FAILED (\"10 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"1234567890\", \"hello1234567890\", \"1234567890world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello1234567890world\") != 0)\n", "\t\treturn FAILED (\"11 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"1234567890\", \"hello12345678901234567890\", \"1234567890world\", (const char*)NULL);\n", "\tif (strcmp (s, \"hello1234567890world\") != 0)\n", "\t\treturn FAILED (\"12 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\t/* Multiple */\n", "\ts = g_build_path (\"/\", \"a\", \"b\", \"c\", \"d\", (const char*)NULL);\n", "\tif (strcmp (s, \"a/b/c/d\") != 0)\n", "\t\treturn FAILED (\"13 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\ts = g_build_path (\"/\", \"/a\", \"\", \"/c/\", (const char*)NULL);\n", "\tif (strcmp (s, \"/a/c/\") != 0)\n", "\t\treturn FAILED (\"14 Got wrong result, got: %s\", s);\n", "\tg_free (s);\n", "\n", "\t/* Null */\n", "\ts = g_build_path (\"/\", NULL, (const char*)NULL);\n", "\tif (s == NULL)\n", "\t\treturn FAILED (\"must get a non-NULL return\");\n", "\tif (s [0] != 0)\n", "\t\treturn FAILED (\"must get an empty string\");\n", "\n", "\t// This is to test the regression introduced by Levi for the Windows support\n", "\t// that code errouneously read below the allowed area (in this case dir [-1]).\n", "\t// and caused all kinds of random errors.\n", "\tdir = \"//\";\n", "\tdir++;\n", "\ts = g_build_filename (dir, buffer, (const char*)NULL);\n", "\tif (s [0] != '/')\n", "\t\treturn FAILED (\"Must have a '/' at the start\");\n", "\n", "\tg_free (s);\n", "\treturn OK;\n", "}\n"], "project": "libmono-system-deployment4.0-cil", "file": "path.pkl", "function": "test_buildpath"}, {"comment_all": {"comment": "/**\n * gsf_input_size:\n * @input: The input\n *\n * Returns: the total number of bytes in the input or -1 on error\n **/", "depth": 0, "reading_ease": 54.22, "reading_grade": 9.9, "line": 321}, "comment_text": "/**\n * gsf_input_size:\n * @input: The input\n *\n * Returns: the total number of bytes in the input or -1 on error\n **/", "comment_tokens": ["gsf_input_size", ":", "@", "input", ":", "The", "input", "Returns", ":", "the", "total", "number", "of", "bytes", "in", "the", "input", "or", "-1", "on", "error"], "ccode": ["\n", "/**\n", " * gsf_input_size:\n", " * @input: The input\n", " *\n", " * Returns: the total number of bytes in the input or -1 on error\n", " **/\n", "gsf_off_t\n", "gsf_input_size (GsfInput *input)\n", "{\n", "\tg_return_val_if_fail (input != NULL, -1);\n", "\treturn input->size;\n", "}\n"], "project": "libgsf-1-114", "file": "gsf-input.pkl", "function": "gsf_input_size"}, {"comment_all": {"comment": "/* replace a new line with a space */", "depth": 1, "reading_ease": 106.67, "reading_grade": 0.1, "line": 166}, "comment_text": "/* replace a new line with a space */", "comment_tokens": ["replace", "a", "new", "line", "with", "a", "space"], "ccode": ["\n", "static char *do_shell(int argc, char *argv[])\n", "{\n", "\tFILE *p;\n", "\tchar buf[256];\n", "\tchar *cmd;\n", "\tsize_t nread;\n", "\tint i;\n", "\n", "\tcmd = argv[0];\n", "\n", "\tp = popen(cmd, \"r\");\n", "\tif (!p) {\n", "\t\tperror(cmd);\n", "\t\texit(1);\n", "\t}\n", "\n", "\tnread = fread(buf, 1, sizeof(buf), p);\n", "\tif (nread == sizeof(buf))\n", "\t\tnread--;\n", "\n", "\t/* remove trailing new lines */\n", "\twhile (nread > 0 && buf[nread - 1] == '\\n')\n", "\t\tnread--;\n", "\n", "\tbuf[nread] = 0;\n", "\n", "\t/* replace a new line with a space */\n", "\tfor (i = 0; i < nread; i++) {\n", "\t\tif (buf[i] == '\\n')\n", "\t\t\tbuf[i] = ' ';\n", "\t}\n", "\n", "\tif (pclose(p) == -1) {\n", "\t\tperror(cmd);\n", "\t\texit(1);\n", "\t}\n", "\n", "\treturn xstrdup(buf);\n", "}\n"], "project": "linux-buildinfo-5.11.0-38-lowlatency", "file": "preprocess.pkl", "function": "do_shell"}, {"comment_all": {"comment": "/* iterate the groups list to see if each group any effect on the active */", "depth": 1, "reading_ease": 82.65, "reading_grade": 5.2, "line": 50}, "comment_text": "/* iterate the groups list to see if each group any effect on the active */", "comment_tokens": ["iterate", "the", "groups", "list", "to", "see", "if", "each", "group", "any", "effect", "on", "the", "active"], "ccode": ["/*\n", " * This routine does an exhaustive check on the groups file.\n", " * It weeds out:\n", " *\n", " * all redundant additions.\n", " * all !groups that don't filter anything.\n", " * all groups that don't match any of the actives.\n", " *\n", " * Any such groups are deleted.\n", " *\n", " * CP is not considered an issue...\n", " */\n", "\n", "#include \"gup.h\"\n", "\n", "/* Remove all superfluous groups */\n", "void prune(LIST *active_l, LIST *group_l)\n", "{\n", "    GROUP *gp;\n", "    GROUP *ap;\n", "    int groupcount;\n", "\n", "    groupcount = 0;\n", "    /* tag the active list */\n", "    TRAVERSE(active_l, ap) {\n", "\tap->u.tag = NULL;\n", "\n", "\tTRAVERSE(group_l, gp) {\n", "\t    if (wildmat(ap->name, gp->name)) {\n", "\t\tTAG *t = (TAG *) malloc(sizeof(TAG));\n", "\t\tif (!t) {\n", "\t\t    logit(L_BOTH, \"WARNING: insufficient memory to prune!\");\n", "\t\t    return;\n", "\t\t}\n", "\t\t/* add the group to the front of this ap's tag list */\n", "\t\tt->group = gp;\n", "\t\tt->next = ap->u.tag;\n", "\t\tap->u.tag = t;\n", "\t    }\n", "\t}\n", "\tif (ap && ap->u.tag && ap->u.tag->group)\n", "\t    if (ap->u.tag->group->u.not == GUP_INCLUDE)\n", "\t\tgroupcount++;\n", "    }\n", "\n", "    /* see if too many groups in the list */\n", "    if (groupcount > maxgroups)\n", "\tgupout(1, \"Too many groups (%d, only %d allowed)\",\n", "\t\tgroupcount, maxgroups);\n", "\n", "    /* iterate the groups list to see if each group any effect on the active */\n", "    TRAVERSE(group_l, gp) {\n", "\tint effect = FALSE;\n", "\n", "\tTRAVERSE(active_l, ap) {\n", "\t    TAG *tag = ap->u.tag;\n", "\n", "\t    /* does gp affect ap? */\n", "\t    if (tag && tag->group == gp && ((!tag->next && !gp->u.not) ||\n", "\t\t(tag->next && tag->next->group->u.not != gp->u.not))) {\n", "\t\teffect = TRUE;\n", "\t\tbreak;\n", "\t    }\n", "\t}\n", "\n", "\tif (!effect && gp->u.not != GUP_POISON) {\n", "\t    /* group doesn't do anything - clobber it */\n", "\n", "\t    /*\n", "\t     * remove it from any tags in which it appears - makes the\n", "\t     * tag-check faster.  We *could* have done an active tag list\n", "\t     * for each group to speed this, but it at the expense of the\n", "\t     * initial tagging process.  As implemented here, we assume\n", "\t     * pruning is a relatively rare occurrence.\n", "\t     */\n", "\t    TRAVERSE(active_l, ap) {\n", "\t\tTAG *t, *prev;\n", "\n", "\t\tfor (prev = NULL, t = ap->u.tag; t; prev = t, t = t->next) {\n", "\t\t    if (t->group == gp) {\n", "\t\t\tif (!prev)\n", "\t\t\t    ap->u.tag = t->next;\n", "\t\t\telse\n", "\t\t\t    prev->next = t->next;\n", "\t\t\tfree(t);\n", "\n", "\t\t\tbreak;\n", "\t\t    }\n", "\t\t}\n", "\t    }\n", "\n", "\t    remove_group(group_l, gp);\n", "\n", "\t    logit(L_BOTH, \"PRUNED: %s %s subsumed\",\n", "\t\t    gp->u.not ? \"exclude\" : \"include\", gp->name);\n", "\t}\n", "    }\n", "}\n"], "project": "gup", "file": "prune.pkl", "function": "prune"}, {"comment_all": {"comment": "/* Incorrect, no longer in table */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 320}, "comment_text": "/* Incorrect, no longer in table */", "comment_tokens": ["Incorrect", ",", "no", "longer", "in", "table"], "ccode": ["\n", "/**\n", " * @ingroup Sliced\n", " * @param service A data service identifier, for example from a\n", " *   vbi_sliced structure.\n", " *\n", " * @return\n", " * Number of payload bits, @c 0 if the service is unknown.\n", " */\n", "unsigned int\n", "vbi_sliced_payload_bits\t\t(unsigned int\t\tservice)\n", "{\n", "\tconst _vbi_service_par *par;\n", "\n", "\t/* These are ambiguous */\n", "\tif (service == VBI_SLICED_CAPTION_525)\n", "\t\treturn 16;\n", "\tif (service == VBI_SLICED_CAPTION_625)\n", "\t\treturn 16;\n", "\tif (service == (VBI_SLICED_VPS | VBI_SLICED_VPS_F2))\n", "\t\treturn 13 * 8;\n", "\tif (service == VBI_SLICED_TELETEXT_B_L25_625)\n", "\t\treturn 42 * 8;\n", "\n", "\t/* Incorrect, no longer in table */\n", "\tif (service == VBI_SLICED_TELETEXT_BD_525)\n", "\t\treturn 34 * 8;\n", "\n", "\tif ((par = find_service_par (service)))\n", "\t\treturn par->payload;\n", "\n", "\treturn 0;\n", "}\n"], "project": "libzvbi0", "file": "raw_decoder.pkl", "function": "vbi_sliced_payload_bits"}, {"comment_all": {"comment": "/* Length of source string */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 38}, "comment_text": "/* O - Length of string */\n/* O - Destination string */\n/* I - Source string */\n/* I - Size of destination string buffer */\n/* Length of source string */\n/* Length of destination string */\n", "comment_tokens": ["O", "-", "Length", "of", "string", "O", "-", "Destination", "string", "I", "-", "Source", "string", "I", "-", "Size", "of", "destination", "string", "buffer", "Length", "of", "source", "string", "Length", "of", "destination", "string"], "ccode": ["/*\n", " * \"$Id: flstring.c 4288 2005-04-16 00:13:17Z mike $\"\n", " *\n", " * BSD string functions for the Fast Light Tool Kit (FLTK).\n", " *\n", " * Copyright 1998-2005 by Bill Spitzak and others.\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n", " * USA.\n", " *\n", " * Please report all bugs and problems on the following page:\n", " *\n", " *     http://www.fltk.org/str.php\n", " */\n", "\n", "#include \"flstring.h\"\n", "\n", "\n", "/*\n", " * 'fl_strlcat()' - Safely concatenate two strings.\n", " */\n", "\n", "size_t\t\t\t\t/* O - Length of string */\n", "fl_strlcat(char       *dst,\t/* O - Destination string */\n", "           const char *src,\t/* I - Source string */\n", "\t   size_t     size) {\t/* I - Size of destination string buffer */\n", "  size_t\tsrclen;\t\t/* Length of source string */\n", "  size_t\tdstlen;\t\t/* Length of destination string */\n", "\n", "\n", " /*\n", "  * Figure out how much room is left...\n", "  */\n", "\n", "  dstlen = strlen(dst);\n", "  size   -= dstlen + 1;\n", "\n", "  if (!size) return (dstlen);\t/* No room, return immediately... */\n", "\n", " /*\n", "  * Figure out how much room is needed...\n", "  */\n", "\n", "  srclen = strlen(src);\n", "\n", " /*\n", "  * Copy the appropriate amount...\n", "  */\n", "\n", "  if (srclen > size) srclen = size;\n", "\n", "  memcpy(dst + dstlen, src, srclen);\n", "  dst[dstlen + srclen] = '\\0';\n", "\n", "  return (dstlen + srclen);\n", "}\n"], "project": "fltk1.1-doc", "file": "flstring.pkl", "function": "fl_strlcat"}, {"comment_all": {"comment": "/* Show the content in case the session gets visible again. */", "depth": 2, "reading_ease": 78.25, "reading_grade": 4.8, "line": 119}, "comment_text": "/* Show the content in case the session gets visible again. */", "comment_tokens": ["Show", "the", "content", "in", "case", "the", "session", "gets", "visible", "again", "."], "ccode": ["\n", "static gboolean\n", "gs_monitor_switch_greeter (GSMonitor *monitor)\n", "{\n", "        gboolean visible;\n", "\n", "        visible = gs_manager_get_session_visible (monitor->priv->manager);\n", "\n", "        /* Only switch to greeter if we are the visible session */\n", "        if (visible) {\n", "                gs_listener_send_switch_greeter (monitor->priv->listener);\n", "        } else {\n", "                /* Show the content in case the session gets visible again. */\n", "                gs_manager_show_content (monitor->priv->manager);\n", "        }\n", "\n", "        return FALSE;\n", "}\n"], "project": "light-locker", "file": "gs-monitor.pkl", "function": "gs_monitor_switch_greeter"}, {"comment_all": {"comment": "/* put the cursor at the current location */", "depth": 1, "reading_ease": 64.37, "reading_grade": 6.0, "line": 114}, "comment_text": "/* put the cursor at the current location */\n/* this was a really bad idea for Xterm users, because\n * current pos char was written in \"standout\", and the\n * text cursor of xterm re-reverse it. \n *    XXX wmove(pop, clig+2, ccol+1);\n */\n", "comment_tokens": ["put", "the", "cursor", "at", "the", "current", "location", "this", "was", "a", "really", "bad", "idea", "for", "Xterm", "users", ",", "because", "current", "pos", "char", "was", "written", "in", "``", "standout", "''", ",", "and", "the", "text", "cursor", "of", "xterm", "re-reverse", "it", ".", "XXX", "wmove", "(", "pop", ",", "clig+2", ",", "ccol+1", ")", ";"], "ccode": ["/*----------------------------------------------------------------*/\n", "#define ASCV_I2LIG(idx)  ((idx)>>6)\n", "#define ASCV_I2COL(idx)  ((idx)&63)\n", "\n", "static int av_affiche(Fichier *fic, WINDOW *pop, int clig, int ccol)\n", "{\n", "int\t\tfoo, lig, col, car;\n", "char\t\tchaine[100];\n", "long\t\tdepl;\n", "unsigned char\toctet;\n", "\n", "wstandout(pop);\n", "for (foo=1; foo<65; foo++)\n", "\tmvwaddch(pop, 1, foo, ' ');\n", "mvwaddstr(pop, 1, 2, fic->nom);\n", "\n", "depl = (clig*64)+ccol;\n", "octet = fic->buffer[depl];\n", "sprintf(chaine, \"%7ld : %3d   0x%02x   0%03o\",\n", "\t\t\tfic->offset+depl, octet, octet, octet);\n", "mvwaddstr(pop, 18, 1, chaine);\n", "mvwaddstr(pop, 18, 33, \"             \");\n", "mvwaddstr(pop, 18, 33, ascii_name(fic->buffer[depl]));\n", "wstandend(pop);\n", "\n", "for (foo=0; foo<16*64; foo++)\n", "\t{\n", "\tlig = ASCV_I2LIG(foo);\n", "\tcol = ASCV_I2COL(foo);\n", "\tcar = fic->buffer[foo];\n", "\tcar = is_printable(car) ? car : ' ';\n", "\tif (clig==lig && ccol==col)\n", "\t\twstandout(pop);\n", "\tmvwaddch(pop, lig+2, col+1, car);\n", "\tif (clig==lig && ccol==col)\n", "\t\twstandend(pop);\n", "\t}\n", "\n", "/* put the cursor at the current location */\n", "/* this was a really bad idea for Xterm users, because\n", " * current pos char was written in \"standout\", and the\n", " * text cursor of xterm re-reverse it. \n", " *    XXX wmove(pop, clig+2, ccol+1);\n", " */\n", "wmove(pop,1,64);\n", "\n", "wrefresh(pop);\n", "return 0;\n", "}\n"], "project": "hexdiff", "file": "asciiview.pkl", "function": "av_affiche"}, {"comment_all": {"comment": "/* XXX handle->opt.timeout = timeout_ms; */", "depth": 2, "reading_ease": 9.21, "reading_grade": 12.7, "line": 68}, "comment_text": "/* XXX handle->opt.timeout = timeout_ms; */", "comment_tokens": ["XXX", "handle-", ">", "opt.timeout", "=", "timeout_ms", ";"], "ccode": ["\n", "static int\n", "dbus_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n", "{\n", "\tstruct pcap_dbus *handlep = handle->priv;\n", "\n", "\tstruct pcap_pkthdr pkth;\n", "\tDBusMessage *message;\n", "\n", "\tchar *raw_msg;\n", "\tint raw_msg_len;\n", "\n", "\tint count = 0;\n", "\n", "\tmessage = dbus_connection_pop_message(handlep->conn);\n", "\n", "\twhile (!message) {\n", "\t\t/* XXX handle->opt.timeout = timeout_ms; */\n", "\t\tif (!dbus_connection_read_write(handlep->conn, 100)) {\n", "\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Connection closed\");\n", "\t\t\treturn -1;\n", "\t\t}\n", "\n", "\t\tif (handle->break_loop) {\n", "\t\t\thandle->break_loop = 0;\n", "\t\t\treturn -2;\n", "\t\t}\n", "\n", "\t\tmessage = dbus_connection_pop_message(handlep->conn);\n", "\t}\n", "\n", "\tif (dbus_message_is_signal(message, DBUS_INTERFACE_LOCAL, \"Disconnected\")) {\n", "\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Disconnected\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tif (dbus_message_marshal(message, &raw_msg, &raw_msg_len)) {\n", "\t\tpkth.caplen = pkth.len = raw_msg_len;\n", "\t\t/* pkth.caplen = min (payload_len, handle->snapshot); */\n", "\n", "\t\tgettimeofday(&pkth.ts, NULL);\n", "\t\tif (handle->fcode.bf_insns == NULL ||\n", "\t\t    bpf_filter(handle->fcode.bf_insns, (u_char *)raw_msg, pkth.len, pkth.caplen)) {\n", "\t\t\thandlep->packets_read++;\n", "\t\t\tcallback(user, &pkth, (u_char *)raw_msg);\n", "\t\t\tcount++;\n", "\t\t}\n", "\n", "\t\tdbus_free(raw_msg);\n", "\t}\n", "\treturn count;\n", "}\n"], "project": "libpcap0.8", "file": "pcap-dbus.pkl", "function": "dbus_read"}, {"comment_all": {"comment": "//printf(\"doHS: '%s'\\n\",h->label);\n", "depth": 1, "reading_ease": 35.61, "reading_grade": 8.8, "line": 691}, "comment_text": "//printf(\"doHS: '%s'\\n\",h->label);\n", "comment_tokens": ["printf", "(", "``", "doHS", ":", "'", "%", "s'\\n", "''", ",", "h-", ">", "label", ")", ";"], "ccode": ["\n", "/******************************************************************************/\n", "\n", "int doHS(Jax *jax, Hotspot *h)\n", "{\n", "\tint err=0;\n", "\n", "\t//printf(\"doHS: '%s'\\n\",h->label);\n", "\tswitch(jax->xe.xany.type)\n", "\t{\n", "\t\tcase ButtonPress:\n", "\t\t\tswitch(h->type)\n", "\t\t\t{\n", "\t\t\t\tcase BUTTON:\n", "\t\t\t\t\th->state=ACTIVE|DIRTY;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tdefault:\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase MotionNotify:\n", "\t\t\tswitch(h->type)\n", "\t\t\t{\n", "\t\t\t\tcase BUTTON:\n", "\t\t\t\t\tif(h->state&ACTIVE)\n", "\t\t\t\t\t{\n", "\t\t\t\t\t\tif(inHS(h, jax->xe.xbutton.x, jax->xe.xbutton.y))\n", "\t\t\t\t\t\t{\n", "\t\t\t\t\t\t\tif(h->state&REST)\n", "\t\t\t\t\t\t\t\th->state=DIRTY|ACTIVE;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\telse\n", "\t\t\t\t\t\t{\n", "\t\t\t\t\t\t\tif(!(h->state&REST))\n", "\t\t\t\t\t\t\t\th->state=DIRTY|ACTIVE|REST;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t}\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tdefault:\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase ButtonRelease:\n", "\t\t\tswitch(h->type)\n", "\t\t\t{\n", "\t\t\t\tcase BUTTON:\n", "\t\t\t\t\tif(inHS(h, jax->xe.xbutton.x, jax->xe.xbutton.y))\n", "\t\t\t\t\t\terr=h->buttonfunc(jax,h);\n", "\t\t\t\t\tif(!(h->state&REST))\n", "\t\t\t\t\t\th->state=REST|DIRTY;\n", "\t\t\t\t\telse\n", "\t\t\t\t\t\th->state=REST;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tdefault:\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tprintf(\"pushHS:unknown XEvent type: %d\\n\",jax->xe.xany.type);\n", "\t\t\treturn(0);\n", "\t}\n", "\th->drawfunc(jax,h);\n", "\treturn(err);\n", "}\n"], "project": "imwheel", "file": "cfg.pkl", "function": "doHS"}, {"comment_all": {"comment": "/* #####   FUNCTION DEFINITIONS  -  EXPORTED FUNCTIONS   ################## */", "depth": 0, "reading_ease": -34.11, "reading_grade": 19.0, "line": 66}, "comment_text": "/* #####   FUNCTION DEFINITIONS  -  EXPORTED FUNCTIONS   ################## */", "comment_tokens": ["#", "#", "#", "#", "#", "FUNCTION", "DEFINITIONS", "-", "EXPORTED", "FUNCTIONS", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"], "ccode": ["/*\n", " * =======================================================================================\n", " *\n", " *      Filename:  access.c\n", " *\n", " *      Description:  Interface for the different register access modules.\n", " *\n", " *      Version:   5.0\n", " *      Released:  10.11.2019\n", " *\n", " *      Author:   Thomas Gruber (tr), thomas.roehl@googlemail.com\n", " *      Project:  likwid\n", " *\n", " *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n", " *\n", " *      This program is free software: you can redistribute it and/or modify it under\n", " *      the terms of the GNU General Public License as published by the Free Software\n", " *      Foundation, either version 3 of the License, or (at your option) any later\n", " *      version.\n", " *\n", " *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n", " *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n", " *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n", " *\n", " *      You should have received a copy of the GNU General Public License along with\n", " *      this program.  If not, see <http://www.gnu.org/licenses/>.\n", " *\n", " * =======================================================================================\n", " */\n", "\n", "/* #####   HEADER FILE INCLUDES   ######################################### */\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <stdint.h>\n", "#include <fcntl.h>\n", "#include <string.h>\n", "#include <unistd.h>\n", "#include <signal.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#include <sys/socket.h>\n", "#include <sys/un.h>\n", "#include <pthread.h>\n", "\n", "#include <types.h>\n", "#include <error.h>\n", "#include <topology.h>\n", "#include <configuration.h>\n", "#include <perfmon.h>\n", "#include <registers.h>\n", "#include <access.h>\n", "#include <access_client.h>\n", "#include <access_x86.h>\n", "\n", "\n", "/* #####   VARIABLES  -  LOCAL TO THIS SOURCE FILE   ###################### */\n", "\n", "static int registeredCpus = 0;\n", "static int *registeredCpuList = NULL;\n", "static int (*access_read)(PciDeviceIndex dev, const int cpu, uint32_t reg, uint64_t *data) = NULL;\n", "static int (*access_write)(PciDeviceIndex dev, const int cpu, uint32_t reg, uint64_t data) = NULL;\n", "static int (*access_init) (int cpu_id) = NULL;\n", "static void (*access_finalize) (int cpu_id) = NULL;\n", "static int (*access_check) (PciDeviceIndex dev, int cpu_id) = NULL;\n", "\n", "/* #####   FUNCTION DEFINITIONS  -  EXPORTED FUNCTIONS   ################## */\n", "\n", "void\n", "HPMmode(int mode)\n", "{\n", "    if ((mode == ACCESSMODE_DIRECT) || (mode == ACCESSMODE_DAEMON))\n", "    {\n", "        config.daemonMode = mode;\n", "    }\n", "}\n"], "project": "likwid", "file": "access.pkl", "function": "HPMmode"}, {"comment_all": {"comment": "/* Split out Bold and Italic attributes from font name */", "depth": 1, "reading_ease": 96.18, "reading_grade": 2.1, "line": 314}, "comment_text": "/* Split out Bold and Italic attributes from font name */", "comment_tokens": ["Split", "out", "Bold", "and", "Italic", "attributes", "from", "font", "name"], "ccode": ["\n", "\n", "void gp_cairo_set_font(plot_struct *plot, const char *name, float fontsize)\n", "{\n", "    char *c;\n", "    char *fname;\n", "\n", "\tFPRINTF((stderr,\"set_font \\\"%s\\\" %f\\n\", name,fontsize));\n", "\n", "\t/* Split out Bold and Italic attributes from font name */\n", "\tfname = strdup(name);\n", "\tfor (c=fname; *c; c++) {\n", "\t    if (*c == '\\\\') {\n", "\t\tchar *d = c;\n", "\t\tdo { *d = *(d+1); } while (*d++);\n", "\t    } else {\n", "\t\tif (*c == '-') *c = ' ';\n", "\t\tif (*c == ':') *c = ' ';\n", "\t    }\n", "\t}\n", "\tif ((c = strstr(fname, \" Bold\"))) {\n", "\t    do { *c = *(c+5); } while (*c++);\n", "\t    plot->fontweight = PANGO_WEIGHT_BOLD;\n", "\t} else\n", "\t    plot->fontweight = PANGO_WEIGHT_NORMAL;\n", "\tif ((c = strstr(fname, \" Italic\"))) {\n", "\t    do { *c = *(c+7); } while (*c++);\n", "\t    plot->fontstyle = PANGO_STYLE_ITALIC;\n", "\t} else\n", "\t    plot->fontstyle = PANGO_STYLE_NORMAL;\n", "\n", "\tstrncpy( plot->fontname, fname, sizeof(plot->fontname) );\n", "\tplot->fontsize = fontsize;\n", "\tfree(fname);\n", "}\n"], "project": "gnuplot-data", "file": "gp_cairo.pkl", "function": "gp_cairo_set_font"}, {"comment_all": {"comment": "/* We're going to discard this list, and build a new one out of some\n   * of its members\n   */", "depth": 1, "reading_ease": 88.06, "reading_grade": 5.2, "line": 532}, "comment_text": "/* We're going to discard this list, and build a new one out of some\n   * of its members\n   */", "comment_tokens": ["We", "'re", "going", "to", "discard", "this", "list", ",", "and", "build", "a", "new", "one", "out", "of", "some", "of", "its", "members"], "ccode": ["\n", "static SV *\n", "try_attribute_specifier (SV *self)\n", "{\n", "  if (try_parse(self, keyword, \"__asm__\"))\n", "    {\n", "      commit = true;\n", "      if (!try_parse(self, punctuator, \"(\"))\n", "        return NULL;\n", "      SV *name = try_parse(self, string_literal);\n", "      if (!try_parse(self, punctuator, \")\"))\n", "        return NULL;\n", "\n", "      SV *attr = new_obj2(\"CParse::Attribute\", sv_2mortal(newSVpv(\"asm_name\", 0)), name);\n", "\n", "      return new_obj(\"CParse::AttributeList\", newRV_noinc((SV *)av_make(1, &attr)));\n", "    }\n", "\n", "  if (!try_parse(self, keyword, \"__attribute__\"))\n", "    return NULL;\n", "\n", "  commit = true;\n", "\n", "  if (!try_parse(self, punctuator, \"(\"))\n", "    return NULL;\n", "  if (!try_parse(self, punctuator, \"(\"))\n", "    return NULL;\n", "\n", "  SV *list = try_op_list(self, attribute, \")\", punctuator, \",\");\n", "  if (!list)\n", "    return NULL;\n", "  if (!try_parse(self, punctuator, \")\"))\n", "    return NULL;\n", "\n", "  /* We're going to discard this list, and build a new one out of some\n", "   * of its members\n", "   */\n", "\n", "  AV *attrs = newAV();\n", "  AV *alist = (AV *)SvRV(list);\n", "  int i;\n", "  for (i = 0; i <= av_len(alist); i++)\n", "    {\n", "      SV **arg = av_fetch(alist, i, 0);\n", "      if (!sv_isa(*arg, \"CParse::Parser::Token::Punctuator\"))\n", "        {\n", "          SvREFCNT_inc(*arg);\n", "          av_push(attrs, *arg);\n", "        }\n", "    }\n", "\n", "  SvREFCNT_dec(list);\n", "\n", "  return new_obj(\"CParse::AttributeList\", newRV_noinc((SV *)attrs));\n", "}\n"], "project": "icheck", "file": "PerlXS.pkl", "function": "try_attribute_specifier"}, {"comment_all": {"comment": "/* Free the BFD bits of a CTF file on ctf_arc_close().  */", "depth": 0, "reading_ease": 86.71, "reading_grade": 3.7, "line": 68}, "comment_text": "/* Free the BFD bits of a CTF file on ctf_arc_close().  */", "comment_tokens": ["Free", "the", "BFD", "bits", "of", "a", "CTF", "file", "on", "ctf_arc_close", "(", ")", "."], "ccode": ["\n", "/* Free the BFD bits of a CTF file on ctf_arc_close().  */\n", "\n", "static void\n", "ctf_bfdclose (struct ctf_archive_internal *arci)\n", "{\n", "  if (arci->ctfi_abfd != NULL)\n", "    if (!bfd_close_all_done (arci->ctfi_abfd))\n", "      ctf_dprintf (\"Cannot close BFD: %s\\n\", bfd_errmsg (bfd_get_error()));\n", "}\n"], "project": "binutils-aarch64-linux-gnu-dbg", "file": "ctf-open-bfd.pkl", "function": "ctf_bfdclose"}, {"comment_all": {"comment": "/*\n * scamper_tracelb_node_cmp\n *\n * function to compare two nodes, taking into account the possibility that\n * the quoted ttl field is present and has a value.\n */", "depth": 0, "reading_ease": 49.15, "reading_grade": 11.9, "line": 131}, "comment_text": "/*\n * scamper_tracelb_node_cmp\n *\n * function to compare two nodes, taking into account the possibility that\n * the quoted ttl field is present and has a value.\n */", "comment_tokens": ["scamper_tracelb_node_cmp", "function", "to", "compare", "two", "nodes", ",", "taking", "into", "account", "the", "possibility", "that", "the", "quoted", "ttl", "field", "is", "present", "and", "has", "a", "value", "."], "ccode": ["\n", "/*\n", " * scamper_tracelb_node_cmp\n", " *\n", " * function to compare two nodes, taking into account the possibility that\n", " * the quoted ttl field is present and has a value.\n", " */\n", "int scamper_tracelb_node_cmp(const scamper_tracelb_node_t *a,\n", "\t\t\t     const scamper_tracelb_node_t *b)\n", "{\n", "  int i;\n", "\n", "  if(a->addr == NULL || b->addr == NULL)\n", "    {\n", "      if(a->addr == NULL && b->addr == NULL)\n", "\treturn 0;\n", "      else if(a->addr == NULL)\n", "\treturn -1;\n", "      return 1;\n", "    }\n", "\n", "  if((i = scamper_addr_human_cmp(a->addr, b->addr)) != 0)\n", "    return i;\n", "\n", "  if(SCAMPER_TRACELB_NODE_QTTL(a) == SCAMPER_TRACELB_NODE_QTTL(b))\n", "    {\n", "      if(SCAMPER_TRACELB_NODE_QTTL(a))\n", "\t{\n", "\t  if(a->q_ttl < b->q_ttl) return -1;\n", "\t  if(a->q_ttl > b->q_ttl) return  1;\n", "\t}\n", "      return 0;\n", "    }\n", "  else if(SCAMPER_TRACELB_NODE_QTTL(a))\n", "    {\n", "      return -1;\n", "    }\n", "  return 1;\n", "}\n"], "project": "scamper", "file": "scamper_tracelb.pkl", "function": "scamper_tracelb_node_cmp"}, {"comment_all": {"comment": "/* Do nothing.  The symbol was never referenced, or\n\t\t     was defined in some object file.  Note that\n\t\t     undefweak symbols are defined by PROVIDE.  This\n\t\t     is to support glibc use of __rela_iplt_start and\n\t\t     similar weak references.  */", "depth": 5, "reading_ease": 60.01, "reading_grade": 7.7, "line": 1134}, "comment_text": "/* Do nothing.  The symbol was never referenced, or\n\t\t     was defined in some object file.  Note that\n\t\t     undefweak symbols are defined by PROVIDE.  This\n\t\t     is to support glibc use of __rela_iplt_start and\n\t\t     similar weak references.  */", "comment_tokens": ["Do", "nothing", ".", "The", "symbol", "was", "never", "referenced", ",", "or", "was", "defined", "in", "some", "object", "file", ".", "Note", "that", "undefweak", "symbols", "are", "defined", "by", "PROVIDE", ".", "This", "is", "to", "support", "glibc", "use", "of", "__rela_iplt_start", "and", "similar", "weak", "references", "."], "ccode": ["\n", "static void\n", "exp_fold_tree_1 (etree_type *tree)\n", "{\n", "  if (tree == NULL)\n", "    {\n", "      memset (&expld.result, 0, sizeof (expld.result));\n", "      return;\n", "    }\n", "\n", "  switch (tree->type.node_class)\n", "    {\n", "    case etree_value:\n", "      if (expld.section == bfd_abs_section_ptr\n", "\t  && !config.sane_expr)\n", "\tnew_abs (tree->value.value);\n", "      else\n", "\tnew_number (tree->value.value);\n", "      expld.result.str = tree->value.str;\n", "      break;\n", "\n", "    case etree_rel:\n", "      if (expld.phase != lang_first_phase_enum)\n", "\t{\n", "\t  asection *output_section = tree->rel.section->output_section;\n", "\t  new_rel (tree->rel.value + tree->rel.section->output_offset,\n", "\t\t   output_section);\n", "\t}\n", "      else\n", "\tmemset (&expld.result, 0, sizeof (expld.result));\n", "      break;\n", "\n", "    case etree_assert:\n", "      exp_fold_tree_1 (tree->assert_s.child);\n", "      if (expld.phase == lang_final_phase_enum && !expld.result.value)\n", "\teinfo (\"%X%P: %s\\n\", tree->assert_s.message);\n", "      break;\n", "\n", "    case etree_unary:\n", "      fold_unary (tree);\n", "      break;\n", "\n", "    case etree_binary:\n", "      fold_binary (tree);\n", "      break;\n", "\n", "    case etree_trinary:\n", "      fold_trinary (tree);\n", "      break;\n", "\n", "    case etree_assign:\n", "    case etree_provide:\n", "    case etree_provided:\n", "      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)\n", "\t{\n", "\t  if (tree->type.node_class != etree_assign)\n", "\t    einfo (_(\"%F%P:%pS can not PROVIDE assignment to\"\n", "\t\t     \" location counter\\n\"), tree);\n", "\t  if (expld.phase != lang_first_phase_enum)\n", "\t    {\n", "\t      /* Notify the folder that this is an assignment to dot.  */\n", "\t      expld.assigning_to_dot = TRUE;\n", "\t      exp_fold_tree_1 (tree->assign.src);\n", "\t      expld.assigning_to_dot = FALSE;\n", "\n", "\t      /* If we are assigning to dot inside an output section\n", "\t\t arrange to keep the section, except for certain\n", "\t\t expressions that evaluate to zero.  We ignore . = 0,\n", "\t\t . = . + 0, and . = ALIGN (. != 0 ? expr : 1).\n", "\t\t We can't ignore all expressions that evaluate to zero\n", "\t\t because an otherwise empty section might have padding\n", "\t\t added by an alignment expression that changes with\n", "\t\t relaxation.  Such a section might have zero size\n", "\t\t before relaxation and so be stripped incorrectly.  */\n", "\t      if (expld.phase == lang_mark_phase_enum\n", "\t\t  && expld.section != bfd_abs_section_ptr\n", "\t\t  && expld.section != bfd_und_section_ptr\n", "\t\t  && !(expld.result.valid_p\n", "\t\t       && expld.result.value == 0\n", "\t\t       && (is_value (tree->assign.src, 0)\n", "\t\t\t   || is_sym_value (tree->assign.src, 0)\n", "\t\t\t   || is_dot_plus_0 (tree->assign.src)\n", "\t\t\t   || is_align_conditional (tree->assign.src))))\n", "\t\texpld.section->flags |= SEC_KEEP;\n", "\n", "\t      if (!expld.result.valid_p\n", "\t\t  || expld.section == bfd_und_section_ptr)\n", "\t\t{\n", "\t\t  if (expld.phase != lang_mark_phase_enum)\n", "\t\t    einfo (_(\"%F%P:%pS invalid assignment to\"\n", "\t\t\t     \" location counter\\n\"), tree);\n", "\t\t}\n", "\t      else if (expld.dotp == NULL)\n", "\t\teinfo (_(\"%F%P:%pS assignment to location counter\"\n", "\t\t\t \" invalid outside of SECTIONS\\n\"), tree);\n", "\n", "\t      /* After allocation, assignment to dot should not be\n", "\t\t done inside an output section since allocation adds a\n", "\t\t padding statement that effectively duplicates the\n", "\t\t assignment.  */\n", "\t      else if (expld.phase <= lang_allocating_phase_enum\n", "\t\t       || expld.section == bfd_abs_section_ptr)\n", "\t\t{\n", "\t\t  bfd_vma nextdot;\n", "\n", "\t\t  nextdot = expld.result.value;\n", "\t\t  if (expld.result.section != NULL)\n", "\t\t    nextdot += expld.result.section->vma;\n", "\t\t  else\n", "\t\t    nextdot += expld.section->vma;\n", "\t\t  if (nextdot < expld.dot\n", "\t\t      && expld.section != bfd_abs_section_ptr)\n", "\t\t    einfo (_(\"%F%P:%pS cannot move location counter backwards\"\n", "\t\t\t     \" (from %V to %V)\\n\"),\n", "\t\t\t   tree, expld.dot, nextdot);\n", "\t\t  else\n", "\t\t    {\n", "\t\t      expld.dot = nextdot;\n", "\t\t      *expld.dotp = nextdot;\n", "\t\t    }\n", "\t\t}\n", "\t    }\n", "\t  else\n", "\t    memset (&expld.result, 0, sizeof (expld.result));\n", "\t}\n", "      else\n", "\t{\n", "\t  struct bfd_link_hash_entry *h = NULL;\n", "\n", "\t  if (tree->type.node_class == etree_provide)\n", "\t    {\n", "\t      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n", "\t\t\t\t\tFALSE, FALSE, TRUE);\n", "\t      if (h == NULL\n", "\t\t  || !(h->type == bfd_link_hash_new\n", "\t\t       || h->type == bfd_link_hash_undefined\n", "\t\t       || h->type == bfd_link_hash_undefweak\n", "\t\t       || h->linker_def))\n", "\t\t{\n", "\t\t  /* Do nothing.  The symbol was never referenced, or\n", "\t\t     was defined in some object file.  Note that\n", "\t\t     undefweak symbols are defined by PROVIDE.  This\n", "\t\t     is to support glibc use of __rela_iplt_start and\n", "\t\t     similar weak references.  */\n", "\t\t  break;\n", "\t\t}\n", "\t    }\n", "\n", "\t  expld.assign_name = tree->assign.dst;\n", "\t  expld.assign_src = NULL;\n", "\t  exp_fold_tree_1 (tree->assign.src);\n", "\t  /* expld.assign_name remaining equal to tree->assign.dst\n", "\t     below indicates the evaluation of tree->assign.src did\n", "\t     not use the value of tree->assign.dst.  We don't allow\n", "\t     self assignment until the final phase for two reasons:\n", "\t     1) Expressions are evaluated multiple times.  With\n", "\t     relaxation, the number of times may vary.\n", "\t     2) Section relative symbol values cannot be correctly\n", "\t     converted to absolute values, as is required by many\n", "\t     expressions, until final section sizing is complete.  */\n", "\t  if (expld.phase == lang_final_phase_enum\n", "\t      || expld.phase == lang_fixed_phase_enum\n", "\t      || expld.assign_name != NULL)\n", "\t    {\n", "\t      if (tree->type.node_class == etree_provide)\n", "\t\ttree->type.node_class = etree_provided;\n", "\n", "\t      if (h == NULL)\n", "\t\t{\n", "\t\t  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n", "\t\t\t\t\t    TRUE, FALSE, TRUE);\n", "\t\t  if (h == NULL)\n", "\t\t    einfo (_(\"%F%P:%s: hash creation failed\\n\"),\n", "\t\t\t   tree->assign.dst);\n", "\t\t}\n", "\n", "              /* If the expression is not valid then fake a zero value.  In\n", "                 the final phase any errors will already have been raised,\n", "                 in earlier phases we want to create this definition so\n", "                 that it can be seen by other expressions.  */\n", "              if (!expld.result.valid_p\n", "                  && h->type == bfd_link_hash_new)\n", "                {\n", "                  expld.result.value = 0;\n", "                  expld.result.section = NULL;\n", "                  expld.result.valid_p = TRUE;\n", "                }\n", "\n", "\t      if (expld.result.valid_p)\n", "\t\t{\n", "\t\t  if (expld.result.section == NULL)\n", "\t\t    expld.result.section = expld.section;\n", "\t\t  if (!update_definedness (tree->assign.dst, h) && 0)\n", "\t\t    {\n", "\t\t      /* Symbol was already defined.  For now this error\n", "\t\t\t is disabled because it causes failures in the ld\n", "\t\t\t testsuite: ld-elf/var1, ld-scripts/defined5, and\n", "\t\t\t ld-scripts/pr14962.  Some of these no doubt\n", "\t\t\t reflect scripts used in the wild.  */\n", "\t\t      (*link_info.callbacks->multiple_definition)\n", "\t\t\t(&link_info, h, link_info.output_bfd,\n", "\t\t\t expld.result.section, expld.result.value);\n", "\t\t    }\n", "\t\t  if (expld.phase == lang_fixed_phase_enum)\n", "\t\t    {\n", "\t\t      if (h->type == bfd_link_hash_defined)\n", "\t\t\t{\n", "\t\t\t  expld.result.value = h->u.def.value;\n", "\t\t\t  expld.result.section = h->u.def.section;\n", "\t\t\t}\n", "\t\t    }\n", "\t\t  else\n", "\t\t    {\n", "\t\t      h->type = bfd_link_hash_defined;\n", "\t\t      h->u.def.value = expld.result.value;\n", "\t\t      h->u.def.section = expld.result.section;\n", "\t\t      h->linker_def = ! tree->assign.type.lineno;\n", "\t\t      h->ldscript_def = 1;\n", "\t\t      h->rel_from_abs = expld.rel_from_abs;\n", "\t\t      if (tree->assign.hidden)\n", "\t\t\tbfd_link_hide_symbol (link_info.output_bfd,\n", "\t\t\t\t\t      &link_info, h);\n", "\n", "\t\t      /* Copy the symbol type if this is an expression only\n", "\t\t\t referencing a single symbol.  (If the expression\n", "\t\t\t contains ternary conditions, ignoring symbols on\n", "\t\t\t false branches.)  */\n", "\t\t      if (expld.assign_src != NULL\n", "\t\t\t  && (expld.assign_src\n", "\t\t\t      != (struct bfd_link_hash_entry *) -1))\n", "\t\t\tbfd_copy_link_hash_symbol_type (link_info.output_bfd,\n", "\t\t\t\t\t\t\th, expld.assign_src);\n", "\t\t    }\n", "\t\t}\n", "\t    }\n", "\t  if (expld.phase != lang_fixed_phase_enum)\n", "\t    expld.assign_name = NULL;\n", "\t}\n", "      break;\n", "\n", "    case etree_name:\n", "      fold_name (tree);\n", "      break;\n", "\n", "    default:\n", "      FAIL ();\n", "      memset (&expld.result, 0, sizeof (expld.result));\n", "      break;\n", "    }\n", "}\n"], "project": "binutils-i686-gnu", "file": "ldexp.pkl", "function": "exp_fold_tree_1"}, {"comment_all": {"comment": "/*!\n * \\brief   bbufferDestroy()\n *\n * \\param[in,out]   pbb   will be set to null before returning\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) Destroys the byte array in the bbuffer and then the bbuffer;\n *          then nulls the contents of the input ptr.\n * </pre>\n */", "depth": 0, "reading_ease": 60.32, "reading_grade": 13.8, "line": 158}, "comment_text": "/*!\n * \\brief   bbufferDestroy()\n *\n * \\param[in,out]   pbb   will be set to null before returning\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) Destroys the byte array in the bbuffer and then the bbuffer;\n *          then nulls the contents of the input ptr.\n * </pre>\n */", "comment_tokens": ["!", "\\brief", "bbufferDestroy", "(", ")", "\\param", "[", "in", ",", "out", "]", "pbb", "will", "be", "set", "to", "null", "before", "returning", "\\return", "void", "<", "pre", ">", "Notes", ":", "(", "1", ")", "Destroys", "the", "byte", "array", "in", "the", "bbuffer", "and", "then", "the", "bbuffer", ";", "then", "nulls", "the", "contents", "of", "the", "input", "ptr", ".", "<", "pre", ">"], "ccode": ["\n", "\n", "/*!\n", " * \\brief   bbufferDestroy()\n", " *\n", " * \\param[in,out]   pbb   will be set to null before returning\n", " * \\return  void\n", " *\n", " * <pre>\n", " * Notes:\n", " *      (1) Destroys the byte array in the bbuffer and then the bbuffer;\n", " *          then nulls the contents of the input ptr.\n", " * </pre>\n", " */\n", "void\n", "bbufferDestroy(L_BBUFFER  **pbb)\n", "{\n", "L_BBUFFER  *bb;\n", "\n", "    PROCNAME(\"bbufferDestroy\");\n", "\n", "    if (pbb == NULL) {\n", "        L_WARNING(\"ptr address is NULL\\n\", procName);\n", "        return;\n", "    }\n", "\n", "    if ((bb = *pbb) == NULL)\n", "        return;\n", "\n", "    if (bb->array)\n", "        LEPT_FREE(bb->array);\n", "    LEPT_FREE(bb);\n", "    *pbb = NULL;\n", "\n", "    return;\n", "}\n"], "project": "libleptonica-dev", "file": "bbuffer.pkl", "function": "bbufferDestroy"}, {"comment_all": {"comment": "/* Check ownership of device and mount point.\n * Return 0 if everything is in order, 1 on error.\n */", "depth": 1, "reading_ease": 71.31, "reading_grade": 5.4, "line": 324}, "comment_text": "/* Check ownership of device and mount point.\n * Return 0 if everything is in order, 1 on error.\n */", "comment_tokens": ["Check", "ownership", "of", "device", "and", "mount", "point", ".", "Return", "0", "if", "everything", "is", "in", "order", ",", "1", "on", "error", "."], "ccode": ["\n", "\n", "int check_ownerships(uid_t uid, char *path) {\n", "/* Check ownership of device and mount point.\n", " * Return 0 if everything is in order, 1 on error.\n", " */\n", "\tstruct stat s;\n", "\tif (stat(path, &s) != 0) {\n", "\t\tfputs(\"Cannot examine encrypted directory\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\tif (!S_ISDIR(s.st_mode)) {\n", "\t\tfputs(\"Device or mountpoint is not a directory\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\tif (s.st_uid != uid) {\n", "\t\tfputs(\"You do not own that encrypted directory\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\treturn 0;\n", "}\n"], "project": "libecryptfs-dev", "file": "mount.ecryptfs_private.pkl", "function": "check_ownerships"}, {"comment_all": {"comment": "/*! \\brief Iterate through all of the input tree files and call the parse function on them */", "depth": 0, "reading_ease": 80.62, "reading_grade": 6.0, "line": 1083}, "comment_text": "/*! \\brief Iterate through all of the input tree files and call the parse function on them */", "comment_tokens": ["!", "\\brief", "Iterate", "through", "all", "of", "the", "input", "tree", "files", "and", "call", "the", "parse", "function", "on", "them"], "ccode": ["\n", "/*! \\brief Iterate through all of the input tree files and call the parse function on them */\n", "static int build_member_list(void)\n", "{\n", "\tint i;\n", "\tint res = -1;\n", "\n", "\tfor (i = 0; i < (sizeof(tree_files) / sizeof(tree_files[0])); i++) {\n", "\t\tif ((res = parse_tree(tree_files[i]))) {\n", "\t\t\tfprintf(stderr, \"Error parsing '%s'!\\n\", tree_files[i]);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\tif (!res)\n", "\t\tres = match_member_relations();\n", "\n", "\treturn res;\n", "}\n"], "project": "asterisk-tests", "file": "menuselect.pkl", "function": "build_member_list"}, {"comment_all": {"comment": "/* OGMRip - A library for DVD ripping and encoding\n * Copyright (C) 2004-2012 Olivier Rolland <billl@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */", "depth": 0, "reading_ease": 52.6, "reading_grade": 10.5, "line": 0}, "comment_text": "/* OGMRip - A library for DVD ripping and encoding\n * Copyright (C) 2004-2012 Olivier Rolland <billl@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */", "comment_tokens": ["OGMRip", "-", "A", "library", "for", "DVD", "ripping", "and", "encoding", "Copyright", "(", "C", ")", "2004-2012", "Olivier", "Rolland", "<", "billl", "@", "users.sourceforge.net", ">", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/* OGMRip - A library for DVD ripping and encoding\n", " * Copyright (C) 2004-2012 Olivier Rolland <billl@users.sourceforge.net>\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n", " */\n", "\n", "/**\n", " * SECTION:ogmrip-dvdcpy\n", " * @title: OGMRipDvdcpy\n", " * @short_description: A codec to copy a DVD title\n", " * @include: ogmrip-dvdcpy.h\n", " */\n", "\n", "#include \"ogmrip-dvdcpy.h\"\n", "\n", "#include \"ogmjob-exec.h\"\n", "\n", "#include <string.h>\n", "#include <unistd.h>\n", "\n", "#include <glib/gstdio.h>\n", "\n", "static gint ogmrip_dvdcpy_run (OGMJobSpawn *spawn);\n", "\n", "static gdouble\n", "ogmrip_dvdcpy_watch (OGMJobExec *exec, const gchar *buffer, OGMRipVideoCodec *video)\n", "{\n", "  guint bytes, total, percent;\n", "\n", "  if (sscanf (buffer, \"%u/%u blocks written (%u%%)\", &bytes, &total, &percent) == 3)\n", "    return percent / 100.;\n", "\n", "  return -1;\n", "}\n"], "project": "ogmrip-plugins", "file": "ogmrip-dvdcpy.pkl", "function": "ogmrip_dvdcpy_watch"}, {"comment_all": {"comment": "/* For undefined variables, += assumes the recursive flavor */", "depth": 2, "reading_ease": 30.53, "reading_grade": 10.7, "line": 295}, "comment_text": "/* For undefined variables, += assumes the recursive flavor */", "comment_tokens": ["For", "undefined", "variables", ",", "+=", "assumes", "the", "recursive", "flavor"], "ccode": ["\n", "void variable_add(const char *name, const char *value,\n", "\t\t  enum variable_flavor flavor)\n", "{\n", "\tstruct variable *v;\n", "\tchar *new_value;\n", "\tbool append = false;\n", "\n", "\tv = variable_lookup(name);\n", "\tif (v) {\n", "\t\t/* For defined variables, += inherits the existing flavor */\n", "\t\tif (flavor == VAR_APPEND) {\n", "\t\t\tflavor = v->flavor;\n", "\t\t\tappend = true;\n", "\t\t} else {\n", "\t\t\tfree(v->value);\n", "\t\t}\n", "\t} else {\n", "\t\t/* For undefined variables, += assumes the recursive flavor */\n", "\t\tif (flavor == VAR_APPEND)\n", "\t\t\tflavor = VAR_RECURSIVE;\n", "\n", "\t\tv = xmalloc(sizeof(*v));\n", "\t\tv->name = xstrdup(name);\n", "\t\tv->exp_count = 0;\n", "\t\tlist_add_tail(&v->node, &variable_list);\n", "\t}\n", "\n", "\tv->flavor = flavor;\n", "\n", "\tif (flavor == VAR_SIMPLE)\n", "\t\tnew_value = expand_string(value);\n", "\telse\n", "\t\tnew_value = xstrdup(value);\n", "\n", "\tif (append) {\n", "\t\tv->value = xrealloc(v->value,\n", "\t\t\t\t    strlen(v->value) + strlen(new_value) + 2);\n", "\t\tstrcat(v->value, \" \");\n", "\t\tstrcat(v->value, new_value);\n", "\t\tfree(new_value);\n", "\t} else {\n", "\t\tv->value = new_value;\n", "\t}\n", "}\n"], "project": "linux-cloud-tools-5.8.0-1039-azure", "file": "preprocess.pkl", "function": "variable_add"}, {"comment_all": {"comment": "/* - (table->size * 4 / 5) */", "depth": 1, "reading_ease": 59.97, "reading_grade": 5.6, "line": 177}, "comment_text": "/* - (table->size * 4 / 5) */", "comment_tokens": ["-", "(", "table-", ">", "size", "4", "5", ")"], "ccode": ["\n", "int\n", "chise_name_table_grow (CHISE_NAME_TABLE* table)\n", "{\n", "  CHISE_NAME_TABLE *new_table\n", "    = chise_make_hash_table ( table->size * 2\n", "\t\t\t      /* - (table->size * 4 / 5) */ );\n", "  int i;\n", "\n", "  if (new_table == NULL)\n", "    return -1;\n", "\n", "  for (i = 0; i < table->size; i++)\n", "    {\n", "      CHISE_NAME_TABLE_ENTRY entry = table->data[i];\n", "      if ( (entry.key != NULL) && (entry.value != NULL) )\n", "\t{\n", "\t  int status\n", "\t    = chise_name_table_put (new_table, entry.key, entry.value);\n", "\t  if (status != 0)\n", "\t    {\n", "\t      chise_destroy_hash_table (new_table);\n", "\t      return -1;\n", "\t    }\n", "\t}\n", "    }\n", "  table->size = new_table->size;\n", "  table->data = new_table->data;\n", "  free (new_table);\n", "  return 0;\n", "}\n"], "project": "libchise1", "file": "name.pkl", "function": "chise_name_table_grow"}, {"comment_all": {"comment": "/*------------------------------------------------------------------------\n |\n |  NAME          msgFatalPerror\n |\n |  FUNCTION      Show an errno-dependant error message and abort the program.\n |\n |  SYNOPSIS      #include \"shhmsg.h\"\n |                void msgFatalPerror(const char *format, ...);\n |\n |  INPUT         format, ...\n |                        Arguments used as with printf(). If NULL,\n |                        the name of the program is printed.\n |\n |  RETURNS       Nothing, never returns.\n |\n |  DESCRIPTION   Prints the given text followed by \": \" and the\n |                correct errormessage on the _msgErrorStream, and then\n |                aborts the program.\n |\t\t  May add the program name before anything is printed.\n |\n |                If errno indicates \"no error\", nothing is printed,\n |                and the program keeps running.\n */", "depth": 0, "reading_ease": 53.98, "reading_grade": 7.9, "line": 68}, "comment_text": "/*------------------------------------------------------------------------\n |\n |  NAME          msgFatalPerror\n |\n |  FUNCTION      Show an errno-dependant error message and abort the program.\n |\n |  SYNOPSIS      #include \"shhmsg.h\"\n |                void msgFatalPerror(const char *format, ...);\n |\n |  INPUT         format, ...\n |                        Arguments used as with printf(). If NULL,\n |                        the name of the program is printed.\n |\n |  RETURNS       Nothing, never returns.\n |\n |  DESCRIPTION   Prints the given text followed by \": \" and the\n |                correct errormessage on the _msgErrorStream, and then\n |                aborts the program.\n |\t\t  May add the program name before anything is printed.\n |\n |                If errno indicates \"no error\", nothing is printed,\n |                and the program keeps running.\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "|", "|", "NAME", "msgFatalPerror", "|", "|", "FUNCTION", "Show", "an", "errno-dependant", "error", "message", "and", "abort", "the", "program", ".", "|", "|", "SYNOPSIS", "#", "include", "``", "shhmsg.h", "''", "|", "void", "msgFatalPerror", "(", "const", "char", "format", ",", "...", ")", ";", "|", "|", "INPUT", "format", ",", "...", "|", "Arguments", "used", "as", "with", "printf", "(", ")", ".", "If", "NULL", ",", "|", "the", "name", "of", "the", "program", "is", "printed", ".", "|", "|", "RETURNS", "Nothing", ",", "never", "returns", ".", "|", "|", "DESCRIPTION", "Prints", "the", "given", "text", "followed", "by", "``", ":", "``", "and", "the", "|", "correct", "errormessage", "on", "the", "_msgErrorStream", ",", "and", "then", "|", "aborts", "the", "program", ".", "|", "May", "add", "the", "program", "name", "before", "anything", "is", "printed", ".", "|", "|", "If", "errno", "indicates", "``", "no", "error", "''", ",", "nothing", "is", "printed", ",", "|", "and", "the", "program", "keeps", "running", "."], "ccode": ["\n", "/*------------------------------------------------------------------------\n", " |\n", " |  NAME          msgFatalPerror\n", " |\n", " |  FUNCTION      Show an errno-dependant error message and abort the program.\n", " |\n", " |  SYNOPSIS      #include \"shhmsg.h\"\n", " |                void msgFatalPerror(const char *format, ...);\n", " |\n", " |  INPUT         format, ...\n", " |                        Arguments used as with printf(). If NULL,\n", " |                        the name of the program is printed.\n", " |\n", " |  RETURNS       Nothing, never returns.\n", " |\n", " |  DESCRIPTION   Prints the given text followed by \": \" and the\n", " |                correct errormessage on the _msgErrorStream, and then\n", " |                aborts the program.\n", " |\t\t  May add the program name before anything is printed.\n", " |\n", " |                If errno indicates \"no error\", nothing is printed,\n", " |                and the program keeps running.\n", " */\n", "void\n", "msgFatalPerror(const char *format, ...)\n", "{\n", "    va_list ap;\n", "    int en;\n", "\n", "    if (!(en = errno))\n", "        return;\n", "    fflush(stdout);\n", "    if (format && *format) {\n", "\tif (_msgShowNameAlways)\n", "\t    fprintf(GET_ERROR_STREAM, \"%s: \", msgGetName());\n", "\tva_start(ap, format);\n", "\tvfprintf(GET_ERROR_STREAM, format, ap);\n", "\tva_end(ap);\n", "    } else\n", "\tfputs(msgGetName(), GET_ERROR_STREAM);\n", "    fprintf(GET_ERROR_STREAM, \": %s\\n\", strerror(en));\n", "    exit(99);\n", "}\n"], "project": "libshhmsg1-dev", "file": "errno.pkl", "function": "msgFatalPerror"}, {"comment_all": {"comment": "/* KMS vertex buffer support - for R600 only but could be used on previous gpus */", "depth": 0, "reading_ease": 74.19, "reading_grade": 6.4, "line": 37}, "comment_text": "/* KMS vertex buffer support - for R600 only but could be used on previous gpus */", "comment_tokens": ["KMS", "vertex", "buffer", "support", "-", "for", "R600", "only", "but", "could", "be", "used", "on", "previous", "gpus"], "ccode": ["/*\n", " * Copyright \u00a9 2009 Red Hat, Inc.\n", " *\n", " * Permission is hereby granted, free of charge, to any person obtaining a\n", " * copy of this software and associated documentation files (the \"Software\"),\n", " * to deal in the Software without restriction, including without limitation\n", " * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n", " * and/or sell copies of the Software, and to permit persons to whom the\n", " * Software is furnished to do so, subject to the following conditions:\n", " *\n", " * The above copyright notice and this permission notice (including the next\n", " * paragraph) shall be included in all copies or substantial portions of the\n", " * Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n", " * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n", " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n", " * SOFTWARE.\n", " *\n", " * Authors:\n", " *    Dave Airlie <airlied@redhat.com>\n", " *\n", " */\n", "#ifdef HAVE_CONFIG_H\n", "#include \"config.h\"\n", "#endif\n", "\n", "#include <errno.h>\n", "#include \"radeon.h\"\n", "#include \"radeon_bo.h\"\n", "#include \"radeon_cs.h\"\n", "\n", "#define VBO_SIZE (16*1024)\n", "\n", "/* KMS vertex buffer support - for R600 only but could be used on previous gpus */\n", "\n", "static struct radeon_bo *radeon_vbo_get_bo(ScrnInfoPtr pScrn);\n", "\n", "void radeon_vbo_put(ScrnInfoPtr pScrn, struct radeon_vbo_object *vbo)\n", "{\n", "\n", "    if (vbo->vb_bo) {\n", "\tradeon_bo_unmap(vbo->vb_bo);\n", "\tradeon_bo_unref(vbo->vb_bo);\n", "\tvbo->vb_bo = NULL;\n", "\tvbo->vb_total = 0;\n", "    }\n", "\n", "    vbo->vb_offset = 0;\n", "}\n"], "project": "xserver-xorg-video-ati", "file": "radeon_vbo.pkl", "function": "radeon_vbo_put"}, {"comment_all": {"comment": "/*\n * DMG2ISO base64.cc\n * \n * Copyright (c) 2004 vu1tur <to@vu1tur.eu.org> This program is free software; you\n * can redistribute it and/or modify it under the terms of the GNU General\n * Public License as published by the Free Software Foundation.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n * \n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc., 51\n * Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */", "depth": 0, "reading_ease": 61.87, "reading_grade": 9.1, "line": 0}, "comment_text": "/*\n * DMG2ISO base64.cc\n * \n * Copyright (c) 2004 vu1tur <to@vu1tur.eu.org> This program is free software; you\n * can redistribute it and/or modify it under the terms of the GNU General\n * Public License as published by the Free Software Foundation.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n * \n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc., 51\n * Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */", "comment_tokens": ["DMG2ISO", "base64.cc", "Copyright", "(", "c", ")", "2004", "vu1tur", "<", "to", "@", "vu1tur.eu.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA", "."], "ccode": ["/*\n", " * DMG2ISO base64.cc\n", " * \n", " * Copyright (c) 2004 vu1tur <to@vu1tur.eu.org> This program is free software; you\n", " * can redistribute it and/or modify it under the terms of the GNU General\n", " * Public License as published by the Free Software Foundation.\n", " * \n", " * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n", " * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n", " * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n", " * details.\n", " * \n", " * You should have received a copy of the GNU General Public License along with\n", " * this program; if not, write to the Free Software Foundation, Inc., 51\n", " * Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n", " */\n", "\n", "#include \"base64.h\"\n", "#include <stdlib.h>\n", "\n", "bool is_base64(const char c)\n", "{\n", "\tif ((c >= 'A' && c <= 'Z') ||\n", "\t    (c >= 'a' && c <= 'z') ||\n", "\t    (c >= '0' && c <= '9') ||\n", "\t    c == '+' ||\n", "\t    c == '/' ||\n", "\t    c == '=')\n", "\t\treturn true;\n", "\treturn false;\n", "}\n"], "project": "dmg2img", "file": "base64.pkl", "function": "is_base64"}, {"comment_all": {"comment": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */", "depth": 0, "reading_ease": 96.69, "reading_grade": 1.9, "line": 3758}, "comment_text": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  \n */", "comment_tokens": ["Removes", "and", "deletes", "the", "top", "of", "the", "stack", ",", "if", "present", ".", "The", "next", "element", "becomes", "the", "new", "top", "."], "ccode": ["\n", "/** Removes and deletes the top of the stack, if present.\n", " *  The next element becomes the new top.\n", " *  \n", " */\n", "void yypop_buffer_state (void)\n", "{\n", "    \tif (!YY_CURRENT_BUFFER)\n", "\t\treturn;\n", "\n", "\tyy_delete_buffer(YY_CURRENT_BUFFER );\n", "\tYY_CURRENT_BUFFER_LVALUE = NULL;\n", "\tif ((yy_buffer_stack_top) > 0)\n", "\t\t--(yy_buffer_stack_top);\n", "\n", "\tif (YY_CURRENT_BUFFER) {\n", "\t\tyy_load_buffer_state(  );\n", "\t\t(yy_did_buffer_switch_on_eof) = 1;\n", "\t}\n", "}\n"], "project": "linux-azure-5.11-cloud-tools-5.11.0-1025", "file": "lexer.lex.pkl", "function": "yypop_buffer_state"}, {"comment_all": {"comment": "/*\n * This routine is used only when running more than one thread (done whenever writing to\n * more than one directory).\n * Fork each of the required threads and then wait on their exit status.\n */", "depth": 0, "reading_ease": 72.16, "reading_grade": 7.2, "line": 1120}, "comment_text": "/*\n * This routine is used only when running more than one thread (done whenever writing to\n * more than one directory).\n * Fork each of the required threads and then wait on their exit status.\n */", "comment_tokens": ["This", "routine", "is", "used", "only", "when", "running", "more", "than", "one", "thread", "(", "done", "whenever", "writing", "to", "more", "than", "one", "directory", ")", ".", "Fork", "each", "of", "the", "required", "threads", "and", "then", "wait", "on", "their", "exit", "status", "."], "ccode": ["\n", "/*\n", " * This routine is used only when running more than one thread (done whenever writing to\n", " * more than one directory).\n", " * Fork each of the required threads and then wait on their exit status.\n", " */\n", "void fork_threads(void)\n", "{\n", "\tint i, active_kids = 0;\n", "\n", "\t/*\n", "\t * Clear out any pending writes before the fork so we don't get duplication\n", "\t */\n", "\tfflush(stdout);\n", "\tfflush(log_file_fp);\n", "\n", "\t/*\n", "\t * Fork one thread for each of the specified children\n", "\t */\n", "\n", "\tfor (i = 0; i < num_threads; i++) {\n", "\t\tif ((child_tasks[i].child_pid = fork()) == -1) {\n", "\t\t\tfprintf(stderr, \"fs_mark: fork failed: %s\\n\",\n", "\t\t\t\tstrerror(errno));\n", "\t\t\tcleanup_exit();\n", "\t\t}\n", "\t\tif (child_tasks[i].child_pid == 0) {\n", "\n", "\t\t\t/*\n", "\t\t\t * Child thread: Set my real pid in the array and\n", "\t\t\t * then do work.\n", "\t\t\t */\n", "\t\t\tchild_tasks[i].child_pid = getpid();\n", "\t\t\tthread_work(child_tasks[i].child_pid);\n", "\n", "\t\t\t/*\n", "\t\t\t * My work is done, exit to let parent thread reap my state\n", "\t\t\t */\n", "\t\t\texit(0);\n", "\t\t}\n", "\t\tactive_kids++;\n", "\t}\n", "\n", "\t/*\n", "\t * Parent thread: Wait for each of the child threads to exit\n", "\t */\n", "\twhile (active_kids) {\n", "\t\tint status;\n", "\t\tpid_t child_pid;\n", "\n", "\t\t/*\n", "\t\t * Wait until child exits. Note that we need to loop on interrupts (this \n", "\t\t * happens in gdb, etc).\n", "\t\t */\n", "\t\tchild_pid = wait(&status);\n", "\t\tif (child_pid == -1) {\n", "\t\t\tif (errno == EINTR)\n", "\t\t\t\tcontinue;\n", "\t\t\tfprintf(stderr, \"fs_mark: wait failed: %s\\n\",\n", "\t\t\t\tstrerror(errno));\n", "\t\t\texit(0);\n", "\t\t}\n", "\n", "\t\t/*\n", "\t\t * Check that this was the clean exit of one of our threads\n", "\t\t */\n", "\t\tfor (i = 0; i < num_threads; i++) {\n", "\t\t\tif (child_tasks[i].child_pid == child_pid) {\n", "\t\t\t\tactive_kids--;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\treturn;\n", "}\n"], "project": "fsmark", "file": "fs_mark.pkl", "function": "fork_threads"}, {"comment_all": {"comment": "/** eval rve and assign the result to lv\n * lv=eval(rve)\n *\n * @param h  - script context\n * @param msg - sip msg\n * @param lv - lvalue\n * @param rve - rvalue expression\n * @return >= 0 on success (expr. bool value), -1 on error\n */", "depth": 0, "reading_ease": 71.14, "reading_grade": 7.6, "line": 367}, "comment_text": "/** eval rve and assign the result to lv\n * lv=eval(rve)\n *\n * @param h  - script context\n * @param msg - sip msg\n * @param lv - lvalue\n * @param rve - rvalue expression\n * @return >= 0 on success (expr. bool value), -1 on error\n */", "comment_tokens": ["eval", "rve", "and", "assign", "the", "result", "to", "lv", "lv=eval", "(", "rve", ")", "@", "param", "h", "-", "script", "context", "@", "param", "msg", "-", "sip", "msg", "@", "param", "lv", "-", "lvalue", "@", "param", "rve", "-", "rvalue", "expression", "@", "return", ">", "=", "0", "on", "success", "(", "expr", ".", "bool", "value", ")", ",", "-1", "on", "error"], "ccode": ["\n", "\n", "\n", "/** eval rve and assign the result to lv\n", " * lv=eval(rve)\n", " *\n", " * @param h  - script context\n", " * @param msg - sip msg\n", " * @param lv - lvalue\n", " * @param rve - rvalue expression\n", " * @return >= 0 on success (expr. bool value), -1 on error\n", " */\n", "int lval_assign(struct run_act_ctx* h, struct sip_msg* msg,\n", "\t\t\t\tstruct lvalue* lv, struct rval_expr* rve)\n", "{\n", "\tstruct rvalue* rv;\n", "\tint ret;\n", "\n", "\tret=0;\n", "\trv=rval_expr_eval(h, msg, rve);\n", "\tif (unlikely(rv==0)){\n", "\t\tLM_ERR(\"rval expression evaluation failed (%d,%d-%d,%d)\\n\",\n", "\t\t\t\trve->fpos.s_line, rve->fpos.s_col,\n", "\t\t\t\trve->fpos.e_line, rve->fpos.e_col);\n", "\t\tgoto error;\n", "\t}\n", "\tswitch(lv->type){\n", "\t\tcase LV_NONE:\n", "\t\t\tLM_BUG(\"uninitialized/invalid lvalue (%d) (cfg line: %d)\\n\",\n", "\t\t\t\t\tlv->type, rve->fpos.s_line);\n", "\t\t\tgoto error;\n", "\t\tcase LV_AVP:\n", "\t\t\tret=lval_avp_assign(h, msg, lv, rv);\n", "\t\t\tbreak;\n", "\t\tcase LV_PVAR:\n", "\t\t\tret=lval_pvar_assign(h, msg, lv, rv);\n", "\t\t\tbreak;\n", "\t}\n", "\tif (unlikely(ret<0)){\n", "\t\tLM_ERR(\"assignment failed at pos: (%d,%d-%d,%d)\\n\",\n", "\t\t\trve->fpos.s_line, rve->fpos.s_col,\n", "\t\t\trve->fpos.e_line, rve->fpos.e_col);\n", "\t}\n", "\telse\n", "\t{\n", "\t\tif(unlikely(_log_assign_action!=NULL))\n", "\t\t\t_log_assign_action(msg, lv);\n", "\t}\n", "\trval_destroy(rv);\n", "\treturn ret;\n", "error:\n", "\tif (rv) rval_destroy(rv);\n", "\treturn -1;\n", "}\n"], "project": "kamailio-snmpstats-modules", "file": "lvalue.pkl", "function": "lval_assign"}, {"comment_all": {"comment": "/*\n *----------------------------------------------------------------------------\n * full screen preferences and utils\n *----------------------------------------------------------------------------\n */", "depth": 0, "reading_ease": 83.32, "reading_grade": 2.9, "line": 382}, "comment_text": "/*\n *----------------------------------------------------------------------------\n * full screen preferences and utils\n *----------------------------------------------------------------------------\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "full", "screen", "preferences", "and", "utils", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["\n", "\n", "/*\n", " *----------------------------------------------------------------------------\n", " * full screen preferences and utils\n", " *----------------------------------------------------------------------------\n", " */\n", "\n", "GList *fullscreen_prefs_list(void)\n", "{\n", "\tGList *list = NULL;\n", "\tGdkDisplay *display;\n", "\tgint number;\n", "\tgint i;\n", "\n", "\tdisplay = gdk_display_get_default();\n", "\tnumber = gdk_display_get_n_screens(display);\n", "\n", "\tfor (i = 0; i < number; i++)\n", "\t\t{\n", "\t\tGdkScreen *screen;\n", "\t\tgint monitors;\n", "\t\tgint j;\n", "\n", "\t\tscreen = gdk_display_get_screen(display, i);\n", "\t\tmonitors = gdk_screen_get_n_monitors(screen);\n", "\n", "\t\tfor (j = -1; j < monitors; j++)\n", "\t\t\t{\n", "\t\t\tScreenData *sd;\n", "\t\t\tGdkRectangle rect;\n", "\t\t\tgchar *name;\n", "\t\t\tgchar *subname;\n", "\n", "\t\t\tname = gdk_screen_make_display_name(screen);\n", "\n", "\t\t\tif (j < 0)\n", "\t\t\t\t{\n", "\t\t\t\trect.x = 0;\n", "\t\t\t\trect.y = 0;\n", "\t\t\t\trect.width = gdk_screen_get_width(screen);\n", "\t\t\t\trect.height = gdk_screen_get_height(screen);\n", "\t\t\t\tsubname = g_strdup(_(\"Full size\"));\n", "\t\t\t\t}\n", "\t\t\telse\n", "\t\t\t\t{\n", "\t\t\t\tgdk_screen_get_monitor_geometry(screen, j, &rect);\n", "\t\t\t\tsubname = gdk_screen_get_monitor_plug_name(screen, j);\n", "\t\t\t\tif (subname == NULL)\n", "\t\t\t\t\t{\n", "\t\t\t\t\tsubname = g_strdup_printf(\"%s %d\", _(\"Monitor\"), j + 1);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\n", "\t\t\tsd = g_new0(ScreenData, 1);\n", "\t\t\tsd->number = (i+1) * 100 + j + 1;\n", "\t\t\tsd->description = g_strdup_printf(\"%s %s, %s\", _(\"Screen\"), name, subname);\n", "\t\t\tsd->x = rect.x;\n", "\t\t\tsd->y = rect.y;\n", "\t\t\tsd->width = rect.width;\n", "\t\t\tsd->height = rect.height;\n", "\n", "\t\t\tDEBUG_1(\"Screen %d %30s %4d,%4d (%4dx%4d)\",\n", "\t\t\t\t\t  sd->number, sd->description, sd->x, sd->y, sd->width, sd->height);\n", "\n", "\t\t\tlist = g_list_append(list, sd);\n", "\n", "\t\t\tg_free(name);\n", "\t\t\tg_free(subname);\n", "\t\t\t}\n", "\t\t}\n", "\n", "\treturn list;\n", "}\n"], "project": "geeqie", "file": "fullscreen.pkl", "function": "fullscreen_prefs_list"}, {"comment_all": {"comment": "/* Ignore our old allocation if reconfiguring */", "depth": 1, "reading_ease": 6.17, "reading_grade": 13.9, "line": 195}, "comment_text": "/* Ignore our old allocation if reconfiguring */", "comment_tokens": ["Ignore", "our", "old", "allocation", "if", "reconfiguring"], "ccode": ["/*-\n", " * Copyright (c) 2014-2017 MongoDB, Inc.\n", " * Copyright (c) 2008-2014 WiredTiger, Inc.\n", " *\tAll rights reserved.\n", " *\n", " * See the file LICENSE for redistribution information.\n", " */\n", "\n", "#include \"wt_internal.h\"\n", "\n", "/*\n", " * Tuning constants.\n", " */\n", "/*\n", " * Threshold when a connection is allocated more cache, as a percentage of\n", " * the amount of pressure the busiest participant has.\n", " */\n", "#define\tWT_CACHE_POOL_BUMP_THRESHOLD\t60\n", "/*\n", " * Threshold when a connection is allocated less cache, as a percentage of\n", " * the amount of pressure the busiest participant has.\n", " */\n", "#define\tWT_CACHE_POOL_REDUCE_THRESHOLD\t20\n", "/* Balancing passes after a bump before a connection is a candidate. */\n", "#define\tWT_CACHE_POOL_BUMP_SKIPS\t5\n", "/* Balancing passes after a reduction before a connection is a candidate. */\n", "#define\tWT_CACHE_POOL_REDUCE_SKIPS\t10\n", "\n", "/*\n", " * Constants that control how much influence different metrics have on\n", " * the pressure calculation.\n", " */\n", "#define\tWT_CACHE_POOL_APP_EVICT_MULTIPLIER\t3\n", "#define\tWT_CACHE_POOL_APP_WAIT_MULTIPLIER\t6\n", "#define\tWT_CACHE_POOL_READ_MULTIPLIER\t\t1\n", "\n", "static void __cache_pool_adjust(\n", "    WT_SESSION_IMPL *, uint64_t, uint64_t, bool, bool *);\n", "static void __cache_pool_assess(WT_SESSION_IMPL *, uint64_t *);\n", "static void __cache_pool_balance(WT_SESSION_IMPL *, bool);\n", "\n", "/*\n", " * __wt_cache_pool_config --\n", " *\tParse and setup the cache pool options.\n", " */\n", "int\n", "__wt_cache_pool_config(WT_SESSION_IMPL *session, const char **cfg)\n", "{\n", "\tWT_CACHE_POOL *cp;\n", "\tWT_CONFIG_ITEM cval;\n", "\tWT_CONNECTION_IMPL *conn, *entry;\n", "\tWT_DECL_RET;\n", "\tchar *pool_name;\n", "\tbool created, updating;\n", "\tuint64_t chunk, quota, reserve, size, used_cache;\n", "\n", "\tconn = S2C(session);\n", "\tcreated = updating = false;\n", "\tpool_name = NULL;\n", "\tcp = NULL;\n", "\n", "\tif (F_ISSET(conn, WT_CONN_CACHE_POOL))\n", "\t\tupdating = true;\n", "\telse {\n", "\t\tWT_RET(__wt_config_gets_none(\n", "\t\t    session, cfg, \"shared_cache.name\", &cval));\n", "\t\tif (cval.len == 0) {\n", "\t\t\t/*\n", "\t\t\t * Tell the user if they configured a cache pool\n", "\t\t\t * size but didn't enable it by naming the pool.\n", "\t\t\t */\n", "\t\t\tif (__wt_config_gets(session, &cfg[1],\n", "\t\t\t    \"shared_cache.size\", &cval) != WT_NOTFOUND)\n", "\t\t\t\tWT_RET_MSG(session, EINVAL,\n", "\t\t\t\t    \"Shared cache configuration requires a \"\n", "\t\t\t\t    \"pool name\");\n", "\t\t\treturn (0);\n", "\t\t}\n", "\n", "\t\tif (__wt_config_gets(session,\n", "\t\t    &cfg[1], \"cache_size\", &cval) != WT_NOTFOUND)\n", "\t\t\tWT_RET_MSG(session, EINVAL,\n", "\t\t\t    \"Only one of cache_size and shared_cache can be \"\n", "\t\t\t    \"in the configuration\");\n", "\n", "\t\t/*\n", "\t\t * NOTE: The allocations made when configuring and opening a\n", "\t\t * cache pool don't really belong to the connection that\n", "\t\t * allocates them. If a memory allocator becomes connection\n", "\t\t * specific in the future we will need a way to allocate memory\n", "\t\t * outside of the connection here.\n", "\t\t */\n", "\t\tWT_RET(__wt_strndup(session, cval.str, cval.len, &pool_name));\n", "\t}\n", "\n", "\t__wt_spin_lock(session, &__wt_process.spinlock);\n", "\tif (__wt_process.cache_pool == NULL) {\n", "\t\tWT_ASSERT(session, !updating);\n", "\t\t/* Create a cache pool. */\n", "\t\tWT_ERR(__wt_calloc_one(session, &cp));\n", "\t\tcreated = true;\n", "\t\tcp->name = pool_name;\n", "\t\tpool_name = NULL; /* Belongs to the cache pool now. */\n", "\t\tTAILQ_INIT(&cp->cache_pool_qh);\n", "\t\tWT_ERR(__wt_spin_init(\n", "\t\t    session, &cp->cache_pool_lock, \"cache shared pool\"));\n", "\t\tWT_ERR(__wt_cond_alloc(\n", "\t\t    session, \"cache pool server\", &cp->cache_pool_cond));\n", "\n", "\t\t__wt_process.cache_pool = cp;\n", "\t\t__wt_verbose(session,\n", "\t\t    WT_VERB_SHARED_CACHE, \"Created cache pool %s\", cp->name);\n", "\t} else if (!updating &&\n", "\t    strcmp(__wt_process.cache_pool->name, pool_name) != 0)\n", "\t\t/* Only a single cache pool is supported. */\n", "\t\tWT_ERR_MSG(session, WT_ERROR,\n", "\t\t    \"Attempting to join a cache pool that does not exist: %s\",\n", "\t\t    pool_name);\n", "\n", "\tcp = __wt_process.cache_pool;\n", "\n", "\t/*\n", "\t * The cache pool requires a reference count to avoid a race between\n", "\t * configuration/open and destroy.\n", "\t */\n", "\tif (!updating)\n", "\t\t++cp->refs;\n", "\n", "\t/*\n", "\t * Cache pool configurations are optional when not creating. If\n", "\t * values aren't being changed, retrieve the current value so that\n", "\t * validation of settings works.\n", "\t */\n", "\tif (!created) {\n", "\t\tif (__wt_config_gets(session, &cfg[1],\n", "\t\t    \"shared_cache.size\", &cval) == 0 && cval.val != 0)\n", "\t\t\tsize = (uint64_t)cval.val;\n", "\t\t else\n", "\t\t\tsize = cp->size;\n", "\t\tif (__wt_config_gets(session, &cfg[1],\n", "\t\t    \"shared_cache.chunk\", &cval) == 0 && cval.val != 0)\n", "\t\t\tchunk = (uint64_t)cval.val;\n", "\t\telse\n", "\t\t\tchunk = cp->chunk;\n", "\t\tif (__wt_config_gets(session, &cfg[1],\n", "\t\t    \"shared_cache.quota\", &cval) == 0 && cval.val != 0)\n", "\t\t\tquota = (uint64_t)cval.val;\n", "\t\telse\n", "\t\t\tquota = cp->quota;\n", "\t} else {\n", "\t\t/*\n", "\t\t * The only time shared cache configuration uses default\n", "\t\t * values is when we are creating the pool.\n", "\t\t */\n", "\t\tWT_ERR(__wt_config_gets(\n", "\t\t    session, cfg, \"shared_cache.size\", &cval));\n", "\t\tWT_ASSERT(session, cval.val != 0);\n", "\t\tsize = (uint64_t)cval.val;\n", "\t\tWT_ERR(__wt_config_gets(\n", "\t\t    session, cfg, \"shared_cache.chunk\", &cval));\n", "\t\tWT_ASSERT(session, cval.val != 0);\n", "\t\tchunk = (uint64_t)cval.val;\n", "\t\tWT_ERR(__wt_config_gets(\n", "\t\t    session, cfg, \"shared_cache.quota\", &cval));\n", "\t\tquota = (uint64_t)cval.val;\n", "\t}\n", "\n", "\t/*\n", "\t * Retrieve the reserve size here for validation of configuration.\n", "\t * Don't save it yet since the connections cache is not created if\n", "\t * we are opening. Cache configuration is responsible for saving the\n", "\t * setting.\n", "\t * The different conditions when reserved size are set are:\n", "\t *  - It's part of the users configuration - use that value.\n", "\t *  - We are reconfiguring - keep the previous value.\n", "\t *  - We are joining a cache pool for the first time (including\n", "\t *  creating the pool) - use the chunk size; that's the default.\n", "\t */\n", "\tif (__wt_config_gets(session, &cfg[1],\n", "\t    \"shared_cache.reserve\", &cval) == 0 && cval.val != 0)\n", "\t\treserve = (uint64_t)cval.val;\n", "\telse if (updating)\n", "\t\treserve = conn->cache->cp_reserved;\n", "\telse\n", "\t\treserve = chunk;\n", "\n", "\t/*\n", "\t * Validate that size and reserve values don't cause the cache\n", "\t * pool to be over subscribed.\n", "\t */\n", "\tused_cache = 0;\n", "\tif (!created) {\n", "\t\tTAILQ_FOREACH(entry, &cp->cache_pool_qh, cpq)\n", "\t\t\tused_cache += entry->cache->cp_reserved;\n", "\t}\n", "\t/* Ignore our old allocation if reconfiguring */\n", "\tif (updating)\n", "\t\tused_cache -= conn->cache->cp_reserved;\n", "\tif (used_cache + reserve > size)\n", "\t\tWT_ERR_MSG(session, EINVAL,\n", "\t\t    \"Shared cache unable to accommodate this configuration. \"\n", "\t\t    \"Shared cache size: %\" PRIu64 \", requested min: %\" PRIu64,\n", "\t\t    size, used_cache + reserve);\n", "\n", "\t/* The configuration is verified - it's safe to update the pool. */\n", "\tcp->size = size;\n", "\tcp->chunk = chunk;\n", "\tcp->quota = quota;\n", "\n", "\tconn->cache->cp_reserved = reserve;\n", "\tconn->cache->cp_quota = quota;\n", "\n", "\t/* Wake up the cache pool server so any changes are noticed. */\n", "\tif (updating)\n", "\t\t__wt_cond_signal(\n", "\t\t    session, __wt_process.cache_pool->cache_pool_cond);\n", "\n", "\t__wt_verbose(session, WT_VERB_SHARED_CACHE,\n", "\t    \"Configured cache pool %s. Size: %\" PRIu64\n", "\t    \", chunk size: %\" PRIu64, cp->name, cp->size, cp->chunk);\n", "\n", "\tF_SET(conn, WT_CONN_CACHE_POOL);\n", "err:\t__wt_spin_unlock(session, &__wt_process.spinlock);\n", "\tif (!updating)\n", "\t\t__wt_free(session, pool_name);\n", "\tif (ret != 0 && created) {\n", "\t\t__wt_free(session, cp->name);\n", "\t\t__wt_cond_destroy(session, &cp->cache_pool_cond);\n", "\t\t__wt_free(session, cp);\n", "\t}\n", "\treturn (ret);\n", "}\n"], "project": "python-wiredtiger", "file": "conn_cache_pool.pkl", "function": "__wt_cache_pool_config"}, {"comment_all": {"comment": "/*\n * Wslay - The WebSocket Library\n *\n * Copyright (c) 2011, 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */", "depth": 0, "reading_ease": 13.32, "reading_grade": 25.6, "line": 0}, "comment_text": "/*\n * Wslay - The WebSocket Library\n *\n * Copyright (c) 2011, 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */", "comment_tokens": ["Wslay", "-", "The", "WebSocket", "Library", "Copyright", "(", "c", ")", "2011", ",", "2012", "Tatsuhiro", "Tsujikawa", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/*\n", " * Wslay - The WebSocket Library\n", " *\n", " * Copyright (c) 2011, 2012 Tatsuhiro Tsujikawa\n", " *\n", " * Permission is hereby granted, free of charge, to any person obtaining\n", " * a copy of this software and associated documentation files (the\n", " * \"Software\"), to deal in the Software without restriction, including\n", " * without limitation the rights to use, copy, modify, merge, publish,\n", " * distribute, sublicense, and/or sell copies of the Software, and to\n", " * permit persons to whom the Software is furnished to do so, subject to\n", " * the following conditions:\n", " *\n", " * The above copyright notice and this permission notice shall be\n", " * included in all copies or substantial portions of the Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n", " * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n", " * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n", " * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n", " * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n", " * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", " */\n", "#include \"wslay_queue.h\"\n", "\n", "#include <string.h>\n", "#include <assert.h>\n", "\n", "struct wslay_queue* wslay_queue_new(void)\n", "{\n", "  struct wslay_queue *queue = (struct wslay_queue*)malloc\n", "    (sizeof(struct wslay_queue));\n", "  if(!queue) {\n", "    return NULL;\n", "  }\n", "  queue->top = queue->tail = NULL;\n", "  return queue;\n", "}\n"], "project": "libaria2-0", "file": "wslay_queue.pkl", "function": "wslay_queue_new"}, {"comment_all": {"comment": "/**\n * exsltSetsRegister:\n *\n * Registers the EXSLT - Sets module\n */", "depth": 0, "reading_ease": 14.63, "reading_grade": 12.7, "line": 255}, "comment_text": "/**\n * exsltSetsRegister:\n *\n * Registers the EXSLT - Sets module\n */", "comment_tokens": ["exsltSetsRegister", ":", "Registers", "the", "EXSLT", "-", "Sets", "module"], "ccode": ["\n", "/**\n", " * exsltSetsRegister:\n", " *\n", " * Registers the EXSLT - Sets module\n", " */\n", "\n", "void\n", "exsltSetsRegister (void) {\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"difference\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsDifferenceFunction);\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"intersection\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsIntersectionFunction);\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"distinct\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsDistinctFunction);\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"has-same-node\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsHasSameNodesFunction);\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"leading\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsLeadingFunction);\n", "    xsltRegisterExtModuleFunction ((const xmlChar *) \"trailing\",\n", "\t\t\t\t   EXSLT_SETS_NAMESPACE,\n", "\t\t\t\t   exsltSetsTrailingFunction);\n", "}\n"], "project": "libxslt1.1", "file": "sets.pkl", "function": "exsltSetsRegister"}, {"comment_all": {"comment": "// indicates current block has not been loaded\n", "depth": 1, "reading_ease": 64.37, "reading_grade": 6.0, "line": 519}, "comment_text": "// indicates current block has not been loaded\n", "comment_tokens": ["indicates", "current", "block", "has", "not", "been", "loaded"], "ccode": ["\n", "int64_t bgzf_seek(BGZF* fp, int64_t pos, int where)\n", "{\n", "\tint block_offset;\n", "\tint64_t block_address;\n", "\n", "\tif (fp->open_mode != 'r' || where != SEEK_SET) {\n", "\t\tfp->errcode |= BGZF_ERR_MISUSE;\n", "\t\treturn -1;\n", "\t}\n", "\tblock_offset = pos & 0xFFFF;\n", "\tblock_address = pos >> 16;\n", "\tif (_bgzf_seek(fp->fp, block_address, SEEK_SET) < 0) {\n", "\t\tfp->errcode |= BGZF_ERR_IO;\n", "\t\treturn -1;\n", "\t}\n", "\tfp->block_length = 0;  // indicates current block has not been loaded\n", "\tfp->block_address = block_address;\n", "\tfp->block_offset = block_offset;\n", "\treturn 0;\n", "}\n"], "project": "libstatgen-dev", "file": "bgzf.pkl", "function": "bgzf_seek"}, {"comment_all": {"comment": "/* Lets generate attr from db_order if database does not have attr */", "depth": 1, "reading_ease": 68.77, "reading_grade": 6.4, "line": 262}, "comment_text": "/* Lets generate attr from db_order if database does not have attr */", "comment_tokens": ["Lets", "generate", "attr", "from", "db_order", "if", "database", "does", "not", "have", "attr"], "ccode": ["\n", "\n", "\n", "int db_file_read_spec(int db){\n", "  \n", "  int i=0;\n", "  int* db_osize=0;\n", "  DB_FIELD** db_order=NULL;\n", "\n", "  switch (db) {\n", "  case DB_OLD: {\n", "    db_osize=&(conf->db_in_size);\n", "    db_order=&(conf->db_in_order);\n", "    db_lineno=&db_in_lineno;\n", "    break;\n", "  }\n", "  case DB_NEW: {\n", "    db_osize=&(conf->db_new_size);\n", "    db_order=&(conf->db_new_order);\n", "    db_lineno=&db_new_lineno;\n", "    break;\n", "  }\n", "  }\n", "\n", "  *db_order=(DB_FIELD*) malloc(1*sizeof(DB_FIELD));\n", "  \n", "  while ((i=db_scan())!=TNEWLINE){\n", "    switch (i) {\n", "      \n", "    case TID : {\n", "      int l;\n", "      \n", "\n", "      /* Yes... we do not check if realloc returns nonnull */\n", "\n", "      *db_order=(DB_FIELD*)\n", "\trealloc((void*)*db_order,\n", "\t\t((*db_osize)+1)*sizeof(DB_FIELD));\n", "      \n", "      if(*db_order==NULL){\n", "\treturn RETFAIL;\n", "      }\n", "      \n", "      (*db_order)[*db_osize]=db_unknown;\n", "      \n", "      for (l=0;l<db_unknown;l++){\n", "\t\n", "\tif (strcmp(db_names[l],dbtext)==0) {\n", "\t  \n", "\t  if (check_db_order(*db_order, *db_osize,\n", "\t\t\t     db_value[l])==RETFAIL) {\n", "\t    error(0,\"Field %s redefined in @@dbspec\\n\",dbtext);\n", "\t    (*db_order)[*db_osize]=db_unknown;\n", "\t  } else {\n", "\t    (*db_order)[*db_osize]=db_value[l];\n", "\t  }\n", "\t  (*db_osize)++;\n", "\t  break;\n", "\t}\n", "      }\n", "      for (l=0;l<db_alias_size;l++){\n", "\t\n", "\tif (strcmp(db_namealias[l],dbtext)==0) {\n", "\t  \n", "\t  if (check_db_order(*db_order, *db_osize,\n", "\t\t\t     db_aliasvalue[l])==RETFAIL) {\n", "\t    error(0,\"Field %s redefined in @@dbspec\\n\",dbtext);\n", "\t    (*db_order)[*db_osize]=db_unknown;\n", "\t  } else {\n", "\t    (*db_order)[*db_osize]=db_aliasvalue[l];\n", "\t  }\n", "\t  (*db_osize)++;\n", "\t  break;\n", "\t}\n", "      }\n", "      if(l==db_unknown){\n", "\terror(0,\"Unknown field %s in database\\n\",dbtext);\n", "\t(*db_osize)++;\n", "      }\n", "      break;\n", "    }\n", "    \n", "    case TDBSPEC : {\n", "      error(0,\"Only one @@dbspec in input database.\\n\");\n", "      return RETFAIL;\n", "      break;\n", "    }\n", "    \n", "    default : {\n", "      error(0,\"Aide internal error while reading input database.\\n\");\n", "      return RETFAIL;\n", "    }\n", "    }\n", "  }\n", "\n", "  /* Lets generate attr from db_order if database does not have attr */\n", "  conf->attr=-1;\n", "\n", "  for (i=0;i<*db_osize;i++) {\n", "    if ((*db_order)[i]==db_attr) {\n", "      conf->attr=1;\n", "    }\n", "  }\n", "  if (conf->attr==DB_ATTR_UNDEF) {\n", "    conf->attr=0;\n", "    error(0,\"Database does not have attr field.\\nComparison may be incorrect\\nGenerating attr-field from dbspec\\nIt might be a good Idea to regenerate databases. Sorry.\\n\");\n", "    for(i=0;i<conf->db_in_size;i++) {\n", "      conf->attr|=1<<(*db_order)[i];\n", "    }\n", "  }\n", "  return RETOK;\n", "}\n"], "project": "aide-common", "file": "db_file.pkl", "function": "db_file_read_spec"}, {"comment_all": {"comment": "/*\n * Expand variables in a token.  The parsing stops when a token separater\n * (in most cases, it is a whitespace) is encountered.  'str' is updated to\n * point to the next character.\n *\n * The returned string must be freed when done.\n */", "depth": 0, "reading_ease": 78.75, "reading_grade": 4.6, "line": 563}, "comment_text": "/*\n * Expand variables in a token.  The parsing stops when a token separater\n * (in most cases, it is a whitespace) is encountered.  'str' is updated to\n * point to the next character.\n *\n * The returned string must be freed when done.\n */", "comment_tokens": ["Expand", "variables", "in", "a", "token", ".", "The", "parsing", "stops", "when", "a", "token", "separater", "(", "in", "most", "cases", ",", "it", "is", "a", "whitespace", ")", "is", "encountered", ".", "'str", "'", "is", "updated", "to", "point", "to", "the", "next", "character", ".", "The", "returned", "string", "must", "be", "freed", "when", "done", "."], "ccode": ["\n", "/*\n", " * Expand variables in a token.  The parsing stops when a token separater\n", " * (in most cases, it is a whitespace) is encountered.  'str' is updated to\n", " * point to the next character.\n", " *\n", " * The returned string must be freed when done.\n", " */\n", "char *expand_one_token(const char **str)\n", "{\n", "\treturn __expand_string(str, is_end_of_token, 0, NULL);\n", "}\n"], "project": "linux-buildinfo-5.8.0-43-generic", "file": "preprocess.pkl", "function": "expand_one_token"}, {"comment_all": {"comment": "/* Test for uuencoded blocks by seeing if over 1/3 of the lines have\n     identical length. */", "depth": 1, "reading_ease": 81.63, "reading_grade": 5.6, "line": 73}, "comment_text": "/* Test for uuencoded blocks by seeing if over 1/3 of the lines have\n     identical length. */", "comment_tokens": ["Test", "for", "uuencoded", "blocks", "by", "seeing", "if", "over", "13", "of", "the", "lines", "have", "identical", "length", "."], "ccode": ["/* istext.c - test if a file contains text or not. */\n", "\n", "/* Copyright (C) 1997 Andrew McCallum\n", "\n", "   Written by:  Andrew Kachites McCallum <mccallum@cs.cmu.edu>\n", "\n", "   This file is part of the Bag-Of-Words Library, `libbow'.\n", "\n", "   This library is free software; you can redistribute it and/or\n", "   modify it under the terms of the GNU Library General Public License\n", "   as published by the Free Software Foundation, version 2.\n", "   \n", "   This library is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "   Library General Public License for more details.\n", "\n", "   You should have received a copy of the GNU Library General Public\n", "   License along with this library; if not, write to the Free Software\n", "   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA */\n", "\n", "#include <stdio.h>\n", "#include <unistd.h>        /* for SunOS 4.1.3_U1 - no SEEK_SET in stdio.h */\n", "#include <assert.h>\n", "#include <ctype.h>\t\t/* for isprint(), etc. */\n", "\n", "/* The percentage of characters that must be text-like in order for\n", "   us to say this is a text file. */\n", "#define TEXT_PRINTABLE_PERCENT 95\n", "\n", "/* Examine the first NUM_TEST_CHARS characters of `fp', and return a \n", "   non-zero value iff TEXT_PRINTABLE_PERCENT of them are printable. */\n", "int\n", "ifile_fp_is_text (FILE *fp)\n", "{\n", "#ifdef _AIX\n", "#define NUM_TEST_CHARS 4096\n", "#else\n", "#define D_NUM_TEST_CHARS 4096\n", "  static const int NUM_TEST_CHARS = D_NUM_TEST_CHARS;\n", "#endif\n", "  char buf[NUM_TEST_CHARS];\n", "  int num_read;\n", "  int num_printable = 0;\n", "  int num_spaces = 0;\n", "  int fpos;\n", "  int i;\n", "  int num_newlines;\n", "#ifdef _AIX\n", "#define NUM_LINE_LENGTHS NUM_TEST_CHARS\n", "#else\n", "  static const int NUM_LINE_LENGTHS = D_NUM_TEST_CHARS;\n", "#endif\n", "  int line_lengths[NUM_LINE_LENGTHS];\n", "  int line_length_histogram[NUM_LINE_LENGTHS];\n", "  int max_line_length_histogram_height;\n", "\n", "  fpos = ftell (fp);\n", "  num_read = fread (buf, sizeof (char), NUM_TEST_CHARS, fp);\n", "  fseek (fp, fpos, SEEK_SET);\n", "\n", "  for (i = 0; i < num_read; i++)\n", "    {\n", "      if (isprint (buf[i]) || isspace (buf[i]))\n", "\tnum_printable++;\n", "      if (isspace (buf[i]))\n", "\tnum_spaces++;\n", "    }\n", "\n", "  if (!(num_read > 0 \n", "\t&& (((100 * num_printable) / num_read) > TEXT_PRINTABLE_PERCENT)))\n", "    return 0;\n", "\n", "  /* Test for uuencoded blocks by seeing if over 1/3 of the lines have\n", "     identical length. */\n", "  for (i = 0, num_newlines = 0, line_lengths[num_newlines] = 0;\n", "       i < num_read;\n", "       i++)\n", "    {\n", "      if (buf[i] == '\\n')\n", "\t{\n", "\t  num_newlines++;\n", "\t  assert (num_newlines < NUM_LINE_LENGTHS);\n", "\t  line_lengths[num_newlines] = 0;\n", "\t}\n", "      else\n", "\t{\n", "\t  line_lengths[num_newlines]++;\n", "\t}\n", "    }\n", "  for (i = 0; i < NUM_LINE_LENGTHS; i++)\n", "    line_length_histogram[i] = 0;\n", "  for (i = 0; i < num_newlines; i++)\n", "    line_length_histogram[line_lengths[i]]++;\n", "  max_line_length_histogram_height = line_length_histogram[0];\n", "  for (i = 1; i < NUM_LINE_LENGTHS; i++)\n", "    if (max_line_length_histogram_height < line_length_histogram[i])\n", "      max_line_length_histogram_height = line_length_histogram[i];\n", "  /* If over a 1/3 of the lines have the same height, this file\n", "     probably contains a uuencoded block. */\n", "  if (max_line_length_histogram_height > num_newlines / 3\n", "      && num_spaces < num_read / 10)\n", "    return 0;\n", "\n", "  return 1;\n", "}\n"], "project": "ifile", "file": "istext.pkl", "function": "ifile_fp_is_text"}, {"comment_all": {"comment": "/*\n * The following routines are for manipulating the .ICEauthority file\n * These are utility functions - they are not part of the standard\n * ICE library specification.\n */", "depth": 0, "reading_ease": 42.88, "reading_grade": 10.1, "line": 59}, "comment_text": "/*\n * The following routines are for manipulating the .ICEauthority file\n * These are utility functions - they are not part of the standard\n * ICE library specification.\n */", "comment_tokens": ["The", "following", "routines", "are", "for", "manipulating", "the", ".ICEauthority", "file", "These", "are", "utility", "functions", "-", "they", "are", "not", "part", "of", "the", "standard", "ICE", "library", "specification", "."], "ccode": ["/******************************************************************************\n", "\n", "\n", "Copyright 1993, 1998  The Open Group\n", "\n", "Permission to use, copy, modify, distribute, and sell this software and its\n", "documentation for any purpose is hereby granted without fee, provided that\n", "the above copyright notice appear in all copies and that both that\n", "copyright notice and this permission notice appear in supporting\n", "documentation.\n", "\n", "The above copyright notice and this permission notice shall be included in\n", "all copies or substantial portions of the Software.\n", "\n", "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n", "OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n", "AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n", "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "\n", "Except as contained in this notice, the name of The Open Group shall not be\n", "used in advertising or otherwise to promote the sale, use or other dealings\n", "in this Software without prior written authorization from The Open Group.\n", "\n", "Author: Ralph Mor, X Consortium\n", "******************************************************************************/\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "#include <X11/ICE/ICElib.h>\n", "#include \"ICElibint.h\"\n", "#include <X11/ICE/ICEutil.h>\n", "#include <X11/Xos.h>\n", "#include <sys/stat.h>\n", "#include <errno.h>\n", "#include <limits.h>\n", "\n", "#include <time.h>\n", "#ifndef X_NOT_POSIX\n", "#include <unistd.h>\n", "#else\n", "#ifndef WIN32\n", "extern unsigned\tsleep ();\n", "#else\n", "#define link rename\n", "#endif\n", "#endif\n", "\n", "static Status read_short (FILE *file, unsigned short *shortp);\n", "static Status read_string (FILE *file, char **stringp);\n", "static Status read_counted_string (FILE *file, unsigned short *countp, char **stringp);\n", "static Status write_short (FILE *file, unsigned short s);\n", "static Status write_string (FILE *file, const char *string);\n", "static Status write_counted_string (FILE *file, unsigned short count, const char *string);\n", "\n", "\n", "\n", "/*\n", " * The following routines are for manipulating the .ICEauthority file\n", " * These are utility functions - they are not part of the standard\n", " * ICE library specification.\n", " */\n", "\n", "char *\n", "IceAuthFileName (void)\n", "{\n", "    const char  *ICEauthority_name = \".ICEauthority\";\n", "    char    \t*name;\n", "    static char\t*buf;\n", "    static size_t bsize;\n", "    size_t    \tsize;\n", "#ifdef WIN32\n", "#ifndef PATH_MAX\n", "#define PATH_MAX 512\n", "#endif\n", "    char    \tdir[PATH_MAX];\n", "#endif\n", "\n", "    if ((name = getenv (\"ICEAUTHORITY\")))\n", "\treturn (name);\n", "\n", "    /* If it's in the XDG_RUNTIME_DIR, don't use a dotfile */\n", "    if ((name = getenv (\"XDG_RUNTIME_DIR\")))\n", "\tICEauthority_name++;\n", "\n", "    if (!name || !name[0])\n", "\tname = getenv (\"HOME\");\n", "\n", "    if (!name || !name[0])\n", "    {\n", "#ifdef WIN32\n", "    register char *ptr1;\n", "    register char *ptr2;\n", "    int len1 = 0, len2 = 0;\n", "\n", "    if ((ptr1 = getenv(\"HOMEDRIVE\")) && (ptr2 = getenv(\"HOMEDIR\"))) {\n", "\tlen1 = strlen (ptr1);\n", "\tlen2 = strlen (ptr2);\n", "    } else if ((ptr2 = getenv(\"USERNAME\"))) {\n", "\tlen1 = strlen (ptr1 = \"/users/\");\n", "\tlen2 = strlen (ptr2);\n", "    }\n", "    if ((len1 + len2 + 1) < PATH_MAX) {\n", "\tsnprintf (dir, sizeof(dir), \"%s%s\", ptr1, (ptr2) ? ptr2 : \"\");\n", "\tname = dir;\n", "    }\n", "    if (!name || !name[0])\n", "#endif\n", "\treturn (NULL);\n", "    }\n", "\n", "    /* Special case for \"/\".  We will add our own '/' later. */\n", "    if (name[1] == '\\0')\n", "\tname++;\n", "\n", "    size = strlen (name) + 1 + strlen (ICEauthority_name) + 1;\n", "\n", "    if (size > bsize)\n", "    {\n", "\n", "\tfree (buf);\n", "\tbuf = malloc (size);\n", "\tif (!buf) {\n", "\t    bsize = 0;\n", "\t    return (NULL);\n", "\t}\n", "\tbsize = size;\n", "    }\n", "\n", "    snprintf (buf, bsize, \"%s/%s\", name, ICEauthority_name);\n", "\n", "    return (buf);\n", "}\n"], "project": "libice6-dbg", "file": "authutil.pkl", "function": "IceAuthFileName"}, {"comment_all": {"comment": "/* Vendor specific Unit Attention mode page for mode_sense */", "depth": 0, "reading_ease": 37.98, "reading_grade": 10.0, "line": 279}, "comment_text": "/* Vendor specific Unit Attention mode page for mode_sense */", "comment_tokens": ["Vendor", "specific", "Unit", "Attention", "mode", "page", "for", "mode_sense"], "ccode": ["\n", "/* Vendor specific Unit Attention mode page for mode_sense */\n", "static int\n", "resp_vs_ua_m_pg(uint8_t *p, int pcontrol)\n", "{\n", "    uint8_t ch_vs_ua_m_pg[] = {/* 0x0, 0xe, */ 0xff, 0, 0, 0, 0, 0,\n", "                               0, 0, 0, 0, 0, 0, 0, 0};\n", "    uint8_t d_vs_ua_m_pg[] = {0x0, 0xe, 0, 0, 0, 0, 0, 0,\n", "                              0, 0, 0, 0, 0, 0, 0, 0};\n", "\n", "    memcpy(p, vs_ua_m_pg, sizeof(vs_ua_m_pg));\n", "    if (1 == pcontrol)\n", "        memcpy(p + 2, ch_vs_ua_m_pg, sizeof(ch_vs_ua_m_pg));\n", "    else if (2 == pcontrol)\n", "        memcpy(p, d_vs_ua_m_pg, sizeof(d_vs_ua_m_pg));\n", "    return sizeof(vs_ua_m_pg);\n", "}\n"], "project": "sg3-utils-udev", "file": "sg_pt_common.pkl", "function": "resp_vs_ua_m_pg"}, {"comment_all": {"comment": "/*\n * Copyright (c) 2008,2009 by Dmitry V. Levin.  See LICENSE.\n */", "depth": 0, "reading_ease": 87.72, "reading_grade": 3.3, "line": 0}, "comment_text": "/*\n * Copyright (c) 2008,2009 by Dmitry V. Levin.  See LICENSE.\n */", "comment_tokens": ["Copyright", "(", "c", ")", "2008,2009", "by", "Dmitry", "V.", "Levin", ".", "See", "LICENSE", "."], "ccode": ["/*\n", " * Copyright (c) 2008,2009 by Dmitry V. Levin.  See LICENSE.\n", " */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <stdarg.h>\n", "#include <unistd.h>\n", "#include <errno.h>\n", "#include <sys/stat.h>\n", "\n", "#include \"passwdqc.h\"\n", "#include \"concat.h\"\n", "\n", "static char *mkreason(const char *what, const char *pathname,\n", "    unsigned int lineno, const char *why)\n", "{\n", "\tchar buf[sizeof(unsigned int) * 3 + 1];\n", "\tconst char *at_line = (lineno ? \" at line \" : \"\");\n", "\tconst char *at_num = (lineno ? buf : \"\");\n", "\n", "\tif (lineno)\n", "\t\tsprintf(buf, \"%u\", lineno);\n", "\treturn concat(what, \" \\\"\", pathname, \"\\\"\", at_line, at_num, \": \",\n", "\t    (why ? why : strerror(errno)), NULL);\n", "}\n"], "project": "libpam-passwdqc", "file": "passwdqc_load.pkl", "function": "mkreason"}, {"comment_all": {"comment": "/* because ^@ == 0 */", "depth": 2, "reading_ease": 77.91, "reading_grade": 2.9, "line": 948}, "comment_text": "/* because ^@ == 0 */", "comment_tokens": ["because", "^", "@", "==", "0"], "ccode": ["\n", "Unicode_t display_getch(struct display *display, Boolean_t block)\n", "{\n", "\tByte_t *p;\n", "\tUnicode_t key;\n", "\tunsigned used, vals, val[16];\n", "\n", "#define GOT_CURSORPOS FUNCTION_F(99)\n", "\n", "\tif (!display)\n", "\t\treturn ERROR_EOF;\n", "\n", "again:\tif (display->size_changed)\n", "\t\treturn ERROR_CHANGED;\n", "\tdisplay_sync(display);\n", "\tif (display->inbuf_bytes >= sizeof display->inbuf - 1)\n", "\t\t;\n", "\telse if (!multiplexor(block)) {\n", "\t\tif (!display->inbuf_bytes)\n", "\t\t\treturn ERROR_EMPTY;\n", "\t} else {\n", "\t\tint n;\n", "\t\tdo {\n", "\t\t\terrno = 0;\n", "\t\t\tn = read(0, display->inbuf + display->inbuf_bytes,\n", "\t\t\t\t sizeof display->inbuf - 1 -\n", "\t\t\t\t\tdisplay->inbuf_bytes);\n", "\t\t} while (n < 0 && (errno == EAGAIN || errno == EINTR));\n", "\t\tif (debug_file) {\n", "\t\t\tfprintf(debug_file, \"read %d:\", n);\n", "\t\t\tif (n > 0)\n", "\t\t\t\tfwrite(display->inbuf + display->inbuf_bytes,\n", "\t\t\t\t       n, 1, debug_file);\n", "\t\t\tfputc('\\n', debug_file);\n", "\t\t}\n", "\t\tif (!n)\n", "\t\t\treturn ERROR_EOF;\n", "\t\tif (n < 0)\n", "\t\t\treturn ERROR_INPUT;\n", "\t\tdisplay->inbuf[display->inbuf_bytes += n] = '\\0';\n", "\t}\n", "\n", "\tp = display->inbuf;\n", "\tkey = *p;\n", "\tif (key != ESCCHAR) {\n", "\t\tif (utf8_bytes[*p] > display->inbuf_bytes) {\n", "\t\t\tif (block)\n", "\t\t\t\tgoto again;\n", "\t\t\treturn ERROR_EMPTY;\n", "\t\t}\n", "\t\tused = utf8_length((char *) p, display->inbuf_bytes);\n", "\t\tkey = utf8_unicode((char *) p, used);\n", "\t\tp += used - 1;\n", "\t\tgoto done;\n", "\t}\n", "\n", "\t/* Translate Escape characters */\n", "\n", "\tkey = 0;\n", "\tvals = 0;\n", "\tswitch (p[1]) {\n", "\n", "\tcase '[':\n", "\t\tfor (p += 2; isdigit(*p); p++) {\n", "\t\t\tval[vals] = 0;\n", "\t\t\tdo {\n", "\t\t\t\tval[vals] *= 10;\n", "\t\t\t\tval[vals] += *p++ - '0';\n", "\t\t\t} while (isdigit(*p));\n", "\t\t\tvals++;\n", "\t\t\tif (*p != ';')\n", "\t\t\t\tbreak;\n", "\t\t\tif (vals == 16)\n", "\t\t\t\tvals--;\n", "\t\t}\n", "\t\tswitch (*p) {\n", "\t\tcase 'R': /* cursor position report from southeast corner */\n", "\t\t\tif (vals >= 2)\n", "\t\t\t\tkey = GOT_CURSORPOS;\n", "\t\t\tbreak;\n", "\t\tcase '~':\n", "\t\t\tif (!val[0])\n", "\t\t\t\tbreak;\n", "\t\t\tswitch (val[0]) {\n", "\t\t\tcase  2: key = FUNCTION_INSERT;\tbreak;\n", "\t\t\tcase  3: key = FUNCTION_DELETE;\tbreak;\n", "\t\t\tcase  5: key = FUNCTION_PGUP;\tbreak;\n", "\t\t\tcase  6: key = FUNCTION_PGDOWN;\tbreak;\n", "\t\t\tcase 15: key = FUNCTION_F(5);\tbreak;\n", "\t\t\tcase 17: key = FUNCTION_F(6);\tbreak;\n", "\t\t\tcase 18: key = FUNCTION_F(7);\tbreak;\n", "\t\t\tcase 19: key = FUNCTION_F(8);\tbreak;\n", "\t\t\tcase 20: key = FUNCTION_F(9);\tbreak;\n", "\t\t\tcase 21: key = FUNCTION_F(10);\tbreak;\n", "\t/*pmk?*/\tcase 22: key = FUNCTION_F(11);\tbreak;\n", "\t\t\tcase 24: key = FUNCTION_F(12);\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase 'A': key = FUNCTION_UP;\tbreak;\n", "\t\tcase 'B': key = FUNCTION_DOWN;\tbreak;\n", "\t\tcase 'C': key = FUNCTION_RIGHT;\tbreak;\n", "\t\tcase 'D': key = FUNCTION_LEFT;\tbreak;\n", "\t\tcase 'F': key = FUNCTION_END;\tbreak;\n", "\t\tcase 'H': key = FUNCTION_HOME;\tbreak;\n", "\t\tcase '\\0': /* truncated escape sequence; get more */\n", "\t\t\tif (!block)\n", "\t\t\t\treturn ERROR_EMPTY;\n", "\t\t\tgoto again;\n", "\t\t}\n", "\t\tbreak;\n", "\n", "\tcase 'O':\n", "\t\tswitch (*(p += 2)) {\n", "\t\tcase 'H': key = FUNCTION_HOME;\tbreak;\n", "\t\tcase 'F': key = FUNCTION_END;\tbreak;\n", "\t\tcase 'P': key = FUNCTION_F(1);\tbreak;\n", "\t\tcase 'Q': key = FUNCTION_F(2);\tbreak;\n", "\t\tcase 'R': key = FUNCTION_F(3);\tbreak;\n", "\t\tcase 'S': key = FUNCTION_F(4);\tbreak;\n", "\t\t}\n", "\t\tbreak;\n", "\n", "\t/* Translate many Escape'd characters into Control */\n", "\tcase '@':\n", "\tcase ' ':\n", "\t\tkey = CONTROL('@');\n", "\t\tp++;\n", "\t\tgoto done; /* because ^@ == 0 */\n", "\tcase '\\\\':\n", "\tcase ']':\n", "\tcase '^':\n", "\tcase '_':\n", "\t\tkey = CONTROL(*++p);\n", "\t\tbreak;\n", "\tcase '/':\n", "\t\tkey = CONTROL('_');\n", "\t\tp++;\n", "\t\tbreak;\n", "\tcase '?':\n", "\t\tkey = '\\x7f';\n", "\t\tp++;\n", "\t\tbreak;\n", "\tcase '\\r':\n", "\t\tkey = '\\n';\n", "\t\tp++;\n", "\t\tbreak;\n", "\tcase ESCCHAR:\n", "\t\tmemmove(display->inbuf, p+2, display->inbuf_bytes -= 2);\n", "\t\tgoto again;\n", "\tcase '\\0': /* truncated escape sequence; get more */\n", "\t\tif (!block)\n", "\t\t\treturn ERROR_EMPTY;\n", "\t\tgoto again;\n", "\tdefault:\n", "\t\tif (p[1] < ' ')\n", "\t\t\tkey = *++p;  /* ignore Esc before control character */\n", "\t\telse if (p[1] >= 'a' && p[1] <= 'z')\n", "\t\t\tkey = CONTROL(*++p-'a'+'A');\n", "\t\telse if (p[1] >= 'A' && p[1] <= 'Z')\n", "\t\t\tkey = CONTROL(*++p);\n", "\t}\n", "\n", "\t/* If we couldn't translate an Escape sequence, return raw chars. */\n", "\tif (!key)\n", "\t\tkey = *(p = display->inbuf);\n", "\n", "done:\tused = ++p - display->inbuf;\n", "\tmemmove(display->inbuf, p, display->inbuf_bytes -= used);\n", "\tif (key == GOT_CURSORPOS) {\n", "\t\tif (display->get_initial_cursor_position == SOUGHT &&\n", "\t\t    val[0] > 0 && val[1] > 0) {\n", "\t\t\tdisplay->get_initial_cursor_position = KNOWN;\n", "\t\t\tdisplay->initial_row = val[0] - 1;\n", "\t\t\tdisplay->initial_column = val[1] - 1;\n", "\t\t} else\n", "\t\t\tset_geometry(display, val[0], val[1]);\n", "\t\tgoto again;\n", "\t}\n", "\treturn key;\n", "}\n"], "project": "aoeui", "file": "display.pkl", "function": "display_getch"}, {"comment_all": {"comment": "/* reversible moves from pieces. Output is a list of squares */", "depth": 0, "reading_ease": 100.24, "reading_grade": 0.5, "line": 330}, "comment_text": "/* reversible moves from pieces. Output is a list of squares */", "comment_tokens": ["reversible", "moves", "from", "pieces", ".", "Output", "is", "a", "list", "of", "squares"], "ccode": ["\t\n", "void \n", "tolist_rev (uint64_t occ, SQ_CONTENT input_piece, SQUARE sq, SQUARE *list)\n", "/* reversible moves from pieces. Output is a list of squares */\n", "{\n", "   \tint direction;\n", "   \tunsigned int pc;\n", "    int s;\n", "   \tint from;\n", "\tint step;\n", "\tconst int *steparr;\n", "\tbool_t slider;\n", "\tSQUARE us;\n", "\n", "    assert (sq < 64);\n", "\n", "\t/* i.e. no pawn allowed as input */\n", "\tassert (input_piece == KNIGHT || input_piece == BISHOP ||\n", "\t\t\tinput_piece == ROOK   || input_piece == QUEEN  || \n", "\t\t\tinput_piece == KING);\n", "\n", "   \tfrom = (int)map88(sq);\n", "   \t\n", "\tpc = input_piece & (PAWN|KNIGHT|BISHOP|ROOK|QUEEN|KING);\n", "\n", "\tsteparr = psteparr [pc];\n", "\tslider  = pslider  [pc];\n", "\n", "\tif (slider) {\n", "\t \t\n", "\t\tfor (direction = 0; steparr[direction] != 0; direction++) {\n", "\t\t\tstep = steparr[direction];\n", "\t\t\ts = from + step;\n", "\t\t\twhile (0 == (s & 0x88)) {\n", "\t\t\t\tus = (SQUARE)unmap88(s);\n", "\t\t\t\tif (0 != (0x1u & (unsigned int)(occ >> us)))\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t*list++ = us;\n", "\t\t\t\ts += step;\n", "  \t\t\t}\n", " \t\t}\n", "\n", "\t} else {\n", "\t\t\n", "\t\tfor (direction = 0; steparr[direction] != 0; direction++) {\n", "\t\t\tstep = steparr[direction];\n", "\t\t\ts = from + step;\n", "\t\t\tif (0 == (s & 0x88)) {\n", "\t\t\t\tus = (SQUARE)unmap88(s);\n", "\t\t\t\tif (0 == (0x1u & (unsigned int)(occ >> us))) {\n", "\t\t\t\t\t*list++ = us;\n", "\t\t\t\t}\n", "  \t\t\t}\n", " \t\t}\t\t\n", "\t}\n", "\n", "\t*list = NOSQUARE;\n", "\n", "   \treturn;\n", "}\t\n"], "project": "libgaviotatb-dev", "file": "gtb-att.pkl", "function": "tolist_rev"}, {"comment_all": {"comment": "/* End of ms_md2doy() */", "depth": 0, "reading_ease": 93.81, "reading_grade": 0.9, "line": 436}, "comment_text": "/* End of ms_md2doy() */", "comment_tokens": ["End", "of", "ms_md2doy", "(", ")"], "ccode": ["\n", "/***************************************************************************\n", " * ms_md2doy:\n", " *\n", " * Compute the day-of-year from a year, month and day-of-month.\n", " *\n", " * Year is expected to be in the range 1800-5000, month is expected to\n", " * be in the range 1-12, mday is expected to be in the range 1-31 and\n", " * jday will be in the range 1-366.\n", " *\n", " * Returns 0 on success and -1 on error.\n", " ***************************************************************************/\n", "int\n", "ms_md2doy (int year, int month, int mday, int *jday)\n", "{\n", "  int idx;\n", "  int leap;\n", "  int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n", "\n", "  /* Sanity check for the supplied parameters */\n", "  if (year < 1800 || year > 5000)\n", "  {\n", "    ms_log (2, \"ms_md2doy(): year (%d) is out of range\\n\", year);\n", "    return -1;\n", "  }\n", "  if (month < 1 || month > 12)\n", "  {\n", "    ms_log (2, \"ms_md2doy(): month (%d) is out of range\\n\", month);\n", "    return -1;\n", "  }\n", "  if (mday < 1 || mday > 31)\n", "  {\n", "    ms_log (2, \"ms_md2doy(): day-of-month (%d) is out of range\\n\", mday);\n", "    return -1;\n", "  }\n", "\n", "  /* Test for leap year */\n", "  leap = (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) ? 1 : 0;\n", "\n", "  /* Add a day to February if leap year */\n", "  if (leap)\n", "    days[1]++;\n", "\n", "  /* Check that the day-of-month jives with specified month */\n", "  if (mday > days[month - 1])\n", "  {\n", "    ms_log (2, \"ms_md2doy(): day-of-month (%d) is out of range for month %d\\n\",\n", "            mday, month);\n", "    return -1;\n", "  }\n", "\n", "  *jday = 0;\n", "  month--;\n", "\n", "  for (idx = 0; idx < 12; idx++)\n", "  {\n", "    if (idx == month)\n", "    {\n", "      *jday += mday;\n", "      break;\n", "    }\n", "\n", "    *jday += days[idx];\n", "  }\n", "\n", "  return 0;\n", "} /* End of ms_md2doy() */\n"], "project": "libmseed-doc", "file": "genutils.pkl", "function": "ms_md2doy"}, {"comment_all": {"comment": "/* Return symbols from the symbol table to libctf, one by one.  We assume (and\n   assert) that the symbols in the elf_link_hash_table are in strictly ascending\n   order, and that none will be added in between existing ones.  Returns NULL\n   when iteration is complete.  */", "depth": 0, "reading_ease": 65.73, "reading_grade": 7.6, "line": 133}, "comment_text": "/* Return symbols from the symbol table to libctf, one by one.  We assume (and\n   assert) that the symbols in the elf_link_hash_table are in strictly ascending\n   order, and that none will be added in between existing ones.  Returns NULL\n   when iteration is complete.  */", "comment_tokens": ["Return", "symbols", "from", "the", "symbol", "table", "to", "libctf", ",", "one", "by", "one", ".", "We", "assume", "(", "and", "assert", ")", "that", "the", "symbols", "in", "the", "elf_link_hash_table", "are", "in", "strictly", "ascending", "order", ",", "and", "that", "none", "will", "be", "added", "in", "between", "existing", "ones", ".", "Returns", "NULL", "when", "iteration", "is", "complete", "."], "ccode": ["\n", "/* Return symbols from the symbol table to libctf, one by one.  We assume (and\n", "   assert) that the symbols in the elf_link_hash_table are in strictly ascending\n", "   order, and that none will be added in between existing ones.  Returns NULL\n", "   when iteration is complete.  */\n", "\n", "static struct ctf_link_sym *\n", "ldelf_ctf_symbols_iter_cb (struct ctf_link_sym *dest,\n", "\t\t\t\t\t   void *arg_)\n", "{\n", "  struct ctf_strsym_iter_cb_arg *arg =\n", "    (struct ctf_strsym_iter_cb_arg *) arg_;\n", "\n", "  if (arg->next_i > arg->symcount)\n", "    {\n", "      arg->next_i = 0;\n", "      arg->next_idx = 0;\n", "      return NULL;\n", "    }\n", "\n", "  ASSERT (arg->syms[arg->next_i].dest_index == arg->next_idx);\n", "  dest->st_name = _bfd_elf_strtab_str (arg->symstrtab, arg->next_i, NULL);\n", "  dest->st_shndx = arg->syms[arg->next_i].sym.st_shndx;\n", "  dest->st_type = ELF_ST_TYPE (arg->syms[arg->next_i].sym.st_info);\n", "  dest->st_value = arg->syms[arg->next_i].sym.st_value;\n", "  arg->next_i++;\n", "  return dest;\n", "}\n"], "project": "binutils-powerpc64-linux-gnu-dbg", "file": "ldelfgen.pkl", "function": "ldelf_ctf_symbols_iter_cb"}, {"comment_all": {"comment": "/*\n\t\t * It doesn't hurt to compute qmember (a pointer to the\n\t\t * quantifier field of the structure), but the pointer is only\n\t\t * valid if the field is:\n\t\t *  - a repeated field, or\n\t\t *  - a field that is part of a oneof\n\t\t *  - an optional field that isn't a pointer type\n\t\t * (Meaning: not a message or a string).\n\t\t */", "depth": 2, "reading_ease": 35.62, "reading_grade": 21.2, "line": 1479}, "comment_text": "/*\n\t\t * It doesn't hurt to compute qmember (a pointer to the\n\t\t * quantifier field of the structure), but the pointer is only\n\t\t * valid if the field is:\n\t\t *  - a repeated field, or\n\t\t *  - a field that is part of a oneof\n\t\t *  - an optional field that isn't a pointer type\n\t\t * (Meaning: not a message or a string).\n\t\t */", "comment_tokens": ["It", "does", "n't", "hurt", "to", "compute", "qmember", "(", "a", "pointer", "to", "the", "quantifier", "field", "of", "the", "structure", ")", ",", "but", "the", "pointer", "is", "only", "valid", "if", "the", "field", "is", ":", "-", "a", "repeated", "field", ",", "or", "-", "a", "field", "that", "is", "part", "of", "a", "oneof", "-", "an", "optional", "field", "that", "is", "n't", "a", "pointer", "type", "(", "Meaning", ":", "not", "a", "message", "or", "a", "string", ")", "."], "ccode": ["\n", "/**@}*/\n", "\n", "size_t\n", "protobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)\n", "{\n", "\tunsigned i;\n", "\tsize_t rv = 0;\n", "\n", "\tASSERT_IS_MESSAGE(message);\n", "\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n", "\t\tconst ProtobufCFieldDescriptor *field =\n", "\t\t\tmessage->descriptor->fields + i;\n", "\t\tconst void *member = ((const char *) message) + field->offset;\n", "\n", "\t\t/*\n", "\t\t * It doesn't hurt to compute qmember (a pointer to the\n", "\t\t * quantifier field of the structure), but the pointer is only\n", "\t\t * valid if the field is:\n", "\t\t *  - a repeated field, or\n", "\t\t *  - a field that is part of a oneof\n", "\t\t *  - an optional field that isn't a pointer type\n", "\t\t * (Meaning: not a message or a string).\n", "\t\t */\n", "\t\tconst void *qmember =\n", "\t\t\t((const char *) message) + field->quantifier_offset;\n", "\n", "\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n", "\t\t\trv += required_field_pack(field, member, out + rv);\n", "\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n", "\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n", "\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n", "\t\t\trv += oneof_field_pack(\n", "\t\t\t\tfield,\n", "\t\t\t\t*(const uint32_t *) qmember,\n", "\t\t\t\tmember,\n", "\t\t\t\tout + rv\n", "\t\t\t);\n", "\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n", "\t\t\trv += optional_field_pack(\n", "\t\t\t\tfield,\n", "\t\t\t\t*(const protobuf_c_boolean *) qmember,\n", "\t\t\t\tmember,\n", "\t\t\t\tout + rv\n", "\t\t\t);\n", "\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n", "\t\t\trv += unlabeled_field_pack(field, member, out + rv);\n", "\t\t} else {\n", "\t\t\trv += repeated_field_pack(field, *(const size_t *) qmember,\n", "\t\t\t\tmember, out + rv);\n", "\t\t}\n", "\t}\n", "\tfor (i = 0; i < message->n_unknown_fields; i++)\n", "\t\trv += unknown_field_pack(&message->unknown_fields[i], out + rv);\n", "\treturn rv;\n", "}\n"], "project": "libprotobuf-c-dev", "file": "protobuf-c.pkl", "function": "protobuf_c_message_pack"}, {"comment_all": {"comment": "/* hmm...should have used avtab_map. */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 170}, "comment_text": "/* hmm...should have used avtab_map. */", "comment_tokens": ["hmm", "...", "should", "have", "used", "avtab_map", "."], "ccode": ["\n", "int display_avtab(avtab_t * a, uint32_t what, policydb_t * p, FILE * fp)\n", "{\n", "\tunsigned int i;\n", "\tavtab_ptr_t cur;\n", "\n", "\t/* hmm...should have used avtab_map. */\n", "\tfor (i = 0; i < a->nslot; i++) {\n", "\t\tfor (cur = a->htable[i]; cur; cur = cur->next) {\n", "\t\t\trender_av_rule(&cur->key, &cur->datum, what, p, fp);\n", "\t\t}\n", "\t}\n", "\tfprintf(fp, \"\\n\");\n", "\treturn 0;\n", "}\n"], "project": "checkpolicy", "file": "dispol.pkl", "function": "display_avtab"}, {"comment_all": {"comment": "/* FIXME: should this be entry->code or entry->name ? */", "depth": 3, "reading_ease": 81.29, "reading_grade": 3.7, "line": 195}, "comment_text": "/* FIXME: should this be entry->code or entry->name ? */", "comment_tokens": ["FIXME", ":", "should", "this", "be", "entry-", ">", "code", "or", "entry-", ">", "name", "?"], "ccode": ["\n", "static char ** \n", "aspell_provider_list_dicts (EnchantProvider * me _GL_UNUSED_PARAMETER, \n", "\t\t\t    size_t * out_n_dicts)\n", "{\n", "\tAspellConfig * spell_config = new_aspell_config ();\n", "\tAspellDictInfoList * dlist = get_aspell_dict_info_list (spell_config);\n", "\n", "\t*out_n_dicts = 0;\n", "\tAspellDictInfoEnumeration * dels = aspell_dict_info_list_elements (dlist);\n", "\n", "\t/* Note: aspell_dict_info_list_size() always returns zero: https://github.com/GNUAspell/aspell/issues/155 */\n", "\tconst AspellDictInfo * entry;\n", "\twhile ( (entry = aspell_dict_info_enumeration_next(dels)) != 0)\n", "\t\t(*out_n_dicts)++;\n", "\tdelete_aspell_dict_info_enumeration (dels);\n", "\n", "\tchar ** out_list = NULL;\n", "\n", "\tif (*out_n_dicts) {\n", "\t\tout_list = g_new0 (char *, *out_n_dicts + 1);\n", "\t\tdels = aspell_dict_info_list_elements (dlist);\n", "\t\t\n", "\t\tfor (size_t i = 0; i < *out_n_dicts; i++) {\n", "\t\t\tentry = aspell_dict_info_enumeration_next (dels);\t\t\t\n", "\t\t\t/* FIXME: should this be entry->code or entry->name ? */\n", "\t\t\tout_list[i] = g_strdup (entry->code);\n", "\t\t}\n", "\t\t\n", "\t\tdelete_aspell_dict_info_enumeration (dels);\n", "\t}\n", "\t\n", "\tdelete_aspell_config (spell_config);\n", "\t\n", "\treturn out_list;\n", "}\n"], "project": "libenchant-2-2", "file": "enchant_aspell.pkl", "function": "aspell_provider_list_dicts"}, {"comment_all": {"comment": "/* modify it under the terms of the GNU General Public License              */", "depth": 0, "reading_ease": 60.31, "reading_grade": 7.6, "line": 12}, "comment_text": "/* This program is free software; you can redistribute it and/or            */\n/* modify it under the terms of the GNU General Public License              */\n/* as published by the Free Software Foundation; either version 2           */\n/* of the License, or (at your option) any later version.                   */\n", "comment_tokens": ["This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", "."], "ccode": ["/****************************************************************************/\n", "/*                                                                          */\n", "/* ./gps/tm.c   -   Convert to selected datum                               */\n", "/*                                                                          */\n", "/* This file is part of gpstrans - a program to communicate with garmin gps */\n", "/* Parts are taken from John F. Waers (jfwaers@csn.net) program MacGPS.     */\n", "/*                                                                          */\n", "/*                                                                          */\n", "/*    Copyright (c) 1995 by Carsten Tschach (tschach@zedat.fu-berlin.de)    */\n", "/*                                                                          */\n", "/*                                                                          */\n", "/* This program is free software; you can redistribute it and/or            */\n", "/* modify it under the terms of the GNU General Public License              */\n", "/* as published by the Free Software Foundation; either version 2           */\n", "/* of the License, or (at your option) any later version.                   */\n", "/*                                                                          */\n", "/* This program is distributed in the hope that it will be useful,          */\n", "/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */\n", "/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */\n", "/* GNU General Public License for more details.                             */\n", "/*                                                                          */\n", "/* You should have received a copy of the GNU General Public License        */\n", "/* along with this program; if not, write to the Free Software              */\n", "/* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,   */\n", "/* USA.                                                                     */\n", "/****************************************************************************/\n", "\n", "#include \"defs.h\"\n", "#include \"Garmin.h\"\n", "#include \"Prefs.h\"\n", "#include <math.h>\n", "\n", "\n", "/****************************************************************************/\n", "/* Equations from \"Map Projections -- A Working Manual\", USGS Professional  */\n", "/* Paper 1395                                                               */\n", "/****************************************************************************/\n", "\n", "\n", "/* prototype function */\n", "static double M (double phi, double a, double es);\n", "\n", "\n", "/****************************************************************************/\n", "/* Convert latitude and longitude to converted position.                    */\n", "/****************************************************************************/\n", "void\n", "toTM (double lat, double lon, double lat0, double lon0, double k0,\n", "      double *x, double *y)\n", "{\n", "  extern struct PREFS gPrefs;\n", "  double m, et2, n, t, c, A, a, m0, es, lambda, phi, lambda0, phi0;\n", "\n", "  datumParams (gPrefs.datum, &a, &es);\n", "\n", "  lambda = lon * Degree;\n", "  phi = lat * Degree;\n", "\n", "  phi0 = lat0 * Degree;\n", "  lambda0 = lon0 * Degree;\n", "\n", "  m0 = M (phi0, a, es);\n", "  m = M (phi, a, es);\n", "\n", "  et2 = es / (1 - es);\n", "\n", "  n = a / sqrt (1 - es * pow (sin (phi), 2.0));\n", "  t = pow (tan (phi), 2.0);\n", "  c = et2 * pow (cos (phi), 2.0);\n", "  A = (lambda - lambda0) * cos (phi);\n", "  *x = k0 * n * (A + (1.0 - t + c) * A * A * A / 6.0\n", "\t\t + (5.0 - 18.0 * t + t * t + 72.0 * c - 58.0 * et2) * pow (A,\n", "\t\t\t\t\t\t\t\t\t   5.0)\n", "\t\t / 120.0);\n", "  *y =\n", "    k0 * (m - m0 +\n", "\t  n * tan (phi) * (A * A / 2.0 +\n", "\t\t\t   (5.0 - t + 9.0 * c + 4 * c * c) * pow (A,\n", "\t\t\t\t\t\t\t\t  4.0) /\n", "\t\t\t   24.0 + (61.0 - 58.0 * t + t * t + 600.0 * c -\n", "\t\t\t\t   330.0 * et2) * pow (A, 6.0) / 720.0));\n", "}\n"], "project": "gpstrans", "file": "tm.pkl", "function": "toTM"}, {"comment_all": {"comment": "/* unless you have a broken HP cc */", "depth": 1, "reading_ease": 89.75, "reading_grade": 2.5, "line": 107}, "comment_text": "/* just to illustrate the default really */\n/* unless you have a broken HP cc */\n/* keep the fortress secure by default */\n", "comment_tokens": ["just", "to", "illustrate", "the", "default", "really", "unless", "you", "have", "a", "broken", "HP", "cc", "keep", "the", "fortress", "secure", "by", "default"], "ccode": ["\n", "static void *create_auth_plain_dir_config(apr_pool_t *p, char *d)\n", "{\n", "    auth_plain_config_rec *conf = apr_palloc(p, sizeof(*conf));\n", "\n", "    conf->auth_pwfile = NULL;     /* just to illustrate the default really */\n", "    conf->auth_grpfile = NULL;    /* unless you have a broken HP cc */\n", "    conf->auth_authoritative = 1; /* keep the fortress secure by default */\n", "    return conf;\n", "}\n"], "project": "libapache2-mod-auth-plain", "file": "mod_auth_plain.pkl", "function": "create_auth_plain_dir_config"}, {"comment_all": {"comment": "/* make table gray (again) */", "depth": 1, "reading_ease": 92.8, "reading_grade": 1.3, "line": 676}, "comment_text": "/* make table gray (again) */", "comment_tokens": ["make", "table", "gray", "(", "again", ")"], "ccode": ["\n", "\n", "void luaC_barrierback (lua_State *L, Table *t) {\n", "  global_State *g = G(L);\n", "  GCObject *o = obj2gco(t);\n", "  lua_assert(isblack(o) && !isdead(g, o));\n", "  lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);\n", "  black2gray(o);  /* make table gray (again) */\n", "  t->gclist = g->grayagain;\n", "  g->grayagain = o;\n", "}\n"], "project": "infon-server", "file": "lgc.pkl", "function": "luaC_barrierback"}, {"comment_all": {"comment": "/* The canonical name cannot be determined.  */", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 255}, "comment_text": "/* The canonical name cannot be determined.  */", "comment_tokens": ["The", "canonical", "name", "can", "not", "be", "determined", "."], "ccode": ["\n", "/* Determine the current locale's character encoding, and canonicalize it\n", "   into one of the canonical names listed in config.charset.\n", "   The result must not be freed; it is statically allocated.\n", "   If the canonical name cannot be determined, the result is a non-canonical\n", "   name.  */\n", "\n", "#ifdef STATIC\n", "STATIC\n", "#endif\n", "const char *\n", "locale_charset ()\n", "{\n", "  const char *codeset;\n", "  const char *aliases;\n", "\n", "#ifndef WIN32\n", "\n", "# if HAVE_LANGINFO_CODESET\n", "\n", "  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n", "  codeset = nl_langinfo (CODESET);\n", "\n", "# else\n", "\n", "  /* On old systems which lack it, use setlocale or getenv.  */\n", "  const char *locale = NULL;\n", "\n", "  /* But most old systems don't have a complete set of locales.  Some\n", "     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n", "     use setlocale here; it would return \"C\" when it doesn't support the\n", "     locale name the user has set.  */\n", "#  if HAVE_SETLOCALE && 0\n", "  locale = setlocale (LC_CTYPE, NULL);\n", "#  endif\n", "  if (locale == NULL || locale[0] == '\\0')\n", "    {\n", "      locale = getenv (\"LC_ALL\");\n", "      if (locale == NULL || locale[0] == '\\0')\n", "\t{\n", "\t  locale = getenv (\"LC_CTYPE\");\n", "\t  if (locale == NULL || locale[0] == '\\0')\n", "\t    locale = getenv (\"LANG\");\n", "\t}\n", "    }\n", "\n", "  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n", "     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n", "     through the charset.alias file.  */\n", "  codeset = locale;\n", "\n", "# endif\n", "\n", "#else /* WIN32 */\n", "\n", "  static char buf[2 + 10 + 1];\n", "\n", "  /* Win32 has a function returning the locale's codepage as a number.  */\n", "  sprintf (buf, \"CP%u\", GetACP ());\n", "  codeset = buf;\n", "\n", "#endif\n", "\n", "  if (codeset == NULL)\n", "    /* The canonical name cannot be determined.  */\n", "    codeset = \"\";\n", "\n", "  /* Resolve alias. */\n", "  for (aliases = get_charset_aliases ();\n", "       *aliases != '\\0';\n", "       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n", "    if (strcmp (codeset, aliases) == 0\n", "\t|| (aliases[0] == '*' && aliases[1] == '\\0'))\n", "      {\n", "\tcodeset = aliases + strlen (aliases) + 1;\n", "\tbreak;\n", "      }\n", "\n", "  return codeset;\n", "}\n"], "project": "libgtk2-gst", "file": "localcharset.pkl", "function": "locale_charset"}, {"comment_all": {"comment": "/* Note: 'pwd' will be used via pointer 'p' on getpwuid_r success. */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 148}, "comment_text": "/* Note: 'pwd' will be used via pointer 'p' on getpwuid_r success. */", "comment_tokens": ["Note", ":", "'pwd", "'", "will", "be", "used", "via", "pointer", "'", "p", "'", "on", "getpwuid_r", "success", "."], "ccode": ["\n", "/*[clinic input]\n", "pwd.getpwuid\n", "\n", "    uidobj: object\n", "    /\n", "\n", "Return the password database entry for the given numeric user ID.\n", "\n", "See `help(pwd)` for more on password database entries.\n", "[clinic start generated code]*/\n", "\n", "static PyObject *\n", "pwd_getpwuid(PyObject *module, PyObject *uidobj)\n", "/*[clinic end generated code: output=c4ee1d4d429b86c4 input=ae64d507a1c6d3e8]*/\n", "{\n", "    PyObject *retval = NULL;\n", "    uid_t uid;\n", "    int nomem = 0;\n", "    struct passwd *p;\n", "    char *buf = NULL, *buf2 = NULL;\n", "\n", "    if (!_Py_Uid_Converter(uidobj, &uid)) {\n", "        if (PyErr_ExceptionMatches(PyExc_OverflowError))\n", "            PyErr_Format(PyExc_KeyError,\n", "                         \"getpwuid(): uid not found\");\n", "        return NULL;\n", "    }\n", "#ifdef HAVE_GETPWUID_R\n", "    int status;\n", "    Py_ssize_t bufsize;\n", "    /* Note: 'pwd' will be used via pointer 'p' on getpwuid_r success. */\n", "    struct passwd pwd;\n", "\n", "    Py_BEGIN_ALLOW_THREADS\n", "    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n", "    if (bufsize == -1) {\n", "        bufsize = DEFAULT_BUFFER_SIZE;\n", "    }\n", "\n", "    while(1) {\n", "        buf2 = PyMem_RawRealloc(buf, bufsize);\n", "        if (buf2 == NULL) {\n", "            p = NULL;\n", "            nomem = 1;\n", "            break;\n", "        }\n", "        buf = buf2;\n", "        status = getpwuid_r(uid, &pwd, buf, bufsize, &p);\n", "        if (status != 0) {\n", "            p = NULL;\n", "        }\n", "        if (p != NULL || status != ERANGE) {\n", "            break;\n", "        }\n", "        if (bufsize > (PY_SSIZE_T_MAX >> 1)) {\n", "            nomem = 1;\n", "            break;\n", "        }\n", "        bufsize <<= 1;\n", "    }\n", "\n", "    Py_END_ALLOW_THREADS\n", "#else\n", "    p = getpwuid(uid);\n", "#endif\n", "    if (p == NULL) {\n", "        PyMem_RawFree(buf);\n", "        if (nomem == 1) {\n", "            return PyErr_NoMemory();\n", "        }\n", "        PyObject *uid_obj = _PyLong_FromUid(uid);\n", "        if (uid_obj == NULL)\n", "            return NULL;\n", "        PyErr_Format(PyExc_KeyError,\n", "                     \"getpwuid(): uid not found: %S\", uid_obj);\n", "        Py_DECREF(uid_obj);\n", "        return NULL;\n", "    }\n", "    retval = mkpwent(p);\n", "#ifdef HAVE_GETPWUID_R\n", "    PyMem_RawFree(buf);\n", "#endif\n", "    return retval;\n", "}\n"], "project": "libpython3.9", "file": "pwdmodule.pkl", "function": "pwd_getpwuid"}, {"comment_all": {"comment": "/* Copy context->state[] to working vars */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 161}, "comment_text": "/* Copy context->state[] to working vars */", "comment_tokens": ["Copy", "context-", ">", "state", "[", "]", "to", "working", "vars"], "ccode": ["\n", "\n", "static void SHA1Transform(u32 state[5], const unsigned char buffer[64]);\n", "static void SHA1Init(SHA1Context* context);\n", "static void SHA1Update(SHA1Context* context, const unsigned char* data, size_t len);\t/* JHB */\n", "static void SHA1Final(SHA1Context* context);\n", "\n", "\n", "#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n", "\n", "/* blk0() and blk() perform the initial expand. */\n", "/* I got the idea of expanding during the round function from SSLeay */\n", "#ifdef WORDS_BIGENDIAN\n", "#define blk0(i) block->l[i]\n", "#else\n", "#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \\\n", "    |(rol(block->l[i],8)&0x00FF00FF))\n", "#endif\n", "#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n", "    ^block->l[(i+2)&15]^block->l[i&15],1))\n", "\n", "\n", "/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */\n", "#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);\n", "#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n", "#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n", "#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n", "#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n", "\n", "\n", "/* Hash a single 512-bit block. This is the core of the algorithm. */\n", "\n", "static void\n", "SHA1Transform(u32 state[5], const unsigned char buffer[64])\n", "{\n", "  u32 a, b, c, d, e;\n", "  typedef union {\n", "    unsigned char c[64];\n", "    u32 l[16];\n", "  } CHAR64LONG16;\n", "  CHAR64LONG16* block;\n", "#ifdef SHA1HANDSOFF\n", "  static unsigned char workspace[64];\n", "  block = (CHAR64LONG16*)workspace;\n", "  memcpy(block, buffer, 64);\n", "#else\n", "  block = (CHAR64LONG16*)buffer;\n", "#endif\n", "\n", "  /* Copy context->state[] to working vars */\n", "  a = state[0];\n", "  b = state[1];\n", "  c = state[2];\n", "  d = state[3];\n", "  e = state[4];\n", "\n", "  /* 4 rounds of 20 operations each. Loop unrolled. */\n", "  R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n", "  R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n", "  R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n", "  R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n", "  R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n", "  R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n", "  R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n", "  R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n", "  R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n", "  R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n", "  R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n", "  R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n", "  R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n", "  R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n", "  R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n", "  R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n", "  R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n", "  R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n", "  R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n", "  R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n", "  \n", "  /* Add the working vars back into context.state[] */\n", "  state[0] += a;\n", "  state[1] += b;\n", "  state[2] += c;\n", "  state[3] += d;\n", "  state[4] += e;\n", "  /* Wipe variables */\n", "  /* a = b = c = d = e = 0; */ /* CLANG: useless */\n", "}\n"], "project": "libflickcurl0-dbg", "file": "sha1.pkl", "function": "SHA1Transform"}, {"comment_all": {"comment": "/* A function called through the vtable when a particular module\n   should be unloaded.  */", "depth": 0, "reading_ease": 66.74, "reading_grade": 7.2, "line": 244}, "comment_text": "/* A function called through the vtable when a particular module\n   should be unloaded.  */", "comment_tokens": ["A", "function", "called", "through", "the", "vtable", "when", "a", "particular", "module", "should", "be", "unloaded", "."], "ccode": ["\n", "\n", "/* A function called through the vtable when a particular module\n", "   should be unloaded.  */\n", "static int\n", "vm_close (lt_user_data loader_data LT__UNUSED, lt_module module)\n", "{\n", "  int errors = 0;\n", "\n", "  if (dlclose (module) != 0)\n", "    {\n", "      DL__SETERROR (CANNOT_CLOSE);\n", "      ++errors;\n", "    }\n", "\n", "  return errors;\n", "}\n"], "project": "libltdl7", "file": "dlopen.pkl", "function": "vm_close"}, {"comment_all": {"comment": "/* This should not be necessary, but its there for now to\n             * avoid null termination issues in libpm. */", "depth": 4, "reading_ease": 71.14, "reading_grade": 7.6, "line": 1588}, "comment_text": "/* This should not be necessary, but its there for now to\n             * avoid null termination issues in libpm. */", "comment_tokens": ["This", "should", "not", "be", "necessary", ",", "but", "its", "there", "for", "now", "to", "avoid", "null", "termination", "issues", "in", "libpm", "."], "ccode": ["\n", "static void * encode_v2(CdoSequence * seq, size_t * sizep, uint32_t be) {\n", "    LINK * l = seq->cmds.next;\n", "    uint32_t hdrlen = 4;\n", "    uint32_t pos = hdrlen + 1;\n", "    uint32_t * p = grow_cdobuf(pos);\n", "    p[0] = u32xe(pos - 1);\n", "    p[1] = u32xe(0x004F4443);\n", "    p[2] = u32xe(seq->version);\n", "    while (l != &seq->cmds) {\n", "        CdoCommand * cmd = all2cmds(l);\n", "        l = l->next;\n", "        switch (cmd->type) {\n", "#if 0\n", "        case CdoCmdSetBaseAddress:\n", "            fprintf(f, \"set_base_address \");\n", "            print_x64(f, cmd->dstaddr);\n", "            fprintf(f, \"\\n\");\n", "            break;\n", "#endif\n", "        case CdoCmdGeneric:\n", "            hdr2(&p, &pos, cmd->id, cmd->count, be);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdComment:\n", "            break;\n", "        case CdoCmdWrite:\n", "            if (cmd->count == 1) {\n", "                if ((cmd->dstaddr >> 32) == 0) {\n", "                    hdr2(&p, &pos, CMD2_WRITE, 2, be);\n", "                    p[pos++] = u32xe_lo(cmd->dstaddr);\n", "                } else {\n", "                    hdr2(&p, &pos, CMD2_WRITE64, 3, be);\n", "                    p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                    p[pos++] = u32xe_lo(cmd->dstaddr);\n", "                }\n", "            } else {\n", "                uint32_t padding = 0;\n", "                uint32_t pos_save = pos;\n", "                do {\n", "                    assert(padding < 4);\n", "                    if (padding) {\n", "                        hdr2(&p, &pos, CMD2_NOP, padding - 1, be);\n", "                        memset(p + pos, 0, (padding - 1)*4);\n", "                        pos += padding - 1;\n", "                    }\n", "                    hdr2(&p, &pos, CMD2_DMA_WRITE, 2 + cmd->count, be);\n", "                    p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                    p[pos++] = u32xe_lo(cmd->dstaddr);\n", "                    if (!auto_align) break;\n", "                    if ((pos & 3) == ((cmd->dstaddr >> 2) & 3)) break;\n", "                    padding++;\n", "                    pos = pos_save;\n", "                } while (1);\n", "            }\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdWriteKeyhole: {\n", "            uint32_t padding = 0;\n", "            uint32_t pos_save = pos;\n", "            do {\n", "                assert(padding < 4);\n", "                if (padding) {\n", "                    hdr2(&p, &pos, CMD2_NOP, padding - 1, be);\n", "                    memset(p + pos, 0, (padding - 1)*4);\n", "                    pos += padding - 1;\n", "                }\n", "                hdr2(&p, &pos, CMD2_DMA_WRITE_KEYHOLE, 3 + cmd->count, be);\n", "                p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "                p[pos++] = u32xe(cmd->value);\n", "                if (!auto_align) break;\n", "                if ((pos & 3) == ((cmd->dstaddr >> 2) & 3)) break;\n", "                padding++;\n", "                pos = pos_save;\n", "            } while (1);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        }\n", "        case CdoCmdSetBlock:\n", "            hdr2(&p, &pos, CMD2_SET, 4, be);\n", "            p[pos++] = u32xe_hi(cmd->dstaddr);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdMaskWrite:\n", "            if ((cmd->dstaddr >> 32) == 0) {\n", "                hdr2(&p, &pos, CMD2_MASK_WRITE, 3, be);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            } else {\n", "                hdr2(&p, &pos, CMD2_MASK_WRITE64, 4, be);\n", "                p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            }\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdMaskPoll: {\n", "            uint32_t has_flags = cmd->flags != 0;\n", "            if ((cmd->dstaddr >> 32) == 0) {\n", "                hdr2(&p, &pos, CMD2_MASK_POLL, has_flags ? 5 : 4, be);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            } else {\n", "                hdr2(&p, &pos, CMD2_MASK_POLL64, has_flags ? 6 : 5, be);\n", "                p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            }\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->count);\n", "            if (has_flags) {\n", "                p[pos++] = u32xe(cmd->flags);\n", "            }\n", "            break;\n", "        }\n", "#if 0\n", "        case CdoCmdMaskPollEq:\n", "            fprintf(f, \"mask_poll_eq \");\n", "            print_x64(f, cmd->dstaddr);\n", "            fprintf(f, \" \");\n", "            print_x64(f, cmd->mask);\n", "            fprintf(f, \" \");\n", "            print_x64(f, cmd->value);\n", "            fprintf(f, \"\\n\");\n", "            break;\n", "#endif\n", "        case CdoCmdDelay:\n", "            hdr2(&p, &pos, CMD2_DELAY, 1, be);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdDmaXfer:\n", "            hdr2(&p, &pos, CMD2_DMA_XFER, 6, be);\n", "            p[pos++] = u32xe_hi(cmd->srcaddr);\n", "            p[pos++] = u32xe_lo(cmd->srcaddr);\n", "            p[pos++] = u32xe_hi(cmd->dstaddr);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCframeRead: {\n", "            uint32_t padding = 0;\n", "            uint32_t pos_save = pos;\n", "            do {\n", "                assert(padding < 4);\n", "                if (padding) {\n", "                    hdr2(&p, &pos, CMD2_NOP, padding - 1, be);\n", "                    memset(p + pos, 0, (padding - 1)*4);\n", "                    pos += padding - 1;\n", "                }\n", "                hdr2(&p, &pos, CMD2_CFRAME_READ, 4 + cmd->count, be);\n", "                p[pos++] = u32xe(cmd->flags);\n", "                p[pos++] = u32xe_hi(cmd->dstaddr);\n", "                p[pos++] = u32xe_lo(cmd->dstaddr);\n", "                p[pos++] = u32xe(cmd->value);\n", "                if (!auto_align) break;\n", "                if ((pos & 3) == 0) break;\n", "                padding++;\n", "                pos = pos_save;\n", "            } while (1);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        }\n", "        case CdoCmdSsitSyncMaster:\n", "            hdr2(&p, &pos, CMD2_SSIT_SYNC_MASTER, 0, be);\n", "            break;\n", "        case CdoCmdSsitSyncSlaves:\n", "            hdr2(&p, &pos, CMD2_SSIT_SYNC_SLAVES, 2, be);\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->count);\n", "            break;\n", "        case CdoCmdSsitWaitSlaves:\n", "            hdr2(&p, &pos, CMD2_SSIT_WAIT_SLAVES, 2, be);\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->count);\n", "            break;\n", "        case CdoCmdNop:\n", "            hdr2(&p, &pos, CMD2_NOP, cmd->count, be);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdEventLogging:\n", "            hdr2(&p, &pos, CMD2_EVENT_LOGGING, 1 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->value);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdSetBoard: {\n", "            uint32_t len = strlen((char *)cmd->buf);\n", "            uint32_t count = (len + 3)/4;\n", "            hdr2(&p, &pos, CMD2_SET_BOARD, count, be);\n", "            memset(p + pos, 0, count*4);\n", "            memcpy(p + pos, cmd->buf, len);\n", "            byte_swap_buffer(p + pos, count, be);\n", "            pos += count;\n", "            break;\n", "        }\n", "        case CdoCmdSetPlmWdt:\n", "            hdr2(&p, &pos, CMD2_SET_PLM_WDT, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdNpiSeq:\n", "            hdr2(&p, &pos, CMD2_NPI_SEQ, 2, be);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdNpiPreCfg:\n", "            hdr2(&p, &pos, CMD2_NPI_PRECFG, 2, be);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdNpiWrite:\n", "            hdr2(&p, &pos, CMD2_NPI_WRITE, 2 + cmd->count, be);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdNpiShutdown:\n", "            hdr2(&p, &pos, CMD2_NPI_SHUTDN, 2, be);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "\n", "        case CdoCmdPmGetApiVersion:\n", "            hdr2(&p, &pos, CMD2_PM_GET_API_VERSION, 0, be);\n", "            break;\n", "        case CdoCmdPmGetDeviceStatus:\n", "            hdr2(&p, &pos, CMD2_PM_GET_DEVICE_STATUS, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmRegisterNotifier:\n", "            hdr2(&p, &pos, CMD2_PM_REGISTER_NOTIFIER, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->count);\n", "            break;\n", "        case CdoCmdPmRequestSuspend:\n", "            hdr2(&p, &pos, CMD2_PM_REQUEST_SUSPEND, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmSelfSuspend:\n", "            hdr2(&p, &pos, CMD2_PM_SELF_SUSPEND, 5, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe_hi(cmd->dstaddr);\n", "            break;\n", "        case CdoCmdPmForcePowerdown:\n", "            hdr2(&p, &pos, CMD2_PM_FORCE_POWERDOWN, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmAbortSuspend:\n", "            hdr2(&p, &pos, CMD2_PM_ABORT_SUSPEND, 2, be);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmRequestWakeup:\n", "            hdr2(&p, &pos, CMD2_PM_REQUEST_WAKEUP, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe_lo(cmd->dstaddr);\n", "            p[pos++] = u32xe_hi(cmd->dstaddr);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmSetWakeupSource:\n", "            hdr2(&p, &pos, CMD2_PM_SET_WAKEUP_SOURCE, 3, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmSystemShutdown:\n", "            hdr2(&p, &pos, CMD2_PM_SYSTEM_SHUTDOWN, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmRequestDevice:\n", "            hdr2(&p, &pos, CMD2_PM_REQUEST_DEVICE, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmReleaseDevice:\n", "            hdr2(&p, &pos, CMD2_PM_RELEASE_DEVICE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmSetRequirement:\n", "            hdr2(&p, &pos, CMD2_PM_SET_REQUIREMENT, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->count);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmSetMaxLatency:\n", "            hdr2(&p, &pos, CMD2_PM_SET_MAX_LATENCY, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->count);\n", "            break;\n", "        case CdoCmdPmResetAssert:\n", "            hdr2(&p, &pos, CMD2_PM_RESET_ASSERT, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmResetGetStatus:\n", "            hdr2(&p, &pos, CMD2_PM_RESET_GET_STATUS, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmPinctrlRequest:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_REQUEST, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmPinctrlRelease:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_RELEASE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmPinctrlGetFunction:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_GET_FUNCTION, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmPinctrlSetFunction:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_SET_FUNCTION, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmPinctrlConfigParamGet:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_CONFIG_PARAM_GET, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmPinctrlConfigParamSet:\n", "            hdr2(&p, &pos, CMD2_PM_PINCTRL_CONFIG_PARAM_SET, 3, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmIoctl:\n", "            hdr2(&p, &pos, CMD2_PM_IOCTL, 2 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmQueryData:\n", "            hdr2(&p, &pos, CMD2_PM_QUERY_DATA, 1 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmClockEnable:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_ENABLE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmClockDisable:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_DISABLE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmClockGetState:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_GETSTATE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmClockSetDivider:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_SETDIVIDER, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmClockGetDivider:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_GETDIVIDER, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmClockSetRate:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_SETRATE, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmClockGetRate:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_GETRATE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmClockSetParent:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_SETPARENT, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmClockGetParent:\n", "            hdr2(&p, &pos, CMD2_PM_CLOCK_GETPARENT, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmPllSetParameter:\n", "            hdr2(&p, &pos, CMD2_PM_PLL_SET_PARAMETER, 3, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmPllGetParameter:\n", "            hdr2(&p, &pos, CMD2_PM_PLL_GET_PARAMETER, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdPmPllSetMode:\n", "            hdr2(&p, &pos, CMD2_PM_PLL_SET_MODE, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdPmPllGetMode:\n", "            hdr2(&p, &pos, CMD2_PM_PLL_GET_MODE, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmAddSubsystem:\n", "            hdr2(&p, &pos, CMD2_PM_ADD_SUBSYSTEM, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmDestroySubsystem:\n", "            hdr2(&p, &pos, CMD2_PM_DESTROY_SUBSYSTEM, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmDescribeNodes:\n", "            hdr2(&p, &pos, CMD2_PM_DESCRIBE_NODES, 0 + cmd->count, be);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "\n", "        case CdoCmdPmAddNode:\n", "            hdr2(&p, &pos, CMD2_PM_ADD_NODE, 1 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmAddNodeParent:\n", "            hdr2(&p, &pos, CMD2_PM_ADD_NODE_PARENT, 1 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmAddNodeName: {\n", "            uint32_t len = strlen((char *)cmd->buf);\n", "            uint32_t count = (len + 3)/4;\n", "            /* This should not be necessary, but its there for now to\n", "             * avoid null termination issues in libpm. */\n", "            if (count < 4) count = 4;\n", "            hdr2(&p, &pos, CMD2_PM_ADD_NODE_NAME, 1 + count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            memset(p + pos, 0, count*4);\n", "            memcpy(p + pos, cmd->buf, len);\n", "            byte_swap_buffer(p + pos, count, be);\n", "            pos += count;\n", "            break;\n", "        }\n", "        case CdoCmdPmAddRequirement:\n", "            hdr2(&p, &pos, CMD2_PM_ADD_REQUIREMENT, 3 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmSetCurrentSubsystem:\n", "            hdr2(&p, &pos, CMD2_PM_SET_CURRENT_SUBSYSTEM, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmInitNode:\n", "            hdr2(&p, &pos, CMD2_PM_INIT_NODE, 2 + cmd->count, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            memcpy(p + pos, cmd->buf, cmd->count * sizeof(uint32_t));\n", "            byte_swap_buffer(p + pos, cmd->count, be);\n", "            pos += cmd->count;\n", "            break;\n", "        case CdoCmdPmFeatureCheck:\n", "            hdr2(&p, &pos, CMD2_PM_FEATURE_CHECK, 1, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            break;\n", "        case CdoCmdPmIsoControl:\n", "            hdr2(&p, &pos, CMD2_PM_ISO_CONTROL, 2, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdCfuSetCrc32:\n", "            if (cmd->flags != 0) {\n", "                hdr2(&p, &pos, CMD2_CFU_SET_CRC32, 2, be);\n", "                p[pos++] = u32xe(cmd->flags);\n", "                p[pos++] = u32xe(cmd->value);\n", "            } else {\n", "                hdr2(&p, &pos, CMD2_CFU_SET_CRC32, 1, be);\n", "                p[pos++] = u32xe(cmd->flags);\n", "            }\n", "            break;\n", "        case CdoCmdCfuDecompress:\n", "            hdr2(&p, &pos, CMD2_CFU_DECOMPRESS, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuCramRW:\n", "            hdr2(&p, &pos, CMD2_CFU_CRAM_RW, 1, be);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdCfuSeuGo:\n", "            hdr2(&p, &pos, CMD2_CFU_SEU_GO, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuCrc8Dis:\n", "            hdr2(&p, &pos, CMD2_CFU_CRC8_DIS, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuSsiPerSlrPr:\n", "            hdr2(&p, &pos, CMD2_CFU_SSI_PER_SLR_PR, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuGsrGsc:\n", "            hdr2(&p, &pos, CMD2_CFU_GSR_GSC, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuGcapClkEn:\n", "            hdr2(&p, &pos, CMD2_CFU_GCAP_CLK_EN, 1, be);\n", "            p[pos++] = u32xe(cmd->flags);\n", "            break;\n", "        case CdoCmdCfuCfiType:\n", "            hdr2(&p, &pos, CMD2_CFU_CFI_TYPE, 1, be);\n", "            p[pos++] = u32xe(cmd->value);\n", "            break;\n", "        case CdoCmdEmSetAction:\n", "            hdr2(&p, &pos, CMD2_EM_SET_ACTION, 3, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->mask);\n", "            break;\n", "        case CdoCmdLdrSetImageInfo:\n", "            hdr2(&p, &pos, CMD2_LDR_SET_IMAGE_INFO, 4, be);\n", "            p[pos++] = u32xe(cmd->id);\n", "            p[pos++] = u32xe(cmd->value);\n", "            p[pos++] = u32xe(cmd->mask);\n", "            p[pos++] = u32xe(cmd->count);\n", "            break;\n", "        default:\n", "            fprintf(stderr, \"unknown command (%u)\\n\", cmd->type);\n", "            break;\n", "        }\n", "    }\n", "    p[3] = u32xe(pos - hdrlen - 1);\n", "    p[4] = u32xe(checksum32(p, hdrlen, be));\n", "    clear_cdobuf();\n", "    *sizep = pos*4;\n", "    return p;\n", "}\n"], "project": "bootgen-xlnx", "file": "cdo-binary.pkl", "function": "encode_v2"}, {"comment_all": {"comment": "/*\n\tblocks signals for critical section\n*/", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 39}, "comment_text": "/*\n\tblocks signals for critical section\n*/", "comment_tokens": ["blocks", "signals", "for", "critical", "section"], "ccode": ["\n", "void start_critical_section(void) {\n", "/*\n", "\tblocks signals for critical section\n", "*/\n", "\tsigprocmask(SIG_BLOCK, &blocked_signals_set, NULL);\n", "}\n"], "project": "fatsort", "file": "signal.pkl", "function": "start_critical_section"}, {"comment_all": {"comment": "/****************************************************************************\n * Copyright 2020 Thomas E. Dickey                                          *\n * Copyright 1998-2004,2010 Free Software Foundation, Inc.                  *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/", "depth": 0, "reading_ease": 35.75, "reading_grade": 17.0, "line": 0}, "comment_text": "/****************************************************************************\n * Copyright 2020 Thomas E. Dickey                                          *\n * Copyright 1998-2004,2010 Free Software Foundation, Inc.                  *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/", "comment_tokens": ["Copyright", "2020", "Thomas", "E.", "Dickey", "Copyright", "1998-2004,2010", "Free", "Software", "Foundation", ",", "Inc", ".", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "distribute", "with", "modifications", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "ABOVE", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", ".", "Except", "as", "contained", "in", "this", "notice", ",", "the", "name", "(", "s", ")", "of", "the", "above", "copyright", "holders", "shall", "not", "be", "used", "in", "advertising", "or", "otherwise", "to", "promote", "the", "sale", ",", "use", "or", "other", "dealings", "in", "this", "Software", "without", "prior", "written", "authorization", "."], "ccode": ["/****************************************************************************\n", " * Copyright 2020 Thomas E. Dickey                                          *\n", " * Copyright 1998-2004,2010 Free Software Foundation, Inc.                  *\n", " *                                                                          *\n", " * Permission is hereby granted, free of charge, to any person obtaining a  *\n", " * copy of this software and associated documentation files (the            *\n", " * \"Software\"), to deal in the Software without restriction, including      *\n", " * without limitation the rights to use, copy, modify, merge, publish,      *\n", " * distribute, distribute with modifications, sublicense, and/or sell       *\n", " * copies of the Software, and to permit persons to whom the Software is    *\n", " * furnished to do so, subject to the following conditions:                 *\n", " *                                                                          *\n", " * The above copyright notice and this permission notice shall be included  *\n", " * in all copies or substantial portions of the Software.                   *\n", " *                                                                          *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n", " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n", " * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n", " * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n", " * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n", " * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n", " *                                                                          *\n", " * Except as contained in this notice, the name(s) of the above copyright   *\n", " * holders shall not be used in advertising or otherwise to promote the     *\n", " * sale, use or other dealings in this Software without prior written       *\n", " * authorization.                                                           *\n", " ****************************************************************************/\n", "\n", "/****************************************************************************\n", " *   Author:  Juergen Pfeifer, 1995,1997                                    *\n", " ****************************************************************************/\n", "\n", "#include \"form.priv.h\"\n", "\n", "MODULE_ID(\"$Id: fld_type.c,v 1.17 2020/02/02 23:34:34 tom Exp $\")\n", "\n", "/*---------------------------------------------------------------------------\n", "|   Facility      :  libnform  \n", "|   Function      :  int set_field_type(FIELD *field, FIELDTYPE *type,...)\n", "|   \n", "|   Description   :  Associate the specified fieldtype with the field.\n", "|                    Certain field types take additional arguments. Look\n", "|                    at the spec of the field types !\n", "|\n", "|   Return Values :  E_OK           - success\n", "|                    E_SYSTEM_ERROR - system error\n", "+--------------------------------------------------------------------------*/\n", "NCURSES_EXPORT(int)\n", "set_field_type(FIELD *field, FIELDTYPE *type,...)\n", "{\n", "  va_list ap;\n", "  int res = E_SYSTEM_ERROR;\n", "  int err = 0;\n", "\n", "  T((T_CALLED(\"set_field_type(%p,%p)\"), (void *)field, (void *)type));\n", "\n", "  va_start(ap, type);\n", "\n", "  Normalize_Field(field);\n", "  _nc_Free_Type(field);\n", "\n", "  field->type = type;\n", "  field->arg = (void *)_nc_Make_Argument(field->type, &ap, &err);\n", "\n", "  if (err)\n", "    {\n", "      _nc_Free_Argument(field->type, (TypeArgument *)(field->arg));\n", "      field->type = (FIELDTYPE *)0;\n", "      field->arg = (void *)0;\n", "    }\n", "  else\n", "    {\n", "      res = E_OK;\n", "      if (field->type)\n", "\tfield->type->ref++;\n", "    }\n", "\n", "  va_end(ap);\n", "  RETURN(res);\n", "}\n"], "project": "libtinfo5", "file": "fld_type.pkl", "function": "set_field_type"}, {"comment_all": {"comment": "/* Flush out information for old buffer. */", "depth": 2, "reading_ease": 56.93, "reading_grade": 6.8, "line": 3742}, "comment_text": "/* Flush out information for old buffer. */", "comment_tokens": ["Flush", "out", "information", "for", "old", "buffer", "."], "ccode": ["\n", "/** Pushes the new state onto the stack. The new state becomes\n", " *  the current state. This function will allocate the stack\n", " *  if necessary.\n", " *  @param new_buffer The new state.\n", " *  \n", " */\n", "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n", "{\n", "    \tif (new_buffer == NULL)\n", "\t\treturn;\n", "\n", "\tyyensure_buffer_stack();\n", "\n", "\t/* This block is copied from yy_switch_to_buffer. */\n", "\tif ( YY_CURRENT_BUFFER )\n", "\t\t{\n", "\t\t/* Flush out information for old buffer. */\n", "\t\t*(yy_c_buf_p) = (yy_hold_char);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\t/* Only push if top exists. Otherwise, replace top. */\n", "\tif (YY_CURRENT_BUFFER)\n", "\t\t(yy_buffer_stack_top)++;\n", "\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n", "\n", "\t/* copied from yy_switch_to_buffer. */\n", "\tyy_load_buffer_state(  );\n", "\t(yy_did_buffer_switch_on_eof) = 1;\n", "}\n"], "project": "linux-aws-5.11-headers-5.11.0-1027", "file": "lexer.lex.pkl", "function": "yypush_buffer_state"}, {"comment_all": {"comment": "/* Because it may fail, the move must occur out-of-place and then be copied\n     * back over the affected files once success is assured */", "depth": 2, "reading_ease": 66.07, "reading_grade": 9.5, "line": 45}, "comment_text": "/* Because it may fail, the move must occur out-of-place and then be copied\n     * back over the affected files once success is assured */", "comment_tokens": ["Because", "it", "may", "fail", ",", "the", "move", "must", "occur", "out-of-place", "and", "then", "be", "copied", "back", "over", "the", "affected", "files", "once", "success", "is", "assured"], "ccode": ["/* Copyright (C) 2008-2016 D. V. Wiebe\n", " *\n", " ***************************************************************************\n", " *\n", " * This file is part of the GetData project.\n", " *\n", " * GetData is free software; you can redistribute it and/or modify it under\n", " * the terms of the GNU Lesser General Public License as published by the\n", " * Free Software Foundation; either version 2.1 of the License, or (at your\n", " * option) any later version.\n", " *\n", " * GetData is distributed in the hope that it will be useful, but WITHOUT\n", " * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n", " * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n", " * License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public License\n", " * along with GetData; if not, write to the Free Software Foundation, Inc.,\n", " * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "#include \"internal.h\"\n", "\n", "static void _GD_ShiftFragment(DIRFILE* D, off64_t offset, int fragment,\n", "    int move)\n", "{\n", "  unsigned int i, n_raw = 0;\n", "\n", "  dtrace(\"%p, %\" PRId64 \", %i, %i\", D, (int64_t)offset, fragment, move);\n", "\n", "  /* check protection */\n", "  if (D->fragment[fragment].protection & GD_PROTECT_FORMAT) {\n", "    _GD_SetError(D, GD_E_PROTECTED, GD_E_PROTECTED_FORMAT, NULL, 0,\n", "        D->fragment[fragment].cname);\n", "    dreturnvoid();\n", "    return;\n", "  }\n", "\n", "  if (move && offset != D->fragment[fragment].frame_offset) {\n", "    gd_entry_t **raw_entry = _GD_Malloc(D, sizeof(*raw_entry) * D->n_entries);\n", "\n", "    if (raw_entry == NULL) {\n", "      dreturnvoid();\n", "      return;\n", "    }\n", "\n", "    /* Because it may fail, the move must occur out-of-place and then be copied\n", "     * back over the affected files once success is assured */\n", "    for (i = 0; i < D->n_entries; ++i)\n", "      if (D->entry[i]->fragment_index == fragment &&\n", "          D->entry[i]->field_type == GD_RAW_ENTRY)\n", "      {\n", "        /* determine encoding scheme */\n", "        if (!_GD_Supports(D, D->entry[i], 0))\n", "          break;\n", "\n", "        /* add this raw field to the list */\n", "        raw_entry[n_raw++] = D->entry[i];\n", "\n", "        if (_GD_MogrifyFile(D, D->entry[i],\n", "              D->fragment[D->entry[i]->fragment_index].encoding,\n", "              D->fragment[D->entry[i]->fragment_index].byte_sex, offset, 0, -1,\n", "              NULL))\n", "          break;\n", "      }\n", "\n", "    /* If successful, move the temporary file over the old file, otherwise\n", "     * remove the temporary files */\n", "    if (D->error) {\n", "      for (i = 0; i < n_raw; ++i)\n", "        _GD_FiniRawIO(D, raw_entry[i], fragment, GD_FINIRAW_DISCARD |\n", "            GD_FINIRAW_CLOTEMP);\n", "    } else {\n", "      for (i = 0; i < n_raw; ++i)\n", "        _GD_FiniRawIO(D, raw_entry[i], fragment, GD_FINIRAW_KEEP |\n", "            GD_FINIRAW_CLOTEMP);\n", "    }\n", "\n", "    free(raw_entry);\n", "\n", "    if (D->error) {\n", "      dreturnvoid();\n", "      return;\n", "    }\n", "  }\n", "\n", "  D->fragment[fragment].frame_offset = offset;\n", "  D->fragment[fragment].modified = 1;\n", "  D->flags &= ~GD_HAVE_VERSION;\n", "\n", "  dreturnvoid();\n", "}\n"], "project": "libgetdata8", "file": "flimits.pkl", "function": "_GD_ShiftFragment"}, {"comment_all": {"comment": "/* Get memory for full buffer, including space for trailing EOB's. */", "depth": 1, "reading_ease": 61.33, "reading_grade": 7.2, "line": 3887}, "comment_text": "/* Get memory for full buffer, including space for trailing EOB's. */", "comment_tokens": ["Get", "memory", "for", "full", "buffer", ",", "including", "space", "for", "trailing", "EOB", "'s", "."], "ccode": ["\n", "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n", " * scan from a @e copy of @a bytes.\n", " * @param yybytes the byte buffer to scan\n", " * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n", " * \n", " * @return the newly allocated buffer state object.\n", " */\n", "YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "\tchar *buf;\n", "\tyy_size_t n;\n", "\tint i;\n", "    \n", "\t/* Get memory for full buffer, including space for trailing EOB's. */\n", "\tn = (yy_size_t) (_yybytes_len + 2);\n", "\tbuf = (char *) yyalloc( n  );\n", "\tif ( ! buf )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n", "\n", "\tfor ( i = 0; i < _yybytes_len; ++i )\n", "\t\tbuf[i] = yybytes[i];\n", "\n", "\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\tb = yy_scan_buffer( buf, n );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n", "\n", "\t/* It's okay to grow etc. this buffer, and we should throw it\n", "\t * away when we're done.\n", "\t */\n", "\tb->yy_is_our_buffer = 1;\n", "\n", "\treturn b;\n", "}\n"], "project": "linux-azure-5.11-headers-5.11.0-1007", "file": "lexer.lex.pkl", "function": "yy_scan_bytes"}, {"comment_all": {"comment": "/*\n     * We don't need to malloc here, as the transfer is finished before\n     * the variable gets popped from the stack\n     */", "depth": 1, "reading_ease": 77.57, "reading_grade": 7.2, "line": 330}, "comment_text": "/*\n     * We don't need to malloc here, as the transfer is finished before\n     * the variable gets popped from the stack\n     */", "comment_tokens": ["We", "do", "n't", "need", "to", "malloc", "here", ",", "as", "the", "transfer", "is", "finished", "before", "the", "variable", "gets", "popped", "from", "the", "stack"], "ccode": ["\n", "void transfer_blocking(CURL *curl)\n", "{\n", "    /*\n", "     * We don't need to malloc here, as the transfer is finished before\n", "     * the variable gets popped from the stack\n", "     */\n", "    volatile TransferStruct transfer;\n", "    transfer.type = DATA;\n", "    transfer.transferring = 1;\n", "    curl_easy_setopt(curl, CURLOPT_PRIVATE, &transfer);\n", "    #ifdef NETWORK_LOCK_DEBUG\n", "    fprintf(stderr,\n", "            \"transfer_blocking(): thread %lu: locking transfer_lock;\\n\",\n", "            pthread_self());\n", "    #endif\n", "    PTHREAD_MUTEX_LOCK(&transfer_lock);\n", "    CURLMcode res = curl_multi_add_handle(curl_multi, curl);\n", "    #ifdef NETWORK_LOCK_DEBUG\n", "    fprintf(stderr,\n", "            \"transfer_blocking(): thread %lu: unlocking transfer_lock;\\n\",\n", "            pthread_self());\n", "    #endif\n", "    PTHREAD_MUTEX_UNLOCK(&transfer_lock);\n", "\n", "    if(res > 0) {\n", "        fprintf(stderr, \"transfer_blocking(): %d, %s\\n\",\n", "                res, curl_multi_strerror(res));\n", "        exit_failure();\n", "    }\n", "\n", "    while (transfer.transferring) {\n", "        curl_multi_perform_once();\n", "    }\n", "}\n"], "project": "httpdirfs", "file": "network.pkl", "function": "transfer_blocking"}, {"comment_all": {"comment": "// fps_factor=(double)(now-fps_lasttime)*PIXEL_SPEED/1000;\n", "depth": 2, "reading_ease": -640.19, "reading_grade": 102.8, "line": 102}, "comment_text": "// fps_factor=(double)(now-fps_lasttime)*PIXEL_SPEED/1000;\n// fps_factor=(double)(now-fps_lasttime)/TICK_INTERVAL;\n", "comment_tokens": ["fps_factor=", "(", "double", ")", "(", "now-fps_lasttime", ")", "PIXEL_SPEED1000", ";", "fps_factor=", "(", "double", ")", "(", "now-fps_lasttime", ")", "TICK_INTERVAL", ";"], "ccode": ["\n", "void fps_newframe()\n", "{\n", "\tstatic Uint32 nexttime=0;\n", "\tstatic Uint32 now;\n", "\tint i;\n", "\n", "\tfps_frames++;\n", "\tfps_lasttime=now;\n", "\tnow=SDL_GetTicks();\n", "\n", "\tswitch(fps_method) {\n", "\t\tcase WAITFORFRAME:\n", "\t\t\tif(nexttime<=now)\n", "\t\t\t\tnexttime=now+TICK_INTERVAL;\n", "\t\t\telse\n", "\t\t\t\tSDL_Delay(nexttime-now);\n", "\t\t\tbreak;\n", "\t\t\t\n", "\t\tcase MAXFPS:\n", "\t\t\t// fps_factor=(double)(now-fps_lasttime)*PIXEL_SPEED/1000;\n", "\t\t\t// fps_factor=(double)(now-fps_lasttime)/TICK_INTERVAL;\n", "\t\t\tfps_factor_avg[fps_factor_avg_idx++]=(double)(now-fps_lasttime)/TICK_INTERVAL;\n", "\t\t\tif(fps_factor_avg_idx==AVG_FRAMES)\n", "\t\t\t\tfps_factor_avg_idx=0;\n", "\t\t\tfps_factor=0;\n", "\t\t\tfor(i=0;i<AVG_FRAMES;i++)\n", "\t\t\t\tfps_factor+=fps_factor_avg[i];\n", "\t\t\tfps_factor/=AVG_FRAMES;\n", "\t\t\tfps=1/((double)(now-fps_lasttime)/1000);\n", "\t\t\tbreak;\n", "\t\t\t\n", "\t}\n", "}\n"], "project": "ketm-data", "file": "fps.pkl", "function": "fps_newframe"}, {"comment_all": {"comment": "/* at least \"l(m)\" */", "depth": 1, "reading_ease": 119.19, "reading_grade": -2.7, "line": 197}, "comment_text": "/* AIX */\n/* at least \"l(m)\" */\n", "comment_tokens": ["AIX", "at", "least", "``", "l", "(", "m", ")", "''"], "ccode": ["\n", "\n", "/* A function called through the vtable to open a module with this\n", "   loader.  Returns an opaque representation of the newly opened\n", "   module for processing with this loader's other vtable functions.  */\n", "static lt_module\n", "vm_open (lt_user_data loader_data LT__UNUSED, const char *filename,\n", "         lt_dladvise advise)\n", "{\n", "  int\t\tmodule_flags = LT_LAZY_OR_NOW;\n", "  lt_module\tmodule;\n", "#ifdef RTLD_MEMBER\n", "  int\t\tlen = LT_STRLEN (filename);\n", "#endif\n", "\n", "  if (advise)\n", "    {\n", "#ifdef RTLD_GLOBAL\n", "      /* If there is some means of asking for global symbol resolution,\n", "         do so.  */\n", "      if (advise->is_symglobal)\n", "        module_flags |= RTLD_GLOBAL;\n", "#else\n", "      /* Otherwise, reset that bit so the caller can tell it wasn't\n", "         acted on.  */\n", "      advise->is_symglobal = 0;\n", "#endif\n", "\n", "/* And similarly for local only symbol resolution.  */\n", "#ifdef RTLD_LOCAL\n", "      if (advise->is_symlocal)\n", "        module_flags |= RTLD_LOCAL;\n", "#else\n", "      advise->is_symlocal = 0;\n", "#endif\n", "    }\n", "\n", "#ifdef RTLD_MEMBER /* AIX */\n", "  if (len >= 4) /* at least \"l(m)\" */\n", "    {\n", "      /* Advise loading an archive member only if the filename really\n", "\t contains both the opening and closing parent, and a member. */\n", "      if (filename[len-1] == ')')\n", "\t{\n", "\t  const char *opening = strrchr(filename, '(');\n", "\t  if (opening && opening < (filename+len-2) && strchr(opening+1, '/') == NULL)\n", "\t    module_flags |= RTLD_MEMBER;\n", "\t}\n", "    }\n", "#endif\n", "\n", "  module = dlopen (filename, module_flags);\n", "\n", "#if defined RTLD_MEMBER && defined LT_SHARED_LIB_MEMBER\n", "  if (!module && len && !(module_flags & RTLD_MEMBER) && errno == ENOEXEC)\n", "    {\n", "      /* Loading without a member specified failed with \"Exec format error\".\n", "\t So the file is there, but either has wrong bitwidth, or is an\n", "\t archive eventually containing the default shared archive member.\n", "\t Retry with default member, getting same error in worst case. */\n", "      const char *member = LT_SHARED_LIB_MEMBER;\n", "\n", "      char *attempt = MALLOC (char, len + strlen (member) + 1);\n", "      if (!attempt)\n", "\t{\n", "\t  LT__SETERROR (NO_MEMORY);\n", "\t  return module;\n", "\t}\n", "\n", "      sprintf (attempt, \"%s%s\", filename, member);\n", "      module = vm_open (loader_data, attempt, advise);\n", "      FREE (attempt);\n", "      return module;\n", "    }\n", "#endif\n", "\n", "  if (!module)\n", "    {\n", "      DL__SETERROR (CANNOT_OPEN);\n", "    }\n", "\n", "  return module;\n", "}\n"], "project": "clamav-freshclam", "file": "dlopen.pkl", "function": "vm_open"}, {"comment_all": {"comment": "/* return full path for ~/.irssi/config */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 78}, "comment_text": "/* return full path for ~/.irssi/config */", "comment_tokens": ["return", "full", "path", "for", "~.irssiconfig"], "ccode": ["\n", "/* return full path for ~/.irssi/config */\n", "const char *get_irssi_config(void)\n", "{\n", "        return irssi_config_file;\n", "}\n"], "project": "irssi", "file": "core.pkl", "function": "get_irssi_config"}, {"comment_all": {"comment": "/* Can't handle 2+ channel files (yet) */", "depth": 2, "reading_ease": 90.77, "reading_grade": 2.1, "line": 427}, "comment_text": "/* Can't handle 2+ channel files (yet) */", "comment_tokens": ["Ca", "n't", "handle", "2+", "channel", "files", "(", "yet", ")"], "ccode": ["\n", "\n", "static int vorbis_open(input_object *obj, const char *path)\n", "{\n", "\tvorbis_info *vi; \n", "\tvoid *datasource = NULL;\n", "\tOggVorbis_File vf_temp;\n", "\tstruct vorbis_local_data *data;\n", "\n", "\tmemset(&vf_temp, 0, sizeof(vf_temp));\n", "\n", "\tif (!obj)\n", "\t\treturn 0;\n", "\n", "\tif ((datasource = reader_open(path, NULL, NULL)) == NULL) {\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tobj->flags = 0;\n", "\tif (reader_seekable (datasource)) {\n", "\t\tobj->flags |= P_SEEK;\n", "\t\tobj->flags |= P_PERFECTSEEK;\n", "\t\tobj->flags |= P_FILEBASED;\n", "\t} else {\n", "\t\tobj->flags |= P_STREAMBASED;\n", "\t}\t\n", "\n", "\tif (ov_open_callbacks(datasource, &vf_temp, NULL, 0, \n", "\t\t(obj->flags & P_STREAMBASED) ? vorbis_stream_callbacks : vorbis_callbacks) < 0) {\n", "\t\tov_clear(&vf_temp);\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tvi = ov_info(&vf_temp, -1);\n", "\tif (!vi) {\n", "\t\tov_clear(&vf_temp);\n", "\t\treturn 0;\n", "\t}\t\t\n", "\n", "\tif (vi->channels > 2) { /* Can't handle 2+ channel files (yet) */\n", "\t\tov_clear(&vf_temp);\n", "\t\treturn 0;\n", "\t}\t\n", "\tobj->nr_channels = vi->channels;\n", "\tobj->frame_size = BLOCK_SIZE;\n", "\tobj->local_data = malloc(sizeof(struct vorbis_local_data));\n", "\tif (!obj->local_data) {\n", "\t\tov_clear(&vf_temp);\n", "\t\treturn 0;\n", "\t}\n", "\tdata = (struct vorbis_local_data *)obj->local_data;\n", "\tdata->current_section = -1;\n", "\tdata->last_section = -1;\n", "\tdata->bitrate_instant = 0;\n", "\tdata->bigendianp = is_big_endian();\n", "\tmemcpy(&data->vf, &vf_temp, sizeof(vf_temp));\n", "\tmemcpy(data->path, path, sizeof(data->path)-1);\n", "\n", "\treturn 1;\n", "}\n"], "project": "alsaplayer-common", "file": "vorbis_engine.pkl", "function": "vorbis_open"}, {"comment_all": {"comment": "/* Try to insert in-order at matching timestamp */", "depth": 1, "reading_ease": 64.37, "reading_grade": 6.0, "line": 372}, "comment_text": "/* Try to insert in-order at matching timestamp */", "comment_tokens": ["Try", "to", "insert", "in-order", "at", "matching", "timestamp"], "ccode": ["\n", "void *tickit_watch_timer_at_tv(Tickit *t, const struct timeval *at, TickitBindFlags flags, TickitCallbackFn *fn, void *user)\n", "{\n", "  TickitWatch *watch = malloc(sizeof(TickitWatch));\n", "  if(!watch)\n", "    return NULL;\n", "\n", "  watch->next = NULL;\n", "  watch->t    = t;\n", "  watch->type = WATCH_TIMER;\n", "\n", "  watch->flags = flags & (TICKIT_BIND_UNBIND|TICKIT_BIND_DESTROY);\n", "  watch->fn = fn;\n", "  watch->user = user;\n", "\n", "  watch->timer.at = *at;\n", "\n", "  if(t->evhooks->timer)\n", "    if(!(*t->evhooks->timer)(t->evdata, at, flags, watch))\n", "      goto fail;\n", "\n", "  TickitWatch **prevp = &t->timers;\n", "  /* Try to insert in-order at matching timestamp */\n", "  while(*prevp && !timercmp(&(*prevp)->timer.at, at, >))\n", "    prevp = &(*prevp)->next;\n", "\n", "  watch->next = *prevp;\n", "  *prevp = watch;\n", "\n", "  return watch;\n", "\n", "fail:\n", "  free(watch);\n", "  return NULL;\n", "}\n"], "project": "libtickit-dev", "file": "tickit.pkl", "function": "tickit_watch_timer_at_tv"}, {"comment_all": {"comment": "/* see yyrealloc() for (char *) cast */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 4194}, "comment_text": "/* see yyrealloc() for (char *) cast */", "comment_tokens": ["see", "yyrealloc", "(", ")", "for", "(", "char", ")", "cast"], "ccode": ["\n", "void yyfree (void * ptr )\n", "{\n", "\t\t\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n", "}\n"], "project": "linux-cloud-tools-5.8.0-44-lowlatency", "file": "lexer.lex.pkl", "function": "yyfree"}, {"comment_all": {"comment": "/* Converts a lockspace handle into a file descriptor */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 1175}, "comment_text": "/* Converts a lockspace handle into a file descriptor */", "comment_tokens": ["Converts", "a", "lockspace", "handle", "into", "a", "file", "descriptor"], "ccode": ["\n", "/* Converts a lockspace handle into a file descriptor */\n", "int dlm_ls_get_fd(dlm_lshandle_t lockspace)\n", "{\n", "    struct dlm_ls_info *lsinfo = (struct dlm_ls_info *)lockspace;\n", "\n", "    return lsinfo->fd;\n", "}\n"], "project": "libdlmcontrol3", "file": "libdlm.pkl", "function": "dlm_ls_get_fd"}, {"comment_all": {"comment": "/* char*[]     array of X labels */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 40}, "comment_text": "/* ----- call the lib ----- */\n/* short       width, height */\n/* FILE*       open FILE pointer */\n/* GDC_CHART_T chart type */\n/* int         number of points per data set */\n/* char*[]     array of X labels */\n/* int         number of data sets */\n/* float[]     data set 1 */\n/*               b );             ...        data set n */\n", "comment_tokens": ["--", "--", "-", "call", "the", "lib", "--", "--", "-", "short", "width", ",", "height", "FILE", "open", "FILE", "pointer", "GDC_CHART_T", "chart", "type", "int", "number", "of", "points", "per", "data", "set", "char", "[", "]", "array", "of", "X", "labels", "int", "number", "of", "data", "sets", "float", "[", "]", "data", "set", "1", "b", ")", ";", "...", "data", "set", "n"], "ccode": ["/* GDCHART 0.10.0dev  1st CHART SAMPLE  2 Nov 2000 */\n", "/* Copyright Bruce Verderaime 1998-2004 */\n", "\n", "/* writes gif file to stdout */\n", "\n", "/* sample gdchart usage */\n", "/* this will produce a 3D BAR chart */\n", "/* this is suitable for use as a CGI */\n", "\n", "/* for CGI use un-comment the \"Content-Type\" line */\n", "\n", "#include <stdio.h>\n", " \n", "#include \"gdc.h\"\n", "#include \"gdchart.h\"\n", " \n", "main()\n", "{\n", "    /* ----- set some data ----- */\n", "/*    float   a[6]  = { 0.5, 0.09, 0.6, 0.85, 0.0, 0.90 }, */\n", "/*            b[6]  = { 1.9, 1.3,  0.6, 0.75, 0.1, 2.0 }; */\n", "    float   a[2][6]  = { { 0.5, 0.09, 0.6, 0.85, 0.0, 0.90 },\n", "                         { 1.9, 1.3,  0.6, 0.75, 0.1, 2.0 } };\n", "\n", "    /* ----- X labels ----- */\n", "    char    *t[6] = { \"Chicago\", \"New York\", \"L.A.\", \"Atlanta\", \"Paris, MD\\n(USA) \", \"London\" };\n", "    /* ----- data set colors (RGB) ----- */\n", "    unsigned long   sc[2]    = { 0xFF8080, 0x8080FF };\n", " \n", "    GDC_BGColor   = 0xFFFFFFL;                  /* backgound color (white) */\n", "    GDC_LineColor = 0x000000L;                  /* line color      (black) */\n", "    GDC_SetColor  = &(sc[0]);                   /* assign set colors */\n", "\n", "/*    printf( \"Content-Type: image/gif\\n\\n\" );     tell browser type */\n", "    GDC_image_type = GDC_GIF;\n", "                              /* ----- call the lib ----- */\n", "    GDC_out_graph( 250, 200,      /* short       width, height */\n", "               stdout,        /* FILE*       open FILE pointer */\n", "               GDC_3DBAR,     /* GDC_CHART_T chart type */\n", "               6,             /* int         number of points per data set */\n", "               t,             /* char*[]     array of X labels */\n", "               2,             /* int         number of data sets */\n", "               (float*)a, NULL );             /* float[]     data set 1 */\n", "/*               b );             ...        data set n */ \n", "\n", "    exit(0);\n", "}\n"], "project": "libgdchart-gd2-xpm", "file": "gdc_samp1.pkl", "function": "main"}, {"comment_all": {"comment": "/*\n\t * Check that ctx is still unused by any thread cache before destroying\n\t * it.  prof_lookup() increments ctx->nlimbo in order to avoid a race\n\t * condition with this function, as does prof_ctx_merge() in order to\n\t * avoid a race between the main body of prof_ctx_merge() and entry\n\t * into this function.\n\t */", "depth": 1, "reading_ease": 65.05, "reading_grade": 9.9, "line": 413}, "comment_text": "/*\n\t * Check that ctx is still unused by any thread cache before destroying\n\t * it.  prof_lookup() increments ctx->nlimbo in order to avoid a race\n\t * condition with this function, as does prof_ctx_merge() in order to\n\t * avoid a race between the main body of prof_ctx_merge() and entry\n\t * into this function.\n\t */", "comment_tokens": ["Check", "that", "ctx", "is", "still", "unused", "by", "any", "thread", "cache", "before", "destroying", "it", ".", "prof_lookup", "(", ")", "increments", "ctx-", ">", "nlimbo", "in", "order", "to", "avoid", "a", "race", "condition", "with", "this", "function", ",", "as", "does", "prof_ctx_merge", "(", ")", "in", "order", "to", "avoid", "a", "race", "between", "the", "main", "body", "of", "prof_ctx_merge", "(", ")", "and", "entry", "into", "this", "function", "."], "ccode": ["\n", "static void\n", "prof_ctx_destroy(prof_ctx_t *ctx)\n", "{\n", "\tprof_tdata_t *prof_tdata;\n", "\n", "\tcassert(config_prof);\n", "\n", "\t/*\n", "\t * Check that ctx is still unused by any thread cache before destroying\n", "\t * it.  prof_lookup() increments ctx->nlimbo in order to avoid a race\n", "\t * condition with this function, as does prof_ctx_merge() in order to\n", "\t * avoid a race between the main body of prof_ctx_merge() and entry\n", "\t * into this function.\n", "\t */\n", "\tprof_tdata = prof_tdata_get(false);\n", "\tassert((uintptr_t)prof_tdata > (uintptr_t)PROF_TDATA_STATE_MAX);\n", "\tprof_enter(prof_tdata);\n", "\tmalloc_mutex_lock(ctx->lock);\n", "\tif (ql_first(&ctx->cnts_ql) == NULL && ctx->cnt_merged.curobjs == 0 &&\n", "\t    ctx->nlimbo == 1) {\n", "\t\tassert(ctx->cnt_merged.curbytes == 0);\n", "\t\tassert(ctx->cnt_merged.accumobjs == 0);\n", "\t\tassert(ctx->cnt_merged.accumbytes == 0);\n", "\t\t/* Remove ctx from bt2ctx. */\n", "\t\tif (ckh_remove(&bt2ctx, ctx->bt, NULL, NULL))\n", "\t\t\tnot_reached();\n", "\t\tprof_leave(prof_tdata);\n", "\t\t/* Destroy ctx. */\n", "\t\tmalloc_mutex_unlock(ctx->lock);\n", "\t\tbt_destroy(ctx->bt);\n", "\t\tidalloc(ctx);\n", "\t} else {\n", "\t\t/*\n", "\t\t * Compensate for increment in prof_ctx_merge() or\n", "\t\t * prof_lookup().\n", "\t\t */\n", "\t\tctx->nlimbo--;\n", "\t\tmalloc_mutex_unlock(ctx->lock);\n", "\t\tprof_leave(prof_tdata);\n", "\t}\n", "}\n"], "project": "libvmem-dev", "file": "prof.pkl", "function": "prof_ctx_destroy"}, {"comment_all": {"comment": "/* by default, reject, unless the productid option is given */", "depth": 2, "reading_ease": 45.42, "reading_grade": 9.2, "line": 371}, "comment_text": "/* by default, reject, unless the productid option is given */", "comment_tokens": ["by", "default", ",", "reject", ",", "unless", "the", "productid", "option", "is", "given"], "ccode": ["\n", "/* this function allows the subdriver to \"claim\" a device: return 1 if\n", " * the device is supported by this subdriver, else 0. */\n", "static int openups_claim(HIDDevice_t * hd)\n", "{\n", "\tint status = is_usb_device_supported(openups_usb_device_table, hd);\n", "\n", "\tswitch (status) {\n", "\tcase POSSIBLY_SUPPORTED:\n", "\t\t/* by default, reject, unless the productid option is given */\n", "\t\tif (getval(\"productid\")) {\n", "\t\t\treturn 1;\n", "\t\t}\n", "\t\tpossibly_supported(\"openUPS\", hd);\n", "\t\treturn 0;\n", "\n", "\tcase SUPPORTED:\n", "\t\treturn 1;\n", "\n", "\tcase NOT_SUPPORTED:\n", "\tdefault:\n", "\t\treturn 0;\n", "\t}\n", "}\n"], "project": "nut-snmp", "file": "openups-hid.pkl", "function": "openups_claim"}, {"comment_all": {"comment": "/*\n * Copyright 2016 Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "depth": 0, "reading_ease": 49.01, "reading_grade": 9.9, "line": 8}, "comment_text": "/*\n * Copyright 2016 Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "comment_tokens": ["Copyright", "2016", "Red", "Hat", ",", "Inc", ".", "Licensed", "under", "the", "Apache", "License", ",", "Version", "2.0", "(", "the", "``", "License", "''", ")", ";", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License", ".", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at", "http", ":", "www.apache.orglicensesLICENSE-2.0", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing", ",", "software", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "``", "AS", "IS", "''", "BASIS", ",", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND", ",", "either", "express", "or", "implied", ".", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and", "limitations", "under", "the", "License", "."], "ccode": ["/* vim: set tabstop=8 shiftwidth=4 softtabstop=4 expandtab smarttab colorcolumn=80: */\n", "/*\n", " * Copyright 2016 Red Hat, Inc.\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " *     http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "#include \"misc.h\"\n", "#include \"../hooks.h\"\n", "#include <jose/openssl.h>\n", "\n", "#include <string.h>\n", "\n", "declare_cleanup(EC_POINT)\n", "declare_cleanup(EC_KEY)\n", "declare_cleanup(BN_CTX)\n", "\n", "static bool\n", "jwk_prep_handles(jose_cfg_t *cfg, const json_t *jwk)\n", "{\n", "    const char *alg = NULL;\n", "\n", "    if (json_unpack((json_t *) jwk, \"{s:s}\", \"alg\", &alg) == -1)\n", "        return false;\n", "\n", "    return strcmp(alg, \"ECDH\") == 0;\n", "}\n"], "project": "libjose0", "file": "ecdh.pkl", "function": "jwk_prep_handles"}, {"comment_all": {"comment": "/**\n * visu_object_setLoadMessage:\n * @obj: a #VisuObject object.\n * @mess: a string.\n *\n * If a message function on load action has been set by\n * visu_object_setLoadMessageFunc(), then the given @mess is given as\n * argument to this function.\n *\n * Since: 3.6\n */", "depth": 0, "reading_ease": 51.85, "reading_grade": 8.8, "line": 492}, "comment_text": "/**\n * visu_object_setLoadMessage:\n * @obj: a #VisuObject object.\n * @mess: a string.\n *\n * If a message function on load action has been set by\n * visu_object_setLoadMessageFunc(), then the given @mess is given as\n * argument to this function.\n *\n * Since: 3.6\n */", "comment_tokens": ["visu_object_setLoadMessage", ":", "@", "obj", ":", "a", "#", "VisuObject", "object", ".", "@", "mess", ":", "a", "string", ".", "If", "a", "message", "function", "on", "load", "action", "has", "been", "set", "by", "visu_object_setLoadMessageFunc", "(", ")", ",", "then", "the", "given", "@", "mess", "is", "given", "as", "argument", "to", "this", "function", ".", "Since", ":", "3.6"], "ccode": ["/**\n", " * visu_object_setLoadMessage:\n", " * @obj: a #VisuObject object.\n", " * @mess: a string.\n", " *\n", " * If a message function on load action has been set by\n", " * visu_object_setLoadMessageFunc(), then the given @mess is given as\n", " * argument to this function.\n", " *\n", " * Since: 3.6\n", " */\n", "void visu_object_setLoadMessage(VisuObject *obj, const gchar *mess)\n", "{\n", "  if (obj->priv->loadMessageFunc)\n", "    obj->priv->loadMessageFunc((gpointer)mess, obj->priv->loadMessageData);\n", "}\n"], "project": "v-sim-doc", "file": "visu_object.pkl", "function": "visu_object_setLoadMessage"}, {"comment_all": {"comment": "/* lazy way to send a signal if the program uses the PIDPATH */", "depth": 0, "reading_ease": 84.68, "reading_grade": 4.4, "line": 297}, "comment_text": "/* lazy way to send a signal if the program uses the PIDPATH */", "comment_tokens": ["lazy", "way", "to", "send", "a", "signal", "if", "the", "program", "uses", "the", "PIDPATH"], "ccode": ["\n", "/* lazy way to send a signal if the program uses the PIDPATH */\n", "int sendsignal(const char *progname, int sig)\n", "{\n", "\tchar\tfn[SMALLBUF];\n", "\n", "\tsnprintf(fn, sizeof(fn), \"%s/%s.pid\", PIDPATH, progname);\n", "\n", "\treturn sendsignalfn(fn, sig);\n", "}\n"], "project": "nut-snmp", "file": "common.pkl", "function": "sendsignal"}, {"comment_all": {"comment": "/* Allocate space for hash table, dict, and freqs */", "depth": 1, "reading_ease": 71.82, "reading_grade": 5.2, "line": 1062}, "comment_text": "/* Allocate space for hash table, dict, and freqs */", "comment_tokens": ["Allocate", "space", "for", "hash", "table", ",", "dict", ",", "and", "freqs"], "ccode": ["\n", "/**\n", " * Tries a set of parameters and updates the COVER_best_t with the results.\n", " * This function is thread safe if zstd is compiled with multithreaded support.\n", " * It takes its parameters as an *OWNING* opaque pointer to support threading.\n", " */\n", "static void COVER_tryParameters(void *opaque) {\n", "  /* Save parameters as local variables */\n", "  COVER_tryParameters_data_t *const data = (COVER_tryParameters_data_t *)opaque;\n", "  const COVER_ctx_t *const ctx = data->ctx;\n", "  const ZDICT_cover_params_t parameters = data->parameters;\n", "  size_t dictBufferCapacity = data->dictBufferCapacity;\n", "  size_t totalCompressedSize = ERROR(GENERIC);\n", "  /* Allocate space for hash table, dict, and freqs */\n", "  COVER_map_t activeDmers;\n", "  BYTE *const dict = (BYTE * const)malloc(dictBufferCapacity);\n", "  COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));\n", "  U32 *freqs = (U32 *)malloc(ctx->suffixSize * sizeof(U32));\n", "  if (!COVER_map_init(&activeDmers, parameters.k - parameters.d + 1)) {\n", "    DISPLAYLEVEL(1, \"Failed to allocate dmer map: out of memory\\n\");\n", "    goto _cleanup;\n", "  }\n", "  if (!dict || !freqs) {\n", "    DISPLAYLEVEL(1, \"Failed to allocate buffers: out of memory\\n\");\n", "    goto _cleanup;\n", "  }\n", "  /* Copy the frequencies because we need to modify them */\n", "  memcpy(freqs, ctx->freqs, ctx->suffixSize * sizeof(U32));\n", "  /* Build the dictionary */\n", "  {\n", "    const size_t tail = COVER_buildDictionary(ctx, freqs, &activeDmers, dict,\n", "                                              dictBufferCapacity, parameters);\n", "    selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,\n", "        ctx->samples, ctx->samplesSizes, (unsigned)ctx->nbTrainSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,\n", "        totalCompressedSize);\n", "\n", "    if (COVER_dictSelectionIsError(selection)) {\n", "      DISPLAYLEVEL(1, \"Failed to select dictionary\\n\");\n", "      goto _cleanup;\n", "    }\n", "  }\n", "_cleanup:\n", "  free(dict);\n", "  COVER_best_finish(data->best, parameters, selection);\n", "  free(data);\n", "  COVER_map_destroy(&activeDmers);\n", "  COVER_dictSelectionFree(selection);\n", "  if (freqs) {\n", "    free(freqs);\n", "  }\n", "}\n"], "project": "libzstd1", "file": "cover.pkl", "function": "COVER_tryParameters"}, {"comment_all": {"comment": "/*----------------------------------------------------------------------------\n   Convert an XML element representing a list of parameters (i.e.  a <params>\n   element) to an xmlrpc_value of type array.  Note that an xmlrpc_value is\n   normally represented in XML by a <value> element, not a <params> element.\n   We use type xmlrpc_value to represent the parameter list just for\n   convenience.\n-----------------------------------------------------------------------------*/", "depth": 1, "reading_ease": 33.92, "reading_grade": 11.5, "line": 103}, "comment_text": "/*----------------------------------------------------------------------------\n   Convert an XML element representing a list of parameters (i.e.  a <params>\n   element) to an xmlrpc_value of type array.  Note that an xmlrpc_value is\n   normally represented in XML by a <value> element, not a <params> element.\n   We use type xmlrpc_value to represent the parameter list just for\n   convenience.\n-----------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "Convert", "an", "XML", "element", "representing", "a", "list", "of", "parameters", "(", "i.e", ".", "a", "<", "params", ">", "element", ")", "to", "an", "xmlrpc_value", "of", "type", "array", ".", "Note", "that", "an", "xmlrpc_value", "is", "normally", "represented", "in", "XML", "by", "a", "<", "value", ">", "element", ",", "not", "a", "<", "params", ">", "element", ".", "We", "use", "type", "xmlrpc_value", "to", "represent", "the", "parameter", "list", "just", "for", "convenience", ".", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "\n", "\n", "static xmlrpc_value *\n", "convertParams(xmlrpc_env *        const envP,\n", "              const xml_element * const elemP) {\n", "/*----------------------------------------------------------------------------\n", "   Convert an XML element representing a list of parameters (i.e.  a <params>\n", "   element) to an xmlrpc_value of type array.  Note that an xmlrpc_value is\n", "   normally represented in XML by a <value> element, not a <params> element.\n", "   We use type xmlrpc_value to represent the parameter list just for\n", "   convenience.\n", "-----------------------------------------------------------------------------*/\n", "    xmlrpc_value * arrayP;\n", "    xmlrpc_value * itemP;\n", "\n", "    XMLRPC_ASSERT_ENV_OK(envP);\n", "    XMLRPC_ASSERT(elemP != NULL);\n", "\n", "    /* Allocate an array to hold our parameters. */\n", "    arrayP = xmlrpc_array_new(envP);\n", "    if (!envP->fault_occurred) {\n", "        /* We're responsible for checking our own element name. */\n", "        validateName(envP, elemP, \"params\");    \n", "\n", "        if (!envP->fault_occurred) {\n", "            /* Iterate over our children. */\n", "            unsigned int const size = xml_element_children_size(elemP);\n", "            xml_element ** const paramPList = xml_element_children(elemP);\n", "\n", "            unsigned int i;\n", "\n", "            for (i = 0; i < size; ++i) {\n", "                xml_element * const paramP = paramPList[i];\n", "                unsigned int const maxNest = (unsigned int)\n", "                    xmlrpc_limit_get(XMLRPC_NESTING_LIMIT_ID);\n", "\n", "                validateName(envP, paramP, \"param\");\n", "                if (!envP->fault_occurred) {\n", "                    validateChildCount(envP, paramP, 1);\n", "                    if (!envP->fault_occurred) {\n", "                        xml_element * const valueEltP =\n", "                            xml_element_children(paramP)[0];\n", "\n", "                        validateName(envP, valueEltP, \"value\");\n", "\n", "                        if (!envP->fault_occurred) {\n", "                            xmlrpc_parseValue(envP, maxNest, valueEltP,\n", "                                              &itemP);\n", "                            if (!envP->fault_occurred) {\n", "                                xmlrpc_array_append_item(envP, arrayP, itemP);\n", "                                xmlrpc_DECREF(itemP);\n", "                            }\n", "                        }\n", "                    }\n", "                }\n", "            }\n", "        }\n", "        if (envP->fault_occurred)\n", "            xmlrpc_DECREF(arrayP);\n", "    }\n", "    return arrayP;\n", "}\n"], "project": "libxmlrpc-c++8v5", "file": "xmlrpc_parse.pkl", "function": "convertParams"}, {"comment_all": {"comment": "/*\n * Please do not edit this file.\n * It was generated using rpcgen.\n */", "depth": 0, "reading_ease": 74.35, "reading_grade": 4.3, "line": 0}, "comment_text": "/*\n * Please do not edit this file.\n * It was generated using rpcgen.\n */", "comment_tokens": ["Please", "do", "not", "edit", "this", "file", ".", "It", "was", "generated", "using", "rpcgen", "."], "ccode": ["/*\n", " * Please do not edit this file.\n", " * It was generated using rpcgen.\n", " */\n", "\n", "#include \"grok_capture.h\"\n", "\n", "bool_t\n", "xdr_grok_capture (XDR *xdrs, grok_capture *objp)\n", "{\n", "\tregister int32_t *buf;\n", "\n", "\n", "\tif (xdrs->x_op == XDR_ENCODE) {\n", "\t\t if (!xdr_int (xdrs, &objp->name_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->name, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->subname_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->subname, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->pattern_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->pattern, ~0))\n", "\t\t\t return FALSE;\n", "\t\tbuf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);\n", "\t\tif (buf == NULL) {\n", "\t\t\t if (!xdr_int (xdrs, &objp->id))\n", "\t\t\t\t return FALSE;\n", "\t\t\t if (!xdr_int (xdrs, &objp->pcre_capture_number))\n", "\t\t\t\t return FALSE;\n", "\t\t\t if (!xdr_int (xdrs, &objp->predicate_lib_len))\n", "\t\t\t\t return FALSE;\n", "\n", "\t\t} else {\n", "\t\tIXDR_PUT_LONG(buf, objp->id);\n", "\t\tIXDR_PUT_LONG(buf, objp->pcre_capture_number);\n", "\t\tIXDR_PUT_LONG(buf, objp->predicate_lib_len);\n", "\t\t}\n", "\t\t if (!xdr_string (xdrs, &objp->predicate_lib, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->predicate_func_name_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->predicate_func_name, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_bytes (xdrs, (char **)&objp->extra.extra_val, (u_int *) &objp->extra.extra_len, ~0))\n", "\t\t\t return FALSE;\n", "\t\treturn TRUE;\n", "\t} else if (xdrs->x_op == XDR_DECODE) {\n", "\t\t if (!xdr_int (xdrs, &objp->name_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->name, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->subname_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->subname, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->pattern_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->pattern, ~0))\n", "\t\t\t return FALSE;\n", "\t\tbuf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);\n", "\t\tif (buf == NULL) {\n", "\t\t\t if (!xdr_int (xdrs, &objp->id))\n", "\t\t\t\t return FALSE;\n", "\t\t\t if (!xdr_int (xdrs, &objp->pcre_capture_number))\n", "\t\t\t\t return FALSE;\n", "\t\t\t if (!xdr_int (xdrs, &objp->predicate_lib_len))\n", "\t\t\t\t return FALSE;\n", "\n", "\t\t} else {\n", "\t\tobjp->id = IXDR_GET_LONG(buf);\n", "\t\tobjp->pcre_capture_number = IXDR_GET_LONG(buf);\n", "\t\tobjp->predicate_lib_len = IXDR_GET_LONG(buf);\n", "\t\t}\n", "\t\t if (!xdr_string (xdrs, &objp->predicate_lib, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_int (xdrs, &objp->predicate_func_name_len))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_string (xdrs, &objp->predicate_func_name, ~0))\n", "\t\t\t return FALSE;\n", "\t\t if (!xdr_bytes (xdrs, (char **)&objp->extra.extra_val, (u_int *) &objp->extra.extra_len, ~0))\n", "\t\t\t return FALSE;\n", "\t return TRUE;\n", "\t}\n", "\n", "\t if (!xdr_int (xdrs, &objp->name_len))\n", "\t\t return FALSE;\n", "\t if (!xdr_string (xdrs, &objp->name, ~0))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->subname_len))\n", "\t\t return FALSE;\n", "\t if (!xdr_string (xdrs, &objp->subname, ~0))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->pattern_len))\n", "\t\t return FALSE;\n", "\t if (!xdr_string (xdrs, &objp->pattern, ~0))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->id))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->pcre_capture_number))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->predicate_lib_len))\n", "\t\t return FALSE;\n", "\t if (!xdr_string (xdrs, &objp->predicate_lib, ~0))\n", "\t\t return FALSE;\n", "\t if (!xdr_int (xdrs, &objp->predicate_func_name_len))\n", "\t\t return FALSE;\n", "\t if (!xdr_string (xdrs, &objp->predicate_func_name, ~0))\n", "\t\t return FALSE;\n", "\t if (!xdr_bytes (xdrs, (char **)&objp->extra.extra_val, (u_int *) &objp->extra.extra_len, ~0))\n", "\t\t return FALSE;\n", "\treturn TRUE;\n", "}\n"], "project": "grok-dbg", "file": "grok_capture_xdr.pkl", "function": "xdr_grok_capture"}, {"comment_all": {"comment": "/* assume 8-bit; it's 1999 now, not 1972 */", "depth": 2, "reading_ease": 106.67, "reading_grade": 0.1, "line": 78}, "comment_text": "/* assume 8-bit; it's 1999 now, not 1972 */", "comment_tokens": ["assume", "8-bit", ";", "it", "'s", "1999", "now", ",", "not", "1972"], "ccode": ["\n", "int\n", "is8bit(void)\n", "{\n", "\tstatic int cache=-1;\n", "\tstruct termios tios;\n", "\tif (cache>=0) return cache;\n", "\n", "\tif (tcgetattr(STDIN_FILENO, &tios)<0) {\n", "\t\t/* assume 8-bit; it's 1999 now, not 1972 */\n", "\t\tcache = 1;\n", "\t}\n", "\telse {\n", "\t\tcache = (tios.c_cflag & CSIZE)==CS8;\n", "\t}\n", "\treturn cache;\n", "}\n"], "project": "finger", "file": "display.pkl", "function": "is8bit"}, {"comment_all": {"comment": "/* Do a bit-for-bit comparison in case two different files produce the \n   same signature. Unlikely, but better safe than sorry. */", "depth": 0, "reading_ease": 53.37, "reading_grade": 8.2, "line": 612}, "comment_text": "/* Do a bit-for-bit comparison in case two different files produce the \n   same signature. Unlikely, but better safe than sorry. */", "comment_tokens": ["Do", "a", "bit-for-bit", "comparison", "in", "case", "two", "different", "files", "produce", "the", "same", "signature", ".", "Unlikely", ",", "but", "better", "safe", "than", "sorry", "."], "ccode": ["\n", "/* Do a bit-for-bit comparison in case two different files produce the \n", "   same signature. Unlikely, but better safe than sorry. */\n", "\n", "int confirmmatch(FILE *file1, FILE *file2)\n", "{\n", "  unsigned char c1[CHUNK_SIZE];\n", "  unsigned char c2[CHUNK_SIZE];\n", "  size_t r1;\n", "  size_t r2;\n", "  \n", "  fseek(file1, 0, SEEK_SET);\n", "  fseek(file2, 0, SEEK_SET);\n", "\n", "  do {\n", "    r1 = fread(c1, sizeof(unsigned char), sizeof(c1), file1);\n", "    r2 = fread(c2, sizeof(unsigned char), sizeof(c2), file2);\n", "\n", "    if (r1 != r2) return 0; /* file lengths are different */\n", "    if (memcmp (c1, c2, r1)) return 0; /* file contents are different */\n", "  } while (r2);\n", "  \n", "  return 1;\n", "}\n"], "project": "fdupes", "file": "fdupes.pkl", "function": "confirmmatch"}, {"comment_all": {"comment": "/* leave it in safe state */", "depth": 1, "reading_ease": 117.16, "reading_grade": -1.9, "line": 220}, "comment_text": "/* leave it in safe state */", "comment_tokens": ["leave", "it", "in", "safe", "state"], "ccode": ["\n", "int\n", "ars_close(ROT *rot)\n", "{\n", "#ifdef HAVE_PTHREAD\n", "    struct ars_priv_data *priv = (struct ars_priv_data *)rot->state.priv;\n", "\n", "    pthread_cancel(priv->thread);\n", "#endif\n", "\n", "    /* leave it in safe state */\n", "    ars_stop(rot);\n", "\n", "    return RIG_OK;\n", "}\n"], "project": "libhamlib-doc", "file": "ars.pkl", "function": "ars_close"}, {"comment_all": {"comment": "/**\n * \\brief Free the data pointed to by condemned of the given size.\n *\n * \\param condemned Pointer to memory.\n * \\param size Number of bytes.\n */", "depth": 0, "reading_ease": 80.99, "reading_grade": 3.8, "line": 78}, "comment_text": "/**\n * \\brief Free the data pointed to by condemned of the given size.\n *\n * \\param condemned Pointer to memory.\n * \\param size Number of bytes.\n */", "comment_tokens": ["\\brief", "Free", "the", "data", "pointed", "to", "by", "condemned", "of", "the", "given", "size", ".", "\\param", "condemned", "Pointer", "to", "memory", ".", "\\param", "size", "Number", "of", "bytes", "."], "ccode": ["\n", "/**\n", " * \\brief Free the data pointed to by condemned of the given size.\n", " *\n", " * \\param condemned Pointer to memory.\n", " * \\param size Number of bytes.\n", " */\n", "void m4ri_mmc_free(void *condemned, size_t size) {\n", "#if __M4RI_ENABLE_MMC\n", "\n", "#if __M4RI_HAVE_OPENMP\n", "#pragma omp critical (mmc)\n", "  {\n", "#endif\n", "    static int j = 0;\n", "    mmb_t *mm = m4ri_mmc_cache;\n", "    if (size < __M4RI_MMC_THRESHOLD) {\n", "      for(int i = 0; i < __M4RI_MMC_NBLOCKS; ++i) {\n", "        if(mm[i].size == 0) {\n", "          mm[i].size = size;\n", "          mm[i].data = condemned;\n", "          goto done;\n", "        }\n", "      }\n", "      m4ri_mm_free(mm[j].data);\n", "      mm[j].size = size;\n", "      mm[j].data = condemned;\n", "      j = (j+1) % __M4RI_MMC_NBLOCKS;\n", "    } else {\n", "      m4ri_mm_free(condemned);\n", "    }\n", "  done:\n", "    ;\n", "#if __M4RI_HAVE_OPENMP\n", "  }\n", "#endif // __M4RI_HAVE_OPENMP\n", "#else // __M4RI_ENABLE_MMC\n", "  m4ri_mm_free(condemned);\n", "#endif // __M4RI_ENABLE_MMC\n", "}\n"], "project": "libm4ri-0.0.20200125", "file": "mmc.pkl", "function": "m4ri_mmc_free"}, {"comment_all": {"comment": "/* dl_iterate_phdr version.\t\t\t\t\t*/", "depth": 3, "reading_ease": -49.0, "reading_grade": 20.6, "line": 524}, "comment_text": "/* FIXME: The DT_DEBUG header is not mandated by the\t*/\n/* ELF spec.  This code appears to be dependent on\t\t*/\n/* idiosynchracies of older GNU tool chains.  If this code\t*/\n/* fails for you, the real problem is probably that it is\t*/\n/* being used at all.  You should be getting the \t\t*/\n/* dl_iterate_phdr version.\t\t\t\t\t*/\n", "comment_tokens": ["FIXME", ":", "The", "DT_DEBUG", "header", "is", "not", "mandated", "by", "the", "ELF", "spec", ".", "This", "code", "appears", "to", "be", "dependent", "on", "idiosynchracies", "of", "older", "GNU", "tool", "chains", ".", "If", "this", "code", "fails", "for", "you", ",", "the", "real", "problem", "is", "probably", "that", "it", "is", "being", "used", "at", "all", ".", "You", "should", "be", "getting", "the", "dl_iterate_phdr", "version", "."], "ccode": ["\n", "#define HAVE_REGISTER_MAIN_STATIC_DATA\n", "\n", "# else /* !LINUX || version(glibc) < 2.2.4 */\n", "\n", "/* Dynamic loading code for Linux running ELF. Somewhat tested on\n", " * Linux/x86, untested but hopefully should work on Linux/Alpha. \n", " * This code was derived from the Solaris/ELF support. Thanks to\n", " * whatever kind soul wrote that.  - Patrick Bridges */\n", "\n", "/* This doesn't necessarily work in all cases, e.g. with preloaded\n", " * dynamic libraries.\t\t\t\t\t\t*/\n", "\n", "#if defined(NETBSD) || defined(OPENBSD)\n", "# if !defined(OPENBSD)\n", "#  include <sys/exec_elf.h>\n", "# endif\n", "/* for compatibility with 1.4.x */\n", "#  ifndef DT_DEBUG\n", "#  define DT_DEBUG     21\n", "#  endif\n", "#  ifndef PT_LOAD\n", "#  define PT_LOAD      1\n", "#  endif\n", "#  ifndef PF_W\n", "#  define PF_W         2\n", "#  endif\n", "#else\n", "#  include <elf.h>\n", "#endif\n", "#include <link.h>\n", "\n", "# endif\n", "\n", "#ifdef __GNUC__\n", "# pragma weak _DYNAMIC\n", "#endif\n", "extern ElfW(Dyn) _DYNAMIC[];\n", "\n", "static struct link_map *\n", "GC_FirstDLOpenedLinkMap()\n", "{\n", "    ElfW(Dyn) *dp;\n", "    static struct link_map *cachedResult = 0;\n", "\n", "    if( _DYNAMIC == 0) {\n", "        return(0);\n", "    }\n", "    if( cachedResult == 0 ) {\n", "        int tag;\n", "        for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {\n", "\t    /* FIXME: The DT_DEBUG header is not mandated by the\t*/\n", "\t    /* ELF spec.  This code appears to be dependent on\t\t*/\n", "\t    /* idiosynchracies of older GNU tool chains.  If this code\t*/\n", "\t    /* fails for you, the real problem is probably that it is\t*/\n", "\t    /* being used at all.  You should be getting the \t\t*/\n", "\t    /* dl_iterate_phdr version.\t\t\t\t\t*/\n", "            if( tag == DT_DEBUG ) {\n", "                struct link_map *lm\n", "                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n", "                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n", "                break;\n", "            }\n", "        }\n", "    }\n", "    return cachedResult;\n", "}\n"], "project": "libmono-csharp4.0c-cil", "file": "dyn_load.pkl", "function": "GC_FirstDLOpenedLinkMap"}, {"comment_all": {"comment": "/*\n *\tMiscellaneous functions\n *\tCopyright Jan Engelhardt, 1999-2010\n *\n *\tThis file is part of libHX. libHX is free software; you can\n *\tredistribute it and/or modify it under the terms of the GNU Lesser\n *\tGeneral Public License as published by the Free Software Foundation;\n *\teither version 2.1 or (at your option) any later version.\n */", "depth": 0, "reading_ease": 54.52, "reading_grade": 9.8, "line": 0}, "comment_text": "/*\n *\tMiscellaneous functions\n *\tCopyright Jan Engelhardt, 1999-2010\n *\n *\tThis file is part of libHX. libHX is free software; you can\n *\tredistribute it and/or modify it under the terms of the GNU Lesser\n *\tGeneral Public License as published by the Free Software Foundation;\n *\teither version 2.1 or (at your option) any later version.\n */", "comment_tokens": ["Miscellaneous", "functions", "Copyright", "Jan", "Engelhardt", ",", "1999-2010", "This", "file", "is", "part", "of", "libHX", ".", "libHX", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "or", "(", "at", "your", "option", ")", "any", "later", "version", "."], "ccode": ["/*\n", " *\tMiscellaneous functions\n", " *\tCopyright Jan Engelhardt, 1999-2010\n", " *\n", " *\tThis file is part of libHX. libHX is free software; you can\n", " *\tredistribute it and/or modify it under the terms of the GNU Lesser\n", " *\tGeneral Public License as published by the Free Software Foundation;\n", " *\teither version 2.1 or (at your option) any later version.\n", " */\n", "#include <stdbool.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <libHX/ctype_helper.h>\n", "#include <libHX/misc.h>\n", "#include \"internal.h\"\n", "\n", "EXPORT_SYMBOL int HX_ffs(unsigned long n)\n", "{\n", "\tint s = 0;\n", "\tif (n == 0)\n", "\t\treturn -1;\n", "\twhile ((n >>= 1) >= 1)\n", "\t\t++s;\n", "\treturn s;\n", "}\n"], "project": "libhx-doc", "file": "misc.pkl", "function": "HX_ffs"}, {"comment_all": {"comment": "/****************************************************************************\nREMARKS:\nHandles opcode 0x0f,0x34\n****************************************************************************/", "depth": 0, "reading_ease": 50.5, "reading_grade": 7.2, "line": 454}, "comment_text": "/****************************************************************************\nREMARKS:\nHandles opcode 0x0f,0x34\n****************************************************************************/", "comment_tokens": ["REMARKS", ":", "Handles", "opcode", "0x0f,0x34"], "ccode": ["\n", "\n", "/****************************************************************************\n", "REMARKS:\n", "Handles opcode 0x0f,0x34\n", "****************************************************************************/\n", "static void x86emuOp2_sysenter(x86emu_t *emu, u8 op2)\n", "{\n", "  OP_DECODE(\"sysenter\");\n", "\n", "  // not implemented\n", "\n", "  INTR_RAISE_UD(emu);\n", "}\n"], "project": "libx86emu-dev", "file": "ops2.pkl", "function": "x86emuOp2_sysenter"}, {"comment_all": {"comment": "/* Each line starts in insert mode (the default). */", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 1131}, "comment_text": "/* Each line starts in insert mode (the default). */", "comment_tokens": ["Each", "line", "starts", "in", "insert", "mode", "(", "the", "default", ")", "."], "ccode": ["\n", "/* **************************************************************** */\n", "/*\t\t\t\t\t\t\t\t    */\n", "/*\t\t\tInitializations \t\t\t    */\n", "/*\t\t\t\t\t\t\t\t    */\n", "/* **************************************************************** */\n", "\n", "/* Initialize readline (and terminal if not already). */\n", "int\n", "rl_initialize (void)\n", "{\n", "  /* If we have never been called before, initialize the\n", "     terminal and data structures. */\n", "  if (rl_initialized == 0)\n", "    {\n", "      RL_SETSTATE(RL_STATE_INITIALIZING);\n", "      readline_initialize_everything ();\n", "      RL_UNSETSTATE(RL_STATE_INITIALIZING);\n", "      rl_initialized++;\n", "      RL_SETSTATE(RL_STATE_INITIALIZED);\n", "    }\n", "  else\n", "    (void)_rl_init_locale ();\t/* check current locale */\n", "\n", "  /* Initialize the current line information. */\n", "  _rl_init_line_state ();\n", "\n", "  /* We aren't done yet.  We haven't even gotten started yet! */\n", "  rl_done = 0;\n", "  RL_UNSETSTATE(RL_STATE_DONE);\n", "\n", "  /* Tell the history routines what is going on. */\n", "  _rl_start_using_history ();\n", "\n", "  /* Make the display buffer match the state of the line. */\n", "  rl_reset_line_state ();\n", "\n", "  /* No such function typed yet. */\n", "  rl_last_func = (rl_command_func_t *)NULL;\n", "\n", "  /* Parsing of key-bindings begins in an enabled state. */\n", "  _rl_parsing_conditionalized_out = 0;\n", "\n", "#if defined (VI_MODE)\n", "  if (rl_editing_mode == vi_mode)\n", "    _rl_vi_initialize_line ();\n", "#endif\n", "\n", "  /* Each line starts in insert mode (the default). */\n", "  _rl_set_insert_mode (RL_IM_DEFAULT, 1);\n", "\n", "  return 0;\n", "}\n"], "project": "bash-static", "file": "readline.pkl", "function": "rl_initialize"}, {"comment_all": {"comment": "/* terminate #(..) */", "depth": 2, "reading_ease": -47.99, "reading_grade": 20.2, "line": 1533}, "comment_text": "/* terminate #(..) */", "comment_tokens": ["terminate", "#", "(", "..", ")"], "ccode": ["\n", "\n", "static void act126()\n", "{ \n", "\t\tNLA = 59;\n", "\t\t\n", "\t\tif ( istackempty() )\n", "\t\tzzmore();\n", "\t\telse if ( topint()==')' ) {\n", "\t\t\tpopint();\n", "\t\t}\n", "\t\telse if ( topint()=='}' ) {\n", "\t\t\tpopint();\n", "\t\t\t/* terminate #(..) */\n", "\t\t\tzzreplstr(\", NULL)\");\n", "\t\t}\n", "\t\tzzmore();\n", "\t}\n"], "project": "cccc", "file": "scan.pkl", "function": "act126"}, {"comment_all": {"comment": "/*\n * Fake test allows debugging of the driver itself\n */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 0}, "comment_text": "/*\n * Fake test allows debugging of the driver itself\n */", "comment_tokens": ["Fake", "test", "allows", "debugging", "of", "the", "driver", "itself"], "ccode": ["/*\n", " * Fake test allows debugging of the driver itself\n", " */\n", " \n", "#include \"test.h\"\n", "\n", "static RESULT\n", "test_fake (void)\n", "{\n", "\treturn OK;\n", "}\n"], "project": "libmono-2.0-1", "file": "fake.pkl", "function": "test_fake"}, {"comment_all": {"comment": "/**\n * This function unpacks packed playlist data from the\n * NJB1. Not applicable for other jukeboxes.\n *\n * @param data a chunk of raw data to process\n * @param nbytes the size of the data chunk\n * @return a new playlist structure with correct name\n *         and all tracks added.\n */", "depth": 0, "reading_ease": 82.34, "reading_grade": 5.3, "line": 46}, "comment_text": "/**\n * This function unpacks packed playlist data from the\n * NJB1. Not applicable for other jukeboxes.\n *\n * @param data a chunk of raw data to process\n * @param nbytes the size of the data chunk\n * @return a new playlist structure with correct name\n *         and all tracks added.\n */", "comment_tokens": ["This", "function", "unpacks", "packed", "playlist", "data", "from", "the", "NJB1", ".", "Not", "applicable", "for", "other", "jukeboxes", ".", "@", "param", "data", "a", "chunk", "of", "raw", "data", "to", "process", "@", "param", "nbytes", "the", "size", "of", "the", "data", "chunk", "@", "return", "a", "new", "playlist", "structure", "with", "correct", "name", "and", "all", "tracks", "added", "."], "ccode": ["\n", "/**\n", " * This function unpacks packed playlist data from the\n", " * NJB1. Not applicable for other jukeboxes.\n", " *\n", " * @param data a chunk of raw data to process\n", " * @param nbytes the size of the data chunk\n", " * @return a new playlist structure with correct name\n", " *         and all tracks added.\n", " */\n", "njb_playlist_t *playlist_unpack(void *data, size_t nbytes)\n", "{\n", "  __dsub= \"playlist_unpack\";\n", "  unsigned char *dp= (unsigned char *) data;\n", "  size_t index;\n", "  njb_playlist_t *pl;\n", "  u_int32_t ntracks, i;\n", "  u_int16_t lname;\n", "\n", "  __enter;\n", "\n", "  pl = NJB_Playlist_New();\n", "  if ( pl == NULL ) {\n", "    __leave;\n", "    return NULL;\n", "  }\n", "\n", "  pl->plid = njb1_bytes_to_32bit(&dp[0]);\n", "  lname = njb1_bytes_to_16bit(&dp[4]);\n", "\n", "  if (njb_unicode_flag == NJB_UC_UTF8) {\n", "    char *utf8str = NULL;\n", "\n", "    utf8str = strtoutf8(&dp[6]);\n", "    if (utf8str == NULL) {\n", "      NJB_Playlist_Destroy(pl);\n", "      __leave;\n", "      return NULL;\n", "    }\n", "    pl->name = utf8str;\n", "  } else {\n", "    pl->name = strdup((char *) &dp[6]);\n", "    if ( pl->name == NULL ) {\n", "      NJB_Playlist_Destroy(pl);\n", "      __leave;\n", "      return NULL;\n", "    }\n", "  }\n", "\n", "  index = lname+12;\n", "  ntracks = njb1_bytes_to_32bit(&dp[index]);\n", "  index += 4;\n", "\n", "  for (i = 0; i<ntracks; i++) {\n", "    u_int32_t trackid;\n", "    njb_playlist_track_t *track;\n", "\n", "    index += 4;\n", "    trackid = njb1_bytes_to_32bit(&dp[index]);\n", "    index += 4;\n", "    if ( index > nbytes ) {\n", "      NJB_Playlist_Destroy(pl);\n", "      __leave;\n", "      return NULL;\n", "    }\n", "\n", "    track = NJB_Playlist_Track_New(trackid);\n", "    if ( track == NULL ) {\n", "      NJB_Playlist_Destroy(pl);\n", "      __leave;\n", "      return NULL;\n", "    }\n", "\n", "    NJB_Playlist_Addtrack(pl, track, NJB_PL_END);\n", "  }\n", "\n", "  pl->_state = NJB_PL_UNCHANGED;\n", "  __leave;\n", "  return pl;\n", "}\n"], "project": "libnjb-dev", "file": "playlist.pkl", "function": "playlist_unpack"}, {"comment_all": {"comment": "/* we write it directly, so we should never see it here. */", "depth": 2, "reading_ease": 85.69, "reading_grade": 4.0, "line": 143}, "comment_text": "/* ignore it (keyring.c does write it directly)*/\n/* we write it directly, so we should never see it here. */\n", "comment_tokens": ["ignore", "it", "(", "keyring.c", "does", "write", "it", "directly", ")", "we", "write", "it", "directly", ",", "so", "we", "should", "never", "see", "it", "here", "."], "ccode": ["/* build-packet.c - assemble packets and write them\n", " * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n", " *               2006 Free Software Foundation, Inc.\n", " *\n", " * This file is part of GnuPG.\n", " *\n", " * GnuPG is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 3 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * GnuPG is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, see <http://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include <config.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <assert.h>\n", "#include <ctype.h>\n", "\n", "#include \"packet.h\"\n", "#include \"errors.h\"\n", "#include \"iobuf.h\"\n", "#include \"mpi.h\"\n", "#include \"util.h\"\n", "#include \"cipher.h\"\n", "#include \"memory.h\"\n", "#include \"i18n.h\"\n", "#include \"options.h\"\n", "#include \"../include/host2net.h\"\n", "\n", "static int do_user_id( IOBUF out, int ctb, PKT_user_id *uid );\n", "static int do_public_key( IOBUF out, int ctb, PKT_public_key *pk );\n", "static int do_secret_key( IOBUF out, int ctb, PKT_secret_key *pk );\n", "static int do_symkey_enc( IOBUF out, int ctb, PKT_symkey_enc *enc );\n", "static int do_pubkey_enc( IOBUF out, int ctb, PKT_pubkey_enc *enc );\n", "static u32 calc_plaintext( PKT_plaintext *pt );\n", "static int do_plaintext( IOBUF out, int ctb, PKT_plaintext *pt );\n", "static int do_encrypted( IOBUF out, int ctb, PKT_encrypted *ed );\n", "static int do_encrypted_mdc( IOBUF out, int ctb, PKT_encrypted *ed );\n", "static int do_compressed( IOBUF out, int ctb, PKT_compressed *cd );\n", "static int do_signature( IOBUF out, int ctb, PKT_signature *sig );\n", "static int do_onepass_sig( IOBUF out, int ctb, PKT_onepass_sig *ops );\n", "\n", "static int calc_header_length( u32 len, int new_ctb );\n", "static int write_16(IOBUF inp, u16 a);\n", "static int write_32(IOBUF inp, u32 a);\n", "static int write_header( IOBUF out, int ctb, u32 len );\n", "static int write_sign_packet_header( IOBUF out, int ctb, u32 len );\n", "static int write_header2( IOBUF out, int ctb, u32 len, int hdrlen );\n", "static int write_new_header( IOBUF out, int ctb, u32 len, int hdrlen );\n", "static int write_version( IOBUF out, int ctb );\n", "\n", "/****************\n", " * Build a packet and write it to INP\n", " * Returns: 0 := okay\n", " *\t   >0 := error\n", " * Note: Caller must free the packet\n", " */\n", "int\n", "build_packet( IOBUF out, PACKET *pkt )\n", "{\n", "    int new_ctb=0, rc=0, ctb;\n", "    int pkttype;\n", "\n", "    if( DBG_PACKET )\n", "\tlog_debug(\"build_packet() type=%d\\n\", pkt->pkttype );\n", "    assert( pkt->pkt.generic );\n", "\n", "    switch( (pkttype = pkt->pkttype) )\n", "      {\n", "      case PKT_PLAINTEXT: new_ctb = pkt->pkt.plaintext->new_ctb; break;\n", "      case PKT_ENCRYPTED:\n", "      case PKT_ENCRYPTED_MDC: new_ctb = pkt->pkt.encrypted->new_ctb; break;\n", "      case PKT_COMPRESSED:new_ctb = pkt->pkt.compressed->new_ctb; break;\n", "      case PKT_USER_ID:\n", "\tif( pkt->pkt.user_id->attrib_data )\n", "\t  pkttype = PKT_ATTRIBUTE;\n", "\tbreak;\n", "      default: break;\n", "      }\n", "\n", "    if( new_ctb || pkttype > 15 ) /* new format */\n", "\tctb = 0xc0 | (pkttype & 0x3f);\n", "    else\n", "\tctb = 0x80 | ((pkttype & 15)<<2);\n", "    switch( pkttype )\n", "      {\n", "      case PKT_ATTRIBUTE:\n", "      case PKT_USER_ID:\n", "\trc = do_user_id( out, ctb, pkt->pkt.user_id );\n", "\tbreak;\n", "      case PKT_OLD_COMMENT:\n", "      case PKT_COMMENT:\n", "\t/*\n", "\t  Ignore these.  Theoretically, this will never be called as\n", "\t  we have no way to output comment packets any longer, but\n", "\t  just in case there is some code path that would end up\n", "\t  outputting a comment that was written before comments were\n", "\t  dropped (in the public key?) this is a no-op.\n", "\t*/\n", "\tbreak;\n", "      case PKT_PUBLIC_SUBKEY:\n", "      case PKT_PUBLIC_KEY:\n", "\trc = do_public_key( out, ctb, pkt->pkt.public_key );\n", "\tbreak;\n", "      case PKT_SECRET_SUBKEY:\n", "      case PKT_SECRET_KEY:\n", "\trc = do_secret_key( out, ctb, pkt->pkt.secret_key );\n", "\tbreak;\n", "      case PKT_SYMKEY_ENC:\n", "\trc = do_symkey_enc( out, ctb, pkt->pkt.symkey_enc );\n", "\tbreak;\n", "      case PKT_PUBKEY_ENC:\n", "\trc = do_pubkey_enc( out, ctb, pkt->pkt.pubkey_enc );\n", "\tbreak;\n", "      case PKT_PLAINTEXT:\n", "\trc = do_plaintext( out, ctb, pkt->pkt.plaintext );\n", "\tbreak;\n", "      case PKT_ENCRYPTED:\n", "\trc = do_encrypted( out, ctb, pkt->pkt.encrypted );\n", "\tbreak;\n", "      case PKT_ENCRYPTED_MDC:\n", "\trc = do_encrypted_mdc( out, ctb, pkt->pkt.encrypted );\n", "\tbreak;\n", "      case PKT_COMPRESSED:\n", "\trc = do_compressed( out, ctb, pkt->pkt.compressed );\n", "\tbreak;\n", "      case PKT_SIGNATURE:\n", "\trc = do_signature( out, ctb, pkt->pkt.signature );\n", "\tbreak;\n", "      case PKT_ONEPASS_SIG:\n", "\trc = do_onepass_sig( out, ctb, pkt->pkt.onepass_sig );\n", "\tbreak;\n", "      case PKT_RING_TRUST:\n", "\tbreak; /* ignore it (keyring.c does write it directly)*/\n", "      case PKT_MDC: /* we write it directly, so we should never see it here. */\n", "      default:\n", "\tlog_bug(\"invalid packet type in build_packet()\\n\");\n", "\tbreak;\n", "      }\n", "\n", "    return rc;\n", "}\n"], "project": "gpgv1", "file": "build-packet.pkl", "function": "build_packet"}, {"comment_all": {"comment": "/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */", "depth": 1, "reading_ease": 53.55, "reading_grade": 12.3, "line": 4103}, "comment_text": "/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */", "comment_tokens": ["The", "cast", "to", "(", "char", ")", "in", "the", "following", "accommodates", "both", "implementations", "that", "use", "char", "generic", "pointers", ",", "and", "those", "that", "use", "void", "generic", "pointers", ".", "It", "works", "with", "the", "latter", "because", "both", "ANSI", "C", "and", "C++", "allow", "castless", "assignment", "from", "any", "pointer", "type", "to", "void", ",", "and", "deal", "with", "argument", "conversions", "as", "though", "doing", "an", "assignment", "."], "ccode": ["\n", "void *yyrealloc  (void * ptr, yy_size_t  size )\n", "{\n", "\t\t\n", "\t/* The cast to (char *) in the following accommodates both\n", "\t * implementations that use char* generic pointers, and those\n", "\t * that use void* generic pointers.  It works with the latter\n", "\t * because both ANSI C and C++ allow castless assignment from\n", "\t * any pointer type to void*, and deal with argument conversions\n", "\t * as though doing an assignment.\n", "\t */\n", "\treturn realloc(ptr, size);\n", "}\n"], "project": "linux-cloud-tools-5.11.0-1020-azure", "file": "lexer.lex.pkl", "function": "yyrealloc"}, {"comment_all": {"comment": "/* casting the USER_DATA pointer to osm_helper */", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 88}, "comment_text": "/* casting the USER_DATA pointer to osm_helper */", "comment_tokens": ["casting", "the", "USER_DATA", "pointer", "to", "osm_helper"], "ccode": ["\n", "static int\n", "parse_way (const void *user_data, const readosm_way * way)\n", "{\n", "/* parsing a Way (callback function)*/\n", "\n", "    /* casting the USER_DATA pointer to osm_helper */\n", "    struct osm_helper *helper = (struct osm_helper *) user_data;\n", "\n", "    if (way != NULL)\n", "\tway = NULL;\t\t/* silencing stupid compiler warnings */\n", "\n", "    helper->read_count++;\n", "    if (eval_abort (helper))\n", "\treturn READOSM_ABORT;\n", "    printf (\"Way#%d\\n\", helper->read_count);\n", "    return READOSM_OK;\n", "}\n"], "project": "libreadosm-doc", "file": "test_osm3.pkl", "function": "parse_way"}, {"comment_all": {"comment": "/* They forgot to leave room for the EOB's. */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 3837}, "comment_text": "/* They forgot to leave room for the EOB's. */", "comment_tokens": ["They", "forgot", "to", "leave", "room", "for", "the", "EOB", "'s", "."], "ccode": ["\n", "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n", " * @param base the character buffer\n", " * @param size the size in bytes of the character buffer\n", " * \n", " * @return the newly allocated buffer state object.\n", " */\n", "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "    \n", "\tif ( size < 2 ||\n", "\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n", "\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n", "\t\t/* They forgot to leave room for the EOB's. */\n", "\t\treturn NULL;\n", "\n", "\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n", "\n", "\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n", "\tb->yy_buf_pos = b->yy_ch_buf = base;\n", "\tb->yy_is_our_buffer = 0;\n", "\tb->yy_input_file = NULL;\n", "\tb->yy_n_chars = b->yy_buf_size;\n", "\tb->yy_is_interactive = 0;\n", "\tb->yy_at_bol = 1;\n", "\tb->yy_fill_buffer = 0;\n", "\tb->yy_buffer_status = YY_BUFFER_NEW;\n", "\n", "\tyy_switch_to_buffer( b  );\n", "\n", "\treturn b;\n", "}\n"], "project": "linux-azure-5.11-headers-5.11.0-1027", "file": "lexer.lex.pkl", "function": "yy_scan_buffer"}, {"comment_all": {"comment": "/**\n * Makes a workspace the active one\n */", "depth": 0, "reading_ease": 99.23, "reading_grade": 0.9, "line": 723}, "comment_text": "/**\n * Makes a workspace the active one\n */", "comment_tokens": ["Makes", "a", "workspace", "the", "active", "one"], "ccode": ["\n", "\n", "\n", "\n", "/**\n", " * Makes a workspace the active one\n", " */\n", "int c_change_workspace(lua_State *lua)\n", "{\n", "\tint top = lua_gettop(lua);\n", "\tGTimeVal timestamp;\n", "\n", "\tif (top != 1) {\n", "\t\tluaL_error(lua,\"change_workspace: %s\", one_indata_expected_error);\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tint type = lua_type(lua, 1);\n", "\n", "\tif (type!=LUA_TNUMBER) {\n", "\t\tluaL_error(lua,\"change_workspace: %s\", number_expected_as_indata_error);\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tint number = lua_tonumber(lua, 1);\n", "\n", "\tWnckWindow *window = get_current_window();\n", "\tif (window) {\n", "\t\tWnckScreen *screen;\n", "\t\tWnckWorkspace *workspace;\n", "\n", "\t\tscreen = wnck_window_get_screen(window);\n", "\t\tworkspace = wnck_screen_get_workspace(screen, number-1);\n", "\n", "\t\tif (!workspace) {\n", "\t\t\tg_warning(_(\"Workspace number %d does not exist!\"), number);\n", "\t\t}\n", "\n", "\t\tg_get_current_time(&timestamp);\n", "\t\tif (!devilspie2_emulate) {\n", "\t\t\twnck_workspace_activate(workspace, timestamp.tv_sec);\n", "\t\t}\n", "\t}\n", "\n", "\tlua_pushboolean(lua, TRUE);\n", "\n", "\treturn 1;\n", "}\n"], "project": "devilspie2", "file": "script_functions.pkl", "function": "c_change_workspace"}, {"comment_all": {"comment": "/* I hold the allocation lock.\tNormally called by collector.\t\t*/", "depth": 0, "reading_ease": 49.99, "reading_grade": 7.4, "line": 991}, "comment_text": "/* This assumes that all accessible objects are marked, and that\t*/\n/* I hold the allocation lock.\tNormally called by collector.\t\t*/\n", "comment_tokens": ["This", "assumes", "that", "all", "accessible", "objects", "are", "marked", ",", "and", "that", "I", "hold", "the", "allocation", "lock", ".", "Normally", "called", "by", "collector", "."], "ccode": ["\n", "\n", "/* This assumes that all accessible objects are marked, and that\t*/\n", "/* I hold the allocation lock.\tNormally called by collector.\t\t*/\n", "void GC_check_heap_proc()\n", "{\n", "#   ifndef SMALL_CONFIG\n", "#     ifdef ALIGN_DOUBLE\n", "        GC_STATIC_ASSERT((sizeof(oh) & (2 * sizeof(word) - 1)) == 0);\n", "#     else\n", "        GC_STATIC_ASSERT((sizeof(oh) & (sizeof(word) - 1)) == 0);\n", "#     endif\n", "#   endif\n", "    GC_apply_to_all_blocks(GC_check_heap_block, (word)0);\n", "}\n"], "project": "libmono-system-runtime4.0-cil", "file": "dbg_mlc.pkl", "function": "GC_check_heap_proc"}, {"comment_all": {"comment": "/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */", "depth": 0, "reading_ease": 45.93, "reading_grade": 9.0, "line": 1532}, "comment_text": "/*\n * Turn a multi-byte string into a wide character string.\n * Return it in allocated memory (NULL for out-of-memory)\n */", "comment_tokens": ["Turn", "a", "multi-byte", "string", "into", "a", "wide", "character", "string", ".", "Return", "it", "in", "allocated", "memory", "(", "NULL", "for", "out-of-memory", ")"], "ccode": ["\n", "/*\n", " * Turn a multi-byte string into a wide character string.\n", " * Return it in allocated memory (NULL for out-of-memory)\n", " */\n", "    static int *\n", "mb_str2wide(char_u *s)\n", "{\n", "    int\t\t*res;\n", "    char_u\t*p;\n", "    int\t\ti = 0;\n", "\n", "    res = ALLOC_MULT(int, mb_charlen(s) + 1);\n", "    if (res != NULL)\n", "    {\n", "\tfor (p = s; *p != NUL; )\n", "\t    res[i++] = mb_ptr2char_adv(&p);\n", "\tres[i] = NUL;\n", "    }\n", "    return res;\n", "}\n"], "project": "vim-athena", "file": "spellfile.pkl", "function": "mb_str2wide"}, {"comment_all": {"comment": "/*---------------------------------------------------------------------------*\\\n** $Author: saulius $\n** $Date: 2015-07-21 17:39:27 +0300 (Tue, 21 Jul 2015) $ \n** $Revision: 3587 $\n** $URL: svn://www.crystallography.net/cod-tools/tags/v2.10/src/externals/cexceptions/cexceptions.c $\n\\*---------------------------------------------------------------------------*/", "depth": 0, "reading_ease": -10.42, "reading_grade": 18.2, "line": 4}, "comment_text": "/*---------------------------------------------------------------------------*\\\n** $Author: saulius $\n** $Date: 2015-07-21 17:39:27 +0300 (Tue, 21 Jul 2015) $ \n** $Revision: 3587 $\n** $URL: svn://www.crystallography.net/cod-tools/tags/v2.10/src/externals/cexceptions/cexceptions.c $\n\\*---------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-\\", "$", "Author", ":", "saulius", "$", "$", "Date", ":", "2015-07-21", "17:39:27", "+0300", "(", "Tue", ",", "21", "Jul", "2015", ")", "$", "$", "Revision", ":", "3587", "$", "$", "URL", ":", "svn", ":", "www.crystallography.netcod-toolstagsv2.10srcexternalscexceptionscexceptions.c", "$", "\\", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["/*---------------------------------------------------------------------------*\\\n", "** $Author: saulius $\n", "** $Date: 2015-07-21 17:39:27 +0300 (Tue, 21 Jul 2015) $ \n", "** $Revision: 3587 $\n", "** $URL: svn://www.crystallography.net/cod-tools/tags/v2.10/src/externals/cexceptions/cexceptions.c $\n", "\\*---------------------------------------------------------------------------*/\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h> /* for 'exit()' */\n", "#include <string.h>\n", "#include <assert.h>\n", "#include <cexceptions.h>\n", "\n", "int cexception_init( cexception_t *ex )\n", "{\n", "    assert( ex );\n", "    memset( ex, 0, sizeof(*ex));\n", "    return 1;\n", "}\n"], "project": "cod-tools", "file": "cexceptions.pkl", "function": "cexception_init"}, {"comment_all": {"comment": "/* Adjust a file descriptor result so that it avoids clobbering\n   STD{IN,OUT,ERR}_FILENO, with specific flags.\n\n   Copyright (C) 2005-2006, 2009-2019 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */*/\n", "depth": 0, "reading_ease": 53.92, "reading_grade": 10.0, "line": 16}, "comment_text": "/* Adjust a file descriptor result so that it avoids clobbering\n   STD{IN,OUT,ERR}_FILENO, with specific flags.\n\n   Copyright (C) 2005-2006, 2009-2019 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */*/\n", "comment_tokens": ["Adjust", "a", "file", "descriptor", "result", "so", "that", "it", "avoids", "clobbering", "STD", "{", "IN", ",", "OUT", ",", "ERR", "}", "_FILENO", ",", "with", "specific", "flags", ".", "Copyright", "(", "C", ")", "2005-2006", ",", "2009-2019", "Free", "Software", "Foundation", ",", "Inc", ".", "This", "program", "is", "free", "software", ":", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ".", "If", "not", ",", "see", "<", "https", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/* Adjust a file descriptor result so that it avoids clobbering\n", "   STD{IN,OUT,ERR}_FILENO, with specific flags.\n", "\n", "   Copyright (C) 2005-2006, 2009-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "/* Written by Paul Eggert and Eric Blake.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"unistd-safer.h\"\n", "\n", "#include <errno.h>\n", "#include <unistd.h>\n", "\n", "/* Return FD, unless FD would be a copy of standard input, output, or\n", "   error; in that case, return a duplicate of FD, closing FD.  If FLAG\n", "   contains O_CLOEXEC, the returned FD will have close-on-exec\n", "   semantics.  On failure to duplicate, close FD, set errno, and\n", "   return -1.  Preserve errno if FD is negative, so that the caller\n", "   can always inspect errno when the returned value is negative.\n", "\n", "   This function is usefully wrapped around functions that return file\n", "   descriptors, e.g., fd_safer_flag (open (\"file\", O_RDONLY | flag), flag).  */\n", "\n", "int\n", "fd_safer_flag (int fd, int flag)\n", "{\n", "  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n", "    {\n", "      int f = dup_safer_flag (fd, flag);\n", "      int e = errno;\n", "      close (fd);\n", "      errno = e;\n", "      fd = f;\n", "    }\n", "\n", "  return fd;\n", "}\n"], "project": "grub-common", "file": "fd-safer-flag.pkl", "function": "fd_safer_flag"}, {"comment_all": {"comment": "/*@=varuse =charint =ignoresigns @*/", "depth": 0, "reading_ease": 59.97, "reading_grade": 5.6, "line": 21}, "comment_text": "/*@=varuse =charint =ignoresigns @*/", "comment_tokens": ["@", "=varuse", "=charint", "=ignoresigns", "@"], "ccode": ["/*@=varuse =charint =ignoresigns @*/\n", "\n", "const char *\n", "POPT_prev_char (const char *str)\n", "{\n", "    const char *p = str;\n", "\n", "    while (1) {\n", "\tp--;\n", "\tif (((unsigned)*p & 0xc0) != (unsigned)0x80)\n", "\t    return p;\n", "    }\n", "}\n"], "project": "libpopt-dev", "file": "poptint.pkl", "function": "POPT_prev_char"}, {"comment_all": {"comment": "/* probability of tristate = m */", "depth": 1, "reading_ease": 8.2, "reading_grade": 13.1, "line": 181}, "comment_text": "/* probability of bool     = y */\n/* probability of tristate = y */\n/* probability of tristate = m */\n", "comment_tokens": ["probability", "of", "bool", "=", "y", "probability", "of", "tristate", "=", "y", "probability", "of", "tristate", "=", "m"], "ccode": ["\n", "static bool conf_set_all_new_symbols(enum conf_def_mode mode)\n", "{\n", "\tstruct symbol *sym, *csym;\n", "\tint i, cnt;\n", "\t/*\n", "\t * can't go as the default in switch-case below, otherwise gcc whines\n", "\t * about -Wmaybe-uninitialized\n", "\t */\n", "\tint pby = 50; /* probability of bool     = y */\n", "\tint pty = 33; /* probability of tristate = y */\n", "\tint ptm = 33; /* probability of tristate = m */\n", "\tbool has_changed = false;\n", "\n", "\tif (mode == def_random) {\n", "\t\tint n, p[3];\n", "\t\tchar *env = getenv(\"KCONFIG_PROBABILITY\");\n", "\n", "\t\tn = 0;\n", "\t\twhile (env && *env) {\n", "\t\t\tchar *endp;\n", "\t\t\tint tmp = strtol(env, &endp, 10);\n", "\n", "\t\t\tif (tmp >= 0 && tmp <= 100) {\n", "\t\t\t\tp[n++] = tmp;\n", "\t\t\t} else {\n", "\t\t\t\terrno = ERANGE;\n", "\t\t\t\tperror(\"KCONFIG_PROBABILITY\");\n", "\t\t\t\texit(1);\n", "\t\t\t}\n", "\t\t\tenv = (*endp == ':') ? endp + 1 : endp;\n", "\t\t\tif (n >= 3)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\tswitch (n) {\n", "\t\tcase 1:\n", "\t\t\tpby = p[0];\n", "\t\t\tptm = pby / 2;\n", "\t\t\tpty = pby - ptm;\n", "\t\t\tbreak;\n", "\t\tcase 2:\n", "\t\t\tpty = p[0];\n", "\t\t\tptm = p[1];\n", "\t\t\tpby = pty + ptm;\n", "\t\t\tbreak;\n", "\t\tcase 3:\n", "\t\t\tpby = p[0];\n", "\t\t\tpty = p[1];\n", "\t\t\tptm = p[2];\n", "\t\t\tbreak;\n", "\t\t}\n", "\n", "\t\tif (pty + ptm > 100) {\n", "\t\t\terrno = ERANGE;\n", "\t\t\tperror(\"KCONFIG_PROBABILITY\");\n", "\t\t\texit(1);\n", "\t\t}\n", "\t}\n", "\n", "\tfor_all_symbols(i, sym) {\n", "\t\tif (sym_has_value(sym) || sym->flags & SYMBOL_VALID)\n", "\t\t\tcontinue;\n", "\t\tswitch (sym_get_type(sym)) {\n", "\t\tcase S_BOOLEAN:\n", "\t\tcase S_TRISTATE:\n", "\t\t\thas_changed = true;\n", "\t\t\tswitch (mode) {\n", "\t\t\tcase def_yes:\n", "\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n", "\t\t\t\tbreak;\n", "\t\t\tcase def_mod:\n", "\t\t\t\tsym->def[S_DEF_USER].tri = mod;\n", "\t\t\t\tbreak;\n", "\t\t\tcase def_no:\n", "\t\t\t\tsym->def[S_DEF_USER].tri = no;\n", "\t\t\t\tbreak;\n", "\t\t\tcase def_random:\n", "\t\t\t\tsym->def[S_DEF_USER].tri = no;\n", "\t\t\t\tcnt = rand() % 100;\n", "\t\t\t\tif (sym->type == S_TRISTATE) {\n", "\t\t\t\t\tif (cnt < pty)\n", "\t\t\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n", "\t\t\t\t\telse if (cnt < pty + ptm)\n", "\t\t\t\t\t\tsym->def[S_DEF_USER].tri = mod;\n", "\t\t\t\t} else if (cnt < pby)\n", "\t\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\tif (!(sym_is_choice(sym) && mode == def_random))\n", "\t\t\t\tsym->flags |= SYMBOL_DEF_USER;\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tbreak;\n", "\t\t}\n", "\n", "\t}\n", "\n", "\tsym_clear_all_valid();\n", "\n", "\t/*\n", "\t * We have different type of choice blocks.\n", "\t * If curr.tri equals to mod then we can select several\n", "\t * choice symbols in one block.\n", "\t * In this case we do nothing.\n", "\t * If curr.tri equals yes then only one symbol can be\n", "\t * selected in a choice block and we set it to yes,\n", "\t * and the rest to no.\n", "\t */\n", "\tif (mode != def_random) {\n", "\t\tfor_all_symbols(i, csym) {\n", "\t\t\tif ((sym_is_choice(csym) && !sym_has_value(csym)) ||\n", "\t\t\t    sym_is_choice_value(csym))\n", "\t\t\t\tcsym->flags |= SYMBOL_NEED_SET_CHOICE_VALUES;\n", "\t\t}\n", "\t}\n", "\n", "\tfor_all_symbols(i, csym) {\n", "\t\tif (sym_has_value(csym) || !sym_is_choice(csym))\n", "\t\t\tcontinue;\n", "\n", "\t\tsym_calc_value(csym);\n", "\t\tif (mode == def_random)\n", "\t\t\thas_changed |= randomize_choice_values(csym);\n", "\t\telse {\n", "\t\t\tset_all_choice_values(csym);\n", "\t\t\thas_changed = true;\n", "\t\t}\n", "\t}\n", "\n", "\treturn has_changed;\n", "}\n"], "project": "linux-buildinfo-5.13.0-1010-oem", "file": "conf.pkl", "function": "conf_set_all_new_symbols"}, {"comment_all": {"comment": "/* Some systems do not provide an id. nic_ctr provides an artificial\n\t * id, and assumes the records will be provided \"in order\".  Also,\n\t * using 0xFF marker is not future proof. 256 NICs is a lot, but\n\t * 640K ought to be enough for anybody(said no one, ever).\n\t * */", "depth": 1, "reading_ease": 76.93, "reading_grade": 5.3, "line": 123}, "comment_text": "/* Some systems do not provide an id. nic_ctr provides an artificial\n\t * id, and assumes the records will be provided \"in order\".  Also,\n\t * using 0xFF marker is not future proof. 256 NICs is a lot, but\n\t * 640K ought to be enough for anybody(said no one, ever).\n\t * */", "comment_tokens": ["Some", "systems", "do", "not", "provide", "an", "id", ".", "nic_ctr", "provides", "an", "artificial", "id", ",", "and", "assumes", "the", "records", "will", "be", "provided", "``", "in", "order", "''", ".", "Also", ",", "using", "0xFF", "marker", "is", "not", "future", "proof", ".", "256", "NICs", "is", "a", "lot", ",", "but", "640K", "ought", "to", "be", "enough", "for", "anybody", "(", "said", "no", "one", ",", "ever", ")", "."], "ccode": ["\n", "/*\n", " * HPE-specific data structures are decoded here.\n", " *\n", " * Code contributed by John Cagle and Tyler Bell.\n", " */\n", "\n", "static void dmi_print_hp_net_iface_rec(u8 id, u8 bus, u8 dev, const u8 *mac)\n", "{\n", "\t/* Some systems do not provide an id. nic_ctr provides an artificial\n", "\t * id, and assumes the records will be provided \"in order\".  Also,\n", "\t * using 0xFF marker is not future proof. 256 NICs is a lot, but\n", "\t * 640K ought to be enough for anybody(said no one, ever).\n", "\t * */\n", "\tstatic u8 nic_ctr;\n", "\n", "\tif (id == 0xFF)\n", "\t\tid = ++nic_ctr;\n", "\n", "\tif (dev == 0x00 && bus == 0x00)\n", "\t\tprintf(\"\\tNIC %d: Disabled\\n\", id);\n", "\telse if (dev == 0xFF && bus == 0xFF)\n", "\t\tprintf(\"\\tNIC %d: Not Installed\\n\", id);\n", "\telse\n", "\t{\n", "\t\tprintf(\"\\tNIC %d: PCI device %02x:%02x.%x, \"\n", "\t\t\t\"MAC address %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n", "\t\t\tid, bus, dev >> 3, dev & 7,\n", "\t\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n", "\t}\n", "}\n"], "project": "dmidecode", "file": "dmioem.pkl", "function": "dmi_print_hp_net_iface_rec"}, {"comment_all": {"comment": "/*\n * Sampling interval in enery space to beats-per-minute\n */", "depth": 0, "reading_ease": 38.99, "reading_grade": 9.6, "line": 111}, "comment_text": "/*\n * Sampling interval in enery space to beats-per-minute\n */", "comment_tokens": ["Sampling", "interval", "in", "enery", "space", "to", "beats-per-minute"], "ccode": ["\n", "/*\n", " * Sampling interval in enery space to beats-per-minute\n", " */\n", "\n", "double interval_to_bpm(double interval)\n", "{\n", "\tdouble samples_per_beat, beats_per_second;\n", "\n", "\tsamples_per_beat = interval * INTERVAL;\n", "\tbeats_per_second = (double)RATE / samples_per_beat;\n", "\treturn beats_per_second * 60;\n", "}\n"], "project": "bpm-tools", "file": "bpm.pkl", "function": "interval_to_bpm"}, {"comment_all": {"comment": "/* cdb_make.c: basic cdb creation routines\n *\n * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n * Public domain.\n */", "depth": 0, "reading_ease": 60.65, "reading_grade": 9.5, "line": 0}, "comment_text": "/* cdb_make.c: basic cdb creation routines\n *\n * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n * Public domain.\n */", "comment_tokens": ["cdb_make.c", ":", "basic", "cdb", "creation", "routines", "This", "file", "is", "a", "part", "of", "tinycdb", "package", "by", "Michael", "Tokarev", ",", "mjt", "@", "corpit.ru", ".", "Public", "domain", "."], "ccode": ["/* cdb_make.c: basic cdb creation routines\n", " *\n", " * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n", " * Public domain.\n", " */\n", "\n", "#include <unistd.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"cdb_int.h\"\n", "\n", "void\n", "cdb_pack(unsigned num, unsigned char buf[4])\n", "{\n", "  buf[0] = num & 255; num >>= 8;\n", "  buf[1] = num & 255; num >>= 8;\n", "  buf[2] = num & 255;\n", "  buf[3] = num >> 8;\n", "}\n"], "project": "libcdb-dev", "file": "cdb_make.pkl", "function": "cdb_pack"}, {"comment_all": {"comment": "/* It is not safe to assume that a binary zero corresponds\n     to a floating-point 0.0, so initialize floats explicitly.  */", "depth": 1, "reading_ease": 53.37, "reading_grade": 8.2, "line": 40}, "comment_text": "/* It is not safe to assume that a binary zero corresponds\n     to a floating-point 0.0, so initialize floats explicitly.  */", "comment_tokens": ["It", "is", "not", "safe", "to", "assume", "that", "a", "binary", "zero", "corresponds", "to", "a", "floating-point", "0.0", ",", "so", "initialize", "floats", "explicitly", "."], "ccode": ["/* symtab.c\n", "\n", "   Copyright (C) 1999-2020 Free Software Foundation, Inc.\n", "\n", "   This file is part of GNU Binutils.\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software\n", "   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n", "   02110-1301, USA.  */\n", "\f\n", "#include \"gprof.h\"\n", "#include \"search_list.h\"\n", "#include \"source.h\"\n", "#include \"symtab.h\"\n", "#include \"cg_arcs.h\"\n", "#include \"corefile.h\"\n", "\n", "static int cmp_addr (const PTR, const PTR);\n", "\n", "Sym_Table symtab;\n", "\n", "\n", "/* Initialize a symbol (so it's empty).  */\n", "\n", "void\n", "sym_init (Sym *sym)\n", "{\n", "  memset (sym, 0, sizeof (*sym));\n", "\n", "  /* It is not safe to assume that a binary zero corresponds\n", "     to a floating-point 0.0, so initialize floats explicitly.  */\n", "  sym->hist.time = 0.0;\n", "  sym->cg.child_time = 0.0;\n", "  sym->cg.prop.fract = 0.0;\n", "  sym->cg.prop.self = 0.0;\n", "  sym->cg.prop.child = 0.0;\n", "}\n"], "project": "binutils-x86-64-linux-gnu", "file": "symtab.pkl", "function": "sym_init"}, {"comment_all": {"comment": "/**\n * Sign data with DSA\n *\n * \\param[in] to_sign The ldns_buffer containing raw data that is\n *                    to be signed\n * \\param[in] key The DSA key structure to sign with\n * \\return ldns_rdf for the RRSIG ldns_rr\n */", "depth": 0, "reading_ease": 73.85, "reading_grade": 10.7, "line": 322}, "comment_text": "/**\n * Sign data with DSA\n *\n * \\param[in] to_sign The ldns_buffer containing raw data that is\n *                    to be signed\n * \\param[in] key The DSA key structure to sign with\n * \\return ldns_rdf for the RRSIG ldns_rr\n */", "comment_tokens": ["Sign", "data", "with", "DSA", "\\param", "[", "in", "]", "to_sign", "The", "ldns_buffer", "containing", "raw", "data", "that", "is", "to", "be", "signed", "\\param", "[", "in", "]", "key", "The", "DSA", "key", "structure", "to", "sign", "with", "\\return", "ldns_rdf", "for", "the", "RRSIG", "ldns_rr"], "ccode": ["\n", "/**\n", " * Sign data with DSA\n", " *\n", " * \\param[in] to_sign The ldns_buffer containing raw data that is\n", " *                    to be signed\n", " * \\param[in] key The DSA key structure to sign with\n", " * \\return ldns_rdf for the RRSIG ldns_rr\n", " */\n", "ldns_rdf *\n", "ldns_sign_public_dsa(ldns_buffer *to_sign, DSA *key)\n", "{\n", "#ifdef USE_DSA\n", "\tunsigned char *sha1_hash;\n", "\tldns_rdf *sigdata_rdf;\n", "\tldns_buffer *b64sig;\n", "\n", "\tDSA_SIG *sig;\n", "\tconst BIGNUM *R, *S;\n", "\tuint8_t *data;\n", "\tsize_t pad;\n", "\n", "\tb64sig = ldns_buffer_new(LDNS_MAX_PACKETLEN);\n", "\tif (!b64sig) {\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tsha1_hash = SHA1((unsigned char*)ldns_buffer_begin(to_sign),\n", "\t\t\t\t  ldns_buffer_position(to_sign), NULL);\n", "\tif (!sha1_hash) {\n", "\t\tldns_buffer_free(b64sig);\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tsig = DSA_do_sign(sha1_hash, SHA_DIGEST_LENGTH, key);\n", "        if(!sig) {\n", "\t\tldns_buffer_free(b64sig);\n", "\t\treturn NULL;\n", "        }\n", "\n", "\tdata = LDNS_XMALLOC(uint8_t, 1 + 2 * SHA_DIGEST_LENGTH);\n", "        if(!data) {\n", "\t\tldns_buffer_free(b64sig);\n", "                DSA_SIG_free(sig);\n", "\t\treturn NULL;\n", "        }\n", "\n", "\tdata[0] = 1;\n", "# ifdef HAVE_DSA_SIG_GET0\n", "\tDSA_SIG_get0(sig, &R, &S);\n", "# else\n", "\tR = sig->r;\n", "\tS = sig->s;\n", "# endif\n", "\tpad = 20 - (size_t) BN_num_bytes(R);\n", "\tif (pad > 0) {\n", "\t\tmemset(data + 1, 0, pad);\n", "\t}\n", "\tBN_bn2bin(R, (unsigned char *) (data + 1) + pad);\n", "\n", "\tpad = 20 - (size_t) BN_num_bytes(S);\n", "\tif (pad > 0) {\n", "\t\tmemset(data + 1 + SHA_DIGEST_LENGTH, 0, pad);\n", "\t}\n", "\tBN_bn2bin(S, (unsigned char *) (data + 1 + SHA_DIGEST_LENGTH + pad));\n", "\n", "\tsigdata_rdf = ldns_rdf_new_frm_data(LDNS_RDF_TYPE_B64,\n", "\t\t\t\t\t\t\t\t 1 + 2 * SHA_DIGEST_LENGTH,\n", "\t\t\t\t\t\t\t\t data);\n", "\n", "\tldns_buffer_free(b64sig);\n", "\tLDNS_FREE(data);\n", "        DSA_SIG_free(sig);\n", "\n", "\treturn sigdata_rdf;\n", "#else\n", "\t(void)to_sign; (void)key;\n", "\treturn NULL;\n", "#endif\n", "}\n"], "project": "python-ldns", "file": "dnssec_sign.pkl", "function": "ldns_sign_public_dsa"}, {"comment_all": {"comment": "// Remove r from out linked list\n", "depth": 2, "reading_ease": 99.23, "reading_grade": 0.9, "line": 150}, "comment_text": "// Remove r from out linked list\n", "comment_tokens": ["Remove", "r", "from", "out", "linked", "list"], "ccode": ["\n", "static void wake_next_worker(hts_tpool_process *q, int locked);\n", "\n", "/* Core of hts_tpool_next_result() */\n", "static hts_tpool_result *hts_tpool_next_result_locked(hts_tpool_process *q) {\n", "    hts_tpool_result *r, *last;\n", "\n", "    if (q->shutdown)\n", "        return NULL;\n", "\n", "    for (last = NULL, r = q->output_head; r; last = r, r = r->next) {\n", "        if (r->serial == q->next_serial)\n", "            break;\n", "    }\n", "\n", "    if (r) {\n", "        // Remove r from out linked list\n", "        if (q->output_head == r)\n", "            q->output_head = r->next;\n", "        else\n", "            last->next = r->next;\n", "\n", "        if (q->output_tail == r)\n", "            q->output_tail = last;\n", "\n", "        if (!q->output_head)\n", "            q->output_tail = NULL;\n", "\n", "        q->next_serial++;\n", "        q->n_output--;\n", "\n", "        if (q->qsize && q->n_output < q->qsize) {\n", "            // Not technically input full, but can guarantee there is\n", "            // room for the input to go somewhere so we still signal.\n", "            // The waiting code will then check the condition again.\n", "            if (q->n_input < q->qsize)\n", "                pthread_cond_signal(&q->input_not_full_c);\n", "            if (!q->shutdown)\n", "                wake_next_worker(q, 1);\n", "        }\n", "    }\n", "\n", "    return r;\n", "}\n"], "project": "tabix", "file": "thread_pool.pkl", "function": "hts_tpool_next_result_locked"}, {"comment_all": {"comment": "/* Advance 'str' to the end character */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 532}, "comment_text": "/* Advance 'str' to the end character */", "comment_tokens": ["Advance", "'str", "'", "to", "the", "end", "character"], "ccode": ["\n", "static char *__expand_string(const char **str, bool (*is_end)(char c),\n", "\t\t\t     int argc, char *argv[])\n", "{\n", "\tconst char *in, *p;\n", "\tchar *expansion, *out;\n", "\tsize_t in_len, out_len;\n", "\n", "\tout = xmalloc(1);\n", "\t*out = 0;\n", "\tout_len = 1;\n", "\n", "\tp = in = *str;\n", "\n", "\twhile (1) {\n", "\t\tif (*p == '$') {\n", "\t\t\tin_len = p - in;\n", "\t\t\tp++;\n", "\t\t\texpansion = expand_dollar_with_args(&p, argc, argv);\n", "\t\t\tout_len += in_len + strlen(expansion);\n", "\t\t\tout = xrealloc(out, out_len);\n", "\t\t\tstrncat(out, in, in_len);\n", "\t\t\tstrcat(out, expansion);\n", "\t\t\tfree(expansion);\n", "\t\t\tin = p;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tif (is_end(*p))\n", "\t\t\tbreak;\n", "\n", "\t\tp++;\n", "\t}\n", "\n", "\tin_len = p - in;\n", "\tout_len += in_len;\n", "\tout = xrealloc(out, out_len);\n", "\tstrncat(out, in, in_len);\n", "\n", "\t/* Advance 'str' to the end character */\n", "\t*str = p;\n", "\n", "\treturn out;\n", "}\n"], "project": "linux-buildinfo-5.11.0-22-lowlatency", "file": "preprocess.pkl", "function": "__expand_string"}, {"comment_all": {"comment": "/* a wrapper for open(). */", "depth": 0, "reading_ease": 92.8, "reading_grade": 1.3, "line": 82}, "comment_text": "/* a wrapper for open(). */", "comment_tokens": ["a", "wrapper", "for", "open", "(", ")", "."], "ccode": ["#endif\n", "\n", "/* ======================================================================== */\n", "\n", "#ifdef EINTR\n", "\n", "#ifdef UNIX\n", "\n", "/* a wrapper for open(). */\n", "global int nonintr_open (const char* path, int flags, mode_t mode)\n", "{\n", "  {var int retval;\n", "  do {\n", "    retval = open(path,flags,mode);\n", "  } while ((retval < 0) && (errno == EINTR));\n", "  return retval;\n", "}}\n"], "project": "clisp-module-berkeley-db", "file": "unixaux.pkl", "function": "nonintr_open"}, {"comment_all": {"comment": "/*\n  File: high_water_alloc.c\n\n  Copyright (C) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.\n\n  This program is free software; you can redistribute it and/or modify it under\n  the terms of the GNU Lesser General Public License as published by the\n  Free Software Foundation; either version 2.1 of the License, or (at\n  your option) any later version.\n\n  This program is distributed in the hope that it will be useful, but WITHOUT\n  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n  License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/", "depth": 0, "reading_ease": 57.16, "reading_grade": 8.8, "line": 16}, "comment_text": "/*\n  File: high_water_alloc.c\n\n  Copyright (C) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.\n\n  This program is free software; you can redistribute it and/or modify it under\n  the terms of the GNU Lesser General Public License as published by the\n  Free Software Foundation; either version 2.1 of the License, or (at\n  your option) any later version.\n\n  This program is distributed in the hope that it will be useful, but WITHOUT\n  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n  License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/", "comment_tokens": ["File", ":", "high_water_alloc.c", "Copyright", "(", "C", ")", "2001-2002", "Silicon", "Graphics", ",", "Inc.", "All", "Rights", "Reserved", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "program", ".", "If", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", "  File: high_water_alloc.c\n", "\n", "  Copyright (C) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.\n", "\n", "  This program is free software; you can redistribute it and/or modify it under\n", "  the terms of the GNU Lesser General Public License as published by the\n", "  Free Software Foundation; either version 2.1 of the License, or (at\n", "  your option) any later version.\n", "\n", "  This program is distributed in the hope that it will be useful, but WITHOUT\n", "  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n", "  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n", "  License for more details.\n", "\n", "  You should have received a copy of the GNU Lesser General Public\n", "  License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", "*/\n", "\n", "#include \"config.h\"\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include \"misc.h\"\n", "\n", "int __acl_high_water_alloc(void **buf, size_t *bufsize, size_t newsize)\n", "{\n", "#define CHUNK_SIZE\t256\n", "\t/*\n", "\t * Goal here is to avoid unnecessary memory allocations by\n", "\t * using static buffers which only grow when necessary.\n", "\t * Size is increased in fixed size chunks (CHUNK_SIZE).\n", "\t */\n", "\tif (*bufsize < newsize) {\n", "\t\tvoid *newbuf;\n", "\n", "\t\tnewsize = (newsize + CHUNK_SIZE-1) & ~(CHUNK_SIZE-1);\n", "\t\tnewbuf = realloc(*buf, newsize);\n", "\t\tif (!newbuf)\n", "\t\t\treturn 1;\n", "\n", "\t\t*buf = newbuf;\n", "\t\t*bufsize = newsize;\n", "\t}\n", "\treturn 0;\n", "}\n"], "project": "libacl1", "file": "high_water_alloc.pkl", "function": "__acl_high_water_alloc"}, {"comment_all": {"comment": "/* Read remote control directives from fdr and process them, writing the\n * results in fdw. Returns the length of the line read, 0 if EOF, or < 0 on\n * error. */", "depth": 0, "reading_ease": 82.65, "reading_grade": 5.2, "line": 192}, "comment_text": "/* Read remote control directives from fdr and process them, writing the\n * results in fdw. Returns the length of the line read, 0 if EOF, or < 0 on\n * error. */", "comment_tokens": ["Read", "remote", "control", "directives", "from", "fdr", "and", "process", "them", ",", "writing", "the", "results", "in", "fdw", ".", "Returns", "the", "length", "of", "the", "line", "read", ",", "0", "if", "EOF", ",", "or", "<", "0", "on", "error", "."], "ccode": ["\n", "/* Read remote control directives from fdr and process them, writing the\n", " * results in fdw. Returns the length of the line read, 0 if EOF, or < 0 on\n", " * error. */\n", "static int rc_do_command(int fdr, int fdw)\n", "{\n", "\tint len, r, reply_len;\n", "\tchar buf[MAX_LINE], reply[MAX_LINE];\n", "\tchar *error;\n", "\n", "\tlen = read_line(fdr, buf);\n", "\tif (len <= 0)\n", "\t\treturn len;\n", "\n", "\tr = fiu_rc_string(buf, &error);\n", "\n", "\treply_len = snprintf(reply, MAX_LINE, \"%d\\n\", r);\n", "\tr = write(fdw, reply, reply_len);\n", "\tif (r <= 0)\n", "\t\treturn r;\n", "\n", "\treturn len;\n", "}\n"], "project": "libfiu0", "file": "fiu-rc.pkl", "function": "rc_do_command"}, {"comment_all": {"comment": "/*\n\t * Goal here is to avoid unnecessary memory allocations by\n\t * using static buffers which only grow when necessary.\n\t * Size is increased in fixed size chunks (CHUNK_SIZE).\n\t */", "depth": 1, "reading_ease": 58.79, "reading_grade": 8.2, "line": 27}, "comment_text": "/*\n\t * Goal here is to avoid unnecessary memory allocations by\n\t * using static buffers which only grow when necessary.\n\t * Size is increased in fixed size chunks (CHUNK_SIZE).\n\t */", "comment_tokens": ["Goal", "here", "is", "to", "avoid", "unnecessary", "memory", "allocations", "by", "using", "static", "buffers", "which", "only", "grow", "when", "necessary", ".", "Size", "is", "increased", "in", "fixed", "size", "chunks", "(", "CHUNK_SIZE", ")", "."], "ccode": ["/*\n", "  File: high_water_alloc.c\n", "\n", "  Copyright (C) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.\n", "\n", "  This program is free software; you can redistribute it and/or modify it under\n", "  the terms of the GNU Lesser General Public License as published by the\n", "  Free Software Foundation; either version 2.1 of the License, or (at\n", "  your option) any later version.\n", "\n", "  This program is distributed in the hope that it will be useful, but WITHOUT\n", "  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n", "  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\n", "  License for more details.\n", "\n", "  You should have received a copy of the GNU Lesser General Public\n", "  License along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", "*/\n", "\n", "#include \"config.h\"\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include \"misc.h\"\n", "\n", "int __acl_high_water_alloc(void **buf, size_t *bufsize, size_t newsize)\n", "{\n", "#define CHUNK_SIZE\t256\n", "\t/*\n", "\t * Goal here is to avoid unnecessary memory allocations by\n", "\t * using static buffers which only grow when necessary.\n", "\t * Size is increased in fixed size chunks (CHUNK_SIZE).\n", "\t */\n", "\tif (*bufsize < newsize) {\n", "\t\tvoid *newbuf;\n", "\n", "\t\tnewsize = (newsize + CHUNK_SIZE-1) & ~(CHUNK_SIZE-1);\n", "\t\tnewbuf = realloc(*buf, newsize);\n", "\t\tif (!newbuf)\n", "\t\t\treturn 1;\n", "\n", "\t\t*buf = newbuf;\n", "\t\t*bufsize = newsize;\n", "\t}\n", "\treturn 0;\n", "}\n"], "project": "libacl1", "file": "high_water_alloc.pkl", "function": "__acl_high_water_alloc"}, {"comment_all": {"comment": "/* call SSL_accept(*ssl) next */", "depth": 1, "reading_ease": 59.97, "reading_grade": 5.6, "line": 90}, "comment_text": "/* call SSL_accept(*ssl) next */", "comment_tokens": ["call", "SSL_accept", "(", "ssl", ")", "next"], "ccode": ["#include <unistd.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <sys/socket.h>\n", "#include <sys/poll.h>\n", "#include <netdb.h>\n", "#include <fcntl.h>\n", "#include <openssl/ssl.h>\n", "\n", "static int library_inited;\n", "\n", "/* don't want to fail handshake if cert isn't verifiable */\n", "static int verify_cb(int preverify_ok, X509_STORE_CTX *ctx) { return 1; }\n", "\n", "const char* ssl_server_cert=\"server.pem\";\n", "const char* ssl_client_crl=\"clientcrl.pem\";\n", "const char* ssl_client_ca=\"clientca.pem\";\n", "const char* ssl_ciphers=\"DEFAULT\";\n", "const char* ssl_client_cert=\"clientcert.pem\";\n", "\n", "int init_serverside_tls(SSL** ssl,int sock) {\n", "/* taken from the qmail tls patch */\n", "  SSL* myssl;\n", "  SSL_CTX* ctx;\n", "  X509_STORE *store;\n", "  X509_LOOKUP *lookup;\n", "\n", "  if (!library_inited) {\n", "    library_inited=1;\n", "    SSL_library_init();\n", "  }\n", "  /* a new SSL context with the bare minimum of options */\n", "  if (!(ctx=SSL_CTX_new(SSLv23_server_method()))) {\n", "#if 0\n", "    printf(\"SSL_CTX_new failed\\n\");\n", "#endif\n", "    return -1;\n", "  }\n", "  if (!SSL_CTX_use_certificate_chain_file(ctx, ssl_server_cert)) {\n", "    SSL_CTX_free(ctx);\n", "#if 0\n", "    printf(\"SSL_CTX_use_certificate_chain_file failed\\n\");\n", "#endif\n", "    return -1;\n", "  }\n", "  SSL_CTX_load_verify_locations(ctx, ssl_client_ca, NULL);\n", "#if OPENSSL_VERSION_NUMBER >= 0x00907000L\n", "  /* crl checking */\n", "  store = SSL_CTX_get_cert_store(ctx);\n", "  if ((lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file())) &&\n", "      (X509_load_crl_file(lookup, ssl_client_crl, X509_FILETYPE_PEM) == 1))\n", "    X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK |\n", "                                X509_V_FLAG_CRL_CHECK_ALL);\n", "#endif\n", "\n", "  /* set the callback here; SSL_set_verify didn't work before 0.9.6c */\n", "  SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, verify_cb);\n", "\n", "  /* a new SSL object, with the rest added to it directly to avoid copying */\n", "  myssl = SSL_new(ctx);\n", "  SSL_CTX_free(ctx);\n", "  if (!myssl) {\n", "#if 0\n", "    printf(\"SSL_new failed\\n\");\n", "#endif\n", "    return -1;\n", "  }\n", "\n", "  /* this will also check whether public and private keys match */\n", "  if (!SSL_use_RSAPrivateKey_file(myssl, ssl_server_cert, SSL_FILETYPE_PEM)) {\n", "    SSL_free(myssl);\n", "#if 0\n", "    printf(\"SSL_use_RSAPrivateKey_file failed\\n\");\n", "#endif\n", "    return -1;\n", "  }\n", "\n", "  SSL_set_cipher_list(myssl, ssl_ciphers);\n", "\n", "#if 0\n", "  SSL_set_tmp_rsa_callback(myssl, tmp_rsa_cb);\n", "  SSL_set_tmp_dh_callback(myssl, tmp_dh_cb);\n", "#endif\n", "#if 0\n", "  SSL_set_rfd(myssl, sock);\n", "  SSL_set_wfd(myssl, sock);\n", "#endif\n", "  SSL_set_fd(myssl, sock);\n", "\n", "  *ssl = myssl; /* call SSL_accept(*ssl) next */\n", "  return 0;\n", "}\n"], "project": "gatling", "file": "ssl.pkl", "function": "init_serverside_tls"}, {"comment_all": {"comment": "/* ALT we can just prefix with ESC; anything else requires CSI u */", "depth": 1, "reading_ease": 84.68, "reading_grade": 4.4, "line": 41}, "comment_text": "/* ALT we can just prefix with ESC; anything else requires CSI u */", "comment_tokens": ["ALT", "we", "can", "just", "prefix", "with", "ESC", ";", "anything", "else", "requires", "CSI", "u"], "ccode": ["#include \"vterm_internal.h\"\n", "\n", "#include <stdio.h>\n", "\n", "#include \"utf8.h\"\n", "\n", "void vterm_keyboard_unichar(VTerm *vt, uint32_t c, VTermModifier mod)\n", "{\n", "  /* The shift modifier is never important for Unicode characters\n", "   * apart from Space\n", "   */\n", "  if(c != ' ')\n", "    mod &= ~VTERM_MOD_SHIFT;\n", "\n", "  if(mod == 0) {\n", "    // Normal text - ignore just shift\n", "    char str[6];\n", "    int seqlen = fill_utf8(c, str);\n", "    vterm_push_output_bytes(vt, str, seqlen);\n", "    return;\n", "  }\n", "\n", "  int needs_CSIu;\n", "  switch(c) {\n", "    /* Special Ctrl- letters that can't be represented elsewise */\n", "    case 'i': case 'j': case 'm': case '[':\n", "      needs_CSIu = 1;\n", "      break;\n", "    /* Ctrl-\\ ] ^ _ don't need CSUu */\n", "    case '\\\\': case ']': case '^': case '_':\n", "      needs_CSIu = 0;\n", "      break;\n", "    /* Shift-space needs CSIu */\n", "    case ' ':\n", "      needs_CSIu = !!(mod & VTERM_MOD_SHIFT);\n", "      break;\n", "    /* All other characters needs CSIu except for letters a-z */\n", "    default:\n", "      needs_CSIu = (c < 'a' || c > 'z');\n", "  }\n", "\n", "  /* ALT we can just prefix with ESC; anything else requires CSI u */\n", "  if(needs_CSIu && (mod & ~VTERM_MOD_ALT)) {\n", "    vterm_push_output_sprintf_ctrl(vt, C1_CSI, \"%d;%du\", c, mod+1);\n", "    return;\n", "  }\n", "\n", "  if(mod & VTERM_MOD_CTRL)\n", "    c &= 0x1f;\n", "\n", "  vterm_push_output_sprintf(vt, \"%s%c\", mod & VTERM_MOD_ALT ? ESC_S : \"\", c);\n", "}\n"], "project": "libvterm-dev", "file": "keyboard.pkl", "function": "vterm_keyboard_unichar"}, {"comment_all": {"comment": "/* Check if it is a valid note name */", "depth": 2, "reading_ease": 114.12, "reading_grade": -0.8, "line": 462}, "comment_text": "/* Check if it is a valid note name */", "comment_tokens": ["Check", "if", "it", "is", "a", "valid", "note", "name"], "ccode": ["\n", "void read_old_notes()\n", "{\n", "\tNote *note;\n", "\tGtkTextBuffer *text_buffer;\n", "\tGtkTextIter iter;\n", "\tDIR *dir = opendir(\".\");\n", "\tFILE *file;\n", "\tstruct dirent *entry;\n", "\tint reserved2;\n", "\tint i;\n", "\tchar buffer[256];\n", "\n", "\trewinddir(dir);\n", "\twhile((entry = readdir(dir)) != NULL) {\n", "\t\t/* Check if it is a valid note name */\n", "\t\tfor(i=0; entry->d_name[i]; i++) {\n", "\t\t\tif(entry->d_name[i] < '0' || entry->d_name[i] > '9') break;\n", "\t\t}\n", "\t\tif(i < strlen(entry->d_name)) continue;\n", "\n", "\t\tnote = malloc(sizeof(Note));\n", "\t\tif(!note) {\n", "\t\t\tfprintf(stderr, \"Failed to allocate note for '%s'.\\n\",\n", "\t\t\t        entry->d_name);\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tfile = fopen(entry->d_name, \"r\");\n", "\t\tnote->id = atoi(entry->d_name);\n", "\t\tif(note->id > highest_note_id) highest_note_id = note->id;\n", "\n", "\t\tif(fscanf(file, \"%d,%d,%d,%d,%d,%d,\",\n", "\t\t          &(note->x), &(note->y), &(note->width),\n", "\t\t          &(note->height), &(note->workspace), &reserved2) < 6) {\n", "\t\t\tfprintf(stderr, \"Failed to parse note '%s': \"\n", "\t\t\t        \"too few values.\", entry->d_name);\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\t/* Get color name */\n", "\t\tif(fgets(buffer, 256, file) == NULL) {\n", "\t\t\tfprintf(stderr, \"Failed to get color from note '%s'.\",\n", "\t\t\t        entry->d_name);\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\t/* Replace the newline with a null char */\n", "\t\tbuffer[strlen(buffer) - 1] = '\\0';\n", "\n", "\t\tfor(i=num_color_schemes; i > 0; i--) {\n", "\t\t\tif(!strcmp(color_schemes[i].name, buffer)) break;\n", "\t\t}\n", "\t\tnote->scheme = &color_schemes[i];\n", "\n", "\t\ttext_buffer = gtk_text_buffer_new(NULL);\n", "\t\twhile(fgets(buffer, 256, file)) {\n", "\t\t\tgtk_text_buffer_get_end_iter(text_buffer, &iter);\n", "\t\t\tgtk_text_buffer_insert(text_buffer, &iter, buffer, -1);\n", "\t\t}\n", "\n", "\t\tnote->text_widget = gtk_text_view_new_with_buffer(text_buffer);\n", "\n", "\t\tcreate_note(note, note->scheme);\n", "\n", "\t\tfclose(file);\n", "\t}\n", "\n", "\tclosedir(dir);\n", "}\n"], "project": "wmstickynotes", "file": "wmstickynotes.pkl", "function": "read_old_notes"}, {"comment_all": {"comment": "// Find out where to put the element and put it\n", "depth": 1, "reading_ease": 95.17, "reading_grade": 2.5, "line": 74}, "comment_text": "// Find out where to put the element and put it\n", "comment_tokens": ["Find", "out", "where", "to", "put", "the", "element", "and", "put", "it"], "ccode": ["\n", "// Inserts element to the heap\n", "void heap_push(struct heap *restrict h, rci_t value, const mzd_t *A) {\n", "  unsigned int index, parent;\n", "\n", "  // Resize the heap if it is too small to hold all the data\n", "  if (h->count == h->size) {\n", "    h->size <<= 1;\n", "    h->data = realloc(h->data, sizeof(rci_t) * h->size);\n", "    if (h->data == NULL) m4ri_die(\"realloc failed.\\n\");\n", "  }\n", "\n", "  // Find out where to put the element and put it\n", "  for(index = h->count++; index; index = parent) {\n", "    parent = (index - 1) >> 1;\n", "    if (mzd_compare_rows_revlex(A, h->data[parent], value)) \n", "      break;\n", "    h->data[index] = h->data[parent];\n", "  }\n", "  h->data[index] = value;\n", "}\n"], "project": "libm4ri-0.0.20200125", "file": "djb.pkl", "function": "heap_push"}, {"comment_all": {"comment": "/* list type does not require status check */", "depth": 2, "reading_ease": 89.75, "reading_grade": 2.5, "line": 244}, "comment_text": "/* list type does not require status check */", "comment_tokens": ["list", "type", "does", "not", "require", "status", "check"], "ccode": ["\n", "int dumpconfig(struct cmd_context *cmd, int argc, char **argv)\n", "{\n", "\tconst char *file = arg_str_value(cmd, file_ARG, NULL);\n", "\tconst char *type = arg_str_value(cmd, configtype_ARG, arg_is_set(cmd, list_ARG) ? \"list\" : \"current\");\n", "\tstruct config_def_tree_spec tree_spec = {0};\n", "\tstruct dm_config_tree *cft = NULL;\n", "\tstruct cft_check_handle *cft_check_handle = NULL;\n", "\tstruct profile *profile = NULL;\n", "\tint r = ECMD_PROCESSED;\n", "\n", "\ttree_spec.cmd = cmd;\n", "\n", "\tif (arg_is_set(cmd, configtype_ARG) && arg_is_set(cmd, validate_ARG)) {\n", "\t\tlog_error(\"Only one of --type and --validate permitted.\");\n", "\t\treturn EINVALID_CMD_LINE;\n", "\t}\n", "\n", "\tif (arg_is_set(cmd, configtype_ARG) && arg_is_set(cmd, list_ARG)) {\n", "\t\tlog_error(\"Only one of --type and --list permitted.\");\n", "\t\treturn EINVALID_CMD_LINE;\n", "\t}\n", "\n", "\tif (arg_is_set(cmd, atversion_ARG)) {\n", "\t\tif (arg_is_set(cmd, sinceversion_ARG)) {\n", "\t\t\tlog_error(\"Only one of --atversion and --sinceversion permitted.\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\n", "\t\tif (!arg_is_set(cmd, configtype_ARG) && !arg_is_set(cmd, list_ARG)) {\n", "\t\t\tlog_error(\"--atversion requires --type or --list\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t} else if (arg_is_set(cmd, sinceversion_ARG)) {\n", "\t\tif (!arg_is_set(cmd, configtype_ARG) || strcmp(type, \"new\")) {\n", "\t\t\tlog_error(\"--sinceversion requires --type new\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t}\n", "\n", "\tif (arg_is_set(cmd, ignoreadvanced_ARG))\n", "\t\ttree_spec.ignoreadvanced = 1;\n", "\n", "\tif (arg_is_set(cmd, ignoreunsupported_ARG)) {\n", "\t\tif (arg_is_set(cmd, showunsupported_ARG)) {\n", "\t\t\tlog_error(\"Only one of --ignoreunsupported and --showunsupported permitted.\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t\ttree_spec.ignoreunsupported = 1;\n", "\t} else if (arg_is_set(cmd, showunsupported_ARG)) {\n", "\t\ttree_spec.ignoreunsupported = 0;\n", "\t} else if (strcmp(type, \"current\") && strcmp(type, \"diff\")) {\n", "\t\t/*\n", "\t\t * By default hide unsupported settings\n", "\t\t * for all display types except \"current\"\n", "\t\t * and \"diff\".\n", "\t\t */\n", "\t\ttree_spec.ignoreunsupported = 1;\n", "\t}\n", "\n", "\tif (strcmp(type, \"current\") && strcmp(type, \"diff\")) {\n", "\t\t/*\n", "\t\t * By default hide deprecated settings\n", "\t\t * for all display types except \"current\"\n", "\t\t * and \"diff\" unless --showdeprecated is set.\n", "\t\t *\n", "\t\t * N.B. Deprecated settings are visible if\n", "\t\t * --atversion is used with a version that\n", "\t\t * is lower than the version in which the\n", "\t\t * setting was deprecated.\n", "\t\t */\n", "\t\tif (!arg_is_set(cmd, showdeprecated_ARG))\n", "\t\t\ttree_spec.ignoredeprecated = 1;\n", "\t}\n", "\n", "\tif (arg_is_set(cmd, ignorelocal_ARG))\n", "\t\ttree_spec.ignorelocal = 1;\n", "\n", "\tif (!strcmp(type, \"current\") || !strcmp(type, \"full\")) {\n", "\t\tif (arg_is_set(cmd, atversion_ARG)) {\n", "\t\t\tlog_error(\"--atversion has no effect with --type %s\", type);\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\n", "\t\tif ((arg_is_set(cmd, ignoreunsupported_ARG) ||\n", "\t\t    arg_is_set(cmd, ignoreadvanced_ARG)) &&\n", "\t\t    !strcmp(type, \"current\")) {\n", "\t\t\t/* FIXME: allow these even for --type current */\n", "\t\t\tlog_error(\"--ignoreadvanced and --ignoreunsupported has \"\n", "\t\t\t\t  \"no effect with --type current\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t} else if (arg_is_set(cmd, mergedconfig_ARG)) {\n", "\t\tlog_error(\"--mergedconfig has no effect without --type current or --type full\");\n", "\t\treturn EINVALID_CMD_LINE;\n", "\t}\n", "\n", "\tif (!_get_vsn(cmd, &tree_spec.version))\n", "\t\treturn EINVALID_CMD_LINE;\n", "\n", "\t/*\n", "\t * The profile specified by --profile cmd arg is like --commandprofile,\n", "\t * but it is used just for dumping the profile content and not for\n", "\t * application.\n", "\t */\n", "\tif (arg_is_set(cmd, profile_ARG) &&\n", "\t    (!(profile = add_profile(cmd, arg_str_value(cmd, profile_ARG, NULL), CONFIG_PROFILE_COMMAND)) ||\n", "\t    !override_config_tree_from_profile(cmd, profile))) {\n", "\t\tlog_error(\"Failed to load profile %s.\", arg_str_value(cmd, profile_ARG, NULL));\n", "\t\treturn ECMD_FAILED;\n", "\t}\n", "\n", "\t/*\n", "\t * Set the 'cft' to work with based on whether we need the plain\n", "\t * config tree or merged config tree cascade if --mergedconfig is used.\n", "\t */\n", "\tif ((arg_is_set(cmd, mergedconfig_ARG) || !strcmp(type, \"full\") || !strcmp(type, \"diff\")) && cmd->cft->cascade) {\n", "\t\tif (!_merge_config_cascade(cmd, cmd->cft, &cft)) {\n", "\t\t\tlog_error(\"Failed to merge configuration.\");\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t} else\n", "\t\tcft = cmd->cft;\n", "\ttree_spec.current_cft = cft;\n", "\n", "\tif (arg_is_set(cmd, validate_ARG)) {\n", "\t\tif (_config_validate(cmd, cft)) {\n", "\t\t\tlog_print(\"LVM configuration valid.\");\n", "\t\t\tgoto out;\n", "\t\t} else {\n", "\t\t\tlog_error(\"LVM configuration invalid.\");\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto out;\n", "\t\t}\n", "\t}\n", "\n", "\tif (!strcmp(type, \"list\") || arg_is_set(cmd, list_ARG)) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_LIST;\n", "\t\tif (arg_is_set(cmd, withcomments_ARG)) {\n", "\t\t\tlog_error(\"--withcomments has no effect with --type list\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t\tif (arg_is_set(cmd, withlocalpreamble_ARG)) {\n", "\t\t\tlog_error(\"--withlocalpreamble has no effect with --type list\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t\tif (arg_is_set(cmd, withgeneralpreamble_ARG)) {\n", "\t\t\tlog_error(\"--withgeneralpreamble has no effect with --type list\");\n", "\t\t\treturn EINVALID_CMD_LINE;\n", "\t\t}\n", "\t\t/* list type does not require status check */\n", "\t} else if (!strcmp(type, \"full\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_FULL;\n", "\t\tif (!_do_def_check(&tree_spec, cft, &cft_check_handle)) {\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto_out;\n", "\t\t}\n", "\t} else if (!strcmp(type, \"current\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_CURRENT;\n", "\t\tif (!_do_def_check(&tree_spec, cft, &cft_check_handle)) {\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto_out;\n", "\t\t}\n", "\t}\n", "\telse if (!strcmp(type, \"missing\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_MISSING;\n", "\t\tif (!_do_def_check(&tree_spec, cft, &cft_check_handle)) {\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto_out;\n", "\t\t}\n", "\t}\n", "\telse if (!strcmp(type, \"default\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_DEFAULT;\n", "\t\t/* default type does not require check status */\n", "\t}\n", "\telse if (!strcmp(type, \"diff\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_DIFF;\n", "\t\tif (!_do_def_check(&tree_spec, cft, &cft_check_handle)) {\n", "\t\t\tr = ECMD_FAILED;\n", "\t\t\tgoto_out;\n", "\t\t}\n", "\t}\n", "\telse if (!strcmp(type, \"new\")) {\n", "\t\ttree_spec.type = arg_is_set(cmd, sinceversion_ARG) ? CFG_DEF_TREE_NEW_SINCE\n", "\t\t\t\t\t\t\t\t  : CFG_DEF_TREE_NEW;\n", "\t\t/* new type does not require check status */\n", "\t}\n", "\telse if (!strcmp(type, \"profilable\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_PROFILABLE;\n", "\t\t/* profilable type does not require check status */\n", "\t}\n", "\telse if (!strcmp(type, \"profilable-command\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_PROFILABLE_CMD;\n", "\t\t/* profilable-command type does not require check status */\n", "\t}\n", "\telse if (!strcmp(type, \"profilable-metadata\")) {\n", "\t\ttree_spec.type = CFG_DEF_TREE_PROFILABLE_MDA;\n", "\t\t/* profilable-metadata  type does not require check status */\n", "\t}\n", "\telse {\n", "\t\tlog_error(\"Incorrect type of configuration specified. \"\n", "\t\t\t  \"Expected one of: current, default, diff, full, list, missing, \"\n", "\t\t\t  \"new, profilable, profilable-command, profilable-metadata.\");\n", "\t\tr = EINVALID_CMD_LINE;\n", "\t\tgoto out;\n", "\t}\n", "\n", "\tif (arg_is_set(cmd, withsummary_ARG) || arg_is_set(cmd, list_ARG))\n", "\t\ttree_spec.withsummary = 1;\n", "\n", "\tif (arg_is_set(cmd, withcomments_ARG))\n", "\t\ttree_spec.withcomments = 1;\n", "\n", "\tif (arg_is_set(cmd, unconfigured_ARG))\n", "\t\ttree_spec.unconfigured = 1;\n", "\n", "\tif (arg_is_set(cmd, withversions_ARG))\n", "\t\ttree_spec.withversions = 1;\n", "\n", "\tif (arg_is_set(cmd, withgeneralpreamble_ARG))\n", "\t\ttree_spec.withgeneralpreamble = 1;\n", "\n", "\tif (arg_is_set(cmd, withlocalpreamble_ARG))\n", "\t\ttree_spec.withlocalpreamble = 1;\n", "\n", "\tif (arg_is_set(cmd, withspaces_ARG))\n", "\t\ttree_spec.withspaces = 1;\n", "\n", "\tif (cft_check_handle)\n", "\t\ttree_spec.check_status = cft_check_handle->status;\n", "\n", "\tif ((tree_spec.type != CFG_DEF_TREE_CURRENT) &&\n", "\t    (tree_spec.type != CFG_DEF_TREE_DIFF) &&\n", "\t    !(cft = config_def_create_tree(&tree_spec))) {\n", "\t\tr = ECMD_FAILED;\n", "\t\tgoto_out;\n", "\t}\n", "\n", "\tif (!config_write(cft, &tree_spec, file, argc, argv)) {\n", "\t\tstack;\n", "\t\tr = ECMD_FAILED;\n", "\t}\n", "out:\n", "\tif (tree_spec.current_cft && (tree_spec.current_cft != cft) &&\n", "\t    (tree_spec.current_cft != cmd->cft))\n", "\t\t/*\n", "\t\t * This happens in case of CFG_DEF_TREE_FULL where we\n", "\t\t * have merged explicitly defined config trees and also\n", "\t\t * we have used default tree.\n", "\t\t */\n", "\t\tdm_config_destroy(tree_spec.current_cft);\n", "\n", "\tif (cft && (cft != cmd->cft))\n", "\t\tdm_config_destroy(cft);\n", "\telse if (profile)\n", "\t\tremove_config_tree_by_source(cmd, CONFIG_PROFILE_COMMAND);\n", "\n", "\t/*\n", "\t * The cmd->cft (the \"current\" tree) is destroyed\n", "\t * together with cmd context destroy...\n", "\t */\n", "\n", "\treturn r;\n", "}\n"], "project": "libdevmapper-event1.02.1", "file": "dumpconfig.pkl", "function": "dumpconfig"}, {"comment_all": {"comment": "/*\n\t\t * Writing 1 byte string (snprintf writes also '\\0') means string is empty\n\t\t */", "depth": 2, "reading_ease": 84.68, "reading_grade": 4.4, "line": 89}, "comment_text": "/*\n\t\t * Writing 1 byte string (snprintf writes also '\\0') means string is empty\n\t\t */", "comment_tokens": ["Writing", "1", "byte", "string", "(", "snprintf", "writes", "also", "'\\0", "'", ")", "means", "string", "is", "empty"], "ccode": ["\n", "int\n", "dynar_str_vcatf(struct dynar *dest, const char *format, va_list ap)\n", "{\n", "\tint to_write;\n", "\tint written;\n", "\tva_list ap_copy;\n", "\tsize_t allocated;\n", "\tchar buf;\n", "\tchar *p;\n", "\n", "\t/*\n", "\t * Find out how much bytes is needed\n", "\t */\n", "\tva_copy(ap_copy, ap);\n", "\tto_write = vsnprintf(&buf, sizeof(buf), format, ap_copy);\n", "\tva_end(ap_copy);\n", "\n", "\tif (to_write < 0) {\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tif ((size_t)to_write < sizeof(buf)) {\n", "\t\t/*\n", "\t\t * Writing 1 byte string (snprintf writes also '\\0') means string is empty\n", "\t\t */\n", "\n", "\t\treturn (0);\n", "\t}\n", "\n", "\tallocated = to_write + 1;\n", "\tif (dynar_prealloc(dest, allocated) != 0) {\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tp = dynar_data(dest) + dynar_size(dest);\n", "\n", "\tva_copy(ap_copy, ap);\n", "\twritten = vsnprintf(p, allocated, format, ap_copy);\n", "\tva_end(ap_copy);\n", "\n", "\tif (written < 0) {\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tif ((size_t)written >= allocated) {\n", "\t\treturn (-1);\n", "\t}\n", "\n", "\tdest->size += written;\n", "\n", "\treturn (written);\n", "}\n"], "project": "corosync-qdevice", "file": "dynar-str.pkl", "function": "dynar_str_vcatf"}, {"comment_all": {"comment": "/*\nCopyright 2001-2003 David Gucwa\nCopyright 2017-2019 Adam Bilbrough\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/", "depth": 0, "reading_ease": 55.37, "reading_grade": 11.5, "line": 0}, "comment_text": "/*\nCopyright 2001-2003 David Gucwa\nCopyright 2017-2019 Adam Bilbrough\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/", "comment_tokens": ["Copyright", "2001-2003", "David", "Gucwa", "Copyright", "2017-2019", "Adam", "Bilbrough", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/*\n", "Copyright 2001-2003 David Gucwa\n", "Copyright 2017-2019 Adam Bilbrough\n", "\n", "This program is free software; you can redistribute it and/or modify\n", "it under the terms of the GNU General Public License as published by\n", "the Free Software Foundation; either version 2 of the License, or\n", "(at your option) any later version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", "*/\n", "#include <string.h>\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <sys/stat.h>\n", "#include <sys/dir.h>\n", "\n", "#include \"fileIO.h\"\n", "#include \"structs.h\"\n", "#include \"screenIO.h\"\n", "#include \"keyboard.h\"\n", "#include \"main.h\"\n", "\n", "extern struct buffer *currentBuffer;\n", "extern int helpBarUpdate;\n", "extern int maxY;\n", "extern char autoIndent;\n", "\n", "void save()\n", "{\n", "  if(!strcmp(currentBuffer->fname, \"\")) {\n", "    doSave(\".\");\n", "  }\n", "  else {\n", "    doSave(currentBuffer->fname);\n", "  }\n", "  currentBuffer->lineUpdate = currentBuffer->topLine;\n", "  currentBuffer->lineUpdate.lineNum = 0;\n", "  currentBuffer->lineUpdate.cursY = 0;\n", "  currentBuffer->keepGoing=1;\n", "}\n"], "project": "dav-text", "file": "fileIO.pkl", "function": "save"}, {"comment_all": {"comment": "/* set the nick here so we have it for the following numeric */", "depth": 3, "reading_ease": 84.68, "reading_grade": 4.4, "line": 145}, "comment_text": "/* set the nick here so we have it for the following numeric */", "comment_tokens": ["set", "the", "nick", "here", "so", "we", "have", "it", "for", "the", "following", "numeric"], "ccode": ["\n", "static gboolean irc_sasl_check_pass(irc_t *irc, char *user, char *pass)\n", "{\n", "\tstorage_status_t status;\n", "\n", "\t/* just check the password here to be able to reply with useful numerics\n", "\t * the actual identification will be handled later */\n", "\tstatus = auth_check_pass(irc, user, pass);\n", "\n", "\tif (status == STORAGE_OK) {\n", "\t\tif (!irc->user->nick) {\n", "\t\t\t/* set the nick here so we have it for the following numeric */\n", "\t\t\tirc->user->nick = g_strdup(user);\n", "\t\t}\n", "\t\tirc_send_num(irc, 900, \"%s!%s@%s %s :You are now logged in as %s\",\n", "\t\t             irc->user->nick, irc->user->user, irc->user->host,\n", "\t\t\t     irc->user->nick, irc->user->nick);\n", "\t\tirc_send_num(irc, 903, \":Password accepted\");\n", "\t\treturn TRUE;\n", "\n", "\t} else if (status == STORAGE_INVALID_PASSWORD) {\n", "\t\tirc_send_num(irc, 904, \":Incorrect password\");\n", "\t} else if (status == STORAGE_NO_SUCH_USER) {\n", "\t\tirc_send_num(irc, 904, \":The nick is (probably) not registered\");\n", "\t} else {\n", "\t\tirc_send_num(irc, 904, \":Unknown SASL authentication error\");\n", "\t}\n", "\n", "\treturn FALSE;\n", "}\n"], "project": "bitlbee-dev", "file": "irc_commands.pkl", "function": "irc_sasl_check_pass"}, {"comment_all": {"comment": "/* Return the number of multibyte characters in the character string STRING.  */", "depth": 0, "reading_ease": 60.31, "reading_grade": 7.6, "line": 26}, "comment_text": "/* Return the number of multibyte characters in the character string STRING.  */", "comment_tokens": ["Return", "the", "number", "of", "multibyte", "characters", "in", "the", "character", "string", "STRING", "."], "ccode": ["/* Counting the multibyte characters in a string.\n", "   Copyright (C) 2007-2008 Free Software Foundation, Inc.\n", "   Written by Bruno Haible <bruno@clisp.org>, 2007.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include <string.h>\n", "\n", "#include <stdlib.h>\n", "\n", "#include \"mbuiter.h\"\n", "\n", "/* Return the number of multibyte characters in the character string STRING.  */\n", "size_t\n", "mbslen (const char *string)\n", "{\n", "  if (MB_CUR_MAX > 1)\n", "    {\n", "      size_t count;\n", "      mbui_iterator_t iter;\n", "\n", "      count = 0;\n", "      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))\n", "\tcount++;\n", "\n", "      return count;\n", "    }\n", "  else\n", "    return strlen (string);\n", "}\n"], "project": "gnuit", "file": "mbslen.pkl", "function": "mbslen"}, {"comment_all": {"comment": "/*\n * ar3k_get_freq\n * Assumes rig!=NULL, freq!=NULL\n */", "depth": 0, "reading_ease": 50.5, "reading_grade": 7.2, "line": 250}, "comment_text": "/*\n * ar3k_get_freq\n * Assumes rig!=NULL, freq!=NULL\n */", "comment_tokens": ["ar3k_get_freq", "Assumes", "rig", "!", "=NULL", ",", "freq", "!", "=NULL"], "ccode": ["\n", "/*\n", " * ar3k_get_freq\n", " * Assumes rig!=NULL, freq!=NULL\n", " */\n", "int ar3k_get_freq(RIG *rig, vfo_t vfo, freq_t *freq)\n", "{\n", "\tchar *rfp;\n", "\tint freq_len, retval;\n", "\tchar freqbuf[BUFSZ];\n", "\n", "\t/*\n", "\t * #--J0WZ-----Y---------Q\n", "\t *      X                R,S,T,U,V\n", "\t */\n", "\tretval = ar3k_transaction (rig, \"D\" EOM, 3, freqbuf, &freq_len);\n", "\tif (retval != RIG_OK)\n", "\t\treturn retval;\n", "\n", "\trfp = strchr(freqbuf, 'Y');\n", "\tif (!rfp)\n", "\t\treturn -RIG_EPROTO;\n", "\tsscanf(rfp+1,\"%\"SCNfreq, freq);\n", "\t*freq *= 10;\n", "\n", "\treturn RIG_OK;\n", "}\n"], "project": "libhamlib++-dev", "file": "ar3000.pkl", "function": "ar3k_get_freq"}, {"comment_all": {"comment": "/*\n\t   * Regular pc relative addressing check that this is the\n\t   * address of a function.\n\t   */", "depth": 3, "reading_ease": 58.28, "reading_grade": 8.4, "line": 61}, "comment_text": "/*\n\t   * Regular pc relative addressing check that this is the\n\t   * address of a function.\n\t   */", "comment_tokens": ["Regular", "pc", "relative", "addressing", "check", "that", "this", "is", "the", "address", "of", "a", "function", "."], "ccode": ["/*\n", " * Copyright (c) 1983, 1993\n", " *      The Regents of the University of California.  All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " * 3. Neither the name of the University nor the names of its contributors\n", " *    may be used to endorse or promote products derived from this software\n", " *    without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "#include \"gprof.h\"\n", "#include \"search_list.h\"\n", "#include \"source.h\"\n", "#include \"symtab.h\"\n", "#include \"cg_arcs.h\"\n", "#include \"corefile.h\"\n", "#include \"hist.h\"\n", "\n", "    /*\n", "     *        opcode of the `callf' instruction\n", "     */\n", "#define\tCALL\t(0xc0000000)\n", "\n", "void sparc_find_call (Sym *, bfd_vma, bfd_vma);\n", "\n", "void\n", "sparc_find_call (Sym *parent, bfd_vma p_lowpc, bfd_vma p_highpc)\n", "{\n", "  bfd_vma pc, dest_pc;\n", "  unsigned int insn;\n", "  Sym *child;\n", "\n", "  DBG (CALLDEBUG, printf (\"[find_call] %s: 0x%lx to 0x%lx\\n\",\n", "\t\t\t  parent->name, (unsigned long) p_lowpc,\n", "\t\t\t  (unsigned long) p_highpc));\n", "  for (pc = (p_lowpc + 3) & ~(bfd_vma) 3; pc < p_highpc; pc += 4)\n", "    {\n", "      insn = bfd_get_32 (core_bfd, ((unsigned char *) core_text_space\n", "\t\t\t\t    + pc - core_text_sect->vma));\n", "      if (insn & CALL)\n", "\t{\n", "\t  DBG (CALLDEBUG,\n", "\t       printf (\"[find_call] 0x%lx: callf\", (unsigned long) pc));\n", "\t  /*\n", "\t   * Regular pc relative addressing check that this is the\n", "\t   * address of a function.\n", "\t   */\n", "\t  dest_pc = pc + (((bfd_signed_vma) (insn & 0x3fffffff)\n", "\t\t\t   ^ 0x20000000) - 0x20000000);\n", "\t  if (hist_check_address (dest_pc))\n", "\t    {\n", "\t      child = sym_lookup (&symtab, dest_pc);\n", "\t      if (child)\n", "\t\t{\n", "\t          DBG (CALLDEBUG,\n", "\t\t      printf (\"\\tdest_pc=0x%lx, (name=%s, addr=0x%lx)\\n\",\n", "\t\t\t     (unsigned long) dest_pc, child->name,\n", "\t\t\t     (unsigned long) child->addr));\n", "\t          if (child->addr == dest_pc)\n", "\t\t    {\n", "\t\t      /* a hit:  */\n", "\t\t      arc_add (parent, child, (unsigned long) 0);\n", "\t\t      continue;\n", "\t\t    }\n", "\t\t}\n", "\t    }\n", "\t  /*\n", "\t   * Something funny going on.\n", "\t   */\n", "\t  DBG (CALLDEBUG, printf (\"\\tbut it's a botch\\n\"));\n", "\t}\n", "    }\n", "}\n"], "project": "binutils-s390x-linux-gnu", "file": "sparc.pkl", "function": "sparc_find_call"}, {"comment_all": {"comment": "/*\n *\tConvert a mins:secs:frames format to plain frames\n */", "depth": 0, "reading_ease": 81.29, "reading_grade": 3.7, "line": 154}, "comment_text": "/*\n *\tConvert a mins:secs:frames format to plain frames\n */", "comment_tokens": ["Convert", "a", "mins", ":", "secs", ":", "frames", "format", "to", "plain", "frames"], "ccode": ["\n", "/*\n", " *\tConvert a mins:secs:frames format to plain frames\n", " */\n", "\n", "long time2frames(char *s)\n", "{\n", "\tint mins = 0, secs = 0, frames = 0;\n", "\tchar *p, *t;\n", "\t\n", "\tif (!(p = strchr(s, ':')))\n", "\t\treturn -1;\n", "\t*p = '\\0';\n", "\tmins = atoi(s);\n", "\t\n", "\tp++;\n", "\tif (!(t = strchr(p, ':')))\n", "\t\treturn -1;\n", "\t*t = '\\0';\n", "\tsecs = atoi(p);\n", "\t\n", "\tt++;\n", "\tframes = atoi(t);\n", "\t\n", "\treturn 75 * (mins * 60 + secs) + frames;\n", "}\n"], "project": "bchunk", "file": "bchunk.pkl", "function": "time2frames"}, {"comment_all": {"comment": "/* flushes all stdio output streams */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 74}, "comment_text": "/* flushes all stdio output streams */", "comment_tokens": ["flushes", "all", "stdio", "output", "streams"], "ccode": ["\n", "/* Print a message and return to caller.\n", " * Caller specifies \"errnoflag\". */\n", "\n", "static void err_doit(int errnoflag, const char *fmt, va_list ap) {\n", "\n", "\tint\t\terrno_save;\n", "\tchar\tbuf[MAXLINE];\n", "\n", "\terrno_save = errno;\t\t/* value caller might want printed */\n", "\tvsprintf(buf, fmt, ap);\n", "\tif (errnoflag)\n", "\t\tsprintf(buf+strlen(buf), \": %s\", strerror(errno_save));\n", "\tstrcat(buf, \"\\n\");\n", "\tfflush(stdout);\t\t/* in case stdout and stderr are the same */\n", "\tfputs(buf, stderr);\n", "\tfflush(NULL);\t\t/* flushes all stdio output streams */\n", "\treturn;\n", "\n", "}\n"], "project": "ipband", "file": "error.pkl", "function": "err_doit"}, {"comment_all": {"comment": "/* Retrieves a string containing the value type identifier\n */", "depth": 0, "reading_ease": 37.98, "reading_grade": 10.0, "line": 73}, "comment_text": "/* Retrieves a string containing the value type identifier\n */", "comment_tokens": ["Retrieves", "a", "string", "containing", "the", "value", "type", "identifier"], "ccode": ["\n", "/* Retrieves a string containing the value type identifier\n", " */\n", "const char *libfole_value_type_get_identifier(\n", "             uint32_t value_type )\n", "{\n", "\tint iterator = 0;\n", "\n", "\twhile( ( libfole_value_types[ iterator ] ).value_type != (uint32_t) -1 )\n", "\t{\n", "\t\tif( ( libfole_value_types[ iterator ] ).value_type == value_type )\n", "\t\t{\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\titerator++;\n", "\t}\n", "\treturn(\n", "\t ( libfole_value_types[ iterator ] ).identifier );\n", "}\n"], "project": "liblnk-dev", "file": "libfole_value_type.pkl", "function": "libfole_value_type_get_identifier"}, {"comment_all": {"comment": "/* Copy the pointers/colour from the victim to the replacement */", "depth": 1, "reading_ease": 53.88, "reading_grade": 8.0, "line": 448}, "comment_text": "/* Copy the pointers/colour from the victim to the replacement */", "comment_tokens": ["Copy", "the", "pointerscolour", "from", "the", "victim", "to", "the", "replacement"], "ccode": ["\n", "void rb_replace_node(struct rb_node *victim, struct rb_node *new,\n", "\t\t     struct rb_root *root)\n", "{\n", "\tstruct rb_node *parent = rb_parent(victim);\n", "\n", "\t/* Set the surrounding nodes to point to the replacement */\n", "\tif (parent) {\n", "\t\tif (victim == parent->rb_left)\n", "\t\t\tparent->rb_left = new;\n", "\t\telse\n", "\t\t\tparent->rb_right = new;\n", "\t} else {\n", "\t\troot->rb_node = new;\n", "\t}\n", "\tif (victim->rb_left)\n", "\t\trb_set_parent(victim->rb_left, new);\n", "\tif (victim->rb_right)\n", "\t\trb_set_parent(victim->rb_right, new);\n", "\n", "\t/* Copy the pointers/colour from the victim to the replacement */\n", "\t*new = *victim;\n", "}\n"], "project": "vde2", "file": "rbtree.pkl", "function": "rb_replace_node"}, {"comment_all": {"comment": "/* Write uncompressed character to RLE-stream */", "depth": 0, "reading_ease": 49.48, "reading_grade": 7.6, "line": 268}, "comment_text": "/* Write uncompressed character to RLE-stream */", "comment_tokens": ["Write", "uncompressed", "character", "to", "RLE-stream"], "ccode": ["\n", "/* Write uncompressed character to RLE-stream */\n", "static int rle_fputc (int val, tkimg_MFile *ofp)\n", "{\n", "    int retval;\n", "\n", "    if (rlebuf.n == 0) {\n", "        /* Nothing in the buffer ? Save the value */\n", "        rlebuf.n   = 1;\n", "        rlebuf.val = val;\n", "        return val;\n", "    }\n", "\n", "    /* Something in the buffer */\n", "    if (rlebuf.val == val) {\n", "        /* Same value in the buffer ? */\n", "        rlebuf.n++;\n", "        if (rlebuf.n == 257) {\n", "            /* Can not be encoded in a single run ? */\n", "            retval = rle_putrun (256, rlebuf.val, ofp);\n", "            if (retval < 0) {\n", "                return retval;\n", "            }\n", "            rlebuf.n -= 256;\n", "        }\n", "        return val;\n", "    }\n", "\n", "    /* Something different in the buffer ? Write out the run */\n", "    retval = rle_putrun (rlebuf.n, rlebuf.val, ofp);\n", "    if (retval < 0) {\n", "        return retval;\n", "    }\n", "\n", "    /* Save the new value */\n", "    rlebuf.n = 1;\n", "    return (rlebuf.val = val);\n", "}\n"], "project": "libtk-img-doc", "file": "sun.pkl", "function": "rle_fputc"}, {"comment_all": {"comment": "/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n   passed-in ref, whether or not the string is already present.  There is no\n   attempt to deduplicate the refs list (but duplicates are harmless).  */", "depth": 0, "reading_ease": 71.14, "reading_grade": 7.6, "line": 230}, "comment_text": "/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n   passed-in ref, whether or not the string is already present.  There is no\n   attempt to deduplicate the refs list (but duplicates are harmless).  */", "comment_tokens": ["Like", "ctf_str_add", "(", ")", ",", "but", "additionally", "augment", "the", "atom", "'s", "refs", "list", "with", "the", "passed-in", "ref", ",", "whether", "or", "not", "the", "string", "is", "already", "present", ".", "There", "is", "no", "attempt", "to", "deduplicate", "the", "refs", "list", "(", "but", "duplicates", "are", "harmless", ")", "."], "ccode": ["\n", "/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n", "   passed-in ref, whether or not the string is already present.  There is no\n", "   attempt to deduplicate the refs list (but duplicates are harmless).  */\n", "uint32_t\n", "ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n", "{\n", "  ctf_str_atom_t *atom;\n", "  if (!str)\n", "    return 0;\n", "\n", "  atom = ctf_str_add_ref_internal (fp, str, TRUE, TRUE, ref);\n", "  if (!atom)\n", "    return 0;\n", "\n", "  return atom->csa_offset;\n", "}\n"], "project": "binutils-riscv64-unknown-elf", "file": "ctf-string.pkl", "function": "ctf_str_add_ref"}, {"comment_all": {"comment": "/* check for embedded null bytes */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 171}, "comment_text": "/* check for embedded null bytes */", "comment_tokens": ["check", "for", "embedded", "null", "bytes"], "ccode": ["\n", "static PyObject *\n", "nis_match (PyObject *self, PyObject *args, PyObject *kwdict)\n", "{\n", "    char *match;\n", "    char *domain = NULL;\n", "    Py_ssize_t keylen;\n", "    int len;\n", "    char *key, *map;\n", "    int err;\n", "    PyObject *ukey, *bkey, *res;\n", "    int fix;\n", "    static char *kwlist[] = {\"key\", \"map\", \"domain\", NULL};\n", "\n", "    if (!PyArg_ParseTupleAndKeywords(args, kwdict,\n", "                                     \"Us|s:match\", kwlist,\n", "                                     &ukey, &map, &domain))\n", "        return NULL;\n", "    if ((bkey = PyUnicode_EncodeFSDefault(ukey)) == NULL)\n", "        return NULL;\n", "    /* check for embedded null bytes */\n", "    if (PyBytes_AsStringAndSize(bkey, &key, &keylen) == -1) {\n", "        Py_DECREF(bkey);\n", "        return NULL;\n", "    }\n", "    if (!domain && ((err = yp_get_default_domain(&domain)) != 0)) {\n", "        Py_DECREF(bkey);\n", "        return nis_error(err);\n", "    }\n", "    map = nis_mapname (map, &fix);\n", "    if (fix)\n", "        keylen++;\n", "    Py_BEGIN_ALLOW_THREADS\n", "    err = yp_match (domain, map, key, keylen, &match, &len);\n", "    Py_END_ALLOW_THREADS\n", "    Py_DECREF(bkey);\n", "    if (fix)\n", "        len--;\n", "    if (err != 0)\n", "        return nis_error(err);\n", "    res = PyUnicode_DecodeFSDefaultAndSize(match, len);\n", "    free (match);\n", "    return res;\n", "}\n"], "project": "libpython3.9-dev", "file": "nismodule.pkl", "function": "nis_match"}, {"comment_all": {"comment": "/*! \\brief\n * Print a name-addr structure, just for debugging\n */", "depth": 0, "reading_ease": 71.82, "reading_grade": 5.2, "line": 70}, "comment_text": "/*! \\brief\n * Print a name-addr structure, just for debugging\n */", "comment_tokens": ["!", "\\brief", "Print", "a", "name-addr", "structure", ",", "just", "for", "debugging"], "ccode": ["\n", "\n", "/*! \\brief\n", " * Print a name-addr structure, just for debugging\n", " */\n", "void print_nameaddr(FILE* _o, name_addr_t* _a)\n", "{\n", "\tfprintf(_o, \"---name-addr---\\n\");\n", "\tfprintf(_o, \"name: '%.*s'\\n\", _a->name.len, ZSW(_a->name.s));\n", "\tfprintf(_o, \"uri : '%.*s'\\n\", _a->uri.len, ZSW(_a->uri.s));\n", "\tfprintf(_o, \"len : %d\\n\", _a->len);\n", "\tfprintf(_o, \"---/name-addr---\\n\");\n", "}\n"], "project": "kamailio-systemd-modules", "file": "parse_nameaddr.pkl", "function": "print_nameaddr"}, {"comment_all": {"comment": "/* success! all checks passed, we've found it */", "depth": 1, "reading_ease": 106.67, "reading_grade": 0.1, "line": 110}, "comment_text": "/* success! all checks passed, we've found it */", "comment_tokens": ["success", "!", "all", "checks", "passed", ",", "we", "'ve", "found", "it"], "ccode": ["\n", "static int _find_entry(void *x, void *key)\n", "{\n", "\tgids_cache_t *entry = (gids_cache_t *) x;\n", "\tgids_cache_needle_t *needle = (gids_cache_needle_t *) key;\n", "\n", "\tif (needle->uid != entry->uid)\n", "\t\treturn 0;\n", "\n", "\tif (needle->gid != entry->gid)\n", "\t\treturn 0;\n", "\n", "\t/* success! all checks passed, we've found it */\n", "\treturn 1;\n", "}\n"], "project": "slurm-wlm-doc", "file": "group_cache.pkl", "function": "_find_entry"}, {"comment_all": {"comment": "/* Leave the currently edited line and make space for listing */", "depth": 1, "reading_ease": 78.25, "reading_grade": 4.8, "line": 61}, "comment_text": "/* Leave the currently edited line and make space for listing */", "comment_tokens": ["Leave", "the", "currently", "edited", "line", "and", "make", "space", "for", "listing"], "ccode": ["\n", "void\n", "input_start_list(void)\n", "{\n", "  /* Leave the currently edited line and make space for listing */\n", "  _rl_move_vert(_rl_vis_botlin);\n", "#ifdef HAVE_RL_CRLF\n", "  rl_crlf();\n", "#endif\n", "}\n"], "project": "bird-doc", "file": "birdc.pkl", "function": "input_start_list"}, {"comment_all": {"comment": "/* Usage: HandleError(\"function\", __FILE__, __LINE__, 0)\n * - nr specifies the exit code (if nonzero)\n *   if zero, it won't exit... */", "depth": 0, "reading_ease": 54.22, "reading_grade": 9.9, "line": 47}, "comment_text": "/* Usage: HandleError(\"function\", __FILE__, __LINE__, 0)\n * - nr specifies the exit code (if nonzero)\n *   if zero, it won't exit... */", "comment_tokens": ["Usage", ":", "HandleError", "(", "``", "function", "''", ",", "__FILE__", ",", "__LINE__", ",", "0", ")", "-", "nr", "specifies", "the", "exit", "code", "(", "if", "nonzero", ")", "if", "zero", ",", "it", "wo", "n't", "exit", "..."], "ccode": ["\n", "/* Usage: HandleError(\"function\", __FILE__, __LINE__, 0)\n", " * - nr specifies the exit code (if nonzero)\n", " *   if zero, it won't exit... */\n", "void HandleError(const char *def, char *file, unsigned int line, signed int nr)\n", "{ \n", "\tchar *separator;\n", "\n", "\tif (def == NULL || *def == '\\0')\n", "\t\tdef = separator = \"\";\n", "\telse\n", "\t\tseparator = \" - \";\n", "\t\n", "\tfprintf(stderr, \"%s%s%s (in file %s, line %d)\\n\", def, separator, \n", "\t\t\tstrerror(errno), file, line);\n", "\t\n", "\tif (nr)\n", "\t{\n", "\t\tputs(ERROCCMSG);\n", "\t\texit(nr);\n", "\t}\n", "}\n"], "project": "bf", "file": "errors.pkl", "function": "HandleError"}, {"comment_all": {"comment": "/*\n    dbview.c - View dBase III files\n    Copyright (c) 1995,96,2003  Martin Schulze <joey@infodrom.org>\n\n    This file is part of the dbview package, a viewer for dBase II files.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program;  if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.\n\n*/", "depth": 0, "reading_ease": 59.94, "reading_grade": 9.8, "line": 0}, "comment_text": "/*\n    dbview.c - View dBase III files\n    Copyright (c) 1995,96,2003  Martin Schulze <joey@infodrom.org>\n\n    This file is part of the dbview package, a viewer for dBase II files.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program;  if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.\n\n*/", "comment_tokens": ["dbview.c", "-", "View", "dBase", "III", "files", "Copyright", "(", "c", ")", "1995,96,2003", "Martin", "Schulze", "<", "joey", "@", "infodrom.org", ">", "This", "file", "is", "part", "of", "the", "dbview", "package", ",", "a", "viewer", "for", "dBase", "II", "files", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111", ",", "USA", "."], "ccode": ["/*\n", "    dbview.c - View dBase III files\n", "    Copyright (c) 1995,96,2003  Martin Schulze <joey@infodrom.org>\n", "\n", "    This file is part of the dbview package, a viewer for dBase II files.\n", "\n", "    This program is free software; you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation; either version 2 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "\n", "    You should have received a copy of the GNU General Public License\n", "    along with this program;  if not, write to the Free Software\n", "    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA.\n", "\n", "*/\n", "\n", "/*\n", " * Thu Sep 26 21:38:33 1996:  Martin Schulze <joey@infodrom.north.de>\n", " *\tAdded trimming option (-t) to also get untrimmed browse output.\n", " *\tThanks to Magnus Lassus <mlassus@walli.uwasa.fi> for the idea and\n", " *\tproviding me with a patch.\n", " */\n", "\n", "#include \"version.h\"\n", "#include \"db_dump.h\"\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <getopt.h>\n", "#include <string.h>\n", "\n", "void help_short()\n", "{\n", "    printf (\"%s %s - %s, (c) 1996 by Martin Schulze\\n\", progname, version, longname);\n", "    printf (\"\\n\");\n", "    printf (\"%s [-b [-t]] [-d delim] [-e] [-h] [-i] [-D] [-o] [-v] dbfile\\n\", progname);\n", "}\n"], "project": "dbview", "file": "dbview.pkl", "function": "help_short"}, {"comment_all": {"comment": "// This function will also work just as well for tracks.\n", "depth": 1, "reading_ease": 95.17, "reading_grade": 2.5, "line": 82}, "comment_text": "// This function will also work just as well for tracks.\n", "comment_tokens": ["This", "function", "will", "also", "work", "just", "as", "well", "for", "tracks", "."], "ccode": ["\n", "\n", "int getfile_command(int argc, char **argv)\n", "{\n", "  uint32_t id;\n", "  char *endptr;\n", "  char *file;\n", "  int ret = 0;\n", "\n", "  // We need file ID and filename\n", "  if ( argc != 3 ) {\n", "    getfile_usage();\n", "    return 0;\n", "  }\n", "\n", "  // Sanity check song ID\n", "  id = strtoul(argv[1], &endptr, 10);\n", "  if ( *endptr != 0 ) {\n", "    fprintf(stderr, \"illegal value %s\\n\", argv[1]);\n", "    return 1;\n", "  } else if ( ! id ) {\n", "    fprintf(stderr, \"bad file/track id %u\\n\", id);\n", "    return 1;\n", " }\n", "\n", "  // Filename, e.g. \"foo.mp3\"\n", "  file = argv[2];\n", "  printf(\"Getting file/track %d to local file %s\\n\", id, file);\n", "\n", "  // This function will also work just as well for tracks.\n", "  if (LIBMTP_Get_File_To_File(device, id, file, progress, NULL) != 0 ) {\n", "    printf(\"\\nError getting file from MTP device.\\n\");\n", "    ret = 1;\n", "  }\n", "  // Terminate progress bar.\n", "  printf(\"\\n\");\n", "\n", "  return ret;\n", "}\n"], "project": "libmtp9", "file": "getfile.pkl", "function": "getfile_command"}, {"comment_all": {"comment": "/* ================================================================================================\n * The following functions are for sorting\n */", "depth": 0, "reading_ease": 56.93, "reading_grade": 6.8, "line": 825}, "comment_text": "/* ================================================================================================\n * The following functions are for sorting\n */", "comment_tokens": ["================================================================================================", "The", "following", "functions", "are", "for", "sorting"], "ccode": ["\n", "/* ================================================================================================\n", " * The following functions are for sorting\n", " */\n", "\n", "int compare_rows(Widget w, int r1, int r2, void *data) {\n", "        int column;\n", "        int n_columns = XbaeMatrixNumColumns(w);\n", "        int result = 0;\n", "        int *column_order = data; \n", "        \n", "        for(column = 0; result == 0 && column < n_columns; column++) {\n", "                String s1 = XbaeMatrixGetCell(w, r1, column_order[column]);\n", "                String s2 = XbaeMatrixGetCell(w, r2, column_order[column]);\n", "                \n", "                result = strcmp(s1, s2);\n", "        }\n", "\n", "        return result;\n", "}\n"], "project": "libxbae-dev", "file": "choice.pkl", "function": "compare_rows"}, {"comment_all": {"comment": "/* don't init for keyboards */", "depth": 1, "reading_ease": 92.8, "reading_grade": 1.3, "line": 334}, "comment_text": "/* don't init for keyboards */", "comment_tokens": ["do", "n't", "init", "for", "keyboards"], "ccode": ["\n", "void\n", "EvdevMBEmuOn(InputInfoPtr pInfo)\n", "{\n", "    if (!pInfo->dev->button) /* don't init for keyboards */\n", "        return;\n", "\n", "    RegisterBlockAndWakeupHandlers (EvdevMBEmuBlockHandler,\n", "                                    EvdevMBEmuWakeupHandler,\n", "                                    (pointer)pInfo);\n", "}\n"], "project": "xserver-xorg-input-evdev", "file": "emuMB.pkl", "function": "EvdevMBEmuOn"}, {"comment_all": {"comment": "/**\n * Try to open a file in a given directory.\n *\n * If the filename is an absolute path, then dirname is ignored. If it is a\n * relative path, then we look in that directory for the file.\n *\n * @param dirname\tDirectory to look in, or NULL for none\n * @param fname\t\tFilename to look for\n * @param fp\t\tSet to NULL if file did not open\n * @return allocated filename on success (caller must free), NULL on failure\n */", "depth": 0, "reading_ease": 78.59, "reading_grade": 6.8, "line": 88}, "comment_text": "/**\n * Try to open a file in a given directory.\n *\n * If the filename is an absolute path, then dirname is ignored. If it is a\n * relative path, then we look in that directory for the file.\n *\n * @param dirname\tDirectory to look in, or NULL for none\n * @param fname\t\tFilename to look for\n * @param fp\t\tSet to NULL if file did not open\n * @return allocated filename on success (caller must free), NULL on failure\n */", "comment_tokens": ["Try", "to", "open", "a", "file", "in", "a", "given", "directory", ".", "If", "the", "filename", "is", "an", "absolute", "path", ",", "then", "dirname", "is", "ignored", ".", "If", "it", "is", "a", "relative", "path", ",", "then", "we", "look", "in", "that", "directory", "for", "the", "file", ".", "@", "param", "dirname", "Directory", "to", "look", "in", ",", "or", "NULL", "for", "none", "@", "param", "fname", "Filename", "to", "look", "for", "@", "param", "fp", "Set", "to", "NULL", "if", "file", "did", "not", "open", "@", "return", "allocated", "filename", "on", "success", "(", "caller", "must", "free", ")", ",", "NULL", "on", "failure"], "ccode": ["\n", "/**\n", " * Try to open a file in a given directory.\n", " *\n", " * If the filename is an absolute path, then dirname is ignored. If it is a\n", " * relative path, then we look in that directory for the file.\n", " *\n", " * @param dirname\tDirectory to look in, or NULL for none\n", " * @param fname\t\tFilename to look for\n", " * @param fp\t\tSet to NULL if file did not open\n", " * @return allocated filename on success (caller must free), NULL on failure\n", " */\n", "static char *try_open(const char *dirname, const char *fname, FILE **fp)\n", "{\n", "\tchar *fullname;\n", "\n", "\tif (!dirname || fname[0] == '/')\n", "\t\tfullname = xstrdup(fname);\n", "\telse\n", "\t\tfullname = join_path(dirname, fname);\n", "\n", "\t*fp = fopen(fullname, \"rb\");\n", "\tif (!*fp) {\n", "\t\tfree(fullname);\n", "\t\tfullname = NULL;\n", "\t}\n", "\n", "\treturn fullname;\n", "}\n"], "project": "device-tree-compiler", "file": "srcpos.pkl", "function": "try_open"}, {"comment_all": {"comment": "// use default if we have a zero size object name:\n", "depth": 2, "reading_ease": 86.71, "reading_grade": 3.7, "line": 159}, "comment_text": "// use default if we have a zero size object name:\n", "comment_tokens": ["use", "default", "if", "we", "have", "a", "zero", "size", "object", "name", ":"], "ccode": ["#endif\n", "\n", "// Open Socket to server.\n", "static int muroar_open_socket_bsd (const char * server) {\n", " struct hostent     * he;\n", " struct sockaddr_in   in;\n", "#ifdef HAVE_AF_UNIX\n", " struct sockaddr_un   un;\n", "#endif\n", " int fh = -1;\n", " char * buf = NULL;\n", " char * object;\n", "#ifdef HAVE_LIB_DNET\n", " char * node;\n", " static char localnode[16] = {0};\n", " struct dn_naddr      *binaddr;\n", " struct nodeent       *dp;\n", "#endif\n", "\n", "#ifdef __WIN32\n", " muroar_init_win32();\n", "#endif\n", "\n", " if ( !strcmp(server, MUROAR_ABSTRACT) || (strstr(server, \"/\") != NULL && strstr(server, \"::\") == NULL) ) {\n", "// Handle AF_UNIX Sockets,\n", "// do not build on broken systems like win32 not\n", "// supporting the AF_UNIX sockets.\n", "#ifdef HAVE_AF_UNIX\n", "  if ( (fh = socket(AF_UNIX, SOCK_STREAM, 0)) == -1 )\n", "   return -1;\n", "\n", "  un.sun_family = AF_UNIX;\n", "\n", "  if ( !strcmp(server, MUROAR_ABSTRACT) ) {\n", "   memset(un.sun_path, 0, sizeof(un.sun_path));\n", "   strncpy(un.sun_path + 1, \"RoarAudio/UNIX/Abstract/1\", sizeof(un.sun_path) - 2);\n", "  } else {\n", "   strncpy(un.sun_path, server, sizeof(un.sun_path) - 1);\n", "  }\n", "\n", "  if ( connect(fh, (struct sockaddr *)&un, sizeof(struct sockaddr_un)) == -1 ) {\n", "   __CLOSE(fh);\n", "   return -1;\n", "  }\n", "\n", "  return fh;\n", "#else\n", "  return -1;\n", "#endif\n", " } else if ( strstr(server, \"::\") != NULL ) {\n", "#ifdef HAVE_LIB_DNET\n", "  // alloc a temp buffer so we can change the string at will:\n", "  buf = strdup(server);\n", "\n", "  // cut node::object into buf and object\n", "  object  = strstr(buf, \"::\");\n", "  *object = 0;\n", "   object += 2;\n", "\n", "  // use default if we have a zero-size node name:\n", "  if ( *buf == 0 ) {\n", "   if ( !localnode[0] ) {\n", "    if ( (binaddr=getnodeadd()) == NULL) {\n", "     free(buf);\n", "     return -1;\n", "    }\n", "\n", "    if ( (dp = getnodebyaddr((char*)binaddr->a_addr, binaddr->a_len, AF_DECnet)) == NULL ) {\n", "     free(buf);\n", "     return -1;\n", "    }\n", "\n", "    strncpy(localnode, dp->n_name, sizeof(localnode)-1);\n", "    localnode[sizeof(localnode)-1] = 0;\n", "   }\n", "\n", "   node = localnode;\n", "  } else {\n", "   node = buf;\n", "  }\n", "\n", "  // use default if we have a zero size object name:\n", "  if ( *object == 0 ) {\n", "   object = MUROAR_OBJECT;\n", "  }\n", "\n", "  fh = dnet_conn(node, object, SOCK_STREAM, NULL, 0, NULL, 0);\n", "\n", "  // free buffer when we are done.\n", "  free(buf);\n", "\n", "  return fh;\n", "#else\n", "  return -1;\n", "#endif\n", " }\n", "\n", " if ( strstr(server, \":\") != NULL ) {\n", "  buf = strdup(server);\n", "  server = buf;\n", "  object = strstr(buf, \":\");\n", "  *object = 0;\n", "  object++;\n", "  if ( !*object ) /* finnaly check if this is just a tailing :, in that case we assume the default port */\n", "   object = NULL;\n", " } else {\n", "  object = NULL;\n", " }\n", "\n", " if ( (he = gethostbyname(server)) == NULL ) {\n", "  if ( buf != NULL )\n", "   free(buf);\n", "  return -1;\n", " }\n", "\n", " memcpy((struct in_addr *)&(in.sin_addr), he->h_addr, sizeof(struct in_addr));\n", "\n", " in.sin_family = AF_INET;\n", " if ( object != NULL ) {\n", "  in.sin_port   = htons(atoi(object));\n", " } else {\n", "  in.sin_port   = htons(MUROAR_PORT);\n", " }\n", "\n", " if ( buf != NULL )\n", "  free(buf);\n", "\n", " if ( (fh = socket(AF_INET, SOCK_STREAM, 0)) == -1 )\n", "  return -1;\n", "\n", " if ( connect(fh, (const struct sockaddr *)&in, sizeof(in)) == -1 ) {\n", "  __CLOSE(fh);\n", "  return -1;\n", " }\n", "\n", " return fh;\n", "}\n"], "project": "libmuroar0", "file": "muroar.pkl", "function": "muroar_open_socket_bsd"}, {"comment_all": {"comment": "/*fe->base_fe->fnt_use = FU_USED;*/", "depth": 1, "reading_ease": -6.7, "reading_grade": 14.7, "line": 13}, "comment_text": "/*fe->base_fe->fnt_use = FU_USED;*/", "comment_tokens": ["fe-", ">", "base_fe-", ">", "fnt_use", "=", "FU_USED", ";"], "ccode": ["#include\t\"defs.h\"\n", "#include\t\"commands.h\"\n", "#include\t\"global.h\"\n", "#include\t\"dvi.h\"\n", "\n", "void\n", "init_dvi_fontinfo(fe)\n", "struct font_entry *fe;\n", "{\n", "    int\tnull_markchar();\n", "    void read_dvi_fontinfo();\n", "\n", "    fe->fnt_type = FT_DVI;\n", "    /*fe->base_fe->fnt_use = FU_USED;*/\n", "    fe->fnt_markchar = null_markchar;\n", "    fe->fnt_readfontinfo = read_dvi_fontinfo;\n", "}\n"], "project": "dvi2dvi", "file": "dvifont.pkl", "function": "init_dvi_fontinfo"}, {"comment_all": {"comment": "// ~4\n", "depth": 2, "reading_ease": 121.22, "reading_grade": -3.5, "line": 1206}, "comment_text": "// ~4\n// find notch (suche kerbe)\n", "comment_tokens": ["~4", "find", "notch", "(", "suche", "kerbe", ")"], "ccode": ["/* ocr-engine numbers only */\n", "/*\n", "This is a Optical-Character-Recognition program\n", "Copyright (C) 2000-2018 Joerg Schulenburg\n", "\n", "This program is free software; you can redistribute it and/or\n", "modify it under the terms of the GNU General Public License\n", "as published by the Free Software Foundation; either version 2\n", "of the License, or (at your option) any later version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n", "\n", " see README for EMAIL-address\n", "\n", "   OCR engine (c) Joerg Schulenburg\n", "   first engine: rule based --- numbers 0..9\n", "\n", "*/\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "/* #include \"pgm2asc.h\" */\n", "#include \"ocr0.h\"\n", "#include \"ocr1.h\"\n", "#include \"amiga.h\"\n", "#include \"pnm.h\"\n", "#include \"gocr.h\"\n", "#include \"unicode_defs.h\"\n", "\n", "#include \"ocr0_dbg.h\" /* define DO_DEBUG IFV MM Setac Break MSG DBG */\n", "\n", "/* extern \"C\"{ */\n", "\n", "// OCR engine ;)\n", "wchar_t ocr0n(ocr0_shared_t *sdata){\n", "   struct box *box1=sdata->box1;\n", "   pix  *bp=sdata->bp;\n", "   int\td,x,y,x0=box1->x0,x1=box1->x1,y0=box1->y0,y1=box1->y1;\n", "   int  dx=x1-x0+1,dy=y1-y0+1,cs=sdata->cs;\t// size\n", "   int  xa,xb,ya,yb, /* tmp-vars */\n", "        i1,i2,i3,i4,i,j;\n", "   int (*aa)[4]=sdata->aa;    /* corner-points, (x,y,dist^2,vector_idx) */\n", "   //wchar_t bc=UNKNOWN;\t\t\t\t// best char (obsolete)\n", "   int  ad=0;\t\t// propability 0..100\n", "   int hchar=sdata->hchar;\t// char is higher than 'e'\n", "   int gchar=sdata->gchar;\t// char has ink lower than m3\n", "   int dots=box1->dots;\n", "   // --- test 5 near S ---------------------------------------------------\n", "   for(ad=d=100;dx>2 && dy>4;){     // min 3x4\n", "      DBG( char c_ask='5'; )\n", "      if (sdata->holes.num > 1) Break; /* be tolerant */\n", "      if( num_cross(  dx/2,  dx/2,0,dy-1,bp,cs)!=3\n", "      &&  num_cross(6*dx/8,2*dx/8,0,dy-1,bp,cs)!=3 ) Break; // 2010-09-25 6x7\n", "\n", "      i1=loop(bp,dx-1,dy-1,dx,cs,0,LE);\n", "      i2=loop(bp,dx-1,dy-2,dx,cs,0,LE);\n", "      if (i2-i1 >= dx/4) Break; // ~{  5x7font\n", "      // i1, i2 unused now\n", "\n", "      if (dx<13 && dy<17)  { // oebb_teletext S5 Aug10\n", "        i1=loop(bp,   0,0,dx,cs,0,RI);\n", "        i2=loop(bp,   0,1,dx,cs,0,RI);\n", "        i3=loop(bp,dx-1,0,dx,cs,0,LE);\n", "        if (i1>i2 && i3>0) ad=98*ad/100;\n", "      }\n", "      // i1, i2, i3 unused now\n", "\n", "      // get the upper and lower hole koords, y around dy/4 ???\n", "      x=5*dx/8;\n", "      y  =loop(bp,x,0,dy,cs,0,DO); if(y>dy/8) Break;\n", "      y +=loop(bp,x,y,dy,cs,1,DO); if(y>(dy+2)/4) ad=98*ad/100; // 2018-09 815\n", "                                   if(y>(dy+2)/3) Break; // 6x7 2010-09-25\n", "      i1 =loop(bp,x,y,dy,cs,0,DO)+y; if(i1>5*dy/8) Break;\n", "      i3=y=(y+i1)/2; // upper end can be shifted to the right for italic\n", "      x  =loop(bp,0,y,dx,cs,0,RI); if(x>4*dx/8) Break;\n", "      x +=loop(bp,x,y,dx,cs,1,RI); if(x>5*dx/8) Break;\n", "      i1 =loop(bp,x,y,dx,cs,0,RI); i1=(i1+2*x)/2; // upper center (i1,i3)\n", "      y=11*dy/16;\n", "      x  =loop(bp,dx-1  ,y,dx,cs,0,LE); if(x>dx/4) Break;\n", "      x +=loop(bp,dx-1-x,y,dx,cs,1,LE); if(x>dx/2) Break;\n", "      i2 =loop(bp,dx-1-x,y,dx,cs,0,LE); i2=dx-1-(i2+2*x)/2; // lower center x\n", "\n", "      MSG( fprintf(stderr,\"i1,i3=%d,%d i2,y=%d,%d (upper+lower center)\",i1,i3,i2,y);)\n", "\n", "      y  =loop(bp,i1,0,dy,cs,0,DO);\n", "      y +=loop(bp,i1,y,dy,cs,1,DO);\n", "      y  =(3*y+i3)/4;\n", "      if( num_cross( i1, dx-1, y, y,bp,cs)>0 ){ /* S or serif5 ? */\n", "        y  =loop(bp,i1  ,i3,dy,cs,0,DO);\n", "        i  =loop(bp,i1-1,i3,dy,cs,0,DO);\n", "        if (y>i ) ad=99*ad/100; /* looks like S */\n", "        y  =loop(bp,i1  ,i3,dy,cs,0,UP);\n", "        i  =loop(bp,i1+1,i3,dy,cs,0,UP);\n", "        if (i<y ) ad=99*ad/100; /* looks like S */\n", "        x  =loop(bp,dx-1,0,dx,cs,0,LE);\n", "        i  =loop(bp,dx-1,1,dx,cs,0,LE);\n", "        if (x>i ) ad=99*ad/100; /* looks like S */\n", "        if( num_cross(   0, dx/2, dy-1, dy-1,bp,cs)>1 \n", "         && num_cross( dx/2,dx-1,    0,    0,bp,cs)>1 ) ad=98*ad/100; /* serifs */\n", "        if (loop(bp,0,dy-1,dx,cs,0,RI)==0) ad=98*ad/100; /* S or 7segment */\n", "        ad=99*ad/100;\n", "      }\n", "\n", "      for(y=dy/5;y<3*dy/4;y++) // right gap?\n", "      if( num_cross(i1,dx-1,y,y,bp,cs)==0 ) break;\n", "      if( y==3*dy/4 ) Break;\n", "\n", "      for(y=dy/4;y<=11*dy/16;y++) // left gap?\n", "      if( num_cross(0,i2,y,y,bp,cs)==0 ) break;\n", "      if( y>11*dy/16 ) Break;\n", "\n", "      // if( num_hole( x0, x1, y0, y1, box1->p,cs,NULL) > 0 ) break;\n", "      if (sdata->holes.num>0) Break;\n", "\n", "      // sS5 \\sl z  left upper v-bow ?\n", "      for(x=dx,i=y=dy/4;y<dy/2;y++){\n", "        j=loop(bp,0,y,dx,cs,0,RI); if(j<x) { x=j; i=y; }\n", "      } y=i;  /* get smalles left gap and its y position */\n", "      i1=loop(bp,0,   dy/16     ,dx,cs,0,RI); /* left gap at top */\n", "      i2=loop(bp,0,(y+dy/16)/2  ,dx,cs,0,RI); /* left gap below top */\n", "      i =loop(bp,0,(y+dy/16)/2+1,dx,cs,0,RI); if( i>i2 ) i2=i;\n", "      i3=loop(bp,0, y  ,dx,cs,0,RI);  /* left gap at y */\n", "      i =loop(bp,0, y-1,dx,cs,0,RI); if( i<i3 ) i3=i;\n", "      if( 2*i2+  dx/16 < i1+i3 ) ad=99*ad/100; /* 5S oebb_teletext */\n", "      if( 2*i2+1+dx/16 < i1+i3 ) Break; /* break if bow */\n", "      \n", "      if( dy>=20 && dx<16 ) /* tall S */\n", "      if(  loop(bp,0,   dy/5     ,dx,cs,0,RI)\n", "         ==loop(bp,0,   dy/4     ,dx,cs,0,RI)\n", "         &&\n", "           loop(bp,0,   dy/10    ,dx,cs,0,RI)\n", "          >loop(bp,0,   dy/4     ,dx,cs,0,RI)\n", "         &&\n", "           loop(bp,0,       1    ,dx,cs,0,RI)\n", "          >loop(bp,0,   dy/4     ,dx,cs,0,RI)+1\n", "         &&\n", "           loop(bp,dx-1,    0    ,dx,cs,0,LE)\n", "          >loop(bp,dx-1,    1    ,dx,cs,0,LE) ) Break;\n", "\n", "      if( dy>=30 && dx>15 ) /* large S */\n", "      if(   loop(bp,dx/4,3*dy/10,dy,cs,1,DO)>0 ) // check start\n", "      if(   loop(bp,dx-2,3*dy/4 ,dy,cs,1,UP)>0 ) // check end\n", "      if( num_cross(dx/4,dx-2,3*dy/10,3*dy/4,bp,cs)==1 ) Break; // connected?\n", "      MSG(fprintf(stderr,\"~S ad=%d\",ad);)\n", "      \n", "      // small fat s is very similar to rounded serif 5\n", "      //   but has a fat diagonal arrea (Oct08 JS)\n", "      if ( num_cross(dx/8,dx-1-dx/8,3*dy/10,3*dy/4,bp,cs)==1 ) ad=98*ad/100;\n", "      MSG(fprintf(stderr,\"~S ad=%d\",ad);)\n", "\n", "      if( dy>17 && dx>9 ) /* S */\n", "      if(   loop(bp,   0,dy/2   ,dx,cs,0,RI)<dx/2\n", "        ||  loop(bp,   0,dy/2-1 ,dx,cs,0,RI)<dx/2 )\n", "      if(   loop(bp,dx/4,3*dy/10,dy,cs,1,DO)>0 ) // check start\n", "      if(   loop(bp,dx-2,2*dy/3 ,dy,cs,1,UP)>0 ) // check end\n", "      if(   loop(bp,   0,      dy/16,dx,cs,0,RI)\n", "        >=  loop(bp,dx-1, dy-1-dy/16,dx,cs,0,LE) ) ad=ad*98/100;\n", "      MSG(fprintf(stderr,\"~S ad=%d\",ad);)\n", "      if(   loop(bp,3*dx/4  ,   0,dy,cs,1,DO) // ToDo: improve!\n", "         <  loop(bp,  dx/4  ,dy-1,dy,cs,1,UP)\n", "       &&   loop(bp,3*dx/4-1,   0,dy,cs,0,DO)\n", "         <  loop(bp,  dx/4+1,dy-1,dy,cs,0,UP) ) ad=ad*98/100;\n", "      MSG(fprintf(stderr,\"~S ad=%d\",ad);)\n", "\n", "      if ( gchar) ad=99*ad/100;\n", "      if (!hchar) ad=98*ad/100; // ~s 6x7 font tmp08/gocr0801_bad5.jpg\n", "      if (box1->m2 && y0>=box1->m2 && ad<100 && ad>96) {ad=96;MSG({})} // s\n", "      Setac(box1,(wchar_t)'5',ad);\n", "      if (ad==100) return '5';\n", "      break;\n", "      \n", "   }\n", "   // --- test 1 ---------------------------------------------------\n", "   for(ad=d=100;dy>4 && dy>dx && 2*dy>box1->m3-box1->m2;){     // min 3x4\n", "      DBG( char c_ask='1'; )\n", "      if( dots==1 ) Break;\n", "      if (sdata->holes.num > 1) Break; /* be tolerant */\n", "\n", "      if( num_cross(0, dx-1, 0  , 0  ,bp,cs) != 1\n", "       && num_cross(0, dx-1, 1  , 1  ,bp,cs) != 1 ) Break;\n", "      if( num_cross(0, dx-1,dy/2,dy/2,bp,cs) != 1 ) Break;\n", "      if( num_cross(0, dx-1,dy-1,dy-1,bp,cs) != 1\n", "       && num_cross(0, dx-1,dy-2,dy-2,bp,cs) != 1 ) Break;\n", "      /*  5x7  micr      ocr-a   6x10        6x9         bad 6x9 \n", "                                                         mozilla\n", "          3x6  5x7       5x7      ..@@..<-\n", "                                  .@@@..       @@@...<-   @@@...<- \n", "                                  ..@@..       @.@...     ..@...   \n", "               ooo        @@@..   ..@@..<      ..@...     ..@...   \n", "          .$.  ooo        ..@..   ..@@..       ..@...<    ..@...<  \n", "          $@.   oo        ..@..   ..@@..       ..@...     ..@...   \n", "          .$.   oo        ..@..   ..@@..       ..@...     ..@...   \n", "          .@.  ooooo      ..@.@   ..@@..       ..@...     ..@...   \n", "          .$.  ooooo      ..@.@   ..@@..       ..@...     ..@...   \n", "          $@$  ooooo      @@@@@   @@@@@@<-     @@@@@@<-   @@@@@@<- \n", "                                                        gocr0801_bad5\n", "       */\n", "      i4=0; // human font\n", "      if (num_cross(0, dx-1,3*dy/4,3*dy/4,bp,cs) != 2 ) { // except ocr-a\n", "        for (y=1; y<dy/2; y++) {\n", "          if (num_cross(0, dx-1, y  , y  ,bp,cs) == 2 ) break;\n", "        } if (y>=dy/2) {\n", "          if (dx>6) ad=98*ad/100;\n", "          else      ad=99*ad/100; MSG(fprintf(stderr,\"ad= %d\",ad);) }\n", "        for( i=dy/8,y=7*dy/16;y<dy-1 && i;y++ ){\n", "          if( num_cross(0, dx-1, y  , y  ,bp,cs) != 1 ) i--;\n", "        } if( dy>8 && !i ) Break;\n", "      } else {  // ocr-a-1\n", "        i=  loop(bp,dx/2,0,dy,cs,0,DO);\n", "        if (loop(bp,dx/2,i,dy,cs,1,DO)<dy-1) Break;\n", "        i=  loop(bp,dx  -1,dy-1-dy/16,dx,cs,0,LE);\n", "        if (loop(bp,dx-i-1,dy-1-dy/16,dx,cs,1,LE)<dx-1) Break;\n", "        i=  loop(bp,0,dy/16,dx,cs,0,RI);\n", "        if (loop(bp,i,dy/16,dx,cs,1,RI)<dx/2) Break;\n", "        i4=1;\n", "        MSG(fprintf(stderr,\"ocr-a-1 detected ad= %d\", ad);)\n", "      }\n", "\n", "      if( num_cross(0, dx-1, 0  , 0  ,bp,cs) > 1\n", "       && num_cross(0, dx-1, 1  , 1  ,bp,cs) > 1 ) Break; // ~/it_7\n", "\n", "      // calculate upper and lower mass center (without lower serif)\n", "\n", "      x =loop(bp,0,7*dy/8-1,dx,cs,0,RI);   i2=x;\n", "      x+=loop(bp,x,7*dy/8-1,dx,cs,1,RI)-1; i2=(i2+x)/2;\n", "\n", "      i1=loop(bp,dx-1  ,1+0* dy/4,dx,cs,0,LE); i1=dx-1-i1-(x-i2)/2;\n", "\n", "      x =(i1-i2+4)/8; i1+=x; i2-=x;\n", "      \n", "      if( get_line2(i1,0,i2,dy-1,bp,cs,100)<95 ) { // dont work for ocr-a-1\n", "        i1=loop(bp,dx-1  ,1+0* dy/4,dx,cs,0,LE); i1=dx-1-i1;\n", "        if( get_line2(i1,0,i2,dy-1,bp,cs,100)<95 ) Break;\n", "      }\n", "      // upper and lower width\n", "      x =loop(bp,(i1+i2)/2,dy/2,dx,cs,1,RI); i=x; i3=0;\n", "      for (y=0;y<7*dy/8;y++)\n", "        if ( loop(bp,i1+y*(i2-i1)/dy, y,dx,cs,1,RI)-i > 1+dx/8 ) break;\n", "      if (y<7*dy/8) { ad=99*ad/100; // serif or ocr-a-1 ?\n", "        MSG(fprintf(stderr,\"i12 %d %d ad= %d\", i1,i2,ad);) }\n", "      if (y<6*dy/8) { ad=99*ad/100; /*  MICR E-13B font Jan07 */\n", "        MSG(fprintf(stderr,\"i12 %d %d ad= %d\", i1,i2,ad);) }\n", "      if (y<4*dy/8) Break;\n", "      MSG(fprintf(stderr,\"i12 %d %d ad= %d\", i1,i2,ad);)\n", "// out_x(box1); printf(\" i12=%d %d\\n\",i1,i2);\n", "      x =loop(bp,i2,dy-1,dx,cs,1,LE); j=x;\n", "      x =loop(bp,i2,dy-2,dx,cs,1,LE); if(x>j)j=x; i=j;\n", "      x =loop(bp,i2,dy-1,dx,cs,1,RI); j=x;\n", "      x =loop(bp,i2,dy-2,dx,cs,1,RI); if(x>j)j=x;\n", "      if(abs(i-j)>1+dx/8) i3|=1;\n", "      if(i3) Break;        \n", "//       out_x(box1);printf(\" 11 i=%d j=%d i2=%d dx=%d\\n\",i,j,i1,dx);\n", "      MSG(fprintf(stderr,\"ad= %d\", ad);)\n", "      // check against v-symmetric I of examples/5x7.png 2018-09\n", "      for(y=0;y<dy;y++){\n", "        x =loop(bp,0   ,y,dx,cs,0,RI);\n", "        j =loop(bp,dx-1,y,dx,cs,0,LE); if(x!=j) break;\n", "      } if (y==dy) { ad=96*ad/100; MSG({}) } // more an (v-symmetric) I\n", "      // check against h-symmetric () of examples/5x7.png 2018-09\n", "      for(x=0;x<dx;x++){\n", "        y =loop(bp,x,0   ,dy,cs,0,DO);\n", "        j =loop(bp,x,dy-1,dy,cs,0,UP); if(y!=j) break;\n", "        y+=loop(bp,x,y     ,dy,cs,1,DO);\n", "        j+=loop(bp,x,dy-1-j,dy,cs,1,UP); if(y!=j) break;\n", "      } if (x==dx) { ad=96*ad/100; MSG({}) }// more an (h-symmetric) ()\n", "      // get most left upper point (i,j)\n", "      for(i=dx,j=y=0;y<7*dy/16;y++){\n", "        x =loop(bp,0,y,dx,cs,0,RI); if(x<i) { i=x;j=y; }\n", "      }  \n", "      if ( i1-i<7*dx/16 ) { ad=ad*98/100;\n", "        MSG(fprintf(stderr,\"i1i %d %d ad= %d\", i1,i,ad);) }\n", "      if ( i1-i<6*dx/16 ) { ad=ad*98/100; // 4*dx/8 => 7*dx/16  MICR E-13B font\n", "        MSG(fprintf(stderr,\"i1i %d %d ad= %d\", i1,i,ad);) }\n", "      if ( i1-i<4*dx/16 ) Break;\n", "      MSG(fprintf(stderr,\"i12 %d %d ad= %d\", i1,i2,ad);)\n", "      x =loop(bp,0,dy/2,dx,cs,0,RI); // right distance\n", "      j =loop(bp,x,dy/2,dx,cs,1,RI); // thickness\n", "      if( j>x+(dy+16)/32 ) ad=98*ad/100; // ~l but  MICR E-13B font\n", "      x =loop(bp,0,0,dx,cs,0,RI); // straight line ???\n", "      j =loop(bp,0,1,dx,cs,0,RI);\n", "      if (j>x) {\n", "        if (dy>9) { Break; }\n", "        else { if (ad>99) ad=ad*99/100; MSG({}) } // ~l but gocr0801_bad5\n", "      }\n", "      if (x==j) j =loop(bp,0,dy/8,dx,cs,0,RI);\n", "      if (j>x && y>9 && !i4) { Break; }\n", "      else if (j>x && !i4 && ad>99) { ad=ad*99/100; MSG({}) }\n", "      if (x==j) if(loop(bp,0,dy/4,dx,cs,0,RI)>x) {  // ~l\n", "        // check micr-1 first before taken as 'l'\n", "        if (loop(bp,dx-1,dy/8,dx,cs,0,LE)<=dx/4\n", "         && loop(bp, 0,3*dy/4,dx,cs,1,RI)< dx-1) ad=97*ad/100;\n", "      }\n", "      MSG(fprintf(stderr,\"1l check ad= %d\", ad);)\n", "      x=j;\n", "//      j =loop(bp,0,2,dx,cs,0,RI); if( j>=x ) Break; x=j; // ~l\n", "//      j =loop(bp,0,   0,dx,cs,0,DO); if( !j  ) Break; // ~7\n", "      if( !hchar ) // ~ right part of n\n", "      /* look for upper right side, not going from nw to se */ \n", "      if( loop(bp,dx-1,   1,dx,cs,0,LE)-dy/6\n", "        > loop(bp,dx-1,dy/4,dx,cs,0,LE)\n", "      // failes on small fonts with 1 point spaces between chars\n", "      //   also do not know what the purpose of this line was (JS Oct08)\n", "      // || get_bw(x1+1,x1+2,y0,y0+dy/8,box1->p,cs,1)==1\n", "        ) Break; // Mai00\n", "      if( loop(bp,dx-1,3*dy/4,dx,cs,0,LE) > dx/2\n", "       && get_bw(x1-dx/4,x1,y1-1,y1,box1->p,cs,1)==1 ) Break; // ~z Jun00\n", "\n", "      i=loop(bp,  dx/8,0,dy,cs,0,DO);\n", "      for (y=dy,x=dx/2;x<3*dx/4;x++){ /* get upper end y */\n", "        j=loop(bp,x,0,dy,cs,0,DO); if (j<y) { y=j; }\n", "      }\n", "      if(y<dy/2 && y+dy/16>=i) ad=99*ad/100; // ~\\tt l ??? ocr-a_1\n", "      MSG(fprintf(stderr,\"1l check i= %d y= %d ad= %d\", i, y, ad);)\n", "\n", "      if(   loop(bp,   0,  dy/8,dx,cs,0,RI)\n", "       -(dx-loop(bp,dx-1,7*dy/8,dx,cs,0,LE)) > dx/4 ) Break; // ~/\n", "\n", "      i=    loop(bp,   0,      0,dy,cs,0,DO); // horizontal line?\n", "      if(dy>=12 && i>dy/8 && i<dy/2){\n", "        if(   loop(bp,dx-1,3*dy/16,dx,cs,0,LE)-dx/8\n", "             >loop(bp,dx-1,      i,dx,cs,0,LE) \n", "         ||   loop(bp,dx-1,3*dy/16,dx,cs,0,LE)-dx/8\n", "             >loop(bp,dx-1,    i+1,dx,cs,0,LE)       ) Break; // ~t,~f\n", "        i= loop(bp,   0,dy-1-dy/32,dx,cs,0,RI);\n", "        x= loop(bp,   0,dy-2-dy/32,dx,cs,0,RI); if (i<x) x=i;\n", "        if( x-loop(bp,   0,    3*dy/4,dx,cs,0,RI)>dx/8 \n", "         &&   loop(bp,dx-1,    3*dy/4,dx,cs,0,LE)-dx/8\n", "             >loop(bp,dx-1,dy-1-dy/32,dx,cs,0,LE)    ) Break; // ~t\n", "        if(   loop(bp,   0,i-1,dx,cs,0,RI)>1 && dx<6) {\n", "          ad=99*ad/100; \n", "          if ( loop(bp,dx-1,i-1,dx,cs,0,LE)>1 ) Break; // ~t\n", "        }\n", "      }\n", "\n", "      if (dx>8){\n", "        if (loop(bp,0,3*dy/4,dx,cs,0,RI)-\n", "            loop(bp,0,dy/2-1,dx,cs,0,RI)>dx/4) ad=95*ad/100; // ~3\n", "        if (loop(bp,dx-1,dy/2-1,dx,cs,0,LE)-\n", "            loop(bp,dx-1,3*dy/4,dx,cs,0,LE)>dx/8) ad=99*ad/100; // ~3 ocr-a?\n", "        if (loop(bp,dx-1, dy/4 ,dx,cs,0,LE)<dx/3  // 2010-09-25 6x9 \n", "         && loop(bp,dx-1, dy/16,dx,cs,0,LE)-\n", "            loop(bp,dx-1,  dy/4,dx,cs,0,LE)>dx/8) ad=95*ad/100; // ~23\n", "        MSG(fprintf(stderr,\"23 check ad= %d\", ad);)\n", "      }\n", "      /* font 5x9 \"2\" recognized as \"1\" */\n", "      i=loop(bp,dx-1-dx/8,dy-1,dy,cs,0,UP);\n", "      if (i<=dy/4) {\n", "        i+=loop(bp,dx-1-dx/8,dy-1-i,dy,cs,1,UP);\n", "        if (i<=dy/4) {\n", "          i=loop(bp,dx-1-dx/8,dy-1-i,dx,cs,0,LE);\n", "          if (loop(bp,dx-1,dy/4,dx,cs,0,LE)<dx/2) // 2010-09-25 6x9 1\n", "          if (2*i>=dx && loop(bp,dx/4,0,dy,cs,0,DO)<dy/2) {\n", "            if (dx<17) ad=98*ad/100;\n", "            if (dx<9)  ad=97*ad/100;\n", "            MSG(fprintf(stderr,\"5x9 2 check ad= %d\", ad);)\n", "          }\n", "        }\n", "      }\n", "\n", "      // 2010-10-01 sample tmp10/barcode_code128_145      \n", "      if (dx<3 && dy>7 && box1->m4==0) ad=ad*96/100; // just a vertical line?\n", "      \n", "      // looking for  ###\n", "      //              ..# pattern (its important, we dont want perp. lines as 1)\n", "      // ToDo: better check that we have exact one on top\n", "      for (i2=0,i=dx,y=0;y<dy/2;y++) {\n", "        j=loop(bp,0,y,dx,cs,0,RI); if (j<i) i=j;\n", "        if (j>i+dx/8) { break; }\n", "      } if (y>=dy/2) ad=95*ad/100;  // Feb07 care plates, right black border\n", "      MSG(fprintf(stderr,\"ad= %d\", ad);)\n", "      \n", "      if (sdata->holes.num > 0) Break; // mini holes should be filtered\n", "      if (!box1->m3 && ad>98) ad=98; else {\n", "        if (!hchar) ad=99*ad/100;\n", "        if (box1->y0>box1->m2) ad=98*ad/100;\n", "        if (box1->y1<(1*box1->m2+3*box1->m3)/4) ad=98*ad/100;\n", "        if (box1->y1-box1->y0<(box1->m3-box1->m1)/2) ad=98*ad/100;\n", "        if ( gchar) ad=99*ad/100;\n", "      }\n", "\n", "      Setac(box1,(wchar_t)'1',ad);\n", "      break;\n", "   }\n", "   // --- test 2 old pixelbased - remove! -----------------------------\n", "#ifdef Old_pixel_based  \n", "   for(ad=d=100;dx>2 && dy>4;){     // min 3x4\n", "      DBG( char c_ask='2'; )\n", "      if (sdata->holes.num > 1) Break; /* be tolerant */\n", "      if( get_bw(x0+dx/2, x0+dx/2 , y1-dy/5, y1     ,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2, x0+dx/2 , y0     , y0+dy/5,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/8, x1-dx/3 , y1-dy/3, y1-dy/3,box1->p,cs,1) != 1 ) Break;\n", "\n", "      if( get_bw(x1-dx/3, x1      , y0+dy/3 , y0+dy/3,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0     , x0+dx/ 8, y1-dy/16, y1     ,box1->p,cs,1) != 1 ) Break;\n", "      if( num_cross(x0, x1-dx/8, y0+dy/2, y0+dy/2,box1->p,cs) != 1 ) Break;\n", "      if( get_bw(x0, x0+dx/9 , y0       , y0       ,box1->p,cs,1) == 1\n", "       && get_bw(x0, x0+dx/2 ,y0+3*dy/16,y0+3*dy/16,box1->p,cs,1) == 1 ) Break;\n", "      if( get_bw(x0, x0+dx/9 , y0       , y0       ,box1->p,cs,1)\n", "       != get_bw(x1-dx/9, x1 , y0       , y0       ,box1->p,cs,1) )\n", "      { if (dx<6 && dy<9) ad=99*ad/100; else Break; }\n", "      // out_x(box1);\n", "\n", "      for( x=x0+dx/4;x<x1-dx/6;x++ )\t\t// C\n", "      if( num_cross( x, x, y0, y0+dy/2,box1->p,cs) == 2 ) break;\n", "      if( x>=x1-dx/6 ) Break;\n", "\n", "      for( x=x0+dx/4;x<x1-dx/6;x++ )\t\t// C, but acr-a\n", "      if( num_cross( x, x, y0+3*dy/8,y1,box1->p,cs) == 2 ) break;\n", "      if( x>=x1-dx/6 ) Break;\n", "\n", "      for(i=1,y=y0;y<y0+dy/2;y++ )\n", "      if( num_cross( x0, x1, y, y,box1->p,cs) == 2 ) i=0;\n", "      if( i ) ad=99*ad/100; // ToDo: ocr-a-2 should have 100%\n", "\n", "      for(i=1,y=y0+dy/5;y<y0+3*dy/4;y++ )\n", "      if( get_bw( x0, x0+dx/3, y, y,box1->p,cs,1) == 0 ) i=0;\n", "      if( i ) Break;\n", "\n", "      x=x1-dx/3,y=y1; /* center bottom */\n", "      turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,UP,ST); if( y<y1-dy/5 ) Break;\n", "      turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,ST,UP); if( y<y1-dy/4 ) ad=99*ad/100;\n", "                                                   if( y<y1-dy/3 ) Break;\n", "      turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,UP,ST); if( y<y0+dy/3 ) Break; y++;\n", "      turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,RI,ST);\n", "      if( x<x1 ){ x--; // hmm thick font and serifs\n", "        turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,UP,ST); if( y<y0+dy/2 ) Break; y++;\n", "        turmite(box1->p,&x,&y,x0,x1,y0,y1,cs,RI,ST);\n", "        if( x<x1 ) Break;\n", "      }\n", "\n", "      // test ob rechte Kante ansteigend\n", "      for(x=0,y=dy/18;y<=dy/3;y++){ // rechts abfallende Kante/Rund?\n", "        i=loop(box1->p,x1,y0+y,dx,cs,0,LE); // use p (not b) for broken chars\n", "        if( i<x ) break;\t// rund\n", "        if( i>x ) x=i;\n", "      }\n", "      if (y>dy/3 ) Break; \t// z\n", "\n", "      // hole is only allowed in beauty fonts\n", "      // if( num_hole( x0, x1,      y0,      y1,box1->p,cs,NULL) > 0 ) // there is no hole\n", "      // if( num_hole( x0, x0+dx/2, y0, y0+dy/2,box1->p,cs,NULL) == 0 ) // except in some beauty fonts\n", "      if (sdata->holes.num>0)\n", "      if (sdata->holes.hole[0].x1 >= dx/2 || sdata->holes.hole[0].y1 >= dy/2)\n", "        Break;\n", "\n", "      if (loop(bp,dx-1,   0,dx,cs,0,LE)\n", "         <loop(bp,dx-1,dy/4,dx,cs,0,LE)-dx/8) Break; // 5x7,5x8 z Jul09\n", "      i1=loop(bp,dx-1-dx/16,0,dy,cs,0,DO);  // Jul00\n", "      i2=loop(bp,     dx/ 2,0,dy,cs,0,DO); if( i2+dy/32>=i1 ) Break; // ~z\n", "      i1=loop(bp,dx-1,dy-3*dy/16,dx,cs,0,LE);\n", "      i2=loop(bp,   0,dy-3*dy/16,dx,cs,0,RI); if( i2>i1 ) ad=98*ad/100; // ~i\n", "      if (dots) ad=98*ad/100; // i\n", "      if (loop(bp,dx-1,dy-1-dy/16,dx,cs,0,LE)>dx/4) ad=96*ad/100; // \\it i\n", "\n", "      if ((!hchar) && box1->m4!=0) ad=80*ad/100;\n", "      Setac(box1,(wchar_t)'2',ad);\n", "      if (ad==100) return '2';\n", "      break;\n", "   }\n", "#endif\n", "   // --- test 2 new edge based v0.44 --------------------------------------\n", "   for(ad=d=100;dx>2 && dy>4;){     // min 3x4\n", "     // rewritten for vectors 0.42\n", "      int ld, i1, i2, i3, i4, i5, i6, i7;  // line derivation + corners\n", "      DBG( wchar_t c_ask='2'; )\n", "      if (sdata->holes.num > 0) Break; /* no hole */\n", "      /* half distance to the center */\n", "      d=2*sq(128/4);\n", "      /* now we check for the lower ends, must be near to the corner */\n", "      if (aa[1][2]>d/4) Break;  /* [2] = distance, ~7... */\n", "      if (aa[2][2]>d/2) Break;  /* [2] = distance, ~r... */\n", "      if (aa[0][2]>d/1) Break;  /* [2] = distance, ~d... */\n", "      if (aa[3][2]>d/1) Break;  /* [2] = distance, ~bhk... */\n", "      /* searching for 4 notches between neighbouring ends */\n", "\n", "/*\n", "    type A       B  \n", "                    \n", "        1OOO    OO  \n", "           2   1  2 <- 6 \n", "   7->  OOOO     O  \n", "        O       O   <- 5\n", "        3OO4   3OO4    \n", "*/\n", "\n", "      // ToDo: replace by vector code (get point on line at dy/4)\n", "      if (loop(bp,dx-1,   0,dx,cs,0,LE)\n", "         <loop(bp,dx-1,dy/4,dx,cs,0,LE)-dx/8) Break; // 5x7,5x8 z Jul09\n", "\n", "      /* get a point on the inner low left side of the J */\n", "      i =box1->num_frame_vectors[0] - 1;\n", "      /* rightmost point on upper left side */\n", "      i2=nearest_frame_vector(box1, aa[0][3], aa[1][3], x1+dx, y0+dy/4);\n", "      /* upper leftmost vector */\n", "      i1=nearest_frame_vector(box1, aa[0][3], i2, x0-dx, (y0+y1)/2);\n", "      i3=aa[1][3];\n", "      /* low leftmost vector */\n", "      i5=nearest_frame_vector(box1, aa[2][3], aa[3][3], x0, y1);\n", "      /* low mostright vector */     \n", "      i4=nearest_frame_vector(box1, aa[1][3], i5, x1+dx, y1);\n", "      /* next local max_x-point after i5 */\n", "      i6=i5;\n", "      for (i=i5;i!=aa[0][3];i=(i+1)%box1->num_frame_vectors[0]) {\n", "        if (box1->frame_vector[ i][0]\n", "           >box1->frame_vector[i6][0]) i6=i; // get next maximum\n", "        if (box1->frame_vector[ i][0]<x0+dx/3\n", "         && box1->frame_vector[ i][1]<y0+dy/3\n", "         && box1->frame_vector[i6][0]>x0+dx/2) break; // 5\n", "      }\n", "      /* which type? ToDo: have a more sure algorithm */     \n", "      i7=nearest_frame_vector(box1, i2, i3, x0-dx/8, (y0+y1)/2);\n", "      if (box1->frame_vector[i7][0]<=x0+  dx/4\n", "       && box1->frame_vector[i7][1]<=y0+2*dy/3) {\n", "        MSG(fprintf(stderr,\"7-segment-type\");)\n", "      } else { /* regular-book-type */\n", "        MSG( fprintf(stderr,\"upper bow not z-like? ad %d\", ad); )\n", "        if (aa[3][0]>=x1-dx/8                // x of upper right point\n", "         && aa[3][1]< y0+dy/8) ad=99*ad/100; // y of upper right point\n", "        if (aa[0][0]<=x0+dx/8                // x of upper left point\n", "         && aa[0][1]< y0+dy/8) ad=99*ad/100; // y of upper left point\n", "        if (aa[3][2]<=aa[1][2]) ad=97*ad/100; // dist to (maxx,0) <= (0,maxy)\n", "      }\n", "      // ToDo: output no=(x,y)\n", "      MSG( fprintf(stderr,\"i1-7 %d %d %d %d %d %d %d ad %d\",\n", "           i1,i2,i3,i4,i5,i6,i7,ad); )\n", "      if (i5==i6) Break; // ~+\n", "      \n", "      if (box1->frame_vector[i5][1]\n", "         -box1->frame_vector[i6][1]<dy/4) Break; // ~5\n", "      if (box1->frame_vector[i1][1]>y0+dy/2) Break; // not to low\n", "      if (box1->frame_vector[i1][0]>x0+dx/8+dx/16) Break; // slanted ?\n", "      if (box1->frame_vector[i2][1]>(y0+  y1)/2) Break; \n", "      if (box1->frame_vector[i2][1]>(5*y0+3*y1)/8) ad=99*ad/100; \n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      if (box1->frame_vector[i2][0]<(x0+x1+1)/2) Break;  // fat tiny fonts?\n", "      if (box1->frame_vector[i2][0]<(x0+2*x1)/3) ad=99*ad/100;\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      if (box1->frame_vector[i3][0]>(3*x0+x1)/4) Break;\n", "      if (box1->frame_vector[i3][0]>(7*x0+x1)/8) ad=99*ad/100;\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      /* check lowest left point */\n", "      if (box1->frame_vector[i3][1]<(y0+3*y1)/4) Break;\n", "      if (box1->frame_vector[i3][1]<(y0+7*y1)/8) ad=99*ad/100;\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      /* check lower leftmost point from right side */\n", "      if (box1->frame_vector[i5][0]>(x0+2*x1)/3) Break;\n", "      if (box1->frame_vector[i5][0]>(x0+  x1)/2) ad=98*ad/100;\n", "      if (box1->frame_vector[i5][0]>(2*x0+2+x1)/3) ad=99*ad/100; /* 9x10 2 */\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      if (box1->frame_vector[i5][1]<(3*y0+5*y1)/8) Break;\n", "      if (box1->frame_vector[i5][1]<(y0+3*y1)/4) ad=99*ad/100;\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      if (box1->frame_vector[i6][1]>(y0+2*y1)/3) Break;\n", "      if (box1->frame_vector[i6][1]>(y0+  y1)/2) ad=99*ad/100;\n", "      MSG( fprintf(stderr,\"ad %d\", ad); )\n", "      if (box1->frame_vector[i6][0]<(x0+3*x1)/4) Break;\n", "      if (box1->frame_vector[i6][0]<(x0+7*x1)/8) ad=99*ad/100;\n", " \n", "      /* check for zZ */\n", "     \n", "      /* check if lower left and right points are joined directly */\n", "      ld=line_deviation(box1, i3, i4);\n", "      MSG(fprintf(stderr,\"i1-i2 %d %d dist= %d/%d\",i1,i2,ld,2*sq(1024/4));)\n", "      if (ld >2*sq(1024/4)) Break;\n", "      if (ld >  sq(1024/4)) ad=99*ad/100;\n", "\n", "      if (box1->m3) {\n", "        if(!hchar){ ad=99*ad/100; }\n", "        if( gchar){ ad=99*ad/100; }\n", "      } else { if (ad==100) ad=99; } /* not 100% sure */\n", "      Setac(box1,'2',ad);\n", "      if (ad==100) return '2';\n", "      break;\n", "   }\n", "   // --- test 3 -------\n", "   for(ad=d=100;dx>3 && dy>4;){\t// dy<=dx nicht perfekt! besser mittleres\n", "\t\t\t\t// min-suchen fuer m\n", "      int i1, i2, i3, i4, i5, i6, i7, i8;  // line derivation + corners\n", "      DBG( char c_ask='3'; )\n", "      if (sdata->holes.num > 1) Break; /* be tolerant */\n", "      if (sdata->holes.num > 0) ad=98*ad/100; /* be tolerant */\n", "      if (4*dx<dy) ad=98*ad/100; // to tall 1:2 - 1:3 is usual \n", "      // --- vector based code ---\n", "      /* half distance to the center */\n", "      d=2*sq(128/4);\n", "      /* now we check for the lower ends, must be near to the corner */\n", "      if (aa[1][2]>d/1) Break;  /* [2] = distance, ~7... */\n", "      if (aa[2][2]>d/1) Break;  /* [2] = distance, ~r... */\n", "      if (aa[0][2]>d/1) Break;  /* [2] = distance, ~d... */\n", "      if (aa[3][2]>d/1) Break;  /* [2] = distance, ~bhk... */\n", "/*\n", "    type A       B      C\n", "                    \n", "        1OO8   1OO   1OO8\n", "           O      8    2    <- 7,8 \n", "           2      2   7      \n", " 1-5->  3OO7    37   3OO\n", "           4      4     4\n", "           O      6     6   <- 6\n", "        5OO6   5OO   5OO\n", "*/\n", "      /* rightmost point on upper left side */\n", "      i2=nearest_frame_vector(box1, aa[0][3], aa[1][3], x1, y0+3*dy/16);\n", "      /* rightmost point on lower left side */\n", "      i4=nearest_frame_vector(box1, aa[0][3], aa[1][3], x1, y1-dy/4);\n", "      /* leftmost point on middle left side */\n", "      i3=nearest_frame_vector(box1,       i2,       i4, x0, y0+dy/2);\n", "      /* upper leftmost vector */\n", "      i1=nearest_frame_vector(box1, aa[0][3], i2, x0-dx, (y0+y1)/2);\n", "      i5=aa[1][3]; // points to vector point in point list\n", "      i6=aa[2][3];\n", "      i8=aa[3][3];\n", "      /* leftmost point on middle right side */\n", "      i7=nearest_frame_vector(box1,       i6,       i8, x0   , y0+dy/2);\n", "      /* which type? ToDo: have a more sure algorithm */\n", "      if (box1->frame_vector[i7][0]>=x1-  dx/4\n", "       && box1->frame_vector[i6][0]>=x1-  dx/8 // ToDo: ...\n", "       && box1->frame_vector[i6][1]>=y1-  dy/8) {\n", "        MSG(fprintf(stderr,\"7-segment-type\");)   \n", "      } else { /* regular-book-type */\n", "      }\n", "      // ToDo: output no=(x,y)\n", "      MSG(fprintf(stderr,\"i1-8 %d %d %d %d %d %d %d %d\",i1,i2,i3,i4,i5,i6,i7,i8);)\n", "      // if (i5==i6) Break; // ~+\n", "  \n", "      // i2 = upper left gap ) , i3 = middle left <\n", "      if (box1->frame_vector[i2][0]\n", "         -box1->frame_vector[i3][0]<dx/4) Break; // video samples\n", "      if (box1->frame_vector[i4][0]\n", "         -box1->frame_vector[i3][0]<dx/4) Break; // video samples\n", "      if (box1->frame_vector[i4][0]\n", "         -box1->frame_vector[i5][0]<dx/2) Break; // video samples\n", "      if (box1->frame_vector[i2][0]\n", "         -box1->frame_vector[i1][0]<dx/2) Break; // video samples\n", "      if (box1->frame_vector[i1][1]>y0+dy/2) Break; // not to low\n", "      if (box1->frame_vector[i1][0]>x0+dx/4+dx/16) Break; // slanted?\n", "      if (box1->frame_vector[i5][1]<y1-dy/2) Break; // not to high\n", "      if (box1->frame_vector[i5][0]>x0+dx/4) Break;\n", "      // ToDo ....\n", "\n", "      // --- pixel based old code ---\n", "      // if( get_bw(x0+dx/2,x0+dx/2,y0,y0+dy/4,box1->p,cs,1) == 0 ) Break; // ~4\n", "      // if( get_bw(x0+dx/2,x0+dx/2,y1-dy/8,y1,box1->p,cs,1) == 0 ) Break; // ~4\n", "      // if( num_cross(x0+dx/2,x0+dx/2,y0     ,y1,box1->p,cs) < 2 ) Break;\n", "      // if( num_cross(x0+dx/4,x0+dx/4,y1-dy/2,y1,box1->p,cs) == 0 ) Break;\n", "      if( get_bw(dx/2,dx/2,        0,dy/6,bp,cs,1) == 0 ) Break; // ~4\n", "      if( get_bw(dx/2,dx-1,     dy/6,dy/6,bp,cs,1) == 0 ) Break; // ~j\n", "      if( get_bw(dx/2,dx/2,dy-1-dy/8,dy-1,bp,cs,1) == 0 ) Break; // ~4\n", "      if( num_cross(dx/2,dx/2,0        ,dy-1,bp,cs) < 2          // normal\n", "       && num_cross(dx/3,dx/3,0        ,dy-1,bp,cs) < 2 ) Break; // fat LCD\n", "      if( num_cross(dx/4,dx/4,dy-1-dy/2,dy-1,bp,cs) == 0 ) Break;\n", "      if( loop(bp,dx/2,  0   ,dy,cs,0,DO)>dy/4 ) Break;\n", "      if( loop(bp,dx/2,  dy-1,dy,cs,0,UP)>dy/4 ) Break;\n", "      if( loop(bp,dx-1,  dy/3,dy,cs,0,LE)>dy/4 /* 3 with upper bow */\n", "       && loop(bp,dx-1,  dy/8,dy,cs,0,LE)>dy/4 /* 3 with horizontal line */\n", "       && loop(bp,dx/4,  dy/8,dy,cs,1,RI)<dy/2 ) Break;\n", "      if( loop(bp,dx-1,2*dy/3,dy,cs,0,LE)>dy/4 ) Break;\n", "      if( loop(bp,dx-1,3*dy/4,dy,cs,0,LE)>dy/2 ) Break; // ~2 Feb06\n", "      if( loop(bp,dx-1,7*dy/8,dy,cs,0,LE)>dy/2 ) Break; // ~2 Feb06\n", "      // search upper right half circle (may fail on 4x5 font)\n", "      for( i3=x=0,i1=y=dy/5;y<dy/2;y++ ){\n", "        i=loop(bp,0,y,dx,cs,0,RI);\n", "        if (i>x) { i3=x=i; i1=y; }\n", "      } i3--;\n", "      if( loop(bp,i3,i1,1,cs,0,UP)==1 ) { // find hidden gap in tiny fonts\n", "        i1--; i3+=loop(bp,i3,i1,dx,cs,0,RI)-1;\n", "      }\n", "      if (i3<dx/3 && i3+1+loop(bp,i3+1,i1,dx,cs,1,RI)<3*dx/4) Break;\n", "      if (loop(bp,dx-1,i1,dx,cs,0,LE)>1+dx/8) ad=ad*99/100; // ~1 with a pixel\n", "      // search lower right half circle\n", "      for( i4=x=0,i2=y=dy-1-dy/8;y>=dy/2;y-- ){\n", "        i=loop(bp,0,y,dx,cs,0,RI);\n", "        if( i>x ) { i4=x=i;i2=y; }\n", "      } i4--; if(i4<dx/3 && i4+1+loop(bp,i4+1,i2,dx,cs,1,RI)<3*dx/4) Break;\n", "      if (loop(bp,dx-1,i2,dx,cs,0,LE)>1+dx/8) ad=ad*99/100; // ~1 with a pixel\n", "\n", "      for( x=xa=0,ya=y=dy/4;y<3*dy/4;y++ ){  // right gap, not on LCD-font\n", "        i=loop(bp,dx-1,y,dx,cs,0,LE);\n", "        if (i>=xa) { xa=i;ya=y;x=xa+loop(bp,dx-1-xa,y,dx,cs,1,LE); }\n", "      } if (dy>3*dx) if (xa<2 && x-xa<dx/2) Break; // ~]\n", "      if (xa>1+dx/8 // noLCD\n", "        && xa<=loop(bp,dx-1,i2,dx,cs,0,LE)) ad=ad*99/100; // ~1 with a pixel\n", "      if (xa>1+dx/8 // noLCD\n", "        && xa<=loop(bp,dx-1,i1,dx,cs,0,LE)) ad=ad*99/100; // ~1 with a pixel\n", "      \n", "      // upper left gap = (i3,i1)\n", "      // lower left gap = (i4,i2)\n", "      MSG(fprintf(stderr,\"left white gaps (%d,%d) (%d,%d)\",i3,i1,i4,i2);)\n", "      if( get_bw(i3,i3,i1,i2  ,bp,cs,1) != 1 ) Break; // no hor. middle line?\n", "      if( get_bw(i4,i4,i1,i2  ,bp,cs,1) != 1 ) Break;\n", "      if( get_bw(i3,i3,0 ,i1  ,bp,cs,1) != 1 ) Break; // no upper bow?\n", "      if( get_bw(i4,i4,i2,dy-1,bp,cs,1) != 1 ) Break; // no lower bow?\n", "      // hole is only allowed in beauty fonts\n", "      // if( num_hole( x0, x1,      y0,      y1,box1->p,cs,NULL) > 0 ) // there is no hole\n", "      // if( num_hole( x0, x0+dx/2, y0, y0+dy/2,box1->p,cs,NULL) == 0 ) // except in some beauty fonts\n", "      if (sdata->holes.num>0)\n", "      if (sdata->holes.hole[0].x1 >= dx/2 || sdata->holes.hole[0].y1 >= dy/2)\n", "        Break;\n", "      Setac(box1,(wchar_t)'3',ad);\n", "      if (ad==100) return '3';\n", "      break;\n", "   }\n", "   // --- test 4 --------------------------------------------------- 25Nov06\n", "   for(ad=d=100;dy>3 && dx>2;){     // min 3x4 ~<gA',\n", "     // rewritten for vectors 0.42\n", "      int ld, i1, i2, i3, i4, i5, i6, i7, i2up, i2dwn;  // line derivation + corners\n", "      DBG( wchar_t c_ask='4'; )\n", "      if (sdata->holes.num > 1) Break; /* no or one hole */\n", "      /* half distance to the center */\n", "      d=2*sq(128/4); /* 2048 */\n", "      /* now we check for the lower left end, must be far away */\n", "      /* lowest is 144 for 9x10 screen font (Apr2009) */\n", "      if (aa[1][2]<d/16) {  /* Apr09: d/8=256 to d/16=128 */\n", "        MSG( fprintf(stderr,\" low-left-dist= %d < max= %d\", aa[1][2], d); )\n", "        Break;  /* [2] = distance, ~ABDEF... */\n", "      }\n", "      /* searching for 4 notches between neighbouring ends */\n", "\n", "/*                                       5x8 2010-10\n", "    type A       B      C      D            ...@.<-\n", "                                            ..@@.\n", "        1  5   1        1      1            .@.@.<\n", "        O  O   O       O5     O5            @..@.  left=i2up\n", "        2OO3   O 5    O O    O O   <- 7 6   @..@.\n", "           O   2O3O  2OO3   2OO3O           @@@@@\n", "           4     4      4      4            ...@.\n", "                                            ...@.<-\n", "                                         \n", "           \n", "     y4-y3 should be significant (bigger y3-y6)?\n", "*/\n", "\n", "      /* Warning: aa0 can be left upper or left lower point for type B */\n", "      /* get a point on the inner low left side of the J */\n", "      i =box1->num_frame_vectors[0] - 1;\n", "      /* leftmost upper point */\n", "      i1=nearest_frame_vector(box1, 0, i, x0, y0-dy);\n", "      /* lowest from leftmost vector can be very low (20/23) */\n", "      i2=nearest_frame_vector(box1, 0, i, x0-2*dx, (y0+7*y1)/8);\n", "      i2up=\n", "         nearest_frame_vector(box1, 0, i, x0-2*dx, (5*y0+3*y1)/8);\n", "      i2dwn=\n", "         nearest_frame_vector(box1, 0, i, x0-4, y1+4);\n", "      /* lowest vector */\n", "      i4=nearest_frame_vector(box1, 0, i, (x0+2*x1)/3, y1+dy);\n", "      /* right center crossing point */     \n", "      i3=nearest_frame_vector(box1, i2, i4, x1, (3*y0+y1)/4);\n", "      /* get a point on the outer right side below top serif */\n", "      /* next local max_y-point after i4 */\n", "      i5=i4;\n", "      for (i=i4;i!=i2;i=(i+1)%box1->num_frame_vectors[0]) {\n", "        if (box1->frame_vector[ i][1]\n", "           <box1->frame_vector[i5][1]) i5=i; // get next maximum\n", "        if (box1->frame_vector[ i][1]\n", "           >box1->frame_vector[i5][1]+1) break; // break after maximum\n", "        if (box1->frame_vector[ i][0]<x0+dx/4) break; // type A B\n", "      }\n", "      if (box1->num_frames>1) {  // type C D\n", "        i = box1->num_frame_vectors[0] - 1; // end outer loop\n", "        j = box1->num_frame_vectors[1] - 1; // end inner loop\n", "        if (box1->num_frames>2) { // see font2.png, 2nd one pixel hole\n", "          j = box1->num_frame_vectors[2] - 1; // end inner loop\n", "          ad=99*ad/100; // little bit unsure\n", "        }\n", "        i6=nearest_frame_vector(box1, i+1, j, x1, y1);\n", "        i7=nearest_frame_vector(box1, i+1, j, x0, y1);\n", "        if (box1->frame_vector[i1][0]\n", "           -box1->frame_vector[i2][0]<dx/4+1) ad=96*ad/100; // ~4x6q\n", "        i =nearest_frame_vector(box1, i+1, j, x0, y0); // top left\n", "        MSG(fprintf(stderr,\"triangle type top-left i=%d\",i);)\n", "        if (box1->frame_vector[i ][0]-x0<dx/4+1\n", "         && box1->frame_vector[i ][1]-y0<dy/4+1\n", "         && dx>7) ad=97*ad/100; // q\n", "        \n", "      } else {  // type A B\n", "        i6=nearest_frame_vector(box1, i5, i1, (x0+3*x1)/4, y1-dy/8);\n", "        i7=nearest_frame_vector(box1, i5, i1,  x0        , y1-dy/8);\n", "        MSG(fprintf(stderr,\"open type\");)\n", "        if (box1->frame_vector[i6][1]-y0>3*dy/4\n", "         || box1->frame_vector[i7][1]-y0>3*dy/4) ad=96*ad/100; // ~uU\n", "      }\n", "      // ToDo: output no=(x,y)\n", "      MSG(fprintf(stderr,\"i1-7 %d %d %d %d %d %d %d 2up %d\",i1,i2,i3,i4,i5,i6,i7,i2up);)\n", "      if (i5==i6) Break; // ~+\n", "      \n", "      if (sdata->holes.num == 1    // handwritten 'a' ? 2018-09\n", "        && box1->frame_vector[i1][0] <= x0+2*dx/3 // left upper corner\n", "        && box1->frame_vector[i1][1] <= y0+  dy/8\n", "        && (!hchar)\n", "      ) { ad=96*ad/100; MSG(fprintf(stderr,\"more an (a)? ad= %d\",ad);)}\n", "      \n", "      MSG(fprintf(stderr,\"i2dwn=%d\",i2dwn);)\n", "      if (sdata->holes.num == 0    // handwritten 'u' ? 2018-09\n", "        && box1->frame_vector[i2dwn][0] <= x0+dx/2 // left upper corner\n", "        && box1->frame_vector[i2dwn][1] >= y1-dy/8\n", "        && (!hchar)\n", "      ) { ad=96*ad/100; MSG(fprintf(stderr,\"more an (u)? ad= %d\",ad);)}\n", "      \n", "      if (box1->frame_vector[i1][1]>y0+dy/8) Break; // not to low\n", "      if (box1->frame_vector[i2][1]\n", "         -box1->frame_vector[i1][1]<dy/2) Break;\n", "      if (box1->frame_vector[i3][0]\n", "         -box1->frame_vector[i2][0]<dx/4) Break;\n", "      if (abs(box1->frame_vector[i3][1]\n", "             -box1->frame_vector[i2][1])>dy/4) Break;\n", "      if (box1->frame_vector[i2][0]>x0+dx/8) Break;\n", "      if (box1->frame_vector[i2][1]>y1-dy/8) Break;\n", "      if (box1->frame_vector[i4][1]\n", "         -box1->frame_vector[i2][1]<dy/8) Break;\n", "      if (box1->frame_vector[i4][1]\n", "         -box1->frame_vector[i2][1]<dy/6) ad=99*ad/100;\n", "      /* min. distance of the horizontal bar to the ground */\n", "      /* y4-y3 should be significant (bigger y3-y6)? */\n", "      if (box1->frame_vector[i4][1]\n", "         -box1->frame_vector[i3][1]<1+dy/16) Break;\n", "      if ((box1->frame_vector[i4][1]\n", "          -box1->frame_vector[i3][1])*2<=\n", "          (box1->frame_vector[i3][1]\n", "          -box1->frame_vector[i6][1])) Break; // 090728 gas_meter (flat-ulike)\n", "      if ((box1->frame_vector[i4][1]\n", "          -box1->frame_vector[i3][1])<\n", "          (box1->frame_vector[i3][1]\n", "          -box1->frame_vector[i6][1])) ad=99*ad/100;\n", "      if (box1->frame_vector[i4][1]\n", "         -box1->frame_vector[i3][1]<dy/6) ad=99*ad/100; /* tall chars */\n", "      if (box1->frame_vector[i4][1]\n", "         -box1->frame_vector[i3][1]<dy/8) ad=99*ad/100;\n", "      if (box1->frame_vector[i4][1]<y1-1-dy/8) Break;\n", "      if (box1->frame_vector[i3][0]<x0+dx/4) Break;\n", "      if (box1->frame_vector[i3][0]<x0+dx/2) ad=98*ad/100;\n", "      /* on very tall chars the i3 point can be near to the groundline */\n", "      if (box1->frame_vector[i3][1]>y1-1) Break;\n", "      if (box1->frame_vector[i3][1]>y1-dy/16) Break;\n", "      if (box1->frame_vector[i3][1]>=y1) Break; // ~5x5#\n", "      if (box1->frame_vector[i5][0]<x0+dx/3) Break;\n", "      /* upper end of right vertical line */\n", "      if (box1->frame_vector[i5][1]>y0+2*dy/3) Break;\n", "      if (box1->frame_vector[i6][1]\n", "         -box1->frame_vector[i5][1]<1+dy/16) Break;\n", "      if (box1->frame_vector[i6][0]<x0+dx/3) Break;\n", "      if (box1->frame_vector[i7][0]>x0+dx/2) Break;\n", "      if (box1->frame_vector[i7][0]>x0+dx/3) ad=ad*99/100;\n", "      if (box1->frame_vector[i6][1]<y0+dy/3) Break;\n", "      if (box1->frame_vector[i6][0]<x0+dx/2) ad=96*ad/100; // ~ 42\n", "      if (box1->frame_vector[i6][0]<aa[2][0]-dx/2\n", "                     && aa[2][1]>=y1-1-dy/8) ad=96*ad/100; // ~ 42\n", "      if (box1->frame_vector[i7][1]<y0+dy/3) Break;\n", "      if (abs(box1->frame_vector[i3][1]\n", "             -box1->frame_vector[i2][1])>dy/4) Break;\n", "      \n", "      /* check if upper left and lower left points are joined directly */\n", "      ld=line_deviation(box1, i1, i2up);\n", "      MSG(fprintf(stderr,\"i1-i2up %d %d dist= %d/%d\",i1,i2up,ld,2*sq(1024/4));)\n", "      if (ld >2*sq(1024/4)) Break;\n", "      if (i2!=i2up) ld=line_deviation(box1, i2up, i2); else  ld=0;\n", "      MSG(fprintf(stderr,\"i2up-i2 %d %d dist= %d/%d\",i2up,i2,ld,2*sq(1024/4));)\n", "      if (ld >2*sq(1024/4)) Break;\n", "      /* check if lower right and upper right points are joined directly */\n", "      ld=line_deviation(box1, i2, i3);\n", "      MSG(fprintf(stderr,\"i2-i3 %d %d dist= %d/%d\",i2,i3,ld,2*sq(1024/4));)\n", "      if (ld >  sq(1024/4)) Break;\n", "      /* check if lower right and upper right points are joined directly */\n", "      ld=line_deviation(box1, i3, i4);\n", "      MSG(fprintf(stderr,\"i3-i4 %d %d dist= %d/%d\",i3,i4,ld,2*sq(1024/4));)\n", "      if (ld >  sq(1024/4)) Break;\n", "      /* check if lower right and upper right points are joined directly */\n", "      ld=line_deviation(box1, i6, i7);\n", "      MSG(fprintf(stderr,\"i6-i7 %d %d dist= %d/%d\",i6,i7,ld,2*sq(1024/4));)\n", "      if (ld >2*sq(1024/4)) Break;\n", "      \n", "      // handwritten a i1=(9,0) i5=(21,1)  Aug2010\n", "      if (sdata->holes.num == 1  // type C and D against italic a, alpha\n", "       && // expect no distance between 1 and 5\n", "         box1->frame_vector[i5][0]\n", "       - box1->frame_vector[i1][0] > dx/4 ) Break;\n", "\n", "      // 4 exists as gchar and ~gchar\n", "      if(!hchar){ ad=99*ad/100; }\n", "      Setac(box1,'4',ad);\n", "      break;\n", "   }\n", "#ifdef Old_pixel_based \n", "   // --- old test 4 pixelbased ------- remove!\n", "   for(ad=d=100;dx>3 && dy>5;){     // dy>dx, min 4x6 font\n", "      DBG( char c_ask='4'; )\n", "      if (sdata->holes.num > 2) Break; /* be tolerant */\n", "      if (sdata->holes.num > 1) ad=97*ad/100;\n", "      // upper raising or vertical line\n", "      if( loop(bp,0   ,3*dy/16,dx,cs,0,RI)\n", "        < loop(bp,0   ,2*dy/4 ,dx,cs,0,RI)-dx/8 ) Break;\n", "      // search for a vertical line on lower end\n", "      for (y=0;y<dy/4;y++)\n", "       if( loop(bp,0   ,dy-1-y,dx,cs,0,RI)\n", "         + loop(bp,dx-1,dy-1-y,dx,cs,0,LE) >= dx/2 ) break;\n", "      if (y>=dy/4) Break;\n", "      if( loop(bp,0   ,dy-1-dy/8,dx,cs,0,RI) <  dx/4 ) Break;\n", "      // --- follow line from (1,0) to (0,.7)\n", "      y=0; x=loop(bp,0,0,dx,cs,0,RI);\n", "      if (x<=dx/4) {  // ocr-a-4\n", "        i=loop(bp,0,dy/4,dx,cs,0,RI); if (i>dx/4) Break;\n", "        i=loop(bp,i,dy/4,dx,cs,1,RI); if (i>dx/2) Break;\n", "        j=loop(bp,i,dy/4,dy,cs,0,DO)+dy/4; if (j>7*dy/8) Break;\n", "      }\n", "      turmite(bp,&x,&y,0,dx-1,0,dy-1,cs,DO,LE); if( x>=0 ) Break;\n", "\n", "      y=loop(bp,0,0,dy,cs,0,DO);\n", "      if( (y+loop(bp,0,y,dy,cs,1,DO)) < dy/2 ) Break;\n", "      if( get_bw(x0   , x0+3*dx/8, y1-dy/7, y1-dy/7,box1->p,cs,1) == 1 ) Break;\n", "      if( get_bw(x0+dx/2, x1     , y1-dy/3, y1-dy/3,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2, x0+dx/2, y0+dy/3, y1-dy/5,box1->p,cs,1) != 1 ) Break;\n", "      i=loop(bp,bp->x-1,  bp->y/4,dx,cs,0,LE);\n", "      if( i > loop(bp,bp->x-1,2*bp->y/4,dx,cs,0,LE)+1\n", "       && i > loop(bp,bp->x-1,3*bp->y/8,dx,cs,0,LE)+1 ) Break;\n", "      if (loop(bp,0,0,dx,cs,0,RI)>dx/4) {\n", "        for(i=dx/8+1,x=0;x<dx && i;x++){\n", "          if( num_cross(x ,x   ,0  ,dy-1, bp,cs) == 2 ) i--;\n", "        } if( i ) Break;\n", "      }\n", "      for(i=dy/6+1,y=dy/4;y<dy && i;y++){\n", "        if( num_cross(0 ,dx-1,y  ,y   , bp,cs) == 2 ) i--;\n", "      } if( dy>15 && i ) Break;\n", "      for(i=dy/10+1,y=dy-1-dy/4;y<dy && i;y++){\n", "        if( num_cross(0   ,dx-1,y ,y  , bp,cs) == 1 )\n", "        if( num_cross(dx/2,dx-1,y ,y  , bp,cs) == 1 ) i--;\n", "      } if( i ) Break;\n", "      // i4 = num_hole ( x0, x1, y0, y1,box1->p,cs,NULL);\n", "      // ToDo:\n", "      //   - get start and endpoint of left edge of left vert. line\n", "      //       and check if that is an streight line\n", "      //   - check the right edge of the inner hole (if there) too\n", "      i4 = sdata->holes.num;\n", "      if (sdata->holes.num >0) { // ~q\n", "        i = loop(bp,0,dy/16,dx,cs,0,RI);\n", "        if (i < dx/3) Break;\n", "        if (i < dx/2) ad=98*ad/100; // hole?\n", "        if ( loop(bp,     0,dy-1,dy,cs,0,UP)\n", "            -loop(bp,dx/8+1,dy-1,dy,cs,0,UP)>dy/16) ad=97*ad/100;\n", "      }\n", "      // thickness of left vertical line\n", "      for (j=y=0;y<dy/6;y++) {\n", "        i=loop(bp,dx-1  ,y,dx,cs,0,LE);\n", "        i=loop(bp,dx-1-i,y,dx,cs,1,LE); if (i>j) j=i;\n", "      }\n", "      if (j>=dx/2) ad=98*ad/100; // ~q handwritten a (or very thinn 4)\n", "      // ToDo: check y of masscenter of the hole q4\n", "      \n", "      if( i4 ) if( dx > 15 )\n", "      if( loop(bp,  dx/2,   0,dy,cs,0,DO)<dy/16\n", "       && loop(bp,  dx/4,   0,dy,cs,0,DO)<dy/8\n", "       && loop(bp,3*dx/4,   0,dy,cs,0,DO)<dy/8\n", "       && loop(bp,  dx/4,dy-1,dy,cs,0,UP)<dy/8\n", "       && loop(bp,  dx/2,dy-1,dy,cs,0,UP)<dy/8\n", "       && loop(bp,3*dx/4,dy-1,dy,cs,0,UP)<dy/4 ) Break; // ~9\n", "\n", "      i =loop(bp,dx-1  ,dy-1,dx,cs,0,LE); // ~9\n", "      i+=loop(bp,dx-1-i,dy-1,dx,cs,1,LE);\n", "      if( i>3*dx/4\n", "       && i-loop(bp,dx-1,dy-1-dy/8,dx,cs,0,LE)>dx/4 ) Break;\n", "       \n", "      i =loop(bp,dx-1-dx/4,dy-1,dx,cs,0,UP);\n", "      if (i>  dy/2) ad=97*ad/100;\n", "      if (i>3*dy/4) ad=97*ad/100;  /* handwritten n */\n", "\n", "      if( num_cross(0 ,dx-1,dy/16 ,dy/16  , bp,cs) == 2 // ~9\n", "       && loop(bp,dx-1,dy/16        ,dx,cs,0,LE)>\n", "          loop(bp,dx-1,dy/16+1+dy/32,dx,cs,0,LE) ) Break;\n", "      if (         !hchar) ad=99*ad/100;\n", "      if (gchar && !hchar) ad=98*ad/100; // ~q\n", "      Setac(box1,(wchar_t)'4',ad);      \n", "      // if (ad>99) bc='4';\n", "      break;\n", "   }\n", "#endif\n", "   // --- test 6 ------- ocr-a-6 looks like a b  :(\n", "   for(ad=d=100;dx>3 && dy>4;){     // dy>dx\n", "      DBG( char c_ask='6'; )\n", "      if (sdata->holes.num > 2) Break; /* be tolerant */\n", "      if( loop(bp,   0,  dy/4,dx,cs,0,RI)>dx/2          // ocr-a=6\n", "       && loop(bp,dx-1,     0,dy,cs,0,DO)>dy/4 ) Break; // italic-6\n", "      if( loop(bp,   0,  dy/2,dx,cs,0,RI)>dx/4 ) Break;\n", "      if( loop(bp,   0,3*dy/4,dx,cs,0,RI)>dx/4 ) Break;\n", "      if( loop(bp,dx-1,3*dy/4,dx,cs,0,LE)>dx/2 ) Break;\n", "      if( num_cross(x0+  dx/2,x0+  dx/2,y0     ,y1     ,box1->p,cs) != 3\n", "       && num_cross(x0+5*dx/8,x0+5*dx/8,y0     ,y1     ,box1->p,cs) != 3 ) {\n", "        if( num_cross(x0+  dx/2,x0+  dx/2,y0+dy/4,y1     ,box1->p,cs) != 2\n", "         && num_cross(x0+5*dx/8,x0+5*dx/8,y0+dy/4,y1     ,box1->p,cs) != 2 ) Break;\n", "        // here we have the problem to decide between ocr-a-6 and b\n", "        if ( loop(box1->p,(x0+x1)/2,y0,dy,cs,0,DO)<dy/2 ) Break;\n", "        ad=99*ad/100;\n", "      } else {\n", "        if (loop(box1->p,x0+dx/2,y0,dx,cs,0,DO)>dy/8\n", "         && loop(box1->p,x1-dx/4,y0,dx,cs,0,DO)>dy/8 ) Break;\n", "      }\n", "      if( num_cross(x0     ,x1     ,y1-dy/4,y1-dy/4,box1->p,cs) != 2 ) Break;\n", "      for( y=y0+dy/6;y<y0+dy/2;y++ ){\n", "        x =loop(box1->p,x1    ,y  ,dx,cs,0,LE); if( x>dx/2 ) break;\n", "        x+=loop(box1->p,x1-x+1,y-1,dx,cs,0,LE); if( x>dx/2 ) break;\n", "      } if( y>=y0+dy/2 ) Break;\n", "      if (loop(box1->p,x0,y1-dy/3,dx,cs,0,RI)>dx/4 ) Break;\n", "      if (loop(box1->p,x1,y1-dy/3,dx,cs,0,LE)>dx/4 ) Break;\n", "\n", "      if (sdata->holes.num != 1) Break;\n", "      if (sdata->holes.hole[0].y1 < dy/2) ad=95*ad/100; // whats good for?\n", "      if (sdata->holes.hole[0].y0 < dy/4) Break;\n", "      MSG( fprintf(stderr,\"hole[0].x0,x1 %d %d\", sdata->holes.hole[0].x0,\n", "           sdata->holes.hole[0].x1); )\n", "      if (sdata->holes.hole[0].x0<1\n", "        && dx-1-sdata->holes.hole[0].x1>2) ad=ad*99/100; // melted serif sS ?\n", "      if (loop(box1->p,x0,y0+dy/2,dx,cs,0,RI)>0\n", "       && loop(box1->p,x0,y0+dy/4,dx,cs,0,RI)==0\n", "       && loop(box1->p,x0,y1-dy/4,dx,cs,0,RI)==0) ad=97*ad/100; // molten serif sS\n", "//      if( num_hole ( x0, x1, y0, y0+dy/2,box1->p,cs,NULL) >  0 ) ad=95*ad/100; \n", "//      if( num_hole ( x0, x1, y0+dy/4, y1,box1->p,cs,NULL) != 1 ) Break; \n", "//      if( num_hole ( x0, x1, y0     , y1,box1->p,cs,NULL) != 1 ) Break; \n", "//    out_x(box1); printf(\" x0 y0 %d %d\\n\",x0,y0);\n", "      /* check left vertical bow */\n", "      i1=loop(bp,0,dy/8     ,dx,cs,0,RI);\n", "      i3=loop(bp,0,dy-1-dy/8,dx,cs,0,RI);\n", "      i2=loop(bp,0,dy/2     ,dx,cs,0,RI); \n", "      if(i1+i3-2*i2<-2-dx/16 && i1+i2+i3>0) Break;  // convex from left\n", "      if(i1+i3-2*i2<1        && i1+i2+i3>0) ad=99*ad/100;  // 7-segment-font\n", "      for( x=dx,y=0;y<dy/4;y++ ){\t// ~ b (serife?)\n", "        i1=loop(bp, 0,y,dx,cs,0,RI);\n", "        i2=loop(bp,i1,y,dx,cs,1,RI);\n", "        if (i2+i1>dx/2 && i2>dx/4) break; /* its a 6 (example: 7-segment) */\n", "        if (i1<x) x=i1; else if (i1>x) break; /* may be serifen b */\n", "      } if (y<dy/4 && i1+i2<=dx/2) Break;\n", "      // ~& (with open upper loop)\n", "      for( i=0,y=dy/2;y<dy;y++){\n", "        if( num_cross(dx/2,dx-1,y,y,bp,cs) > 1 ) i++; if( i>dy/8 ) break;\n", "      } if( y<dy ) Break;\n", "      if ( gchar) ad=99*ad/100;\n", "      if (!hchar) ad=98*ad/100;\n", "      if ( box1->dots ) ad=98*ad/100;\n", "      Setac(box1,(wchar_t)'6',ad);\n", "      // bc='6';\n", "      break;\n", "   }\n", "   // --- test 7 ---------------------------------------------------\n", "   for(ad=d=100;dx>2 && dy>4;){     // dx>1 dy>2*dx\n", "      DBG( wchar_t c_ask='7'; )\n", "      if (sdata->holes.num > 0) Break; /* no hole */\n", "      /* half distance to the center */\n", "      d=2*sq(128/4);\n", "      /* now we check for the lower ends, must be near to the corner */\n", "      if (aa[1][2]<d/4        \n", "       && aa[2][2]<d/4) Break;  /* [2] = distance, ~2... */\n", "      if (aa[0][2]>d/2) Break;  /* [2] = distance, ~d... */\n", "      if (aa[3][2]>d/2) Break;  /* [2] = distance, ~bhk... */\n", "      /* check for upper long line ~) 4x11 */\n", "      if (4*(aa[3][0]-aa[0][0])<3*dx) Break;\n", "      /* check for low end width ~2 2017-07 */\n", "      j=loop(bp,0,dy-1,dx,cs,0,RI);\n", "      j=loop(bp,j,dy-1,dx,cs,1,RI); if(3*j>dx) Break; // max thickness 1/3\n", "      /* searching for 4 notches between neighbouring ends */\n", "      if( loop(bp,dx/2,0,dy,cs,0,DO)>dy/8 ) Break;\n", "      if( num_cross(0,dx-1,3*dy/4,3*dy/4,bp,cs) != 1 ) Break; // preselect\n", "      for( yb=xb=y=0;y<dy/2;y++){ // upper h-line and gap\n", "        j=loop(bp,0,y,dx,cs,0,RI);if(xb>0 && j>dx/4) break; // gap after h-line\n", "        j=loop(bp,j,y,dx,cs,1,RI);if(j>xb){ xb=j;yb=y; }  // h-line\n", "      } if( xb<dx/4 || y==dy/2 ) Break;\n", "      j=loop(bp,0,dy/2,dx,cs,0,RI);\n", "      j=loop(bp,j,dy/2,dx,cs,1,RI); if(xb<2*j) Break; // minimum thickness\n", "      for(x=0,y+=dy/16;y<dy;y++){\t// one v-line?\n", "        if( num_cross(0,dx-1,y,y,bp,cs) != 1 ) break;\n", "        j=loop(bp,dx-1,y,dx,cs,0,LE); if( j<x ) break; if( j-1>x ) x=j-1;\n", "      } if( y<dy || x<dx/3 ) {\n", "         MSG( fprintf(stderr,\"xy= %d %d\",x,y); )\n", "         Break;\n", "      }\n", "      j =loop(bp,dx-1,0,dy,cs,0,DO);  // ~T\n", "      j+=loop(bp,dx-1,j,dy,cs,1,DO)+dy/16;\n", "      i =loop(bp,dx-1,j,dx,cs,0,LE); if(j<dy/2) {\n", "       if (i>j) Break;\n", "       j=loop(bp,   0,j,dx,cs,0,RI);\n", "       if(j>dx/4 && j<=i+dx/16) Break; // tall T\n", "      }\n", "\n", "      MSG( fprintf(stderr,\"7: ad= %d\",ad); )\n", "      if(   loop(bp,   0,3*dy/8,dx,cs,0,RI)\n", "          <=loop(bp,dx-1,3*dy/8,dx,cs,0,LE)+dx/8 ) ad=ad*98/100; // l\n", "      MSG( fprintf(stderr,\"7: ad= %d\",ad); )\n", "      if( num_cross(0,dx-1,dy/4,dy/4,bp,cs) == 1\n", "       && loop(bp,0,dy/4,dx,cs,0,RI) < dx/2 ) ad=ad*96/100; // J\n", "      MSG( fprintf(stderr,\"7: ad= %d\",ad); )\n", "      /* check for upper long line ~) 4x11 */\n", "      if (box1->m3 &&   dy<box1->m3-box1->m2) ad=99*ad/100; // too small\n", "      if (box1->m3 && 2*dy<box1->m3-box1->m2) ad=96*ad/100; // too small\n", "      if (dy>3*dx) ad=99*ad/100; // )\n", "      if ( gchar)  ad=99*ad/100; // J\n", "      if (!hchar)  ad=99*ad/100;\n", "      Setac(box1,(wchar_t)'7',ad);\n", "      break;\n", "   }\n", "   // --- test 8 ---------------------------------------------------\n", "   // last change: May15th,2000 JS\n", "   for(ad=d=100;dx>2 && dy>4;){     //    or we need large height\n", "      DBG( char c_ask='8'; )\n", "      if (sdata->holes.num != 2) Break;\n", "      if( num_cross(x0,x1,y0  +dy/4,y0  +dy/4,box1->p,cs) != 2 ) Break; // ~gr (glued)\n", "      if( num_cross(x0,x1,y1  -dy/4,y1  -dy/4,box1->p,cs) != 2\n", "       && num_cross(x0,x1,y1-3*dy/8,y1-3*dy/8,box1->p,cs) != 2 ) Break;\n", "      if( get_bw(x0,x0+dx/4,y1-dy/4,y1-dy/4,box1->p,cs,1) == 0 ) Break; // ~9\n", "      if( get_bw(x0,x0+dx/2,y0+dy/4,y0+dy/4,box1->p,cs,1) == 0 ) Break;\n", "      if( get_bw(x0+dx/2,x0+dx/2,y0+dy/4,y1-dy/4,box1->p,cs,1) == 0 ) Break; // ~0\n", "// MSG( printf(\" x0 y0 %d %d\\n\",x0,y0); )\n", "      for( i2=i1=x=0,i=y=y0+dy/3;y<=y1-dy/3;y++){\t// check left middle nick\n", "\tj=loop(box1->p,x0,y,dx,cs,0,RI);\n", "\tif (j>x || (abs(j-x)<=dx/8  /* care about MICR E-13B font */\n", "                 && (i1=loop(box1->p,x0+j,y,dx,cs,1,RI))>dx/2)) {\n", "           if (j>x) x=j; i=y; if (i1>i2) i2=i1; }\n", "      } if(i>=y1-dy/3 || (x<dx/8 && i2<=dx/2) || x>dx/2) Break; // no gB\n", "      if (x< dx/4) ad=99*ad/100; // no B\n", "      if (x<=dx/8) ad=98*ad/100; // no B\n", "      j =   loop(box1->p,x1,y1-  dy/4,dx,cs,0,LE);\n", "      if( j>loop(box1->p,x1,y1-  dy/5,dx,cs,0,LE)\n", "       && j>loop(box1->p,x1,y1-2*dy/5,dx,cs,0,LE) ) Break;\t// &\n", "      // check for upper hole\n", "      for (j=0;j<sdata->holes.num;j++) {\n", "        if (sdata->holes.hole[j].y1 < i-y0+1   ) break;\n", "        if (sdata->holes.hole[j].y1 < i-y0+dy/8) break;\n", "      } if (j==sdata->holes.num) Break;  // not found\n", "      // if( num_hole(x0,x1,y0,i+1   ,box1->p,cs,NULL)!=1 )\n", "      // if( num_hole(x0,x1,y0,i+dy/8,box1->p,cs,NULL)!=1 ) Break;\t// upper hole\n", "      // check for lower hole\n", "      for (j=0;j<sdata->holes.num;j++) {\n", "        if (sdata->holes.hole[j].y0 > i-y0-1   ) break;\n", "      } if (j==sdata->holes.num) Break;  // not found\n", "      // if( num_hole(x0,x1,i-1,y1,box1->p,cs,NULL)!=1 ) Break; \n", "      i1=i;  // left middle nick\n", "      /* find the middle right nick */\n", "      for( x=0,i2=i=y=y0+dy/3;y<=y1-dy/3;y++){\n", "\tj=loop(box1->p,x1,y,dx,cs,0,LE); if( j>=x ) i2=y;\n", "        /* we care also for 7-segment and unusual fonts */\n", "        if (j>x || (abs(j-x)<=(dx+4)/8\n", "                 && loop(box1->p,x1-j,y,dx,cs,1,LE)>dx/2)){\n", "           if (j>x) x=j; i=y; }\n", "        // MSG(fprintf(stderr,\" yjix %d %d %d %d %d %d\",y-y0,j,i-y0,x,loop(box1->p,x1-j,y,dx,cs,1,LE),dx/2);)\n", "      }\n", "      if( i>y0+dy/2+dy/10 ) Break;\n", "      // if( x<dx/8 ) Break;\n", "      if( x>dx/2 ) Break;\n", "      MSG(fprintf(stderr,\"center bar at y= %d %d x=%d+%d i1=%d\",i-y0,i2-y0,x,j,i1);)\n", "      if( num_cross(x0,x1, i      , i      ,box1->p,cs) != 1\n", "       && num_cross(x0,x1, i+1    , i+1    ,box1->p,cs) != 1\n", "       && num_cross(x0,x1,(i+i2)/2,(i+i2)/2,box1->p,cs) != 1 ) Break; // no g\n", "      if(abs(i1-i)>(dy+5)/10) ad=99*ad/100; // y-distance right-left-nick\n", "      if(abs(i1-i)>(dy+4)/8)  ad=99*ad/100; // y-distance right-left-nick\n", "      if(abs(i1-i)>(dy+2)/4) Break;\n", "      // ~B ff\n", "      for(i=dx,y=0;y<dy/8+2;y++){\n", "        j=loop(bp,0,y,dx,cs,0,RI); if( j<i ) i=j; if( j>i+dx/16 ) break;\n", "      } if( y<dy/8+2 ) Break;\n", "      for(i=dx,y=0;y<dy/8+2;y++){\n", "        j=loop(bp,0,dy-1-y,dx,cs,0,RI);\n", "        if( j<i ) i=j; if( j>i+dx/16 ) break;\n", "      } if( y<dy/8+2 ) Break;\n", "      if(  dy>16 && num_cross(0,dx-1,dy-1,dy-1,bp,cs) > 1\n", "        && loop(bp,0,dy-1,dx,cs,0,RI) <dx/8+1 ) Break; // no fat serif S\n", "      for( i=0,y=dy/2;y<dy;y++){\n", "        if( num_cross(0,dx-1,y,y,bp,cs) > 2 ) i++; if( i>dy/8 ) break;\n", "      } if( y<dy ) Break;\n", "      if ( loop(bp,dx-1,0,dx,cs,0,LE)==0 ) ad=99*ad/100;\n", "      if (num_cross(   0,dx-1,dy-1,dy-1,bp,cs) > 1) ad=98*ad/100; // &\n", "      if (num_cross(dx-1,dx-1,dy/2,dy-1,bp,cs) > 1) ad=98*ad/100; // &\n", "      if (num_cross(   0,dx-1,   0,   0,bp,cs) > 1) ad=98*ad/100;\n", "      if (dy>15)\n", "      if (num_cross(   0,dx-1,   1,   1,bp,cs) > 1) ad=98*ad/100;\n", "      /* if m1..4 is unsure ignore hchar and gchar ~ga */\n", "      if (!hchar) {\n", "        if ((box1->m2-box1->y0)*8>=dy-dy/16) ad=98*ad/100;\n", "        else                                 ad=99*ad/100;\n", "      }\n", "      if ( gchar\n", "         && (box1->y1-box1->m3)*8>=dy) ad=99*ad/100;\n", "      Setac(box1,(wchar_t)'8',ad);\n", "      break;\n", "   }\n", "   // --- test 9 \\it g ---------------------------------------------------\n", "   /* \n", "    * \n", "    *    lcd  micr round\n", "    *    ooo  ooo  ooo\n", "    *    o o  o o  o o\n", "    *    ooo  ooo  ooo\n", "    *      o    o    o\n", "    *    ooo    o   o\n", "    */\n", "   for(ad=d=100;dx>2 && dy>4;){     // dx>1 dy>2*dx\n", "      DBG( char c_ask='9'; )\n", "      if (sdata->holes.num > 1) Break;\n", "      if( num_cross(x0+  dx/2,x0+  dx/2,y0,y1-dy/4,box1->p,cs) != 2 // pre select\n", "       && num_cross(x0+  dx/2,x0+  dx/2,y0,     y1,box1->p,cs) != 3 // pre select\n", "       && num_cross(x0+3*dx/8,x0+3*dx/8,y0,y1,box1->p,cs) != 3\n", "       && num_cross(x0+  dx/4,x1  -dx/4,y0,y1,box1->p,cs) != 3 ) Break;\n", "      if( num_cross(x0+  dx/2,x0  +dx/2,y0,y0+dy/4,box1->p,cs) < 1 ) Break;\n", "      if( num_cross(x0+  dx/2,x1, y0+dy/2 ,y0+dy/2,box1->p,cs) < 1 ) Break;\n", "      if( num_cross(x0,x1, y0+  dy/4 ,y0+  dy/4,box1->p,cs) != 2 \n", "       && num_cross(x0,x1, y0+3*dy/8 ,y0+3*dy/8,box1->p,cs) != 2 ) Break;\n", "      if( num_cross(x1-dx/8,x1,y0+dy/4,y0+dy/4,box1->p,cs) == 0) ad=ad*97/100; // ~4\n", "      for( x=0,i=y=y0+dy/2;y<=y1-dy/4;y++){\t// find notch (suche kerbe)\n", "\tj=loop(box1->p,x0,y,dx,cs,0,RI); \n", "        if( j>x ) { x=j; i=y; }  \n", "      } if (x<1 || x<dx/8) Break; y=i;\n", " //      fprintf(stderr,\" debug 9: %d %d\\n\",x,i-y0);\n", "      if( x<dx/2 ) {  /* big bow? */\n", "        j=loop(box1->p,x0+x-1,y,dy/8+1,cs,0,DO)/2; y=i=y+j;\n", "        j=loop(box1->p,x0+x-1,y,dx/2  ,cs,0,RI);   x+=j;\n", "        if (x<dx/2) Break;\n", "      }\n", "      // check for the right lower bow\n", "      MSG( fprintf(stderr,\"bow-y0= %d\",i-y0); )\n", "      if (dx>5)\n", "      if( num_cross(x0+dx/2,x1,i,y1     ,box1->p,cs) != 1  /* fails on 5x8 */\n", "       && num_cross(x0+dx/2,x1,i,y1-dy/8,box1->p,cs) != 1 ) Break;\n", "      if( num_cross(x0+dx/2,x0+dx/2,i,y1,box1->p,cs)  > 1 ) Break;\n", "      if( num_cross(x0+dx/2,x1     ,i, i,box1->p,cs) != 1 ) Break;\n", "\n", "      if (sdata->holes.num < 1) { /* happens for 5x7 font */\n", "        if (dx<8) ad=98*ad/100; else Break; }\n", "      else {\n", "        if (sdata->holes.hole[0].y1 >= i+1) Break;\n", "        if (sdata->holes.hole[0].y0 >  i-1) Break;\n", "        if (sdata->holes.num > 1)\n", "        if (sdata->holes.hole[1].y0 >  i-1) Break;\n", "      // if( num_hole(x0,x1,y0,i+1,box1->p,cs,NULL)!=1 ) Break;\n", "      // if( num_hole(x0,x1,i-1,y1,box1->p,cs,NULL)!=0 ) Break;\n", "      }\n", "      if( loop(box1->p,x0,y1  ,dy,cs,0,RI)>dx/3 &&\n", "          loop(box1->p,x0,y1-1,dy,cs,0,RI)>dx/3\n", "         && (box1->m3==0 || (box1->m3!=0 && (!hchar || gchar)))) ad=98*ad/100; // no q OR ocr-a-9\n", "      for( x=0,i=y=y0+dy/3;y<=y1-dy/3;y++){\t// suche kerbe\n", "\tj=loop(box1->p,x1,y,dx,cs,0,LE); \n", "        if( j>x ) { x=j; i=y; }\n", "      } if( x>dx/2 ) Break;\t\t// no g\n", "      i1=loop(bp,dx-1,dy/8     ,dx,cs,0,LE); if(i1>dx/2) Break;\n", "      i3=loop(bp,dx-1,dy-1-dy/8,dx,cs,0,LE);\n", "      i2=loop(bp,dx-1,dy/2     ,dx,cs,0,LE); if(i1+i3-2*i2<-1-dx/16) Break; // konvex\n", "      i1=loop(bp,dx-1,dy/4     ,dx,cs,0,LE); if(i1>dx/2) Break;\n", "      i3=loop(bp,dx-1,dy-1-dy/8,dx,cs,0,LE);\n", "      for(y=dy/4;y<dy-1-dy/4;y++){ // may fail on type=round\n", "        i2=loop(bp,dx-1,y,dx,cs,0,LE);\n", "        // konvex from right ~g ~3 Jul09\n", "        if(i2>i1+(i3-i1)*(2*y-dy/2)/dy+dx/16) break;\n", "        // MSG(fprintf(stderr,\" y i2 %d %d %d\",y,i2,i1+(i3-i1)*(2*y-dy/2)/dy);)\n", "      } if(y<dy-1-dy/4) Break;\n", "      x=loop(bp,dx  -1,6*dy/8,dx,cs,0,LE); if(x>0){\n", "        x--; // robust\n", "        y=loop(bp,dx-x-1,  dy-1,dy,cs,0,UP);\n", "        if(y<dy/8) Break; // ~q (serif!)\n", "      }\n", "      // check for agglutinated serif y\n", "      if (dy>=16 && dx>9\n", "        && loop(bp,   0,dy/ 4,dx,cs,0,RI)\n", "          -loop(bp,   0,dy/16,dx,cs,0,RI)>dx/6\n", "        && loop(bp,dx-1,dy/ 4,dx,cs,0,LE)\n", "          -loop(bp,dx-1,dy/16,dx,cs,0,LE)>dx/6) Break; // ~ serif yY\n", "          \n", "      if (box1->m3) {\n", "        if ( gchar) ad=99*ad/100;  /* unsure (italic g)? */\n", "        if (box1->m2 && (!gchar) && y1 > box1->m3){\n", "          ad=99*ad/100;\n", "          if (box1->m4-box1->m3<3) ad=99*ad/100;\n", "          // if (!hchar) ad = 99*ad/100;\n", "        }\n", "        if (!hchar) ad=99*ad/100;  /* unsure */\n", "      } else { if (ad==100) ad=99; } /* not 100% sure */\n", "      Setac(box1,(wchar_t)'9',ad);\n", "      break;\n", "   }\n", "   // 0 is same as O !?\n", "   // --- test 0 (with one big hole in it ) -----------------------------\n", "   for(d=ad=100;dx>2 && dy>3;){     // min 3x4\n", "      DBG( char c_ask='0'; )\n", "      if (sdata->holes.num > 1) Break; /* be tolerant */\n", "      if( get_bw(x0      , x0+dx/3,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x1-dx/3 , x1     ,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      /* could be an O, unless we find a dot in the center */\n", "      if( get_bw(x0      , x1     ,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 3 ) ad=99;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y1-dy/3 , y1,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0      , y0+dy/3,box1->p,cs,1) != 1 ) Break;\n", "      /* accept 0 with dot in center, accept \\/0 too ... */\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0+dy/3 , y1-dy/3,box1->p,cs,1) != 0 ) Break;\n", "\n", "      if( num_cross(x0+dx/2,x0+dx/2,y0      , y1     ,box1->p,cs)  != 2 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0      , y0     ,box1->p,cs)  != 1 ) // AND\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0+1    , y0+1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1      , y1     ,box1->p,cs)  != 1 ) // against \"rauschen\"\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1-1    , y1-1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0     ,x0     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x0+1   ,x0+1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x1     ,x1     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x1-1   ,x1-1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      // if( num_hole(x0,x1,y0,y1,box1->p,cs,NULL) != 1 ) Break;\n", "      if (sdata->holes.num != 1) Break;\n", "      \n", "      i= loop(bp,0   ,0   ,x1-x0,cs,0,RI)-\n", "         loop(bp,0   ,2   ,x1-x0,cs,0,RI);\n", "      if (i<0) Break;\n", "      if (i==0) {\n", "        if (loop(bp,dx-1,0   ,x1-x0,cs,0,LE)>\n", "            loop(bp,dx-1,2   ,x1-x0,cs,0,LE)  ) ad=98*ad/100;\n", "        ad=99*ad/100; /* LCD-type? */\n", "      }\n", "      \n", "      x=loop(bp,dx-1,dy-1-dy/3,x1-x0,cs,0,LE);\t// should be minimum\n", "      for (y=dy-1-dy/3;y<dy;y++){\n", "        i=loop(bp,dx-1,y,x1-x0,cs,0,LE);\n", "        if (i<x-dx/16-1) break; if (i>x) x=i;\n", "      }\n", "      if( y<dy ) Break;\n", "\n", "      // ~D (but ocr-a-font)\n", "      i=      loop(bp,   0,     dy/16,dx,cs,0,RI)\n", "         +    loop(bp,   0,dy-1-dy/16,dx,cs,0,RI)\n", "         -  2*loop(bp,   0,     dy/2 ,dx,cs,0,RI);\n", "      j=      loop(bp,dx-1,     dy/16,dx,cs,0,LE)\n", "         +    loop(bp,dx-1,dy-1-dy/16,dx,cs,0,LE)\n", "         <= 2*loop(bp,dx-1,     dy/2 ,dx,cs,0,LE);\n", "      if (i<-dx/8 || i+dx/8<j) Break; // not konvex\n", "\n", "      if( loop(bp,dx-1,     dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,     dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( loop(bp,dx-1,dy-1-dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,dy-1-dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( get_bw(x1-dx/32,x1,y0,y0+dy/32,box1->p,cs,1) == 0\n", "       && get_bw(x1-dx/32,x1,y1-dy/32,y1,box1->p,cs,1) == 0\n", "       && ( get_bw(x0,x0+dx/32,y0,y0+dy/32,box1->p,cs,1) == 1\n", "         || get_bw(x0,x0+dx/32,y1-dy/32,y1,box1->p,cs,1) == 1 ) ) {\n", "         if (dx<32) ad=ad*99/100; else Break; // ~D\n", "      }\n", "\n", "      // search lowest inner white point\n", "      for(y=dy,j=x=0;x<dx;x++) {\n", "        i =loop(bp,x,dy-1  ,y1-y0,cs,0,UP);\n", "        i+=loop(bp,x,dy-1-i,y1-y0,cs,1,UP);\n", "        if (i<=y) { y=i; j=x; }\n", "      } i=y;\n", "      // italic a\n", "      for(y=dy-1-i;y<dy-1;y++)\n", "        if( num_cross(j,dx-1,y,y,bp,cs) > 1 ) ad=99*ad/100; // ~a \\it a\n", "\n", "      if (loop(bp,   0,   0,x1-x0,cs,0,RI)>=dx/8) { // round, notLCD\n", "        if (loop(bp,dx-1,dy-1,x1-x0,cs,0,LE)<dx/8) ad=98*ad/100; // \\it a\n", "        if (loop(bp,dx-1,   0,x1-x0,cs,0,LE)<dx/8) ad=98*ad/100; // \\it a\n", "      }\n", "\n", "      if (abs(loop(bp,dx/2,   0,dy,cs,0,DO)\n", "             -loop(bp,dx/2,dy-1,dy,cs,0,UP))>dy/8\n", "        || num_cross(0,dx-1,   0,   0,bp,cs) > 1\n", "        || num_cross(0,dx-1,dy-1,dy-1,bp,cs) > 1\n", "         ) ad=98*ad/100; // ~bq\n", "\n", "      if (box1->m3) {\n", "       if (!hchar) ad=98*ad/100; else // ~o\n", "       if ( gchar) ad=99*ad/100;      // wrong line detection?\n", "      } else { if (ad==100) ad=99; } /* not 100% sure */\n", "      if (ad>98) ad=98; /* we can never be sure having a O, (2010-10 98%)\n", "                           let context correction decide, see below! */\n", "      Setac(box1,(wchar_t)'0',ad);\n", "      break;\n", "   } \n", "   // --- test 0 with a straight line in it -------------------\n", "   for(ad=100;dx>4 && dy>5;){  /* v0.3.1+ */\n", "      DBG( char c_ask='0'; )\n", "      if (sdata->holes.num > 3) Break; /* be tolerant */\n", "      if (sdata->holes.num < 1) Break;\n", "      if (sdata->holes.num != 2) ad=95*ad/100;\n", "      if( get_bw(x0      , x0+dx/2,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x1-dx/2 , x1     ,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y1-dy/2 , y1,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0      , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0+dy/3 , y1-dy/3,box1->p,cs,1) != 1 ) Break;\n", "      // out_x(box1); printf(\" x0 y0 %d %d\\n\",x0,y0);\n", "      if( num_cross(x0+dx/2,x0+dx/2,y0      , y1     ,box1->p,cs)  != 3 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0      , y0     ,box1->p,cs)  != 1 ) // AND\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0+1    , y0+1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1      , y1     ,box1->p,cs)  != 1 ) // against \"rauschen\"\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1-1    , y1-1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0     ,x0     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x0+1   ,x0+1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x1     ,x1     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x1-1   ,x1-1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      // if( num_hole(x0,x1,y0,y1,box1->p,cs,NULL) != 2 ) Break;\n", "      if (sdata->holes.num != 2) ad=85*ad/100;\n", "      \n", "      if( loop(bp,0   ,        0,x1-x0,cs,0,RI)<=\n", "          loop(bp,0   ,  2+dy/32,x1-x0,cs,0,RI)  ) Break;\n", "      x=  loop(bp,0   ,dy/2  ,x1-x0,cs,0,RI);\n", "      i=  loop(bp,0   ,dy/2-1,x1-x0,cs,0,RI); if (i>x) x=i;\n", "      i=  loop(bp,0   ,dy/2-2,x1-x0,cs,0,RI); if (i>x && dy>8) x=i;\n", "      if( loop(bp,0   ,  dy/4,x1-x0,cs,0,RI)<x ) Break; // ~8\n", "      x=  loop(bp,dx-1,dy/2  ,x1-x0,cs,0,LE);\n", "      i=  loop(bp,dx-1,dy/2-1,x1-x0,cs,0,LE); if(i>x) x=i;\n", "      i=  loop(bp,dx-1,dy/2-1,x1-x0,cs,0,LE); if(i>x && dy>8) x=i;\n", "      if( loop(bp,dx-1,3*dy/4,x1-x0,cs,0,LE)<x) Break; // ~8\n", "\n", "      x=loop(bp,dx-1,dy-1-dy/3,x1-x0,cs,0,LE);\t// should be minimum\n", "      for( y=dy-1-dy/3;y<dy;y++ ){\n", "        i=loop(bp,dx-1,y,x1-x0,cs,0,LE);\n", "        if (i<x-dx/16) break; \n", "        if (i>x) x=i;\n", "      }\n", "      if( y<dy ) Break;\n", "      \n", "      /* test for straight line */\n", "      y =loop(bp,dx/2,dy-1  ,y1-y0,cs,0,UP); if(y>dy/4) Break;\n", "      y+=loop(bp,dx/2,dy-1-y,y1-y0,cs,1,UP); if(y>dy/3) Break; if (y>dy/4) ad=ad*99/100;\n", "      y+=loop(bp,dx/2,dy-1-y,y1-y0,cs,0,UP); if(3*y>2*dy) Break;\n", "      x =loop(bp,dx/2,dy-y,dx/2,cs,0,RI);    if(x==0) Break;\n", "      // MM; fprintf(stderr,\" y=%d x=%d\\n\",y-1,x);\n", "      if( loop(bp,dx/2+x-1-dx/16,dy-y,y1-y0,cs,0,UP)==0 ) Break;\n", "       // $\n", "      for(i=0,y=dy/4;y<dy-dy/4-1;y++)\n", "      if( loop(bp,   0,y,dx-1,cs,0,RI) > dx/4\n", "       || loop(bp,dx-1,y,dx-1,cs,0,LE) > dx/4 ) break;\n", "      if( y<dy-dy/4-1 ) Break;\n", "\n", "      // ~D\n", "      if(     loop(bp,0,     dy/16,dx,cs,0,RI)\n", "         +    loop(bp,0,dy-1-dy/16,dx,cs,0,RI)\n", "         <= 2*loop(bp,0,     dy/2 ,dx,cs,0,RI)+dx/8 ) Break; // not konvex\n", "\n", "      if( loop(bp,dx-1,     dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,     dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( loop(bp,dx-1,dy-1-dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,dy-1-dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( get_bw(x1-dx/32,x1,y0,y0+dy/32,box1->p,cs,1) == 0\n", "       && get_bw(x1-dx/32,x1,y1-dy/32,y1,box1->p,cs,1) == 0\n", "       && ( get_bw(x0,x0+dx/32,y0,y0+dy/32,box1->p,cs,1) == 1\n", "         || get_bw(x0,x0+dx/32,y1-dy/32,y1,box1->p,cs,1) == 1 ) ) Break; // ~D\n", "\n", "      /* 5x9 font \"9\" is like \"0\" */\n", "      if (dx<16)\n", "      if ( num_cross(x0,x0,y0,y1,box1->p,cs)  != 1 ) ad=98*ad/100;\n", "\n", "       // italic a\n", "      for(i=0,y=6*dy/8;y<dy-dy/16;y++)\n", "      if( num_cross(0,dx-1,y,y,bp,cs) > 2 ) i++; else i--;\n", "      if(i>0) ad=ad*98/100; // ~'a' \\it a\n", "      if( !hchar ) ad=90*ad/100;\n", "      Setac(box1,(wchar_t)'0',ad);\n", "      break;\n", "   } \n", "   // --- test 0 with a dot in it -------------------\n", "   for(ad=100;dx>4 && dy>5;){  /* v0.46+ */\n", "      DBG( char c_ask='0'; )\n", "      if (sdata->holes.num != 1) Break; /* do not be tolerant */\n", "      // 8x10 font 2-pixel line width has 3 frames\n", "      if (sdata->box1->num_frames != 3) ad=85*ad/100; // 2010-09-24\n", "      // MSG(fprintf(stderr,\"ad=%d\",ad);)\n", "      if( get_bw(x0      , x0+dx/2,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x1-dx/2 , x1     ,y0+dy/2 , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y1-dy/2 , y1,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0      , y0+dy/2,box1->p,cs,1) != 1 ) Break;\n", "      if( get_bw(x0+dx/2 , x0+dx/2,y0+dy/3 , y1-dy/3,box1->p,cs,1) != 1 ) Break;\n", "      // out_x(box1); printf(\" x0 y0 %d %d\\n\",x0,y0);\n", "      if( num_cross(x0+dx/2,x0+dx/2,y0      , y1     ,box1->p,cs)  != 3 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0      , y0     ,box1->p,cs)  != 1 ) // AND\n", "      if( num_cross(x0+dx/3,x1-dx/3,y0+1    , y0+1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1      , y1     ,box1->p,cs)  != 1 ) // against \"rauschen\"\n", "      if( num_cross(x0+dx/3,x1-dx/3,y1-1    , y1-1   ,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x0     ,x0     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x0+1   ,x0+1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      if( num_cross(x1     ,x1     ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 )\n", "      if( num_cross(x1-1   ,x1-1   ,y0+dy/3 , y1-dy/3,box1->p,cs)  != 1 ) Break;\n", "      // if( num_hole(x0,x1,y0,y1,box1->p,cs,NULL) != 2 ) Break;\n", "      // MSG(fprintf(stderr,\"ad=%d\",ad);)\n", "      \n", "      if( loop(bp,0   ,        0,x1-x0,cs,0,RI)<=\n", "          loop(bp,0   ,  2+dy/32,x1-x0,cs,0,RI)  ) Break;\n", "      x=  loop(bp,0   ,dy/2  ,x1-x0,cs,0,RI);\n", "      i=  loop(bp,0   ,dy/2-1,x1-x0,cs,0,RI); if (i>x) x=i;\n", "      i=  loop(bp,0   ,dy/2-2,x1-x0,cs,0,RI); if (i>x && dy>8) x=i;\n", "      if( loop(bp,0   ,  dy/4,x1-x0,cs,0,RI)<x ) Break; // ~8\n", "      x=  loop(bp,dx-1,dy/2  ,x1-x0,cs,0,LE);\n", "      i=  loop(bp,dx-1,dy/2-1,x1-x0,cs,0,LE); if(i>x) x=i;\n", "      i=  loop(bp,dx-1,dy/2-1,x1-x0,cs,0,LE); if(i>x && dy>8) x=i;\n", "      if( loop(bp,dx-1,3*dy/4,x1-x0,cs,0,LE)<x) Break; // ~8\n", "\n", "      x=loop(bp,dx-1,dy-1-dy/3,x1-x0,cs,0,LE);\t// should be minimum\n", "      for( y=dy-1-dy/3;y<dy;y++ ){\n", "        i=loop(bp,dx-1,y,x1-x0,cs,0,LE);\n", "        if (i<x-dx/16) break; \n", "        if (i>x) x=i;\n", "      }\n", "      if( y<dy ) Break;\n", "      \n", "      /* test for straight line */\n", "      y =loop(bp,dx/2,dy-1  ,y1-y0,cs,0,UP); if(y>dy/4) Break;\n", "      y+=loop(bp,dx/2,dy-1-y,y1-y0,cs,1,UP); if(y>dy/3) Break;\n", "        if (y>dy/4) { ad=ad*99/100;MSG(fprintf(stderr,\"ad=%d\",ad);) }\n", "      y+=loop(bp,dx/2,dy-1-y,y1-y0,cs,0,UP); if(3*y>2*dy) Break;\n", "      x =loop(bp,dx/2,dy-y,dx/2,cs,0,RI);    if(x==0) Break;\n", "      // MM; fprintf(stderr,\" y=%d x=%d\\n\",y-1,x);\n", "      if( loop(bp,dx/2+x-1-dx/16,dy-y,y1-y0,cs,0,UP)==0 ) Break;\n", "       // $\n", "      for(i=0,y=dy/4;y<dy-dy/4-1;y++)\n", "      if( loop(bp,   0,y,dx-1,cs,0,RI) > dx/4\n", "       || loop(bp,dx-1,y,dx-1,cs,0,LE) > dx/4 ) break;\n", "      if( y<dy-dy/4-1 ) Break;\n", "\n", "      // ~D\n", "      if(     loop(bp,0,     dy/16,dx,cs,0,RI)\n", "         +    loop(bp,0,dy-1-dy/16,dx,cs,0,RI)\n", "         <= 2*loop(bp,0,     dy/2 ,dx,cs,0,RI)+dx/8 ) Break; // not konvex\n", "\n", "      if( loop(bp,dx-1,     dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,     dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( loop(bp,dx-1,dy-1-dy/16,dx,cs,0,LE)>dx/8 )\n", "      if( loop(bp,0   ,dy-1-dy/16,dx,cs,0,RI)<dx/16 ) Break;\n", "      if( get_bw(x1-dx/32,x1,y0,y0+dy/32,box1->p,cs,1) == 0\n", "       && get_bw(x1-dx/32,x1,y1-dy/32,y1,box1->p,cs,1) == 0\n", "       && ( get_bw(x0,x0+dx/32,y0,y0+dy/32,box1->p,cs,1) == 1\n", "         || get_bw(x0,x0+dx/32,y1-dy/32,y1,box1->p,cs,1) == 1 ) ) Break; // ~D\n", "\n", "      /* 5x9 font \"9\" is like \"0\" */\n", "      if (dx<16)\n", "      if (num_cross(x0,x0,y0,y1,box1->p,cs)  != 1) {\n", "        ad=98*ad/100;MSG(fprintf(stderr,\"ad=%d\",ad);) }\n", "\n", "       // italic a\n", "      for(i=0,y=6*dy/8;y<dy-dy/16;y++)\n", "        if (num_cross(0,dx-1,y,y,bp,cs) > 2) i++; else i--;\n", "      if (i>0) { ad=ad*98/100; MSG(fprintf(stderr,\"i=%d ad=%d\",i,ad);) }\n", "\n", "      if (!hchar) ad=90*ad/100;\n", "      Setac(box1,(wchar_t)'0',ad);\n", "      break;\n", "   } \n", "   return box1->c;\n", "}\n"], "project": "gocr", "file": "ocr0n.pkl", "function": "ocr0n"}, {"comment_all": {"comment": "/* for open, O_ constants defined here on BSD systems */", "depth": 0, "reading_ease": 87.72, "reading_grade": 3.3, "line": 27}, "comment_text": "/* for open, O_ constants defined here on BSD systems */\n/* HAVE_SYS_FILE_H */\n/* not HAVE_FCNTL_H */\n", "comment_tokens": ["for", "open", ",", "O_", "constants", "defined", "here", "on", "BSD", "systems", "HAVE_SYS_FILE_H", "not", "HAVE_FCNTL_H"], "ccode": ["/* Miscellaneous utilities:\n", "    open_for_writing()\n", "    smalloc()\n", "    open_append()\n", "*/\n", "\n", "#ifdef HAVE_CONFIG_H\n", "# include \"config.h\"\n", "#endif\n", "\n", "#include \"defs.h\"\n", "\n", "#include <stdio.h> /* for fdopen */\n", "#include <sys/stat.h>  /* for stat, open*/\n", "#include <errno.h>\n", "\n", "#include <strings.h> \n", "#include <stdlib.h>\n", "\n", "#ifdef HAVE_UNISTD_H\n", "#include <unistd.h> /* for setuid/seteuid/setgid/setegid, unlink */\n", "#endif\n", "\n", "#ifdef HAVE_FCNTL_H\n", "#include <fcntl.h> /* for open */\n", "#else /* not HAVE_FCNTL_H */\n", "#ifdef HAVE_SYS_FILE_H\n", "#include <sys/file.h> /* for open, O_ constants defined here on BSD systems */\n", "#endif /* HAVE_SYS_FILE_H */\n", "#endif /* not HAVE_FCNTL_H */\n", "\n", "#include <sys/stat.h> /* for stat, open */\n", "\n", "#include \"dhcp_probe.h\"\n", "#include \"utils.h\"\n", "#include \"report.h\"\n", "\n", "\n", "FILE *\n", "open_for_writing(char * filename) \n", "{\n", "/*\tOpen a regular file for writing.\n", "\tIf the file already exists, it will be removed first.\n", "\tOn error we return NULL and log an error message.\n", "\tBased closely on write_open() from BIND 8.1.2.\n", "*/\n", "\tint fd;\n", "\tFILE *stream;\n", "\tstruct stat stat_buffer;\n", "\n", "\tif (stat(filename, &stat_buffer) < 0) {\n", "\t\tif (errno != ENOENT) {\n", "\t\t\treport(LOG_ERR, \"open_for_writing(): stat of %s failed: %s\", filename, get_errmsg());\n", "\t\t\treturn NULL;\n", "\t\t} \n", "\t} else { /* filename already exists */\n", "\t\tif (!(stat_buffer.st_mode & S_IFREG)) {\n", "\t\t\t/* since we just want to open a regular file for writing, its existance as a special\n", "\t\t\t   file probably means something is wrong, so let's TRY to avoid removing it. */\n", "\t\t\treport(LOG_ERR, \"open_for_writing(): %s exists but isn't a regular file\", filename);\n", "\t\t\treturn(NULL);\n", "\t\t}\n", "\t}\n", "\n", "\t/* At this point, filename either does not exist, or already exists as a regular file.\n", "\t   Either way, it's toast.  Note that it is possible for it's status to have changed since\n", "\t   we checked earlier; e.g. it may have changed from non-existance to existance as a special file.\n", "\t   So it's still possible we'll wipe out a special file, but we've made an effort to avoid it. */\n", "\tif (unlink(filename) < 0) {\n", "\t\tif (errno != ENOENT) {\n", "\t\t\treport(LOG_ERR, \"open_for_writing(): unlink of %s failed: %s\", filename, get_errmsg());\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t}\n", "\n", "\t/* Use open() to get the atomic behavior provided by O_CREAT|O_EXCL.  If it succeeds,\n", "\t   convert the file descriptor into a file stream, which is what we're supposed to return. */\n", "\tfd = open(filename, O_WRONLY|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n", "\tif (fd < 0) {\n", "\t\treport(LOG_ERR, \"open_for_writing(): open of %s failed: %s\", filename, get_errmsg());\n", "\t\treturn NULL;\n", "\t}\n", "\tstream = fdopen(fd, \"w\");\n", "\tif (stream == NULL) {\n", "\t\treport(LOG_ERR, \"open_for_writing(): fdopen failed: %s\", get_errmsg());\n", "\t\t(void) close(fd);\n", "\t\treturn NULL;\n", "\t}\n", "\treturn(stream);\n", "}\n"], "project": "dhcp-probe", "file": "utils.pkl", "function": "open_for_writing"}, {"comment_all": {"comment": "/* We already know which ioctl to use. */", "depth": 2, "reading_ease": 106.67, "reading_grade": 0.1, "line": 60}, "comment_text": "/* We already know which ioctl to use. */", "comment_tokens": ["We", "already", "know", "which", "ioctl", "to", "use", "."], "ccode": ["\n", "int getbtnmap(int fd, uint16_t *btnmap)\n", "{\n", "\tstatic int jsiocgbtnmap = 0;\n", "\tint ioctls[] = { JSIOCGBTNMAP, JSIOCGBTNMAP_LARGE, JSIOCGBTNMAP_SMALL, 0 };\n", "\n", "\tif (jsiocgbtnmap != 0) {\n", "\t\t/* We already know which ioctl to use. */\n", "\t\treturn ioctl(fd, jsiocgbtnmap, btnmap);\n", "\t} else {\n", "\t\treturn determine_ioctl(fd, ioctls, &jsiocgbtnmap, btnmap);\n", "\t}\n", "}\n"], "project": "joystick", "file": "axbtnmap.pkl", "function": "getbtnmap"}, {"comment_all": {"comment": "/* colorset variable or the drawingmode if it is 2.             */", "depth": 0, "reading_ease": 79.26, "reading_grade": 4.4, "line": 140}, "comment_text": "/* This function allocates the colors for gdpc according to the */\n/* colorset variable or the drawingmode if it is 2.             */\n", "comment_tokens": ["This", "function", "allocates", "the", "colors", "for", "gdpc", "according", "to", "the", "colorset", "variable", "or", "the", "drawingmode", "if", "it", "is", "2", "."], "ccode": ["\n", "\n", "/****************************************************************/\n", "/* This function allocates the colors for gdpc according to the */\n", "/* colorset variable or the drawingmode if it is 2.             */\n", "/****************************************************************/\n", "gint allocatecolors (GdkColor **colors,gint colorset,gint mode)\n", "{\n", "gboolean *success;\n", "gint i, ncolors=19;\n", "gint colcomp;\n", "double rcomp, gcomp, bcomp;\n", "\n", "    if (mode!=2){\n", "\t*colors = (GdkColor *) calloc (ncolors, sizeof(GdkColor));\n", "\tsuccess = (gboolean *) calloc (ncolors, sizeof(gboolean));\n", "    }\n", "    else {\n", "\tncolors = 8*17+2;\n", "\t*colors = (GdkColor *) calloc (ncolors, sizeof(GdkColor));\n", "\tsuccess = (gboolean *) calloc (ncolors, sizeof(gboolean));\n", "    }\n", "\n", "    if (colorset==1) {\n", "\tfor(i=0;i<ncolors;i++) {\n", "\t    (*colors)[i].red = xcolorinv[i][0];\n", "\t    (*colors)[i].green = xcolorinv[i][1];\n", "\t    (*colors)[i].blue = xcolorinv[i][2];\n", "\t}\n", "    }\n", "    else if (colorset==2) {\n", "\tfor(i=0;i<ncolors;i++) {\n", "\t    (*colors)[i].red = xcoldcolor[i][0];\n", "\t    (*colors)[i].green = xcoldcolor[i][1];\n", "\t    (*colors)[i].blue = xcoldcolor[i][2];\n", "\t}\n", "    }\n", "    else if (colorset==3) {\n", "\tfor(i=0;i<ncolors;i++) {\n", "\t    (*colors)[i].red = xcoldcolor2[i][0];\n", "\t    (*colors)[i].green = xcoldcolor2[i][1];\n", "\t    (*colors)[i].blue = xcoldcolor2[i][2];\n", "\t}\n", "    }\n", "\n", "/* Set the greyscale colors. */\n", "    else if (colorset==4) {\n", "\t    i = 0;\n", "\t    (*colors)[i].red = 0;\n", "\t    (*colors)[i].green = 0;\n", "\t    (*colors)[i].blue = 0;\n", "\t    i = 1;\n", "\t    (*colors)[i].red = 65535;\n", "\t    (*colors)[i].green = 65535;\n", "\t    (*colors)[i].blue = 65535;\n", "\tfor(i=2;i<ncolors;i++) {\n", "\t    (*colors)[i].red = 65535 - (i-2)*14*256 -2300;\n", "\t    (*colors)[i].green = (*colors)[i].red;\n", "\t    (*colors)[i].blue = (*colors)[i].red;\n", "\t}\n", "    }\n", "    else {\n", "\tfor(i=0;i<ncolors;i++) {\n", "\t    (*colors)[i].red = xcolor[i][0];\n", "\t    (*colors)[i].green = xcolor[i][1];\n", "\t    (*colors)[i].blue = xcolor[i][2];\n", "\t}\n", "    }\n", "/* If drawingmode is 2 than we will create a special set of colors. */\n", "    if (mode==2) {\n", "/* White */\n", "\t    (*colors)[0].red = 0;\n", "\t    (*colors)[0].green = 0;\n", "\t    (*colors)[0].blue = 0;\n", "/* Black */\n", "\t    (*colors)[1].red = 65535;\n", "\t    (*colors)[1].green = 65535;\n", "\t    (*colors)[1].blue = 65535;\n", "\t\n", "/* Then we start calculating the actual components of the colors. */\n", "\tfor(i=0;i<17;i++) {\n", "\t    rcomp = cos(i*PI/17);\n", "\t    gcomp = sin(i*PI/17);\n", "\t    bcomp = -cos(i*PI/17);\n", "\t    if(rcomp<0) rcomp = 0;\n", "\t    if(gcomp<0) gcomp = 0;\n", "\t    if(bcomp<0) bcomp = 0;\n", "\n", "\t    rcomp = rcomp/sqrt(1.3*rcomp*rcomp+1.2*gcomp*gcomp+0.7*bcomp*bcomp);\n", "\t    gcomp = gcomp/sqrt(1.3*rcomp*rcomp+1.2*gcomp*gcomp+0.7*bcomp*bcomp);\n", "\t    bcomp = bcomp/sqrt(1.3*rcomp*rcomp+1.2*gcomp*gcomp+0.7*bcomp*bcomp);\n", "\n", "\t    colcomp = rcomp*65535+comp1;\n", "\t    if (colcomp<0) (*colors)[i*8+2].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+2].red = 65535;\n", "\t    else (*colors)[i*8+2].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp1;\n", "            if (colcomp<0) (*colors)[i*8+2].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+2].green = 65535;\n", "            else (*colors)[i*8+2].green = (gushort) colcomp;         \n", "\n", "\t    colcomp = bcomp*65535+comp1;\n", "            if (colcomp<0) (*colors)[i*8+2].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+2].blue = 65535;\n", "            else (*colors)[i*8+2].blue = (gushort) colcomp;\n", "         \n", "\t    colcomp = rcomp*65535+comp2;\n", "\t    if (colcomp<0) (*colors)[i*8+3].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+3].red = 65535;\n", "\t    else (*colors)[i*8+3].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp2;\n", "            if (colcomp<0) (*colors)[i*8+3].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+3].green = 65535;\n", "            else (*colors)[i*8+3].green = (gushort) colcomp;         \n", "\n", "\t    colcomp = bcomp*65535+comp2;\n", "            if (colcomp<0) (*colors)[i*8+3].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+3].blue = 65535;\n", "            else (*colors)[i*8+3].blue = (gushort) colcomp;\n", "         \n", "\t    colcomp = rcomp*65535+comp3;\n", "\t    if (colcomp<0) (*colors)[i*8+4].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+4].red = 65535;\n", "\t    else (*colors)[i*8+4].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp3;\n", "            if (colcomp<0) (*colors)[i*8+4].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+4].green = 65535;\n", "            else (*colors)[i*8+4].green = (gushort) colcomp;\n", "\n", "\t    colcomp = bcomp*65535+comp3;\n", "            if (colcomp<0) (*colors)[i*8+4].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+4].blue = 65535;\n", "            else (*colors)[i*8+4].blue = (gushort) colcomp;\n", "         \n", "\t    colcomp = rcomp*65535+comp4;\n", "\t    if (colcomp<0) (*colors)[i*8+5].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+5].red = 65535;\n", "\t    else (*colors)[i*8+5].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp4;\n", "            if (colcomp<0) (*colors)[i*8+5].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+5].green = 65535;\n", "            else (*colors)[i*8+5].green = (gushort) colcomp;\n", "\n", "\t    colcomp = bcomp*65535+comp4;\n", "            if (colcomp<0) (*colors)[i*8+5].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+5].blue = 65535;\n", "            else (*colors)[i*8+5].blue = (gushort) colcomp;\n", "         \n", "\t    colcomp = rcomp*65535+comp5;\n", "\t    if (colcomp<0) (*colors)[i*8+6].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+6].red = 65535;\n", "\t    else (*colors)[i*8+6].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp5;\n", "            if (colcomp<0) (*colors)[i*8+6].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+6].green = 65535;\n", "            else (*colors)[i*8+6].green = (gushort) colcomp;\n", "\n", "\t    colcomp = bcomp*65535+comp5;\n", "            if (colcomp<0) (*colors)[i*8+6].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+6].blue = 65535;\n", "            else (*colors)[i*8+6].blue = (gushort) colcomp;\n", "\n", "\t    colcomp = rcomp*65535+comp6;\n", "\t    if (colcomp<0) (*colors)[i*8+7].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+7].red = 65535;\n", "\t    else (*colors)[i*8+7].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp6;\n", "            if (colcomp<0) (*colors)[i*8+7].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+7].green = 65535;\n", "            else (*colors)[i*8+7].green = (gushort) colcomp;\n", "\n", "\t    colcomp = bcomp*65535+comp6;\n", "            if (colcomp<0) (*colors)[i*8+7].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+7].blue = 65535;\n", "            else (*colors)[i*8+7].blue = (gushort) colcomp;\n", "\n", "\t    colcomp = rcomp*65535+comp7;\n", "\t    if (colcomp<0) (*colors)[i*8+8].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+8].red = 65535;\n", "\t    else (*colors)[i*8+8].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp7;\n", "            if (colcomp<0) (*colors)[i*8+8].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+8].green = 65535;\n", "            else (*colors)[i*8+8].green = (gushort) colcomp;         \n", "\n", "\t    colcomp = bcomp*65535+comp7;\n", "            if (colcomp<0) (*colors)[i*8+8].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+8].blue = 65535;\n", "            else (*colors)[i*8+8].blue = (gushort) colcomp;\n", "\n", "\t    colcomp = rcomp*65535+comp8;\n", "\t    if (colcomp<0) (*colors)[i*8+9].red = 0;\n", "\t    else if (colcomp>65535) (*colors)[i*8+9].red = 65535;\n", "\t    else (*colors)[i*8+9].red = (gushort) colcomp;\n", "\n", "\t    colcomp = gcomp*65535+comp8;\n", "            if (colcomp<0) (*colors)[i*8+9].green = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+9].green = 65535;\n", "            else (*colors)[i*8+9].green = (gushort) colcomp;         \n", "\n", "\t    colcomp = bcomp*65535+comp8;\n", "            if (colcomp<0) (*colors)[i*8+9].blue = 0;\n", "            else if (colcomp>65535) (*colors)[i*8+9].blue = 65535;\n", "            else (*colors)[i*8+9].blue = (gushort) colcomp;\n", "\t}\n", "    }\n", "\n", "/* When we're done setting the colors we allocate them. */\n", "    if (gdk_colormap_alloc_colors(gdk_colormap_get_system(),\n", "\t\t\t\t  *colors, ncolors, FALSE, \n", "\t\t\t\t  FALSE, success))\n", "        g_error(\"Can't allocate colors\\n\");\n", "\n", "    return ncolors;\n", "}\n"], "project": "gdpc", "file": "colors.pkl", "function": "allocatecolors"}, {"comment_all": {"comment": "/* Speed should not matter (see comments in upsdrv_updateinfo),\n\t * but set it relatively low in case there are problems with higher\n\t * speeds. */", "depth": 1, "reading_ease": 58.62, "reading_grade": 10.3, "line": 178}, "comment_text": "/* Speed should not matter (see comments in upsdrv_updateinfo),\n\t * but set it relatively low in case there are problems with higher\n\t * speeds. */", "comment_tokens": ["Speed", "should", "not", "matter", "(", "see", "comments", "in", "upsdrv_updateinfo", ")", ",", "but", "set", "it", "relatively", "low", "in", "case", "there", "are", "problems", "with", "higher", "speeds", "."], "ccode": ["\n", "void upsdrv_initups(void)\n", "{\n", "\tupsfd = ser_open(device_path);\n", "\n", "\t/* Speed should not matter (see comments in upsdrv_updateinfo),\n", "\t * but set it relatively low in case there are problems with higher\n", "\t * speeds. */\n", "\tser_set_speed(upsfd, device_path, B9600);\n", "\n", "\t/* raise RTS */\n", "\tser_set_rts(upsfd, 1);\n", "}\n"], "project": "nut-ipmi", "file": "liebert.pkl", "function": "upsdrv_initups"}, {"comment_all": {"comment": "// LAPACK prototypes for a packed cholesky factorization and a linear solve\n// using that factorization, respectively\n", "depth": 0, "reading_ease": 30.87, "reading_grade": 12.7, "line": 397}, "comment_text": "// LAPACK prototypes for a packed cholesky factorization and a linear solve\n// using that factorization, respectively\n", "comment_tokens": ["LAPACK", "prototypes", "for", "a", "packed", "cholesky", "factorization", "and", "a", "linear", "solve", "using", "that", "factorization", ",", "respectively"], "ccode": ["\n", "// LAPACK prototypes for a packed cholesky factorization and a linear solve\n", "// using that factorization, respectively\n", "int dpptrf_(char* uplo, int* n, double* ap,\n", "            int* info, int uplo_len);\n", "int dpptrs_(char* uplo, int* n, int* nrhs,\n", "            double* ap, double* b, int* ldb, int* info,\n", "            int uplo_len);\n", "\n", "\n", "void dogleg_computeJtJfactorization(dogleg_operatingPoint_t* point, dogleg_solverContext_t* ctx)\n", "{\n", "  // I already have this data, so don't need to recompute\n", "  if(point->updateGN_valid)\n", "    return;\n", "\n", "  if( ctx->is_sparse )\n", "  {\n", "    // I'm assuming the pattern of zeros will remain the same throughout, so I\n", "    // analyze only once\n", "    if(ctx->factorization == NULL)\n", "    {\n", "      ctx->factorization = cholmod_analyze(point->Jt, &ctx->common);\n", "      ASSERT(ctx->factorization != NULL);\n", "    }\n", "\n", "    while(1)\n", "    {\n", "      if( ctx->lambda == 0.0 )\n", "        ASSERT( cholmod_factorize(point->Jt, ctx->factorization, &ctx->common) );\n", "      else\n", "      {\n", "        double beta[] = { ctx->lambda, 0 };\n", "        ASSERT( cholmod_factorize_p(point->Jt, beta, NULL, 0,\n", "                                    ctx->factorization, &ctx->common) );\n", "      }\n", "\n", "      if(ctx->factorization->minor == ctx->factorization->n)\n", "        break;\n", "\n", "      // singular JtJ. Raise lambda and go again\n", "      if( ctx->lambda == 0.0) ctx->lambda = LAMBDA_INITIAL;\n", "      else                    ctx->lambda *= 10.0;\n", "      ASSERT( isfinite(ctx->lambda) );\n", "\n", "      if( DOGLEG_DEBUG )\n", "        SAY( \"singular JtJ. Have rank/full rank: %zd/%d. Adding %g I from now on\",\n", "             ctx->factorization->minor, ctx->Nstate, ctx->lambda);\n", "    }\n", "  }\n", "  else\n", "  {\n", "    if(ctx->factorization_dense == NULL)\n", "    {\n", "      // Need to store symmetric JtJ, so I only need one triangle of it\n", "      ctx->factorization_dense = malloc( ctx->Nstate * (ctx->Nstate+1) / 2 *\n", "                                         sizeof( ctx->factorization_dense[0]));\n", "      ASSERT(ctx->factorization_dense);\n", "    }\n", "\n", "    while(1)\n", "    {\n", "      // I construct my JtJ. JtJ is packed and stored row-first. I have two\n", "      // equivalent implementations. The one enabled here is maybe a bit faster,\n", "      // but it's definitely clearer\n", "#if 1\n", "      memset(ctx->factorization_dense,\n", "             0,\n", "             ctx->Nstate*(ctx->Nstate+1)/2*sizeof(ctx->factorization_dense[0]));\n", "      for(int i=0; i<ctx->Nmeasurements; i++)\n", "        accum_outerproduct_packed( ctx->factorization_dense, &point->J_dense[ctx->Nstate*i],\n", "                                   ctx->Nstate );\n", "      if( ctx->lambda > 0.0 )\n", "      {\n", "        int iJtJ=0;\n", "        for(int i1=0; i1<ctx->Nstate; i1++)\n", "        {\n", "          ctx->factorization_dense[iJtJ] += ctx->lambda;\n", "          iJtJ                           += ctx->Nstate-i1;\n", "        }\n", "      }\n", "#else\n", "      int iJtJ = 0;\n", "      for(int i1=0; i1<ctx->Nstate; i1++)\n", "      {\n", "        #error this does not work. overwritten in the following loop\n", "        ctx->factorization_dense[iJtJ] += ctx->lambda;\n", "\n", "        for(int i0=i1; i0<ctx->Nstate; i0++, iJtJ++)\n", "          ctx->factorization_dense[iJtJ] = inner_withstride( &point->J_dense[i0],\n", "                                                             &point->J_dense[i1],\n", "                                                             ctx->Nmeasurements,\n", "                                                             ctx->Nstate);\n", "      }\n", "#endif\n", "\n", "\n", "\n", "      int info;\n", "      dpptrf_(&(char){'L'}, &(int){ctx->Nstate}, ctx->factorization_dense,\n", "              &info, 1);\n", "      ASSERT(info >= 0); // we MUST either succeed or see complain of singular\n", "      // JtJ\n", "      if( info == 0 )\n", "        break;\n", "\n", "      // singular JtJ. Raise lambda and go again\n", "      if( ctx->lambda == 0.0) ctx->lambda = LAMBDA_INITIAL;\n", "      else                    ctx->lambda *= 10.0;\n", "\n", "      if( DOGLEG_DEBUG )\n", "        SAY( \"singular JtJ. Adding %g I from now on\", ctx->lambda);\n", "    }\n", "  }\n", "}\n"], "project": "libdogleg2", "file": "dogleg.pkl", "function": "dogleg_computeJtJfactorization"}, {"comment_all": {"comment": "/* The data material is known to contain ASCII, and if any value in there\n * is a lower case letter, it is first converted to upper case one.\n*/", "depth": 0, "reading_ease": 60.99, "reading_grade": 11.5, "line": 63}, "comment_text": "/* The data material is known to contain ASCII, and if any value in there\n * is a lower case letter, it is first converted to upper case one.\n*/", "comment_tokens": ["The", "data", "material", "is", "known", "to", "contain", "ASCII", ",", "and", "if", "any", "value", "in", "there", "is", "a", "lower", "case", "letter", ",", "it", "is", "first", "converted", "to", "upper", "case", "one", "."], "ccode": ["\n", "/* The data material is known to contain ASCII, and if any value in there\n", " * is a lower case letter, it is first converted to upper case one.\n", "*/\n", "uint32_t __attribute__((pure)) keyhashuc(const void const *p, int len, uint32_t hash)\n", "{\n", "\tconst uint8_t *u = p;\n", "\tint i;\n", "\n", "\tif (hash == 0)\n", "        \thash = (uint32_t)FNV_32_OFFSET;\n", "\n", "\tfor (i = 0; i < len; ++i, ++u) {\n", "#if defined(NO_FNV_GCC_OPTIMIZATION)\n", "\t\thash *= FNV_32_PRIME;\n", "#else\n", "\t\thash += (hash<<1) + (hash<<4) + (hash<<7) +\n", "\t\t        (hash<<8) + (hash<<24);\n", "#endif\n", "\t\tuint32_t c = *u;\n", "\t\t// Is it lower case ASCII letter ?\n", "\t\tif ('a' <= c && c <= 'z') {\n", "\t\t\t// convert to upper case.\n", "\t\t\tc -= ('a' - 'A');\n", "\t\t}\n", "\t\thash ^= c;\n", "\t}\n", "\treturn hash;\n", "}\n"], "project": "aprx", "file": "keyhash.pkl", "function": "keyhashuc"}, {"comment_all": {"comment": "/*\n * Determine if a trap affects the player.\n * Always miss 5% of the time, Always hit 5% of the time.\n * Otherwise, match trap power against player armor.\n */", "depth": 0, "reading_ease": 79.56, "reading_grade": 4.3, "line": 25}, "comment_text": "/*\n * Determine if a trap affects the player.\n * Always miss 5% of the time, Always hit 5% of the time.\n * Otherwise, match trap power against player armor.\n */", "comment_tokens": ["Determine", "if", "a", "trap", "affects", "the", "player", ".", "Always", "miss", "5", "%", "of", "the", "time", ",", "Always", "hit", "5", "%", "of", "the", "time", ".", "Otherwise", ",", "match", "trap", "power", "against", "player", "armor", "."], "ccode": ["/*\n", " * File: trap.c\n", " * Purpose: Trap triggering, selection, and placement\n", " *\n", " * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke\n", " *\n", " * This work is free software; you can redistribute it and/or modify it\n", " * under the terms of either:\n", " *\n", " * a) the GNU General Public License as published by the Free Software\n", " *    Foundation, version 2, or\n", " *\n", " * b) the \"Angband licence\":\n", " *    This software may be copied and distributed for educational, research,\n", " *    and not for profit purposes provided that this copyright and statement\n", " *    are included in all such copies.  Other copyrights may also apply.\n", " */\n", "\n", "#include \"angband.h\"\n", "#include \"attack.h\"\n", "#include \"cave.h\"\n", "#include \"effects.h\"\n", "#include \"spells.h\"\n", "#include \"trap.h\"\n", "\n", "/*\n", " * Determine if a trap affects the player.\n", " * Always miss 5% of the time, Always hit 5% of the time.\n", " * Otherwise, match trap power against player armor.\n", " */\n", "bool trap_check_hit(int power)\n", "{\n", "\treturn test_hit(power, p_ptr->state.ac + p_ptr->state.to_a, TRUE);\n", "}\n"], "project": "angband-data", "file": "trap.pkl", "function": "trap_check_hit"}, {"comment_all": {"comment": "/* new check from Mat\u00edas Giovannini */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 0}, "comment_text": "/* new check from Mat\u00edas Giovannini */", "comment_tokens": ["new", "check", "from", "Mat\u00edas", "Giovannini"], "ccode": ["/* new check from Mat\u00edas Giovannini */\n", "#include \"caml/mlvalues.h\"\n", "value check(value d) {\n", "  int i = 1;\n", "  char *s = (char*) &i;\n", "  return (s[0] == 0 ? Val_true : Val_false);\n", "}\n"], "project": "libocamlnet-ocaml-dev", "file": "tend.pkl", "function": "check"}, {"comment_all": {"comment": "/* Initialize the to-uppercase and to-lowercase tables. These should\n        *not* be localized to a platform-native character set! They are\n        intended to work on Latin-1 data, and the code below correctly\n        sets up the tables for that character set. */", "depth": 1, "reading_ease": 58.99, "reading_grade": 8.1, "line": 29}, "comment_text": "/* Initialize the to-uppercase and to-lowercase tables. These should\n        *not* be localized to a platform-native character set! They are\n        intended to work on Latin-1 data, and the code below correctly\n        sets up the tables for that character set. */", "comment_tokens": ["Initialize", "the", "to-uppercase", "and", "to-lowercase", "tables", ".", "These", "should", "not", "be", "localized", "to", "a", "platform-native", "character", "set", "!", "They", "are", "intended", "to", "work", "on", "Latin-1", "data", ",", "and", "the", "code", "below", "correctly", "sets", "up", "the", "tables", "for", "that", "character", "set", "."], "ccode": ["/* gtmisc.c: Miscellaneous functions\n", "        for GlkTerm, curses.h implementation of the Glk API.\n", "    Designed by Andrew Plotkin <erkyrath@eblong.com>\n", "    http://www.eblong.com/zarf/glk/index.html\n", "*/\n", "\n", "#include \"gtoption.h\"\n", "#include <stdlib.h>\n", "#include <wchar.h>\n", "#include <curses.h>\n", "#include \"glk.h\"\n", "#include \"glkterm.h\"\n", "\n", "static unsigned char char_tolower_table[256];\n", "static unsigned char char_toupper_table[256];\n", "unsigned char char_printable_table[256];\n", "unsigned char char_typable_table[256];\n", "\n", "gidispatch_rock_t (*gli_register_obj)(void *obj, glui32 objclass) = NULL;\n", "void (*gli_unregister_obj)(void *obj, glui32 objclass, gidispatch_rock_t objrock) = NULL;\n", "gidispatch_rock_t (*gli_register_arr)(void *array, glui32 len, char *typecode) = NULL;\n", "void (*gli_unregister_arr)(void *array, glui32 len, char *typecode, \n", "    gidispatch_rock_t objrock) = NULL;\n", "\n", "/* Set up things. This is called from main(). */\n", "void gli_initialize_misc()\n", "{\n", "    int ix;\n", "    \n", "    /* Initialize the to-uppercase and to-lowercase tables. These should\n", "        *not* be localized to a platform-native character set! They are\n", "        intended to work on Latin-1 data, and the code below correctly\n", "        sets up the tables for that character set. */\n", "    \n", "    for (ix=0; ix<256; ix++) {\n", "        char_toupper_table[ix] = ix;\n", "        char_tolower_table[ix] = ix;\n", "    }\n", "    for (ix=0; ix<256; ix++) {\n", "        int lower_equiv;\n", "        if (ix >= 'A' && ix <= 'Z') {\n", "            lower_equiv = ix + ('a' - 'A');\n", "        }\n", "        else if (ix >= 0xC0 && ix <= 0xDE && ix != 0xD7) {\n", "            lower_equiv = ix + 0x20;\n", "        }\n", "        else {\n", "            lower_equiv = 0;\n", "        }\n", "        if (lower_equiv) {\n", "            char_tolower_table[ix] = lower_equiv;\n", "            char_toupper_table[lower_equiv] = ix;\n", "        }\n", "    }\n", "}\n"], "project": "libglktermw-dev", "file": "gtmisc.pkl", "function": "gli_initialize_misc"}, {"comment_all": {"comment": "/*  @lc_strncmp()@ ---\tlike @strncmp()@ except that we convert the\n *\t\t\tfirst string to lower case before comparing.\n */", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 76}, "comment_text": "/*  @lc_strncmp()@ ---\tlike @strncmp()@ except that we convert the\n *\t\t\tfirst string to lower case before comparing.\n */", "comment_tokens": ["@", "lc_strncmp", "(", ")", "@", "--", "-", "like", "@", "strncmp", "(", ")", "@", "except", "that", "we", "convert", "the", "first", "string", "to", "lower", "case", "before", "comparing", "."], "ccode": ["#ifndef lint\n", "static char sccsid[] = \"@(#)regexp.c     1.2 (LBL) 12/4/85\";\n", "static char rcsid[] =\n", "   \"$Id: regexp.c,v 1.3 1999/05/27 16:17:43 mike Exp $\";\n", "#endif\n", "\n", "/*\n", " * Copyright %%\\copyright%% 1980 The Regents of the University of California.\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " * 3. All advertising materials mentioning features or use of this software\n", " *    must display the following acknowledgement:\n", " *\tThis product includes software developed by the University of\n", " *\tCalifornia, Berkeley and its contributors.\n", " * 4. Neither the name of the University nor the names of its contributors\n", " *    may be used to endorse or promote products derived from this software\n", " *    without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "\n", "/*\n", " * Regular expression matching routines for lgrind/tgrind/tfontedpr.\n", " *\n", " * These routines were written by Dave Presotto (I think) for vgrind.\n", " * Minor mods & attempts to improve performance by Van Jacobson\n", " * (van@@lbl-rtsg) and Chris Torek (chris@@maryland).\n", " *\n", " * Modifications.\n", " * --------------\n", " *    Sep 91\tGeorge V Reilly\tFixed up some bogus uses of @NIL@ and @NULL@.\n", " * 30 Mar 85\tVan & Chris\tChanged @expmatch()@ to return pointer to\n", " *\t\t\t\tstart of what was matched in addition to\n", " *\t\t\t\tpointer to match end.  Several changes to\n", " *\t\t\t\timprove performance (too numerous to mention).\n", " * 11 Dec 84\tDave Presotto\tWritten.\n", " */\n", "\n", "\n", "#include <stdio.h>\n", "#include <malloc.h>\n", "#include <ctype.h>\n", "#include <string.h>\n", "#include \"regexp.h\"\n", "\n", "#define makelower(c) (isupper((c)) ? tolower((c)) : (c))\n", "\n", "extern char *l_id;\n", "static void expconv(void);\t /* forward declaration */\n", "\n", "int    (*re_strncmp)(const char *, const char *, size_t);\t \n", "\t\t\t/* function used by @expmatch()@ to compare\n", "\t\t\t* strings.  The caller should make it point to\n", "\t\t\t* @strncmp()@ if case is significant &\n", "\t\t\t* @lc_strncmp()@ otherwise.\n", "\t\t\t*/\n", "\n", "\n", "/*  @lc_strncmp()@ ---\tlike @strncmp()@ except that we convert the\n", " *\t\t\tfirst string to lower case before comparing.\n", " */\n", "int lc_strncmp(register const char *s1, register const char *s2, register size_t len)\n", "{\n", "   while (len-- > 0)\n", "      if (*s2 - makelower(*s1))\n", "\t return 1;\n", "      else\n", "\t s2++, s1++;\n", "   \n", "   return 0;\n", "}\n"], "project": "lgrind", "file": "regexp.pkl", "function": "lc_strncmp"}, {"comment_all": {"comment": "/* we want each signal positioned at final_time */", "depth": 1, "reading_ease": 64.37, "reading_grade": 6.0, "line": 129}, "comment_text": "/* convert to normal processing when we hit final_count */\n/* we want each signal positioned at final_time */\n", "comment_tokens": ["convert", "to", "normal", "processing", "when", "we", "hit", "final_count", "we", "want", "each", "signal", "positioned", "at", "final_time"], "ccode": ["\n", "\n", "void integrate_toss_fetch(snd_susp_type a_susp, snd_list_type snd_list)\n", "    {\n", "    integrate_susp_type susp = (integrate_susp_type) a_susp;\n", "    time_type final_time = susp->susp.t0;\n", "    long n;\n", "\n", "    /* fetch samples from input up to final_time for this block of zeros */\n", "    while ((round((final_time - susp->input->t0) * susp->input->sr)) >=\n", "\t   susp->input->current)\n", "\tsusp_get_samples(input, input_ptr, input_cnt);\n", "    /* convert to normal processing when we hit final_count */\n", "    /* we want each signal positioned at final_time */\n", "    n = round((final_time - susp->input->t0) * susp->input->sr -\n", "         (susp->input->current - susp->input_cnt));\n", "    susp->input_ptr += n;\n", "    susp_took(input_cnt, n);\n", "    susp->susp.fetch = susp->susp.keep_fetch;\n", "    (*(susp->susp.fetch))(a_susp, snd_list);\n", "}\n"], "project": "audacity-data", "file": "integrate.pkl", "function": "integrate_toss_fetch"}, {"comment_all": {"comment": "/*\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */", "depth": 0, "reading_ease": 58.42, "reading_grade": 10.4, "line": 0}, "comment_text": "/*\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */", "comment_tokens": ["Copyright", "(", "C", ")", "2006", "Andreas", "Granig", "<", "agranig", "@", "linguin.org", ">", "This", "file", "is", "part", "of", "Kamailio", ",", "a", "free", "SIP", "server", ".", "Kamailio", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", "Kamailio", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA"], "ccode": ["/*\n", " * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "/*!\n", " * \\file\n", " * \\brief Supported parser\n", " * \\ingroup parser\n", " */\n", "\n", "#include \"../mem/mem.h\"\n", "#include \"parse_supported.h\"\n", "\n", "/*!\n", " * Parse all Supported headers\n", " */\n", "int parse_supported( struct sip_msg *msg)\n", "{\n", "\tunsigned int supported;\n", "\tstruct hdr_field  *hdr;\n", "\tstruct option_tag_body *sb;\n", "\n", "\t/* maybe the header is already parsed! */\n", "\tif (msg->supported && msg->supported->parsed)\n", "\t\treturn 0;\n", "\n", "\t/* parse to the end in order to get all SUPPORTED headers */\n", "\tif (parse_headers(msg,HDR_EOH_F,0)==-1 || !msg->supported)\n", "\t\treturn -1;\n", "\n", "\t/* bad luck! :-( - we have to parse them */\n", "\tsupported = 0;\n", "\tfor( hdr=msg->supported ; hdr ; hdr=next_sibling_hdr(hdr)) {\n", "\t\tif (hdr->parsed) {\n", "\t\t\tsupported |= ((struct option_tag_body*)hdr->parsed)->option_tags;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tsb = (struct option_tag_body*)pkg_malloc(sizeof(struct option_tag_body));\n", "\t\tif (sb == 0) {\n", "\t\t\tPKG_MEM_ERROR;\n", "\t\t\treturn -1;\n", "\t\t}\n", "\n", "\t\tparse_option_tag_body(&(hdr->body), &(sb->option_tags));\n", "\t\tsb->hfree = hf_free_option_tag;\n", "\t\tsb->option_tags_all = 0;\n", "\t\thdr->parsed = (void*)sb;\n", "\t\tsupported |= sb->option_tags;\n", "\t}\n", "\n", "\t((struct option_tag_body*)msg->supported->parsed)->option_tags_all = \n", "\t\tsupported;\n", "\treturn 0;\n", "}\n"], "project": "kamailio-json-modules", "file": "parse_supported.pkl", "function": "parse_supported"}, {"comment_all": {"comment": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */", "depth": 0, "reading_ease": 20.72, "reading_grade": 16.6, "line": 3341}, "comment_text": "/* yy_get_next_buffer - try to read in a new buffer\n *\n * Returns a code representing an action:\n *\tEOB_ACT_LAST_MATCH -\n *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n *\tEOB_ACT_END_OF_FILE - end of file\n */", "comment_tokens": ["yy_get_next_buffer", "-", "try", "to", "read", "in", "a", "new", "buffer", "Returns", "a", "code", "representing", "an", "action", ":", "EOB_ACT_LAST_MATCH", "-", "EOB_ACT_CONTINUE_SCAN", "-", "continue", "scanning", "from", "current", "position", "EOB_ACT_END_OF_FILE", "-", "end", "of", "file"], "ccode": ["\n", "/* yy_get_next_buffer - try to read in a new buffer\n", " *\n", " * Returns a code representing an action:\n", " *\tEOB_ACT_LAST_MATCH -\n", " *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n", " *\tEOB_ACT_END_OF_FILE - end of file\n", " */\n", "static int yy_get_next_buffer (void)\n", "{\n", "    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n", "\tchar *source = (yytext_ptr);\n", "\tint number_to_move, i;\n", "\tint ret_val;\n", "\n", "\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n", "\t\tYY_FATAL_ERROR(\n", "\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n", "\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n", "\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n", "\t\t\t{\n", "\t\t\t/* We matched a single character, the EOB, so\n", "\t\t\t * treat this as a final EOF.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_END_OF_FILE;\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\t/* We matched some text prior to the EOB, first\n", "\t\t\t * process it.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_LAST_MATCH;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t/* Try to read more data. */\n", "\n", "\t/* First move last chars to start of buffer. */\n", "\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n", "\n", "\tfor ( i = 0; i < number_to_move; ++i )\n", "\t\t*(dest++) = *(source++);\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n", "\t\t/* don't do the read, it's not guaranteed to return an EOF,\n", "\t\t * just force an EOF\n", "\t\t */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n", "\n", "\telse\n", "\t\t{\n", "\t\t\tint num_to_read =\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n", "\n", "\t\twhile ( num_to_read <= 0 )\n", "\t\t\t{ /* Not enough room in the buffer - grow it. */\n", "\n", "\t\t\t/* just a shorter name for the current buffer */\n", "\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n", "\n", "\t\t\tint yy_c_buf_p_offset =\n", "\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n", "\n", "\t\t\tif ( b->yy_is_our_buffer )\n", "\t\t\t\t{\n", "\t\t\t\tint new_size = b->yy_buf_size * 2;\n", "\n", "\t\t\t\tif ( new_size <= 0 )\n", "\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n", "\t\t\t\telse\n", "\t\t\t\t\tb->yy_buf_size *= 2;\n", "\n", "\t\t\t\tb->yy_ch_buf = (char *)\n", "\t\t\t\t\t/* Include room in for 2 EOB chars. */\n", "\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n", "\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n", "\t\t\t\t}\n", "\t\t\telse\n", "\t\t\t\t/* Can't grow it, we don't own it. */\n", "\t\t\t\tb->yy_ch_buf = NULL;\n", "\n", "\t\t\tif ( ! b->yy_ch_buf )\n", "\t\t\t\tYY_FATAL_ERROR(\n", "\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n", "\n", "\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n", "\n", "\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n", "\t\t\t\t\t\tnumber_to_move - 1;\n", "\n", "\t\t\t}\n", "\n", "\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n", "\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n", "\n", "\t\t/* Read in more data. */\n", "\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n", "\t\t\t(yy_n_chars), num_to_read );\n", "\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\tif ( (yy_n_chars) == 0 )\n", "\t\t{\n", "\t\tif ( number_to_move == YY_MORE_ADJ )\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_END_OF_FILE;\n", "\t\t\tyyrestart( yyin  );\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_LAST_MATCH;\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n", "\t\t\t\tYY_BUFFER_EOF_PENDING;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\telse\n", "\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n", "\n", "\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n", "\t\t/* Extend the array by 50%, plus the number we really need. */\n", "\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n", "\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n", "\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n", "\t\t/* \"- 2\" to take care of EOB's */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n", "\t}\n", "\n", "\t(yy_n_chars) += number_to_move;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n", "\n", "\treturn ret_val;\n", "}\n"], "project": "linux-buildinfo-5.8.0-1038-gcp", "file": "lexer.lex.pkl", "function": "yy_get_next_buffer"}, {"comment_all": {"comment": "/* test for g_module_open (NULL, ...) */", "depth": 0, "reading_ease": 92.8, "reading_grade": 1.3, "line": 33}, "comment_text": "/* test for g_module_open (NULL, ...) */", "comment_tokens": ["test", "for", "g_module_open", "(", "NULL", ",", "...", ")"], "ccode": ["\n", "/* test for g_module_open (NULL, ...) */\n", "static RESULT\n", "test_module_symbol_null (void)\n", "{\n", "\tgpointer proc = GINT_TO_POINTER (42);\n", "\n", "\tGModule *m = g_module_open (NULL, G_MODULE_BIND_LAZY);\n", "\n", "\tif (m == NULL)\n", "\t\treturn FAILED (\"bind to main module failed. #0\");\n", "\n", "\tif (g_module_symbol (m, \"__unlikely_\\nexistent__\", &proc))\n", "\t\treturn FAILED (\"non-existent symbol lookup failed. #1\");\n", "\n", "\tif (proc)\n", "\t\treturn FAILED (\"non-existent symbol lookup failed. #2\");\n", "\n", "\tif (!g_module_symbol (m, EXTERNAL_SYMBOL, &proc))\n", "\t\treturn FAILED (\"external lookup failed. #3\");\n", "\n", "\tif (!proc)\n", "\t\treturn FAILED (\"external lookup failed. #4\");\n", "\n", "\tif (!g_module_symbol (m, \"dummy_test_export\", &proc))\n", "\t\treturn FAILED (\"in-proc lookup failed. #5\");\n", "\n", "\tif (!proc)\n", "\t\treturn FAILED (\"in-proc lookup failed. #6\");\n", "\n", "\tif (!g_module_close (m))\n", "\t\treturn FAILED (\"close failed. #7\");\n", "\n", "\treturn OK;\n", "}\n"], "project": "libmono-smdiagnostics0.0-cil", "file": "module.pkl", "function": "test_module_symbol_null"}, {"comment_all": {"comment": "/*****************************************************************************\n* Return the last GIF error (0 if none) and reset the error.\t\t     *\n*****************************************************************************/", "depth": 0, "reading_ease": 84.68, "reading_grade": 4.4, "line": 32}, "comment_text": "/*****************************************************************************\n* Return the last GIF error (0 if none) and reset the error.\t\t     *\n*****************************************************************************/", "comment_tokens": ["Return", "the", "last", "GIF", "error", "(", "0", "if", "none", ")", "and", "reset", "the", "error", "."], "ccode": ["/*****************************************************************************\n", "*   \"Gif-Lib\" - Yet another gif library.\t\t\t\t     *\n", "*\t\t\t\t\t\t\t\t\t     *\n", "* Written by:  Gershon Elber\t\t\tIBM PC Ver 0.1,\tJun. 1989    *\n", "******************************************************************************\n", "* Handle error reporting for the GIF library.\t\t\t\t     *\n", "******************************************************************************\n", "* History:\t\t\t\t\t\t\t\t     *\n", "* 17 Jun 89 - Version 1.0 by Gershon Elber.\t\t\t\t     *\n", "*****************************************************************************/\n", "\n", "#include <stdio.h>\n", "#include \"gif_lib.h\"\n", "\n", "#define PROGRAM_NAME\t\"GIF_LIBRARY\"\n", "\n", "int _GifError = 0;\n", "\n", "#ifdef SYSV\n", "static char *VersionStr =\n", "        \"Gif library module,\\t\\tGershon Elber\\n\\\n", "\t(C) Copyright 1989 Gershon Elber, Non commercial use only.\\n\";\n", "#else\n", "static char *VersionStr =\n", "\tPROGRAM_NAME\n", "\t\"\tIBMPC \"\n", "\tGIF_LIB_VERSION\n", "\t\"\tGershon Elber,\t\"\n", "\t__DATE__ \",   \" __TIME__ \"\\n\"\n", "\t\"(C) Copyright 1989 Gershon Elber, Non commercial use only.\\n\";\n", "#endif /* SYSV */\n", "\n", "/*****************************************************************************\n", "* Return the last GIF error (0 if none) and reset the error.\t\t     *\n", "*****************************************************************************/\n", "int GifLastError(void)\n", "{\n", "    int i = _GifError;\n", "\n", "    _GifError = 0;\n", "\n", "    return i;\n", "}\n"], "project": "imaptool", "file": "gif_err.pkl", "function": "GifLastError"}, {"comment_all": {"comment": "/* Returns the library version as a string\n */", "depth": 0, "reading_ease": 81.29, "reading_grade": 3.7, "line": 31}, "comment_text": "/* Returns the library version as a string\n */", "comment_tokens": ["Returns", "the", "library", "version", "as", "a", "string"], "ccode": ["/*\n", " * Support functions\n", " *\n", " * Copyright (C) 2009-2018, Joachim Metz <joachim.metz@gmail.com>\n", " *\n", " * Refer to AUTHORS for acknowledgements.\n", " *\n", " * This software is free software: you can redistribute it and/or modify\n", " * it under the terms of the GNU Lesser General Public License as published by\n", " * the Free Software Foundation, either version 3 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This software is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public License\n", " * along with this software.  If not, see <http://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include <common.h>\n", "#include <types.h>\n", "\n", "#include <stdio.h>\n", "\n", "#include \"libfwnt_definitions.h\"\n", "#include \"libfwnt_support.h\"\n", "\n", "#if !defined( HAVE_LOCAL_LIBFWNT )\n", "\n", "/* Returns the library version as a string\n", " */\n", "const char *libfwnt_get_version(\n", "             void )\n", "{\n", "\treturn( (const char *) LIBFWNT_VERSION_STRING );\n", "}\n"], "project": "libfwnt1", "file": "libfwnt_support.pkl", "function": "libfwnt_get_version"}, {"comment_all": {"comment": "/*\n *----------------------------------------------------------------------------\n *\n * Pngtcl_Init --\n *\n *  Initialisation routine for loadable module\n *\n * Results:\n *  None.\n *\n * Side effects:\n *  Creates commands in the interpreter,\n *  loads xml package.\n *\n *----------------------------------------------------------------------------\n */", "depth": 0, "reading_ease": 36.96, "reading_grade": 10.3, "line": 21}, "comment_text": "/*\n *----------------------------------------------------------------------------\n *\n * Pngtcl_Init --\n *\n *  Initialisation routine for loadable module\n *\n * Results:\n *  None.\n *\n * Side effects:\n *  Creates commands in the interpreter,\n *  loads xml package.\n *\n *----------------------------------------------------------------------------\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "Pngtcl_Init", "--", "Initialisation", "routine", "for", "loadable", "module", "Results", ":", "None", ".", "Side", "effects", ":", "Creates", "commands", "in", "the", "interpreter", ",", "loads", "xml", "package", ".", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["/*\n", " * pngtcl.c --\n", " *\n", " *  Generic interface to XML parsers.\n", " *\n", " * Copyright (c) 2002 Andreas Kupries <andreas_kupries@users.sourceforge.net>\n", " *\n", " * Zveno Pty Ltd makes this software and associated documentation\n", " * available free of charge for any purpose.  You may make copies\n", " * of the software but you must include all of this notice on any copy.\n", " *\n", " * Zveno Pty Ltd does not warrant that this software is error free\n", " * or fit for any purpose.  Zveno Pty Ltd disclaims any liability for\n", " * all claims, expenses, losses, damages and costs any user may incur\n", " * as a result of using, copying or modifying the software.\n", " *\n", " */\n", "\n", "#include \"zlibtcl.h\"\n", "#include \"pngtcl.h\"\n", "\n", "/*\n", " *----------------------------------------------------------------------------\n", " *\n", " * Pngtcl_Init --\n", " *\n", " *  Initialisation routine for loadable module\n", " *\n", " * Results:\n", " *  None.\n", " *\n", " * Side effects:\n", " *  Creates commands in the interpreter,\n", " *  loads xml package.\n", " *\n", " *----------------------------------------------------------------------------\n", " */\n", "\n", "int\n", "Pngtcl_Init (interp)\n", "      Tcl_Interp *interp; /* Interpreter to initialise. */\n", "{\n", "  extern const PngtclStubs pngtclStubs;\n", "\n", "  if (Tcl_InitStubs(interp, \"8.3\", 0) == NULL) {\n", "    return TCL_ERROR;\n", "  }\n", "  if (Zlibtcl_InitStubs(interp, ZLIBTCL_VERSION, 1) == NULL) {\n", "    return TCL_ERROR;\n", "  }\n", "\n", "  if (Tcl_PkgProvideEx(interp, PACKAGE_NAME, PACKAGE_VERSION,\n", "\t\t       (ClientData) &pngtclStubs) != TCL_OK) {\n", "    return TCL_ERROR;\n", "  }\n", "\n", "  return TCL_OK;\n", "}\n"], "project": "libtk-img-doc", "file": "pngtcl.pkl", "function": "Pngtcl_Init"}, {"comment_all": {"comment": "/*\n** Restore all tasks to where they were when taskRestoreAll()\n** was called.\n*/", "depth": 0, "reading_ease": 77.23, "reading_grade": 5.2, "line": 214}, "comment_text": "/*\n** Restore all tasks to where they were when taskRestoreAll()\n** was called.\n*/", "comment_tokens": ["Restore", "all", "tasks", "to", "where", "they", "were", "when", "taskRestoreAll", "(", ")", "was", "called", "."], "ccode": ["\n", "\n", "\n", "/*\n", "** Restore all tasks to where they were when taskRestoreAll()\n", "** was called.\n", "*/\n", "void taskRestoreAll ()\n", "{\n", "  int loop;\n", "\n", "  for ( loop = 0; loop <= max_task; loop++ ) {\n", "    if ( tasks[loop] ) {\n", "      taskRestore ( tasks[loop] );\n", "    }\n", "  }\n", "}\n"], "project": "gtimer", "file": "task.pkl", "function": "taskRestoreAll"}, {"comment_all": {"comment": "/* devices.c\n *\n * (c) 2015, 2018 Markus Heinz\n *\n * This software is licensed under the terms of the GPL.\n * For details see file COPYING.\n */", "depth": 0, "reading_ease": 86.2, "reading_grade": 3.8, "line": 0}, "comment_text": "/* devices.c\n *\n * (c) 2015, 2018 Markus Heinz\n *\n * This software is licensed under the terms of the GPL.\n * For details see file COPYING.\n */", "comment_tokens": ["devices.c", "(", "c", ")", "2015", ",", "2018", "Markus", "Heinz", "This", "software", "is", "licensed", "under", "the", "terms", "of", "the", "GPL", ".", "For", "details", "see", "file", "COPYING", "."], "ccode": ["/* devices.c\n", " *\n", " * (c) 2015, 2018 Markus Heinz\n", " *\n", " * This software is licensed under the terms of the GPL.\n", " * For details see file COPYING.\n", " */\n", "\n", "#include \"config.h\"\n", "\n", "#include <stdio.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "#include <string.h>\n", "#include <sys/ioctl.h>\n", "\n", "#include \"inklevel.h\"\n", "#include \"internal.h\"\n", "#include \"devices.h\"\n", "#include \"bjnp.h\"\n", "#include \"libusb-utils.h\"\n", "\n", "int get_device_id(const int port, const char *device_file, \n", "                  const int portnumber, char *device_id) {\n", "  int result = COULD_NOT_GET_DEVICE_ID;\n", "\n", "  if (port == USB) {\n", "    libusb_context *ctx = NULL;\n", "    usb_printer *printer = NULL;\n", "\n", "    if (init_usb(ctx) != USB_SUCCESS) {\n", "      return COULD_NOT_GET_DEVICE_ID;\n", "    }\n", "\n", "    printer = find_printer(ctx, portnumber);\n", "\n", "    if (printer != NULL) {\n", "      result = open_device_handle(printer);\n", "\n", "      if (result == USB_SUCCESS) {\n", "\tresult = get_usb_device_id(printer, device_id, BUFLEN);\n", "        release_device_handle(printer);\n", "      }\n", "      \n", "      free(printer);\n", "    }\n", "\n", "    shutdown_usb(ctx);\n", "\n", "    if (result == USB_SUCCESS)\n", "      return OK;\n", "    else\n", "      return COULD_NOT_GET_DEVICE_ID;\n", "\n", "  } else if (port == CUSTOM_BJNP)  {\n", "    return bjnp_get_id_from_named_printer(portnumber, device_file, device_id);\n", "  } else if (port == BJNP) {\n", "    return bjnp_get_id_from_printer_port(portnumber, device_id);\n", "  } else {\n", "    return UNKNOWN_PORT_SPECIFIED;\n", "  }\n", "}\n"], "project": "libinklevel5", "file": "devices.pkl", "function": "get_device_id"}, {"comment_all": {"comment": "/* a;sldkjfaslf;kjsaf;lsakjf;alksjdf;laskdjf;a */", "depth": 1, "reading_ease": -470.99, "reading_grade": 79.2, "line": 155}, "comment_text": "/* a;sldkjfaslf;kjsaf;lsakjf;alksjdf;laskdjf;a */", "comment_tokens": ["a", ";", "sldkjfaslf", ";", "kjsaf", ";", "lsakjf", ";", "alksjdf", ";", "laskdjf", ";", "a"], "ccode": ["\n", "void\n", "jconv_info_set_locale (void)\n", "{\n", "\tchar *locale_name;\n", "\t\n", "\tlocale_name = setlocale(LC_CTYPE, NULL);\n", "\tif (current_locale >= 0 &&\n", "\t    strcasecmp(jconv_locales[current_locale].name, locale_name) == 0)\n", "\t\treturn;\n", "\tcurrent_locale = -1;\n", "\t/* 1st try */\n", "\tcurrent_locale = jconv_info_query(locale_name, strlen(locale_name));\n", "\tif (current_locale >= 0) return;\n", "\t/* 2nd try */\n", "\tcurrent_locale = jconv_info_query(locale_name,\n", "\t\t\t\t\t  strcspn(locale_name, \"@\"));\n", "\tif (current_locale >= 0) return;\n", "\t/* 3rd try */\n", "\tcurrent_locale = jconv_info_query(locale_name,\n", "\t\t\t\t\t  strcspn(locale_name, \"@.+,\"));\n", "\tif (current_locale >= 0) return;\n", "\t/* 4th try */\n", "\tcurrent_locale = jconv_info_query(locale_name,\n", "\t\t\t\t\t  strcspn(locale_name, \"@.+,_\"));\n", "\tif (current_locale >= 0) return;\n", "\t/* a;sldkjfaslf;kjsaf;lsakjf;alksjdf;laskdjf;a */\n", "\tcurrent_locale = 0;\n", "}\n"], "project": "libjconv-bin", "file": "info.pkl", "function": "jconv_info_set_locale"}, {"comment_all": {"comment": "/*\n * Make sure the format string is well formed, and parse out\n * the used atoms.\n */", "depth": 0, "reading_ease": 99.57, "reading_grade": 2.9, "line": 869}, "comment_text": "/*\n * Make sure the format string is well formed, and parse out\n * the used atoms.\n */", "comment_tokens": ["Make", "sure", "the", "format", "string", "is", "well", "formed", ",", "and", "parse", "out", "the", "used", "atoms", "."], "ccode": ["\n", "/*\n", " * Make sure the format string is well formed, and parse out\n", " * the used atoms.\n", " */\n", "int verify_ref_format(struct ref_format *format)\n", "{\n", "\tconst char *cp, *sp;\n", "\n", "\tformat->need_color_reset_at_eol = 0;\n", "\tfor (cp = format->format; *cp && (sp = find_next(cp)); ) {\n", "\t\tstruct strbuf err = STRBUF_INIT;\n", "\t\tconst char *color, *ep = strchr(sp, ')');\n", "\t\tint at;\n", "\n", "\t\tif (!ep)\n", "\t\t\treturn error(_(\"malformed format string %s\"), sp);\n", "\t\t/* sp points at \"%(\" and ep points at the closing \")\" */\n", "\t\tat = parse_ref_filter_atom(format, sp + 2, ep, &err);\n", "\t\tif (at < 0)\n", "\t\t\tdie(\"%s\", err.buf);\n", "\t\tcp = ep + 1;\n", "\n", "\t\tif (skip_prefix(used_atom[at].name, \"color:\", &color))\n", "\t\t\tformat->need_color_reset_at_eol = !!strcmp(color, \"reset\");\n", "\t\tstrbuf_release(&err);\n", "\t}\n", "\tif (format->need_color_reset_at_eol && !want_color(format->use_color))\n", "\t\tformat->need_color_reset_at_eol = 0;\n", "\treturn 0;\n", "}\n"], "project": "git-man", "file": "ref-filter.pkl", "function": "verify_ref_format"}, {"comment_all": {"comment": "/************************************************************\nCopyright (c) 1993 by Silicon Graphics Computer Systems, Inc.\n\nPermission to use, copy, modify, and distribute this\nsoftware and its documentation for any purpose and without\nfee is hereby granted, provided that the above copyright\nnotice appear in all copies and that both that copyright\nnotice and this permission notice appear in supporting\ndocumentation, and that the name of Silicon Graphics not be\nused in advertising or publicity pertaining to distribution\nof the software without specific prior written permission.\nSilicon Graphics makes no representation about the suitability\nof this software for any purpose. It is provided \"as is\"\nwithout any express or implied warranty.\n\nSILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\nSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\nGRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\nDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\nDATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\nTHE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n********************************************************/", "depth": 0, "reading_ease": 32.87, "reading_grade": 16.1, "line": 0}, "comment_text": "/************************************************************\nCopyright (c) 1993 by Silicon Graphics Computer Systems, Inc.\n\nPermission to use, copy, modify, and distribute this\nsoftware and its documentation for any purpose and without\nfee is hereby granted, provided that the above copyright\nnotice appear in all copies and that both that copyright\nnotice and this permission notice appear in supporting\ndocumentation, and that the name of Silicon Graphics not be\nused in advertising or publicity pertaining to distribution\nof the software without specific prior written permission.\nSilicon Graphics makes no representation about the suitability\nof this software for any purpose. It is provided \"as is\"\nwithout any express or implied warranty.\n\nSILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\nSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\nGRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\nDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\nDATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\nTHE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n********************************************************/", "comment_tokens": ["Copyright", "(", "c", ")", "1993", "by", "Silicon", "Graphics", "Computer", "Systems", ",", "Inc", ".", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "and", "distribute", "this", "software", "and", "its", "documentation", "for", "any", "purpose", "and", "without", "fee", "is", "hereby", "granted", ",", "provided", "that", "the", "above", "copyright", "notice", "appear", "in", "all", "copies", "and", "that", "both", "that", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "supporting", "documentation", ",", "and", "that", "the", "name", "of", "Silicon", "Graphics", "not", "be", "used", "in", "advertising", "or", "publicity", "pertaining", "to", "distribution", "of", "the", "software", "without", "specific", "prior", "written", "permission", ".", "Silicon", "Graphics", "makes", "no", "representation", "about", "the", "suitability", "of", "this", "software", "for", "any", "purpose", ".", "It", "is", "provided", "``", "as", "is", "''", "without", "any", "express", "or", "implied", "warranty", ".", "SILICON", "GRAPHICS", "DISCLAIMS", "ALL", "WARRANTIES", "WITH", "REGARD", "TO", "THIS", "SOFTWARE", ",", "INCLUDING", "ALL", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "IN", "NO", "EVENT", "SHALL", "SILICON", "GRAPHICS", "BE", "LIABLE", "FOR", "ANY", "SPECIAL", ",", "INDIRECT", "OR", "CONSEQUENTIAL", "DAMAGES", "OR", "ANY", "DAMAGES", "WHATSOEVER", "RESULTING", "FROM", "LOSS", "OF", "USE", ",", "DATA", "OR", "PROFITS", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "NEGLIGENCE", "OR", "OTHER", "TORTIOUS", "ACTION", ",", "ARISING", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "USE", "OR", "PERFORMANCE", "OF", "THIS", "SOFTWARE", "."], "ccode": ["/************************************************************\n", "Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.\n", "\n", "Permission to use, copy, modify, and distribute this\n", "software and its documentation for any purpose and without\n", "fee is hereby granted, provided that the above copyright\n", "notice appear in all copies and that both that copyright\n", "notice and this permission notice appear in supporting\n", "documentation, and that the name of Silicon Graphics not be\n", "used in advertising or publicity pertaining to distribution\n", "of the software without specific prior written permission.\n", "Silicon Graphics makes no representation about the suitability\n", "of this software for any purpose. It is provided \"as is\"\n", "without any express or implied warranty.\n", "\n", "SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n", "SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n", "AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n", "GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n", "DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n", "DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n", "OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n", "THE USE OR PERFORMANCE OF THIS SOFTWARE.\n", "\n", "********************************************************/\n", "\n", "#ifdef HAVE_DIX_CONFIG_H\n", "#include <dix-config.h>\n", "#endif\n", "\n", "#include <stdio.h>\n", "#include <X11/X.h>\n", "#include <X11/Xproto.h>\n", "#include <X11/keysym.h>\n", "#include \"inputstr.h\"\n", "#include \"scrnintstr.h\"\n", "#include \"windowstr.h\"\n", "#include <xkbsrv.h>\n", "#include <X11/extensions/XI.h>\n", "\n", "void\n", "XkbDDXKeybdCtrlProc(DeviceIntPtr dev, KeybdCtrl * ctrl)\n", "{\n", "    int realRepeat;\n", "\n", "    realRepeat = ctrl->autoRepeat;\n", "    if ((dev->kbdfeed) && (XkbDDXUsesSoftRepeat(dev)))\n", "        ctrl->autoRepeat = 0;\n", "    if (dev->key && dev->key->xkbInfo && dev->key->xkbInfo->kbdProc)\n", "        (*dev->key->xkbInfo->kbdProc) (dev, ctrl);\n", "    ctrl->autoRepeat = realRepeat;\n", "    return;\n", "}\n"], "project": "xnest", "file": "ddxCtrls.pkl", "function": "XkbDDXKeybdCtrlProc"}, {"comment_all": {"comment": "// write everything into the options file\t    \n", "depth": 2, "reading_ease": 56.93, "reading_grade": 6.8, "line": 98}, "comment_text": "// write everything into the options file\t    \n", "comment_tokens": ["write", "everything", "into", "the", "options", "file"], "ccode": ["\n", "void FinalScore()\n", "{\n", "    char Name[200]=\"\",text[200];\n", "\tint a;\n", "    FILE *file;\n", "\n", "    if (Score>Hiscore[9]) {\n", "    Blit(0,0,back);\n", "    XCenteredString(Screen, 200, \"< YOUR FINAL SCORE >\");\n", "    sprintf(text,\"%d\", Score);\n", "    XCenteredString(Screen, 250, text);\n", "    XCenteredString(Screen, 300, \"Enter Your Name:\");\n", "    Update();\n", "\tSDL_EventState(SDL_KEYUP, SDL_ENABLE);\n", "\tSDL_EventState(SDL_KEYDOWN, SDL_ENABLE);\n", "\tSFont_Input(Screen, 350, 350, 200, Name);\n", "    if (strcmp(Name,\"\")==0) strcpy(Name,\"Anonymous Coward\");\n", "    for (i=0;i<10;i++) {\n", "\tif (Score>Hiscore[i]) {\n", "\t    // Move other players down on the list\n", "\t    for (a=9;a>=i;a--) {\n", "\t\tstrcpy(Player[a],Player[a-1]);\n", "\t\tHiscore[a]=Hiscore[a-1];\t\t\n", "\t    }\n", "\t    // add the player\n", "\t    strcpy(Player[i],Name);\n", "\t    Hiscore[i]=Score;\n", "\t    break;\n", "\t}\n", "    }\n", "//    for (i=0;i<10;i++)\n", "//\tprintf(\"%s %d\\n\",Player[i],Hiscore[i]);\n", "    \n", "    // write everything into the options file\t    \n", "    file=OpenOptionsFile(\"w\");\n", "    if (file==NULL) exit(1);\n", "    \n", "    fprintf(file, \"# BumpRace Options File\\n\\n\");\n", "    for (i=0;i<10;i++)\n", "\tfprintf(file, \"%s\\n\", Player[i]);\n", "    for (i=0;i<10;i++)\n", "\tfprintf(file, \"%d\\n\", Hiscore[i]);\n", "\n", "    fclose(file);\n", "\n", "} else {\n", "\n", "    if (Score<0) Score=0;\n", "    Blit(0,0,back);\n", "    XCenteredString(Screen, 200, \"< YOUR FINAL SCORE >\");\n", "    sprintf(text,\"%d\", Score);\n", "    XCenteredString(Screen, 250, text);\n", "    XCenteredString(Screen, 300, \"You didn't qualify for the highscore list...\");\n", "    Update();\n", "    SDL_EventState(SDL_KEYUP, SDL_ENABLE);\n", "    SDL_EventState(SDL_KEYDOWN, SDL_ENABLE);    \n", "    SDL_WaitEvent(&event);\n", "    SDL_WaitEvent(&event);\n", "}}\n"], "project": "bumprace-data", "file": "options.pkl", "function": "FinalScore"}, {"comment_all": {"comment": "/* filecopy copies a file as a tmp file */", "depth": 0, "reading_ease": 105.66, "reading_grade": 0.5, "line": 53}, "comment_text": "/* filecopy copies a file as a tmp file */", "comment_tokens": ["filecopy", "copies", "a", "file", "as", "a", "tmp", "file"], "ccode": ["\n", "/* filecopy copies a file as a tmp file */\n", "char *filecopy(char *from)\n", "{\n", "\tchar buf[BUFSIZ];\n", "\tint fdf,fdt;\n", "\tint n;\n", "\tstatic char tempbin[]=\"/tmp/.umbinfmtXXXXXX\";\n", "\tmode_t oldmask=umask(0077);\n", "\tfdt=mkstemp(tempbin);\n", "\tumask(oldmask);\n", "\tif (fdt < 0)\n", "\t\treturn NULL;\n", "\tif ((fdf=open(from,O_RDONLY,0)) < 0)\n", "\t\treturn NULL;\n", "\twhile ((n=read(fdf,buf,BUFSIZ)) > 0)\n", "\t\twrite (fdt,buf,n);\n", "\tclose(fdf);\n", "\tfchmod (fdt,0700); \n", "\tclose (fdt);\n", "\treturn tempbin;\n", "}\n"], "project": "libumlib0", "file": "umbinwrap.pkl", "function": "filecopy"}, {"comment_all": {"comment": "/*\n * Expand a string that follows '$'\n *\n * For example, if the input string is\n *     ($(FOO)$($(BAR)))$(BAZ)\n * this helper evaluates\n *     $($(FOO)$($(BAR)))\n * and returns a new string containing the expansion (note that the string is\n * recursively expanded), also advancing 'str' to point to the next character\n * after the corresponding closing parenthesis, in this case, *str will be\n *     $(BAR)\n */", "depth": 0, "reading_ease": 17.68, "reading_grade": 24.0, "line": 440}, "comment_text": "/*\n * Expand a string that follows '$'\n *\n * For example, if the input string is\n *     ($(FOO)$($(BAR)))$(BAZ)\n * this helper evaluates\n *     $($(FOO)$($(BAR)))\n * and returns a new string containing the expansion (note that the string is\n * recursively expanded), also advancing 'str' to point to the next character\n * after the corresponding closing parenthesis, in this case, *str will be\n *     $(BAR)\n */", "comment_tokens": ["Expand", "a", "string", "that", "follows", "'", "$", "'", "For", "example", ",", "if", "the", "input", "string", "is", "(", "$", "(", "FOO", ")", "$", "(", "$", "(", "BAR", ")", ")", ")", "$", "(", "BAZ", ")", "this", "helper", "evaluates", "$", "(", "$", "(", "FOO", ")", "$", "(", "$", "(", "BAR", ")", ")", ")", "and", "returns", "a", "new", "string", "containing", "the", "expansion", "(", "note", "that", "the", "string", "is", "recursively", "expanded", ")", ",", "also", "advancing", "'str", "'", "to", "point", "to", "the", "next", "character", "after", "the", "corresponding", "closing", "parenthesis", ",", "in", "this", "case", ",", "str", "will", "be", "$", "(", "BAR", ")"], "ccode": ["\n", "/*\n", " * Expand a string that follows '$'\n", " *\n", " * For example, if the input string is\n", " *     ($(FOO)$($(BAR)))$(BAZ)\n", " * this helper evaluates\n", " *     $($(FOO)$($(BAR)))\n", " * and returns a new string containing the expansion (note that the string is\n", " * recursively expanded), also advancing 'str' to point to the next character\n", " * after the corresponding closing parenthesis, in this case, *str will be\n", " *     $(BAR)\n", " */\n", "static char *expand_dollar_with_args(const char **str, int argc, char *argv[])\n", "{\n", "\tconst char *p = *str;\n", "\tconst char *q;\n", "\tint nest = 0;\n", "\n", "\t/*\n", "\t * In Kconfig, variable/function references always start with \"$(\".\n", "\t * Neither single-letter variables as in $A nor curly braces as in ${CC}\n", "\t * are supported.  '$' not followed by '(' loses its special meaning.\n", "\t */\n", "\tif (*p != '(') {\n", "\t\t*str = p;\n", "\t\treturn xstrdup(\"$\");\n", "\t}\n", "\n", "\tp++;\n", "\tq = p;\n", "\twhile (*q) {\n", "\t\tif (*q == '(') {\n", "\t\t\tnest++;\n", "\t\t} else if (*q == ')') {\n", "\t\t\tif (nest-- == 0)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\tq++;\n", "\t}\n", "\n", "\tif (!*q)\n", "\t\tpperror(\"unterminated reference to '%s': missing ')'\", p);\n", "\n", "\t/* Advance 'str' to after the expanded initial portion of the string */\n", "\t*str = q + 1;\n", "\n", "\treturn eval_clause(p, q - p, argc, argv);\n", "}\n"], "project": "linux-azure-5.8-tools-5.8.0-1042", "file": "preprocess.pkl", "function": "expand_dollar_with_args"}, {"comment_all": {"comment": "/* GStreamer\n * Copyright (C) 2009 Wim Taymans <wim.taymans at gmail.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n */", "depth": 0, "reading_ease": 61.77, "reading_grade": 9.1, "line": 0}, "comment_text": "/* GStreamer\n * Copyright (C) 2009 Wim Taymans <wim.taymans at gmail.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n */", "comment_tokens": ["GStreamer", "Copyright", "(", "C", ")", "2009", "Wim", "Taymans", "<", "wim.taymans", "at", "gmail.com", ">", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "St", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA", "."], "ccode": ["/* GStreamer\n", " * Copyright (C) 2009 Wim Taymans <wim.taymans at gmail.com>\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n", " * Boston, MA 02110-1301, USA.\n", " */\n", "\n", "#include <gst/gst.h>\n", "\n", "#include <gst/rtsp-server/rtsp-server.h>\n", "\n", "\n", "static gboolean\n", "timeout (GstRTSPServer * server)\n", "{\n", "  GstRTSPSessionPool *pool;\n", "\n", "  pool = gst_rtsp_server_get_session_pool (server);\n", "  gst_rtsp_session_pool_cleanup (pool);\n", "  g_object_unref (pool);\n", "\n", "  return TRUE;\n", "}\n"], "project": "libgstrtspserver-1.0-dev", "file": "test-sdp.pkl", "function": "timeout"}, {"comment_all": {"comment": "/* decompress a open file. Call fatal() on error\n   return the number of bytes that have been retrieved\n */", "depth": 0, "reading_ease": 79.77, "reading_grade": 4.2, "line": 176}, "comment_text": "/* decompress a open file. Call fatal() on error\n   return the number of bytes that have been retrieved\n */", "comment_tokens": ["decompress", "a", "open", "file", ".", "Call", "fatal", "(", ")", "on", "error", "return", "the", "number", "of", "bytes", "that", "have", "been", "retrieved"], "ccode": ["\n", "/* decompress a open file. Call fatal() on error\n", "   return the number of bytes that have been retrieved\n", " */\n", "off_t runzip_fd(int fd_in, int fd_out, int fd_hist, off_t expected_size)\n", "{\n", "\toff_t total = 0;\n", "\twhile (total < expected_size) {\n", "\t\ttotal += runzip_chunk(fd_in, fd_out, fd_hist);\n", "\t}\n", "\treturn total;\n", "}\n"], "project": "rzip", "file": "runzip.pkl", "function": "runzip_fd"}, {"comment_all": {"comment": "/**\n * Fall back on getting device name from pcap.\n */", "depth": 0, "reading_ease": 88.74, "reading_grade": 2.9, "line": 30}, "comment_text": "/**\n * Fall back on getting device name from pcap.\n */", "comment_tokens": ["Fall", "back", "on", "getting", "device", "name", "from", "pcap", "."], "ccode": ["/* arping/src/unix.c\n", " *\n", " *  Copyright (C) 2000-2011 Thomas Habets <thomas@habets.se>\n", " *\n", " *  This program is free software; you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation; either version 2 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  This program is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License along\n", " *  with this program; if not, write to the Free Software Foundation, Inc.,\n", " *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " */\n", "#if HAVE_CONFIG_H\n", "#include \"config.h\"\n", "#endif\n", "\n", "#include <signal.h>\n", "\n", "#include <pcap.h>\n", "\n", "#include \"arping.h\"\n", "\n", "#define UNUSED(x) (void)(x)\n", "\n", "/**\n", " * Fall back on getting device name from pcap.\n", " */\n", "const char *\n", "arping_lookupdev_default(uint32_t srcip, uint32_t dstip, char *ebuf)\n", "{\n", "        UNUSED(srcip);\n", "        UNUSED(dstip);\n", "        return pcap_lookupdev(ebuf);\n", "}\n"], "project": "arping", "file": "unix.pkl", "function": "arping_lookupdev_default"}, {"comment_all": {"comment": "/*\n * namecmp_ext()\n *\n * Compare a pathname with the extensions list. Returns 0 for\n * a match, -1 otherwise.\n *\n */", "depth": 0, "reading_ease": 72.32, "reading_grade": 5.0, "line": 236}, "comment_text": "/*\n * namecmp_ext()\n *\n * Compare a pathname with the extensions list. Returns 0 for\n * a match, -1 otherwise.\n *\n */", "comment_tokens": ["namecmp_ext", "(", ")", "Compare", "a", "pathname", "with", "the", "extensions", "list", ".", "Returns", "0", "for", "a", "match", ",", "-1", "otherwise", "."], "ccode": ["\n", "\n", "/*\n", " * namecmp_ext()\n", " *\n", " * Compare a pathname with the extensions list. Returns 0 for\n", " * a match, -1 otherwise.\n", " *\n", " */\n", "STATIC int\n", "namecmp_ext (name)\n", "     reg char *name;\n", "{\n", "  reg Pattern *px;\n", "  char *p,*n;\n", "\n", "  n=name;\n", "  if(ignoreslash && (n[0]=='/')) n++;\n", "\n", "  for(px=pattern; px; px=px->p_forw)\n", "   if((px->p_ptype)==PATTYPE_EXT)\n", "     {\n", "       p=px->p_str;\n", "       if(ignoreslash && (p[0]=='/')) p++;\n", "\n", "       if(fnmatch(p,n,0)==0) return 0;\n", "     }\n", "\n", "  return -1;\n", "}\n"], "project": "afio", "file": "match.pkl", "function": "namecmp_ext"}, {"comment_all": {"comment": "/*\n * Update the PieceList and Pindex arrays when a piece is captured or when a\n * capture is unmade.\n */", "depth": 0, "reading_ease": 71.14, "reading_grade": 7.6, "line": 1074}, "comment_text": "/*\n * Update the PieceList and Pindex arrays when a piece is captured or when a\n * capture is unmade.\n */", "comment_tokens": ["Update", "the", "PieceList", "and", "Pindex", "arrays", "when", "a", "piece", "is", "captured", "or", "when", "a", "capture", "is", "unmade", "."], "ccode": ["\n", "\n", "\n", "/*\n", " * Update the PieceList and Pindex arrays when a piece is captured or when a\n", " * capture is unmade.\n", " */\n", "\n", "void\n", "UpdatePieceList(short side, short sq, UpdatePieceList_mode iop)\n", "{\n", "    short i;\n", "\n", "    if (iop == REMOVE_PIECE)\n", "    {\n", "        PieceCnt[side]--;\n", "\n", "        for (i = Pindex[sq]; i <= PieceCnt[side]; i++)\n", "        {\n", "            PieceList[side][i] = PieceList[side][i + 1];\n", "            Pindex[PieceList[side][i]] = i;\n", "        }\n", "    }\n", "    else if (board[sq] == king)\n", "    {\n", "        /* king must have index 0 */\n", "        for (i = PieceCnt[side]; i >= 0; i--)\n", "        {\n", "            PieceList[side][i + 1] = PieceList[side][i];\n", "            Pindex[PieceList[side][i + 1]] = i + 1;\n", "        }\n", "\n", "        PieceCnt[side]++;\n", "        PieceList[side][0] = sq;\n", "        Pindex[sq] = 0;\n", "    }\n", "    else\n", "    {\n", "        PieceCnt[side]++;\n", "        PieceList[side][PieceCnt[side]] = sq;\n", "        Pindex[sq] = PieceCnt[side];\n", "    }\n", "}\n"], "project": "gnuminishogi", "file": "search.pkl", "function": "UpdatePieceList"}, {"comment_all": {"comment": "/*\n\t\t * keep checking more lines until we find something that\n\t\t * looks like a token\n\t\t */", "depth": 2, "reading_ease": 83.66, "reading_grade": 4.8, "line": 328}, "comment_text": "/*\n\t\t * keep checking more lines until we find something that\n\t\t * looks like a token\n\t\t */", "comment_tokens": ["keep", "checking", "more", "lines", "until", "we", "find", "something", "that", "looks", "like", "a", "token"], "ccode": ["\n", "static int read_token_from_file(char *filename, struct securid_token *t)\n", "{\n", "\tchar buf[65536], *p;\n", "\tint rc = ERR_BAD_LEN;\n", "\tFILE *f;\n", "\tsize_t len;\n", "\n", "\tf = fopen(filename, \"r\");\n", "\tif (f == NULL)\n", "\t\treturn ERR_FILE_READ;\n", "\n", "\tlen = fread(buf, 1, sizeof(buf) - 1, f);\n", "\tif (ferror(f))\n", "\t\tlen = 0;\n", "\tfclose(f);\n", "\n", "\tif (len == 0)\n", "\t\treturn ERR_FILE_READ;\n", "\tbuf[len] = 0;\n", "\n", "\tfor (p = buf; *p; ) {\n", "\t\trc = __stoken_parse_and_decode_token(p, t, 1);\n", "\n", "\t\t/*\n", "\t\t * keep checking more lines until we find something that\n", "\t\t * looks like a token\n", "\t\t */\n", "\t\tif (rc != ERR_GENERAL)\n", "\t\t\tbreak;\n", "\n", "\t\tp = strchr(p, '\\n');\n", "\t\tif (!p)\n", "\t\t\tbreak;\n", "\t\tp++;\n", "\t}\n", "\n", "\treturn rc;\n", "}\n"], "project": "libstoken-dev", "file": "common.pkl", "function": "read_token_from_file"}, {"comment_all": {"comment": "/*\n * Function: dump_hex()\n *\n * Prints a buffer in hexadecimal (mostly for debugging purposes)\n */", "depth": 0, "reading_ease": 34.93, "reading_grade": 11.1, "line": 4508}, "comment_text": "/*\n * Function: dump_hex()\n *\n * Prints a buffer in hexadecimal (mostly for debugging purposes)\n */", "comment_tokens": ["Function", ":", "dump_hex", "(", ")", "Prints", "a", "buffer", "in", "hexadecimal", "(", "mostly", "for", "debugging", "purposes", ")"], "ccode": ["\n", "\n", "\n", "/*\n", " * Function: dump_hex()\n", " *\n", " * Prints a buffer in hexadecimal (mostly for debugging purposes)\n", " */\n", "\n", "void dump_hex(void* ptr, size_t s){\n", "\tunsigned int i;\n", "\n", "\tfor(i=0; i < s; i++){\n", "\t\tprintf(\"%02x \",  *( ((uint8_t *)ptr)+i) );\n", "\t}\n", "\n", "\tputs(\"\");\n", "}\n"], "project": "ipv6toolkit", "file": "libipv6.pkl", "function": "dump_hex"}, {"comment_all": {"comment": "/**\n * gdk_x11_screen_lookup_visual:\n * @screen: (type GdkX11Screen): a #GdkScreen.\n * @xvisualid: an X Visual ID.\n *\n * Looks up the #GdkVisual for a particular screen and X Visual ID.\n *\n * Returns: (transfer none) (type GdkX11Visual): the #GdkVisual (owned by the screen\n *   object), or %NULL if the visual ID wasn\u2019t found.\n *\n * Since: 2.2\n */", "depth": 0, "reading_ease": 60.01, "reading_grade": 7.7, "line": 438}, "comment_text": "/**\n * gdk_x11_screen_lookup_visual:\n * @screen: (type GdkX11Screen): a #GdkScreen.\n * @xvisualid: an X Visual ID.\n *\n * Looks up the #GdkVisual for a particular screen and X Visual ID.\n *\n * Returns: (transfer none) (type GdkX11Visual): the #GdkVisual (owned by the screen\n *   object), or %NULL if the visual ID wasn\u2019t found.\n *\n * Since: 2.2\n */", "comment_tokens": ["gdk_x11_screen_lookup_visual", ":", "@", "screen", ":", "(", "type", "GdkX11Screen", ")", ":", "a", "#", "GdkScreen", ".", "@", "xvisualid", ":", "an", "X", "Visual", "ID", ".", "Looks", "up", "the", "#", "GdkVisual", "for", "a", "particular", "screen", "and", "X", "Visual", "ID", ".", "Returns", ":", "(", "transfer", "none", ")", "(", "type", "GdkX11Visual", ")", ":", "the", "#", "GdkVisual", "(", "owned", "by", "the", "screen", "object", ")", ",", "or", "%", "NULL", "if", "the", "visual", "ID", "wasn", "\u2019", "t", "found", ".", "Since", ":", "2.2"], "ccode": ["\n", "/**\n", " * gdk_x11_screen_lookup_visual:\n", " * @screen: (type GdkX11Screen): a #GdkScreen.\n", " * @xvisualid: an X Visual ID.\n", " *\n", " * Looks up the #GdkVisual for a particular screen and X Visual ID.\n", " *\n", " * Returns: (transfer none) (type GdkX11Visual): the #GdkVisual (owned by the screen\n", " *   object), or %NULL if the visual ID wasn\u2019t found.\n", " *\n", " * Since: 2.2\n", " */\n", "GdkVisual *\n", "gdk_x11_screen_lookup_visual (GdkScreen *screen,\n", "                              VisualID   xvisualid)\n", "{\n", "  int i;\n", "  GdkX11Screen *x11_screen;\n", "  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);\n", "  x11_screen = GDK_X11_SCREEN (screen);\n", "\n", "  for (i = 0; i < x11_screen->nvisuals; i++)\n", "    if (xvisualid == GDK_X11_VISUAL (x11_screen->visuals[i])->xvisual->visualid)\n", "      return x11_screen->visuals[i];\n", "\n", "  return NULL;\n", "}\n"], "project": "libgail-3-0", "file": "gdkvisual-x11.pkl", "function": "gdk_x11_screen_lookup_visual"}, {"comment_all": {"comment": "/*\n\t * In Kconfig, variable/function references always start with \"$(\".\n\t * Neither single-letter variables as in $A nor curly braces as in ${CC}\n\t * are supported.  '$' not followed by '(' loses its special meaning.\n\t */", "depth": 1, "reading_ease": 62.04, "reading_grade": 6.9, "line": 458}, "comment_text": "/*\n\t * In Kconfig, variable/function references always start with \"$(\".\n\t * Neither single-letter variables as in $A nor curly braces as in ${CC}\n\t * are supported.  '$' not followed by '(' loses its special meaning.\n\t */", "comment_tokens": ["In", "Kconfig", ",", "variablefunction", "references", "always", "start", "with", "``", "$", "(", "``", ".", "Neither", "single-letter", "variables", "as", "in", "$", "A", "nor", "curly", "braces", "as", "in", "$", "{", "CC", "}", "are", "supported", ".", "'", "$", "'", "not", "followed", "by", "'", "(", "'", "loses", "its", "special", "meaning", "."], "ccode": ["\n", "/*\n", " * Expand a string that follows '$'\n", " *\n", " * For example, if the input string is\n", " *     ($(FOO)$($(BAR)))$(BAZ)\n", " * this helper evaluates\n", " *     $($(FOO)$($(BAR)))\n", " * and returns a new string containing the expansion (note that the string is\n", " * recursively expanded), also advancing 'str' to point to the next character\n", " * after the corresponding closing parenthesis, in this case, *str will be\n", " *     $(BAR)\n", " */\n", "static char *expand_dollar_with_args(const char **str, int argc, char *argv[])\n", "{\n", "\tconst char *p = *str;\n", "\tconst char *q;\n", "\tint nest = 0;\n", "\n", "\t/*\n", "\t * In Kconfig, variable/function references always start with \"$(\".\n", "\t * Neither single-letter variables as in $A nor curly braces as in ${CC}\n", "\t * are supported.  '$' not followed by '(' loses its special meaning.\n", "\t */\n", "\tif (*p != '(') {\n", "\t\t*str = p;\n", "\t\treturn xstrdup(\"$\");\n", "\t}\n", "\n", "\tp++;\n", "\tq = p;\n", "\twhile (*q) {\n", "\t\tif (*q == '(') {\n", "\t\t\tnest++;\n", "\t\t} else if (*q == ')') {\n", "\t\t\tif (nest-- == 0)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\tq++;\n", "\t}\n", "\n", "\tif (!*q)\n", "\t\tpperror(\"unterminated reference to '%s': missing ')'\", p);\n", "\n", "\t/* Advance 'str' to after the expanded initial portion of the string */\n", "\t*str = q + 1;\n", "\n", "\treturn eval_clause(p, q - p, argc, argv);\n", "}\n"], "project": "linux-cloud-tools-5.11.0-43-lowlatency", "file": "preprocess.pkl", "function": "expand_dollar_with_args"}, {"comment_all": {"comment": "//  E2 = D == H && D != B && H != F ? D : E; // 010- => 0101 or 0100 => 5 or 4\n", "depth": 2, "reading_ease": 114.12, "reading_grade": -0.8, "line": 64}, "comment_text": "//  E2 = D == H && D != B && H != F ? D : E; // 010- => 0101 or 0100 => 5 or 4\n", "comment_tokens": ["E2", "=", "D", "==", "H", "&", "&", "D", "!", "=", "B", "&", "&", "H", "!", "=", "F", "?", "D", ":", "E", ";", "010-", "=", ">", "0101", "or", "0100", "=", ">", "5", "or", "4"], "ccode": ["/*\n", " * filter.c\n", " * Copyright (C) 2003 Florian Schulze <crow@icculus.org>\n", " *\n", " * This file is part of Jump 'n Bump.\n", " *\n", " * Jump 'n Bump is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * Jump 'n Bump is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n", " */\n", "\n", "/*\n", " The following scaling filter is called advancedmame2x.\n", " The implementation found here was possible because of the great ideas of\n", " Lucas Pope.\n", " */\n", "\n", "typedef unsigned char byte;\n", "static int scale2x_inited = 0;\n", "static byte lookup_map[4*16];\n", "\n", "void init_scale2x(void)\n", "{\n", "\tint i;\n", "\n", "\tif (scale2x_inited)\n", "\t\treturn;\n", "\n", "\t//-------------------------------------------------------------------------\n", "\t// scale2x takes the following source:\n", "\t// A B C\n", "\t// D E F\n", "\t// G H I\n", "\t//\n", "\t// and doubles the size of E to produce:\n", "\t// E0 E1\n", "\t// E2 E3\n", "\t//\n", "\t//  E0 = D == B && B != F && D != H ? D : E;\n", "\t//  E1 = B == F && B != D && F != H ? F : E;\n", "\t//  E2 = D == H && D != B && H != F ? D : E;\n", "\t//  E3 = H == F && D != H && B != F ? F : E;\n", "\t//\n", "\t// to make this comparison regimen faster, we encode source color\n", "\t// equivalency into a single byte with the getCode() macro\n", "\t//\n", "\t// #define getCode(b,f,h,d) ( (b == f)<<0 | (f == h)<<1 | (h == d)<<2 | (d == b)<<3 )\n", "\n", "\t// encode the scale2x conditionals into a lookup code\n", "\tfor (i=0; i<16; i++) {\n", "\t\t//  E0 = D == B && B != F && D != H ? D : E; // 10-0 => 1000 or 1010 => 8 or A\n", "\t\tlookup_map[0*16+i] = (i == 0x8 || i == 0xA) ? 0 : 1;\n", "\t\t//  E1 = B == F && B != D && F != H ? F : E; // 0-01 => 0101 or 0001 => 5 or 1\n", "\t\tlookup_map[1*16+i] = (i == 0x5 || i == 0x1) ? 2 : 1;\n", "\t\t//  E2 = D == H && D != B && H != F ? D : E; // 010- => 0101 or 0100 => 5 or 4\n", "\t\tlookup_map[2*16+i] = (i == 0x4 || i == 0x5) ? 0 : 1;\n", "\t\t//  E3 = H == F && D != H && B != F ? F : E; // -010 => 1010 or 0010 => A or 2\n", "\t\tlookup_map[3*16+i] = (i == 0xA || i == 0x2) ? 2 : 1;\n", "\t}\n", "}\n"], "project": "jumpnbump", "file": "filter.pkl", "function": "init_scale2x"}, {"comment_all": {"comment": "/* nothing to do if no data */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 659}, "comment_text": "/* nothing to do if no data */", "comment_tokens": ["nothing", "to", "do", "if", "no", "data"], "ccode": ["\n", "\n", "TA_Error\n", "TA_control_build_tree(FONT* font)\n", "{\n", "  Control* control = font->control;\n", "  control_data* control_data_head;\n", "  int emit_newline = 0;\n", "\n", "\n", "  font->control_segment_dirs_head = NULL;\n", "  font->control_segment_dirs_cur = NULL;\n", "\n", "  /* nothing to do if no data */\n", "  if (!control)\n", "  {\n", "    font->control_data_head = NULL;\n", "    font->control_data_cur = NULL;\n", "    return TA_Err_Ok;\n", "  }\n", "\n", "  control_data_head = (control_data*)malloc(sizeof (control_data));\n", "  if (!control_data_head)\n", "    return FT_Err_Out_Of_Memory;\n", "\n", "  LLRB_INIT(control_data_head);\n", "\n", "  while (control)\n", "  {\n", "    Control_Type type = control->type;\n", "    long font_idx = control->font_idx;\n", "    long glyph_idx = control->glyph_idx;\n", "    int x_shift = control->x_shift;\n", "    int y_shift = control->y_shift;\n", "    int line_number = control->line_number;\n", "\n", "    number_set_iter ppems_iter;\n", "    int ppem;\n", "\n", "\n", "    /* we don't store style information in the tree */\n", "    if (type == Control_Script_Feature_Glyphs)\n", "    {\n", "      control = control->next;\n", "      continue;\n", "    }\n", "\n", "    ppems_iter.range = control->ppems;\n", "    ppem = number_set_get_first(&ppems_iter);\n", "\n", "    /* ppem is always zero for one-point segments */\n", "    if (type == Control_Single_Point_Segment_Left\n", "        || type == Control_Single_Point_Segment_Right\n", "        || type == Control_Single_Point_Segment_None)\n", "      goto Points_Loop;\n", "\n", "    while (ppem >= 0)\n", "    {\n", "      number_set_iter points_iter;\n", "      int point_idx;\n", "\n", "\n", "    Points_Loop:\n", "      points_iter.range = control->points;\n", "      point_idx = number_set_get_first(&points_iter);\n", "\n", "      while (point_idx >= 0)\n", "      {\n", "        Node* node;\n", "        Node* val;\n", "\n", "\n", "        node = (Node*)malloc(sizeof (Node));\n", "        if (!node)\n", "          return FT_Err_Out_Of_Memory;\n", "\n", "        node->ctrl.type = type;\n", "        node->ctrl.font_idx = font_idx;\n", "        node->ctrl.glyph_idx = glyph_idx;\n", "        node->ctrl.ppem = ppem;\n", "        node->ctrl.point_idx = point_idx;\n", "        node->ctrl.x_shift = x_shift;\n", "        node->ctrl.y_shift = y_shift;\n", "        node->ctrl.line_number = line_number;\n", "\n", "        val = LLRB_INSERT(control_data, control_data_head, node);\n", "        if (val && font->debug)\n", "        {\n", "          /* entry is already present; we overwrite it */\n", "          Control d;\n", "          number_range ppems;\n", "          number_range points;\n", "\n", "          sds s;\n", "\n", "\n", "          /* construct Control entry for debugging output */\n", "          ppems.start = ppem;\n", "          ppems.end = ppem;\n", "          ppems.next = NULL;\n", "          points.start = point_idx;\n", "          points.end = point_idx;\n", "          points.next = NULL;\n", "\n", "          d.type = type;\n", "          d.font_idx = font_idx;\n", "          d.glyph_idx = glyph_idx;\n", "          d.points = &points;\n", "          d.x_shift = x_shift;\n", "          d.y_shift = y_shift;\n", "          d.ppems = &ppems;\n", "          d.next = NULL;\n", "\n", "          s = control_show_line(font, &d);\n", "          if (s)\n", "          {\n", "            fprintf(stderr, \"Control instruction `%s' (line %d)\"\n", "                            \" overwrites data from line %d.\\n\",\n", "                            s, line_number, val->ctrl.line_number);\n", "            sdsfree(s);\n", "          }\n", "\n", "          emit_newline = 1;\n", "        }\n", "        if (val)\n", "        {\n", "          val->ctrl.type = type;\n", "          val->ctrl.font_idx = font_idx;\n", "          val->ctrl.glyph_idx = glyph_idx;\n", "          val->ctrl.ppem = ppem;\n", "          val->ctrl.point_idx = point_idx;\n", "          val->ctrl.x_shift = x_shift;\n", "          val->ctrl.y_shift = y_shift;\n", "          val->ctrl.line_number = line_number;\n", "\n", "          free(node);\n", "        }\n", "\n", "        point_idx = number_set_get_next(&points_iter);\n", "      }\n", "\n", "      ppem = number_set_get_next(&ppems_iter);\n", "    }\n", "\n", "    control = control->next;\n", "  }\n", "\n", "  if (font->debug && emit_newline)\n", "    fprintf(stderr, \"\\n\");\n", "\n", "  font->control_data_head = control_data_head;\n", "  font->control_data_cur = LLRB_MIN(control_data, control_data_head);\n", "\n", "  return TA_Err_Ok;\n", "}\n"], "project": "ttfautohint", "file": "tacontrol.pkl", "function": "TA_control_build_tree"}, {"comment_all": {"comment": "// This is a highly simplisic implementation. It's good enough for matching \"Password: \", though.\n", "depth": 1, "reading_ease": 64.88, "reading_grade": 5.8, "line": 434}, "comment_text": "// This is a highly simplisic implementation. It's good enough for matching \"Password: \", though.\n", "comment_tokens": ["This", "is", "a", "highly", "simplisic", "implementation", ".", "It", "'s", "good", "enough", "for", "matching", "``", "Password", ":", "``", ",", "though", "."], "ccode": ["\n", "int match( const char *reference, const char *buffer, ssize_t bufsize, int state )\n", "{\n", "    // This is a highly simplisic implementation. It's good enough for matching \"Password: \", though.\n", "    int i;\n", "    for( i=0;reference[state]!='\\0' && i<bufsize; ++i ) {\n", "\tif( reference[state]==buffer[i] )\n", "\t    state++;\n", "\telse {\n", "\t    state=0;\n", "\t    if( reference[state]==buffer[i] )\n", "\t\tstate++;\n", "\t}\n", "    }\n", "\n", "    return state;\n", "}\n"], "project": "sshpass", "file": "main.pkl", "function": "match"}, {"comment_all": {"comment": "/* Copyright (C) 2006,2007 Daiki Ueno <ueno@unixuser.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */", "depth": 0, "reading_ease": 59.84, "reading_grade": 9.8, "line": 0}, "comment_text": "/* Copyright (C) 2006,2007 Daiki Ueno <ueno@unixuser.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */", "comment_tokens": ["Copyright", "(", "C", ")", "2006,2007", "Daiki", "Ueno", "<", "ueno", "@", "unixuser.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "St", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA"], "ccode": ["/* Copyright (C) 2006,2007 Daiki Ueno <ueno@unixuser.org>\n", "\n", "This program is free software; you can redistribute it and/or modify\n", "it under the terms of the GNU General Public License as published by\n", "the Free Software Foundation; either version 2 of the License, or\n", "(at your option) any later version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */\n", "\n", "#include <unistd.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#include <stdlib.h>\n", "#include <limits.h>\n", "#include <string.h>\n", "#include <errno.h>\n", "#include <sys/types.h>\n", "#include <stdio.h>\n", "#include <assert.h>\n", "#include \"config.h\"\n", "#include \"treil.h\"\n", "\n", "void\n", "treil_tree_free (treil_tree_t tree)\n", "{\n", "  if (tree->sibling)\n", "    treil_tree_free (tree->sibling);\n", "  if (tree->children)\n", "    treil_tree_free (tree->children);\n", "  free (tree->name);\n", "  free (tree);\n", "}\n"], "project": "treil", "file": "tree.pkl", "function": "treil_tree_free"}, {"comment_all": {"comment": "/* the default value is not stored in value, only in def */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 128}, "comment_text": "/* the default value is not stored in value, only in def */", "comment_tokens": ["the", "default", "value", "is", "not", "stored", "in", "value", ",", "only", "in", "def"], "ccode": ["\n", "int set_isvisible(set_t *set)\n", "{\n", "\t/* the default value is not stored in value, only in def */\n", "\treturn !((set->flags & SET_HIDDEN) ||\n", "\t         ((set->flags & SET_HIDDEN_DEFAULT) &&\n", "\t          (set->value == NULL)));\n", "}\n"], "project": "bitlbee-common", "file": "set.pkl", "function": "set_isvisible"}, {"comment_all": {"comment": "/* What kind of information do we want from getnameinfo()? */", "depth": 3, "reading_ease": 53.88, "reading_grade": 8.0, "line": 282}, "comment_text": "/* What kind of information do we want from getnameinfo()? */", "comment_tokens": ["What", "kind", "of", "information", "do", "we", "want", "from", "getnameinfo", "(", ")", "?"], "ccode": ["\n", "void\n", "show_name(enum type_t type)\n", "{\n", "\tstruct addrinfo *res;\n", "\tstruct addrinfo hints;\n", "\tstruct ifaddrs *ifa, *ifap;\n", "\tchar *p;\n", "\tint ret;\n", "\n", "\t/* Handle a few cases specially. */\n", "\tswitch(type)\n", "\t{\n", "\t\tcase DEFAULT: \n", "\t\t\tprintf(\"%s\\n\", localhost());\n", "\t\t\tbreak;\n", "\t\tcase SHORT:\n", "\t\t\tp = localhost();\n", "\t\t\t*(strchrnul(p, '.')) = '\\0';\n", "\t\t\tprintf(\"%s\\n\", p);\n", "\t\t\tbreak;\n", "\t\tcase NIS:\n", "\t\t\tprintf(\"%s\\n\", localdomain());\n", "\t\t\tbreak;\n", "\t\tcase NIS_DEF:\n", "\t\t\tprintf(\"%s\\n\", localnisdomain());\n", "\t\t\tbreak;\n", "\t\tcase ALL_IPS:\n", "\t\tcase ALL_FQDNS: {\n", "\t\t\tchar buf[NI_MAXHOST];\n", "\t\t\tint flags, ret, family, addrlen;\n", "\n", "\t\t\t/* What kind of information do we want from getnameinfo()? */\n", "\t\t\tflags = (type == ALL_IPS) ? NI_NUMERICHOST : NI_NAMEREQD;\n", "\n", "\t\t\tif (getifaddrs(&ifa) != 0)\n", "\t\t\t\terrx(1, \"%s\", strerror(errno));\n", "\t\t\tfor (ifap = ifa; ifap != NULL; ifap = ifap->ifa_next) {\n", "\t\t\t\t/* Skip interfaces that have no configured addresses */\n", "\t\t\t\tif (ifap->ifa_addr == NULL)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t/* Skip the loopback interface */\n", "\t\t\t\tif (ifap->ifa_flags & IFF_LOOPBACK)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t/* Skip interfaces that are not UP */\n", "\t\t\t\tif (!(ifap->ifa_flags & IFF_UP))\n", "\t\t\t\t\tcontinue;\n", "\n", "\t\t\t\t/* Only handle IPv4 and IPv6 addresses */\n", "\t\t\t\tfamily = ifap->ifa_addr->sa_family;\n", "\t\t\t\tif (family != AF_INET && family != AF_INET6)\n", "\t\t\t\t\tcontinue;\n", "\n", "\t\t\t\taddrlen = (family == AF_INET) ? sizeof(struct sockaddr_in) :\n", "\t\t\t\t\t\t\t\tsizeof(struct sockaddr_in6);\n", "\n", "\t\t\t\t/* Skip IPv6 link-local addresses */\n", "\t\t\t\tif (family == AF_INET6) {\n", "\t\t\t\t\tstruct sockaddr_in6 *sin6;\n", "\n", "\t\t\t\t\tsin6 = (struct sockaddr_in6 *)ifap->ifa_addr;\n", "\t\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) ||\n", "\t\t\t\t\t\t\tIN6_IS_ADDR_MC_LINKLOCAL(&sin6->sin6_addr))\n", "\t\t\t\t\t\tcontinue;\n", "\t\t\t\t}\n", "\n", "\t\t\t\tret = getnameinfo(ifap->ifa_addr, addrlen,\n", "\t\t\t\t\t\t  buf, sizeof(buf), NULL, 0, flags);\n", "\n", "\t\t\t\t/* Just skip addresses that cannot be translated */\n", "\t\t\t\tif (ret != 0) {\n", "\t\t\t\t    if (type != ALL_FQDNS && ret != EAI_NONAME)\n", "\t\t\t\t\terrx(1, \"%s\", gai_strerror(ret));\n", "\t\t\t\t} else\n", "\t\t\t\t\tprintf(\"%s \", buf);\n", "\t\t\t}\n", "\t\t\tprintf(\"\\n\");\n", "\t\t\tfreeifaddrs(ifa);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tdefault:\n", "\t\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n", "\t\t\thints.ai_socktype = SOCK_DGRAM;\n", "\t\t\thints.ai_flags = AI_CANONNAME;\n", "\n", "\t\t\tp = localhost();\n", "\t\t\tif ((ret = getaddrinfo(p, NULL, &hints, &res)) != 0)\n", "\t\t\t\terrx(1, \"%s\", gai_strerror(ret));\n", "\t\t\t\n", "\t\t\tp = strchr(res->ai_canonname, '.');\n", "\n", "\t\t\tswitch (type) {\n", "\t\t\tcase ALIAS: {\n", "\t\t\t\tstruct hostent *hp;\n", "\t\t\t\tint i;\n", "\n", "\t\t\t\tif ((hp = gethostbyname(localhost())) == NULL)\n", "\t\t\t\t\terrx(1, \"%s\", hstrerror(h_errno));\n", "\n", "\t\t\t\tfor (i = 0; hp->h_aliases[i]; i++) {\n", "\t\t\t\t\tif (i > 0)\n", "\t\t\t\t\t\tprintf(\" \");\n", "\t\t\t\t\tprintf(\"%s\", hp->h_aliases[i]);\n", "\t\t\t\t}\n", "\t\t\t\tprintf(\"\\n\");\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tcase IP: {\n", "\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n", "\t\t\t\tint ret;\n", "\n", "\t\t\t\tstruct addrinfo *walk;\n", "\n", "\t\t\t\tfor (walk = res; walk != NULL; walk = walk->ai_next) {\n", "\t\t\t\t\tif ((ret = getnameinfo(walk->ai_addr, walk->ai_addrlen,\n", "\t\t\t\t\t\t\t\tbuf, sizeof(buf), NULL, 0,\n", "\t\t\t\t\t\t\t\tNI_NUMERICHOST)) != 0)\n", "\t\t\t\t\t\terrx(1, \"%s\", gai_strerror(ret));\n", "\n", "\t\t\t\t\tif (walk != res)\n", "\t\t\t\t\t\tprintf(\" \");\n", "\n", "\t\t\t\t\tprintf(\"%s\", buf);\n", "\t\t\t\t}\n", "\t\t\t\tprintf(\"\\n\");\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tcase DNS:\n", "\t\t\t\tif (p != NULL)\n", "\t\t\t\t\tprintf(\"%s\\n\", ++p);\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase FQDN:\n", "\t\t\t\tprintf(\"%s\\n\", res->ai_canonname);\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tdefault:\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t}\n", "}\n"], "project": "hostname", "file": "hostname.pkl", "function": "show_name"}, {"comment_all": {"comment": "// Also clear all objects (with the exception of coins + diamonds if this isn't a new level).\n", "depth": 1, "reading_ease": 63.7, "reading_grade": 8.4, "line": 1844}, "comment_text": "// Anything that can be set by choosenumbers() needs to be set to a default value here.\n// Also clear all objects (with the exception of coins + diamonds if this isn't a new level).\n", "comment_tokens": ["Anything", "that", "can", "be", "set", "by", "choosenumbers", "(", ")", "needs", "to", "be", "set", "to", "a", "default", "value", "here", ".", "Also", "clear", "all", "objects", "(", "with", "the", "exception", "of", "coins", "+", "diamonds", "if", "this", "is", "n't", "a", "new", "level", ")", "."], "ccode": ["\n", "///////////////////////////////////////////////////////////////////////////////////\n", "\n", "void blanklevel (void)\n", "{\n", "   int n;\n", "   \n", "   // Anything that can be set by choosenumbers() needs to be set to a default value here.\n", "   // Also clear all objects (with the exception of coins + diamonds if this isn't a new level).\n", "\n", "   lightningcheck = LIGHTNINGCHECK_DEFAULT;\n", "   lightningy = START_LIGHTNING_Y;\n", "   \n", "   levelinfo.fastlightningy = DEFAULT_FASTLIGHTNINGY;\n", "   levelinfo.fastlightningcheck = FASTLIGHTNINGCHECK_DEFAULT;\n", "\n", "   if (resetmoney)\n", "   {\n", "      levelinfo.coins = 0;\n", "      for (n = 0; n < MAX_COINS; n++)\n", "      {\n", "         coin[n].exists = 0;\n", "      }\n", "   \n", "      levelinfo.diamonds = 0;\n", "      levelinfo.topdiamonds = 1;\n", "      for (n = 0; n < MAX_DIAMONDS; n++)\n", "      {\n", "         diamond[n].exists = 0;\n", "      }\n", "   }\n", "   \n", "   goodie.exists = 0;\n", "   \n", "   for (n = 0; n < MAX_ENEMYSHOTS; n++)\n", "   {\n", "      enemyshot[n].exists = 0;\n", "   }\n", "   \n", "   for (n = 0; n < MAX_FRIENDLYSHOTS; n++)\n", "   {\n", "      friendlyshot[n].exists = 0;\n", "   }\n", "   \n", "   for (n = 0; n < ENEMYTYPES; n++)\n", "   {\n", "      levelinfo.enemycount[n] = 0;\n", "   }\n", "   for (n = 0; n < MAX_ENEMIES; n++)\n", "   {\n", "      enemy[n].exists = 0;\n", "   }\n", "   \n", "   levelinfo.scrollerspeedx = 1;\n", "   levelinfo.scrolleroffset = SPRITE_SIZE;\n", "   \n", "   levelinfo.diverhoverlevel = SPRITE_SIZE + (SPRITE_SIZE / 4);\n", "   levelinfo.divespeedy = DIVE_SPEEDY_DEFAULT;\n", "   levelinfo.divespeedx = DIVE_SPEEDX_DEFAULT;\n", "   \n", "   levelinfo.bomberhoverlevel = (SPRITE_SIZE * 2) + (SPRITE_SIZE / 4);\n", "   levelinfo.bombspeed = BOMB_SPEED_DEFAULT;\n", "   \n", "   levelinfo.roamerminspeed = ROAMER_MIN_SPEED_DEFAULT;\n", "   levelinfo.roamermaxspeed = ROAMER_MAX_SPEED_DEFAULT;\n", "\n", "   levelinfo.brownianmaxspeed = BROWNIAN_MAX_SPEED_DEFAULT;\n", "   \n", "   levelinfo.guardianaccels = 0;\n", "   \n", "   levelinfo.gunnershootprob = GUNNER_SHOOT_PROB_DEFAULT;\n", "   levelinfo.enemyshotbasespeed = ENEMY_SHOT_SPEED_DEFAULT;\n", "   \n", "   levelinfo.electrasflag = 0;\n", "   levelinfo.electraoffset = ELECTRA_OFFSET_DEFAULT;\n", "   \n", "   levelinfo.snipersflag = 0;\n", "   \n", "   levelinfo.dropperhoveroffset = SPRITE_SIZE;\n", "   levelinfo.dropperspeedy = DROPPER_SPEEDY_DEFAULT;\n", "   \n", "   for (n = 0; n < POWERUPTYPES; n++)\n", "   {\n", "      levelinfo.powerup_prob[n] = BASEPOWERUPPROB;\n", "   }\n", "   \n", "   return;\n", "}\n"], "project": "komi", "file": "komi.pkl", "function": "blanklevel"}, {"comment_all": {"comment": "//const char args_doc[]=\"ARG1 ARG2\";\n", "depth": 0, "reading_ease": 50.5, "reading_grade": 7.2, "line": 57}, "comment_text": "//const char args_doc[]=\"ARG1 ARG2\";\n", "comment_tokens": ["const", "char", "args_doc", "[", "]", "=", "''", "ARG1", "ARG2", "''", ";"], "ccode": ["\n", "static FILE *fout;\n", "\n", "//const char args_doc[]=\"ARG1 ARG2\";\n", "\n", "static error_t parse_opt (int key, char *arg, struct argp_state *state)\n", "{\n", "\tswitch (key) {\n", "\tcase 'a':\n", "\t\taudio++;\n", "\t\tbreak;\n", "\tcase 'r':\n", "\t\tuse_mmap=0;\n", "\t\tbreak;\n", "\tcase 'v':\n", "\t\tdebug++;\n", "\t\tbreak;\n", "\tcase 'd':\n", "\t\tdevicename=arg;\n", "\t\tbreak;\n", "\tcase 'i':\n", "\tcase 'o':\n", "\t\tif (mode!=NORMAL) {\n", "\t\t\targp_error(state,\"You can't use input/output options simultaneously.\\n\");\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tif (key=='i')\n", "\t\t\tmode=INPUT;\n", "\t\telse\n", "\t\t\tmode=OUTPUT;\n", "\n", "\t\tfilename=arg;\n", "\t\tbreak;\n", "\tcase 'f':\n", "\t\tfreq_mhz=atof(arg);\n", "\t\tbreak;\n", "\tcase 'n':\n", "\t\tnbufs=atoi(arg);\n", "\t\tif  (nbufs<2)\n", "\t\t\tnbufs=2;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\treturn ARGP_ERR_UNKNOWN;\n", "\t}\n", "\treturn 0;\n", "}\n"], "project": "libv4l2rds0", "file": "decode_tm6000.pkl", "function": "parse_opt"}, {"comment_all": {"comment": "/*\n * get_pos:\n *      Get the position from the pos file, if there is one.  If not,\n *      return a random number.\n */", "depth": 0, "reading_ease": 87.72, "reading_grade": 3.3, "line": 143}, "comment_text": "/*\n * get_pos:\n *      Get the position from the pos file, if there is one.  If not,\n *      return a random number.\n */", "comment_tokens": ["get_pos", ":", "Get", "the", "position", "from", "the", "pos", "file", ",", "if", "there", "is", "one", ".", "If", "not", ",", "return", "a", "random", "number", "."], "ccode": ["\n", "/*\n", " * get_pos:\n", " *      Get the position from the pos file, if there is one.  If not,\n", " *      return a random number.\n", " */\n", "void get_pos(STRFILE * fp)\n", "{\n", "    pos = random() % fp->str_numstr;\n", "    if (++(pos) >= fp->str_numstr)\n", "\tpos -= fp->str_numstr;\n", "}\n"], "project": "fortunes-es", "file": "randstr.pkl", "function": "get_pos"}, {"comment_all": {"comment": "/*\n * NAME:\tcrc->compute()\n * DESCRIPTION:\tcalculate CRC-32 value (ISO 3309)\n */", "depth": 0, "reading_ease": 21.06, "reading_grade": 12.3, "line": 105}, "comment_text": "/*\n * NAME:\tcrc->compute()\n * DESCRIPTION:\tcalculate CRC-32 value (ISO 3309)\n */", "comment_tokens": ["NAME", ":", "crc-", ">", "compute", "(", ")", "DESCRIPTION", ":", "calculate", "CRC-32", "value", "(", "ISO", "3309", ")"], "ccode": ["\n", "/*\n", " * NAME:\tcrc->compute()\n", " * DESCRIPTION:\tcalculate CRC-32 value (ISO 3309)\n", " */\n", "unsigned long id3_crc_compute(id3_byte_t const *data, id3_length_t length)\n", "{\n", "  register unsigned long crc;\n", "\n", "  for (crc = 0xffffffffL; length >= 8; length -= 8) {\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "    crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  }\n", "\n", "  switch (length) {\n", "  case 7: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 6: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 5: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 4: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 3: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 2: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 1: crc = crc_table[(crc ^ *data++) & 0xff] ^ (crc >> 8);\n", "  case 0: break;\n", "  }\n", "\n", "  return crc ^ 0xffffffffL;\n", "}\n"], "project": "libid3tag0-dev", "file": "crc.pkl", "function": "id3_crc_compute"}, {"comment_all": {"comment": "/* Only writes are fully protected from overlaps with other writes.\n\t\t * Reads may overlap with concurrent writes to some degree.\n\t\t * Therefore we check reads only for backslips in time\n\t\t * (which never should happen).\n\t\t */", "depth": 2, "reading_ease": 69.07, "reading_grade": 6.3, "line": 660}, "comment_text": "/* Only writes are fully protected from overlaps with other writes.\n\t\t * Reads may overlap with concurrent writes to some degree.\n\t\t * Therefore we check reads only for backslips in time\n\t\t * (which never should happen).\n\t\t */", "comment_tokens": ["Only", "writes", "are", "fully", "protected", "from", "overlaps", "with", "other", "writes", ".", "Reads", "may", "overlap", "with", "concurrent", "writes", "to", "some", "degree", ".", "Therefore", "we", "check", "reads", "only", "for", "backslips", "in", "time", "(", "which", "never", "should", "happen", ")", "."], "ccode": ["\n", "///////////////////////////////////////////////////////////////////////\n", "\n", "// infrastructure for verify mode\n", "\n", "static\n", "void check_tags(struct request *rq, void *buffer, int len, int do_write)\n", "{\n", "\tint i;\n", "\tchar *mode = do_write ? \"write\" : \"read\";\n", "\tif (!verify_mode || !rq->old_version)\n", "\t\treturn;\n", "\tfor (i = 0; i < len; i += 512) {\n", "\t\tstruct verify_tag *tag = buffer+i;\n", "\t\tif (!rq->old_version[i/512]) { // version not yet valid\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\tif (dry_run)\n", "\t\t\tcontinue;\n", "\t\tif (tag->tag_start != start_stamp.tv_sec) {\n", "\t\t\tprintf(\"VERIFY ERROR (%s): bad start tag at sector %lld+%d (tag %lld != [expected] %ld)\\n\", mode, rq->sector, i/512, tag->tag_start, start_stamp.tv_sec);\n", "\t\t\tflush_stdout();\n", "\t\t\trq->verify_errors++;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t\t/* Only writes are fully protected from overlaps with other writes.\n", "\t\t * Reads may overlap with concurrent writes to some degree.\n", "\t\t * Therefore we check reads only for backslips in time\n", "\t\t * (which never should happen).\n", "\t\t */\n", "\t\tif ((do_write && tag->tag_write_seqnr != rq->old_version[i/512]) ||\n", "\t\t   tag->tag_write_seqnr < rq->old_version[i/512]) {\n", "\t\t\tprintf(\"VERIFY ERROR (%s): data version mismatch at sector %lld+%d (seqnr %u != [expected] %u)\\n\", mode, rq->sector, i/512, tag->tag_write_seqnr, rq->old_version[i/512]);\n", "\t\t\tflush_stdout();\n", "\t\t\trq->verify_errors++;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\t}\n", "}\n"], "project": "blkreplay", "file": "blkreplay.pkl", "function": "check_tags"}, {"comment_all": {"comment": "/* cdb_seq.c: sequential record retrieval routines\n *\n * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n * Public domain.\n */", "depth": 0, "reading_ease": 52.19, "reading_grade": 10.7, "line": 0}, "comment_text": "/* cdb_seq.c: sequential record retrieval routines\n *\n * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n * Public domain.\n */", "comment_tokens": ["cdb_seq.c", ":", "sequential", "record", "retrieval", "routines", "This", "file", "is", "a", "part", "of", "tinycdb", "package", "by", "Michael", "Tokarev", ",", "mjt", "@", "corpit.ru", ".", "Public", "domain", "."], "ccode": ["/* cdb_seq.c: sequential record retrieval routines\n", " *\n", " * This file is a part of tinycdb package by Michael Tokarev, mjt@corpit.ru.\n", " * Public domain.\n", " */\n", "\n", "#include \"cdb_int.h\"\n", "\n", "int\n", "cdb_seqnext(unsigned *cptr, struct cdb *cdbp) {\n", "  unsigned klen, vlen;\n", "  unsigned pos = *cptr;\n", "  unsigned dend = cdbp->cdb_dend;\n", "  const unsigned char *mem = cdbp->cdb_mem;\n", "  if (pos > dend - 8)\n", "    return 0;\n", "  klen = cdb_unpack(mem + pos);\n", "  vlen = cdb_unpack(mem + pos + 4);\n", "  pos += 8;\n", "  if (dend - klen < pos || dend - vlen < pos + klen)\n", "    return errno = EPROTO, -1;\n", "  cdbp->cdb_kpos = pos;\n", "  cdbp->cdb_klen = klen;\n", "  cdbp->cdb_vpos = pos + klen;\n", "  cdbp->cdb_vlen = vlen;\n", "  *cptr = pos + klen + vlen;\n", "  return 1;\n", "}\n"], "project": "libcdb-dev", "file": "cdb_seq.pkl", "function": "cdb_seqnext"}, {"comment_all": {"comment": "/* Compile with: gcc -g -c -Wall foo-v0.c  */", "depth": 0, "reading_ease": 106.67, "reading_grade": 0.1, "line": 0}, "comment_text": "/* Compile with: gcc -g -c -Wall foo-v0.c  */", "comment_tokens": ["Compile", "with", ":", "gcc", "-g", "-c", "-Wall", "foo-v0.c"], "ccode": ["/* Compile with: gcc -g -c -Wall foo-v0.c  */\n", "\n", "void\n", "to_erase()\n", "{\n", "}\n"], "project": "abigail-tools", "file": "test2-filtered-removed-fns-v0.pkl", "function": "to_erase"}, {"comment_all": {"comment": "/* fflush() is undefined for input streams by ISO C,\n\t * but not POSIX 2008 if you ignore ISO C overrides.\n\t * Leave it unchecked and rely on the following\n\t * functions to detect errors.\n\t */", "depth": 1, "reading_ease": 72.66, "reading_grade": 7.0, "line": 117}, "comment_text": "/* fflush() is undefined for input streams by ISO C,\n\t * but not POSIX 2008 if you ignore ISO C overrides.\n\t * Leave it unchecked and rely on the following\n\t * functions to detect errors.\n\t */", "comment_tokens": ["fflush", "(", ")", "is", "undefined", "for", "input", "streams", "by", "ISO", "C", ",", "but", "not", "POSIX", "2008", "if", "you", "ignore", "ISO", "C", "overrides", ".", "Leave", "it", "unchecked", "and", "rely", "on", "the", "following", "functions", "to", "detect", "errors", "."], "ccode": ["\n", "int\n", "fshut(FILE *fp, const char *fname)\n", "{\n", "\tint ret = 0;\n", "\n", "\t/* fflush() is undefined for input streams by ISO C,\n", "\t * but not POSIX 2008 if you ignore ISO C overrides.\n", "\t * Leave it unchecked and rely on the following\n", "\t * functions to detect errors.\n", "\t */\n", "\tfflush(fp);\n", "\n", "\tif (ferror(fp) && !ret) {\n", "\t\twarn(\"ferror '%s':\", fname);\n", "\t\tret = 1;\n", "\t}\n", "\n", "\tif (fclose(fp) && !ret) {\n", "\t\twarn(\"fclose '%s':\", fname);\n", "\t\tret = 1;\n", "\t}\n", "\n", "\treturn ret;\n", "}\n"], "project": "farbfeld", "file": "util.pkl", "function": "fshut"}, {"comment_all": {"comment": "/*\n * Convert a pam_response structure to a PamHandleObject.Response object.\n */", "depth": 0, "reading_ease": 21.06, "reading_grade": 12.3, "line": 1794}, "comment_text": "/*\n * Convert a pam_response structure to a PamHandleObject.Response object.\n */", "comment_tokens": ["Convert", "a", "pam_response", "structure", "to", "a", "PamHandleObject.Response", "object", "."], "ccode": ["\n", "/*\n", " * Convert a pam_response structure to a PamHandleObject.Response object.\n", " */\n", "static PyObject* PamHandle_conversation_2response(\n", "    PamHandleObject* pamHandle, struct pam_response* pam_response)\n", "{\n", "  PyObject*\t\tnewargs;\n", "  PyObject*  \t\tresult = 0;\n", "\n", "  newargs = Py_BuildValue(\"si\", pam_response->resp, pam_response->resp_retcode);\n", "  if (newargs == 0)\n", "    goto error_exit;\n", "  result = pamHandle->response->tp_new(pamHandle->response, newargs, 0);\n", "  if (result == 0)\n", "    goto error_exit;\n", "\n", "error_exit:\n", "  py_xdecref(newargs);\n", "  return result;\n", "}\n"], "project": "libpam-python", "file": "pam_python.pkl", "function": "PamHandle_conversation_2response"}, {"comment_all": {"comment": "/* address=0xc000 | crc=0x1b */", "depth": 2, "reading_ease": -6.7, "reading_grade": 14.7, "line": 36}, "comment_text": "/* T=0x23, R=0x01 */\n/* PIF_CMD_PAK_WRITE */\n/* address=0xc000 | crc=0x1b */\n", "comment_tokens": ["T=0x23", ",", "R=0x01", "PIF_CMD_PAK_WRITE", "address=0xc000", "|", "crc=0x1b"], "ccode": ["/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n", " *   Mupen64plus - rumble_via_input_plugin.c                               *\n", " *   Mupen64Plus homepage: http://code.google.com/p/mupen64plus/           *\n", " *   Copyright (C) 2014 Bobby Smiles                                       *\n", " *                                                                         *\n", " *   This program is free software; you can redistribute it and/or modify  *\n", " *   it under the terms of the GNU General Public License as published by  *\n", " *   the Free Software Foundation; either version 2 of the License, or     *\n", " *   (at your option) any later version.                                   *\n", " *                                                                         *\n", " *   This program is distributed in the hope that it will be useful,       *\n", " *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n", " *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n", " *   GNU General Public License for more details.                          *\n", " *                                                                         *\n", " *   You should have received a copy of the GNU General Public License     *\n", " *   along with this program; if not, write to the                         *\n", " *   Free Software Foundation, Inc.,                                       *\n", " *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *\n", " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "\n", "#include \"rumble_via_input_plugin.h\"\n", "#include \"plugin.h\"\n", "\n", "#include \"si/rumblepak.h\"\n", "\n", "#include <string.h>\n", "\n", "void rvip_rumble(void* opaque, enum rumble_action action)\n", "{\n", "    int channel = *(int*)opaque;\n", "\n", "    static const uint8_t rumble_cmd_header[] =\n", "    {\n", "        0x23, 0x01, /* T=0x23, R=0x01 */\n", "        0x03,       /* PIF_CMD_PAK_WRITE */\n", "        0xc0, 0x1b, /* address=0xc000 | crc=0x1b */\n", "    };\n", "\n", "    uint8_t cmd[0x26];\n", "\n", "    uint8_t rumble_data = (action == RUMBLE_START)\n", "        ? 0x01\n", "        : 0x00;\n", "\n", "    /* build rumble command */\n", "    memcpy(cmd, rumble_cmd_header, 5);\n", "    memset(cmd + 5, rumble_data, 0x20);\n", "    cmd[0x25] = 0; /* dummy data CRC */\n", "\n", "    if (input.controllerCommand)\n", "        input.controllerCommand(channel, cmd);\n", "}\n"], "project": "libretro-mupen64plus", "file": "rumble_via_input_plugin.pkl", "function": "rvip_rumble"}, {"comment_all": {"comment": "// print the data as a hex-list, without the translation into ascii behind it\n", "depth": 0, "reading_ease": 66.74, "reading_grade": 7.2, "line": 277}, "comment_text": "// print the data as a hex-list, without the translation into ascii behind it\n", "comment_tokens": ["print", "the", "data", "as", "a", "hex-list", ",", "without", "the", "translation", "into", "ascii", "behind", "it"], "ccode": ["\n", "// print the data as a hex-list, without the translation into ascii behind it\n", "void printHex(u_char *data, int len) {\n", "\tint i, j;\n", "\n", "\tfor (i = 0; i <= len / 8; i++) {\n", "\t\tfor (j = 0; j < 8; j++) {\n", "\t\t\tif (i * 8 + j >= len) break;\n", "\t\t\tprintf(\"%02x\", data[i * 8 + j]);\n", "\t\t}\n", "\t\tif (i * 8 + j < len) printf(\"\\n\\t\\t\\t\\t\\t    \");\n", "\t}\n", "}\n"], "project": "dhcpdump", "file": "dhcpdump.pkl", "function": "printHex"}, {"comment_all": {"comment": "/*\n * Copyright 2017 Bruno Haible <bruno@clisp.org>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */", "depth": 0, "reading_ease": 53.92, "reading_grade": 10.0, "line": 14}, "comment_text": "/*\n * Copyright 2017 Bruno Haible <bruno@clisp.org>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */", "comment_tokens": ["Copyright", "2017", "Bruno", "Haible", "<", "bruno", "@", "clisp.org", ">", "This", "program", "is", "free", "software", ":", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ".", "If", "not", ",", "see", "<", "https", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", " * Copyright 2017 Bruno Haible <bruno@clisp.org>\n", " *\n", " * This program is free software: you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include \"config.h\"\n", "\n", "#include \"avcall-internal.h\"\n", "\n", "/* This is the implementation of the library API.\n", "   The symbols that the linker sees are all prefixed with 'avcall_',\n", "   to avoid potential collisions with other libraries. */\n", "\n", "int avcall_overflown (av_alist* list)\n", "{\n", "  return _av_overflown(AV_LIST_INNER(list));\n", "}\n"], "project": "libffcall1-dev", "file": "avcall-libapi.pkl", "function": "avcall_overflown"}, {"comment_all": {"comment": "/* Return size number of bytes in buf.  Read in new record\n    * if needed.  Check to make sure missing records with\n    * record number variable found in record header.\n\t*/", "depth": 1, "reading_ease": 87.72, "reading_grade": 3.3, "line": 299}, "comment_text": "/* Return size number of bytes in buf.  Read in new record\n    * if needed.  Check to make sure missing records with\n    * record number variable found in record header.\n\t*/", "comment_tokens": ["Return", "size", "number", "of", "bytes", "in", "buf", ".", "Read", "in", "new", "record", "if", "needed", ".", "Check", "to", "make", "sure", "missing", "records", "with", "record", "number", "variable", "found", "in", "record", "header", "."], "ccode": ["\n", "int tg_read_rec_bytes(tg_file_str *tg_file,char *buf,int size)\n", "   {\n", "   /* Return size number of bytes in buf.  Read in new record\n", "    * if needed.  Check to make sure missing records with\n", "    * record number variable found in record header.\n", "\t*/\n", "   int wsize,n;\n", "   char *wbuf;\n", "   \n", "   wsize = size/2;\n", "   wbuf = buf;\n", "   \n", "   /* Is there enough data in recbuf for request */\n", "   if((tg_file->data_ind + wsize - 1) > 2043)\n", "\t  {\n", "\t  /* No there is not enough data for this request, but before\n", "\t   * we read the next buffer, we should copy what we have into\n", "\t   * the buffer pointed to by buf.\n", "\t   */\n", "\t  if(tg_file->data_ind < 2044)\n", "\t\t {\n", "\t\t memcpy(wbuf,&(tg_file->recbuf.data[tg_file->data_ind]),\n", "\t\t\t\t(2043 - tg_file->data_ind + 1) * 2);\n", "\t\t wsize = wsize - (2043 - tg_file->data_ind + 1);\n", "\t\t wbuf = (wbuf + ((2043 - tg_file->data_ind + 1) * 2));\n", "\t\t }\n", "\t  \n", "\t  /* New record has to be read in */\n", "\t  tg_file->data_ind = 0;\n", "\t  if((n = tg_read_map_rec(tg_file)) < TG_RECSIZE)\n", "\t\t {\n", "\t\t if(n == 0)\n", "\t\t\t{\n", "\t\t\treturn(n);\n", "\t\t\t}\n", "\t\t else\n", "\t\t\t{\n", "\t\t\tfprintf(stderr,\"tg_read_map_rec: %d \\n\",n);\n", "\t\t\treturn(-1);\n", "\t\t\t}\n", "\t\t }\n", "\t  if(tg_file->first_rec)\n", "\t\t {\n", "\t\t tg_file->recnum = tg_file->recbuf.rec_num;\n", "\t\t tg_file->first_rec = FALSE;\n", "\t\t }\n", "\t  else\n", "\t\t {\n", "\t\t if((tg_file->recnum + 1) != tg_file->recbuf.rec_num)\n", "\t\t\t{\n", "\t\t\ttg_file->recnum = tg_file->recbuf.rec_num;\n", "\t\t\t/* Set index to next ray */\n", "\t\t\ttg_file->data_ind = tg_file->recbuf.first_ray - 5;\n", "\t\t\treturn(TG_REC_NOSEQ);\n", "\t\t\t}\n", "\t\t else\n", "\t\t\t{\n", "\t\t\ttg_file->recnum = tg_file->recbuf.rec_num;\n", "\t\t\t}\n", "\t\t }\t\t\t   \n", "\t  tg_file->data_ind = 0;\n", "\t  }\n", "   \n", "   memcpy(wbuf,&(tg_file->recbuf.data[tg_file->data_ind]),wsize*2);\n", "   tg_file->data_ind = tg_file->data_ind + wsize;\n", "   \n", "   return(size);\n", "   }\n"], "project": "librsl-dev", "file": "toga.pkl", "function": "tg_read_rec_bytes"}, {"comment_all": {"comment": "/* Now update the file to have the correct size. */", "depth": 3, "reading_ease": 96.18, "reading_grade": 2.1, "line": 300}, "comment_text": "/* Now update the file to have the correct size. */", "comment_tokens": ["Now", "update", "the", "file", "to", "have", "the", "correct", "size", "."], "ccode": ["\n", "/* Close the sound file. */\n", "int closeWaveFile(\n", "    waveFile file)\n", "{\n", "    FILE *soundFile = file->soundFile;\n", "    int passed = 1;\n", "\n", "    if(!file->isInput) {\n", "        if(fseek(soundFile, 4, SEEK_SET) != 0) {\n", "            fprintf(stderr, \"Failed to seek on input file.\\n\");\n", "            passed = 0;\n", "        } else {\n", "            /* Now update the file to have the correct size. */\n", "            writeInt(file, file->bytesWritten - 8);\n", "            if(file->failed) {\n", "                fprintf(stderr, \"Failed to write wave file size.\\n\");\n", "                passed = 0;\n", "            }\n", "            if(fseek(soundFile, 40, SEEK_SET) != 0) {\n", "                fprintf(stderr, \"Failed to seek on input file.\\n\");\n", "                passed = 0;\n", "            } else {\n", "                /* Now update the file to have the correct size. */\n", "                writeInt(file, file->bytesWritten - 48);\n", "                if(file->failed) {\n", "                    fprintf(stderr, \"Failed to write wave file size.\\n\");\n", "                    passed = 0;\n", "                }\n", "            }\n", "        }\n", "    }\n", "    closeFile(file);\n", "    return passed;\n", "}\n"], "project": "libsonic0", "file": "wave.pkl", "function": "closeWaveFile"}, {"comment_all": {"comment": "/* Because an empty library is not portable, our library will always contains\n   at least this member.\n*/", "depth": 0, "reading_ease": 55.24, "reading_grade": 9.5, "line": 0}, "comment_text": "/* Because an empty library is not portable, our library will always contains\n   at least this member.\n*/", "comment_tokens": ["Because", "an", "empty", "library", "is", "not", "portable", ",", "our", "library", "will", "always", "contains", "at", "least", "this", "member", "."], "ccode": ["/* Because an empty library is not portable, our library will always contains\n", "   at least this member.\n", "*/\n", " \n", "void\n", "my_null_proc(void)\n", "{\n", "\treturn;\n", "}\n"], "project": "dhcp-probe", "file": "my_null_proc.pkl", "function": "my_null_proc"}, {"comment_all": {"comment": "/* FIXME: Needed for linux/drivers/char/dsp56k.c.  Is this correct?  */", "depth": 2, "reading_ease": 42.54, "reading_grade": 8.2, "line": 56}, "comment_text": "/* FIXME: Needed for linux/drivers/char/dsp56k.c.  Is this correct?  */", "comment_tokens": ["FIXME", ":", "Needed", "for", "linuxdriverschardsp56k.c", ".", "Is", "this", "correct", "?"], "ccode": ["/*\n", " *  Copyright (C) 2008  Robert Millan\n", " *\n", " *  This program is free software: you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation, either version 3 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  This program is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License\n", " *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <stdint.h>\n", "#include <stdio.h>\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "#include <sys/types.h>\n", "\n", "int\n", "main (int argc, char *argv[])\n", "{\n", "  unsigned int offset, prev_offset = 0;\n", "  unsigned int native_value;\n", "  int fd;\n", "  uint8_t value[3];\n", "  char type;\n", "  char *line = NULL;\n", "  size_t zero = 0;\n", "\n", "  if (argc != 2)\n", "    {\n", "      fprintf (stderr, \"Usage: %s output < input\\n\", argv[0]);\n", "      exit (1);\n", "    }\n", "\n", "  fd = open (argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n", "\n", "  while (getline (&line, &zero, stdin) != -1)\n", "    {\n", "      sscanf (line, \"%c \", &type);\n", "\n", "      if (type != 'P')\n", "\tcontinue;\n", "\n", "      sscanf (line + 2, \"%x %x\\n\", &offset, &native_value);\n", "\n", "      value[0] = (native_value >> 16) & 0xff;\n", "      value[1] = (native_value >> 8) & 0xff;\n", "      value[2] = native_value & 0xff;\n", "\n", "      /* FIXME: Needed for linux/drivers/char/dsp56k.c.  Is this correct?  */\n", "      if (offset > 0x7000)\n", "        offset = prev_offset + 1;\n", "      \n", "      pwrite (fd, value, 3, (off_t) (offset * 3));\n", "\n", "      prev_offset = offset;\n", "    }\n", "\n", "  close (fd);\n", "\n", "  exit (0);\n", "}\n"], "project": "a56", "file": "a56-tobin.pkl", "function": "main"}, {"comment_all": {"comment": "/*\n * Grab the given keyboard shortcut.\n */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 820}, "comment_text": "/*\n * Grab the given keyboard shortcut.\n */", "comment_tokens": ["Grab", "the", "given", "keyboard", "shortcut", "."], "ccode": ["\n", "/*\n", " * Grab the given keyboard shortcut.\n", " */\n", "static int x_shortcut_grab(struct keyboard_shortcut *ks)\n", "{\n", "        ASSERT_OR_RET(ks->is_valid, 1);\n", "        Window root;\n", "        root = RootWindow(xctx.dpy, DefaultScreen(xctx.dpy));\n", "\n", "        x_shortcut_setup_error_handler();\n", "\n", "        if (ks->is_valid) {\n", "                XGrabKey(xctx.dpy,\n", "                         ks->code,\n", "                         ks->mask,\n", "                         root,\n", "                         true,\n", "                         GrabModeAsync,\n", "                         GrabModeAsync);\n", "                XGrabKey(xctx.dpy,\n", "                         ks->code,\n", "                         ks->mask | x_numlock_mod(),\n", "                         root,\n", "                         true,\n", "                         GrabModeAsync,\n", "                         GrabModeAsync);\n", "        }\n", "\n", "        if (x_shortcut_tear_down_error_handler()) {\n", "                LOG_W(\"Unable to grab key '%s'.\", ks->str);\n", "                ks->is_valid = false;\n", "                return 1;\n", "        }\n", "        return 0;\n", "}\n"], "project": "dunst", "file": "x.pkl", "function": "x_shortcut_grab"}, {"comment_all": {"comment": "/* Abort on C0 or C1 controls */", "depth": 2, "reading_ease": 99.23, "reading_grade": 0.9, "line": 118}, "comment_text": "/* Abort on C0 or C1 controls */", "comment_tokens": ["Abort", "on", "C0", "or", "C1", "controls"], "ccode": ["\n", "size_t tickit_utf8_ncountmore(const char *str, size_t len, TickitStringPos *pos, const TickitStringPos *limit)\n", "{\n", "  TickitStringPos here = *pos;\n", "  size_t start_bytes = pos->bytes;\n", "\n", "  str += pos->bytes;\n", "  if(len != (size_t)-1)\n", "    len -= pos->bytes;\n", "\n", "  while(len != 0 && *str) {\n", "    uint32_t cp;\n", "    int bytes = next_utf8(str, len, &cp);\n", "    if(bytes == -1)\n", "      return -1;\n", "\n", "    /* Abort on C0 or C1 controls */\n", "    if(cp < 0x20 || (cp >= 0x80 && cp < 0xa0))\n", "      return -1;\n", "\n", "    int width = mk_wcwidth(cp);\n", "    if(width == -1)\n", "      return -1;\n", "\n", "    int is_grapheme = (width > 0) ? 1 : 0;\n", "    if(is_grapheme) // Commit on the previous grapheme\n", "      *pos = here;\n", "\n", "    if(limit && limit->bytes != (size_t)-1 && here.bytes + bytes > limit->bytes)\n", "      break;\n", "    if(limit && limit->codepoints != -1 && here.codepoints + 1 > limit->codepoints)\n", "      break;\n", "    if(limit && limit->graphemes != -1 && here.graphemes + is_grapheme > limit->graphemes)\n", "      break;\n", "    if(limit && limit->columns != -1 && here.columns + width > limit->columns)\n", "      break;\n", "\n", "    str += bytes;\n", "    if(len != (size_t)-1)\n", "      len -= bytes;\n", "\n", "    here.bytes += bytes;\n", "    here.codepoints += 1;\n", "    here.graphemes += is_grapheme;\n", "    here.columns += width;\n", "  }\n", "\n", "  if(len == 0 || *str == 0) // Commit on the final grapheme\n", "    *pos = here;\n", "\n", "  return pos->bytes - start_bytes;\n", "}\n"], "project": "libtickit-dev", "file": "utf8.pkl", "function": "tickit_utf8_ncountmore"}, {"comment_all": {"comment": "/* For defined variables, += inherits the existing flavor */", "depth": 2, "reading_ease": 30.53, "reading_grade": 10.7, "line": 287}, "comment_text": "/* For defined variables, += inherits the existing flavor */", "comment_tokens": ["For", "defined", "variables", ",", "+=", "inherits", "the", "existing", "flavor"], "ccode": ["\n", "void variable_add(const char *name, const char *value,\n", "\t\t  enum variable_flavor flavor)\n", "{\n", "\tstruct variable *v;\n", "\tchar *new_value;\n", "\tbool append = false;\n", "\n", "\tv = variable_lookup(name);\n", "\tif (v) {\n", "\t\t/* For defined variables, += inherits the existing flavor */\n", "\t\tif (flavor == VAR_APPEND) {\n", "\t\t\tflavor = v->flavor;\n", "\t\t\tappend = true;\n", "\t\t} else {\n", "\t\t\tfree(v->value);\n", "\t\t}\n", "\t} else {\n", "\t\t/* For undefined variables, += assumes the recursive flavor */\n", "\t\tif (flavor == VAR_APPEND)\n", "\t\t\tflavor = VAR_RECURSIVE;\n", "\n", "\t\tv = xmalloc(sizeof(*v));\n", "\t\tv->name = xstrdup(name);\n", "\t\tv->exp_count = 0;\n", "\t\tlist_add_tail(&v->node, &variable_list);\n", "\t}\n", "\n", "\tv->flavor = flavor;\n", "\n", "\tif (flavor == VAR_SIMPLE)\n", "\t\tnew_value = expand_string(value);\n", "\telse\n", "\t\tnew_value = xstrdup(value);\n", "\n", "\tif (append) {\n", "\t\tv->value = xrealloc(v->value,\n", "\t\t\t\t    strlen(v->value) + strlen(new_value) + 2);\n", "\t\tstrcat(v->value, \" \");\n", "\t\tstrcat(v->value, new_value);\n", "\t\tfree(new_value);\n", "\t} else {\n", "\t\tv->value = new_value;\n", "\t}\n", "}\n"], "project": "linux-cloud-tools-5.8.0-59-generic", "file": "preprocess.pkl", "function": "variable_add"}, {"comment_all": {"comment": "/*! \\file\n * \\brief Parser :: Parse if-match header\n *\n * \\ingroup parser\n */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 20}, "comment_text": "/*! \\file\n * \\brief Parser :: Parse if-match header\n *\n * \\ingroup parser\n */", "comment_tokens": ["!", "\\file", "\\brief", "Parser", ":", ":", "Parse", "if-match", "header", "\\ingroup", "parser"], "ccode": ["/*\n", " * Copyright (C) 2004 Jamey Hicks, jamey dot hicks at hp dot com\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "/*! \\file\n", " * \\brief Parser :: Parse if-match header\n", " *\n", " * \\ingroup parser\n", " */\n", "\n", "#include <string.h>\n", "\n", "#include \"parse_sipifmatch.h\"\n", "#include \"../dprint.h\"\n", "#include \"parse_def.h\"\n", "#include \"../mem/mem.h\"\n", "#include \"../trim.h\"\n", "\n", "static inline char* skip_token(char* _b, int _l)\n", "{\n", "\tint i = 0;\n", "\n", "\tfor(i = 0; i < _l; i++) {\n", "\t\tswitch(_b[i]) {\n", "\t\t\tcase ' ':\n", "\t\t\tcase '\\r':\n", "\t\t\tcase '\\n':\n", "\t\t\tcase '\\t':\n", "\t\t\tcase ';':\n", "\t\t\t\treturn _b + i;\n", "\t\t}\n", "\t}\n", "\n", "\treturn _b + _l;\n", "}\n"], "project": "kamailio-ims-modules", "file": "parse_sipifmatch.pkl", "function": "skip_token"}, {"comment_all": {"comment": "/* lazy allocation of the lexer */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 292}, "comment_text": "/* lazy allocation of the lexer */", "comment_tokens": ["lazy", "allocation", "of", "the", "lexer"], "ccode": ["\n", "yajl_status\n", "yajl_parse(yajl_handle hand, const unsigned char * jsonText,\n", "           size_t jsonTextLen)\n", "{\n", "    yajl_status status;\n", "\n", "    /* lazy allocation of the lexer */\n", "    if (hand->lexer == NULL) {\n", "        hand->lexer = yajl_lex_alloc(&(hand->alloc),\n", "                                     hand->flags & yajl_allow_comments,\n", "                                     !(hand->flags & yajl_dont_validate_strings));\n", "    }\n", "\n", "    status = yajl_do_parse(hand, jsonText, jsonTextLen);\n", "    return status;\n", "}\n"], "project": "libwgdb-dev", "file": "yajl_all.pkl", "function": "yajl_parse"}, {"comment_all": {"comment": "/*\n * Get a heap-duplicated name of the shell function, for\n * use in tracing.\n */", "depth": 0, "reading_ease": 76.22, "reading_grade": 5.6, "line": 1046}, "comment_text": "/*\n * Get a heap-duplicated name of the shell function, for\n * use in tracing.\n */", "comment_tokens": ["Get", "a", "heap-duplicated", "name", "of", "the", "shell", "function", ",", "for", "use", "in", "tracing", "."], "ccode": ["\n", "/*\n", " * Get a heap-duplicated name of the shell function, for\n", " * use in tracing.\n", " */\n", "\n", "/**/\n", "mod_export char *\n", "getshfuncfile(Shfunc shf)\n", "{\n", "    if (shf->node.flags & PM_LOADDIR) {\n", "\treturn zhtricat(shf->filename, \"/\", shf->node.nam);\n", "    } else if (shf->filename) {\n", "\treturn dupstring(shf->filename);\n", "    } else {\n", "\treturn NULL;\n", "    }\n", "}\n"], "project": "zsh", "file": "hashtable.pkl", "function": "getshfuncfile"}, {"comment_all": {"comment": "/* put_byte, put one byte att current write position */", "depth": 0, "reading_ease": 71.82, "reading_grade": 5.2, "line": 488}, "comment_text": "/* put_byte, put one byte att current write position */", "comment_tokens": ["put_byte", ",", "put", "one", "byte", "att", "current", "write", "position"], "ccode": ["\n", "/* put_byte, put one byte att current write position */\n", "inline void\n", "put_byte(unsigned char byte)\n", "{\n", "    *out_buffer.write_pos = byte;\n", "}\n"], "project": "bbe", "file": "buffer.pkl", "function": "put_byte"}, {"comment_all": {"comment": "/*\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/", "depth": 0, "reading_ease": 52.23, "reading_grade": 12.8, "line": 0}, "comment_text": "/*\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/", "comment_tokens": ["This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/*\n", "This program is free software; you can redistribute it and/or modify\n", "it under the terms of the GNU General Public License as published by\n", "the Free Software Foundation; either version 2, or (at your option)\n", "any later version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n", "*/\n", "\n", "#include <glib.h>\n", "#include <gtk/gtk.h>\n", "#include \"main.h\"\n", "#include \"stock.h\"\n", "#include \"theme_sel.h\"\n", "#include \"font_sel.h\"\n", "#include \"preview_pane.h\"\n", "#include \"about_dialog.h\"\n", "\n", "static void about_clicked(GtkWidget *widget, gpointer u)\n", "{\n", "\tshow_about_dialog();\n", "}\n"], "project": "gtk-chtheme", "file": "mainwin.pkl", "function": "about_clicked"}, {"comment_all": {"comment": "/*\n * psx_posix_syscall_actor performs the system call on the targeted\n * thread and decreases the outstanding syscall counter.\n */", "depth": 0, "reading_ease": 47.79, "reading_grade": 10.3, "line": 83}, "comment_text": "/*\n * psx_posix_syscall_actor performs the system call on the targeted\n * thread and decreases the outstanding syscall counter.\n */", "comment_tokens": ["psx_posix_syscall_actor", "performs", "the", "system", "call", "on", "the", "targeted", "thread", "and", "decreases", "the", "outstanding", "syscall", "counter", "."], "ccode": ["\n", "/*\n", " * psx_posix_syscall_actor performs the system call on the targeted\n", " * thread and decreases the outstanding syscall counter.\n", " */\n", "static void psx_posix_syscall_actor(int signum, siginfo_t *info, void *ignore) {\n", "    /* bail early if this isn't something we recognize */\n", "    if (signum != psx_tracker.psx_sig || !psx_tracker.cmd.active ||\n", "\tinfo == NULL || info->si_code != SI_TKILL || info->si_pid != getpid()) {\n", "\treturn;\n", "    }\n", "\n", "    if (!psx_tracker.cmd.six) {\n", "\t(void) syscall(psx_tracker.cmd.syscall_nr,\n", "\t\t       psx_tracker.cmd.arg1,\n", "\t\t       psx_tracker.cmd.arg2,\n", "\t\t       psx_tracker.cmd.arg3);\n", "    } else {\n", "\t(void) syscall(psx_tracker.cmd.syscall_nr,\n", "\t\t       psx_tracker.cmd.arg1,\n", "\t\t       psx_tracker.cmd.arg2,\n", "\t\t       psx_tracker.cmd.arg3,\n", "\t\t       psx_tracker.cmd.arg4,\n", "\t\t       psx_tracker.cmd.arg5,\n", "\t\t       psx_tracker.cmd.arg6);\n", "    }\n", "\n", "    pthread_mutex_lock(&psx_tracker.state_mu);\n", "    --psx_tracker.cmd.todo;\n", "    pthread_cond_broadcast(&psx_tracker.cond);\n", "    pthread_mutex_unlock(&psx_tracker.state_mu);\n", "}\n"], "project": "libpam-cap", "file": "psx.pkl", "function": "psx_posix_syscall_actor"}, {"comment_all": {"comment": "// DECRQM == request mode, DEC origin mode\n", "depth": 4, "reading_ease": 73.85, "reading_grade": 4.5, "line": 100}, "comment_text": "// printf(\"\\033[?6n\"); // DECDSR 6 == request cursor position\n// DECRQM == request mode, DEC origin mode\n", "comment_tokens": ["printf", "(", "``", "\\033", "[", "?", "6n", "''", ")", ";", "DECDSR", "6", "==", "request", "cursor", "position", "DECRQM", "==", "request", "mode", ",", "DEC", "origin", "mode"], "ccode": ["// we want optarg\n", "#define _XOPEN_SOURCE 600\n", "\n", "#include <stdio.h>\n", "#include <unistd.h>\n", "#include <errno.h>\n", "\n", "#include \"termkey.h\"\n", "\n", "int main(int argc, char *argv[])\n", "{\n", "  TERMKEY_CHECK_VERSION;\n", "\n", "  int mouse = 0;\n", "  int mouse_proto = 0;\n", "  TermKeyFormat format = TERMKEY_FORMAT_VIM;\n", "\n", "  char buffer[50];\n", "  TermKey *tk;\n", "\n", "  int opt;\n", "  while((opt = getopt(argc, argv, \"m::p:\")) != -1) {\n", "    switch(opt) {\n", "    case 'm':\n", "      if(optarg)\n", "        mouse = atoi(optarg);\n", "      else\n", "        mouse = 1000;\n", "\n", "      break;\n", "\n", "    case 'p':\n", "      mouse_proto = atoi(optarg);\n", "      break;\n", "\n", "    default:\n", "      fprintf(stderr, \"Usage: %s [-m]\\n\", argv[0]);\n", "      return 1;\n", "    }\n", "  }\n", "\n", "  tk = termkey_new(0, TERMKEY_FLAG_SPACESYMBOL|TERMKEY_FLAG_CTRLC);\n", "\n", "  if(!tk) {\n", "    fprintf(stderr, \"Cannot allocate termkey instance\\n\");\n", "    exit(1);\n", "  }\n", "\n", "  if(termkey_get_flags(tk) & TERMKEY_FLAG_UTF8)\n", "    printf(\"Termkey in UTF-8 mode\\n\");\n", "  else if(termkey_get_flags(tk) & TERMKEY_FLAG_RAW)\n", "    printf(\"Termkey in RAW mode\\n\");\n", "\n", "  TermKeyResult ret;\n", "  TermKeyKey key;\n", "\n", "  if(mouse) {\n", "    printf(\"\\033[?%dhMouse mode active\\n\", mouse);\n", "    if(mouse_proto)\n", "      printf(\"\\033[?%dh\", mouse_proto);\n", "  }\n", "\n", "  while((ret = termkey_waitkey(tk, &key)) != TERMKEY_RES_EOF) {\n", "    if(ret == TERMKEY_RES_KEY) {\n", "      termkey_strfkey(tk, buffer, sizeof buffer, &key, format);\n", "      if(key.type == TERMKEY_TYPE_MOUSE) {\n", "        int line, col;\n", "        termkey_interpret_mouse(tk, &key, NULL, NULL, &line, &col);\n", "        printf(\"%s at line=%d, col=%d\\n\", buffer, line, col);\n", "      }\n", "      else if(key.type == TERMKEY_TYPE_POSITION) {\n", "        int line, col;\n", "        termkey_interpret_position(tk, &key, &line, &col);\n", "        printf(\"Cursor position report at line=%d, col=%d\\n\", line, col);\n", "      }\n", "      else if(key.type == TERMKEY_TYPE_MODEREPORT) {\n", "        int initial, mode, value;\n", "        termkey_interpret_modereport(tk, &key, &initial, &mode, &value);\n", "        printf(\"Mode report %s mode %d = %d\\n\", initial ? \"DEC\" : \"ANSI\", mode, value);\n", "      }\n", "      else if(key.type == TERMKEY_TYPE_UNKNOWN_CSI) {\n", "        long args[16];\n", "        size_t nargs = 16;\n", "        unsigned long command;\n", "        termkey_interpret_csi(tk, &key, args, &nargs, &command);\n", "        printf(\"Unrecognised CSI %c %ld;%ld %c%c\\n\", (char)(command >> 8), args[0], args[1], (char)(command >> 16), (char)command);\n", "      }\n", "      else {\n", "        printf(\"Key %s\\n\", buffer);\n", "      }\n", "\n", "      if(key.type == TERMKEY_TYPE_UNICODE &&\n", "         key.modifiers & TERMKEY_KEYMOD_CTRL &&\n", "         (key.code.codepoint == 'C' || key.code.codepoint == 'c'))\n", "        break;\n", "\n", "      if(key.type == TERMKEY_TYPE_UNICODE &&\n", "         key.modifiers == 0 &&\n", "         key.code.codepoint == '?') {\n", "        // printf(\"\\033[?6n\"); // DECDSR 6 == request cursor position\n", "        printf(\"\\033[?1$p\"); // DECRQM == request mode, DEC origin mode\n", "        fflush(stdout);\n", "      }\n", "    }\n", "    else if(ret == TERMKEY_RES_ERROR) {\n", "      if(errno != EINTR) {\n", "        perror(\"termkey_waitkey\");\n", "        break;\n", "      }\n", "      printf(\"Interrupted by signal\\n\");\n", "    }\n", "  }\n", "\n", "  if(mouse)\n", "    printf(\"\\033[?%dlMouse mode deactivated\\n\", mouse);\n", "\n", "  termkey_destroy(tk);\n", "}\n"], "project": "libtermkey1", "file": "demo.pkl", "function": "main"}, {"comment_all": {"comment": "/*\n\t\t\t * Take a full backup into each incremental directory.\n\t\t\t */", "depth": 2, "reading_ease": 29.52, "reading_grade": 11.1, "line": 198}, "comment_text": "/*\n\t\t\t * Take a full backup into each incremental directory.\n\t\t\t */", "comment_tokens": ["Take", "a", "full", "backup", "into", "each", "incremental", "directory", "."], "ccode": ["\n", "static int\n", "take_full_backup(WT_SESSION *session, int i)\n", "{\n", "\tWT_CURSOR *cursor;\n", "\tint j, ret;\n", "\tchar buf[1024], h[256];\n", "\tconst char *filename, *hdir;\n", "\n", "\t/*\n", "\t * First time through we take a full backup into the incremental\n", "\t * directories.  Otherwise only into the appropriate full directory.\n", "\t */\n", "\tif (i != 0) {\n", "\t\t(void)snprintf(h, sizeof(h), \"%s.%d\", home_full, i);\n", "\t\thdir = h;\n", "\t} else\n", "\t\thdir = home_incr;\n", "\tret = session->open_cursor(session, \"backup:\", NULL, NULL, &cursor);\n", "\n", "\twhile ((ret = cursor->next(cursor)) == 0) {\n", "\t\tret = cursor->get_key(cursor, &filename);\n", "\t\tif (i == 0)\n", "\t\t\t/*\n", "\t\t\t * Take a full backup into each incremental directory.\n", "\t\t\t */\n", "\t\t\tfor (j = 0; j < MAX_ITERATIONS; j++) {\n", "\t\t\t\t(void)snprintf(h, sizeof(h),\n", "\t\t\t\t    \"%s.%d\", home_incr, j);\n", "\t\t\t\t(void)snprintf(buf, sizeof(buf),\n", "\t\t\t\t    \"cp %s/%s %s/%s\",\n", "\t\t\t\t    home, filename, h, filename);\n", "\t\t\t\tret = system(buf);\n", "\t\t\t}\n", "\t\telse {\n", "\t\t\t(void)snprintf(h, sizeof(h), \"%s.%d\", home_full, i);\n", "\t\t\t(void)snprintf(buf, sizeof(buf), \"cp %s/%s %s/%s\",\n", "\t\t\t    home, filename, hdir, filename);\n", "\t\t\tret = system(buf);\n", "\t\t}\n", "\t}\n", "\tif (ret != WT_NOTFOUND)\n", "\t\tfprintf(stderr,\n", "\t\t    \"WT_CURSOR.next: %s\\n\", session->strerror(session, ret));\n", "\tret = cursor->close(cursor);\n", "\treturn (ret);\n", "}\n"], "project": "python-wiredtiger", "file": "ex_backup.pkl", "function": "take_full_backup"}, {"comment_all": {"comment": "/* Mix the two 32-bit halves as if we were on a 32-bit platform,\n       namely low 32 bits first, then high 32 bits.\n       Also, ignore final 32 bits if they are zero. */", "depth": 2, "reading_ease": 89.58, "reading_grade": 4.6, "line": 408}, "comment_text": "/* Mix the two 32-bit halves as if we were on a 32-bit platform,\n       namely low 32 bits first, then high 32 bits.\n       Also, ignore final 32 bits if they are zero. */", "comment_tokens": ["Mix", "the", "two", "32-bit", "halves", "as", "if", "we", "were", "on", "a", "32-bit", "platform", ",", "namely", "low", "32", "bits", "first", ",", "then", "high", "32", "bits", ".", "Also", ",", "ignore", "final", "32", "bits", "if", "they", "are", "zero", "."], "ccode": ["\n", "static intnat hash_nat(value v)\n", "{\n", "  bngsize len, i;\n", "  uint32_t h;\n", "\n", "  len = bng_num_digits(&Digit_val(v,0), Wosize_val(v) - 1);\n", "  h = 0;\n", "  for (i = 0; i < len; i++) {\n", "    bngdigit d = Digit_val(v, i);\n", "#ifdef ARCH_SIXTYFOUR\n", "    /* Mix the two 32-bit halves as if we were on a 32-bit platform,\n", "       namely low 32 bits first, then high 32 bits.\n", "       Also, ignore final 32 bits if they are zero. */\n", "    h = caml_hash_mix_uint32(h, (uint32_t) d);\n", "    d = d >> 32;\n", "    if (d == 0 && i + 1 == len) break;\n", "    h = caml_hash_mix_uint32(h, (uint32_t) d);\n", "#else\n", "    h = caml_hash_mix_uint32(h, d);\n", "#endif\n", "  }\n", "  return h;\n", "}\n"], "project": "libnum-ocaml", "file": "nat_stubs.pkl", "function": "hash_nat"}, {"comment_all": {"comment": "/*\n * __wt_ext_config_parser_open --\n *\tWT_EXTENSION_API->config_parser_open implementation\n */", "depth": 0, "reading_ease": -219.22, "reading_grade": 44.6, "line": 53}, "comment_text": "/*\n * __wt_ext_config_parser_open --\n *\tWT_EXTENSION_API->config_parser_open implementation\n */", "comment_tokens": ["__wt_ext_config_parser_open", "--", "WT_EXTENSION_API-", ">", "config_parser_open", "implementation"], "ccode": ["\n", "/*\n", " * __wt_ext_config_parser_open --\n", " *\tWT_EXTENSION_API->config_parser_open implementation\n", " */\n", "int\n", "__wt_ext_config_parser_open(WT_EXTENSION_API *wt_ext, WT_SESSION *wt_session,\n", "    const char *config, size_t len, WT_CONFIG_PARSER **config_parserp)\n", "{\n", "\tWT_UNUSED(wt_ext);\n", "\treturn (wiredtiger_config_parser_open(\n", "\t    wt_session, config, len, config_parserp));\n", "}\n"], "project": "libwiredtiger-java", "file": "config_ext.pkl", "function": "__wt_ext_config_parser_open"}, {"comment_all": {"comment": "/*\n * Parse a CHIP-ADDRESS command line argument and return the corresponding\n * chip address, or a negative value if the address is invalid.\n */", "depth": 0, "reading_ease": 41.7, "reading_grade": 12.7, "line": 375}, "comment_text": "/*\n * Parse a CHIP-ADDRESS command line argument and return the corresponding\n * chip address, or a negative value if the address is invalid.\n */", "comment_tokens": ["Parse", "a", "CHIP-ADDRESS", "command", "line", "argument", "and", "return", "the", "corresponding", "chip", "address", ",", "or", "a", "negative", "value", "if", "the", "address", "is", "invalid", "."], "ccode": ["\n", "/*\n", " * Parse a CHIP-ADDRESS command line argument and return the corresponding\n", " * chip address, or a negative value if the address is invalid.\n", " */\n", "int parse_i2c_address(const char *address_arg, int all_addrs)\n", "{\n", "\tlong address;\n", "\tchar *end;\n", "\tlong min_addr = 0x03;\n", "\tlong max_addr = 0x77;\n", "\n", "\taddress = strtol(address_arg, &end, 0);\n", "\tif (*end || !*address_arg) {\n", "\t\tfprintf(stderr, \"Error: Chip address is not a number!\\n\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tif (all_addrs) {\n", "\t\tmin_addr = 0x00;\n", "\t\tmax_addr = 0x7f;\n", "\t}\n", "\n", "\tif (address < min_addr || address > max_addr) {\n", "\t\tfprintf(stderr, \"Error: Chip address out of range \"\n", "\t\t\t\"(0x%02lx-0x%02lx)!\\n\", min_addr, max_addr);\n", "\t\treturn -2;\n", "\t}\n", "\n", "\treturn address;\n", "}\n"], "project": "libi2c0", "file": "i2cbusses.pkl", "function": "parse_i2c_address"}, {"comment_all": {"comment": "/* Check input data is in range of supported length */", "depth": 1, "reading_ease": 79.26, "reading_grade": 4.4, "line": 320}, "comment_text": "/* Check input data is in range of supported length */", "comment_tokens": ["Check", "input", "data", "is", "in", "range", "of", "supported", "length"], "ccode": ["\n", "\n", "void\n", "kasumi_f9_1_buffer_sse(const kasumi_key_sched_t *pCtx, const void *pBufferIn,\n", "                       const uint32_t lengthInBytes, void *pDigest)\n", "{\n", "#ifndef LINUX\n", "        DECLARE_ALIGNED(uint128_t xmm_save[10], 16);\n", "\n", "        SAVE_XMMS(xmm_save);\n", "#endif\n", "#ifdef SAFE_PARAM\n", "        /* Check for NULL pointers */\n", "        if (pCtx == NULL || pBufferIn == NULL || pDigest == NULL)\n", "                return;\n", "\n", "        /* Check input data is in range of supported length */\n", "        if (lengthInBytes == 0 || lengthInBytes > (KASUMI_MAX_LEN / CHAR_BIT))\n", "                return;\n", "#endif\n", "        kasumi_f9_1_buffer(pCtx, pBufferIn, lengthInBytes, pDigest);\n", "#ifdef SAFE_DATA\n", "        /* Clear sensitive data in registers */\n", "        CLEAR_SCRATCH_GPS();\n", "        CLEAR_SCRATCH_SIMD_REGS();\n", "#endif\n", "#ifndef LINUX\n", "        RESTORE_XMMS(xmm_save);\n", "#endif\n", "}\n"], "project": "libipsec-mb0", "file": "kasumi_sse.pkl", "function": "kasumi_f9_1_buffer_sse"}, {"comment_all": {"comment": "/**\n * compare_nodes - Node comparison function\n * @_a: The first node (a #struct file)\n * @_b: The second node (a #struct file)\n *\n * Compare the two nodes for the binary tree.\n */", "depth": 0, "reading_ease": 62.01, "reading_grade": 11.1, "line": 304}, "comment_text": "/**\n * compare_nodes - Node comparison function\n * @_a: The first node (a #struct file)\n * @_b: The second node (a #struct file)\n *\n * Compare the two nodes for the binary tree.\n */", "comment_tokens": ["compare_nodes", "-", "Node", "comparison", "function", "@", "_a", ":", "The", "first", "node", "(", "a", "#", "struct", "file", ")", "@", "_b", ":", "The", "second", "node", "(", "a", "#", "struct", "file", ")", "Compare", "the", "two", "nodes", "for", "the", "binary", "tree", "."], "ccode": ["\n", "/**\n", " * compare_nodes - Node comparison function\n", " * @_a: The first node (a #struct file)\n", " * @_b: The second node (a #struct file)\n", " *\n", " * Compare the two nodes for the binary tree.\n", " */\n", "static int compare_nodes(const void *_a, const void *_b)\n", "{\n", "    const struct file *a = _a;\n", "    const struct file *b = _b;\n", "    int diff = 0;\n", "\n", "    if (diff == 0)\n", "        diff = CMP(a->st.st_dev, b->st.st_dev);\n", "    if (diff == 0)\n", "        diff = CMP(a->st.st_size, b->st.st_size);\n", "\n", "    return diff;\n", "}\n"], "project": "hardlink", "file": "hardlink.pkl", "function": "compare_nodes"}, {"comment_all": {"comment": "/*\n                     * We are not sure what type the input is.\n                     * Hopefully this isn't a renamed detached signature...\n                     */", "depth": 5, "reading_ease": 71.82, "reading_grade": 5.2, "line": 1100}, "comment_text": "/*\n                     * We are not sure what type the input is.\n                     * Hopefully this isn't a renamed detached signature...\n                     */", "comment_tokens": ["We", "are", "not", "sure", "what", "type", "the", "input", "is", ".", "Hopefully", "this", "is", "n't", "a", "renamed", "detached", "signature", "..."], "ccode": ["\n", "\n", "\n", "\n", "/*****************************************************************************\n", " *\n", " * Function : pgpopts_build_argv\n", " *\n", " * Purpose  : Contructs an argv style array of GnuPG options out of a Pgpopts\n", " *            structure.\n", " *\n", " * Input    : pgpopts - A Pgpopts structure to build the GnuPG options from.\n", " *\n", " * Output   : An argv style vector or NULL on error.\n", " *\n", " * Errors   : On en error NULL is returned.\n", " *\n", " * Notes    : PGP 2.6 contains a lot of bugs in the command line option parsing.\n", " *            However, many tools and scripts which use PGP assume this bugs\n", " *            so we will try to simulate this PGP bugs.\n", " *\n", " *****************************************************************************/\n", "char ** pgpopts_build_argv(Pgpopts *pgpopts)\n", "{\n", "    Pgpopts\topts;\n", "    ArgvFactory\taf;\n", "    \n", "    assert(pgpopts != NULL);\n", "    \n", "    opts = *pgpopts;\t/* don't modify pgpopts */\n", "    \n", "    argv_factory_init(&af);\n", "    argv_factory_add(&af, GPG_PATH);\n", "    \n", "    if (opts.k)\n", "    {\n", "        /* key commands */\n", "        --opts.k;\n", "        \n", "        build_batchmode(&af, &opts);\n", "        build_force(&af, &opts);\n", "        build_certdepth(&af, &opts);\n", "        \n", "        if (opts.g == 1)\t\t\t/* -kg create new key */\n", "        {\n", "            argv_factory_add(&af, \"--gen-key\");\n", "            opts.g = 0;\n", "            \n", "            if (opts.args_used > 0)\n", "                fprintf(stderr, \"Info: The optional keybits argument '%s' is not used.\\n\", opts.args[0]);\n", "        }\n", "        else if (opts.x == 0 && opts.a == 1)\t/* -ka import key */\n", "        {\n", "            argv_factory_add(&af, \"--import\");\n", "            opts.a = 0;\n", "            if (!opts.f)\n", "            {\n", "                if (opts.args_used == 0)\n", "                {\n", "                    fprintf(stderr, \"Error: Keyfile required.\\n\");\n", "                    return NULL;\n", "                }\n", "                \n", "                if (opts.args_used > 1)\n", "                {\n", "                    fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                    return NULL;\n", "                }\n", "                \n", "                argv_factory_add(&af, opts.args[0]);\n", "            }\n", "            else\n", "                opts.f = 0;\t/* yes, on -kaf, PGP just ignores all arguments */\n", "        }\n", "        else if (opts.x == 1)\t\t\t/* -kx export key */\n", "        {\n", "            build_asciiarmor(&af, &opts);\n", "            argv_factory_add(&af, \"--export\");\n", "            opts.x = 0;\n", "            if (opts.args_used == 0)\n", "            {\n", "                fprintf(stderr, \"Error: User-ID required for exporting a key.\\n\");\n", "                return NULL;\n", "            }\n", "            if (opts.f)\n", "            {\n", "                opts.f = 0;\n", "                if (opts.args_used == 1)\n", "                    argv_factory_add(&af, opts.args[0]);\n", "                else\n", "                {\n", "                    fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                    return NULL;\n", "                }\n", "            }\n", "            else\n", "            {\n", "                if (opts.args_used < 2)\n", "                {\n", "                    fprintf(stderr, \"Error: File to store exported key required.\\n\");\n", "                    return NULL;\n", "                }\n", "                \n", "                if (opts.args_used > 2)\n", "                {\n", "                    fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                    return NULL;\n", "                }\n", "                \n", "                argv_factory_add(&af, \"--output\");\n", "                argv_factory_add(&af, opts.args[1]);\n", "                argv_factory_add(&af, opts.args[0]);\n", "            }\n", "        }\n", "        else if (opts.v)\n", "        {\n", "            if (opts.v >= 2)\n", "                argv_factory_add(&af, \"--verbose\");\n", "            \n", "            if (opts.c == 0)\n", "                argv_factory_add(&af, \"--list-keys\");\t/* -kv / -kvv */\n", "            else\n", "            {\n", "                argv_factory_add(&af, \"--fingerprint\");\t/* -kvc / -kvvc */\n", "                opts.c = 0;\n", "            }\n", "            \n", "            if (opts.args_used == 1)\n", "                argv_factory_add(&af, opts.args[0]);\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "        }\n", "        else if (opts.c)\t\t\t/* -kc check key signatures */\n", "        {\n", "            argv_factory_add(&af, \"--check-sigs\");\n", "            opts.c = 0;\n", "            \n", "            if (opts.args_used == 1)\n", "                argv_factory_add(&af, opts.args[0]);\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "        }\n", "        else if (opts.r == 1 && opts.s == 0)\t/* -kr delete key */\n", "        {\n", "            opts.r = 0;\n", "            argv_factory_add(&af, \"--delete-key\");\n", "            \n", "            if (opts.args_used == 0)\n", "            {\n", "                fprintf(stderr, \"Error: User ID required for deleting a key.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            argv_factory_add(&af, opts.args[0]);\n", "        }\n", "        else if (opts.r == 1 && opts.s == 1)\t/* -krs remove signature from key */\n", "        {\n", "            opts.r = 0;\n", "            opts.s = 0;\n", "            \n", "            fprintf(stderr, \"BUG: GnuPG doesn't support removing a key signature.\\n\");\n", "            return NULL;\n", "        }\n", "        else if (opts.r == 0 && opts.s == 1)\t/* -ks add signature to key */\n", "        {\n", "            opts.s = 0;\n", "            argv_factory_add(&af, \"--edit-key\");\n", "            \n", "            if (opts.args_used == 0)\n", "            {\n", "                fprintf(stderr, \"Error: User ID required for signing a key.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            argv_factory_add(&af, opts.args[0]);\n", "            argv_factory_add(&af, \"sign\");\n", "            argv_factory_add(&af, \"quit\");\n", "            \n", "        }\n", "        else if (opts.e)\t\t\t/* -ke edit key */\n", "        {\n", "            argv_factory_add(&af, \"--edit-key\");\n", "            opts.e = 0;\n", "            \n", "            if (opts.args_used == 0)\n", "            {\n", "                fprintf(stderr, \"Error: User ID required for editing a key.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            argv_factory_add(&af, opts.args[0]);\n", "        }\n", "        else if (opts.d)\t\t\t/* -kd create key revocation certificate */\n", "        {\n", "            argv_factory_add(&af, \"--gen-revoke\");\n", "            opts.d = 0;\n", "            \n", "            if (opts.args_used == 0)\n", "            {\n", "                fprintf(stderr, \"Error: User ID required for generating key revokation certificate.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            if (opts.args_used >= 2)\n", "            {\n", "                fprintf(stderr, \"BUG: Keyring argument not supported.\\n\");\n", "                return NULL;\n", "            }\n", "            \n", "            argv_factory_add(&af, opts.args[0]);\n", "        }\n", "        else\n", "        {\n", "            fprintf(stderr, \"Invalid key command option\\n\");\n", "            return NULL;\n", "        }\n", "    }\n", "    else if (opts.s==0 && opts.e==0 && opts.c==0)\n", "    {\n", "        build_batchmode(&af, &opts);\n", "        \n", "        if (opts.a || opts.asciiarmor)\t\t\t/* store ascii armored */\n", "        {\n", "            build_comment(&af, &opts);\n", "            build_compress(&af, &opts);\n", "            build_charset(&af, &opts);\n", "            build_output(&af, &opts);\n", "            argv_factory_add(&af, \"--armor\");\n", "            argv_factory_add(&af, \"--store\");\n", "            if (build_input(&af, &opts))\n", "                return NULL;\n", "        }\n", "        else\t\t\t\t\t\t/* decrypt, verify */\n", "        {\n", "            opts.d = 0;\t/* FIXME: How to handle these flags?? */\n", "            opts.p = 0;\n", "            \n", "            build_certdepth(&af, &opts);\n", "            build_keyrings(&af, &opts);\n", "            \n", "            /*\n", "             * Try to be a little bit intelligent and try to determine if the\n", "             * user would like to decrypt or verify a message a verify a\n", "             * detached signature.\n", "             */\n", "            \n", "            if (opts.args_used == 0)\n", "            {\n", "                /*\n", "                 * It's easy: Decrypt or verify a message from stdin\n", "                 */\n", "                \n", "                build_passfd(&af, &opts);\n", "                \n", "                if (opts.outputfile)\n", "                {\n", "                    argv_factory_add(&af, \"--output\");\n", "                    argv_factory_add(&af, opts.outputfile);\n", "                }\n", "                \n", "                if (opts.f)\n", "                {\n", "                    opts.f = 0;\n", "                    argv_factory_add(&af, \"--decrypt\");\n", "                }\n", "                else if (opts.stdinisterminal)\n", "                {\n", "                    fprintf(stderr, \"Error: Filename for decryption needed.\\n\");\n", "                    return NULL;\n", "                }\n", "            }\n", "            else if (opts.args_used >= 2)\n", "            {\n", "                /*\n", "                 * It's (hopefully) easy: Verify a cleartext signature. But this\n", "                 *  only works, if the user didn't made a misstake on command line\n", "                 *  options. The bad thing is, we can't check if the user made a\n", "                 *  misstake or signature verification failed...\n", "                 */\n", "                \n", "                argv_factory_add(&af, \"--verify\");\n", "                argv_factory_add(&af, opts.args[0]);\n", "                argv_factory_add(&af, opts.args[1]);\n", "            }\n", "            else\n", "            {\n", "                /*\n", "                 * It's complicated: We must try to guess if the user would like \n", "                 * to decrypt a file or verify a detached signature. This process\n", "                 * doesn't work if the detached signature doesn't end with `.sig'\n", "                 */\n", "                \n", "                char *file_base = strdup(opts.args[0]);\n", "                char *file_ext  = strrchr(file_base, '.');\n", "                \n", "                if (file_ext)\n", "                    *file_ext++ = 0;\n", "                \n", "                if (file_ext && !strcasecmp(file_ext, \"sig\"))\n", "                {\n", "                    /*\n", "                     * Yes, the user would like to check a detached signature.\n", "                     * We asume the correctly named data file will exists.\n", "                     */\n", "                    \n", "                    argv_factory_add(&af, \"--verify\");\n", "                    argv_factory_add(&af, opts.args[0]);\n", "                    argv_factory_add(&af, file_base);\n", "                }\n", "                else if(file_ext && !strcasecmp(file_ext, \"asc\"))\n", "                {\n", "                    /*\n", "                     * The given file is armored data. We try to determine the type of\n", "                     * armored data. However, this will not work correctly with PGP 2.6\n", "                     * generated data.\n", "                     */\n", "                    \n", "                    switch (guess_armor_type(opts.args[0])) \n", "                    {\n", "                        case ARMOR_TYPE_SIGNATURE:\n", "                            /*\n", "                             * Yes, a detached signature. Assume their is a file to check\n", "                             * this signature against it, without the .asc extension.\n", "                             */\n", "                            argv_factory_add(&af, \"--verify\");\n", "                            argv_factory_add(&af, opts.args[0]);\n", "                            argv_factory_add(&af, file_base);\n", "                            break;\n", "                        \n", "                        case ARMOR_TYPE_SIGNED_MESSAGE:\n", "                            /*\n", "                             * This is a clear sign message. Check the signatures.\n", "                             */\n", "                            if (opts.outputfile)\n", "                            {\n", "                                argv_factory_add(&af, \"--output\");\n", "                                argv_factory_add(&af, opts.outputfile);\n", "                            }\n", "                            if (opts.f)\n", "                            {\n", "                                opts.f = 0;\n", "                                argv_factory_add(&af, \"--decrypt\");\n", "                            }\n", "                            argv_factory_add(&af, opts.args[0]);\n", "                            break;\n", "                        \n", "                        default:\n", "                            /*\n", "                             * This armored data could be either a signed/encrypted or\n", "                             * a detached signature.\n", "                             * If a file without the extension .asc exists assume the user\n", "                             * would like to check a detached signature.\n", "                             */\n", "                            if (access(file_base, R_OK)==0)\n", "                            {\n", "                                /* Assume a detached signature */\n", "                                argv_factory_add(&af, \"--verify\");\n", "                                argv_factory_add(&af, opts.args[0]);\n", "                                argv_factory_add(&af, file_base);\n", "                            }\n", "                            else\n", "                            {\n", "                                if (opts.outputfile)\n", "                                {\n", "                                    argv_factory_add(&af, \"--output\");\n", "                                    argv_factory_add(&af, opts.outputfile);\n", "                                }\n", "                                \n", "                                if (opts.f) \n", "                                {\n", "                                    opts.f = 0;\n", "                                    argv_factory_add(&af, \"--decrypt\");\n", "                                }\n", "                                \n", "                                argv_factory_add(&af, opts.args[0]);\n", "                                \n", "                                /* FIXME: should we close stdin ??? */\n", "                            }\n", "                    }\n", "                }\n", "                else\n", "                {\n", "                    /*\n", "                     * We are not sure what type the input is.\n", "                     * Hopefully this isn't a renamed detached signature...\n", "                     */\n", "                    \n", "                    int null_fd;\n", "                    \n", "                    if (opts.outputfile)\n", "                    {\n", "                        argv_factory_add(&af, \"--output\");\n", "                        argv_factory_add(&af, opts.outputfile);\n", "                    }\n", "                    \n", "                    if (opts.f)\n", "                    {\n", "                        opts.f = 0;\n", "                        argv_factory_add(&af, \"--decrypt\");\n", "                    }\n", "                    \n", "                    argv_factory_add(&af, opts.args[0]);\n", "                    \n", "                    /*\n", "                     * Redirect stdin to /dev/null to prevent waiting for data\n", "                     * on stdin when \"decrypting\" a detached signature.\n", "                     */\n", "                    \n", "                    if ((null_fd = open(\"/dev/null\", O_RDWR)) == -1)\n", "                    {\n", "                        fprintf(stderr, \"Can't open /dev/null\\n\");\n", "                        return NULL;\n", "                    }\n", "                    close(0);\n", "                    dup2(null_fd, 0);\n", "                    close(null_fd);\n", "                }\n", "            }\n", "        }\n", "    }\n", "    else\n", "    {\n", "        int textmode = opts.t;\n", "        \n", "        build_textmode(&af, &opts);\n", "        build_asciiarmor(&af, &opts);\n", "        build_batchmode(&af, &opts);\n", "        build_force(&af, &opts);\n", "        build_comment(&af, &opts);\n", "        build_compress(&af, &opts);\n", "        build_charset(&af, &opts);\n", "        build_passfd(&af, &opts);\n", "        build_keyrings(&af, &opts);\n", "        \n", "        if (opts.c==1 && opts.e==0 && opts.s==0)\t/* encrypt symmetric */\n", "        {\n", "            opts.c = 0;\n", "            build_output(&af, &opts);\n", "            argv_factory_add(&af, \"--symmetric\");\n", "            if (build_input(&af, &opts))\n", "                return NULL;\n", "        }\n", "        else if (opts.c==0 && opts.e==1)\t\t/* encrypt asymmetric*/\n", "        {\n", "            int i;\n", "            \n", "            opts.e = 0;\n", "            build_certdepth(&af, &opts);\n", "            build_output(&af, &opts);\n", "            \n", "            for (i = !opts.f && opts.args_used != 0 ? 1 : 0; opts.args[i]; ++i)\n", "            {\n", "                argv_factory_add(&af, \"--recipient\");\n", "                argv_factory_add(&af, opts.args[i]);\n", "            }\n", "            \n", "            if (opts.encrypttoself)\n", "            {\n", "                argv_factory_add(&af, \"--encrypt-to\");\n", "                if (opts.localuserid)\n", "                    argv_factory_add(&af, opts.localuserid);\n", "                else\n", "                {\n", "                    char *id = get_defaultkey();\n", "                    if (!id)\n", "                    {\n", "                        fprintf(stderr, \"Error: Can't get default key user id.\\n\");\n", "                        return NULL;\n", "                    }\n", "                    argv_factory_add(&af, id);\n", "                }\n", "            }\n", "            \n", "            if (opts.s)\n", "            {\n", "                opts.s = 0;\n", "                build_localuser(&af, &opts);\n", "                argv_factory_add(&af, \"--sign\");\n", "            }\n", "            \n", "            argv_factory_add(&af, \"--encrypt\");\n", "            \n", "            if (build_input(&af, &opts))\n", "                return NULL;\n", "            \n", "            opts.f = 0;\n", "        }\n", "        else if (opts.c==0 && opts.e==0 && opts.s==1)\t/* sign */\n", "        {\n", "            build_localuser(&af, &opts);\n", "            build_output(&af, &opts);\n", "            \n", "            opts.s = 0; /* build_output() uses this flag too */\n", "            \n", "            if (opts.clearsign && (opts.a || opts.asciiarmor) && textmode && opts.b==0)\n", "            {\n", "                argv_factory_add(&af, \"--escape-from\");\n", "                argv_factory_add(&af, \"--clearsign\");\n", "            }\n", "            else if (opts.b==1)\t\t\t\t/* detached sign */\n", "            {\n", "                argv_factory_add(&af, \"--detach-sign\");\n", "                opts.b = 0;\n", "            }\n", "            else\n", "                argv_factory_add(&af, \"--sign\");\n", "            \n", "            if (build_input(&af, &opts))\n", "                return NULL;\n", "        }\n", "        else\t\t\t\t\t\t/* unknown commands */\n", "        {\n", "            fprintf(stderr, \"Error: Unknown command option combination.\\n\");\n", "            return NULL;\n", "        }\n", "    }\n", "    \n", "    if (check_opts_used(&opts))\n", "    {\n", "        fprintf(stderr, \"Error: Invalid options\\n\");\n", "        return NULL;\n", "    }\n", "    \n", "    return af.argv;\n", "}\n"], "project": "pgpgpg", "file": "pgpopts.pkl", "function": "pgpopts_build_argv"}, {"comment_all": {"comment": "//%p\\\" style=\\\"text-decoration: none;\\\">%s</a>\", !strncmp(curName, \"const \", 6) ? \"const \" : \"\", pc, pc->name);\n", "depth": 4, "reading_ease": 26.13, "reading_grade": 10.4, "line": 3640}, "comment_text": "//%p\\\" style=\\\"text-decoration: none;\\\">%s</a>\", !strncmp(curName, \"const \", 6) ? \"const \" : \"\", pc, pc->name);\n", "comment_tokens": ["%", "p\\", "''", "style=\\", "''", "text-decoration", ":", "none", ";", "\\", "''", ">", "%", "s", "<", "a", ">", "''", ",", "!", "strncmp", "(", "curName", ",", "``", "const", "``", ",", "6", ")", "?", "``", "const", "``", ":", "``", "''", ",", "pc", ",", "pc-", ">", "name", ")", ";"], "ccode": ["\n", "void GetTemplateString(struct __ecereNameSpace__ecere__com__Class * c, char * templateString)\n", "{\n", "struct __ecereNameSpace__ecere__com__Instance * m = ((struct __ecereNameSpace__ecere__com__Module *)(((char *)c->module + sizeof(struct __ecereNameSpace__ecere__com__Instance))))->application;\n", "const char * n = c->name;\n", "char * lt = strchr(n, '<');\n", "char * s;\n", "char ch;\n", "char curName[256];\n", "int len = 0;\n", "\n", "memcpy(templateString, n, lt - n);\n", "templateString[lt - n] = 0;\n", "strcat(templateString, \"</a>\");\n", "for(s = lt; (ch = *s); s++)\n", "{\n", "if(ch == '<' || ch == '>' || ch == ',')\n", "{\n", "if(len)\n", "{\n", "struct __ecereNameSpace__ecere__com__Class * pc;\n", "char * d = templateString + strlen(templateString);\n", "\n", "curName[len] = 0;\n", "__ecereFunction___ecereNameSpace__ecere__sys__TrimLSpaces(curName, curName);\n", "__ecereFunction___ecereNameSpace__ecere__sys__TrimRSpaces(curName, curName);\n", "pc = __ecereNameSpace__ecere__com__eSystem_FindClass(m, curName);\n", "if(pc)\n", "sprintf(d, \"%s<a href=\\\"api://%p\\\" style=\\\"text-decoration: none;\\\">%s</a>\", !strncmp(curName, \"const \", 6) ? \"const \" : \"\", pc, pc->name);\n", "else\n", "strcat(d, curName);\n", "}\n", "if(ch == '<')\n", "strcat(templateString, \"&lt;\");\n", "else if(ch == '>')\n", "strcat(templateString, \"&gt;\");\n", "else\n", "strcat(templateString, \", \");\n", "len = 0;\n", "}\n", "else if(ch == '=')\n", "{\n", "curName[len++] = ' ';\n", "curName[len++] = ch;\n", "curName[len++] = ' ';\n", "curName[0] = 0;\n", "strcat(templateString, curName);\n", "len = 0;\n", "}\n", "else\n", "curName[len++] = ch;\n", "}\n", "}\n"], "project": "ecere-dev", "file": "Documentor.pkl", "function": "GetTemplateString"}, {"comment_all": {"comment": "// Verify 'value' is a positive number\n", "depth": 1, "reading_ease": 31.55, "reading_grade": 10.4, "line": 295}, "comment_text": "// Verify 'value' is a positive number\n", "comment_tokens": ["Verify", "'value", "'", "is", "a", "positive", "number"], "ccode": ["\n", "int side_length_validator(struct cli_def *cli, const char *name, const char *value) {\n", "  // Verify 'value' is a positive number\n", "  long len;\n", "  char *endptr;\n", "  int rc = CLI_OK;\n", "\n", "  printf(\"side_length_validator called\\n\");\n", "  errno = 0;\n", "  len = strtol(value, &endptr, 10);\n", "  if ((endptr == value) || (*endptr != '\\0') || ((errno == ERANGE) && ((len == LONG_MIN) || (len == LONG_MAX))))\n", "    return CLI_ERROR;\n", "  return rc;\n", "}\n"], "project": "libcli-dev", "file": "clitest.pkl", "function": "side_length_validator"}, {"comment_all": {"comment": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  @param yyscanner The scanner object.\n */", "depth": 0, "reading_ease": 89.45, "reading_grade": 2.6, "line": 3710}, "comment_text": "/** Removes and deletes the top of the stack, if present.\n *  The next element becomes the new top.\n *  @param yyscanner The scanner object.\n */", "comment_tokens": ["Removes", "and", "deletes", "the", "top", "of", "the", "stack", ",", "if", "present", ".", "The", "next", "element", "becomes", "the", "new", "top", ".", "@", "param", "yyscanner", "The", "scanner", "object", "."], "ccode": ["\n", "/** Removes and deletes the top of the stack, if present.\n", " *  The next element becomes the new top.\n", " *  @param yyscanner The scanner object.\n", " */\n", "void yypop_buffer_state (yyscan_t yyscanner)\n", "{\n", "    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n", "\tif (!YY_CURRENT_BUFFER)\n", "\t\treturn;\n", "\n", "\tyy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);\n", "\tYY_CURRENT_BUFFER_LVALUE = NULL;\n", "\tif (yyg->yy_buffer_stack_top > 0)\n", "\t\t--yyg->yy_buffer_stack_top;\n", "\n", "\tif (YY_CURRENT_BUFFER) {\n", "\t\tyy_load_buffer_state( yyscanner );\n", "\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n", "\t}\n", "}\n"], "project": "foma-bin", "file": "lex.yy.pkl", "function": "yypop_buffer_state"}, {"comment_all": {"comment": "/*  REAL a,b;\nREAL c1,s1,s2,c2,s3,c3,s4,c4;\n REAL f0,g0,f1,g1,f2,g2,f3,g3; */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 215}, "comment_text": "/*  REAL a,b;\nREAL c1,s1,s2,c2,s3,c3,s4,c4;\n REAL f0,g0,f1,g1,f2,g2,f3,g3; */", "comment_tokens": ["REAL", "a", ",", "b", ";", "REAL", "c1", ",", "s1", ",", "s2", ",", "c2", ",", "s3", ",", "c3", ",", "s4", ",", "c4", ";", "REAL", "f0", ",", "g0", ",", "f1", ",", "g1", ",", "f2", ",", "g2", ",", "f3", ",", "g3", ";"], "ccode": ["\n", "\n", "#define SQRT2_2   0.70710678118654752440084436210484\n", "#define SQRT2   2*0.70710678118654752440084436210484\n", "\n", "void mayer_fht(REAL *fz, int n)\n", "{\n", "/*  REAL a,b;\n", "REAL c1,s1,s2,c2,s3,c3,s4,c4;\n", " REAL f0,g0,f1,g1,f2,g2,f3,g3; */\n", " int  k,k1,k2,k3,k4,kx;\n", " REAL *fi,*fn,*gi;\n", " TRIG_VARS;\n", "\n", " for (k1=1,k2=0;k1<n;k1++)\n", "    {\n", "     REAL aa;\n", "     for (k=n>>1; (!((k2^=k)&k)); k>>=1);\n", "     if (k1>k2)\n", "        {\n", "             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;\n", "        }\n", "    }\n", " for ( k=0 ; (1<<k)<n ; k++ );\n", " k  &= 1;\n", " if (k==0)\n", "    {\n", "         for (fi=fz,fn=fz+n;fi<fn;fi+=4)\n", "            {\n", "             REAL f0,f1,f2,f3;\n", "             f1     = fi[0 ]-fi[1 ];\n", "             f0     = fi[0 ]+fi[1 ];\n", "             f3     = fi[2 ]-fi[3 ];\n", "             f2     = fi[2 ]+fi[3 ];\n", "             fi[2 ] = (f0-f2);  \n", "             fi[0 ] = (f0+f2);\n", "             fi[3 ] = (f1-f3);  \n", "             fi[1 ] = (f1+f3);\n", "            }\n", "    }\n", " else\n", "    {\n", "         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)\n", "            {\n", "             REAL bs1,bc1,bs2,bc2,bs3,bc3,bs4,bc4,\n", "                bg0,bf0,bf1,bg1,bf2,bg2,bf3,bg3;\n", "             bc1     = fi[0 ] - gi[0 ];\n", "             bs1     = fi[0 ] + gi[0 ];\n", "             bc2     = fi[2 ] - gi[2 ];\n", "             bs2     = fi[2 ] + gi[2 ];\n", "             bc3     = fi[4 ] - gi[4 ];\n", "             bs3     = fi[4 ] + gi[4 ];\n", "             bc4     = fi[6 ] - gi[6 ];\n", "             bs4     = fi[6 ] + gi[6 ];\n", "             bf1     = (bs1 - bs2);     \n", "             bf0     = (bs1 + bs2);\n", "             bg1     = (bc1 - bc2);     \n", "             bg0     = (bc1 + bc2);\n", "             bf3     = (bs3 - bs4);     \n", "             bf2     = (bs3 + bs4);\n", "             bg3     = SQRT2*bc4;               \n", "             bg2     = SQRT2*bc3;\n", "             fi[4 ] = bf0 - bf2;\n", "             fi[0 ] = bf0 + bf2;\n", "             fi[6 ] = bf1 - bf3;\n", "             fi[2 ] = bf1 + bf3;\n", "             gi[4 ] = bg0 - bg2;\n", "             gi[0 ] = bg0 + bg2;\n", "             gi[6 ] = bg1 - bg3;\n", "             gi[2 ] = bg1 + bg3;\n", "            }\n", "    }\n", " if (n<16) return;\n", "\n", " do\n", "    {\n", "     REAL s1,c1;\n", "     int ii;\n", "     k  += 2;\n", "     k1  = 1  << k;\n", "     k2  = k1 << 1;\n", "     k4  = k2 << 1;\n", "     k3  = k2 + k1;\n", "     kx  = k1 >> 1;\n", "         fi  = fz;\n", "         gi  = fi + kx;\n", "         fn  = fz + n;\n", "         do\n", "            {\n", "             REAL g0,f0,f1,g1,f2,g2,f3,g3;\n", "             f1      = fi[0 ] - fi[k1];\n", "             f0      = fi[0 ] + fi[k1];\n", "             f3      = fi[k2] - fi[k3];\n", "             f2      = fi[k2] + fi[k3];\n", "             fi[k2]  = f0         - f2;\n", "             fi[0 ]  = f0         + f2;\n", "             fi[k3]  = f1         - f3;\n", "             fi[k1]  = f1         + f3;\n", "             g1      = gi[0 ] - gi[k1];\n", "             g0      = gi[0 ] + gi[k1];\n", "             g3      = SQRT2  * gi[k3];\n", "             g2      = SQRT2  * gi[k2];\n", "             gi[k2]  = g0         - g2;\n", "             gi[0 ]  = g0         + g2;\n", "             gi[k3]  = g1         - g3;\n", "             gi[k1]  = g1         + g3;\n", "             gi     += k4;\n", "             fi     += k4;\n", "            } while (fi<fn);\n", "     TRIG_INIT(k,c1,s1);\n", "     for (ii=1;ii<kx;ii++)\n", "        {\n", "         REAL c2,s2;\n", "         TRIG_NEXT(k,c1,s1);\n", "         c2 = c1*c1 - s1*s1;\n", "         s2 = 2*(c1*s1);\n", "             fn = fz + n;\n", "             fi = fz +ii;\n", "             gi = fz +k1-ii;\n", "             do\n", "                {\n", "                 REAL a,b,g0,f0,f1,g1,f2,g2,f3,g3;\n", "                 b       = s2*fi[k1] - c2*gi[k1];\n", "                 a       = c2*fi[k1] + s2*gi[k1];\n", "                 f1      = fi[0 ]    - a;\n", "                 f0      = fi[0 ]    + a;\n", "                 g1      = gi[0 ]    - b;\n", "                 g0      = gi[0 ]    + b;\n", "                 b       = s2*fi[k3] - c2*gi[k3];\n", "                 a       = c2*fi[k3] + s2*gi[k3];\n", "                 f3      = fi[k2]    - a;\n", "                 f2      = fi[k2]    + a;\n", "                 g3      = gi[k2]    - b;\n", "                 g2      = gi[k2]    + b;\n", "                 b       = s1*f2     - c1*g3;\n", "                 a       = c1*f2     + s1*g3;\n", "                 fi[k2]  = f0        - a;\n", "                 fi[0 ]  = f0        + a;\n", "                 gi[k3]  = g1        - b;\n", "                 gi[k1]  = g1        + b;\n", "                 b       = c1*g2     - s1*f3;\n", "                 a       = s1*g2     + c1*f3;\n", "                 gi[k2]  = g0        - a;\n", "                 gi[0 ]  = g0        + a;\n", "                 fi[k3]  = f1        - b;\n", "                 fi[k1]  = f1        + b;\n", "                 gi     += k4;\n", "                 fi     += k4;\n", "                } while (fi<fn);\n", "        }\n", "     TRIG_RESET(k,c1,s1);\n", "    } while (k4<n);\n", "}\n"], "project": "autotalent", "file": "mayer_fft.pkl", "function": "mayer_fht"}, {"comment_all": {"comment": "/* Requires that we hold the lock and a reference */", "depth": 1, "reading_ease": 87.72, "reading_grade": 3.3, "line": 242}, "comment_text": "/* Requires that we hold the lock and a reference */", "comment_tokens": ["Requires", "that", "we", "hold", "the", "lock", "and", "a", "reference"], "ccode": ["\n", "\n", "void\n", "bufferevent_run_readcb_(struct bufferevent *bufev, int options)\n", "{\n", "\t/* Requires that we hold the lock and a reference */\n", "\tstruct bufferevent_private *p = BEV_UPCAST(bufev);\n", "\tif (bufev->readcb == NULL)\n", "\t\treturn;\n", "\tif ((p->options|options) & BEV_OPT_DEFER_CALLBACKS) {\n", "\t\tp->readcb_pending = 1;\n", "\t\tSCHEDULE_DEFERRED(p);\n", "\t} else {\n", "\t\tbufev->readcb(bufev, bufev->cbarg);\n", "\t\tbufferevent_inbuf_wm_check(bufev);\n", "\t}\n", "}\n"], "project": "libevent-dev", "file": "bufferevent.pkl", "function": "bufferevent_run_readcb_"}, {"comment_all": {"comment": "/*\n * routine to change little endian short to host short\n */", "depth": 0, "reading_ease": 79.26, "reading_grade": 4.4, "line": 27}, "comment_text": "/*\n * routine to change little endian short to host short\n */", "comment_tokens": ["routine", "to", "change", "little", "endian", "short", "to", "host", "short"], "ccode": ["\n", "/*\n", " * routine to change little endian short to host short\n", " */\n", "short get_short(u_char *cp)\n", "{\n", "        short ret;\n", "\n", "        ret = *cp++;\n", "        ret += ((*cp++)<<8);\n", "\n", "        return ret;\n", "}\n"], "project": "dbf2mysql", "file": "endian.pkl", "function": "get_short"}, {"comment_all": {"comment": "/*\n\t\t\t\t * if AI_CANONNAME and if reverse lookup\n\t\t\t\t * fail, return ai anyway to pacify\n\t\t\t\t * calling application.\n\t\t\t\t *\n\t\t\t\t * XXX getaddrinfo() is a name->address\n\t\t\t\t * translation function, and it looks strange\n\t\t\t\t * that we do addr->name translation here.\n\t\t\t\t */", "depth": 4, "reading_ease": 55.74, "reading_grade": 9.3, "line": 378}, "comment_text": "/*\n\t\t\t\t * if AI_CANONNAME and if reverse lookup\n\t\t\t\t * fail, return ai anyway to pacify\n\t\t\t\t * calling application.\n\t\t\t\t *\n\t\t\t\t * XXX getaddrinfo() is a name->address\n\t\t\t\t * translation function, and it looks strange\n\t\t\t\t * that we do addr->name translation here.\n\t\t\t\t */", "comment_tokens": ["if", "AI_CANONNAME", "and", "if", "reverse", "lookup", "fail", ",", "return", "ai", "anyway", "to", "pacify", "calling", "application", ".", "XXX", "getaddrinfo", "(", ")", "is", "a", "name-", ">", "address", "translation", "function", ",", "and", "it", "looks", "strange", "that", "we", "do", "addr-", ">", "name", "translation", "here", "."], "ccode": ["\n", "\n", "/***************************************************************************/\n", "int getaddrinfo__compat (const char *hostname, const char *servname, const AI *hints, AI **res)\n", "{\n", "\tAI sentinel;\n", "\tAI *top = NULL;\n", "\tAI *cur;\n", "\tint i, error = 0;\n", "\tchar pton[PTON_MAX];\n", "\tAI ai;\n", "\tAI *pai;\n", "\tunsigned short port;\n", "\n", "\t/* initialize file static vars */\n", "\tsentinel.ai_next = NULL;\n", "\tcur = &sentinel;\n", "\tpai = &ai;\n", "\tpai->ai_flags = 0;\n", "\tpai->ai_family = PF_UNSPEC;\n", "\tpai->ai_socktype = ANY;\n", "\tpai->ai_protocol = ANY;\n", "\tpai->ai_addrlen = 0;\n", "\tpai->ai_canonname = NULL;\n", "\tpai->ai_addr = NULL;\n", "\tpai->ai_next = NULL;\n", "\tport = ANY;\n", "\t\n", "\tif (hostname == NULL && servname == NULL)\n", "\t\treturn EAI_NONAME;\n", "\tif (hints) {\n", "\t\t/* error check for hints */\n", "\t\tif (hints->ai_addrlen || hints->ai_canonname ||\n", "\t\t    hints->ai_addr || hints->ai_next)\n", "\t\t\tERR(EAI_BADHINTS); /* xxx */\n", "\t\tif (hints->ai_flags & ~AI_MASK)\n", "\t\t\tERR(EAI_BADFLAGS);\n", "\t\tswitch (hints->ai_family) {\n", "\t\tcase PF_UNSPEC:\n", "\t\tcase PF_INET:\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tERR(EAI_FAMILY);\n", "\t\t}\n", "\t\tmemcpy(pai, hints, sizeof(*pai));\n", "\t\tswitch (pai->ai_socktype) {\n", "\t\tcase ANY:\n", "\t\t\tswitch (pai->ai_protocol) {\n", "\t\t\tcase ANY:\n", "\t\t\t\tbreak;\n", "\t\t\tcase IPPROTO_UDP:\n", "\t\t\t\tpai->ai_socktype = SOCK_DGRAM;\n", "\t\t\t\tbreak;\n", "\t\t\tcase IPPROTO_TCP:\n", "\t\t\t\tpai->ai_socktype = SOCK_STREAM;\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "#if defined(SOCK_RAW)\n", "\t\t\t\tpai->ai_socktype = SOCK_RAW;\n", "#endif\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tbreak;\n", "#if defined(SOCK_RAW)\n", "\t\tcase SOCK_RAW:\n", "\t\t\tbreak;\n", "#endif\n", "\t\tcase SOCK_DGRAM:\n", "\t\t\tif (pai->ai_protocol != IPPROTO_UDP &&\n", "\t\t\t    pai->ai_protocol != ANY)\n", "\t\t\t\tERR(EAI_BADHINTS);\t/*xxx*/\n", "\t\t\tpai->ai_protocol = IPPROTO_UDP;\n", "\t\t\tbreak;\n", "\t\tcase SOCK_STREAM:\n", "\t\t\tif (pai->ai_protocol != IPPROTO_TCP &&\n", "\t\t\t    pai->ai_protocol != ANY)\n", "\t\t\t\tERR(EAI_BADHINTS);\t/*xxx*/\n", "\t\t\tpai->ai_protocol = IPPROTO_TCP;\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tERR(EAI_SOCKTYPE);\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\t/*\n", "\t * service port\n", "\t */\n", "\tif (servname) {\n", "\t\tif (str_isnumber(servname)) {\n", "\t\t\tif (pai->ai_socktype == ANY) {\n", "\t\t\t\t/* caller accept *ANY* socktype */\n", "\t\t\t\tpai->ai_socktype = SOCK_DGRAM;\n", "\t\t\t\tpai->ai_protocol = IPPROTO_UDP;\n", "\t\t\t}\n", "\t\t\tport = htons((unsigned short)atoi(servname));\n", "\t\t} else {\n", "\t\t\tstruct servent *sp;\n", "\t\t\tconst char *proto;\n", "\n", "\t\t\tproto = NULL;\n", "\t\t\tswitch (pai->ai_socktype) {\n", "\t\t\tcase ANY:\n", "\t\t\t\tproto = NULL;\n", "\t\t\t\tbreak;\n", "\t\t\tcase SOCK_DGRAM:\n", "\t\t\t\tproto = \"udp\";\n", "\t\t\t\tbreak;\n", "\t\t\tcase SOCK_STREAM:\n", "\t\t\t\tproto = \"tcp\";\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\tfprintf(stderr, \"panic!\\n\");\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tif ((sp = getservbyname(servname, proto)) == NULL)\n", "\t\t\t\tERR(EAI_SERVICE);\n", "\t\t\tport = sp->s_port;\n", "\t\t\tif (pai->ai_socktype == ANY) {\n", "\t\t\t\tif (strcmp(sp->s_proto, \"udp\") == 0) {\n", "\t\t\t\t\tpai->ai_socktype = SOCK_DGRAM;\n", "\t\t\t\t\tpai->ai_protocol = IPPROTO_UDP;\n", "\t\t\t\t} else if (strcmp(sp->s_proto, \"tcp\") == 0) {\n", "\t\t\t\t\tpai->ai_socktype = SOCK_STREAM;\n", "\t\t\t\t\tpai->ai_protocol = IPPROTO_TCP;\n", "\t\t\t\t} else {\n", "\t\t\t\t\tERR(EAI_PROTOCOL);\t/*xxx*/\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\t\n", "\t/*\n", "\t * hostname == NULL.\n", "\t * passive socket -> anyaddr (0.0.0.0 or ::)\n", "\t * non-passive socket -> localhost (127.0.0.1 or ::1)\n", "\t */\n", "\tif (hostname == NULL) {\n", "\t\tstruct afd *afd;\n", "\t\tint s;\n", "\n", "\t\tfor (afd = &afdl[0]; afd->a_af; afd++) {\n", "\t\t\tif (!(pai->ai_family == PF_UNSPEC\n", "\t\t\t   || pai->ai_family == afd->a_af)) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\t/*\n", "\t\t\t * filter out AFs that are not supported by the kernel\n", "\t\t\t * XXX errno?\n", "\t\t\t */\n", "\t\t\ts = socket(afd->a_af, SOCK_DGRAM, 0);\n", "\t\t\tif (s < 0)\n", "\t\t\t\tcontinue;\n", "\t\t\tclose(s);\n", "\n", "\t\t\tif (pai->ai_flags & AI_PASSIVE) {\n", "\t\t\t\tGET_AI(cur->ai_next, afd, afd->a_addrany, port);\n", "\t\t\t\t/* xxx meaningless?\n", "\t\t\t\t * GET_CANONNAME(cur->ai_next, \"anyaddr\");\n", "\t\t\t\t */\n", "\t\t\t} else {\n", "\t\t\t\tGET_AI(cur->ai_next, afd, afd->a_loopback,\n", "\t\t\t\t\tport);\n", "\t\t\t\t/* xxx meaningless?\n", "\t\t\t\t * GET_CANONNAME(cur->ai_next, \"localhost\");\n", "\t\t\t\t */\n", "\t\t\t}\n", "\t\t\tcur = cur->ai_next;\n", "\t\t}\n", "\t\ttop = sentinel.ai_next;\n", "\t\tif (top)\n", "\t\t\tgoto good;\n", "\t\telse\n", "\t\t\tERR(EAI_FAMILY);\n", "\t}\n", "\t\n", "\t/* hostname as numeric name */\n", "\tfor (i = 0; afdl[i].a_af; i++) {\n", "\t\tif (inet_pton__compat(afdl[i].a_af, hostname, pton)) {\n", "\t\t\tunsigned long v4a;\n", "\n", "\t\t\tswitch (afdl[i].a_af) {\n", "\t\t\tcase AF_INET:\n", "\t\t\t\tv4a = ((struct in_addr *)pton)->s_addr;\n", "\t\t\t\tif (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))\n", "\t\t\t\t\tpai->ai_flags &= ~AI_CANONNAME;\n", "\t\t\t\tv4a >>= IN_CLASSA_NSHIFT;\n", "\t\t\t\tif (v4a == 0 || v4a == IN_LOOPBACKNET)\n", "\t\t\t\t\tpai->ai_flags &= ~AI_CANONNAME;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\t\n", "\t\t\tif (pai->ai_family == afdl[i].a_af ||\n", "\t\t\t    pai->ai_family == PF_UNSPEC) {\n", "\t\t\t\tif (! (pai->ai_flags & AI_CANONNAME)) {\n", "\t\t\t\t\tGET_AI(top, &afdl[i], pton, port);\n", "\t\t\t\t\tgoto good;\n", "\t\t\t\t}\n", "\t\t\t\t/*\n", "\t\t\t\t * if AI_CANONNAME and if reverse lookup\n", "\t\t\t\t * fail, return ai anyway to pacify\n", "\t\t\t\t * calling application.\n", "\t\t\t\t *\n", "\t\t\t\t * XXX getaddrinfo() is a name->address\n", "\t\t\t\t * translation function, and it looks strange\n", "\t\t\t\t * that we do addr->name translation here.\n", "\t\t\t\t */\n", "\t\t\t\tget_name(pton, &afdl[i], &top, pton, pai, port);\n", "\t\t\t\tgoto good;\n", "\t\t\t} else \n", "\t\t\t\tERR(EAI_FAMILY);\t/*xxx*/\n", "\t\t}\n", "\t}\n", "\n", "\tif (pai->ai_flags & AI_NUMERICHOST)\n", "\t\tERR(EAI_NONAME);\n", "\n", "\t/* hostname as alphabetical name */\n", "\terror = get_addr(hostname, pai->ai_family, &top, pai, port);\n", "\tif (error == 0) {\n", "\t\tif (top) {\n", " good:\n", "\t\t\t*res = top;\n", "\t\t\treturn SUCCESS;\n", "\t\t} else\n", "\t\t\terror = EAI_FAIL;\n", "\t}\n", " free:\n", "\tif (top)\n", "\t\tfreeaddrinfo(top);\n", " bad:\n", "\t*res = NULL;\n", "\treturn error;\n", "}\n"], "project": "epic4", "file": "gailib.pkl", "function": "getaddrinfo__compat"}, {"comment_all": {"comment": "/* Compare two netspecs, for sorting. Comparison is done on minimum of range */", "depth": 0, "reading_ease": 56.93, "reading_grade": 6.8, "line": 293}, "comment_text": "/* Compare two netspecs, for sorting. Comparison is done on minimum of range */", "comment_tokens": ["Compare", "two", "netspecs", ",", "for", "sorting", ".", "Comparison", "is", "done", "on", "minimum", "of", "range"], "ccode": ["\n", "\n", "/* Compare two netspecs, for sorting. Comparison is done on minimum of range */\n", "int netsort(const void* a, const void* b)\n", "{\n", "\tunsigned int c1 = ((struct netspec*)a)->min;\n", "\tunsigned int c2 = ((struct netspec*)b)->min;\n", "\tif (c1 < c2) return -1;\n", "\tif (c1 > c2) return +1;\n", "\treturn 0;\n", "}\n"], "project": "grepcidr", "file": "grepcidr.pkl", "function": "netsort"}, {"comment_all": {"comment": "/* Print the test name, escaping any '#' characters it\n\t\t   might contain */", "depth": 2, "reading_ease": 69.79, "reading_grade": 6.0, "line": 119}, "comment_text": "/* Print the test name, escaping any '#' characters it\n\t\t   might contain */", "comment_tokens": ["Print", "the", "test", "name", ",", "escaping", "any", "'", "#", "'", "characters", "it", "might", "contain"], "ccode": ["/*-\n", " * Copyright (c) 2004 Nik Clayton\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "\n", "#define _GNU_SOURCE\n", "#include <ctype.h>\n", "#include <stdarg.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "\n", "#include \"tap.h\"\n", "\n", "static int no_plan = 0;\n", "static int skip_all = 0;\n", "static int have_plan = 0;\n", "static unsigned int test_count = 0; /* Number of tests that have been run */\n", "static unsigned int e_tests = 0; /* Expected number of tests to run */\n", "static unsigned int failures = 0; /* Number of tests that failed */\n", "static char *todo_msg = NULL;\n", "static char *todo_msg_fixed = \"libtap malloc issue\";\n", "static int todo = 0;\n", "static int test_died = 0;\n", "\n", "/* Encapsulate the pthread code in a conditional.  In the absence of\n", "   libpthread the code does nothing */\n", "#ifdef HAVE_LIBPTHREAD\n", "#include <pthread.h>\n", "static pthread_mutex_t M = PTHREAD_MUTEX_INITIALIZER;\n", "# define LOCK pthread_mutex_lock(&M);\n", "# define UNLOCK pthread_mutex_unlock(&M);\n", "#else\n", "# define LOCK\n", "# define UNLOCK\n", "#endif\n", "\n", "static void _expected_tests(unsigned int);\n", "static void _tap_init(void);\n", "static void _cleanup(void);\n", "\n", "/*\n", " * Generate a test result.\n", " *\n", " * ok -- boolean, indicates whether or not the test passed.\n", " * test_name -- the name of the test, may be NULL\n", " * test_comment -- a comment to print afterwards, may be NULL\n", " */\n", "unsigned int\n", "_gen_result(int ok, const char *func, char *file, unsigned int line,\n", "\t    char *test_name, ...)\n", "{\n", "\tva_list ap;\n", "\tchar *local_test_name = NULL;\n", "\tchar *c;\n", "\tint name_is_digits;\n", "\n", "\tLOCK;\n", "\n", "\ttest_count++;\n", "\n", "\t/* Start by taking the test name and performing any printf()\n", "\t   expansions on it */\n", "\tif(test_name != NULL) {\n", "\t\tva_start(ap, test_name);\n", "\t\tif (vasprintf(&local_test_name, test_name, ap) == -1) {\n", "\t\t\tlocal_test_name = NULL;\n", "\t\t}\n", "\t\tva_end(ap);\n", "\n", "\t\t/* Make sure the test name contains more than digits\n", "\t\t   and spaces.  Emit an error message and exit if it\n", "\t\t   does */\n", "\t\tif(local_test_name) {\n", "\t\t\tname_is_digits = 1;\n", "\t\t\tfor(c = local_test_name; *c != '\\0'; c++) {\n", "\t\t\t\tif(!isdigit(*c) && !isspace(*c)) {\n", "\t\t\t\t\tname_is_digits = 0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\n", "\t\t\tif(name_is_digits) {\n", "\t\t\t\tdiag(\"    You named your test '%s'.  You shouldn't use numbers for your test names.\", local_test_name);\n", "\t\t\t\tdiag(\"    Very confusing.\");\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\tif(!ok) {\n", "\t\tprintf(\"not \");\n", "\t\tfailures++;\n", "\t}\n", "\n", "\tprintf(\"ok %d\", test_count);\n", "\n", "\tif(test_name != NULL) {\n", "\t\tprintf(\" - \");\n", "\n", "\t\t/* Print the test name, escaping any '#' characters it\n", "\t\t   might contain */\n", "\t\tif(local_test_name != NULL) {\n", "\t\t\tflockfile(stdout);\n", "\t\t\tfor(c = local_test_name; *c != '\\0'; c++) {\n", "\t\t\t\tif(*c == '#')\n", "\t\t\t\t\tfputc('\\\\', stdout);\n", "\t\t\t\tfputc((int)*c, stdout);\n", "\t\t\t}\n", "\t\t\tfunlockfile(stdout);\n", "\t\t} else {\t/* vasprintf() failed, use a fixed message */\n", "\t\t\tprintf(\"%s\", todo_msg_fixed);\n", "\t\t}\n", "\t}\n", "\n", "\t/* If we're in a todo_start() block then flag the test as being\n", "\t   TODO.  todo_msg should contain the message to print at this\n", "\t   point.  If it's NULL then asprintf() failed, and we should\n", "\t   use the fixed message.\n", "\n", "\t   This is not counted as a failure, so decrement the counter if\n", "\t   the test failed. */\n", "\tif(todo) {\n", "\t\tprintf(\" # TODO %s\", todo_msg ? todo_msg : todo_msg_fixed);\n", "\t\tif(!ok)\n", "\t\t\tfailures--;\n", "\t}\n", "\n", "\tprintf(\"\\n\");\n", "\n", "\tif(!ok) {\n", "\t\tif(getenv(\"HARNESS_ACTIVE\") != NULL)\n", "\t\t\tfputs(\"\\n\", stderr);\n", "\n", "\t\tdiag(\"    Failed %stest (%s:%s() at line %d)\",\n", "\t\t     todo ? \"(TODO) \" : \"\", file, func, line);\n", "\t}\n", "\tfree(local_test_name);\n", "\n", "\tUNLOCK;\n", "\n", "\t/* We only care (when testing) that ok is positive, but here we\n", "\t   specifically only want to return 1 or 0 */\n", "\treturn ok ? 1 : 0;\n", "}\n"], "project": "liblttng-ust-ctl4", "file": "tap.pkl", "function": "_gen_result"}, {"comment_all": {"comment": "/*\n * Worldvisions Tunnel Vision Software:\n *   Copyright (C) 1997-2002 Net Integration Technologies, Inc.\n * \n * Functions to make us compile with both newer and older versions of openssl.\n * \n * THIS FILE MUST BE COMPILED AS STANDARD C, NOT C++!!!\n * \n * See wvsslhacks.h.\n */", "depth": 0, "reading_ease": 67.76, "reading_grade": 6.8, "line": 0}, "comment_text": "/*\n * Worldvisions Tunnel Vision Software:\n *   Copyright (C) 1997-2002 Net Integration Technologies, Inc.\n * \n * Functions to make us compile with both newer and older versions of openssl.\n * \n * THIS FILE MUST BE COMPILED AS STANDARD C, NOT C++!!!\n * \n * See wvsslhacks.h.\n */", "comment_tokens": ["Worldvisions", "Tunnel", "Vision", "Software", ":", "Copyright", "(", "C", ")", "1997-2002", "Net", "Integration", "Technologies", ",", "Inc", ".", "Functions", "to", "make", "us", "compile", "with", "both", "newer", "and", "older", "versions", "of", "openssl", ".", "THIS", "FILE", "MUST", "BE", "COMPILED", "AS", "STANDARD", "C", ",", "NOT", "C++", "!", "!", "!", "See", "wvsslhacks.h", "."], "ccode": ["/*\n", " * Worldvisions Tunnel Vision Software:\n", " *   Copyright (C) 1997-2002 Net Integration Technologies, Inc.\n", " * \n", " * Functions to make us compile with both newer and older versions of openssl.\n", " * \n", " * THIS FILE MUST BE COMPILED AS STANDARD C, NOT C++!!!\n", " * \n", " * See wvsslhacks.h.\n", " */\n", "#include \"wvsslhacks.h\"\n", "\n", "RSA *wv_d2i_RSAPublicKey(RSA **a, const unsigned char **pp, long length)\n", "{\n", "    return d2i_RSAPublicKey(a, (void *)pp, length);\n", "}\n"], "project": "libwvstreams4.6-base", "file": "wvsslhacks.pkl", "function": "wv_d2i_RSAPublicKey"}, {"comment_all": {"comment": "/* This function is used to compare two atoms coordinates to each other.*/", "depth": 0, "reading_ease": 67.76, "reading_grade": 6.8, "line": 62}, "comment_text": "/* This function is used to compare two atoms coordinates to each other.*/", "comment_tokens": ["This", "function", "is", "used", "to", "compare", "two", "atoms", "coordinates", "to", "each", "other", "."], "ccode": ["\n", "\n", "/************************************************************************/\n", "/* This function is used to compare two atoms coordinates to each other.*/\n", "/************************************************************************/\n", "gint compare3(struct xyzstruc *coords,gint i,gint j)\n", "{\n", "    if (coords[i].zcoord < coords[j].zcoord) return (-1);\n", "    else if (coords[i].zcoord > coords[j].zcoord) return (1);\n", "    else {\n", "\tif (coords[i].ycoord < coords[j].ycoord) return (-1);\n", "\telse if (coords[i].ycoord > coords[j].ycoord) return (1);\n", "\telse {\n", "\t    if (coords[i].xcoord < coords[j].xcoord) return (-1);\n", "\t    else if (coords[i].xcoord > coords[j].xcoord) return (1);\n", "\t    else return (0);\n", "\t}\n", "    }\n", "}\n"], "project": "gdpc-examples", "file": "sort.pkl", "function": "compare3"}, {"comment_all": {"comment": "/*\n * On return, caller must free *datap.\n */", "depth": 0, "reading_ease": 73.85, "reading_grade": 4.5, "line": 368}, "comment_text": "/*\n * On return, caller must free *datap.\n */", "comment_tokens": ["On", "return", ",", "caller", "must", "free", "datap", "."], "ccode": ["\n", "/*\n", " * On return, caller must free *datap.\n", " */\n", "int hfi_hfifs_read(const char *attr, char **datap)\n", "{\n", "\tint fd = -1, ret = -1;\n", "\tint saved_errno;\n", "\n", "\tfd = hfi_hfifs_open(attr, O_RDONLY);\n", "\tsaved_errno = errno;\n", "\n", "\tif (fd == -1)\n", "\t\tgoto bail;\n", "\n", "\tret = read_page(fd, datap);\n", "\tsaved_errno = errno;\n", "\n", "bail:\n", "\tif (ret == -1)\n", "\t\t*datap = NULL;\n", "\n", "\tif (fd != -1) {\n", "\t\tclose(fd);\n", "\t}\n", "\n", "\terrno = saved_errno;\n", "\treturn ret;\n", "}\n"], "project": "libpsm2-dev", "file": "opa_sysfs.pkl", "function": "hfi_hfifs_read"}, {"comment_all": {"comment": "/* Note: have to check all and not bail out early, so that we set the\n     \"used\" flags.\n\n     May be called with family == AF_LOCALto check interface by name only. */", "depth": 1, "reading_ease": 82.65, "reading_grade": 5.2, "line": 116}, "comment_text": "/* Note: have to check all and not bail out early, so that we set the\n     \"used\" flags.\n\n     May be called with family == AF_LOCALto check interface by name only. */", "comment_tokens": ["Note", ":", "have", "to", "check", "all", "and", "not", "bail", "out", "early", ",", "so", "that", "we", "set", "the", "``", "used", "''", "flags", ".", "May", "be", "called", "with", "family", "==", "AF_LOCALto", "check", "interface", "by", "name", "only", "."], "ccode": ["\n", "#endif\n", "\n", "int iface_check(int family, struct all_addr *addr, char *name, int *auth)\n", "{\n", "  struct iname *tmp;\n", "  int ret = 1, match_addr = 0;\n", "\n", "  /* Note: have to check all and not bail out early, so that we set the\n", "     \"used\" flags.\n", "\n", "     May be called with family == AF_LOCALto check interface by name only. */\n", "  \n", "  if (auth)\n", "    *auth = 0;\n", "  \n", "  if (daemon->if_names || daemon->if_addrs)\n", "    {\n", "      ret = 0;\n", "\n", "      for (tmp = daemon->if_names; tmp; tmp = tmp->next)\n", "\tif (tmp->name && wildcard_match(tmp->name, name))\n", "\t  ret = tmp->used = 1;\n", "\t        \n", "      if (addr)\n", "\tfor (tmp = daemon->if_addrs; tmp; tmp = tmp->next)\n", "\t  if (tmp->addr.sa.sa_family == family)\n", "\t    {\n", "\t      if (family == AF_INET &&\n", "\t\t  tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)\n", "\t\tret = match_addr = tmp->used = 1;\n", "#ifdef HAVE_IPV6\n", "\t      else if (family == AF_INET6 &&\n", "\t\t       IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, \n", "\t\t\t\t\t  &addr->addr.addr6))\n", "\t\tret = match_addr = tmp->used = 1;\n", "#endif\n", "\t    }          \n", "    }\n", "  \n", "  if (!match_addr)\n", "    for (tmp = daemon->if_except; tmp; tmp = tmp->next)\n", "      if (tmp->name && wildcard_match(tmp->name, name))\n", "\tret = 0;\n", "    \n", "\n", "  for (tmp = daemon->authinterface; tmp; tmp = tmp->next)\n", "    if (tmp->name)\n", "      {\n", "\tif (strcmp(tmp->name, name) == 0 &&\n", "\t    (tmp->addr.sa.sa_family == 0 || tmp->addr.sa.sa_family == family))\n", "\t  break;\n", "      }\n", "    else if (addr && tmp->addr.sa.sa_family == AF_INET && family == AF_INET &&\n", "\t     tmp->addr.in.sin_addr.s_addr == addr->addr.addr4.s_addr)\n", "      break;\n", "#ifdef HAVE_IPV6\n", "    else if (addr && tmp->addr.sa.sa_family == AF_INET6 && family == AF_INET6 &&\n", "\t     IN6_ARE_ADDR_EQUAL(&tmp->addr.in6.sin6_addr, &addr->addr.addr6))\n", "      break;\n", "#endif      \n", "\n", "  if (tmp && auth) \n", "    {\n", "      *auth = 1;\n", "      ret = 1;\n", "    }\n", "\n", "  return ret; \n", "}\n"], "project": "dnsmasq-base-lua", "file": "network.pkl", "function": "iface_check"}, {"comment_all": {"comment": "/* number of elements as KeyValueType */", "depth": 1, "reading_ease": 15.64, "reading_grade": 12.3, "line": 355}, "comment_text": "/* number of elements as KeyValueType */", "comment_tokens": ["number", "of", "elements", "as", "KeyValueType"], "ccode": ["\n", "\n", " static void keyiqst(KeyValueType *base, KeyValueType *max) \n", " { \n", "   register KeyValueType *i; \n", "   register KeyValueType *j; \n", "   register KeyValueType *jj; \n", "   register KeyValueType *mid; \n", "   register KeyValueType c; \n", "   KeyValueType *tmp; \n", "   long lo; \n", "   long hi; \n", "\n", "   lo = (max - base)>>1;         /* number of elements as KeyValueType */ \n", "   do { \n", "     mid = base + ((unsigned) lo>>1); \n", "     if (lo >= MTHRESH) { \n", "       j = (base->key > mid->key ? base : mid); \n", "       tmp = max - 1; \n", "       if (j->key > tmp->key) { \n", "         j = (j == base ? mid : base); /* switch to first loser */ \n", "         if (j->key < tmp->key) \n", "           j = tmp; \n", "       } \n", "\n", "       if (j != mid) {  /* SWAP */  \n", "         c = *mid; \n", "         *mid = *j; \n", "         *j = c; \n", "       } \n", "     } \n", "\n", "     /* Semi-standard quicksort partitioning/swapping */ \n", "     for (i = base, j = max - 1;;) { \n", "       while (i < mid && i->key <= mid->key) \n", "         i++; \n", "       while (j > mid) { \n", "         if (mid->key <= j->key) { \n", "           j--; \n", "           continue; \n", "         } \n", "         tmp = i + 1;    /* value of i after swap */ \n", "         if (i == mid)   /* j <-> mid, new mid is j */ \n", "           mid = jj = j; \n", "         else            /* i <-> j */ \n", "           jj = j--; \n", "         goto swap; \n", "       } \n", "\n", "       if (i == mid)  \n", "         break; \n", "       else {            /* i <-> mid, new mid is i */ \n", "         jj = mid; \n", "         tmp = mid = i;  /* value of i after swap */ \n", "         j--; \n", "       } \n", " swap: \n", "       c = *i; \n", "       *i = *jj; \n", "       *jj = c; \n", "       i = tmp; \n", "     } \n", "\n", "     i = (j = mid) + 1; \n", "     if ((lo = (j - base)>>1) <= (hi = (max - i)>>1)) { \n", "       if (lo >= THRESH) \n", "         keyiqst(base, j); \n", "       base = i; \n", "       lo = hi; \n", "     } \n", "     else { \n", "       if (hi >= THRESH) \n", "         keyiqst(i, max); \n", "       max = j; \n", "     } \n", "   } while (lo >= THRESH); \n", " } \n"], "project": "libmetis-edf-dev", "file": "myqsort.pkl", "function": "keyiqst"}, {"comment_all": {"comment": "/* force value to be positive */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 33}, "comment_text": "/* force value to be positive */", "comment_tokens": ["force", "value", "to", "be", "positive"], "ccode": ["/*****************************************************************************/\n", "/*                                                                           */\n", "/* Copyright (c) 1989-2008 Morgan Stanley All rights reserved.*/\n", "/* See .../src/LICENSE for terms of distribution.                           */\n", "/*                                                                           */\n", "/*                                                                           */\n", "/*****************************************************************************/\n", "/* contributed by Daniel F. Fisher */\n", "\n", "/* header file inclusions */\n", "#include <string.h>\n", "#include <limits.h>\n", "\n", "/* external function definitions */\n", "int \n", "bstrhash(char *key)\n", "{\n", "  int c;\n", "  int i;\n", "  int r = 0;\n", "  int b[sizeof(int)];\n", "\n", "  for (i = 0; i < sizeof(int); b[i++] = 0);\n", "\n", "  i = 0;\n", "  while ((c = *key++) != '\\0') {\n", "    b[i] ^= c;\n", "    i = (i + 1) % sizeof(int);\n", "  }\n", "  for (i = 0; i < sizeof(int); i++) {\n", "    r = (r << 8) | b[i];\n", "  }\n", "  if (r < 0)\n", "    r -= INT_MIN;\t\t/* force value to be positive */\n", "\n", "  return r;\n", "}\n"], "project": "aplus-fsf-dev", "file": "bstrhash.pkl", "function": "bstrhash"}, {"comment_all": {"comment": "/**\n * Returns a Iterator that can be used for simple iteration over a\n * collection.\n *\n * @return a Iterator that can be used for simple iteration over a\n *         collection\n */", "depth": 0, "reading_ease": 41.36, "reading_grade": 10.7, "line": 71}, "comment_text": "/**\n * Returns a Iterator that can be used for simple iteration over a\n * collection.\n *\n * @return a Iterator that can be used for simple iteration over a\n *         collection\n */", "comment_tokens": ["Returns", "a", "Iterator", "that", "can", "be", "used", "for", "simple", "iteration", "over", "a", "collection", ".", "@", "return", "a", "Iterator", "that", "can", "be", "used", "for", "simple", "iteration", "over", "a", "collection"], "ccode": ["\n", "/**\n", " * Returns a Iterator that can be used for simple iteration over a\n", " * collection.\n", " *\n", " * @return a Iterator that can be used for simple iteration over a\n", " *         collection\n", " */\n", "static ValaIterator*\n", "vala_iterable_real_iterator (ValaIterable* self)\n", "{\n", "\tg_critical (\"Type `%s' does not implement abstract method `vala_iterable_iterator'\", g_type_name (G_TYPE_FROM_INSTANCE (self)));\n", "\treturn NULL;\n", "}\n"], "project": "libvala-0.48-dev", "file": "iterable.pkl", "function": "vala_iterable_real_iterator"}, {"comment_all": {"comment": "/*     ELPA reflects a substantial effort on the part of the original */", "depth": 0, "reading_ease": 60.31, "reading_grade": 7.6, "line": 34}, "comment_text": "/*     along with ELPA.  If not, see <http://www.gnu.org/licenses/> */*/\n/*  */\n/*     ELPA reflects a substantial effort on the part of the original */\n/*     ELPA consortium, and we ask you to respect the spirit of the */\n/*     license that we chose: i.e., please contribute any changes you */\n/*     may have back to the original ELPA library distribution, and keep */\n/*     any derivatives of ELPA under the same license that we chose for */\n/*     the original distribution, the GNU Lesser General Public License. */\n", "comment_tokens": ["along", "with", "ELPA", ".", "If", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "ELPA", "reflects", "a", "substantial", "effort", "on", "the", "part", "of", "the", "original", "ELPA", "consortium", ",", "and", "we", "ask", "you", "to", "respect", "the", "spirit", "of", "the", "license", "that", "we", "chose", ":", "i.e.", ",", "please", "contribute", "any", "changes", "you", "may", "have", "back", "to", "the", "original", "ELPA", "library", "distribution", ",", "and", "keep", "any", "derivatives", "of", "ELPA", "under", "the", "same", "license", "that", "we", "chose", "for", "the", "original", "distribution", ",", "the", "GNU", "Lesser", "General", "Public", "License", "."], "ccode": ["/*     This file is part of ELPA. */\n", "/*  */\n", "/*     The ELPA library was originally created by the ELPA consortium, */\n", "/*     consisting of the following organizations: */\n", "/*  */\n", "/*     - Max Planck Computing and Data Facility (MPCDF), formerly known as */\n", "/*       Rechenzentrum Garching der Max-Planck-Gesellschaft (RZG), */\n", "/*     - Bergische Universit\u00e4t Wuppertal, Lehrstuhl f\u00fcr angewandte */\n", "/*       Informatik, */\n", "/*     - Technische Universit\u00e4t M\u00fcnchen, Lehrstuhl f\u00fcr Informatik mit */\n", "/*       Schwerpunkt Wissenschaftliches Rechnen , */\n", "/*     - Fritz-Haber-Institut, Berlin, Abt. Theorie, */\n", "/*     - Max-Plack-Institut f\u00fcr Mathematik in den Naturwissenschaften, */\n", "/*       Leipzig, Abt. Komplexe Strukutren in Biologie und Kognition, */\n", "/*       and */\n", "/*     - IBM Deutschland GmbH */\n", "/*  */\n", "/*  */\n", "/*     More information can be found here: */\n", "/*     http://elpa.mpcdf.mpg.de/ */\n", "/*  */\n", "/*     ELPA is free software: you can redistribute it and/or modify */\n", "/*     it under the terms of the version 3 of the license of the */\n", "/*     GNU Lesser General Public License as published by the Free */\n", "/*     Software Foundation. */\n", "/*  */\n", "/*     ELPA is distributed in the hope that it will be useful, */\n", "/*     but WITHOUT ANY WARRANTY; without even the implied warranty of */\n", "/*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */\n", "/*     GNU Lesser General Public License for more details. */\n", "/*  */\n", "/*     You should have received a copy of the GNU Lesser General Public License */\n", "/*     along with ELPA.  If not, see <http://www.gnu.org/licenses/> */\n", "/*  */\n", "/*     ELPA reflects a substantial effort on the part of the original */\n", "/*     ELPA consortium, and we ask you to respect the spirit of the */\n", "/*     license that we chose: i.e., please contribute any changes you */\n", "/*     may have back to the original ELPA library distribution, and keep */\n", "/*     any derivatives of ELPA under the same license that we chose for */\n", "/*     the original distribution, the GNU Lesser General Public License. */\n", "/*  */\n", "/*  */\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <elpa/elpa.h>\n", "#include <complex.h>\n", "\n", "int call_elpa1_real_solver_from_c(int na, int nev, double *a, int lda, double *ev, double *q, int ldq, int nblk, int ncols, int mpi_comm_rows, int mpi_comm_cols) {\n", "  return elpa_solve_evp_real_1stage(na, nev, a, lda, ev, q, ldq, nblk, ncols, mpi_comm_rows, mpi_comm_cols);\n", "}\n"], "project": "libelpa4", "file": "call_elpa1.pkl", "function": "call_elpa1_real_solver_from_c"}, {"comment_all": {"comment": "/*\n** read all exited processes that have been added to the exitfile\n** and store them into memory\n*/", "depth": 0, "reading_ease": 55.24, "reading_grade": 9.5, "line": 280}, "comment_text": "/*\n** read all exited processes that have been added to the exitfile\n** and store them into memory\n*/", "comment_tokens": ["read", "all", "exited", "processes", "that", "have", "been", "added", "to", "the", "exitfile", "and", "store", "them", "into", "memory"], "ccode": ["\n", "/*\n", "** read all exited processes that have been added to the exitfile\n", "** and store them into memory\n", "*/\n", "unsigned int\n", "netatop_exitstore(void)\n", "{\n", "\tsocklen_t\t\tsocklen = 0, nexitnet, sz, nr=0;\n", "\tunsigned long\t\tuncomplen;\n", "\tunsigned char\t\tnextsize;\n", "\tunsigned char\t\treadbuf[nahp->ntplen+100];\n", "\tunsigned char\t\tdatabuf[nahp->ntplen];\n", "\tstruct netpertask\t*tmp = (struct netpertask *)databuf;\n", "\tstruct exitstore\t*esp;\n", "\n", "        regainrootprivs();\n", "\n", "\t/*\n", "\t** force garbage collection:\n", "\t**   netatop module builds new list of exited processes that\n", "\t**   can be read by netatopd and written to exitfile\n", "\t*/\n", "\tif (getsockopt(netsock, SOL_IP, NETATOP_FORCE_GC, NULL, &socklen)!=0) {\n", "        \tif (! droprootprivs())\n", "        \t\tcleanstop(42);\n", "\n", "\t\tif (errno == ENOPROTOOPT || errno == EPERM)\n", "\t\t{\n", "\t\t\tsupportflags &= ~NETATOP;\n", "\t\t\tsupportflags &= ~NETATOPD;\n", "\t\t\tclose(netsock);\n", "\t\t\tnetsock = -1;\n", "\t\t}\n", "\n", "\t\treturn 0;\n", "\t}\n", "\n", "\t/*\n", " \t** wait until list of exited processes is read by netatopd\n", "\t** and available to be read by atop\n", "\t*/\n", "\tif (getsockopt(netsock, SOL_IP, NETATOP_EMPTY_EXIT, 0, &socklen) !=0) {\n", "        \tif (! droprootprivs())\n", "        \t\tcleanstop(42);\n", "\n", "\t\tif (errno == ENOPROTOOPT || errno == EPERM)\n", "\t\t{\n", "\t\t\tsupportflags &= ~NETATOP;\n", "\t\t\tsupportflags &= ~NETATOPD;\n", "\t\t\tclose(netsock);\n", "\t\t\tnetsock = -1;\n", "\t\t}\n", "\n", "\t\treturn 0;\n", "\t}\n", "\n", "       \tif (! droprootprivs())\n", "       \t\tcleanstop(42);\n", "\n", "\t/*\n", "\t** verify how many exited processes are available to be read\n", "\t** from the exitfile\n", "\t*/\n", "\tnexitnet = nahp->curseq - lastseq;\n", "\tlastseq  = nahp->curseq;\n", "\n", "\t/*\n", "\t** allocate storage for all exited processes\n", "\t*/\n", "\texitall = malloc(nexitnet * sizeof(struct exitstore));\n", "\n", "\tptrverify(exitall, \"Malloc failed for %d exited netprocs\\n\", nexitnet);\n", "\n", "\tmemset(exitall, 0, nexitnet * sizeof(struct exitstore));\n", "\n", "\tesp = exitall;\n", "\n", "\t/*\n", "\t** read next byte from exitfile that specifies the length\n", "\t** of the next record\n", "\t*/\n", "\tif ( read(netexitfd, &nextsize, 1) != 1) \n", "\t\treturn 0;\n", "\n", "\t/*\n", "\t** read the next record and (if possible) the byte specifying\n", "\t** the size of the next record\n", "\t*/\n", "\twhile ( (sz = read(netexitfd, readbuf, nextsize+1)) >= nextsize)\n", "\t{\n", "\t\t/*\n", "\t\t** decompress record and store it\n", "\t\t*/\n", "        \tuncomplen = nahp->ntplen;\n", "\n", "\t\tif (nahp->ntplen <= sizeof(struct netpertask))\n", "\t\t{\n", "\t\t\t(void) uncompress((Byte *)&(esp->npt), &uncomplen,\n", "\t\t\t\t\t\t\treadbuf, nextsize);\n", "\t\t}\n", "\t\telse\n", "\t\t{\n", "\t\t\t(void) uncompress((Byte *)databuf, &uncomplen,\n", "\t\t\t\t\t\t\treadbuf, nextsize);\n", "\t\t\tesp->npt = *tmp;\n", "\t\t}\n", "\n", "\t\tesp++;\n", "\t\tnr++;\n", "\n", "\t\t/*\n", "\t\t** check if we have read all records\n", "\t\t*/\n", "\t\tif (nr == nexitnet)\n", "\t\t{\n", "\t\t\t/*\n", "\t\t\t** if we have read one byte too many:\n", "\t\t\t** reposition seek pointer \n", "\t\t\t*/\n", "\t\t\tif (sz > nextsize)\n", "\t\t\t\t(void) lseek(netexitfd, -1, SEEK_CUR);\n", "\n", "\t\t\tbreak;\n", "\t\t}\n", "\n", "\t\t/*\n", "\t\t** prepare reading next record\n", "\t\t*/\n", "\t\tif (sz > nextsize)\n", "\t\t\tnextsize = readbuf[nextsize];\n", "\t\telse\n", "\t\t\tbreak;\t// unexpected: more requested than available\n", "\t}\n", "\n", "\texitnum = nr;\n", "\n", "\treturn nr;\n", "}\n"], "project": "atop", "file": "netatopif.pkl", "function": "netatop_exitstore"}, {"comment_all": {"comment": "/*\n * Return the first entry in a hash table for a linear search\n */", "depth": 0, "reading_ease": 84.68, "reading_grade": 4.4, "line": 396}, "comment_text": "/*\n * Return the first entry in a hash table for a linear search\n */", "comment_tokens": ["Return", "the", "first", "entry", "in", "a", "hash", "table", "for", "a", "linear", "search"], "ccode": ["\f\n", "\n", "\n", "/*\n", " * Return the first entry in a hash table for a linear search\n", " */\n", "\n", "hash_datum *\n", "hash_FirstEntry(hashtable)\n", "\thash_tbl *hashtable;\n", "{\n", "\thashtable->bucketnum = 0;\n", "\thashtable->member = (hashtable->table)[0];\n", "\treturn hash_NextEntry(hashtable);\n", "}\n"], "project": "bootp", "file": "hash.pkl", "function": "hash_FirstEntry"}, {"comment_all": {"comment": "/* number of bytes to remove after the conversion */", "depth": 1, "reading_ease": 63.36, "reading_grade": 6.4, "line": 33}, "comment_text": "/* initial lengths of the string to interpret     */\n/* 2,4,6 or 8 bytes                               */\n/* number of bytes to remove after the conversion */\n/* temporary string                               */\n", "comment_tokens": ["initial", "lengths", "of", "the", "string", "to", "interpret", "2,4,6", "or", "8", "bytes", "number", "of", "bytes", "to", "remove", "after", "the", "conversion", "temporary", "string"], "ccode": ["/* ########################################################### */\n", "/* This Software is licensed under the GPL licensed Version 2, */\n", "/* please read http://www.gnu.org/copyleft/gpl.html            */\n", "/* ########################################################### */\n", "\n", "/* ************************************ */\n", "/* Various UTF-8 manipulation functions */\n", "/* ************************************ */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <stdarg.h>\n", "#include <string.h>\n", "#include <ctype.h>\n", "#include <limits.h>\n", "#include <langinfo.h>\n", "#include \"xmalloc.h\"\n", "#include \"utf8.h\"\n", "\n", "/* ======================================================================== */\n", "/* Unicode (UTF-8) ascii representation interpreter.                        */\n", "/* The string passed will be altered but will not move in memory            */\n", "/* All sequence of \\uxx, \\uxxxx, \\uxxxxxx and \\uxxxxxxxx will be replace by */\n", "/* the corresponding UTF-8 character.                                       */\n", "/* ======================================================================== */\n", "void\n", "utf8_interpret(char * s, langinfo_t * langinfo)\n", "{\n", "  char * utf8_str;          /* \\uxx...                                        */\n", "  size_t utf8_to_eos_len;   /* bytes in s starting from the first             *\n", "                             * occurrence of \\u                               */\n", "  size_t init_len;          /* initial lengths of the string to interpret     */\n", "  size_t utf8_ascii_len;    /* 2,4,6 or 8 bytes                               */\n", "  size_t len_to_remove = 0; /* number of bytes to remove after the conversion */\n", "  char   tmp[9];            /* temporary string                               */\n", "\n", "  /* Guard against the case where s is NULL */\n", "  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "  if (s == NULL)\n", "    return;\n", "\n", "  init_len = strlen(s);\n", "\n", "  while ((utf8_str = strstr(s, \"\\\\u\")) != NULL)\n", "  {\n", "    utf8_to_eos_len = strlen(utf8_str);\n", "    if (utf8_to_eos_len < 4) /* string too short to contain *\n", "                              * a valid UTF-8 char          */\n", "    {\n", "      *utf8_str       = '.';\n", "      *(utf8_str + 1) = '\\0';\n", "    }\n", "    else /* s is long enough */\n", "    {\n", "      unsigned byte;\n", "      char *   utf8_seq_offset = utf8_str + 2;\n", "\n", "      /* Get the first 2 utf8 bytes */\n", "      *tmp       = *utf8_seq_offset;\n", "      *(tmp + 1) = *(utf8_seq_offset + 1);\n", "      *(tmp + 2) = '\\0';\n", "\n", "      /* If they are invalid, replace the \\u sequence by a dot */\n", "      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "      if (!isxdigit(tmp[0]) || !isxdigit(tmp[1]))\n", "      {\n", "        *utf8_str = '.';\n", "        if (4 >= utf8_to_eos_len)\n", "          *(utf8_str + 1) = '\\0';\n", "        else\n", "          memmove(utf8_str, utf8_str + 4, utf8_to_eos_len - 4);\n", "        return;\n", "      }\n", "      else\n", "      {\n", "        /* They are valid, deduce from them the length of the sequence */\n", "        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "        sscanf(tmp, \"%2x\", &byte);\n", "        utf8_ascii_len = utf8_get_length(byte) * 2;\n", "\n", "        /* Check again if the inputs string is long enough */\n", "        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "        if (utf8_to_eos_len - 2 < utf8_ascii_len)\n", "        {\n", "          *utf8_str       = '.';\n", "          *(utf8_str + 1) = '\\0';\n", "        }\n", "        else\n", "        {\n", "          /* replace the \\u sequence by the bytes forming the UTF-8 char */\n", "          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "          size_t i;\n", "          *tmp = byte;\n", "\n", "          /* Put the bytes in the tmp string */\n", "          /* ''''''''''''''''''''''''''''''' */\n", "          if (langinfo->utf8)\n", "          {\n", "            for (i = 1; i < utf8_ascii_len / 2; i++)\n", "            {\n", "              sscanf(utf8_seq_offset + 2 * i, \"%2x\", &byte);\n", "              *(tmp + i) = byte;\n", "            }\n", "            tmp[utf8_ascii_len / 2] = '\\0';\n", "          }\n", "\n", "          /* Does they form a valid UTF-8 char? */\n", "          /* '''''''''''''''''''''''''''''''''' */\n", "          if (langinfo->utf8 && utf8_validate(tmp, utf8_ascii_len / 2))\n", "          {\n", "            /* Put them back in the original string and move */\n", "            /* the remaining bytes after them                */\n", "            /* ''''''''''''''''''''''''''''''''''''''''''''' */\n", "            memmove(utf8_str, tmp, utf8_ascii_len / 2);\n", "\n", "            if (utf8_to_eos_len < utf8_ascii_len)\n", "              *(utf8_str + utf8_ascii_len / 2 + 1) = '\\0';\n", "            else\n", "              memmove(utf8_str + utf8_ascii_len / 2,\n", "                      utf8_seq_offset + utf8_ascii_len,\n", "                      utf8_to_eos_len - utf8_ascii_len - 2 + 1);\n", "          }\n", "          else\n", "          {\n", "            /* The invalid sequence is replaced by a dot */\n", "            /* ''''''''''''''''''''''''''''''''''''''''' */\n", "            *utf8_str = '.';\n", "            if (utf8_to_eos_len < utf8_ascii_len)\n", "              *(utf8_str + 1) = '\\0';\n", "            else\n", "              memmove(utf8_str + 1, utf8_seq_offset + utf8_ascii_len,\n", "                      utf8_to_eos_len - utf8_ascii_len - 2 + 1);\n", "            utf8_ascii_len = 2;\n", "          }\n", "        }\n", "\n", "        /* Update the number of bytes to remove at the end */\n", "        /* of the initial string                           */\n", "        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "        len_to_remove += 2 + utf8_ascii_len / 2;\n", "      }\n", "    }\n", "  }\n", "\n", "  /* Make sure that the string is well terminated */\n", "  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n", "  *(s + init_len - len_to_remove) = '\\0';\n", "\n", "  return;\n", "}\n"], "project": "smenu", "file": "utf8.pkl", "function": "utf8_interpret"}, {"comment_all": {"comment": "/* the following occur in the NIST 1.02 version */", "depth": 2, "reading_ease": 71.82, "reading_grade": 5.2, "line": 1139}, "comment_text": "/* FIXME */\n/* the following occur in the NIST 1.02 version */\n/* case (blas_unassembled) : retcode = (bsm->mtxAp == NULL); */\n", "comment_tokens": ["FIXME", "the", "following", "occur", "in", "the", "NIST", "1.02", "version", "case", "(", "blas_unassembled", ")", ":", "retcode", "=", "(", "bsm-", ">", "mtxAp", "==", "NULL", ")", ";"], "ccode": ["\n", "               /* Matrix Property Routines */\n", "\n", "rsb_blas_int_t rsb__BLAS_usgp( blas_sparse_matrix A, rsb_blas_int_t pname )\n", "{\n", "\t/**\n", "\t \\ingroup gr_internals\n", "\t matrix property get\n", "\t */\n", "\tstruct rsb_blas_sparse_matrix_t * bsm = NULL;\n", "\trsb_blas_int_t retcode = RSB_BLAS_ERROR;\n", "\n", "\tif( (bsm = rsb__BLAS_matrix_retrieve(A) ) == NULL )\n", "\t\tgoto ret;\n", "\n", "\tswitch (pname)\n", "\t{\n", "\t\t/*  */\n", "\t\tcase (blas_num_rows) : retcode=bsm->coomatrix.nr; break;\n", "\t\tcase (blas_num_cols) : retcode=bsm->coomatrix.nc; break;\n", "\t\tcase (blas_num_nonzeros) : if (bsm->mtxAp != NULL) rsb__BLAS_Xusget_matrix_nnz(A,&retcode) ; else retcode = bsm->coomatrix.nnz; break;\n", "\t\t//case (blas_num_nonzeros) : retcode=bsm->coomatrix.nnz; break;\n", "\t\t/*  */\n", "\t\tcase (blas_complex) : retcode=bsm->field == blas_complex; break;\n", "\t\tcase (blas_real) : retcode=bsm->field == blas_real; break;\n", "\t\tcase (blas_single_precision) : retcode=bsm->fprecision == blas_single_precision ? 1:0; break;\n", "\t\tcase (blas_double_precision) : retcode=bsm->fprecision == blas_double_precision ? 1:0; break;\n", "\t\t/*  */\n", "\t\tcase (blas_triangular) : retcode=( /*bsm->symmetry == blas_triangular || */bsm->symmetry == blas_lower_triangular || bsm->symmetry == blas_upper_triangular ); break;\n", "\t\tcase (blas_lower_triangular) : retcode=bsm->symmetry == blas_lower_triangular; break;\n", "\t\tcase (blas_upper_triangular) : retcode=bsm->symmetry == blas_upper_triangular; break;\n", "\t\t/*  */\n", "\t\tcase (blas_general) : retcode=bsm->symmetry == blas_general; break;\n", "\t\tcase (blas_lower_symmetric) : retcode=( bsm->symmetry == blas_lower_symmetric ); break;\n", "\t\tcase (blas_upper_symmetric) : retcode=( bsm->symmetry == blas_upper_symmetric ); break;\n", "\t\tcase (blas_symmetric) : retcode=( /*bsm->symmetry == blas_symmetric || */bsm->symmetry == blas_lower_symmetric || bsm->symmetry == blas_upper_symmetric ); break;\n", "\t\t/* case (blas_hermitian) : retcode=bsm->symmetry == blas_hermitian; break; */\n", "\t\tcase (blas_hermitian) : retcode=( /*bsm->symmetry == blas_hermitian || */bsm->symmetry == blas_lower_hermitian || bsm->symmetry == blas_upper_hermitian ); break;\n", "\t\t/*  */\n", "\t\tcase (blas_zero_base) : retcode=bsm->base == blas_zero_base; break;\n", "\t\tcase (blas_one_base) : retcode=bsm->base == blas_one_base; break;\n", "\t\t/*  */\n", "\t\tcase (blas_rowmajor) : retcode=bsm->order == blas_rowmajor; break;\n", "\t\tcase (blas_colmajor) : retcode=bsm->order == blas_colmajor; break;\n", "\t\t/*  */\n", "\t\tcase (blas_new_handle) : retcode=bsm->type == blas_new_handle; break;\n", "\t\tcase (blas_open_handle) : retcode=bsm->type == blas_open_handle; break;\n", "\t\tcase (blas_valid_handle) : retcode=bsm->type == blas_valid_handle;\n", "\t\tcase (blas_invalid_handle) : retcode=bsm->type != blas_valid_handle; /* FIXME */\n", "\t\t/* the following occur in the NIST 1.02 version */\n", "\t\t/* case (blas_unassembled) : retcode = (bsm->mtxAp == NULL); */\n", "\t\tcase (blas_unassembled) : retcode=bsm->type != blas_valid_handle;\n", "\t\tcase (blas_regular) : retcode = 0;\n", "\t\tcase (blas_irregular) : retcode = 1;\n", "\t\tcase (blas_block) : retcode = 0;\n", "\n", "\t\tbreak;\n", "#if RSB_WANT_SPARSE_BLAS_EXTENSIONS\n", "\t\tcase (blas_rsb_duplicates_ovw) :\n", "\t\tcase (blas_rsb_duplicates_sum) :\n", "\t\tretcode = bsm->dupstra ;\n", "\t\tbreak;\n", "\t\tcase (blas_rsb_rep_csr) :\n", "\t\tcase (blas_rsb_rep_coo) :\n", "\t\tcase (blas_rsb_rep_rsb) :\n", "\t\tretcode = bsm->fmt_hint;\n", "\t\tbreak;\n", "#endif /* RSB_WANT_SPARSE_BLAS_EXTENSIONS */\n", "#if RSB_BLAS_WANT_EXPERIMENTAL_TUNING \n", "\t\tcase (blas_rsb_spmv_autotuning_on ):\n", "\t\tcase (blas_rsb_spmv_autotuning_off ):\n", "\t\t/* NOTE: we return values for untransposed here. */\n", "\t\tcase (blas_rsb_spmv_n_autotuning_off ):\n", "\t\tcase (blas_rsb_spmv_n_autotuning_on ):\n", "\t\tcase (blas_rsb_autotune_next_operation):\n", "\t\t\tretcode = bsm->opt_mvn_hint > 0 ?  bsm->opt_mvn_hint : 0;\n", "\t\tbreak;\n", "\t\tcase (blas_rsb_spmv_t_autotuning_off ):\n", "\t\tcase (blas_rsb_spmv_t_autotuning_on ):\n", "\t\t\tretcode = bsm->opt_mvt_hint > 0 ?  bsm->opt_mvt_hint : 0;\n", "\t\tbreak;\n", "#else\n", "\t\tcase (blas_rsb_spmv_autotuning_on ):\n", "\t\tcase (blas_rsb_spmv_autotuning_off ):\n", "\t\tcase (blas_rsb_spmv_n_autotuning_off ):\n", "\t\tcase (blas_rsb_spmv_n_autotuning_on ):\n", "\t\tcase (blas_rsb_spmv_t_autotuning_off ):\n", "\t\tcase (blas_rsb_spmv_t_autotuning_on ):\n", "\t\tcase (blas_rsb_autotune_next_operation):\n", "#if RSB_WANT_OMP_RECURSIVE_KERNELS\n", "\t\t\tretcode = RSB_BLAS_ERROR_UNSUPPORTED;\n", "#else /* RSB_WANT_OMP_RECURSIVE_KERNELS */\n", "\t\t\tretcode = RSB_CONST_MIN_SUPPORTED_CORES;\n", "#endif /* RSB_WANT_OMP_RECURSIVE_KERNELS */\n", "\t\tbreak;\n", "#endif /* RSB_BLAS_WANT_EXPERIMENTAL_TUNING */\n", "\t}\n", "ret:\n", "\treturn retcode;\n", "}\n"], "project": "librsb-dev", "file": "rsb_libspblas_handle.pkl", "function": "rsb__BLAS_usgp"}, {"comment_all": {"comment": "/* We should never, ever, reach here. */", "depth": 2, "reading_ease": 90.77, "reading_grade": 2.1, "line": 550}, "comment_text": "/* We should never, ever, reach here. */", "comment_tokens": ["We", "should", "never", ",", "ever", ",", "reach", "here", "."], "ccode": ["\n", "void\n", "setgid_io_init (void)\n", "{\n", "  gid_t safegid;\n", "  int setgid_io_inpipe[2];\n", "  int setgid_io_outpipe[2];\n", "\n", "  g_return_if_fail (setgid_io_initialised == 0);\n", "  if (pipe (setgid_io_inpipe) != 0){\n", "    g_warning(\"Unable to create pipe\");\n", "  }\n", "  if (pipe (setgid_io_outpipe) != 0){\n", "    g_warning(\"Unable to create pipe\");\n", "  }\n", "\n", "  if ((setgid_io_child_pid = fork ()) != 0) {\n", "    close (setgid_io_inpipe[1]);\n", "    close (setgid_io_outpipe[0]);\n", "\n", "    setgid_io_infd = setgid_io_inpipe[0];\n", "    setgid_io_outfd = setgid_io_outpipe[1];\n", "\n", "    safegid = getgid ();\n", "    setregid (safegid, safegid);\n", "  } else {\n", "    close (setgid_io_inpipe[0]);\n", "    close (setgid_io_outpipe[1]);\n", "    close (STDIN_FILENO);\n", "\n", "    setgid_io_pipe_watcher (setgid_io_inpipe[1], setgid_io_outpipe[0]);\n", "    /* We should never, ever, reach here. */\n", "    g_assert_not_reached ();\n", "  }\n", "\n", "  setgid_io_initialised = 1;\n", "}\n"], "project": "gweled", "file": "games-setgid-io.pkl", "function": "setgid_io_init"}, {"comment_all": {"comment": "/* %toplevel */", "depth": 1, "reading_ease": 36.62, "reading_grade": 8.4, "line": 4570}, "comment_text": "/* %vector-unfold-right! */\n/* srfi-133#%vector-unfold-right! */\n/* %toplevel */\n", "comment_tokens": ["%", "vector-unfold-right", "!", "srfi-133", "#", "%", "vector-unfold-right", "!", "%", "toplevel"], "ccode": ["SCM_EXTENSION_ENTRY void Scm_Init_srfi_133() {\n", "   Scm_SelectModule(SCM_MODULE(SCM_OBJ(Scm_GaucheModule())));\n", "SCM_INIT_EXTENSION(srfi_133);\n", "  scm__rc.d1950[1] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[0])),TRUE); /* srfi-133 */\n", "  scm__rc.d1950[0] = SCM_OBJ(Scm_FindModule(SCM_SYMBOL(scm__rc.d1950[1]), SCM_FIND_MODULE_CREATE)); /* module srfi-133 */\n", "   Scm_SelectModule(SCM_MODULE(scm__rc.d1950[0]));\n", "   Scm_SelectModule(SCM_MODULE(SCM_OBJ(Scm_GaucheModule())));\n", "   Scm_SelectModule(SCM_MODULE(scm__rc.d1950[0]));\n", "  scm__rc.d1950[2] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[1])),TRUE); /* %vector-check-start+end */\n", "  scm__rc.d1950[4] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[2])),TRUE); /* <vector> */\n", "  scm__rc.d1950[5] = SCM_OBJ(Scm_FindModule(SCM_SYMBOL(scm__rc.d1950[1]), SCM_FIND_MODULE_CREATE)); /* module srfi-133 */\n", "  scm__rc.d1950[3] = Scm_MakeIdentifier(scm__rc.d1950[4], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#<vector> */\n", "  scm__rc.d1950[7] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[3])),TRUE); /* is-a? */\n", "  scm__rc.d1950[9] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[4])),TRUE); /* gauche.common-macros */\n", "  scm__rc.d1950[8] = SCM_OBJ(Scm_FindModule(SCM_SYMBOL(scm__rc.d1950[9]), SCM_FIND_MODULE_CREATE)); /* module gauche.common-macros */\n", "  scm__rc.d1950[6] = Scm_MakeIdentifier(scm__rc.d1950[7], SCM_MODULE(scm__rc.d1950[8]), SCM_NIL); /* gauche.common-macros#is-a? */\n", "  scm__rc.d1950[10] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[5])),TRUE); /* v */\n", "  scm__rc.d1950[12] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[6])),TRUE); /* type-error */\n", "  scm__rc.d1950[11] = Scm_MakeIdentifier(scm__rc.d1950[12], SCM_MODULE(scm__rc.d1950[8]), SCM_NIL); /* gauche.common-macros#type-error */\n", "  scm__rc.d1950[14] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[7])),TRUE); /* <= */\n", "  scm__rc.d1950[13] = Scm_MakeIdentifier(scm__rc.d1950[14], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#<= */\n", "  scm__rc.d1950[16] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[9])),TRUE); /* errorf */\n", "  scm__rc.d1950[15] = Scm_MakeIdentifier(scm__rc.d1950[16], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#errorf */\n", "  scm__rc.d1950[17] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[12])),TRUE); /* s */\n", "  scm__rc.d1950[18] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[13])),TRUE); /* e */\n", "  scm__rc.d1950[19] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[14])),TRUE); /* open-end? */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[20]), scm__rc.d1950[19]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[22]), scm__rc.d1950[18]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[24]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[26]), scm__rc.d1950[10]);\n", "  scm__rc.d1950[28] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[15])),TRUE); /* source-info */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[33]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[35] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[17])),TRUE); /* unused-args */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[36]), scm__rc.d1950[35]);\n", "  scm__rc.d1950[42] = Scm_MakeExtendedPair(scm__rc.d1950[2], SCM_OBJ(&scm__rc.d1950[26]), SCM_OBJ(&scm__rc.d1950[40]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[43]), scm__rc.d1950[42]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[0]))->name = scm__rc.d1950[2];/* %vector-check-start+end */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[29] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[41] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[56] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[72] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[0]))[99] = SCM_WORD(scm__rc.d1950[15]);\n", "  ScmObj G1954 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[0]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[2]) /* %vector-check-start+end */, G1954,0);\n", "\n", "  scm__rc.d1950[45] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[18])),TRUE); /* %ensure-mutable */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[46]), scm__rc.d1950[10]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[48]), scm__rc.d1950[35]);\n", "  scm__rc.d1950[52] = Scm_MakeExtendedPair(scm__rc.d1950[45], SCM_OBJ(&scm__rc.d1950[46]), SCM_OBJ(&scm__rc.d1950[50]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[53]), scm__rc.d1950[52]);\n", "  scm__rc.d1950[55] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[19])),TRUE); /* lvar */\n", "  scm__rc.d1950[56] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[20])),TRUE); /* values */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[57]), scm__rc.d1950[56]);\n", "  scm__rc.d1950[64] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[21])),TRUE); /* lambda */\n", "  scm__rc.d1950[63] = Scm_MakeIdentifier(scm__rc.d1950[64], SCM_MODULE(Scm_GaucheModule()), SCM_NIL); /* gauche#lambda */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[69]), scm__rc.d1950[63]);\n", "  ((ScmObj*)SCM_OBJ(&scm__rc.d1950[73]))[3] = scm__rc.d1950[55];\n", "  ((ScmObj*)SCM_OBJ(&scm__rc.d1950[73]))[4] = scm__rc.d1950[10];\n", "  ((ScmObj*)SCM_OBJ(&scm__rc.d1950[73]))[11] = scm__rc.d1950[45];\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[1]))->name = scm__rc.d1950[45];/* %ensure-mutable */\n", "  ScmObj G1955 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[1]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[45]) /* %ensure-mutable */, G1955,SCM_BINDING_INLINABLE);\n", "\n", "  scm__rc.d1950[90] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[22])),TRUE); /* f */\n", "  scm__rc.d1950[91] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[23])),TRUE); /* rvec */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[92]), scm__rc.d1950[18]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[94]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[96]), scm__rc.d1950[91]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[98]), scm__rc.d1950[90]);\n", "  scm__rc.d1950[100] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[24])),TRUE); /* seed */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[101]), scm__rc.d1950[100]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[103]), scm__rc.d1950[18]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[105]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[107]), scm__rc.d1950[91]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[109]), scm__rc.d1950[90]);\n", "  scm__rc.d1950[111] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[25])),TRUE); /* seeds */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[112]), scm__rc.d1950[18]);\n", "  SCM_SET_CDR(SCM_OBJ(&scm__rc.d1950[112]), scm__rc.d1950[111]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[114]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[116]), scm__rc.d1950[91]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[118]), scm__rc.d1950[90]);\n", "  scm__rc.d1950[126] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[98]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[127]), scm__rc.d1950[126]);\n", "  scm__rc.d1950[129] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[109]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[130]), scm__rc.d1950[129]);\n", "  scm__rc.d1950[132] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[118]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[133]), scm__rc.d1950[132]);\n", "  scm__rc.d1950[135] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[26])),TRUE); /* %vector-unfold! */\n", "  scm__rc.d1950[137] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[27])),TRUE); /* make-case-lambda */\n", "  scm__rc.d1950[136] = Scm_MakeIdentifier(scm__rc.d1950[137], SCM_MODULE(Scm_GaucheInternalModule()), SCM_NIL); /* gauche.internal#make-case-lambda */\n", "  scm__rc.d1950[138] = Scm_MakeIdentifier(scm__rc.d1950[135], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-unfold! */\n", "  scm__rc.d1950[139] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[28])),TRUE); /* %toplevel */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[5]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[185]))[17] = SCM_WORD(scm__rc.d1950[135]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[185]))[19] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[185]))[21] = SCM_WORD(scm__rc.d1950[138]);\n", "  scm__rc.d1950[140] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[98]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[141]), scm__rc.d1950[140]);\n", "  scm__rc.d1950[143] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[109]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[144]), scm__rc.d1950[143]);\n", "  scm__rc.d1950[146] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[118]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[147]), scm__rc.d1950[146]);\n", "  scm__rc.d1950[149] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[29])),TRUE); /* %vector-unfold-right! */\n", "  scm__rc.d1950[150] = Scm_MakeIdentifier(scm__rc.d1950[149], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-unfold-right! */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[9]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[277]))[17] = SCM_WORD(scm__rc.d1950[149]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[277]))[19] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[277]))[21] = SCM_WORD(scm__rc.d1950[150]);\n", "  scm__rc.d1950[151] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[30])),TRUE); /* vector-unfold */\n", "  scm__rc.d1950[153] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[31])),TRUE); /* make-vector */\n", "  scm__rc.d1950[152] = Scm_MakeIdentifier(scm__rc.d1950[153], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#make-vector */\n", "  scm__rc.d1950[154] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[32])),TRUE); /* len */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[155]), scm__rc.d1950[154]);\n", "  SCM_SET_CDR(SCM_OBJ(&scm__rc.d1950[155]), scm__rc.d1950[111]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[157]), scm__rc.d1950[90]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[163]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[167] = Scm_MakeExtendedPair(scm__rc.d1950[151], SCM_OBJ(&scm__rc.d1950[157]), SCM_OBJ(&scm__rc.d1950[165]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[168]), scm__rc.d1950[167]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[10]))->name = scm__rc.d1950[151];/* vector-unfold */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[300]))[4] = SCM_WORD(scm__rc.d1950[152]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[300]))[9] = SCM_WORD(scm__rc.d1950[138]);\n", "  ScmObj G1956 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[10]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[151]) /* vector-unfold */, G1956,0);\n", "\n", "  scm__rc.d1950[170] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[33])),TRUE); /* vector-unfold-right */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[175]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[179] = Scm_MakeExtendedPair(scm__rc.d1950[170], SCM_OBJ(&scm__rc.d1950[157]), SCM_OBJ(&scm__rc.d1950[177]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[180]), scm__rc.d1950[179]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[11]))->name = scm__rc.d1950[170];/* vector-unfold-right */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[317]))[4] = SCM_WORD(scm__rc.d1950[152]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[317]))[9] = SCM_WORD(scm__rc.d1950[150]);\n", "  ScmObj G1957 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[11]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[170]) /* vector-unfold-right */, G1957,0);\n", "\n", "  scm__rc.d1950[182] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[34])),TRUE); /* vector-unfold! */\n", "  scm__rc.d1950[183] = Scm_MakeIdentifier(scm__rc.d1950[45], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%ensure-mutable */\n", "  scm__rc.d1950[185] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[36])),TRUE); /* error */\n", "  scm__rc.d1950[184] = Scm_MakeIdentifier(scm__rc.d1950[185], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#error */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[190]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[194] = Scm_MakeExtendedPair(scm__rc.d1950[182], SCM_OBJ(&scm__rc.d1950[118]), SCM_OBJ(&scm__rc.d1950[192]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[195]), scm__rc.d1950[194]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[12]))->name = scm__rc.d1950[182];/* vector-unfold! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[14] = SCM_WORD(scm__rc.d1950[91]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[24] = SCM_WORD(scm__rc.d1950[183]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[34] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[45] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[52] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[63] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[76] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[334]))[78] = SCM_WORD(scm__rc.d1950[138]);\n", "  ScmObj G1958 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[12]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[182]) /* vector-unfold! */, G1958,0);\n", "\n", "  scm__rc.d1950[197] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[38])),TRUE); /* vector-unfold-right! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[202]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[206] = Scm_MakeExtendedPair(scm__rc.d1950[197], SCM_OBJ(&scm__rc.d1950[118]), SCM_OBJ(&scm__rc.d1950[204]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[207]), scm__rc.d1950[206]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[13]))->name = scm__rc.d1950[197];/* vector-unfold-right! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[14] = SCM_WORD(scm__rc.d1950[91]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[24] = SCM_WORD(scm__rc.d1950[183]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[34] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[45] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[52] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[63] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[76] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[420]))[78] = SCM_WORD(scm__rc.d1950[150]);\n", "  ScmObj G1959 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[13]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[197]) /* vector-unfold-right! */, G1959,0);\n", "\n", "  scm__rc.d1950[209] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[39])),TRUE); /* %vector-reverse-copy! */\n", "  scm__rc.d1950[210] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[40])),TRUE); /* target */\n", "  scm__rc.d1950[211] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[41])),TRUE); /* tstart */\n", "  scm__rc.d1950[212] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[42])),TRUE); /* source */\n", "  scm__rc.d1950[213] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[43])),TRUE); /* sstart */\n", "  scm__rc.d1950[214] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[44])),TRUE); /* send */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[215]), scm__rc.d1950[214]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[217]), scm__rc.d1950[213]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[219]), scm__rc.d1950[212]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[221]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[223]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[229]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[233] = Scm_MakeExtendedPair(scm__rc.d1950[209], SCM_OBJ(&scm__rc.d1950[223]), SCM_OBJ(&scm__rc.d1950[231]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[234]), scm__rc.d1950[233]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[14]))->name = scm__rc.d1950[209];/* %vector-reverse-copy! */\n", "  ScmObj G1960 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[14]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[209]) /* %vector-reverse-copy! */, G1960,0);\n", "\n", "  scm__rc.d1950[236] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[45])),TRUE); /* vector-reverse-copy */\n", "  scm__rc.d1950[237] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[47])),TRUE); /* vec */\n", "  scm__rc.d1950[238] = Scm_MakeKeyword(SCM_STRING(SCM_OBJ(&scm__sc.d1951[48]))); /* optional */\n", "  scm__rc.d1950[239] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[49])),TRUE); /* start */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[240]), scm__rc.d1950[239]);\n", "  scm__rc.d1950[242] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[50])),TRUE); /* end */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[245]), scm__rc.d1950[242]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[251]), scm__rc.d1950[238]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[253]), scm__rc.d1950[237]);\n", "  scm__rc.d1950[255] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[51])),TRUE); /* receive */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[258]), scm__rc.d1950[242]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[260]), scm__rc.d1950[239]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[262]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[264]), scm__rc.d1950[2]);\n", "  scm__rc.d1950[266] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[52])),TRUE); /* rlet1 */\n", "  scm__rc.d1950[267] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[53])),TRUE); /* - */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[268]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[270]), scm__rc.d1950[18]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[272]), scm__rc.d1950[267]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[276]), scm__rc.d1950[153]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[278]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[282]), scm__rc.d1950[91]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[284]), scm__rc.d1950[209]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[290]), scm__rc.d1950[91]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[292]), scm__rc.d1950[266]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[300]), scm__rc.d1950[255]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[306]), scm__rc.d1950[64]);\n", "  scm__rc.d1950[308] = Scm_MakeIdentifier(scm__rc.d1950[2], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-check-start+end */\n", "  scm__rc.d1950[309] = Scm_MakeIdentifier(scm__rc.d1950[209], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-reverse-copy! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[314]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[318] = Scm_MakeExtendedPair(scm__rc.d1950[236], SCM_OBJ(&scm__rc.d1950[253]), SCM_OBJ(&scm__rc.d1950[316]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[319]), scm__rc.d1950[318]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[15]))->name = scm__rc.d1950[236];/* vector-reverse-copy */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[525]))[44] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[525]))[53] = SCM_WORD(scm__rc.d1950[308]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[525]))[61] = SCM_WORD(scm__rc.d1950[152]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[525]))[71] = SCM_WORD(scm__rc.d1950[309]);\n", "  ScmObj G1965 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[15]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[236]) /* vector-reverse-copy */, G1965,0);\n", "\n", "  scm__rc.d1950[321] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[54])),TRUE); /* vector-reverse-copy! */\n", "  scm__rc.d1950[322] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[55])),TRUE); /* src */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[323]), scm__rc.d1950[213]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[325]), scm__rc.d1950[214]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[331]), scm__rc.d1950[238]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[333]), scm__rc.d1950[322]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[335]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[337]), scm__rc.d1950[210]);\n", "  scm__rc.d1950[339] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[56])),TRUE); /* assume-type */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[340]), scm__rc.d1950[4]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[342]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[344]), scm__rc.d1950[339]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[346]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[348]), scm__rc.d1950[45]);\n", "  scm__rc.d1950[350] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[57])),TRUE); /* let1 */\n", "  scm__rc.d1950[351] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[58])),TRUE); /* tlen */\n", "  scm__rc.d1950[352] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[59])),TRUE); /* vector-length */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[353]), scm__rc.d1950[352]);\n", "  scm__rc.d1950[355] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[60])),TRUE); /* unless */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[356]), scm__rc.d1950[351]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[358]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[362]), scm__rc.d1950[14]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[364]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[368]), scm__rc.d1950[16]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[374]), scm__rc.d1950[355]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[376]), scm__rc.d1950[214]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[378]), scm__rc.d1950[213]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[380]), scm__rc.d1950[322]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[382]), scm__rc.d1950[2]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[384]), scm__rc.d1950[351]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[386]), scm__rc.d1950[267]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[392]), scm__rc.d1950[14]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[396]), scm__rc.d1950[16]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[402]), scm__rc.d1950[355]);\n", "  scm__rc.d1950[404] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[63])),TRUE); /* if */\n", "  scm__rc.d1950[405] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[64])),TRUE); /* and */\n", "  scm__rc.d1950[406] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[65])),TRUE); /* eq? */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[407]), scm__rc.d1950[322]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[409]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[411]), scm__rc.d1950[406]);\n", "  scm__rc.d1950[413] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[66])),TRUE); /* or */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[414]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[416]), scm__rc.d1950[14]);\n", "  scm__rc.d1950[418] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[67])),TRUE); /* < */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[419]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[421]), scm__rc.d1950[418]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[427]), scm__rc.d1950[405]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[429]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[431]), scm__rc.d1950[418]);\n", "  scm__rc.d1950[433] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[68])),TRUE); /* + */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[434]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[436]), scm__rc.d1950[433]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[440]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[442]), scm__rc.d1950[418]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[448]), scm__rc.d1950[405]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[454]), scm__rc.d1950[413]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[460]), scm__rc.d1950[405]);\n", "  scm__rc.d1950[462] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[69])),TRUE); /* begin */\n", "  scm__rc.d1950[463] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[70])),TRUE); /* vector-copy! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[464]), scm__rc.d1950[322]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[466]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[468]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[470]), scm__rc.d1950[463]);\n", "  scm__rc.d1950[472] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[71])),TRUE); /* %vector-reverse! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[473]), scm__rc.d1950[211]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[475]), scm__rc.d1950[210]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[477]), scm__rc.d1950[472]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[483]), scm__rc.d1950[462]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[485]), scm__rc.d1950[209]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[493]), scm__rc.d1950[404]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[503]), scm__rc.d1950[255]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[511]), scm__rc.d1950[351]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[513]), scm__rc.d1950[350]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[523]), scm__rc.d1950[64]);\n", "  scm__rc.d1950[525] = Scm_MakeIdentifier(scm__rc.d1950[463], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-copy! */\n", "  scm__rc.d1950[526] = Scm_MakeIdentifier(scm__rc.d1950[472], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-reverse! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[531]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[535] = Scm_MakeExtendedPair(scm__rc.d1950[321], SCM_OBJ(&scm__rc.d1950[337]), SCM_OBJ(&scm__rc.d1950[533]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[536]), scm__rc.d1950[535]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[16]))->name = scm__rc.d1950[321];/* vector-reverse-copy! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[44] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[49] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[51] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[59] = SCM_WORD(scm__rc.d1950[210]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[61] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[64] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[69] = SCM_WORD(scm__rc.d1950[183]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[79] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[90] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[99] = SCM_WORD(scm__rc.d1950[308]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[119] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[155] = SCM_WORD(scm__rc.d1950[525]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[163] = SCM_WORD(scm__rc.d1950[526]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[598]))[171] = SCM_WORD(scm__rc.d1950[309]);\n", "  ScmObj G1970 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[16]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[321]) /* vector-reverse-copy! */, G1970,0);\n", "\n", "  scm__rc.d1950[538] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[72])),TRUE); /* vector-concatenate */\n", "  scm__rc.d1950[540] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[73])),TRUE); /* vector-append */\n", "  scm__rc.d1950[539] = Scm_MakeIdentifier(scm__rc.d1950[540], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-append */\n", "  scm__rc.d1950[541] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[74])),TRUE); /* vecs */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[542]), scm__rc.d1950[541]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[548]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[552] = Scm_MakeExtendedPair(scm__rc.d1950[538], SCM_OBJ(&scm__rc.d1950[542]), SCM_OBJ(&scm__rc.d1950[550]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[553]), scm__rc.d1950[552]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[17]))->name = scm__rc.d1950[538];/* vector-concatenate */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[774]))[1] = SCM_WORD(scm__rc.d1950[539]);\n", "  ScmObj G1971 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[17]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[538]) /* vector-concatenate */, G1971,0);\n", "\n", "  scm__rc.d1950[555] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[75])),TRUE); /* vector-append-subvectors */\n", "  scm__rc.d1950[557] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[76])),TRUE); /* slices */\n", "  scm__rc.d1950[556] = Scm_MakeIdentifier(scm__rc.d1950[557], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#slices */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[560]), scm__rc.d1950[555]);\n", "  scm__rc.d1950[562] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[80])),TRUE); /* sv */\n", "  scm__rc.d1950[563] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[81])),TRUE); /* c */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[564]), scm__rc.d1950[563]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[566]), scm__rc.d1950[562]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[572]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[576] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[560]), SCM_OBJ(&scm__rc.d1950[566]), SCM_OBJ(&scm__rc.d1950[574]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[577]), scm__rc.d1950[576]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[779]))[38] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[779]))[48] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[779]))[57] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[779]))[73] = SCM_WORD(scm__rc.d1950[15]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[779]))[91] = SCM_WORD(scm__rc.d1950[184]);\n", "  scm__rc.d1950[580] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[82])),TRUE); /* fold */\n", "  scm__rc.d1950[579] = Scm_MakeIdentifier(scm__rc.d1950[580], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#fold */\n", "  scm__rc.d1950[582] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[83])),TRUE); /* match:error */\n", "  scm__rc.d1950[584] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[84])),TRUE); /* util.match */\n", "  scm__rc.d1950[583] = SCM_OBJ(Scm_FindModule(SCM_SYMBOL(scm__rc.d1950[584]), SCM_FIND_MODULE_CREATE)); /* module util.match */\n", "  scm__rc.d1950[581] = Scm_MakeIdentifier(scm__rc.d1950[582], SCM_MODULE(scm__rc.d1950[583]), SCM_NIL); /* util.match#match:error */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[589]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[593] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[560]), SCM_OBJ(&scm__rc.d1950[566]), SCM_OBJ(&scm__rc.d1950[591]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[594]), scm__rc.d1950[593]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[881]))[34] = SCM_WORD(scm__rc.d1950[525]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[881]))[42] = SCM_WORD(scm__rc.d1950[581]);\n", "  scm__rc.d1950[596] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[85])),TRUE); /* args */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[601]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[605] = Scm_MakeExtendedPair(scm__rc.d1950[555], scm__rc.d1950[596], SCM_OBJ(&scm__rc.d1950[603]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[606]), scm__rc.d1950[605]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[20]))->name = scm__rc.d1950[555];/* vector-append-subvectors */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[934]))[5] = SCM_WORD(scm__rc.d1950[556]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[934]))[15] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[934]))[21] = SCM_WORD(scm__rc.d1950[152]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[934]))[31] = SCM_WORD(scm__rc.d1950[579]);\n", "  ScmObj G1977 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[20]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[555]) /* vector-append-subvectors */, G1977,0);\n", "\n", "  scm__rc.d1950[608] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[86])),TRUE); /* vector-empty? */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[609]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[615]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[619] = Scm_MakeExtendedPair(scm__rc.d1950[608], SCM_OBJ(&scm__rc.d1950[609]), SCM_OBJ(&scm__rc.d1950[617]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[620]), scm__rc.d1950[619]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[21]))->name = scm__rc.d1950[608];/* vector-empty? */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[967]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[967]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[967]))[14] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[967]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[967]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ScmObj G1978 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[21]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[608]) /* vector-empty? */, G1978,0);\n", "\n", "  scm__rc.d1950[622] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[87])),TRUE); /* vector= */\n", "  scm__rc.d1950[623] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[88])),TRUE); /* pairwise= */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[624]), scm__rc.d1950[623]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[626]), scm__rc.d1950[622]);\n", "  scm__rc.d1950[628] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[89])),TRUE); /* va */\n", "  scm__rc.d1950[629] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[90])),TRUE); /* vb */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[630]), scm__rc.d1950[629]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[632]), scm__rc.d1950[628]);\n", "  scm__rc.d1950[634] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[626]), SCM_OBJ(&scm__rc.d1950[632]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[635]), scm__rc.d1950[634]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[22]))->name = scm__rc.d1950[623];/* (vector= pairwise=) */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[639]), scm__rc.d1950[622]);\n", "  scm__rc.d1950[641] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[91])),TRUE); /* w */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[642]), scm__rc.d1950[641]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[648]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[652] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[639]), SCM_OBJ(&scm__rc.d1950[642]), SCM_OBJ(&scm__rc.d1950[650]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[653]), scm__rc.d1950[652]);\n", "  scm__rc.d1950[656] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[92])),TRUE); /* every */\n", "  scm__rc.d1950[655] = Scm_MakeIdentifier(scm__rc.d1950[656], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#every */\n", "  scm__rc.d1950[657] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[93])),TRUE); /* elt= */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[658]), scm__rc.d1950[657]);\n", "  SCM_SET_CDR(SCM_OBJ(&scm__rc.d1950[658]), scm__rc.d1950[541]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[664]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[668] = Scm_MakeExtendedPair(scm__rc.d1950[622], SCM_OBJ(&scm__rc.d1950[658]), SCM_OBJ(&scm__rc.d1950[666]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[669]), scm__rc.d1950[668]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[24]))->name = scm__rc.d1950[622];/* vector= */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[18] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[20] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[28] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[30] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[33] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[44] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[46] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[54] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[56] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[59] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[72] = SCM_WORD(scm__rc.d1950[655]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[80] = SCM_WORD(scm__rc.d1950[655]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1023]))[84] = SCM_WORD(scm__rc.d1950[581]);\n", "  ScmObj G1983 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[24]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[622]) /* vector= */, G1983,0);\n", "\n", "  scm__rc.d1950[672] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[94])),TRUE); /* min */\n", "  scm__rc.d1950[671] = Scm_MakeIdentifier(scm__rc.d1950[672], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#min */\n", "  scm__rc.d1950[673] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[95])),FALSE); /* G1984 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[674]), scm__rc.d1950[673]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[678]), scm__rc.d1950[154]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[680]), scm__rc.d1950[10]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[686]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[690] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[676]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[688]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[691]), scm__rc.d1950[690]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1109]))[28] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[695] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[96])),TRUE); /* proc */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[696]), scm__rc.d1950[100]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[698]), scm__rc.d1950[695]);\n", "  scm__rc.d1950[700] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[97])),TRUE); /* vs */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[701]), scm__rc.d1950[10]);\n", "  SCM_SET_CDR(SCM_OBJ(&scm__rc.d1950[701]), scm__rc.d1950[700]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[703]), scm__rc.d1950[100]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[705]), scm__rc.d1950[695]);\n", "  scm__rc.d1950[711] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[698]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[712]), scm__rc.d1950[711]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1142]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1142]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1142]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1142]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1142]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  scm__rc.d1950[716] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[98])),TRUE); /* x */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[717]), scm__rc.d1950[716]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[723]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[727] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[725]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[728]), scm__rc.d1950[727]);\n", "  scm__rc.d1950[731] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[99])),TRUE); /* map */\n", "  scm__rc.d1950[730] = Scm_MakeIdentifier(scm__rc.d1950[731], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#map */\n", "  scm__rc.d1950[732] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[705]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[733]), scm__rc.d1950[732]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1191]))[10] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1191]))[31] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[735] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[100])),TRUE); /* vector-fold */\n", "  scm__rc.d1950[736] = Scm_MakeIdentifier(scm__rc.d1950[735], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-fold */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[29]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1229]))[16] = SCM_WORD(scm__rc.d1950[735]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1229]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1229]))[20] = SCM_WORD(scm__rc.d1950[736]);\n", "  scm__rc.d1950[737] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[101])),FALSE); /* G1985 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[738]), scm__rc.d1950[737]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[746]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[750] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[740]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[748]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[751]), scm__rc.d1950[750]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1251]))[28] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[755] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[698]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[756]), scm__rc.d1950[755]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1284]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1284]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1284]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1284]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1284]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[762]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[766] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[764]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[767]), scm__rc.d1950[766]);\n", "  scm__rc.d1950[769] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[705]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[770]), scm__rc.d1950[769]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1333]))[10] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1333]))[31] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[772] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[102])),TRUE); /* vector-fold-right */\n", "  scm__rc.d1950[773] = Scm_MakeIdentifier(scm__rc.d1950[772], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-fold-right */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[34]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1371]))[16] = SCM_WORD(scm__rc.d1950[772]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1371]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1371]))[20] = SCM_WORD(scm__rc.d1950[773]);\n", "  scm__rc.d1950[774] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[103])),TRUE); /* pred */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[775]), scm__rc.d1950[774]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[777]), scm__rc.d1950[774]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[783]), scm__rc.d1950[563]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[789]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[793] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[783]), SCM_OBJ(&scm__rc.d1950[791]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[794]), scm__rc.d1950[793]);\n", "  scm__rc.d1950[796] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[775]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[797]), scm__rc.d1950[796]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1403]))[6] = SCM_WORD(scm__rc.d1950[736]);\n", "  scm__rc.d1950[799] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[104])),TRUE); /* es */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[800]), scm__rc.d1950[563]);\n", "  SCM_SET_CDR(SCM_OBJ(&scm__rc.d1950[800]), scm__rc.d1950[799]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[806]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[810] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[800]), SCM_OBJ(&scm__rc.d1950[808]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[811]), scm__rc.d1950[810]);\n", "  scm__rc.d1950[813] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[814]), scm__rc.d1950[813]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1421]))[1] = SCM_WORD(scm__rc.d1950[736]);\n", "  scm__rc.d1950[816] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[105])),TRUE); /* vector-count */\n", "  scm__rc.d1950[817] = Scm_MakeIdentifier(scm__rc.d1950[816], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-count */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[39]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1431]))[14] = SCM_WORD(scm__rc.d1950[816]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1431]))[16] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1431]))[18] = SCM_WORD(scm__rc.d1950[817]);\n", "  scm__rc.d1950[818] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[106])),TRUE); /* vector-cumulate */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[819]), scm__rc.d1950[100]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[821]), scm__rc.d1950[90]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[827]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[831] = Scm_MakeExtendedPair(scm__rc.d1950[818], SCM_OBJ(&scm__rc.d1950[821]), SCM_OBJ(&scm__rc.d1950[829]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[832]), scm__rc.d1950[831]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[40]))->name = scm__rc.d1950[818];/* vector-cumulate */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[14] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1451]))[27] = SCM_WORD(scm__rc.d1950[152]);\n", "  ScmObj G1986 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[40]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[818]) /* vector-cumulate */, G1986,0);\n", "\n", "  scm__rc.d1950[834] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[107])),FALSE); /* G1987 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[835]), scm__rc.d1950[834]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[843]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[847] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[837]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[845]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[848]), scm__rc.d1950[847]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1509]))[28] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[852] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[775]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[853]), scm__rc.d1950[852]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1542]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1542]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1542]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1542]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1542]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[859]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[863] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[861]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[864]), scm__rc.d1950[863]);\n", "  scm__rc.d1950[866] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[867]), scm__rc.d1950[866]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1591]))[10] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1591]))[28] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[869] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[108])),TRUE); /* vector-index */\n", "  scm__rc.d1950[870] = Scm_MakeIdentifier(scm__rc.d1950[869], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-index */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[45]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1629]))[16] = SCM_WORD(scm__rc.d1950[869]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1629]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1629]))[20] = SCM_WORD(scm__rc.d1950[870]);\n", "  scm__rc.d1950[871] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[109])),FALSE); /* G1988 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[872]), scm__rc.d1950[871]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[880]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[884] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[874]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[882]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[885]), scm__rc.d1950[884]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1651]))[28] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[889] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[775]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[890]), scm__rc.d1950[889]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1684]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1684]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1684]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1684]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1684]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[896]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[900] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[898]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[901]), scm__rc.d1950[900]);\n", "  scm__rc.d1950[903] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[904]), scm__rc.d1950[903]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1733]))[10] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1733]))[28] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[906] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[110])),TRUE); /* vector-index-right */\n", "  scm__rc.d1950[907] = Scm_MakeIdentifier(scm__rc.d1950[906], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-index-right */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[50]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1771]))[16] = SCM_WORD(scm__rc.d1950[906]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1771]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1771]))[20] = SCM_WORD(scm__rc.d1950[907]);\n", "  scm__rc.d1950[908] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[111])),TRUE); /* vector-skip */\n", "  scm__rc.d1950[910] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[112])),TRUE); /* complement */\n", "  scm__rc.d1950[909] = Scm_MakeIdentifier(scm__rc.d1950[910], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#complement */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[915]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[919] = Scm_MakeExtendedPair(scm__rc.d1950[908], SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[917]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[920]), scm__rc.d1950[919]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[51]))->name = scm__rc.d1950[908];/* vector-skip */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1793]))[1] = SCM_WORD(scm__rc.d1950[870]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1793]))[6] = SCM_WORD(scm__rc.d1950[909]);\n", "  ScmObj G1989 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[51]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[908]) /* vector-skip */, G1989,0);\n", "\n", "  scm__rc.d1950[922] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[113])),TRUE); /* vector-skip-right */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[927]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[931] = Scm_MakeExtendedPair(scm__rc.d1950[922], SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[929]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[932]), scm__rc.d1950[931]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[52]))->name = scm__rc.d1950[922];/* vector-skip-right */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1805]))[1] = SCM_WORD(scm__rc.d1950[907]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1805]))[6] = SCM_WORD(scm__rc.d1950[909]);\n", "  ScmObj G1990 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[52]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[922]) /* vector-skip-right */, G1990,0);\n", "\n", "  scm__rc.d1950[934] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[114])),TRUE); /* vector-binary-search */\n", "  scm__rc.d1950[935] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[115])),TRUE); /* value */\n", "  scm__rc.d1950[936] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[116])),TRUE); /* cmp */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[937]), scm__rc.d1950[936]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[939]), scm__rc.d1950[935]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[941]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[943]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[945]), scm__rc.d1950[339]);\n", "  scm__rc.d1950[947] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[117])),TRUE); /* not */\n", "  scm__rc.d1950[948] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[118])),TRUE); /* = */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[949]), scm__rc.d1950[948]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[953]), scm__rc.d1950[947]);\n", "  scm__rc.d1950[955] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[119])),TRUE); /* let */\n", "  scm__rc.d1950[956] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[120])),TRUE); /* rec */\n", "  scm__rc.d1950[957] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[121])),TRUE); /* lo */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[958]), scm__rc.d1950[957]);\n", "  scm__rc.d1950[960] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[122])),TRUE); /* hi */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[961]), scm__rc.d1950[960]);\n", "  scm__rc.d1950[967] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[123])),TRUE); /* let* */\n", "  scm__rc.d1950[968] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[124])),TRUE); /* mid */\n", "  scm__rc.d1950[969] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[125])),TRUE); /* ash */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[970]), scm__rc.d1950[960]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[972]), scm__rc.d1950[957]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[974]), scm__rc.d1950[433]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[978]), scm__rc.d1950[969]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[982]), scm__rc.d1950[968]);\n", "  scm__rc.d1950[984] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[126])),TRUE); /* r */\n", "  scm__rc.d1950[985] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[127])),TRUE); /* vector-ref */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[986]), scm__rc.d1950[968]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[988]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[990]), scm__rc.d1950[985]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[992]), scm__rc.d1950[935]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[996]), scm__rc.d1950[936]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1000]), scm__rc.d1950[984]);\n", "  scm__rc.d1950[1006] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[128])),TRUE); /* cond */\n", "  scm__rc.d1950[1007] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[129])),TRUE); /* zero? */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1008]), scm__rc.d1950[984]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1010]), scm__rc.d1950[1007]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1014]), scm__rc.d1950[957]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1016]), scm__rc.d1950[948]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1020]), scm__rc.d1950[984]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1022]), scm__rc.d1950[418]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1024]), scm__rc.d1950[968]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1026]), scm__rc.d1950[956]);\n", "  scm__rc.d1950[1032] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[130])),TRUE); /* else */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1033]), scm__rc.d1950[956]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1037]), scm__rc.d1950[1032]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1047]), scm__rc.d1950[1006]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1053]), scm__rc.d1950[967]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1059]), scm__rc.d1950[956]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1061]), scm__rc.d1950[955]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1067]), scm__rc.d1950[405]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1075]), scm__rc.d1950[255]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1083]), scm__rc.d1950[64]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1089]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1093] = Scm_MakeExtendedPair(scm__rc.d1950[934], SCM_OBJ(&scm__rc.d1950[941]), SCM_OBJ(&scm__rc.d1950[1091]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1094]), scm__rc.d1950[1093]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[53]))->name = scm__rc.d1950[934];/* vector-binary-search */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[44] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[49] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[51] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[59] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[61] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[64] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1817]))[73] = SCM_WORD(scm__rc.d1950[308]);\n", "  ScmObj G1995 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[53]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[934]) /* vector-binary-search */, G1995,0);\n", "\n", "  scm__rc.d1950[1096] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[131])),FALSE); /* G1996 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1097]), scm__rc.d1950[1096]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1105]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1109] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[1099]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[1107]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1110]), scm__rc.d1950[1109]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1936]))[25] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[1114] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[775]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1115]), scm__rc.d1950[1114]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1963]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1963]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1963]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1963]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[1963]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  scm__rc.d1950[1117] = \n", "SCM_POSITIVE_INFINITY;\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1122]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1126] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[1124]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1127]), scm__rc.d1950[1126]);\n", "  scm__rc.d1950[1129] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1130]), scm__rc.d1950[1129]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2010]))[8] = SCM_WORD(scm__rc.d1950[1117]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2010]))[11] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2010]))[29] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[1132] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[132])),TRUE); /* vector-any */\n", "  scm__rc.d1950[1133] = Scm_MakeIdentifier(scm__rc.d1950[1132], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-any */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[58]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2047]))[16] = SCM_WORD(scm__rc.d1950[1132]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2047]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2047]))[20] = SCM_WORD(scm__rc.d1950[1133]);\n", "  scm__rc.d1950[1134] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[133])),FALSE); /* G1997 */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1135]), scm__rc.d1950[1134]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1143]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1147] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[1137]), SCM_OBJ(&scm__rc.d1950[680]), SCM_OBJ(&scm__rc.d1950[1145]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1148]), scm__rc.d1950[1147]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2069]))[25] = SCM_WORD(scm__rc.d1950[671]);\n", "  scm__rc.d1950[1152] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[775]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1153]), scm__rc.d1950[1152]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2096]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2096]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2096]))[14] = SCM_WORD(scm__rc.d1950[10]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2096]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2096]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1159]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1163] = Scm_MakeExtendedPair(SCM_OBJ(&scm__rc.d1950[714]), SCM_OBJ(&scm__rc.d1950[717]), SCM_OBJ(&scm__rc.d1950[1161]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1164]), scm__rc.d1950[1163]);\n", "  scm__rc.d1950[1166] = Scm_MakeExtendedPair(SCM_FALSE, SCM_OBJ(&scm__rc.d1950[777]), SCM_OBJ(&scm__rc.d1950[38]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1167]), scm__rc.d1950[1166]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2148]))[8] = SCM_WORD(scm__rc.d1950[1117]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2148]))[11] = SCM_WORD(scm__rc.d1950[579]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2148]))[31] = SCM_WORD(scm__rc.d1950[730]);\n", "  scm__rc.d1950[1169] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[134])),TRUE); /* vector-every */\n", "  scm__rc.d1950[1170] = Scm_MakeIdentifier(scm__rc.d1950[1169], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#vector-every */\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[63]))->name = scm__rc.d1950[139];/* %toplevel */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2190]))[16] = SCM_WORD(scm__rc.d1950[1169]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2190]))[18] = SCM_WORD(scm__rc.d1950[136]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2190]))[20] = SCM_WORD(scm__rc.d1950[1170]);\n", "  scm__rc.d1950[1171] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[135])),TRUE); /* vector-partition */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1172]), scm__rc.d1950[774]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1178]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1182] = Scm_MakeExtendedPair(scm__rc.d1950[1171], SCM_OBJ(&scm__rc.d1950[1172]), SCM_OBJ(&scm__rc.d1950[1180]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1183]), scm__rc.d1950[1182]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[64]))->name = scm__rc.d1950[1171];/* vector-partition */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[14] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2212]))[27] = SCM_WORD(scm__rc.d1950[152]);\n", "  ScmObj G1998 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[64]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[1171]) /* vector-partition */, G1998,0);\n", "\n", "  scm__rc.d1950[1185] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[136])),TRUE); /* %vector-swap! */\n", "  scm__rc.d1950[1186] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[137])),TRUE); /* i */\n", "  scm__rc.d1950[1187] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[138])),TRUE); /* j */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1188]), scm__rc.d1950[1187]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1190]), scm__rc.d1950[1186]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1192]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1198]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1202] = Scm_MakeExtendedPair(scm__rc.d1950[1185], SCM_OBJ(&scm__rc.d1950[1192]), SCM_OBJ(&scm__rc.d1950[1200]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1203]), scm__rc.d1950[1202]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[65]))->name = scm__rc.d1950[1185];/* %vector-swap! */\n", "  ScmObj G1999 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[65]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[1185]) /* %vector-swap! */, G1999,0);\n", "\n", "  scm__rc.d1950[1205] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[139])),TRUE); /* vector-swap! */\n", "  scm__rc.d1950[1206] = Scm_MakeIdentifier(scm__rc.d1950[1185], SCM_MODULE(scm__rc.d1950[5]), SCM_NIL); /* srfi-133#%vector-swap! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1211]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1215] = Scm_MakeExtendedPair(scm__rc.d1950[1205], SCM_OBJ(&scm__rc.d1950[1192]), SCM_OBJ(&scm__rc.d1950[1213]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1216]), scm__rc.d1950[1215]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[66]))->name = scm__rc.d1950[1205];/* vector-swap! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[4] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[6] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[14] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[16] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[19] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[24] = SCM_WORD(scm__rc.d1950[183]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[35] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[46] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[53] = SCM_WORD(scm__rc.d1950[13]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[64] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2313]))[69] = SCM_WORD(scm__rc.d1950[1206]);\n", "  ScmObj G2000 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[66]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[1205]) /* vector-swap! */, G2000,0);\n", "\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1222]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1226] = Scm_MakeExtendedPair(scm__rc.d1950[472], SCM_OBJ(&scm__rc.d1950[278]), SCM_OBJ(&scm__rc.d1950[1224]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1227]), scm__rc.d1950[1226]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[67]))->name = scm__rc.d1950[472];/* %vector-reverse! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2384]))[13] = SCM_WORD(scm__rc.d1950[1206]);\n", "  ScmObj G2001 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[67]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[472]) /* %vector-reverse! */, G2001,0);\n", "\n", "  scm__rc.d1950[1229] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[142])),TRUE); /* vector-reverse! */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1230]), scm__rc.d1950[45]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1232]), scm__rc.d1950[472]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1240]), scm__rc.d1950[255]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1250]), scm__rc.d1950[64]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1256]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1260] = Scm_MakeExtendedPair(scm__rc.d1950[1229], SCM_OBJ(&scm__rc.d1950[253]), SCM_OBJ(&scm__rc.d1950[1258]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1261]), scm__rc.d1950[1260]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[68]))->name = scm__rc.d1950[1229];/* vector-reverse! */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[44] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[49] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[51] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[59] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[61] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[64] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[69] = SCM_WORD(scm__rc.d1950[183]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[78] = SCM_WORD(scm__rc.d1950[308]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2404]))[84] = SCM_WORD(scm__rc.d1950[526]);\n", "  ScmObj G2006 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[68]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[1229]) /* vector-reverse! */, G2006,0);\n", "\n", "  scm__rc.d1950[1263] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[143])),TRUE); /* reverse-vector->list */\n", "  scm__rc.d1950[1264] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[144])),TRUE); /* do */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1265]), scm__rc.d1950[1186]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1267]), scm__rc.d1950[433]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1271]), scm__rc.d1950[17]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1273]), scm__rc.d1950[1186]);\n", "  scm__rc.d1950[1275] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[145])),TRUE); /* quote */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1278]), scm__rc.d1950[1275]);\n", "  scm__rc.d1950[1280] = Scm_MakeSymbol(SCM_STRING(SCM_OBJ(&scm__sc.d1951[146])),TRUE); /* cons */\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1281]), scm__rc.d1950[1186]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1283]), scm__rc.d1950[237]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1285]), scm__rc.d1950[985]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1289]), scm__rc.d1950[1280]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1295]), scm__rc.d1950[984]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1301]), scm__rc.d1950[1186]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1303]), scm__rc.d1950[948]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1311]), scm__rc.d1950[1264]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1319]), scm__rc.d1950[255]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1327]), scm__rc.d1950[64]);\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1333]), scm__rc.d1950[28]);\n", "  scm__rc.d1950[1337] = Scm_MakeExtendedPair(scm__rc.d1950[1263], SCM_OBJ(&scm__rc.d1950[253]), SCM_OBJ(&scm__rc.d1950[1335]));\n", "  SCM_SET_CAR(SCM_OBJ(&scm__rc.d1950[1338]), scm__rc.d1950[1337]);\n", "  SCM_COMPILED_CODE(SCM_OBJ(&scm__rc.d1953[69]))->name = scm__rc.d1950[1263];/* reverse-vector->list */\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[44] = SCM_WORD(scm__rc.d1950[184]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[49] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[51] = SCM_WORD(scm__rc.d1950[6]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[59] = SCM_WORD(scm__rc.d1950[237]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[61] = SCM_WORD(scm__rc.d1950[3]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[64] = SCM_WORD(scm__rc.d1950[11]);\n", "  ((ScmWord*)SCM_OBJ(&scm__rc.d1952[2490]))[73] = SCM_WORD(scm__rc.d1950[308]);\n", "  ScmObj G2011 = Scm_MakeClosure(SCM_OBJ(&scm__rc.d1953[69]), NULL);\n", "\n", "  Scm_MakeBinding(SCM_MODULE(Scm_CurrentModule()) /*  */, SCM_SYMBOL(scm__rc.d1950[1263]) /* reverse-vector->list */, G2011,0);\n", "\n", "  Scm_VMExecuteToplevels(toplevels);\n", "}\n"], "project": "libgauche-0.9-0", "file": "srfi-133.pkl", "function": "Scm_Init_srfi_133"}, {"comment_all": {"comment": "/***\n * Matt's smaller s-expression parsing library\n *\n * Written by Matt Sottile (matt@lanl.gov), January 2002.\n ***/", "depth": 0, "reading_ease": 31.55, "reading_grade": 10.4, "line": 26}, "comment_text": "/***\n * Matt's smaller s-expression parsing library\n *\n * Written by Matt Sottile (matt@lanl.gov), January 2002.\n ***/", "comment_tokens": ["Matt", "'s", "smaller", "s-expression", "parsing", "library", "Written", "by", "Matt", "Sottile", "(", "matt", "@", "lanl.gov", ")", ",", "January", "2002", "."], "ccode": ["/**\n", "This software and ancillary information (herein called \"SOFTWARE\")\n", "called Supermon is made available under the terms described\n", "here.  The SOFTWARE has been approved for release with associated\n", "LA-CC Number LA-CC 99-51.\n", "\n", "Unless otherwise indicated, this SOFTWARE has been authored by an\n", "employee or employees of the University of California, operator of the\n", "Los Alamos National Laboratory under Contract No.  W-7405-ENG-36 with\n", "the U.S. Department of Energy.  The U.S. Government has rights to use,\n", "reproduce, and distribute this SOFTWARE, and to allow others to do so.\n", "The public may copy, distribute, prepare derivative works and publicly\n", "display this SOFTWARE without charge, provided that this Notice and\n", "any statement of authorship are reproduced on all copies.  Neither the\n", "Government nor the University makes any warranty, express or implied,\n", "or assumes any liability or responsibility for the use of this\n", "SOFTWARE.\n", "\n", "If SOFTWARE is modified to produce derivative works, such modified\n", "SOFTWARE should be clearly marked, so as not to confuse it with the\n", "version available from LANL.\n", "**/\n", "/** NOTICE: This software is licensed under the GNU Public License, which\n", "    is included as LICENSE_GPL in this source distribution. **/\n", "/** NOTE: This library is part of the supermon project, hence the name\n", "          supermon above. **/\n", "/***\n", " * Matt's smaller s-expression parsing library\n", " *\n", " * Written by Matt Sottile (matt@lanl.gov), January 2002.\n", " ***/\n", "\n", "#include <assert.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"sexp.h\"\n", "#include \"faststack.h\"\n", "\n", "/**\n", " * Recursively walk an s-expression and free it.\n", " */\n", "void\n", "destroy_sexp (sexp_t * s)\n", "{\n", "  if (s == NULL) {\n", "    return;\n", "  }\n", "\n", "  if (s->ty == SEXP_LIST)\n", "    destroy_sexp (s->list);\n", "\n", "  if (s->ty == SEXP_VALUE && s->val != NULL)\n", "    free(s->val);\n", "\n", "  destroy_sexp (s->next);\n", "\n", "  sexp_t_deallocate(s);\n", "}\n"], "project": "orbital-eunuchs-sniper", "file": "sexp.pkl", "function": "destroy_sexp"}, {"comment_all": {"comment": "/* If cancelled, mark all proposals correctly so that the fast marking\n\t   scheme still works */", "depth": 1, "reading_ease": 74.19, "reading_grade": 6.4, "line": 663}, "comment_text": "/* If cancelled, mark all proposals correctly so that the fast marking\n\t   scheme still works */", "comment_tokens": ["If", "cancelled", ",", "mark", "all", "proposals", "correctly", "so", "that", "the", "fast", "marking", "scheme", "still", "works"], "ccode": ["\n", "void\n", "gtk_source_completion_model_cancel (GtkSourceCompletionModel *model)\n", "{\n", "\tGList *item;\n", "\t\n", "\t/* If cancelled, mark all proposals correctly so that the fast marking\n", "\t   scheme still works */\n", "\tfor (item = model->priv->store; item != NULL; item = g_list_next (item))\n", "\t{\n", "\t\t((ProposalNode *)item->data)->mark = model->priv->marking;\n", "\t}\n", "}\n"], "project": "libgtksourceview2.0-0", "file": "gtksourcecompletionmodel.pkl", "function": "gtk_source_completion_model_cancel"}, {"comment_all": {"comment": "/* Copyright (c) 1992 AT&T - All rights reserved. */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 0}, "comment_text": "/* Copyright (c) 1992 AT&T - All rights reserved. */", "comment_tokens": ["Copyright", "(", "c", ")", "1992", "AT", "&", "T", "-", "All", "rights", "reserved", "."], "ccode": ["/* Copyright (c) 1992 AT&T - All rights reserved. */\n", "#include <libc.h>\n", "#include <libg.h>\n", "#include \"libgint.h\"\n", "\n", "void\n", "texture(Bitmap *d, Rectangle r, Bitmap *s, Fcode f)\n", "{\n", "\tint x, y, w, h, bfunc;\n", "\tGC g;\n", "\n", "\tx = r.min.x;\n", "\ty = r.min.y;\n", "\tif(d->flag&SHIFT){\n", "\t\tx -= d->r.min.x;\n", "\t\ty -= d->r.min.y;\n", "\t}\n", "\tg = _getcopygc(f, d, s, &bfunc);\n", "\tif(d->flag&SHIFT){\n", "\t\tXSetTSOrigin(_dpy, g, -d->r.min.x, -d->r.min.y);\n", "\t}else\n", "\t\tXSetTSOrigin(_dpy, g, 0, 0);\n", "\tw = Dx(r);\n", "\th = Dy(r);\n", "\tif(bfunc == UseFillRectangle){\n", "\t\t/* source isn't involved at all */\n", "\t\tXFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n", "\t}else if(bfunc == UseCopyArea){\n", "\t\tXSetTile(_dpy, g, (Drawable)s->id);\n", "\t\tXSetFillStyle(_dpy, g, FillTiled);\n", "\t\tXFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n", "\t\tXSetFillStyle(_dpy, g, FillSolid);\n", "\t}else{\n", "\t\tif(s->ldepth != 0)\n", "\t\t\tberror(\"unsupported texture\");\n", "\t\tXSetStipple(_dpy, g, (Drawable)s->id);\n", "\t\tXSetFillStyle(_dpy, g, FillOpaqueStippled);\n", "\t\tXFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);\n", "\t\tXSetFillStyle(_dpy, g, FillSolid);\n", "\t}\n", "}\n"], "project": "wily", "file": "texture.pkl", "function": "texture"}, {"comment_all": {"comment": "/* Add the given root structure to the index. */", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 131}, "comment_text": "/* Add the given root structure to the index. */", "comment_tokens": ["Add", "the", "given", "root", "structure", "to", "the", "index", "."], "ccode": ["\n", "/* Add the given root structure to the index. */\n", "static void add_roots_to_index(p)\n", "struct roots *p;\n", "{\n", "    register int h = rt_hash(p -> r_start);\n", "    \n", "    p -> r_next = GC_root_index[h];\n", "    GC_root_index[h] = p;\n", "}\n"], "project": "libmono-corlib4.5-cil", "file": "mark_rts.pkl", "function": "add_roots_to_index"}, {"comment_all": {"comment": "/* this simplified version of `fmod` that returns the remainder of double\n * division by 0xffffffff, which is enough for our purposes */", "depth": 0, "reading_ease": 51.18, "reading_grade": 11.1, "line": 369}, "comment_text": "/* this simplified version of `fmod` that returns the remainder of double\n * division by 0xffffffff, which is enough for our purposes */", "comment_tokens": ["this", "simplified", "version", "of", "`", "fmod", "`", "that", "returns", "the", "remainder", "of", "double", "division", "by", "0xffffffff", ",", "which", "is", "enough", "for", "our", "purposes"], "ccode": ["\n", "/* this simplified version of `fmod` that returns the remainder of double\n", " * division by 0xffffffff, which is enough for our purposes */\n", "static double mpack_fmod_pow2_32(double a)\n", "{\n", "  return a - ((double)(mpack_uint32_t)(a / POW2(32)) * POW2(32));\n", "}\n"], "project": "libmpack0", "file": "conv.pkl", "function": "mpack_fmod_pow2_32"}, {"comment_all": {"comment": "/* position and speed return to their default values */", "depth": 2, "reading_ease": 63.36, "reading_grade": 6.4, "line": 355}, "comment_text": "/* position and speed return to their default values */", "comment_tokens": ["position", "and", "speed", "return", "to", "their", "default", "values"], "ccode": ["\n", "static void\n", "stop_cb (GtkButton * button, gpointer data)\n", "{\n", "  GstState state;\n", "\n", "  gst_element_get_state (pipeline, &state, NULL, GST_CLOCK_TIME_NONE);\n", "  if (state != GST_STATE_READY) {\n", "    g_print (\"READY pipeline\\n\");\n", "    gst_element_set_state (pipeline, GST_STATE_READY);\n", "    /* position and speed return to their default values */\n", "    gtk_adjustment_set_value (adjustment, 0.0);\n", "    gtk_adjustment_set_value (sadjustment, 1.0);\n", "    g_source_remove (update_id);\n", "  }\n", "}\n"], "project": "libgstreamer-plugins-base1.0-0", "file": "scrubby.pkl", "function": "stop_cb"}, {"comment_all": {"comment": "/* yy_get_previous_state - get the state just before the EOB char was reached */", "depth": 0, "reading_ease": 77.23, "reading_grade": 5.2, "line": 1737}, "comment_text": "/* yy_get_previous_state - get the state just before the EOB char was reached */", "comment_tokens": ["yy_get_previous_state", "-", "get", "the", "state", "just", "before", "the", "EOB", "char", "was", "reached"], "ccode": ["\n", "\n", "/* yy_get_previous_state - get the state just before the EOB char was reached */\n", "\n", "static yy_state_type yy_get_previous_state()\n", "\t{\n", "\tregister yy_state_type yy_current_state;\n", "\tregister char *yy_cp;\n", "\n", "\tyy_current_state = yy_start;\n", "\tyy_state_ptr = yy_state_buf;\n", "\t*yy_state_ptr++ = yy_current_state;\n", "\n", "\tfor ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )\n", "\t\t{\n", "\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n", "\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n", "\t\t\t{\n", "\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n", "\t\t\tif ( yy_current_state >= 317 )\n", "\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n", "\t\t\t}\n", "\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n", "\t\t*yy_state_ptr++ = yy_current_state;\n", "\t\t}\n", "\n", "\treturn yy_current_state;\n", "\t}\n"], "project": "libcss-parser-pp0v5", "file": "css_lex.pkl", "function": "yy_get_previous_state"}, {"comment_all": {"comment": "/* Unlocking recursive lock or the lock was never locked. */", "depth": 2, "reading_ease": 62.34, "reading_grade": 6.8, "line": 50}, "comment_text": "/* Unlocking recursive lock or the lock was never locked. */", "comment_tokens": ["Unlocking", "recursive", "lock", "or", "the", "lock", "was", "never", "locked", "."], "ccode": ["\n", "/*\n", " * Exit task-exclusive mode.\n", " *\n", " * @param[in] inst  The instance used for previous run_exclusive_enter() call.\n", " * @param[in] state Lock state as returned by run_exclusive_enter().\n", " */\n", "void\n", "run_exclusive_exit(sample_instance_t *inst, isc_result_t state) {\n", "\tif (state == ISC_R_SUCCESS) {\n", "\t\tisc_task_endexclusive(inst->task);\n", "\t} else {\n", "\t\t/* Unlocking recursive lock or the lock was never locked. */\n", "\t\tINSIST(state == ISC_R_LOCKBUSY || state == ISC_R_IGNORE);\n", "\t}\n", "\n", "\treturn;\n", "}\n"], "project": "bind9utils", "file": "lock.pkl", "function": "run_exclusive_exit"}, {"comment_all": {"comment": "/* Start with the first file after going back into the main loop */", "depth": 1, "reading_ease": 84.68, "reading_grade": 4.4, "line": 142}, "comment_text": "/* Start with the first file after going back into the main loop */", "comment_tokens": ["Start", "with", "the", "first", "file", "after", "going", "back", "into", "the", "main", "loop"], "ccode": ["\n", "\n", "static GObject*\n", "gpa_stream_verify_operation_ctor (GType type, guint n_construct_properties,\n", "\t\t\t\t  GObjectConstructParam *construct_properties)\n", "{\n", "  GObject *object;\n", "  GpaStreamVerifyOperation *op;\n", "\n", "  object = parent_class->constructor (type, n_construct_properties,\n", "\t\t\t\t      construct_properties);\n", "  op = GPA_STREAM_VERIFY_OPERATION (object);\n", "\n", "  /* Start with the first file after going back into the main loop */\n", "  g_idle_add (idle_cb, op);\n", "\n", "  /* We connect the done signal to two handles.  The error handler is\n", "     called first.  */\n", "  g_signal_connect (G_OBJECT (GPA_OPERATION (op)->context), \"done\",\n", "\t\t    G_CALLBACK (done_error_cb), op);\n", "  g_signal_connect (G_OBJECT (GPA_OPERATION (op)->context), \"done\",\n", "\t\t    G_CALLBACK (done_cb), op);\n", "\n", "  /* FIXME: Implement silent option.  */\n", "  gtk_window_set_title\n", "    (GTK_WINDOW (GPA_STREAM_OPERATION (op)->progress_dialog),\n", "     _(\"Verifying message ...\"));\n", "\n", "  if (op->silent)\n", "    gtk_widget_hide (GPA_STREAM_OPERATION (op)->progress_dialog);\n", "  else\n", "    {\n", "      char *strval;\n", "\n", "      op->dialog = gpa_file_verify_dialog_new (GPA_OPERATION (op)->window);\n", "      g_signal_connect (G_OBJECT (op->dialog), \"response\",\n", "\t\t\tG_CALLBACK (response_cb), op);\n", "      g_object_get (G_OBJECT (op), \"client-title\", &strval, NULL);\n", "      gpa_file_verify_dialog_set_title (GPA_FILE_VERIFY_DIALOG (op->dialog),\n", "                                        strval);\n", "      g_free (strval);\n", "    }\n", "\n", "  return object;\n", "}\n"], "project": "gpa", "file": "gpastreamverifyop.pkl", "function": "gpa_stream_verify_operation_ctor"}, {"comment_all": {"comment": "/* convert to normal processing when we hit final_count */", "depth": 1, "reading_ease": 46.44, "reading_grade": 8.8, "line": 127}, "comment_text": "/* convert to normal processing when we hit final_count */\n/* we want each signal positioned at final_time */\n", "comment_tokens": ["convert", "to", "normal", "processing", "when", "we", "hit", "final_count", "we", "want", "each", "signal", "positioned", "at", "final_time"], "ccode": ["\n", "\n", "void normalize_toss_fetch(snd_susp_type a_susp, snd_list_type snd_list)\n", "    {\n", "    normalize_susp_type susp = (normalize_susp_type) a_susp;\n", "    time_type final_time = susp->susp.t0;\n", "    long n;\n", "\n", "    /* fetch samples from s1 up to final_time for this block of zeros */\n", "    while ((round((final_time - susp->s1->t0) * susp->s1->sr)) >=\n", "\t   susp->s1->current)\n", "\tsusp_get_samples(s1, s1_ptr, s1_cnt);\n", "    /* convert to normal processing when we hit final_count */\n", "    /* we want each signal positioned at final_time */\n", "    n = round((final_time - susp->s1->t0) * susp->s1->sr -\n", "         (susp->s1->current - susp->s1_cnt));\n", "    susp->s1_ptr += n;\n", "    susp_took(s1_cnt, n);\n", "    susp->susp.fetch = susp->susp.keep_fetch;\n", "    (*(susp->susp.fetch))(a_susp, snd_list);\n", "}\n"], "project": "audacity-data", "file": "scale.pkl", "function": "normalize_toss_fetch"}, {"comment_all": {"comment": "/***************************************\n  $Header: /home/amb/CVS/cxref/query/output.c,v 1.6 2004-06-22 17:31:24 amb Exp $\n\n  C Cross Referencing & Documentation tool. Version 1.6.\n  ******************/", "depth": 0, "reading_ease": 14.97, "reading_grade": 14.7, "line": 0}, "comment_text": "/***************************************\n  $Header: /home/amb/CVS/cxref/query/output.c,v 1.6 2004-06-22 17:31:24 amb Exp $\n\n  C Cross Referencing & Documentation tool. Version 1.6.\n  ******************/", "comment_tokens": ["$", "Header", ":", "homeambCVScxrefqueryoutput.c", ",", "v", "1.6", "2004-06-22", "17:31:24", "amb", "Exp", "$", "C", "Cross", "Referencing", "&", "Documentation", "tool", ".", "Version", "1.6", "."], "ccode": ["/***************************************\n", "  $Header: /home/amb/CVS/cxref/query/output.c,v 1.6 2004-06-22 17:31:24 amb Exp $\n", "\n", "  C Cross Referencing & Documentation tool. Version 1.6.\n", "  ******************/ /******************\n", "  Written by Andrew M. Bishop\n", "\n", "  This file Copyright 1995,96,97,2004 Andrew M. Bishop\n", "  It may be distributed under the GNU Public License, version 2, or\n", "  any higher version.  See section COPYING of the GNU Public license\n", "  for conditions under which this file may be redistributed.\n", "  ***************************************/\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include \"memory.h\"\n", "#include \"datatype.h\"\n", "#include \"cxref.h\"\n", "#include \"query.h\"\n", "\n", "\n", "/*+ The command line switch that sets the amount of cross referencing to do. +*/\n", "extern int option_xref;\n", "\n", "extern File *files;             /*+ The files that are queried. +*/\n", "extern int n_files;             /*+ The number of files referenced. +*/\n", "\n", "extern Function *functions;     /*+ The functions that are queried. +*/\n", "extern int n_functions;         /*+ The number of functions referenced. +*/\n", "\n", "extern Variable *variables;     /*+ The variables that are queried. +*/\n", "extern int n_variables;         /*+ The number of variables referenced. +*/\n", "\n", "extern Typedef *typedefs;       /*+ The type definitions that are queried. +*/\n", "extern int n_typedefs;          /*+ The number of typedefs referenced. +*/\n", "\n", "/* Local fuctions */\n", "\n", "static void OutputFile(File file);\n", "static void OutputInclude(Include incl,int depth);\n", "static void OutputFunction(Function func);\n", "static void OutputVariable(Variable var);\n", "static void OutputTypedef(Typedef type);\n", "\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Ouput the cross references for the named thing.\n", "\n", "  char* name The name of the object to ouput the cross references for.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "void OutputCrossRef(char* name)\n", "{\n", " int i,any=0;\n", "\n", " for(i=0;i<n_files;i++)\n", "    if(!strcmp(name,files[i]->name))\n", "       {OutputFile(files[i]);any++;}\n", "\n", " for(i=0;i<n_typedefs;i++)\n", "    if(!strcmp(name,typedefs[i]->name))\n", "      {OutputTypedef(typedefs[i]);any++;}\n", "\n", " for(i=0;i<n_variables;i++)\n", "    if(!strcmp(name,variables[i]->name))\n", "      {OutputVariable(variables[i]);any++;}\n", "\n", " for(i=0;i<n_functions;i++)\n", "    if(!strcmp(name,functions[i]->name))\n", "      {OutputFunction(functions[i]);any++;}\n", "\n", " if(!any)\n", "    printf(\"cxref-query: No match for '%s'.\\n\",name);\n", "}\n"], "project": "cxref-doc", "file": "output.pkl", "function": "OutputCrossRef"}, {"comment_all": {"comment": "/*\n * Update existing process entry, or add a process to the\n * process array.\n */", "depth": 0, "reading_ease": 76.22, "reading_grade": 5.6, "line": 48}, "comment_text": "/*\n * Update existing process entry, or add a process to the\n * process array.\n */", "comment_tokens": ["Update", "existing", "process", "entry", ",", "or", "add", "a", "process", "to", "the", "process", "array", "."], "ccode": ["/*\n", " * Update existing process entry, or add a process to the\n", " * process array.\n", " */\n", "void\n", "addProc ( char *procname , int mem , int rss )\n", "{\n", "   register struct ProcInfo\n", "      *thisproc ;\n", "/*\n", " * is the array empty?\n", " */\n", "   if ( !procs )\n", "   {\n", "      lastallocated = minProcs ;\n", "      if ( ( procs = calloc ( minProcs , sizeof ( struct ProcInfo ) ) )\n", "\t   == NULL )\n", "      {\n", "\t fprintf ( stderr , \"%s: cannot alloc %d processes\" , progname ,\n", "\t\t   minProcs ) ;\n", "\t perror ( \"\" ) ;\n", "\t exit ( 1 ) ;\n", "      }\n", "/* printf(\"allocated %d procs\\n\",lastallocated); */\n", "      thisproc = nextproc = procs ;\n", "      strcpy ( thisproc -> procname , procname ) ;\n", "      thisproc -> totMem = mem ;\n", "      thisproc -> totRSS = rss ;\n", "      thisproc -> nProcs = 1 ;\n", "      nProcs = 1 ;\n", "   }\n", "/*\n", " * if a process with that name doesn't already exist in the\n", " * array, make a new entry. Allocate more space if necessary.\n", " */\n", "   else if ( !( thisproc = LookupProc ( procname ) ) )\n", "   {\n", "      if ( nProcs == lastallocated )\t/* no more space */\n", "      {\n", "\t lastallocated *= 2 ;\n", "\t if ( ( procs = realloc\n", "\t\t( procs , lastallocated * sizeof ( struct ProcInfo) ) )\n", "\t      == NULL )\n", "\t {\n", "\t    fprintf ( stderr , \"%s: cannot alloc %d processes\" ,\n", "\t\t      progname , lastallocated ) ;\n", "\t    perror ( \"\" ) ;\n", "\t    exit ( 1 ) ;\n", "\t }\n", "/* printf(\"allocated %d procs\\n\",lastallocated); */\n", "      }\n", "      thisproc = procs + nProcs ;\n", "      strcpy ( thisproc -> procname , procname ) ;\n", "      thisproc -> totMem = mem ;\n", "      thisproc -> totRSS = rss ;\n", "      thisproc -> nProcs = 1 ;\n", "      nProcs++ ;\n", "   }\n", "   else\n", "   {\n", "      thisproc -> totMem += mem ;\n", "      thisproc -> totRSS += rss ;\n", "      thisproc -> nProcs++ ;\n", "   }\n", "}\n"], "project": "gmemusage", "file": "hash.pkl", "function": "addProc"}, {"comment_all": {"comment": "/*\n * FindDefaultConversion\n *\n * Find \"default\" conversion proc by for_encoding and to_encoding in the\n * given namespace.\n *\n * If found, returns the procedure's oid, otherwise InvalidOid.  Note that\n * you get the procedure's OID not the conversion's OID!\n */", "depth": 0, "reading_ease": 43.69, "reading_grade": 9.8, "line": 177}, "comment_text": "/*\n * FindDefaultConversion\n *\n * Find \"default\" conversion proc by for_encoding and to_encoding in the\n * given namespace.\n *\n * If found, returns the procedure's oid, otherwise InvalidOid.  Note that\n * you get the procedure's OID not the conversion's OID!\n */", "comment_tokens": ["FindDefaultConversion", "Find", "``", "default", "''", "conversion", "proc", "by", "for_encoding", "and", "to_encoding", "in", "the", "given", "namespace", ".", "If", "found", ",", "returns", "the", "procedure", "'s", "oid", ",", "otherwise", "InvalidOid", ".", "Note", "that", "you", "get", "the", "procedure", "'s", "OID", "not", "the", "conversion", "'s", "OID", "!"], "ccode": ["\n", "/*\n", " * FindDefaultConversion\n", " *\n", " * Find \"default\" conversion proc by for_encoding and to_encoding in the\n", " * given namespace.\n", " *\n", " * If found, returns the procedure's oid, otherwise InvalidOid.  Note that\n", " * you get the procedure's OID not the conversion's OID!\n", " */\n", "Oid\n", "FindDefaultConversion(Oid name_space, int32 for_encoding, int32 to_encoding)\n", "{\n", "\tCatCList   *catlist;\n", "\tHeapTuple\ttuple;\n", "\tForm_pg_conversion body;\n", "\tOid\t\t\tproc = InvalidOid;\n", "\tint\t\t\ti;\n", "\n", "\tcatlist = SearchSysCacheList3(CONDEFAULT,\n", "\t\t\t\t\t\t\t\t  ObjectIdGetDatum(name_space),\n", "\t\t\t\t\t\t\t\t  Int32GetDatum(for_encoding),\n", "\t\t\t\t\t\t\t\t  Int32GetDatum(to_encoding));\n", "\n", "\tfor (i = 0; i < catlist->n_members; i++)\n", "\t{\n", "\t\ttuple = &catlist->members[i]->tuple;\n", "\t\tbody = (Form_pg_conversion) GETSTRUCT(tuple);\n", "\t\tif (body->condefault)\n", "\t\t{\n", "\t\t\tproc = body->conproc;\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\tReleaseSysCacheList(catlist);\n", "\treturn proc;\n", "}\n"], "project": "postgresql-plpython3-12", "file": "pg_conversion.pkl", "function": "FindDefaultConversion"}, {"comment_all": {"comment": "/* Initialize host info (UUID,uptime,...) */", "depth": 0, "reading_ease": 33.58, "reading_grade": 9.6, "line": 29}, "comment_text": "/* Initialize host info (UUID,uptime,...) */", "comment_tokens": ["Initialize", "host", "info", "(", "UUID", ",", "uptime", ",", "...", ")"], "ccode": ["/*\n", " * vmfs-tools - Tools to access VMFS filesystems\n", " * Copyright (C) 2009 Christophe Fillot <cf@utc.fr>\n", " * Copyright (C) 2009 Mike Hommey <mh@glandium.org>\n", " *\n", " * This program is free software: you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation, either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", " */\n", "/* \n", " * VMFS host.\n", " */\n", "\n", "#define _GNU_SOURCE\n", "#include <string.h>\n", "#include <stdlib.h>\n", "#include \"vmfs.h\"\n", "\n", "static uuid_t host_uuid;\n", "static struct timeval host_tv_start;\n", "\n", "/* Initialize host info (UUID,uptime,...) */\n", "int vmfs_host_init(void)\n", "{\n", "   static bool initialized = 0;\n", "   if (! initialized) {\n", "      uuid_generate_time(host_uuid);\n", "      gettimeofday(&host_tv_start,NULL);\n", "      initialized = 1;\n", "   }\n", "   return(0);\n", "}\n"], "project": "vmfs-tools", "file": "vmfs_host.pkl", "function": "vmfs_host_init"}, {"comment_all": {"comment": "/* In the find_leak case, we have to finish to guarantee that \t*/", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 365}, "comment_text": "/* Make sure all blocks have been reclaimed, so sweep routines\t*/\n/* don't see cleared mark bits.\t\t\t\t\t*/\n/* If we're guaranteed to finish, then this is unnecessary.\t\t*/\n/* In the find_leak case, we have to finish to guarantee that \t*/\n/* previously unmarked objects are not reported as leaks.\t\t*/\n", "comment_tokens": ["Make", "sure", "all", "blocks", "have", "been", "reclaimed", ",", "so", "sweep", "routines", "do", "n't", "see", "cleared", "mark", "bits", ".", "If", "we", "'re", "guaranteed", "to", "finish", ",", "then", "this", "is", "unnecessary", ".", "In", "the", "find_leak", "case", ",", "we", "have", "to", "finish", "to", "guarantee", "that", "previously", "unmarked", "objects", "are", "not", "reported", "as", "leaks", "."], "ccode": ["\n", "\n", "/*\n", " * Stop the world garbage collection.  Assumes lock held, signals disabled.\n", " * If stop_func is not GC_never_stop_func, then abort if stop_func returns TRUE.\n", " * Return TRUE if we successfully completed the collection.\n", " */\n", "GC_bool GC_try_to_collect_inner(stop_func)\n", "GC_stop_func stop_func;\n", "{\n", "#   ifdef CONDPRINT\n", "        CLOCK_TYPE start_time, current_time;\n", "#   endif\n", "    if (GC_dont_gc) return FALSE;\n", "    \n", "    if (GC_notify_event)\n", "\tGC_notify_event (GC_EVENT_START);\n", "    \n", "    if (GC_incremental && GC_collection_in_progress()) {\n", "#   ifdef CONDPRINT\n", "      if (GC_print_stats) {\n", "\tGC_printf0(\n", "\t    \"GC_try_to_collect_inner: finishing collection in progress\\n\");\n", "      }\n", "#   endif /* CONDPRINT */\n", "      /* Just finish collection already in progress.\t*/\n", "    \twhile(GC_collection_in_progress()) {\n", "    \t    if (stop_func()) return(FALSE);\n", "    \t    GC_collect_a_little_inner(1);\n", "    \t}\n", "    }\n", "    if (stop_func == GC_never_stop_func) GC_notify_full_gc();\n", "#   ifdef CONDPRINT\n", "      if (GC_print_stats) {\n", "        if (GC_print_stats) GET_TIME(start_time);\n", "\tGC_printf2(\n", "\t   \"Initiating full world-stop collection %lu after %ld allocd bytes\\n\",\n", "\t   (unsigned long) GC_gc_no+1,\n", "\t   (long)WORDS_TO_BYTES(GC_words_allocd));\n", "      }\n", "#   endif\n", "    GC_promote_black_lists();\n", "    /* Make sure all blocks have been reclaimed, so sweep routines\t*/\n", "    /* don't see cleared mark bits.\t\t\t\t\t*/\n", "    /* If we're guaranteed to finish, then this is unnecessary.\t\t*/\n", "    /* In the find_leak case, we have to finish to guarantee that \t*/\n", "    /* previously unmarked objects are not reported as leaks.\t\t*/\n", "#       ifdef PARALLEL_MARK\n", "\t    GC_wait_for_reclaim();\n", "#       endif\n", " \tif ((GC_find_leak || stop_func != GC_never_stop_func)\n", "\t    && !GC_reclaim_all(stop_func, FALSE)) {\n", "\t    /* Aborted.  So far everything is still consistent.\t*/\n", "\t    return(FALSE);\n", "\t}\n", "    GC_invalidate_mark_state();  /* Flush mark stack.\t*/\n", "    GC_clear_marks();\n", "#   ifdef SAVE_CALL_CHAIN_IN_GC\n", "        GC_save_callers(GC_last_stack);\n", "#   endif\n", "    GC_is_full_gc = TRUE;\n", "    if (!GC_stopped_mark(stop_func)) {\n", "      if (!GC_incremental) {\n", "    \t/* We're partially done and have no way to complete or use \t*/\n", "    \t/* current work.  Reestablish invariants as cheaply as\t\t*/\n", "    \t/* possible.\t\t\t\t\t\t\t*/\n", "    \tGC_invalidate_mark_state();\n", "\tGC_unpromote_black_lists();\n", "      } /* else we claim the world is already still consistent.  We'll \t*/\n", "        /* finish incrementally.\t\t\t\t\t*/\n", "      return(FALSE);\n", "    }\n", "    GC_finish_collection();\n", "#   if defined(CONDPRINT)\n", "      if (GC_print_stats) {\n", "        GET_TIME(current_time);\n", "        GC_printf1(\"Complete collection took %lu msecs\\n\",\n", "                   MS_TIME_DIFF(current_time,start_time));\n", "      }\n", "#   endif\n", "    if (GC_notify_event)\n", "\tGC_notify_event (GC_EVENT_END);\n", "      \n", "    return(TRUE);\n", "}\n"], "project": "libmono-simd4.0-cil", "file": "alloc.pkl", "function": "GC_try_to_collect_inner"}, {"comment_all": {"comment": "/* caleb- does found where \"reload kbm\" is used.\n   * caleb- think the send_hime_message() here does nothing.\n   */", "depth": 1, "reading_ease": 97.7, "reading_grade": 1.5, "line": 190}, "comment_text": "/* caleb- does found where \"reload kbm\" is used.\n   * caleb- think the send_hime_message() here does nothing.\n   */", "comment_tokens": ["caleb-", "does", "found", "where", "``", "reload", "kbm", "''", "is", "used", ".", "caleb-", "think", "the", "send_hime_message", "(", ")", "here", "does", "nothing", "."], "ccode": ["\n", "\n", "static GtkWidget *kbm_widget = NULL;\n", "\n", "static int new_select_idx_tsin_space_opt;\n", "//static GdkColor tsin_phrase_line_gcolor;\n", "\n", "void save_kbm_conf()\n", "{\n", "  if (kbm_widget == NULL)\n", "  {\n", "    fprintf(stderr, \"save_kbm_conf: kbm_widget is NULL!\\n\");\n", "    return;\n", "  }\n", "\n", "  int idx = gtk_combo_box_get_active (GTK_COMBO_BOX (opt_kbm_opts));\n", "\n", "  int idx_selkeys = gtk_combo_box_get_active (GTK_COMBO_BOX (opt_selkeys));\n", "\n", "  pho_candicate_col_N = (int) gtk_spin_button_get_value(GTK_SPIN_BUTTON(spinner_pho_candicate_col_N));\n", "\n", "  if (pho_candicate_col_N > strlen(selkeys[idx_selkeys].kstr))\n", "    pho_candicate_col_N = strlen(selkeys[idx_selkeys].kstr);\n", "\n", "  dbg(\"pho_candicate_col_N %d\\n\", pho_candicate_col_N);\n", "\n", "  char tt[128];\n", "  sprintf(tt, \"%s %s %d %d\", kbm_sel[idx].kbm, selkeys[idx_selkeys].kstr, pho_candicate_col_N, selkeys[idx_selkeys].RL);\n", "\n", "  char phokbm_name[128];\n", "  get_hime_conf_fstr(PHONETIC_KEYBOARD, phokbm_name, \"\");\n", "\n", "  if (strcmp(phokbm_name, tt)) {\n", "    save_hime_conf_str(PHONETIC_KEYBOARD_BAK, phokbm_name);\n", "  }\n", "  save_hime_conf_str(PHONETIC_KEYBOARD, tt);\n", "\n", "  save_tsin_eng_pho_key();\n", "\n", "  save_hime_conf_int(TSIN_SPACE_OPT,\n", "                     tsin_space_options[new_select_idx_tsin_space_opt].key);\n", "\n", "  save_hime_conf_int(TSIN_PHRASE_PRE_SELECT,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_phrase_pre_select)));\n", "\n", "  save_hime_conf_int(PHONETIC_CHAR_DYNAMIC_SEQUENCE,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_phonetic_char_dynamic_sequence)));\n", "  save_hime_conf_int(PHO_HIDE_ROW2,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_pho_hide_row2)));\n", "\n", "  save_hime_conf_int(PHO_IN_ROW1,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_pho_in_row1)));\n", "\n", "  save_hime_conf_int(PHONETIC_HUGE_TAB,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_phonetic_huge_tab)));\n", "\n", "  save_hime_conf_int(TSIN_TONE_CHAR_INPUT,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_tone_char_input)));\n", "\n", "  save_hime_conf_int(TSIN_USE_PHO_NEAR,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_use_pho_near)));\n", "\n", "\n", "  save_hime_conf_int(TSIN_TAB_PHRASE_END,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_tab_phrase_end)));\n", "\n", "\n", "  save_hime_conf_int(TSIN_TAIL_SELECT_KEY,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_tail_select_key)));\n", "\n", "  save_hime_conf_int(TSIN_BUFFER_EDITING_MODE,\n", "       gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(check_button_tsin_buffer_editing_mode)));\n", "\n", "  tsin_buffer_size = (int) gtk_spin_button_get_value(GTK_SPIN_BUTTON(spinner_tsin_buffer_size));\n", "  save_hime_conf_int(TSIN_BUFFER_SIZE, tsin_buffer_size);\n", "\n", "#if 0\n", "  gchar *cstr;\n", "  cstr = gtk_color_selection_palette_to_string(&tsin_phrase_line_gcolor, 1);\n", "  dbg(\"color %s\\n\", cstr);\n", "  save_hime_conf_str(TSIN_PHRASE_LINE_COLOR, cstr);\n", "  g_free(cstr);\n", "#endif\n", "\n", "\n", "  save_omni_config();\n", "  /* caleb- does found where \"reload kbm\" is used.\n", "   * caleb- think the send_hime_message() here does nothing.\n", "   */\n", "  send_hime_message(GDK_DISPLAY(), \"reload kbm\");\n", "}\n"], "project": "hime-anthy", "file": "hime-setup-pho.pkl", "function": "save_kbm_conf"}, {"comment_all": {"comment": "/* sox_read may return a number that is less than was requested; only if\n   * 0 samples is returned does it indicate that end-of-file has been reached\n   * or an error has occurred */", "depth": 1, "reading_ease": 57.95, "reading_grade": 12.6, "line": 46}, "comment_text": "/* sox_read may return a number that is less than was requested; only if\n   * 0 samples is returned does it indicate that end-of-file has been reached\n   * or an error has occurred */", "comment_tokens": ["sox_read", "may", "return", "a", "number", "that", "is", "less", "than", "was", "requested", ";", "only", "if", "0", "samples", "is", "returned", "does", "it", "indicate", "that", "end-of-file", "has", "been", "reached", "or", "an", "error", "has", "occurred"], "ccode": ["/* Simple example of using SoX libraries\n", " *\n", " * Copyright (c) 2007-8 robs@users.sourceforge.net\n", " *\n", " * This program is free software; you can redistribute it and/or modify it\n", " * under the terms of the GNU General Public License as published by the\n", " * Free Software Foundation; either version 2 of the License, or (at your\n", " * option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful, but\n", " * WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General\n", " * Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License along\n", " * with this program; if not, write to the Free Software Foundation, Inc.,\n", " * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " */\n", "\n", "#ifdef NDEBUG /* N.B. assert used with active statements so enable always. */\n", "#undef NDEBUG /* Must undef above assert.h or other that might include it. */\n", "#endif\n", "\n", "#include \"sox.h\"\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <assert.h>\n", "\n", "static sox_format_t * in, * out; /* input and output files */\n", "\n", "/* The function that will be called to input samples into the effects chain.\n", " * In this example, we get samples to process from a SoX-openned audio file.\n", " * In a different application, they might be generated or come from a different\n", " * part of the application. */\n", "static int input_drain(\n", "    sox_effect_t * effp, sox_sample_t * obuf, size_t * osamp)\n", "{\n", "  (void)effp;   /* This parameter is not needed in this example */\n", "\n", "  /* ensure that *osamp is a multiple of the number of channels. */\n", "  *osamp -= *osamp % effp->out_signal.channels;\n", "\n", "  /* Read up to *osamp samples into obuf; store the actual number read\n", "   * back to *osamp */\n", "  *osamp = sox_read(in, obuf, *osamp);\n", "\n", "  /* sox_read may return a number that is less than was requested; only if\n", "   * 0 samples is returned does it indicate that end-of-file has been reached\n", "   * or an error has occurred */\n", "  if (!*osamp && in->sox_errno)\n", "    fprintf(stderr, \"%s: %s\\n\", in->filename, in->sox_errstr);\n", "  return *osamp? SOX_SUCCESS : SOX_EOF;\n", "}\n"], "project": "libsox3", "file": "example1.pkl", "function": "input_drain"}, {"comment_all": {"comment": "/* don't log password! */", "depth": 1, "reading_ease": 93.81, "reading_grade": 0.9, "line": 404}, "comment_text": "/* don't log password! */", "comment_tokens": ["do", "n't", "log", "password", "!"], "ccode": ["\n", "/*\n", " * ReadPass(): read password from console\n", " *\n", " * returns: 0 = OK, else error\n", " */\n", "static int\n", "ReadPass(const void *valueptr, const optionTable_t *tableptr,\n", "\t const char *filename, const char *line)\n", "{\n", "\tchar *passwd = prompt(\"Enter eBay password: \", 1);\n", "\n", "\tif (!passwd) {\n", "\t\tprintLog(stderr, \"Password entry failed!\\n\");\n", "\t\treturn 1;\n", "\t}\n", "\tputchar('\\n');\n", "\n", "\tsetPassword(passwd);\n", "\t/* don't log password! */\n", "\treturn 0;\n", "}\n"], "project": "esniper", "file": "esniper.pkl", "function": "ReadPass"}, {"comment_all": {"comment": "/* Sadly, strdup is not portable. */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 49}, "comment_text": "/* Sadly, strdup is not portable. */", "comment_tokens": ["Sadly", ",", "strdup", "is", "not", "portable", "."], "ccode": ["\n", "static void (*json_oom)(void) = default_oom;\n", "\n", "/* Sadly, strdup is not portable. */\n", "static char *json_strdup(const char *str)\n", "{\n", "\tchar *ret = (char*) malloc(strlen(str) + 1);\n", "\tif (ret == NULL) {\n", "\t\tjson_oom();\n", "\t\treturn NULL;\n", "\t}\n", "\tstrcpy(ret, str);\n", "\treturn ret;\n", "}\n"], "project": "proftpd-mod-sqlite", "file": "ccan-json.pkl", "function": "json_strdup"}, {"comment_all": {"comment": "/* \n     * destroy/free bot sentry account prefs\n     */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 641}, "comment_text": "/* \n     * destroy/free bot sentry account prefs\n     */", "comment_tokens": ["destroyfree", "bot", "sentry", "account", "prefs"], "ccode": ["\n", "static gboolean\n", "plugin_unload(\n", "    PurplePlugin * plugin)\n", "{\n", "    PurplePluginProtocolInfo *prpl_info;\n", "    GList *tmp = NULL;\n", "    GList *popt_iter = NULL;\n", "    GList *prpl_iter = NULL;\n", "    GSList *pend_iter = NULL;\n", "\n", "    purple_signals_disconnect_by_handle(plugin);\n", "    purple_prefs_disconnect_callback(callback_id);\n", "\n", "    for (pend_iter = pending_list; pend_iter; pend_iter = pend_iter->next) {\n", "        free_pending(pend_iter, TRUE);\n", "    }\n", "\n", "    /* \n", "     * destroy/free bot sentry account prefs\n", "     */\n", "    for (prpl_iter = purple_plugins_get_protocols(); prpl_iter; prpl_iter = prpl_iter->next) {\n", "        if (NULL == (PurplePlugin *) prpl_iter->data) {\n", "            return FALSE;\n", "        }\n", "        prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO((PurplePlugin *) prpl_iter->data);\n", "        if (NULL == prpl_info) {\n", "            return FALSE;\n", "        }\n", "        popt_iter = prpl_info->protocol_options;\n", "        while (NULL != popt_iter) {\n", "            tmp = popt_iter;\n", "            popt_iter = g_list_next(popt_iter);\n", "            if (g_str_has_prefix(purple_account_option_get_setting((PurpleAccountOption *) tmp->data), PLUGIN_ID \"-\")) {\n", "                purple_account_option_destroy((PurpleAccountOption *)\n", "                                              tmp->data);\n", "                prpl_info->protocol_options = g_list_remove(prpl_info->protocol_options, tmp->data);\n", "            }\n", "        }\n", "    }\n", "\n", "    return TRUE;\n", "}\n"], "project": "pidgin-bot-sentry", "file": "bot-sentry.pkl", "function": "plugin_unload"}, {"comment_all": {"comment": "/* in promilles (tenths of a percent) */", "depth": 1, "reading_ease": 99.23, "reading_grade": 0.9, "line": 377}, "comment_text": "/* in promilles (tenths of a percent) */", "comment_tokens": ["in", "promilles", "(", "tenths", "of", "a", "percent", ")"], "ccode": ["\n", "\n", "void\n", "print_progress(const char *msg, unsigned long current, unsigned long end, struct timespec *start)\n", "{\n", "\tunsigned progress;\t/* in promilles (tenths of a percent) */\n", "\ttime_t tm;\n", "\tstatic time_t last_time = 0;\n", "\tstatic unsigned int lapse = 0;\n", "\tstatic const char *spinner = \"/|\\\\-\";\n", "\tstruct timespec delta;\n", "\tunsigned long eta;\n", "\tchar eta_msg[16] = \" \";\n", "\n", "\tif (current < end) {\n", "\t\ttm = time(NULL);\n", "\t\tif (tm - last_time < 1)\n", "\t\t\treturn;\n", "\t\tlast_time = tm;\n", "\t\tprogress = current * 1000 / end;\n", "\t} else\n", "\t\tprogress = 1000;\n", "\n", "\tif (start != NULL && progress != 0) {\n", "\t\tcalc_delta(start, &delta);\n", "\t\teta = 1000 * delta.tv_sec + delta.tv_nsec / (NSEC_PER_SEC / 1000);\n", "\t\teta = eta / progress - delta.tv_sec;\n", "\t\teta_to_human_short(eta, eta_msg);\n", "\t}\n", "\tif (flag_ignore_r_char) {\n", "\t\tPROGRESS_MSG(\"%-\" PROGRESS_MAXLEN \"s: [%3u.%u %%] %c  %16s\\n\",\n", "\t\t\t     msg, progress / 10, progress % 10,\n", "\t\t\t     spinner[lapse % 4], eta_msg);\n", "\t} else {\n", "\t\tPROGRESS_MSG(\"\\r\");\n", "\t\tPROGRESS_MSG(\"%-\" PROGRESS_MAXLEN \"s: [%3u.%u %%] %c  %16s\",\n", "\t\t\t     msg, progress / 10, progress % 10,\n", "\t\t\t     spinner[lapse % 4], eta_msg);\n", "\t}\n", "\tlapse++;\n", "}\n"], "project": "kdump-tools", "file": "print_info.pkl", "function": "print_progress"}, {"comment_all": {"comment": "/*==============================================\n * listui_init_windows -- Initialize anything dependent on screen size\n *============================================*/", "depth": 0, "reading_ease": 22.07, "reading_grade": 11.9, "line": 115}, "comment_text": "/*==============================================\n * listui_init_windows -- Initialize anything dependent on screen size\n *============================================*/", "comment_tokens": ["==============================================", "listui_init_windows", "--", "Initialize", "anything", "dependent", "on", "screen", "size", "============================================"], "ccode": ["\n", "/*********************************************\n", " * local function prototypes\n", " *********************************************/\n", "\n", "/* alphabetical */\n", "static void activate_popup_list_uiwin (listdisp * ld);\n", "static void display_string(UIWINDOW uiwin, LLRECT rect, STRING text);\n", "static INT handle_list_cmds(listdisp * ld, INT code);\n", "static BOOLEAN handle_popup_list_resize(listdisp * ld, INT code);\n", "static void print_list_title(char * buffer, INT len, const listdisp * ld, STRING ttl);\n", "static void shw_array_of_strings(STRING *strings, listdisp *ld\n", "\t, DETAILFNC detfnc, void * param);\n", "static void shw_popup_list(INDISEQ seq, listdisp * ld);\n", "static void shw_recordlist_details(INDISEQ seq, listdisp * ld);\n", "static void shw_recordlist_list(INDISEQ seq, listdisp * ld);\n", "\n", "/*********************************************\n", " * local variables\n", " *********************************************/\n", "\n", "/* the following values are default (larger screens get more) */\n", "static int LIST_LINES_DEF = 6;       /* number of lines of person info in list */\n", "static int POPUP_LINES_DEF = 17;     /* max lines in popup list */\n", "/* working values */\n", "static int LIST_LINES=0;\n", "static int POPUP_LINES=0;\n", "\n", "/*==============================================\n", " * listui_init_windows -- Initialize anything dependent on screen size\n", " *============================================*/\n", "void\n", "listui_init_windows (INT extralines)\n", "{\n", "\t/* initialize list window heights to default */\n", "\tLIST_LINES = LIST_LINES_DEF;\n", "\tPOPUP_LINES = POPUP_LINES_DEF;\n", "\t/* increase for larger screens */\n", "\tif(extralines > 0) {\n", "\t\tLIST_LINES = LIST_LINES_DEF + extralines;\n", "\t\tPOPUP_LINES = POPUP_LINES_DEF + extralines;\n", "\t}\n", "\n", "\tLISTWIN_WIDTH = ll_cols-7;\n", "}\n"], "project": "lifelines", "file": "listui.pkl", "function": "listui_init_windows"}, {"comment_all": {"comment": "/* LibTomMath, multiple-precision integer library -- Tom St Denis */", "depth": 0, "reading_ease": -3.32, "reading_grade": 15.5, "line": 2}, "comment_text": "/* LibTomMath, multiple-precision integer library -- Tom St Denis */\n/* SPDX-License-Identifier: Unlicense */\n", "comment_tokens": ["LibTomMath", ",", "multiple-precision", "integer", "library", "--", "Tom", "St", "Denis", "SPDX-License-Identifier", ":", "Unlicense"], "ccode": ["#include \"tommath_private.h\"\n", "#ifdef BN_MP_FROM_UBIN_C\n", "/* LibTomMath, multiple-precision integer library -- Tom St Denis */\n", "/* SPDX-License-Identifier: Unlicense */\n", "\n", "/* reads a unsigned char array, assumes the msb is stored first [big endian] */\n", "mp_err mp_from_ubin(mp_int *a, const unsigned char *buf, size_t size)\n", "{\n", "   mp_err err;\n", "\n", "   /* make sure there are at least two digits */\n", "   if (a->alloc < 2) {\n", "      if ((err = mp_grow(a, 2)) != MP_OKAY) {\n", "         return err;\n", "      }\n", "   }\n", "\n", "   /* zero the int */\n", "   mp_zero(a);\n", "\n", "   /* read the bytes in */\n", "   while (size-- > 0u) {\n", "      if ((err = mp_mul_2d(a, 8, a)) != MP_OKAY) {\n", "         return err;\n", "      }\n", "\n", "#ifndef MP_8BIT\n", "      a->dp[0] |= *buf++;\n", "      a->used += 1;\n", "#else\n", "      a->dp[0] = (*buf & MP_MASK);\n", "      a->dp[1] |= ((*buf++ >> 7) & 1u);\n", "      a->used += 2;\n", "#endif\n", "   }\n", "   mp_clamp(a);\n", "   return MP_OKAY;\n", "}\n"], "project": "libtommath-dev", "file": "bn_mp_from_ubin.pkl", "function": "mp_from_ubin"}, {"comment_all": {"comment": "/* end of selector = integer code */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 102}, "comment_text": "/* end of selector = integer code */", "comment_tokens": ["end", "of", "selector", "=", "integer", "code"], "ccode": ["/***********************************************************************/\n", "/* Open Visualization Data Explorer                                    */\n", "/* (C) Copyright IBM Corp. 1989,1999                                   */\n", "/* ALL RIGHTS RESERVED                                                 */\n", "/* This code licensed under the                                        */\n", "/*    \"IBM PUBLIC LICENSE - Open Visualization Data Explorer\"          */\n", "/***********************************************************************/\n", "\n", "#include <dxconfig.h>\n", "\n", "\n", "\n", "/***\n", "MODULE:\n", "    Route\n", "SHORTDESCRIPTION:\n", "    Passes the 2nd input object to the output path(s) specified by the selector list \n", "    or NULL if the selector is not in valid range.\n", "CATEGORY:\n", "    Special\n", "INPUTS:\n", "    $Select;\tInteger list;\t0;\tThe selector value\n", "    ...;\tObject;\t\tNULL;\tThe input object list\n", "OUTPUTS:\n", "    Output;   \tObject; \tNULL;\tThe 2nd input object or NULL\n", "FLAGS:\n", "    MODULE_ROUTE \n", "BUGS:\n", "AUTHOR:\n", "    Nancy R. Brown\n", "END:\n", "***/\n", "\n", "#include <dx/dx.h>\n", "#define NARGS 22\n", "#define MAXOUTPUTS 4\n", "\n", "Error\n", "m_Route (Object *in, Object *out)\n", "{\n", "    /* Route module handled entirely by the executive.  */\n", "    /* (will put following code in evalgraph.c)         */\n", "    \n", "    DXSetError(ERROR_INTERNAL, \"#8015\", \"Route\");\n", "    return(ERROR);\n", "\n", "#if 0\n", "    int i,limit;\n", "    int numselitems, rank, shape[32], *selptr;\n", "    int numoutitems = 0;\n", "    Type type;\n", "    Category category;\n", "\n", "    if (in[0] == NULL)\n", "    {\n", "\tout[0] == NULL;\n", "\treturn(OK);\n", "    }\n", "    if (!(DXGetObjectClass(in[0])==CLASS_ARRAY)) {\n", "      DXSetError(ERROR_BAD_PARAMETER,\n", "                 \"#10010\", \"route value\");\n", "      return(ERROR);\n", "    }\n", "    if (!DXGetArrayInfo((Array)in[0], &numselitems, &type, &category,\n", "                        &rank, shape)) {\n", "      return(ERROR);\n", "    }\n", "    if (type!=TYPE_INT) {\n", "      DXSetError(ERROR_BAD_PARAMETER,\n", "                 \"selector must be an integer or an integer list\");\n", "      return(ERROR);\n", "    }\n", "    if (! ((rank == 0) || ((rank == 1)&&(shape[0]=1)))) {\n", "      DXSetError(ERROR_BAD_PARAMETER,\n", "                 \"selector must be an integer or an integer list\");\n", "      return(ERROR);\n", "    }\n", "/*** ===> How can you determine actual number of outputs ??? ***/\n", "    for (i = 0, limit = MAXOUTPUTS; i < limit; ++i) {\n", "      if (out[i])\n", "        numoutitems++; \n", "    }\n", "    DXDebug(\"*1\",\"Route module has %d outputs\",numoutitems);\n", "    if (numselitems == 1) { \n", "      DXDebug(\"*1\",\"Route module input selector is an integer\");\n", "      if (DXExtractInteger(in[0], &i) == ERROR)\n", "      {\n", "\t DXSetError(ERROR_BAD_PARAMETER, \"#10010\", \"route value\");\n", "\t return(ERROR);\n", "      }\n", "\n", "      for (i = 0, limit = numoutitems; i < limit; ++i) {\n", "        out[i] == NULL;\n", "      }    /* initialize all outputs to NULL */ \n", "      if (i <= 0 || i >= numoutitems) \n", "\t return(OK);\n", "      else\n", "      {\n", "         DXDebug(\"*1\",\"Routing input object to output# %d in Route module\",i);\n", "         out[i] = in[1];\n", "         return(OK);\n", "      }\n", "    }   /* end of selector = integer code */\n", "    DXDebug(\"*1\",\"Route module input selector is an integer list\");\n", "    selptr = (int *)DXGetArrayData((Array)in[0]);\n", "    for (i = 0, limit = numselitems; i < limit; ++i) {  \n", "       /*** if (selptr[i] > 0 && selptr[i] <= numoutitems) { use MAXOUTPUTS for now ... ***/        \n", "       if (selptr[i] > 0 && selptr[i] <= MAXOUTPUTS) {        \n", "         DXDebug(\"*1\",\"Routing input object to output# %d in Route module\",i);\n", "         out[selptr[i]] = in[1];\n", "       }\n", "    else\n", "      DXDebug(\"*1\",\"Route module input selector value %d is out of range\",\n", "             selptr[i]);\n", "    }   \n", "    return(OK);\n", "#endif\n", "}\n"], "project": "dx", "file": "route.pkl", "function": "m_Route"}, {"comment_all": {"comment": "/*\n**! method object decode_header(string data)\n**! method object decode_header(string data, mapping options)\n**! \tDecodes an X-Face image header. \n**!\n**!\t<pre>\n**!\t    \"xsize\":int\n**!\t    \"ysize\":int\n**!\t\tsize of image\n**!\t    \"type\":\"image/x-xface\"\n**!\t\tfile type information\n**!\t</pre>\n**!\n**!     The <tt>options</tt> argument may be a mapping\n**!\tcontaining zero options.\n**!\n**! note\n**!\tThere aint no such thing as a X-Face image header.\n**!\tThis stuff tells the characteristics of an X-Face image.\n**!\n*/", "depth": 0, "reading_ease": 56.72, "reading_grade": 6.9, "line": 460}, "comment_text": "/*\n**! method object decode_header(string data)\n**! method object decode_header(string data, mapping options)\n**! \tDecodes an X-Face image header. \n**!\n**!\t<pre>\n**!\t    \"xsize\":int\n**!\t    \"ysize\":int\n**!\t\tsize of image\n**!\t    \"type\":\"image/x-xface\"\n**!\t\tfile type information\n**!\t</pre>\n**!\n**!     The <tt>options</tt> argument may be a mapping\n**!\tcontaining zero options.\n**!\n**! note\n**!\tThere aint no such thing as a X-Face image header.\n**!\tThis stuff tells the characteristics of an X-Face image.\n**!\n*/", "comment_tokens": ["!", "method", "object", "decode_header", "(", "string", "data", ")", "!", "method", "object", "decode_header", "(", "string", "data", ",", "mapping", "options", ")", "!", "Decodes", "an", "X-Face", "image", "header", ".", "!", "!", "<", "pre", ">", "!", "``", "xsize", "''", ":", "int", "!", "``", "ysize", "''", ":", "int", "!", "size", "of", "image", "!", "``", "type", "''", ":", "''", "imagex-xface", "''", "!", "file", "type", "information", "!", "<", "pre", ">", "!", "!", "The", "<", "tt", ">", "options", "<", "tt", ">", "argument", "may", "be", "a", "mapping", "!", "containing", "zero", "options", ".", "!", "!", "note", "!", "There", "aint", "no", "such", "thing", "as", "a", "X-Face", "image", "header", ".", "!", "This", "stuff", "tells", "the", "characteristics", "of", "an", "X-Face", "image", ".", "!"], "ccode": ["\n", "/*\n", "**! method object decode_header(string data)\n", "**! method object decode_header(string data, mapping options)\n", "**! \tDecodes an X-Face image header. \n", "**!\n", "**!\t<pre>\n", "**!\t    \"xsize\":int\n", "**!\t    \"ysize\":int\n", "**!\t\tsize of image\n", "**!\t    \"type\":\"image/x-xface\"\n", "**!\t\tfile type information\n", "**!\t</pre>\n", "**!\n", "**!     The <tt>options</tt> argument may be a mapping\n", "**!\tcontaining zero options.\n", "**!\n", "**! note\n", "**!\tThere aint no such thing as a X-Face image header.\n", "**!\tThis stuff tells the characteristics of an X-Face image.\n", "**!\n", "*/\n", "\n", "static void image_xface_decode_header(INT32 args)\n", "{\n", "  if(args<1 || TYPEOF(sp[-args]) != T_STRING)\n", "    Pike_error(\"Image.XFace.decode_header: Illegal arguments\\n\");\n", "\n", "  pop_n_elems(args);\n", "\n", "  ref_push_string(literal_type_string);\n", "  push_text(\"image/x-xface\");\n", "\n", "  push_text(\"xsize\");\n", "  push_int(48);\n", "\n", "  push_text(\"ysize\");\n", "  push_int(48);\n", "\n", "  f_aggregate_mapping(6);\n", "}\n"], "project": "pike8.0-dev", "file": "image_xface.pkl", "function": "image_xface_decode_header"}, {"comment_all": {"comment": "/*\n * Check for a valid number.  This should be elsewhere.\n */", "depth": 0, "reading_ease": 100.75, "reading_grade": 0.3, "line": 169}, "comment_text": "/*\n * Check for a valid number.  This should be elsewhere.\n */", "comment_tokens": ["Check", "for", "a", "valid", "number", ".", "This", "should", "be", "elsewhere", "."], "ccode": ["\n", "\n", "\n", "/*\n", " * Check for a valid number.  This should be elsewhere.\n", " */\n", "\n", "int\n", "is_number(const char *p)\n", "{\n", "\tdo {\n", "\t\tif (! is_digit(*p))\n", "\t\t\treturn 0;\n", "\t} while (*++p != '\\0');\n", "\treturn 1;\n", "}\n"], "project": "dash", "file": "mystring.pkl", "function": "is_number"}, {"comment_all": {"comment": "// The size of our tty\n", "depth": 1, "reading_ease": 117.16, "reading_grade": -1.9, "line": 499}, "comment_text": "// The size of our tty\n", "comment_tokens": ["The", "size", "of", "our", "tty"], "ccode": ["\n", "void window_resize_handler(int signum)\n", "{\n", "    struct winsize ttysize; // The size of our tty\n", "\n", "    if( ioctl( ourtty, TIOCGWINSZ, &ttysize )==0 )\n", "        ioctl( masterpt, TIOCSWINSZ, &ttysize );\n", "}\n"], "project": "sshpass", "file": "main.pkl", "function": "window_resize_handler"}, {"comment_all": {"comment": "/*********************************************************************\n *\n * Authors: Vincenzo Ciaschini - Vincenzo.Ciaschini@cnaf.infn.it \n *\n * Copyright (c) Members of the EGEE Collaboration. 2004-2010.\n * See http://www.eu-egee.org/partners/ for details on the copyright holders.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Parts of this code may be based upon or even include verbatim pieces,\n * originally written by other people, in which case the original header\n * follows.\n *\n *********************************************************************/", "depth": 0, "reading_ease": 49.11, "reading_grade": 9.8, "line": 11}, "comment_text": "/*********************************************************************\n *\n * Authors: Vincenzo Ciaschini - Vincenzo.Ciaschini@cnaf.infn.it \n *\n * Copyright (c) Members of the EGEE Collaboration. 2004-2010.\n * See http://www.eu-egee.org/partners/ for details on the copyright holders.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Parts of this code may be based upon or even include verbatim pieces,\n * originally written by other people, in which case the original header\n * follows.\n *\n *********************************************************************/", "comment_tokens": ["Authors", ":", "Vincenzo", "Ciaschini", "-", "Vincenzo.Ciaschini", "@", "cnaf.infn.it", "Copyright", "(", "c", ")", "Members", "of", "the", "EGEE", "Collaboration", ".", "2004-2010", ".", "See", "http", ":", "www.eu-egee.orgpartners", "for", "details", "on", "the", "copyright", "holders", ".", "Licensed", "under", "the", "Apache", "License", ",", "Version", "2.0", "(", "the", "``", "License", "''", ")", ";", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License", ".", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at", "http", ":", "www.apache.orglicensesLICENSE-2.0", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing", ",", "software", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "``", "AS", "IS", "''", "BASIS", ",", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND", ",", "either", "express", "or", "implied", ".", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and", "limitations", "under", "the", "License", ".", "Parts", "of", "this", "code", "may", "be", "based", "upon", "or", "even", "include", "verbatim", "pieces", ",", "originally", "written", "by", "other", "people", ",", "in", "which", "case", "the", "original", "header", "follows", "."], "ccode": ["/*********************************************************************\n", " *\n", " * Authors: Vincenzo Ciaschini - Vincenzo.Ciaschini@cnaf.infn.it \n", " *\n", " * Copyright (c) Members of the EGEE Collaboration. 2004-2010.\n", " * See http://www.eu-egee.org/partners/ for details on the copyright holders.\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " *    http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " *\n", " * Parts of this code may be based upon or even include verbatim pieces,\n", " * originally written by other people, in which case the original header\n", " * follows.\n", " *\n", " *********************************************************************/\n", "#include \"config.h\"\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "char **listadd(char **vect, char *data)\n", "{\n", "  int i = 0;\n", "  char **newvect;\n", "\n", "  if (!data)\n", "    return vect;\n", "\n", "  if (vect)\n", "    while (vect[i++]) ;\n", "  else\n", "    i=1;\n", "\n", "  if ((newvect = (char **)malloc((i+1)*sizeof(char *)))) {\n", "    if (vect) {\n", "      memcpy(newvect, vect, (sizeof(char*)*(i-1)));\n", "      newvect[i-1] = data;\n", "      newvect[i] = NULL;\n", "      free(vect);\n", "    }\n", "    else {\n", "      newvect[0] = data;\n", "      newvect[1] = NULL;\n", "    }\n", "    return newvect;\n", "  }\n", "  return NULL;\n", "}\n"], "project": "libcanl-c-dev", "file": "list.pkl", "function": "listadd"}, {"comment_all": {"comment": "/* Initialize the number of residue names: */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 48}, "comment_text": "/* Initialize the number of residue names: */", "comment_tokens": ["Initialize", "the", "number", "of", "residue", "names", ":"], "ccode": ["/* Copyright (C) 2000 Damir Zucic */\n", "\n", "/*=============================================================================\n", "\n", "\t\t\t    residue_names.c\n", "\n", "Purpose:\n", "\tExtract residue names from the list.\n", "\n", "Input:\n", "\t(1) Pointer to SelectS structure, where data will be stored.\n", "\t(2) Pointer to the string with list of residue names.\n", "\n", "Output:\n", "\t(1) Some data added to SelectS structure.\n", "\t(2) Return value.\n", "\n", "Return value:\n", "\t(1) Positive on success.\n", "\t(2) Negative on failure.\n", "\n", "========includes:============================================================*/\n", "\n", "#include <stdio.h>\n", "\n", "#include <string.h>\n", "\n", "#include <X11/Xlib.h>\n", "#include <X11/Xutil.h>\n", "#include <X11/Xos.h>\n", "#include <X11/Xatom.h>\n", "\n", "#include \"defines.h\"\n", "#include \"typedefs.h\"\n", "\n", "/*======extract residue names:===============================================*/\n", "\n", "int ExtractResidueNames_ (SelectS *selectSP, char *stringP)\n", "{\n", "char\t\t*P, *tokenP;\n", "int\t\tnameI;\n", "\n", "/* Check the string length: */\n", "if (strlen (stringP) == 0) return -1;\n", "\n", "/* Initialize all_residue_namesF (1 = select all residue names): */\n", "selectSP->all_residue_namesF = 0;\n", "\n", "/* Initialize the number of residue names: */\n", "selectSP->residue_namesN = 0;\n", "\n", "/* If wildcard (asterisk) is present, set */\n", "/* all_residue_namesF  to one and return: */\n", "if (strstr (stringP, \"*\"))\n", "\t{\n", "\tselectSP->all_residue_namesF = 1;\n", "\treturn 1;\n", "\t}\n", "\n", "/* Parse the list of residue names: */\n", "P = stringP;\n", "while ((tokenP = strtok (P, \" \\t,;\")) != NULL)\n", "\t{\n", "\t/** Ensure the proper operation of strtok: **/\n", "\tP = NULL;\n", "\n", "\t/** Copy the token and update the count: **/\n", "\tnameI = selectSP->residue_namesN;\n", "\tstrncpy (selectSP->residue_nameAA[nameI],\n", "\t\t tokenP, RESNAMESIZE - 1);\n", "\tselectSP->residue_nameAA[nameI][RESNAMESIZE - 1] = '\\0';\n", "\n", "\t/** Update and check the count: **/\n", "\tselectSP->residue_namesN++;\n", "\tif (selectSP->residue_namesN >= MAXFIELDS) break;\n", "\t}\n", "\n", "/* Return positive value on success: */\n", "return 1;\n", "}\n"], "project": "garlic", "file": "residue_names.pkl", "function": "ExtractResidueNames_"}, {"comment_all": {"comment": "//logger(L_DBG,\"[DS]: processOutputData\");\n", "depth": 1, "reading_ease": -175.9, "reading_grade": 38.3, "line": 303}, "comment_text": "//logger(L_DBG,\"[DS]: processOutputData\");\n", "comment_tokens": ["logger", "(", "L_DBG", ",", "''", "[", "DS", "]", ":", "processOutputData", "''", ")", ";"], "ccode": ["\n", "static int processOutputData()\n", "{\n", "    //logger(L_DBG,\"[DS]: processOutputData\");\n", "\n", "    int ret = EXIT_OK;\n", "\n", "    // Verify commands from queue (timeout about 1/2 sec)\n", "    dMessage* dm = (dMessage*) queuePop(Q_DISP);\n", "    if (dm != NULL) {\n", "\n", "        //DEBUG2(\"[DS]: Got event %p %d\", dm, dm->type);\n", "\n", "        if (connected() == EXIT_NOK && \n", "            !haveConnectionless() &&\n", "                !(dm->type == DM_EVENT)) { // can process these even if no connection\n", "\n", "            //logger(L_DBG, \"[DS]: No connection. Skip event\");\n", "\n", "        } else {\n", "            \n", "            if (dm->type < DM_TYPE_MAX) {\n", "                ret = (_dispMsgHooks[dm->type].hook)(dm);\n", "            }\n", "        }\n", "\n", "        freeDMessage(dm);\n", "    }\n", "    \n", "    if (ret == EXIT_ABORT) { \n", "        DEBUG2(\"[DS]: processOutputData ret %d\", ret); \n", "    }\n", "    return ret;\n", "}\n"], "project": "anyremote", "file": "dispatcher.pkl", "function": "processOutputData"}, {"comment_all": {"comment": "/*\n=====================\nG_TimeShiftAllClients\n\nMove ALL clients back to where they were at the specified \"time\",\nexcept for \"skip\"\n=====================\n*/", "depth": 0, "reading_ease": 80.62, "reading_grade": 6.0, "line": 199}, "comment_text": "/*\n=====================\nG_TimeShiftAllClients\n\nMove ALL clients back to where they were at the specified \"time\",\nexcept for \"skip\"\n=====================\n*/", "comment_tokens": ["=====================", "G_TimeShiftAllClients", "Move", "ALL", "clients", "back", "to", "where", "they", "were", "at", "the", "specified", "``", "time", "''", ",", "except", "for", "``", "skip", "''", "====================="], "ccode": ["\n", "\n", "/*\n", "=====================\n", "G_TimeShiftAllClients\n", "\n", "Move ALL clients back to where they were at the specified \"time\",\n", "except for \"skip\"\n", "=====================\n", "*/\n", "void G_TimeShiftAllClients( int time, edict_t *skip ) \n", "{\n", "\tint\t\t\ti;\n", "\tedict_t\t*ent;\n", "\n", "\tfor (i=0 ; i<g_maxclients->value ; i++)\n", "\t{\n", "\t\tent = g_edicts + 1 + i;\n", "\t\tif (!ent->inuse || !ent->client)\n", "\t\t\tcontinue;\n", "\n", "\t\tif ( ent->client && ent->inuse && !ent->client->resp.spectator && ent != skip ) \n", "\t\t{\n", "\t\t\tG_TimeShiftClient( ent, time, false, skip );\n", "\t\t}\n", "\t}\n", "}\n"], "project": "alien-arena", "file": "g_unlagged.pkl", "function": "G_TimeShiftAllClients"}, {"comment_all": {"comment": "/* remove the domain portion, if necessary */", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 798}, "comment_text": "/* remove the domain portion, if necessary */", "comment_tokens": ["remove", "the", "domain", "portion", ",", "if", "necessary"], "ccode": ["\n", "extern int switch_p_build_node_info(switch_node_info_t *switch_node)\n", "{\n", "\tsw_gen_node_info_t *gen_node_info = (sw_gen_node_info_t *) switch_node;\n", "\tstruct ifaddrs *if_array = NULL, *if_rec;\n", "\tsw_gen_ifa_t *ifa_ptr;\n", "\tvoid *addr_ptr = NULL;\n", "\tchar addr_str[INET6_ADDRSTRLEN], *ip_family;\n", "\tchar hostname[256], *tmp;\n", "\n", "\tif (debug_flags & DEBUG_FLAG_SWITCH)\n", "\t\tinfo(\"switch_p_build_node_info() starting\");\n", "\txassert(gen_node_info);\n", "\txassert(gen_node_info->magic == SW_GEN_NODE_INFO_MAGIC);\n", "\tif (gethostname(hostname, sizeof(hostname)) < 0)\n", "\t\treturn SLURM_ERROR;\n", "\t/* remove the domain portion, if necessary */\n", "\ttmp = strstr(hostname, \".\");\n", "\tif (tmp)\n", "\t\t*tmp = '\\0';\n", "\tgen_node_info->node_name = xstrdup(hostname);\n", "\tif (getifaddrs(&if_array) == 0) {\n", "\t\tfor (if_rec = if_array; if_rec; if_rec = if_rec->ifa_next) {\n", "#if !defined(__FreeBSD__)\n", "\t   \t\tif (if_rec->ifa_flags & IFF_LOOPBACK)\n", "\t\t\t\tcontinue;\n", "#endif\n", "\t\t\tif (if_rec->ifa_addr->sa_family == AF_INET) {\n", "\t\t\t\taddr_ptr = &((struct sockaddr_in *)\n", "\t\t\t\t\t\tif_rec->ifa_addr)->sin_addr;\n", "\t\t\t\tip_family = \"IP_V4\";\n", "\t\t\t} else if (if_rec->ifa_addr->sa_family == AF_INET6) {\n", "\t\t\t\taddr_ptr = &((struct sockaddr_in6 *)\n", "\t\t\t\t\t\tif_rec->ifa_addr)->sin6_addr;\n", "\t\t\t\tip_family = \"IP_V6\";\n", "\t\t\t} else {\n", "\t\t\t\t/* AF_PACKET (statistics) and others ignored */\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\t(void) inet_ntop(if_rec->ifa_addr->sa_family,\n", "\t\t\t\t\t addr_ptr, addr_str, sizeof(addr_str));\n", "\t\t\txrealloc(gen_node_info->ifa_array,\n", "\t\t\t\t sizeof(sw_gen_ifa_t *) *\n", "\t\t\t\t        (gen_node_info->ifa_cnt + 1));\n", "\t\t\tifa_ptr = xmalloc(sizeof(sw_gen_ifa_t));\n", "\t\t\tifa_ptr->ifa_addr   = xstrdup(addr_str);\n", "\t\t\tifa_ptr->ifa_family = xstrdup(ip_family);\n", "\t\t\tifa_ptr->ifa_name   = xstrdup(if_rec->ifa_name);\n", "\t\t\tgen_node_info->ifa_array[gen_node_info->ifa_cnt++] =\n", "\t\t\t\tifa_ptr;\n", "\t\t\tif (debug_flags & DEBUG_FLAG_SWITCH) {\n", "\t\t\t\tinfo(\"%s: name=%s ip_family=%s address=%s\",\n", "\t\t\t\t     plugin_type, if_rec->ifa_name, ip_family,\n", "\t\t\t\t     addr_str);\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\tfreeifaddrs(if_array);\n", "\n", "\treturn SLURM_SUCCESS;\n", "}\n"], "project": "libpam-slurm", "file": "switch_generic.pkl", "function": "switch_p_build_node_info"}, {"comment_all": {"comment": "/* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n  results in better blocks. */", "depth": 1, "reading_ease": 40.35, "reading_grade": 11.1, "line": 293}, "comment_text": "/* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n  results in better blocks. */", "comment_tokens": ["Unintuitively", ",", "Using", "a", "simple", "LZ77", "method", "here", "instead", "of", "ZopfliLZ77Optimal", "results", "in", "better", "blocks", "."], "ccode": ["\n", "void ZopfliBlockSplit(const ZopfliOptions* options,\n", "                      const unsigned char* in, size_t instart, size_t inend,\n", "                      size_t maxblocks, size_t** splitpoints, size_t* npoints) {\n", "  size_t pos = 0;\n", "  size_t i;\n", "  ZopfliBlockState s;\n", "  size_t* lz77splitpoints = 0;\n", "  size_t nlz77points = 0;\n", "  ZopfliLZ77Store store;\n", "  ZopfliHash hash;\n", "  ZopfliHash* h = &hash;\n", "\n", "  ZopfliInitLZ77Store(in, &store);\n", "  ZopfliInitBlockState(options, instart, inend, 0, &s);\n", "  ZopfliAllocHash(ZOPFLI_WINDOW_SIZE, h);\n", "\n", "  *npoints = 0;\n", "  *splitpoints = 0;\n", "\n", "  /* Unintuitively, Using a simple LZ77 method here instead of ZopfliLZ77Optimal\n", "  results in better blocks. */\n", "  ZopfliLZ77Greedy(&s, in, instart, inend, &store, h);\n", "\n", "  ZopfliBlockSplitLZ77(options,\n", "                       &store, maxblocks,\n", "                       &lz77splitpoints, &nlz77points);\n", "\n", "  /* Convert LZ77 positions to positions in the uncompressed input. */\n", "  pos = instart;\n", "  if (nlz77points > 0) {\n", "    for (i = 0; i < store.size; i++) {\n", "      size_t length = store.dists[i] == 0 ? 1 : store.litlens[i];\n", "      if (lz77splitpoints[*npoints] == i) {\n", "        ZOPFLI_APPEND_DATA(pos, splitpoints, npoints);\n", "        if (*npoints == nlz77points) break;\n", "      }\n", "      pos += length;\n", "    }\n", "  }\n", "  assert(*npoints == nlz77points);\n", "\n", "  free(lz77splitpoints);\n", "  ZopfliCleanBlockState(&s);\n", "  ZopfliCleanLZ77Store(&store);\n", "  ZopfliCleanHash(h);\n", "}\n"], "project": "apngasm", "file": "blocksplitter.pkl", "function": "ZopfliBlockSplit"}, {"comment_all": {"comment": "/* Create a symbol whose only job is to point to this section.  This\n   is useful for things like relocs which are relative to the base\n   of a section.  */", "depth": 0, "reading_ease": 82.65, "reading_grade": 5.2, "line": 793}, "comment_text": "/* Create a symbol whose only job is to point to this section.  This\n   is useful for things like relocs which are relative to the base\n   of a section.  */", "comment_tokens": ["Create", "a", "symbol", "whose", "only", "job", "is", "to", "point", "to", "this", "section", ".", "This", "is", "useful", "for", "things", "like", "relocs", "which", "are", "relative", "to", "the", "base", "of", "a", "section", "."], "ccode": ["\n", "#define section_hash_lookup(table, string, create, copy) \\\n", "  ((struct section_hash_entry *) \\\n", "   bfd_hash_lookup ((table), (string), (create), (copy)))\n", "\n", "/* Create a symbol whose only job is to point to this section.  This\n", "   is useful for things like relocs which are relative to the base\n", "   of a section.  */\n", "\n", "bfd_boolean\n", "_bfd_generic_new_section_hook (bfd *abfd, asection *newsect)\n", "{\n", "  newsect->symbol = bfd_make_empty_symbol (abfd);\n", "  if (newsect->symbol == NULL)\n", "    return FALSE;\n", "\n", "  newsect->symbol->name = newsect->name;\n", "  newsect->symbol->value = 0;\n", "  newsect->symbol->section = newsect;\n", "  newsect->symbol->flags = BSF_SECTION_SYM;\n", "\n", "  newsect->symbol_ptr_ptr = &newsect->symbol;\n", "  return TRUE;\n", "}\n"], "project": "binutils-doc", "file": "section.pkl", "function": "_bfd_generic_new_section_hook"}, {"comment_all": {"comment": "/*\n * \\file\n *\n * \\author Russell Bryant <russell@digium.com>\n *\n * \\brief Menu stub\n */", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 18}, "comment_text": "/*\n * \\file\n *\n * \\author Russell Bryant <russell@digium.com>\n *\n * \\brief Menu stub\n */", "comment_tokens": ["\\file", "\\author", "Russell", "Bryant", "<", "russell", "@", "digium.com", ">", "\\brief", "Menu", "stub"], "ccode": ["/*\n", " * Asterisk -- An open source telephony toolkit.\n", " *\n", " * Copyright (C) 2005 - 2006, Russell Bryant\n", " *\n", " * Russell Bryant <russell@digium.com>\n", " *\n", " * See http://www.asterisk.org for more information about\n", " * the Asterisk project. Please do not directly contact\n", " * any of the maintainers of this project for assistance;\n", " * the project provides a web site, mailing lists and IRC\n", " * channels for your use.\n", " *\n", " * This program is free software, distributed under the terms of\n", " * the GNU General Public License Version 2. See the LICENSE file\n", " * at the top of the source tree.\n", " */\n", "\n", "/*\n", " * \\file\n", " *\n", " * \\author Russell Bryant <russell@digium.com>\n", " *\n", " * \\brief Menu stub\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "\n", "#include \"menuselect.h\"\n", "\n", "int run_menu(void)\n", "{\n", "\tfprintf(stderr, \"**************************************************\\n\");\n", "\tfprintf(stderr, \"*** Install ncurses to use the menu interface! ***\\n\");\n", "\tfprintf(stderr, \"**************************************************\\n\");\n", "\n", "\treturn -1;\n", "}\n"], "project": "asterisk-modules", "file": "menuselect_stub.pkl", "function": "run_menu"}, {"comment_all": {"comment": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */", "depth": 0, "reading_ease": 75.71, "reading_grade": 5.8, "line": 3672}, "comment_text": "/* Initializes or reinitializes a buffer.\n * This function is sometimes called more than once on the same buffer,\n * such as during a yyrestart() or at EOF.\n */", "comment_tokens": ["Initializes", "or", "reinitializes", "a", "buffer", ".", "This", "function", "is", "sometimes", "called", "more", "than", "once", "on", "the", "same", "buffer", ",", "such", "as", "during", "a", "yyrestart", "(", ")", "or", "at", "EOF", "."], "ccode": ["\n", "/* Initializes or reinitializes a buffer.\n", " * This function is sometimes called more than once on the same buffer,\n", " * such as during a yyrestart() or at EOF.\n", " */\n", "    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n", "\n", "{\n", "\tint oerrno = errno;\n", "    \n", "\tyy_flush_buffer( b );\n", "\n", "\tb->yy_input_file = file;\n", "\tb->yy_fill_buffer = 1;\n", "\n", "    /* If b is the current buffer, then yy_init_buffer was _probably_\n", "     * called from yyrestart() or through yy_get_next_buffer.\n", "     * In that case, we don't want to reset the lineno or column.\n", "     */\n", "    if (b != YY_CURRENT_BUFFER){\n", "        b->yy_bs_lineno = 1;\n", "        b->yy_bs_column = 0;\n", "    }\n", "\n", "        b->yy_is_interactive = 0;\n", "    \n", "\terrno = oerrno;\n", "}\n"], "project": "linux-headers-5.10.0-1021-oem", "file": "lexer.lex.pkl", "function": "yy_init_buffer"}, {"comment_all": {"comment": "/* This dependency is not met, so we can stop now */", "depth": 5, "reading_ease": 86.71, "reading_grade": 3.7, "line": 654}, "comment_text": "/* This dependency is not met, so we can stop now */", "comment_tokens": ["This", "dependency", "is", "not", "met", ",", "so", "we", "can", "stop", "now"], "ccode": ["\n", "/*!\n", " * \\arg interactive Set to non-zero if being called while user is making changes\n", " */\n", "static unsigned int calc_dep_failures(int interactive, int pre_confload)\n", "{\n", "\tunsigned int result = 0;\n", "\tstruct category *cat;\n", "\tstruct member *mem;\n", "\tstruct reference *dep;\n", "\tstruct dep_file *dep_file;\n", "\tunsigned int changed, old_failure;\n", "\n", "\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\tif (mem->is_separator) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\told_failure = mem->depsfailed;\n", "\t\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n", "\t\t\t\tif (dep->member)\n", "\t\t\t\t\tcontinue;\n", "\n", "\t\t\t\tmem->depsfailed = HARD_FAILURE;\n", "\t\t\t\tAST_LIST_TRAVERSE(&deps_file, dep_file, list) {\n", "\t\t\t\t\tif (!strcasecmp(dep_file->name, dep->name)) {\n", "\t\t\t\t\t\tif (dep_file->met == DEP_FILE_MET) {\n", "\t\t\t\t\t\t\tmem->depsfailed = NO_FAILURE;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tif (mem->depsfailed != NO_FAILURE) {\n", "\t\t\t\t\tbreak; /* This dependency is not met, so we can stop now */\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif (old_failure == SOFT_FAILURE && mem->depsfailed != HARD_FAILURE)\n", "\t\t\t\tmem->depsfailed = SOFT_FAILURE;\n", "\t\t}\n", "\t}\n", "\n", "\tif (pre_confload) {\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tdo {\n", "\t\tchanged = 0;\n", "\n", "\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\t\tif (mem->is_separator) {\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t}\n", "\n", "\t\t\t\told_failure = mem->depsfailed;\n", "\n", "\t\t\t\tif (mem->depsfailed == HARD_FAILURE)\n", "\t\t\t\t\tcontinue;\n", "\n", "\t\t\t\tmem->depsfailed = NO_FAILURE;\n", "\n", "\t\t\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n", "\t\t\t\t\tif (!dep->member)\n", "\t\t\t\t\t\tcontinue;\n", "\t\t\t\t\tif (dep->member->depsfailed == HARD_FAILURE) {\n", "\t\t\t\t\t\tmem->depsfailed = HARD_FAILURE;\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\t} else if (dep->member->depsfailed == SOFT_FAILURE) {\n", "\t\t\t\t\t\tmem->depsfailed = SOFT_FAILURE;\n", "\t\t\t\t\t} else if (!dep->member->enabled) {\n", "\t\t\t\t\t\tmem->depsfailed = SOFT_FAILURE;\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\n", "\t\t\t\tif (mem->depsfailed != old_failure) {\n", "\t\t\t\t\tif ((mem->depsfailed == NO_FAILURE) && mem->was_defaulted) {\n", "\t\t\t\t\t\tmem->enabled = !strcasecmp(mem->defaultenabled, \"yes\");\n", "\t\t\t\t\t\tprint_debug(\"Just set %s enabled to %d\\n\", mem->name, mem->enabled);\n", "\t\t\t\t\t} else {\n", "\t\t\t\t\t\tmem->enabled = interactive ? 0 : mem->was_enabled;\n", "\t\t\t\t\t\tprint_debug(\"Just set %s enabled to %d\\n\", mem->name, mem->enabled);\n", "\t\t\t\t\t}\n", "\t\t\t\t\tchanged = 1;\n", "\t\t\t\t\tbreak; /* This dependency is not met, so we can stop now */\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif (changed)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\n", "\t\tif (changed)\n", "\t\t\tresult = 1;\n", "\n", "\t} while (changed);\n", "\n", "\treturn result;\n", "}\n"], "project": "asterisk-vpb", "file": "menuselect.pkl", "function": "calc_dep_failures"}, {"comment_all": {"comment": "/* Copyright 2019 Philip Heron <phil@sanslogic.co.uk>                    */", "depth": 0, "reading_ease": 49.48, "reading_grade": 7.6, "line": 2}, "comment_text": "/* Copyright 2019 Philip Heron <phil@sanslogic.co.uk>                    */", "comment_tokens": ["Copyright", "2019", "Philip", "Heron", "<", "phil", "@", "sanslogic.co.uk", ">"], "ccode": ["/* hacktv - Analogue video transmitter for the HackRF                    */\n", "/*=======================================================================*/\n", "/* Copyright 2019 Philip Heron <phil@sanslogic.co.uk>                    */\n", "/*                                                                       */\n", "/* This program is free software: you can redistribute it and/or modify  */\n", "/* it under the terms of the GNU General Public License as published by  */\n", "/* the Free Software Foundation, either version 3 of the License, or     */\n", "/* (at your option) any later version.                                   */\n", "/*                                                                       */\n", "/* This program is distributed in the hope that it will be useful,       */\n", "/* but WITHOUT ANY WARRANTY; without even the implied warranty of        */\n", "/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */\n", "/* GNU General Public License for more details.                          */\n", "/*                                                                       */\n", "/* You should have received a copy of the GNU General Public License     */\n", "/* along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n", "\n", "/* -=== ACP / Macrovision encoder ===- */\n", "\n", "#include <stdint.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <math.h>\n", "#include \"video.h\"\n", "\n", "int acp_init(acp_t *s, vid_t *vid)\n", "{\n", "\tdouble left;\n", "\tdouble spacing;\n", "\tdouble psync_width;\n", "\tint i;\n", "\t\n", "\tmemset(s, 0, sizeof(acp_t));\n", "\t\n", "\ts->vid = vid;\n", "\t\n", "\tif(s->vid->conf.lines == 625)\n", "\t{\n", "\t\tleft = 8.88e-6;\n", "\t\tspacing = 5.92e-6;\n", "\t\tpsync_width = 2.368e-6;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tleft = 8.288e-6;\n", "\t\tspacing = 8.288e-6;\n", "\t\tpsync_width = 2.222e-6;\n", "\t}\n", "\t\n", "\t/* Calculate the levels */\n", "\ts->psync_level = vid->sync_level + round((vid->white_level - vid->sync_level) * 0.06);\n", "\ts->pagc_level  = vid->sync_level + round((vid->white_level - vid->sync_level) * 1.10);\n", "\t\n", "\t/* Calculate the width of each pulse */\n", "\ts->psync_width = round(vid->sample_rate * psync_width);\n", "\ts->pagc_width  = round(vid->sample_rate * 2.7e-6);\n", "\t\n", "\t/* Left position of each pulse */\n", "\tfor(i = 0; i < 6; i++)\n", "\t{\n", "\t\ts->left[i] = round(vid->sample_rate * (left + spacing * i));\n", "\t}\n", "\t\n", "\treturn(VID_OK);\n", "}\n"], "project": "hacktv", "file": "acp.pkl", "function": "acp_init"}, {"comment_all": {"comment": "/* get input block in little-endian format */", "depth": 2, "reading_ease": 48.47, "reading_grade": 8.0, "line": 282}, "comment_text": "/* get input block in little-endian format */", "comment_tokens": ["get", "input", "block", "in", "little-endian", "format"], "ccode": ["#endif\n", "#endif\n", "\n", "#ifndef ONLY_SKEIN_256\n", "\n", "/*****************************  Skein_512 ******************************/\n", "#if !(SKEIN_USE_ASM & 512)\n", "void Skein_512_Process_Block(Skein_512_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\n", "    { /* do it in C */\n", "    enum\n", "        {\n", "        WCNT = SKEIN_512_STATE_WORDS\n", "        };\n", "#undef  RCNT\n", "#define RCNT  (SKEIN_512_ROUNDS_TOTAL/8)\n", "\n", "#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\n", "#define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)\n", "#else\n", "#define SKEIN_UNROLL_512 (0)\n", "#endif\n", "\n", "#if SKEIN_UNROLL_512\n", "#if (RCNT % SKEIN_UNROLL_512)\n", "#error \"Invalid SKEIN_UNROLL_512\"               /* sanity check on unroll count */\n", "#endif\n", "    size_t  r;\n", "    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\n", "#else\n", "    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\n", "#endif\n", "    u64b_t  X0,X1,X2,X3,X4,X5,X6,X7;            /* local copy of vars, for speed */\n", "    u64b_t  w [WCNT];                           /* local copy of input block */\n", "#ifdef SKEIN_DEBUG\n", "    const u64b_t *Xptr[8];                      /* use for debugging (help compiler put Xn in registers) */\n", "    Xptr[0] = &X0;  Xptr[1] = &X1;  Xptr[2] = &X2;  Xptr[3] = &X3;\n", "    Xptr[4] = &X4;  Xptr[5] = &X5;  Xptr[6] = &X6;  Xptr[7] = &X7;\n", "#endif\n", "\n", "    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\n", "\tts[0] = ctx->h.T[0];\n", "\tts[1] = ctx->h.T[1];\n", "    do  {\n", "        /* this implementation only supports 2**64 input bytes (no carry out here) */\n", "        ts[0] += byteCntAdd;                    /* update processed length */\n", "\n", "        /* precompute the key schedule for this block */\n", "        ks[0] = ctx->X[0];\n", "        ks[1] = ctx->X[1];\n", "        ks[2] = ctx->X[2];\n", "        ks[3] = ctx->X[3];\n", "        ks[4] = ctx->X[4];\n", "        ks[5] = ctx->X[5];\n", "        ks[6] = ctx->X[6];\n", "        ks[7] = ctx->X[7];\n", "        ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ \n", "                ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\n", "\n", "        ts[2] = ts[0] ^ ts[1];\n", "\n", "        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\n", "\t\tDebugSaveTweak(ctx);\n", "        Skein_Show_Block(BLK_BITS,&ctx->h,ctx->X,blkPtr,w,ks,ts);\n", "\n", "        X0   = w[0] + ks[0];                    /* do the first full key injection */\n", "        X1   = w[1] + ks[1];\n", "        X2   = w[2] + ks[2];\n", "        X3   = w[3] + ks[3];\n", "        X4   = w[4] + ks[4];\n", "        X5   = w[5] + ks[5] + ts[0];\n", "        X6   = w[6] + ks[6] + ts[1];\n", "        X7   = w[7] + ks[7];\n", "\n", "        blkPtr += SKEIN_512_BLOCK_BYTES;\n", "\n", "        Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INITIAL,Xptr);\n", "        /* run the rounds */\n", "#define Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                  \\\n", "    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \\\n", "    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \\\n", "    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \\\n", "    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \\\n", "\n", "#if SKEIN_UNROLL_512 == 0                       \n", "#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)      /* unrolled */  \\\n", "    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n", "    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);\n", "\n", "#define I512(R)                                                     \\\n", "    X0   += ks[((R)+1) % 9];   /* inject the key schedule value */  \\\n", "    X1   += ks[((R)+2) % 9];                                        \\\n", "    X2   += ks[((R)+3) % 9];                                        \\\n", "    X3   += ks[((R)+4) % 9];                                        \\\n", "    X4   += ks[((R)+5) % 9];                                        \\\n", "    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \\\n", "    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \\\n", "    X7   += ks[((R)+8) % 9] +     (R)+1;                            \\\n", "    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\n", "#else                                       /* looping version */\n", "#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n", "    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n", "    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);\n", "\n", "#define I512(R)                                                     \\\n", "    X0   += ks[r+(R)+0];        /* inject the key schedule value */ \\\n", "    X1   += ks[r+(R)+1];                                            \\\n", "    X2   += ks[r+(R)+2];                                            \\\n", "    X3   += ks[r+(R)+3];                                            \\\n", "    X4   += ks[r+(R)+4];                                            \\\n", "    X5   += ks[r+(R)+5] + ts[r+(R)+0];                              \\\n", "    X6   += ks[r+(R)+6] + ts[r+(R)+1];                              \\\n", "    X7   += ks[r+(R)+7] +    r+(R)   ;                              \\\n", "    ks[r +       (R)+8] = ks[r+(R)-1];  /* rotate key schedule */   \\\n", "    ts[r +       (R)+2] = ts[r+(R)-1];                              \\\n", "    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\n", "\n", "    for (r=1;r < 2*RCNT;r+=2*SKEIN_UNROLL_512)   /* loop thru it */\n", "#endif                         /* end of looped code definitions */\n", "        {\n", "#define R512_8_rounds(R)  /* do 8 full rounds */  \\\n", "        R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1);   \\\n", "        R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2);   \\\n", "        R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3);   \\\n", "        R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4);   \\\n", "        I512(2*(R));                              \\\n", "        R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5);   \\\n", "        R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6);   \\\n", "        R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7);   \\\n", "        R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8);   \\\n", "        I512(2*(R)+1);        /* and key injection */\n", "\n", "        R512_8_rounds( 0);\n", "\n", "#define R512_Unroll_R(NN) ((SKEIN_UNROLL_512 == 0 && SKEIN_512_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_512 > (NN)))\n", "\n", "  #if   R512_Unroll_R( 1)\n", "        R512_8_rounds( 1);\n", "  #endif\n", "  #if   R512_Unroll_R( 2)\n", "        R512_8_rounds( 2);\n", "  #endif\n", "  #if   R512_Unroll_R( 3)\n", "        R512_8_rounds( 3);\n", "  #endif\n", "  #if   R512_Unroll_R( 4)\n", "        R512_8_rounds( 4);\n", "  #endif\n", "  #if   R512_Unroll_R( 5)\n", "        R512_8_rounds( 5);\n", "  #endif\n", "  #if   R512_Unroll_R( 6)\n", "        R512_8_rounds( 6);\n", "  #endif\n", "  #if   R512_Unroll_R( 7)\n", "        R512_8_rounds( 7);\n", "  #endif\n", "  #if   R512_Unroll_R( 8)\n", "        R512_8_rounds( 8);\n", "  #endif\n", "  #if   R512_Unroll_R( 9)\n", "        R512_8_rounds( 9);\n", "  #endif\n", "  #if   R512_Unroll_R(10)\n", "        R512_8_rounds(10);\n", "  #endif\n", "  #if   R512_Unroll_R(11)\n", "        R512_8_rounds(11);\n", "  #endif\n", "  #if   R512_Unroll_R(12)\n", "        R512_8_rounds(12);\n", "  #endif\n", "  #if   R512_Unroll_R(13)\n", "        R512_8_rounds(13);\n", "  #endif\n", "  #if   R512_Unroll_R(14)\n", "        R512_8_rounds(14);\n", "  #endif\n", "  #if  (SKEIN_UNROLL_512 > 14)\n", "#error  \"need more unrolling in Skein_512_Process_Block\"\n", "  #endif\n", "        }\n", "\n", "        /* do the final \"feedforward\" xor, update context chaining vars */\n", "        ctx->X[0] = X0 ^ w[0];\n", "        ctx->X[1] = X1 ^ w[1];\n", "        ctx->X[2] = X2 ^ w[2];\n", "        ctx->X[3] = X3 ^ w[3];\n", "        ctx->X[4] = X4 ^ w[4];\n", "        ctx->X[5] = X5 ^ w[5];\n", "        ctx->X[6] = X6 ^ w[6];\n", "        ctx->X[7] = X7 ^ w[7];\n", "        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_FEED_FWD,ctx->X);\n", "\n", "        ts[1] &= ~SKEIN_T1_FLAG_FIRST;\n", "        }\n", "    while (--blkCnt);\n", "    ctx->h.T[0] = ts[0];\n", "    ctx->h.T[1] = ts[1];\n", "    }\n"], "project": "ekeyd", "file": "skein_block.pkl", "function": "Skein_512_Process_Block"}, {"comment_all": {"comment": "// try to get shell 1.0 interface instead.\n", "depth": 1, "reading_ease": 84.84, "reading_grade": 2.3, "line": 102}, "comment_text": "// try to get shell 1.0 interface instead.\n", "comment_tokens": ["try", "to", "get", "shell", "1.0", "interface", "instead", "."], "ccode": ["\n", "INTN GetShellArgcArgv(EFI_HANDLE ImageHandle, CHAR16 **Argv[])\n", "{\n", "  // Code inspired from EDK2's\n", "  // ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.c (BSD)\n", "  EFI_STATUS Status;\n", "  static const EFI_GUID EfiShellParametersProtocolGuid\n", "      = EFI_SHELL_PARAMETERS_PROTOCOL_GUID;\n", "  static const EFI_GUID ShellInterfaceProtocolGuid\n", "      = SHELL_INTERFACE_PROTOCOL_GUID;\n", "  EFI_SHELL_PARAMETERS_PROTOCOL *EfiShellParametersProtocol = NULL;\n", "  EFI_SHELL_INTERFACE *EfiShellInterfaceProtocol = NULL;\n", "\n", "  Status = uefi_call_wrapper(BS->OpenProtocol, 6,\n", "                             ImageHandle,\n", "                             (EFI_GUID*)&EfiShellParametersProtocolGuid,\n", "                             (VOID **)&EfiShellParametersProtocol,\n", "                             ImageHandle,\n", "                             NULL,\n", "                             EFI_OPEN_PROTOCOL_GET_PROTOCOL\n", "                             );\n", "  if (!EFI_ERROR(Status))\n", "  {\n", "    // use shell 2.0 interface\n", "    // Print(L\"Got argc/argv from shell intf proto\\n\");\n", "    *Argv = EfiShellParametersProtocol->Argv;\n", "    return EfiShellParametersProtocol->Argc;\n", "  }\n", "\n", "  // try to get shell 1.0 interface instead.\n", "  Status = uefi_call_wrapper(BS->OpenProtocol, 6,\n", "                             ImageHandle,\n", "                             (EFI_GUID*)&ShellInterfaceProtocolGuid,\n", "                             (VOID **)&EfiShellInterfaceProtocol,\n", "                             ImageHandle,\n", "                             NULL,\n", "                             EFI_OPEN_PROTOCOL_GET_PROTOCOL\n", "                             );\n", "  if (!EFI_ERROR(Status))\n", "  {\n", "    // Print(L\"Got argc/argv from shell params proto\\n\");\n", "    *Argv = EfiShellInterfaceProtocol->Argv;\n", "    return EfiShellInterfaceProtocol->Argc;\n", "  }\n", "\n", "  // shell 1.0 and 2.0 interfaces failed\n", "  return GetShellArgcArgvFromLoadedImage(ImageHandle, Argv);\n", "}\n"], "project": "gnu-efi", "file": "cmdline.pkl", "function": "GetShellArgcArgv"}, {"comment_all": {"comment": "/* FIXME: Nothing so far, to be expanded... */", "depth": 1, "reading_ease": 81.29, "reading_grade": 3.7, "line": 116}, "comment_text": "/* FIXME: Nothing so far, to be expanded... */", "comment_tokens": ["FIXME", ":", "Nothing", "so", "far", ",", "to", "be", "expanded", "..."], "ccode": ["\n", "void cif2restart( void )\n", "{\n", "    /* FIXME: Nothing so far, to be expanded... */\n", "}\n"], "project": "libcod-cif-parser-yapp-perl", "file": "cif2_lexer.pkl", "function": "cif2restart"}, {"comment_all": {"comment": "/* ILMI spec - page 90 */", "depth": 0, "reading_ease": 92.8, "reading_grade": 1.3, "line": 92}, "comment_text": "/* Attachment point info */\n/* ILMI spec - page 90 */\n", "comment_tokens": ["Attachment", "point", "info", "ILMI", "spec", "-", "page", "90"], "ccode": ["\n", "/* Attachment point info */\n", "/* ILMI spec - page 90 */\n", "void action_A12( int fd, Msgs *msgs ){\n", "\tdiag( COMPONENT, DIAG_INFO, \"Action A12: get attachment point\" );\n", "\tmsgs->apointmsg->data->a.get_next_request->request_id = ++requestID;\n", "\tsend_message( fd, msgs->apointmsg );\n", "}\n"], "project": "libatm1-dev", "file": "actions.pkl", "function": "action_A12"}, {"comment_all": {"comment": "/* This is useful when an image has been created from a PNG file,\n * so it could be either truecolor or 8-bit. */", "depth": 0, "reading_ease": 75.54, "reading_grade": 7.9, "line": 199}, "comment_text": "/* This is useful when an image has been created from a PNG file,\n * so it could be either truecolor or 8-bit. */", "comment_tokens": ["This", "is", "useful", "when", "an", "image", "has", "been", "created", "from", "a", "PNG", "file", ",", "so", "it", "could", "be", "either", "truecolor", "or", "8-bit", "."], "ccode": ["\n", "/* This is useful when an image has been created from a PNG file,\n", " * so it could be either truecolor or 8-bit. */\n", "value ml_image_is_truecolor(value gdw) {\n", "  gdImagePtr im;\n", "  im = IM_VAL(gdw);\n", "  if (im->trueColor) {\n", "      return Val_true;\n", "  }\n", "  else {\n", "      return Val_false;\n", "  }\n", "}\n"], "project": "libgd-ocaml-dev", "file": "gdstubs.pkl", "function": "ml_image_is_truecolor"}, {"comment_all": {"comment": "/**\n * the direct function of => zzip_close(fp). it will cleanup the\n * inflate-portion of => zlib and free the structure given.\n *\n * it is called quite from the error-cleanup parts\n * of the various => _open functions.\n *\n * the .refcount is decreased and if zero the fp->dir is closed just as well.\n */", "depth": 0, "reading_ease": 77.23, "reading_grade": 5.2, "line": 37}, "comment_text": "/**\n * the direct function of => zzip_close(fp). it will cleanup the\n * inflate-portion of => zlib and free the structure given.\n *\n * it is called quite from the error-cleanup parts\n * of the various => _open functions.\n *\n * the .refcount is decreased and if zero the fp->dir is closed just as well.\n */", "comment_tokens": ["the", "direct", "function", "of", "=", ">", "zzip_close", "(", "fp", ")", ".", "it", "will", "cleanup", "the", "inflate-portion", "of", "=", ">", "zlib", "and", "free", "the", "structure", "given", ".", "it", "is", "called", "quite", "from", "the", "error-cleanup", "parts", "of", "the", "various", "=", ">", "_open", "functions", ".", "the", ".refcount", "is", "decreased", "and", "if", "zero", "the", "fp-", ">", "dir", "is", "closed", "just", "as", "well", "."], "ccode": ["\n", "/*\n", " * Author:\n", " *      Guido Draheim <guidod@gmx.de>\n", " *      Tomi Ollila <Tomi.Ollila@iki.fi>\n", " *\n", " * Copyright (c) 1999,2000,2001,2002,2003 Guido Draheim\n", " *          All rights reserved,\n", " *          use under the restrictions of the\n", " *          Lesser GNU General Public License\n", " *          or alternatively the restrictions\n", " *          of the Mozilla Public License 1.1\n", " */\n", "\n", "#include <zzip/lib.h>           /* exported... */\n", "#include <zzip/file.h>\n", "\n", "#include <string.h>\n", "#include <sys/stat.h>\n", "#include <errno.h>\n", "#include <stdlib.h>\n", "#include <ctype.h>\n", "\n", "#include <zzip/format.h>\n", "#include <zzip/fetch.h>\n", "#include <zzip/__debug.h>\n", "\n", "#if 0\n", "# if defined ZZIP_HAVE_IO_H\n", "# include <io.h>                /* tell */\n", "# else\n", "# define tell(fd) lseek(fd,0,SEEK_CUR)\n", "# endif\n", "#else\n", "#define tells(fd) seeks(fd,0,SEEK_CUR)\n", "#endif\n", "\n", "/**\n", " * the direct function of => zzip_close(fp). it will cleanup the\n", " * inflate-portion of => zlib and free the structure given.\n", " *\n", " * it is called quite from the error-cleanup parts\n", " * of the various => _open functions.\n", " *\n", " * the .refcount is decreased and if zero the fp->dir is closed just as well.\n", " */\n", "int\n", "zzip_file_close(ZZIP_FILE * fp)\n", "{\n", "    auto int self;\n", "    ZZIP_DIR *dir = fp->dir;\n", "\n", "    if (fp->method)\n", "        inflateEnd(&fp->d_stream);      /* inflateEnd() can be called many times */\n", "\n", "    if (dir->cache.locked == NULL)\n", "        dir->cache.locked = &self;\n", "\n", "    if (fp->buf32k)\n", "    {\n", "        if (dir->cache.locked == &self && dir->cache.buf32k == NULL)\n", "            dir->cache.buf32k = fp->buf32k;\n", "        else\n", "            free(fp->buf32k);\n", "    }\n", "\n", "    if (dir->currentfp == fp)\n", "        dir->currentfp = NULL;\n", "\n", "    dir->refcount--;\n", "    /* ease to notice possible dangling reference errors */\n", "    memset(fp, 0, sizeof(*fp));\n", "\n", "    if (dir->cache.locked == &self && dir->cache.fp == NULL)\n", "        dir->cache.fp = fp;\n", "    else\n", "        free(fp);\n", "\n", "    if (dir->cache.locked == &self)\n", "        dir->cache.locked = NULL;\n", "\n", "    if (! dir->refcount)\n", "        return zzip_dir_close(dir);\n", "    else\n", "        return 0;\n", "}\n"], "project": "zziplib-bin", "file": "file.pkl", "function": "zzip_file_close"}, {"comment_all": {"comment": "/**\n * SECTION:gupnp-last-change-parser\n * @short_description: A/V LastChange event XML parser\n *\n * #GUPnPLastChangeParser parses XML strings from LastChange events that are\n * generated by AVTransport and RenderingControl services.\n *\n */", "depth": 0, "reading_ease": 6.84, "reading_grade": 17.8, "line": 23}, "comment_text": "/**\n * SECTION:gupnp-last-change-parser\n * @short_description: A/V LastChange event XML parser\n *\n * #GUPnPLastChangeParser parses XML strings from LastChange events that are\n * generated by AVTransport and RenderingControl services.\n *\n */", "comment_tokens": ["SECTION", ":", "gupnp-last-change-parser", "@", "short_description", ":", "AV", "LastChange", "event", "XML", "parser", "#", "GUPnPLastChangeParser", "parses", "XML", "strings", "from", "LastChange", "events", "that", "are", "generated", "by", "AVTransport", "and", "RenderingControl", "services", "."], "ccode": ["/*\n", " * Copyright (C) 2007 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>\n", " * Copyright (C) 2007 OpenedHand Ltd\n", " *\n", " * Authors: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>\n", " *          Jorn Baayen <jorn@openedhand.com>\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n", " * Boston, MA 02110-1301, USA.\n", " */\n", "\n", "/**\n", " * SECTION:gupnp-last-change-parser\n", " * @short_description: A/V LastChange event XML parser\n", " *\n", " * #GUPnPLastChangeParser parses XML strings from LastChange events that are\n", " * generated by AVTransport and RenderingControl services.\n", " *\n", " */\n", "\n", "\n", "#include <gobject/gvaluecollector.h>\n", "\n", "#include \"gupnp-last-change-parser.h\"\n", "#include \"gvalue-util.h\"\n", "#include \"xml-util.h\"\n", "\n", "G_DEFINE_TYPE (GUPnPLastChangeParser,\n", "               gupnp_last_change_parser,\n", "               G_TYPE_OBJECT);\n", "\n", "static void\n", "gupnp_last_change_parser_init (G_GNUC_UNUSED GUPnPLastChangeParser *parser)\n", "{\n", "}\n"], "project": "libgupnp-av-1.0-dev", "file": "gupnp-last-change-parser.pkl", "function": "gupnp_last_change_parser_init"}, {"comment_all": {"comment": "/* addkern() {{{\n *\n * Adds a new kerning pair to the list. Does not check if the pair\n * already exists. The new pair is inserted at the beginning of the\n * list.\n */", "depth": 0, "reading_ease": 87.42, "reading_grade": 3.4, "line": 437}, "comment_text": "/* addkern() {{{\n *\n * Adds a new kerning pair to the list. Does not check if the pair\n * already exists. The new pair is inserted at the beginning of the\n * list.\n */", "comment_tokens": ["addkern", "(", ")", "{", "{", "{", "Adds", "a", "new", "kerning", "pair", "to", "the", "list", ".", "Does", "not", "check", "if", "the", "pair", "already", "exists", ".", "The", "new", "pair", "is", "inserted", "at", "the", "beginning", "of", "the", "list", "."], "ccode": ["/* }}} */\n", "\n", "/* addkern() {{{\n", " *\n", " * Adds a new kerning pair to the list. Does not check if the pair\n", " * already exists. The new pair is inserted at the beginning of the\n", " * list.\n", " */\n", "void addkern(PSDoc *psdoc, ADOBEINFO *ai, ADOBEINFO *succ, int kerning) {\n", "\tKERN *nk ;\n", "\n", "\tif((NULL == ai) || (NULL == succ)) {\n", "\t\terror(\"One of the glyphs is not set.\");\n", "\t\treturn;\n", "\t}\n", "\tnk = newkern(psdoc) ;\n", "\tnk->succ = newstring(psdoc, succ->adobename);\n", "\tnk->delta = kerning;\n", "\tnk->next = ai->kerns ;\n", "\tai->kerns = nk ;\n", "}\n"], "project": "pslib1", "file": "ps_afm.pkl", "function": "addkern"}, {"comment_all": {"comment": "/* Release keys, otherwise it will continue moving that way */", "depth": 4, "reading_ease": 53.88, "reading_grade": 8.0, "line": 151}, "comment_text": "/* Release keys, otherwise it will continue moving that way */", "comment_tokens": ["Release", "keys", ",", "otherwise", "it", "will", "continue", "moving", "that", "way"], "ccode": ["\n", "int intr_sysupdate()\n", "{\n", "\tSDL_Event e;\n", "\tint i = 0;\n", "\tstatic int last_time = 0;\n", "\tint now, time_diff;\n", "\n", "\twhile (SDL_PollEvent(&e)) {\n", "\t\tswitch (e.type) {\n", "\t\t\tcase SDL_QUIT:\n", "\t\t\t\tSDL_Quit();\n", "\t\t\t\texit(1);\n", "\t\t\t\tbreak;\n", "\t\t\tcase SDL_MOUSEBUTTONDOWN:\n", "\t\t\tcase SDL_MOUSEBUTTONUP:\n", "\t\t\t\tif(e.button.state == SDL_PRESSED &&\n", "\t\t\t\t\t\t((key_pressed(KEY_PL3_LEFT) && e.button.button == SDL_BUTTON_RIGHT) ||\n", "\t\t\t\t\t\t(key_pressed(KEY_PL3_RIGHT) && e.button.button == SDL_BUTTON_LEFT) ||\n", "\t\t\t\t\t\t(e.button.button == SDL_BUTTON_LEFT && e.button.button == SDL_BUTTON_RIGHT) ||\n", "\t\t\t  e.button.button == SDL_BUTTON_MIDDLE))\n", "\t\t\t\t\t{\n", "\t\t\t\t\taddkey(KEY_PL3_JUMP & 0x7fff);\n", "\t\t\t\t\t}\n", "\t\t\t\telse if(e.button.state == SDL_RELEASED &&\n", "\t\t\t\t\t\t((key_pressed(KEY_PL3_LEFT) && e.button.button == SDL_BUTTON_RIGHT) ||\n", "\t\t\t\t\t\t(key_pressed(KEY_PL3_RIGHT) && e.button.button == SDL_BUTTON_LEFT) ||\n", "\t\t\t  e.button.button == SDL_BUTTON_MIDDLE))\n", "\t\t\t\t\t{\n", "\t\t\t\t\taddkey((KEY_PL3_JUMP & 0x7fff) | 0x8000);\n", "\t\t\t\t\t}\n", "\n", "\t\t\t\tif(e.button.button == SDL_BUTTON_LEFT)\n", "\t\t\t\t\t{\n", "\t\t\t\t\tSDL_Scancode scancode = KEY_PL3_LEFT;\n", "\t\t\t\t\tscancode &= 0x7fff;\n", "\t\t\t\t\tif(e.button.state == SDL_RELEASED)\n", "\t\t\t\t\t\t{\n", "\t\t\t\t\t\tif(key_pressed(KEY_PL3_JUMP) && (SDL_GetMouseState(NULL, NULL)&SDL_BUTTON(SDL_BUTTON_RIGHT)))\n", "\t\t\t\t\t\t\taddkey(KEY_PL3_RIGHT & 0x7fff);\n", "\t\t\t\t\t\telse\n", "\t\t\t\t\t\t\tscancode |= 0x8000;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\taddkey(scancode);\n", "\t\t\t\t\t}\n", "\t\t\t\telse if(e.button.button == SDL_BUTTON_RIGHT)\n", "\t\t\t\t\t{\n", "\t\t\t\t\tSDL_Scancode scancode = KEY_PL3_RIGHT;\n", "\t\t\t\t\tscancode &= 0x7fff;\n", "\t\t\t\t\tif (e.button.state == SDL_RELEASED)\n", "\t\t\t\t\t\t{\n", "\t\t\t\t\t\tif(key_pressed(KEY_PL3_JUMP) && (SDL_GetMouseState(NULL, NULL)&SDL_BUTTON(SDL_BUTTON_LEFT)))\n", "\t\t\t\t\t\t\taddkey(KEY_PL3_LEFT & 0x7fff);\n", "\t\t\t\t\t\telse\n", "\t\t\t\t\t\t\tscancode |= 0x8000;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\taddkey(scancode);\n", "\t\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase SDL_KEYDOWN:\n", "\t\t\tcase SDL_KEYUP:\n", "\t\t\t\tif (e.key.repeat != 0) {\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t}\n", "\t\t\t\tswitch (e.key.keysym.scancode) {\n", "\t\t\t\t\tcase SDL_SCANCODE_F12:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYDOWN) {\n", "\t\t\t\t\t\t\tSDL_Quit();\n", "\t\t\t\t\t\t\texit(1);\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_F10:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYDOWN) {\n", "\t\t\t\t\t\t\tfs_toggle();\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_1:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP)\n", "\t\t\t\t\t\t\tai[0] = !ai[0];\n", "\n", "\t\t\t\t\t\t/* Release keys, otherwise it will continue moving that way */\n", "\t\t\t\t\t\taddkey((KEY_PL1_LEFT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL1_RIGHT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL1_JUMP & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_2:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP)\n", "\t\t\t\t\t\t\tai[1] = !ai[1];\n", "\n", "\t\t\t\t\t\t/* Release keys, otherwise it will continue moving that way */\n", "\t\t\t\t\t\taddkey((KEY_PL2_LEFT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL2_RIGHT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL2_JUMP & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_3:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP)\n", "\t\t\t\t\t\t\tai[2] = !ai[2];\n", "\n", "\t\t\t\t\t\t/* Release keys, otherwise it will continue moving that way */\n", "\t\t\t\t\t\taddkey((KEY_PL3_LEFT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL3_RIGHT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL3_JUMP & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_4:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP)\n", "\t\t\t\t\t\t\tai[3] = !ai[3];\n", "\n", "\t\t\t\t\t\t/* Release keys, otherwise it will continue moving that way */\n", "\t\t\t\t\t\taddkey((KEY_PL4_LEFT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL4_RIGHT & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\taddkey((KEY_PL4_JUMP & 0x7fff) | 0x8000);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase SDL_SCANCODE_ESCAPE:\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP)\n", "\t\t\t\t\t\t\taddkey(1 | 0x8000);\n", "\t\t\t\t\t\telse\n", "\t\t\t\t\t\t\taddkey(1 & 0x7fff);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tdefault:\n", "\t\t\t\t\t\te.key.keysym.scancode &= 0x7fff;\n", "\t\t\t\t\t\tif (e.type == SDL_KEYUP) {\n", "\t\t\t\t\t\t\te.key.keysym.scancode |= 0x8000;\n", "\t\t\t\t\t\t\tadd_last_key(e.key.keysym.sym);\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\taddkey(e.key.keysym.scancode);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\ti++;\n", "\t}\n", "\n", "\tSDL_Delay(1);\n", "\tnow = SDL_GetTicks();\n", "\ttime_diff = now - last_time;\n", "\tif (time_diff>0) {\n", "\t\ti = time_diff / (1000 / 60);\n", "\t\tif (i) {\n", "\t\t\tlast_time = now;\n", "\t\t} else {\n", "\t\t\tint tmp;\n", "\n", "\t\t\ttmp = (1000/60) - i - 10;\n", "\t\t\tif (tmp>0)\n", "\t\t\t\tSDL_Delay(tmp);\n", "\t\t}\n", "\t}\n", "\n", "\treturn i;\n", "}\n"], "project": "jumpnbump", "file": "interrpt.pkl", "function": "intr_sysupdate"}, {"comment_all": {"comment": "/*\n\t Map the Interrupt Vectors (0x0 - 0x400) + BIOS data (0x400 - 0x502)\n\t and the ROM (0xa0000 - 0x100000)\n\t*/", "depth": 1, "reading_ease": 81.63, "reading_grade": 5.6, "line": 210}, "comment_text": "/*\n\t Map the Interrupt Vectors (0x0 - 0x400) + BIOS data (0x400 - 0x502)\n\t and the ROM (0xa0000 - 0x100000)\n\t*/", "comment_tokens": ["Map", "the", "Interrupt", "Vectors", "(", "0x0", "-", "0x400", ")", "+", "BIOS", "data", "(", "0x400", "-", "0x502", ")", "and", "the", "ROM", "(", "0xa0000", "-", "0x100000", ")"], "ccode": ["\n", "int LRMI_common_init(void)\n", "{\n", "\tvoid *m;\n", "\tint fd_mem;\n", "\n", "\tif (!real_mem_init())\n", "\t\treturn 0;\n", "\n", "\t/*\n", "\t Map the Interrupt Vectors (0x0 - 0x400) + BIOS data (0x400 - 0x502)\n", "\t and the ROM (0xa0000 - 0x100000)\n", "\t*/\n", "\tfd_mem = open(\"/dev/mem\", O_RDWR);\n", "\n", "\tif (fd_mem == -1) {\n", "\t\treal_mem_deinit();\n", "\t\tperror(\"open /dev/mem\");\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tm = mmap((void *)0, 0x502,\n", "\t PROT_READ | PROT_WRITE | PROT_EXEC,\n", "\t MAP_FIXED | MAP_SHARED, fd_mem, 0);\n", "\n", "\tif (m == (void *)-1) {\n", "\t\tclose(fd_mem);\n", "\t\treal_mem_deinit();\n", "\t\tperror(\"mmap /dev/mem\");\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tm = mmap((void *)0xa0000, 0x100000 - 0xa0000,\n", "\t PROT_READ | PROT_WRITE | PROT_EXEC,\n", "\t MAP_FIXED | MAP_SHARED, fd_mem, 0xa0000);\n", "\n", "\tif (m == (void *)-1) {\n", "\t\tmunmap((void *)0, 0x502);\n", "\t\tclose(fd_mem);\n", "\t\treal_mem_deinit();\n", "\t\tperror(\"mmap /dev/mem\");\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tclose(fd_mem);\n", "\n", "\treturn 1;\n", "}\n"], "project": "libx86-1", "file": "x86-common.pkl", "function": "LRMI_common_init"}, {"comment_all": {"comment": "/* Write failed! */", "depth": 3, "reading_ease": 120.21, "reading_grade": -3.1, "line": 170}, "comment_text": "/* Write failed! */\n/* errno set by write system call. */\n", "comment_tokens": ["Write", "failed", "!", "errno", "set", "by", "write", "system", "call", "."], "ccode": ["\n", "/*\n", " * _FSFlush - Flush the FS request buffer.  If the buffer is empty, no\n", " * action is taken.  This routine correctly handles incremental writes.\n", " * This routine may have to be reworked if int < long.\n", " */\n", "void\n", "_FSFlush(register FSServer *svr)\n", "{\n", "    register long size,\n", "                todo;\n", "    register int write_stat;\n", "    register char *bufindex;\n", "\n", "    size = todo = svr->bufptr - svr->buffer;\n", "    bufindex = svr->bufptr = svr->buffer;\n", "    /*\n", "     * While write has not written the entire buffer, keep looping until the\n", "     * entire buffer is written.  bufindex will be incremented and size\n", "     * decremented as buffer is written out.\n", "     */\n", "    while (size) {\n", "\tESET(0);\n", "\twrite_stat = _FSTransWrite(svr->trans_conn, bufindex, (int) todo);\n", "\tif (write_stat >= 0) {\n", "\t    size -= write_stat;\n", "\t    todo = size;\n", "\t    bufindex += write_stat;\n", "\t} else if (ETEST()) {\n", "\t    _FSWaitForWritable(svr);\n", "#ifdef SUNSYSV\n", "\t} else if (ECHECK(0)) {\n", "\t    _FSWaitForWritable(svr);\n", "#endif\n", "\n", "#ifdef EMSGSIZE\n", "\t} else if (ECHECK(EMSGSIZE)) {\n", "\t    if (todo > 1)\n", "\t\ttodo >>= 1;\n", "\t    else\n", "\t\t_FSWaitForWritable(svr);\n", "#endif\n", "\t} else {\n", "\t    /* Write failed! */\n", "\t    /* errno set by write system call. */\n", "\t    (*_FSIOErrorFunction) (svr);\n", "\t}\n", "    }\n", "    svr->last_req = (char *) &_dummy_request;\n", "}\n"], "project": "libfs6", "file": "FSlibInt.pkl", "function": "_FSFlush"}, {"comment_all": {"comment": "/* sorted list of non-overlapping intervals of East Asian Ambiguous\n   * characters, generated by \"uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c\" */", "depth": 1, "reading_ease": 44.75, "reading_grade": 11.5, "line": 239}, "comment_text": "/* sorted list of non-overlapping intervals of East Asian Ambiguous\n   * characters, generated by \"uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c\" */", "comment_tokens": ["sorted", "list", "of", "non-overlapping", "intervals", "of", "East", "Asian", "Ambiguous", "characters", ",", "generated", "by", "``", "uniset", "+WIDTH-A", "-cat=Me", "-cat=Mn", "-cat=Cf", "c", "''"], "ccode": ["\n", "\n", "/*\n", " * The following functions are the same as mk_wcwidth() and\n", " * mk_wcswidth(), except that spacing characters in the East Asian\n", " * Ambiguous (A) category as defined in Unicode Technical Report #11\n", " * have a column width of 2. This variant might be useful for users of\n", " * CJK legacy encodings who want to migrate to UCS without changing\n", " * the traditional terminal character-width behaviour. It is not\n", " * otherwise recommended for general use.\n", " */\n", "static int mk_wcwidth_cjk(uint32_t ucs)\n", "{\n", "  /* sorted list of non-overlapping intervals of East Asian Ambiguous\n", "   * characters, generated by \"uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c\" */\n", "  static const struct interval ambiguous[] = {\n", "    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },\n", "    { 0x00AA, 0x00AA }, { 0x00AE, 0x00AE }, { 0x00B0, 0x00B4 },\n", "    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },\n", "    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },\n", "    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },\n", "    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },\n", "    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },\n", "    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },\n", "    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },\n", "    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },\n", "    { 0x0148, 0x014B }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },\n", "    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },\n", "    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },\n", "    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },\n", "    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },\n", "    { 0x02C4, 0x02C4 }, { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB },\n", "    { 0x02CD, 0x02CD }, { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB },\n", "    { 0x02DD, 0x02DD }, { 0x02DF, 0x02DF }, { 0x0391, 0x03A1 },\n", "    { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 }, { 0x03C3, 0x03C9 },\n", "    { 0x0401, 0x0401 }, { 0x0410, 0x044F }, { 0x0451, 0x0451 },\n", "    { 0x2010, 0x2010 }, { 0x2013, 0x2016 }, { 0x2018, 0x2019 },\n", "    { 0x201C, 0x201D }, { 0x2020, 0x2022 }, { 0x2024, 0x2027 },\n", "    { 0x2030, 0x2030 }, { 0x2032, 0x2033 }, { 0x2035, 0x2035 },\n", "    { 0x203B, 0x203B }, { 0x203E, 0x203E }, { 0x2074, 0x2074 },\n", "    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },\n", "    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },\n", "    { 0x2113, 0x2113 }, { 0x2116, 0x2116 }, { 0x2121, 0x2122 },\n", "    { 0x2126, 0x2126 }, { 0x212B, 0x212B }, { 0x2153, 0x2154 },\n", "    { 0x215B, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },\n", "    { 0x2190, 0x2199 }, { 0x21B8, 0x21B9 }, { 0x21D2, 0x21D2 },\n", "    { 0x21D4, 0x21D4 }, { 0x21E7, 0x21E7 }, { 0x2200, 0x2200 },\n", "    { 0x2202, 0x2203 }, { 0x2207, 0x2208 }, { 0x220B, 0x220B },\n", "    { 0x220F, 0x220F }, { 0x2211, 0x2211 }, { 0x2215, 0x2215 },\n", "    { 0x221A, 0x221A }, { 0x221D, 0x2220 }, { 0x2223, 0x2223 },\n", "    { 0x2225, 0x2225 }, { 0x2227, 0x222C }, { 0x222E, 0x222E },\n", "    { 0x2234, 0x2237 }, { 0x223C, 0x223D }, { 0x2248, 0x2248 },\n", "    { 0x224C, 0x224C }, { 0x2252, 0x2252 }, { 0x2260, 0x2261 },\n", "    { 0x2264, 0x2267 }, { 0x226A, 0x226B }, { 0x226E, 0x226F },\n", "    { 0x2282, 0x2283 }, { 0x2286, 0x2287 }, { 0x2295, 0x2295 },\n", "    { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 }, { 0x22BF, 0x22BF },\n", "    { 0x2312, 0x2312 }, { 0x2460, 0x24E9 }, { 0x24EB, 0x254B },\n", "    { 0x2550, 0x2573 }, { 0x2580, 0x258F }, { 0x2592, 0x2595 },\n", "    { 0x25A0, 0x25A1 }, { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 },\n", "    { 0x25B6, 0x25B7 }, { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 },\n", "    { 0x25C6, 0x25C8 }, { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 },\n", "    { 0x25E2, 0x25E5 }, { 0x25EF, 0x25EF }, { 0x2605, 0x2606 },\n", "    { 0x2609, 0x2609 }, { 0x260E, 0x260F }, { 0x2614, 0x2615 },\n", "    { 0x261C, 0x261C }, { 0x261E, 0x261E }, { 0x2640, 0x2640 },\n", "    { 0x2642, 0x2642 }, { 0x2660, 0x2661 }, { 0x2663, 0x2665 },\n", "    { 0x2667, 0x266A }, { 0x266C, 0x266D }, { 0x266F, 0x266F },\n", "    { 0x273D, 0x273D }, { 0x2776, 0x277F }, { 0xE000, 0xF8FF },\n", "    { 0xFFFD, 0xFFFD }, { 0xF0000, 0xFFFFD }, { 0x100000, 0x10FFFD }\n", "  };\n", "\n", "  /* binary search in table of non-spacing characters */\n", "  if (bisearch(ucs, ambiguous,\n", "               sizeof(ambiguous) / sizeof(struct interval) - 1))\n", "    return 2;\n", "\n", "  return mk_wcwidth(ucs);\n", "}\n"], "project": "libvterm-dev", "file": "unicode.pkl", "function": "mk_wcwidth_cjk"}, {"comment_all": {"comment": "/*\n\t\t\t * The EWMH spec states that if the cardinal returned\n\t\t\t * is 0xFFFFFFFF (-1) then the window should appear\n\t\t\t * on all desktops, in our case, group 0.\n\t\t\t */", "depth": 3, "reading_ease": 79.94, "reading_grade": 8.3, "line": 399}, "comment_text": "/*\n\t\t\t * The EWMH spec states that if the cardinal returned\n\t\t\t * is 0xFFFFFFFF (-1) then the window should appear\n\t\t\t * on all desktops, in our case, group 0.\n\t\t\t */", "comment_tokens": ["The", "EWMH", "spec", "states", "that", "if", "the", "cardinal", "returned", "is", "0xFFFFFFFF", "(", "-1", ")", "then", "the", "window", "should", "appear", "on", "all", "desktops", ",", "in", "our", "case", ",", "group", "0", "."], "ccode": ["\n", "static void\n", "xev_handle_clientmessage(XEvent *ee)\n", "{\n", "\tXClientMessageEvent\t*e = &ee->xclient;\n", "\tstruct client_ctx\t*cc, *old_cc;\n", "\tstruct screen_ctx       *sc;\n", "\n", "\tLOG_DEBUG3(\"window: 0x%lx\", e->window);\n", "\n", "\tif (e->message_type == cwmh[WM_CHANGE_STATE]) {\n", "\t\tif ((cc = client_find(e->window)) != NULL) {\n", "\t    \t\tif (e->data.l[0] == IconicState)\n", "\t\t\t\tclient_hide(cc);\n", "\t\t}\n", "\t} else if (e->message_type == ewmh[_NET_CLOSE_WINDOW]) {\n", "\t\tif ((cc = client_find(e->window)) != NULL) {\n", "\t\t\tclient_send_delete(cc);\n", "\t\t}\n", "\t} else if (e->message_type == ewmh[_NET_ACTIVE_WINDOW]) {\n", "\t\tif ((cc = client_find(e->window)) != NULL) {\n", "\t\t\tif ((old_cc = client_current()) != NULL)\n", "\t\t\t\tclient_ptrsave(old_cc);\n", "\t\t\tclient_show(cc);\n", "\t\t\tclient_ptrwarp(cc);\n", "\t\t}\n", "\t} else if (e->message_type == ewmh[_NET_WM_DESKTOP]) {\n", "\t\tif ((cc = client_find(e->window)) != NULL) {\n", "\t\t\t/*\n", "\t\t\t * The EWMH spec states that if the cardinal returned\n", "\t\t\t * is 0xFFFFFFFF (-1) then the window should appear\n", "\t\t\t * on all desktops, in our case, group 0.\n", "\t\t\t */\n", "\t\t\tif (e->data.l[0] == (unsigned long)-1)\n", "\t\t\t\tgroup_movetogroup(cc, 0);\n", "\t\t\telse\n", "\t\t\t\tgroup_movetogroup(cc, e->data.l[0]);\n", "\t\t}\n", "\t} else if (e->message_type == ewmh[_NET_WM_STATE]) {\n", "\t\tif ((cc = client_find(e->window)) != NULL) {\n", "\t\t\txu_ewmh_handle_net_wm_state_msg(cc,\n", "\t\t\t    e->data.l[0], e->data.l[1], e->data.l[2]);\n", "\t\t}\n", "\t} else if (e->message_type == ewmh[_NET_CURRENT_DESKTOP]) {\n", "\t\tif ((sc = screen_find(e->window)) != NULL) {\n", "\t\t\tgroup_only(sc, e->data.l[0]);\n", "\t\t}\n", "\t}\n", "}\n"], "project": "cwm", "file": "xevents.pkl", "function": "xev_handle_clientmessage"}, {"comment_all": {"comment": "/* flips the drawto counter, registers the restored rects in the\n   new dirty_mask[drawto] array. */", "depth": 0, "reading_ease": 66.74, "reading_grade": 7.2, "line": 44}, "comment_text": "/* flips the drawto counter, registers the restored rects in the\n   new dirty_mask[drawto] array. */", "comment_tokens": ["flips", "the", "drawto", "counter", ",", "registers", "the", "restored", "rects", "in", "the", "new", "dirty_mask", "[", "drawto", "]", "array", "."], "ccode": ["\n", "/* flips the drawto counter, registers the restored rects in the\n", "   new dirty_mask[drawto] array. */\n", "void dirty_restore(SDL_Surface *target, SDL_Surface *background, \n", "\t\t   int bg_xoff, int bg_yoff)\n", "{\n", "  SDL_Rect r,rb;\n", "  unsigned long int mask;\n", "  int row;\n", "\n", "  if (all_dirty[1 - drawto])\n", "    {\n", "      r.x = bg_xoff;\n", "      r.y = bg_yoff;\n", "      r.w = target->w;\n", "      r.h = target->h;\n", "      SDL_BlitSurface(background,&r,target,0);\n", "    }\n", "  else\n", "    {\n", "      for (row = 0; row < 32; row++)\n", "\t{\n", "\t  r.y = row*DIRTY_TILE_SIZE;\n", "\t  r.h = DIRTY_TILE_SIZE;\n", "\t  r.x = 0;\n", "\t  r.w = 0;\n", "\t  \n", "\t  mask = dirty_mask[1 - drawto][row];\n", "\t  \n", "\t  while (mask)\n", "\t    {\n", "\t      while (mask && ((mask & 1) == 0))\n", "\t\t{\n", "\t\t  r.x += DIRTY_TILE_SIZE;\n", "\t\t  mask /= 2;\n", "\t\t}\n", "\t      while (mask && (mask & 1))\n", "\t\t{\n", "\t\t  r.w += DIRTY_TILE_SIZE;\n", "\t\t  mask /= 2;\n", "\t\t}\n", "\t      rb.x = r.x + bg_xoff;\n", "\t      rb.y = r.y + bg_yoff;\n", "\t      rb.w = r.w;\n", "\t      rb.h = r.h;\n", "\t      SDL_BlitSurface(background,&rb, target,&r);\n", "\t      r.x += r.w;\n", "\t      r.w = 0;\n", "\t    }\n", "\t}\n", "    }\n", "}\n"], "project": "airstrike-common", "file": "dirty.pkl", "function": "dirty_restore"}, {"comment_all": {"comment": "/**\n * return child node of an xavp\n * - $xavp(rname=>cname)\n */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 889}, "comment_text": "/**\n * return child node of an xavp\n * - $xavp(rname=>cname)\n */", "comment_tokens": ["return", "child", "node", "of", "an", "xavp", "-", "$", "xavp", "(", "rname=", ">", "cname", ")"], "ccode": ["\n", "/**\n", " * return child node of an xavp\n", " * - $xavp(rname=>cname)\n", " */\n", "sr_xavp_t* xavp_get_child(str *rname, str *cname)\n", "{\n", "\tsr_xavp_t *ravp=NULL;\n", "\n", "\travp = xavp_get(rname, NULL);\n", "\tif(ravp==NULL || ravp->val.type!=SR_XTYPE_XAVP)\n", "\t\treturn NULL;\n", "\n", "\treturn xavp_get(cname, ravp->val.v.xavp);\n", "}\n"], "project": "kamailio-tls-modules", "file": "xavp.pkl", "function": "xavp_get_child"}, {"comment_all": {"comment": "/* user entered their system password followed by generated OTP? */", "depth": 2, "reading_ease": 36.96, "reading_grade": 10.3, "line": 279}, "comment_text": "/* user entered their system password followed by generated OTP? */", "comment_tokens": ["user", "entered", "their", "system", "password", "followed", "by", "generated", "OTP", "?"], "ccode": ["\n", "PAM_EXTERN int\n", "pam_sm_authenticate (pam_handle_t * pamh,\n", "\t\t     int flags, int argc, const char **argv)\n", "{\n", "  int retval, rc;\n", "  const char *user = NULL;\n", "  const char *password = NULL;\n", "  char otp[MAX_OTP_LEN + 1];\n", "  int password_len = 0;\n", "  struct pam_conv *conv;\n", "  struct pam_message *pmsg[1], msg[1];\n", "  struct pam_response *resp;\n", "  int nargs = 1;\n", "  struct cfg cfg;\n", "  char *query_prompt = NULL;\n", "  char *onlypasswd = strdup (\"\");\t/* empty passwords never match */\n", "\n", "  if (!onlypasswd)\n", "    {\n", "      retval = PAM_BUF_ERR;\n", "      goto done;\n", "    }\n", "\n", "  parse_cfg (flags, argc, argv, &cfg);\n", "\n", "  retval = pam_get_user (pamh, &user, NULL);\n", "  if (retval != PAM_SUCCESS)\n", "    {\n", "      DBG ((\"get user returned error: %s\", pam_strerror (pamh, retval)));\n", "      goto done;\n", "    }\n", "  DBG ((\"get user returned: %s\", user));\n", "\n", "  if (cfg.try_first_pass || cfg.use_first_pass)\n", "    {\n", "      retval = pam_get_item (pamh, PAM_AUTHTOK, (const void **) &password);\n", "      if (retval != PAM_SUCCESS)\n", "\t{\n", "\t  DBG ((\"get password returned error: %s\",\n", "\t\tpam_strerror (pamh, retval)));\n", "\t  goto done;\n", "\t}\n", "      DBG ((\"get password returned: %s\", password));\n", "    }\n", "\n", "  if (cfg.use_first_pass && password == NULL)\n", "    {\n", "      DBG ((\"use_first_pass set and no password, giving up\"));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "\n", "  rc = oath_init ();\n", "  if (rc != OATH_OK)\n", "    {\n", "      DBG ((\"oath_init() failed (%d)\", rc));\n", "      retval = PAM_AUTHINFO_UNAVAIL;\n", "      goto done;\n", "    }\n", "\n", "  if (password == NULL)\n", "    {\n", "      retval = pam_get_item (pamh, PAM_CONV, (const void **) &conv);\n", "      if (retval != PAM_SUCCESS)\n", "\t{\n", "\t  DBG ((\"get conv returned error: %s\", pam_strerror (pamh, retval)));\n", "\t  goto done;\n", "\t}\n", "\n", "      pmsg[0] = &msg[0];\n", "      {\n", "\tconst char *query_template = \"One-time password (OATH) for `%s': \";\n", "\tsize_t len = strlen (query_template) + strlen (user);\n", "\tsize_t wrote;\n", "\n", "\tquery_prompt = malloc (len);\n", "\tif (!query_prompt)\n", "\t  {\n", "\t    retval = PAM_BUF_ERR;\n", "\t    goto done;\n", "\t  }\n", "\n", "\twrote = snprintf (query_prompt, len, query_template, user);\n", "\tif (wrote < 0 || wrote >= len)\n", "\t  {\n", "\t    retval = PAM_BUF_ERR;\n", "\t    goto done;\n", "\t  }\n", "\n", "\tmsg[0].msg = query_prompt;\n", "      }\n", "      msg[0].msg_style = PAM_PROMPT_ECHO_OFF;\n", "      resp = NULL;\n", "\n", "      retval = conv->conv (nargs, (const struct pam_message **) pmsg,\n", "\t\t\t   &resp, conv->appdata_ptr);\n", "\n", "      free (query_prompt);\n", "      query_prompt = NULL;\n", "\n", "      if (retval != PAM_SUCCESS)\n", "\t{\n", "\t  DBG ((\"conv returned error: %s\", pam_strerror (pamh, retval)));\n", "\t  goto done;\n", "\t}\n", "\n", "      DBG ((\"conv returned: %s\", resp->resp));\n", "\n", "      password = resp->resp;\n", "    }\n", "\n", "  if (password)\n", "    password_len = strlen (password);\n", "  else\n", "    {\n", "      DBG ((\"Could not read password\"));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "\n", "  if (password_len < MIN_OTP_LEN)\n", "    {\n", "      DBG ((\"OTP too short: %s\", password));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "  else if (cfg.digits != 0 && password_len < cfg.digits)\n", "    {\n", "      DBG ((\"OTP shorter than digits=%d: %s\", cfg.digits, password));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "  else if (cfg.digits == 0 && password_len > MAX_OTP_LEN)\n", "    {\n", "      DBG ((\"OTP too long (and no digits=): %s\", password));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "  else if (cfg.digits != 0 && password_len > cfg.digits)\n", "    {\n", "      free (onlypasswd);\n", "      onlypasswd = strdup (password);\n", "      if (!onlypasswd)\n", "        {\n", "          retval = PAM_BUF_ERR;\n", "          goto done;\n", "        }\n", "\n", "      /* user entered their system password followed by generated OTP? */\n", "\n", "      onlypasswd[password_len - cfg.digits] = '\\0';\n", "\n", "      DBG ((\"Password: %s \", onlypasswd));\n", "\n", "      memcpy (otp, password + password_len - cfg.digits, cfg.digits);\n", "      otp[cfg.digits] = '\\0';\n", "\n", "      retval = pam_set_item (pamh, PAM_AUTHTOK, onlypasswd);\n", "      if (retval != PAM_SUCCESS)\n", "\t{\n", "\t  DBG ((\"set_item returned error: %s\", pam_strerror (pamh, retval)));\n", "\t  goto done;\n", "\t}\n", "    }\n", "  else\n", "    {\n", "      strcpy (otp, password);\n", "      password = NULL;\n", "    }\n", "\n", "  DBG ((\"OTP: %s\", otp ? otp : \"(null)\"));\n", "\n", "  {\n", "    time_t last_otp;\n", "\n", "    rc = oath_authenticate_usersfile (cfg.usersfile,\n", "\t\t\t\t      user,\n", "\t\t\t\t      otp, cfg.window, onlypasswd, &last_otp);\n", "    DBG ((\"authenticate rc %d (%s: %s) last otp %s\", rc,\n", "\t  oath_strerror_name (rc) ? oath_strerror_name (rc) : \"UNKNOWN\",\n", "\t  oath_strerror (rc), ctime (&last_otp)));\n", "  }\n", "\n", "  if (rc != OATH_OK)\n", "    {\n", "      DBG ((\"One-time password not authorized to login as user '%s'\", user));\n", "      retval = PAM_AUTH_ERR;\n", "      goto done;\n", "    }\n", "\n", "  retval = PAM_SUCCESS;\n", "\n", "done:\n", "  oath_done ();\n", "  free (query_prompt);\n", "  free (onlypasswd);\n", "  if (cfg.alwaysok && retval != PAM_SUCCESS)\n", "    {\n", "      DBG ((\"alwaysok needed (otherwise return with %d)\", retval));\n", "      retval = PAM_SUCCESS;\n", "    }\n", "  DBG ((\"done. [%s]\", pam_strerror (pamh, retval)));\n", "\n", "  return retval;\n", "}\n"], "project": "liboath-dev", "file": "pam_oath.pkl", "function": "pam_sm_authenticate"}, {"comment_all": {"comment": "/*\n * srtp_auth_type_self_test(at) performs srtp_auth_type_test on at's internal\n * list of test data.\n */", "depth": 0, "reading_ease": 10.56, "reading_grade": 14.3, "line": 178}, "comment_text": "/*\n * srtp_auth_type_self_test(at) performs srtp_auth_type_test on at's internal\n * list of test data.\n */", "comment_tokens": ["srtp_auth_type_self_test", "(", "at", ")", "performs", "srtp_auth_type_test", "on", "at", "'s", "internal", "list", "of", "test", "data", "."], "ccode": ["\n", "/*\n", " * srtp_auth_type_self_test(at) performs srtp_auth_type_test on at's internal\n", " * list of test data.\n", " */\n", "\n", "srtp_err_status_t srtp_auth_type_self_test(const srtp_auth_type_t *at)\n", "{\n", "    return srtp_auth_type_test(at, at->test_data);\n", "}\n"], "project": "libsrtp2-1", "file": "auth.pkl", "function": "srtp_auth_type_self_test"}, {"comment_all": {"comment": "/*\ncif_value_type_t **datablock_types( DATABLOCK *datablock )\n{\n    return datablock->types;\n}\n*/", "depth": 0, "reading_ease": -27.68, "reading_grade": 18.6, "line": 235}, "comment_text": "/*\ncif_value_type_t **datablock_types( DATABLOCK *datablock )\n{\n    return datablock->types;\n}\n*/", "comment_tokens": ["cif_value_type_t", "datablock_types", "(", "DATABLOCK", "datablock", ")", "{", "return", "datablock-", ">", "types", ";", "}"], "ccode": ["\n", "/*\n", "cif_value_type_t **datablock_types( DATABLOCK *datablock )\n", "{\n", "    return datablock->types;\n", "}\n", "*/\n", "\n", "cif_value_type_t datablock_value_type( DATABLOCK *datablock, int tag_nr, int val_nr )\n", "{\n", "    CIFVALUE *v = datablock_cifvalue( datablock, tag_nr, val_nr );\n", "    if( v ) {\n", "        return value_type( v );\n", "    } else {\n", "        return CIF_NON_EXISTANT;\n", "    }\n", "}\n"], "project": "libcod-cif-parser-yapp-perl", "file": "datablock.pkl", "function": "datablock_value_type"}, {"comment_all": {"comment": "/*\n * This function zeros out the allocated block, and updates all of the\n * appropriate filesystem records.\n */", "depth": 0, "reading_ease": 47.79, "reading_grade": 10.3, "line": 220}, "comment_text": "/*\n * This function zeros out the allocated block, and updates all of the\n * appropriate filesystem records.\n */", "comment_tokens": ["This", "function", "zeros", "out", "the", "allocated", "block", ",", "and", "updates", "all", "of", "the", "appropriate", "filesystem", "records", "."], "ccode": ["\n", "/*\n", " * This function zeros out the allocated block, and updates all of the\n", " * appropriate filesystem records.\n", " */\n", "errcode_t ext2fs_alloc_block3(ext2_filsys fs, blk64_t goal, char *block_buf,\n", "\t\t\t      blk64_t *ret, struct blk_alloc_ctx *ctx)\n", "{\n", "\terrcode_t\tretval;\n", "\tblk64_t\t\tblock;\n", "\n", "\tif (fs->get_alloc_block2) {\n", "\t\tretval = (fs->get_alloc_block2)(fs, goal, &block, ctx);\n", "\t\tif (retval)\n", "\t\t\tgoto fail;\n", "\t} else if (fs->get_alloc_block) {\n", "\t\tretval = (fs->get_alloc_block)(fs, goal, &block);\n", "\t\tif (retval)\n", "\t\t\tgoto fail;\n", "\t} else {\n", "\t\tif (!fs->block_map) {\n", "\t\t\tretval = ext2fs_read_block_bitmap(fs);\n", "\t\t\tif (retval)\n", "\t\t\t\tgoto fail;\n", "\t\t}\n", "\n", "\t\tretval = ext2fs_new_block3(fs, goal, 0, &block, ctx);\n", "\t\tif (retval)\n", "\t\t\tgoto fail;\n", "\t}\n", "\n", "\tif (block_buf) {\n", "\t\tmemset(block_buf, 0, fs->blocksize);\n", "\t\tretval = io_channel_write_blk64(fs->io, block, 1, block_buf);\n", "\t} else\n", "\t\tretval = ext2fs_zero_blocks2(fs, block, 1, NULL, NULL);\n", "\tif (retval)\n", "\t\tgoto fail;\n", "\n", "\text2fs_block_alloc_stats2(fs, block, +1);\n", "\t*ret = block;\n", "\n", "fail:\n", "\treturn retval;\n", "}\n"], "project": "fuse2fs", "file": "alloc.pkl", "function": "ext2fs_alloc_block3"}, {"comment_all": {"comment": "/* maybe the header is already parsed! */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 51}, "comment_text": "/* maybe the header is already parsed! */", "comment_tokens": ["maybe", "the", "header", "is", "already", "parsed", "!"], "ccode": ["/*\n", " * Copyright (c) 2004 Juha Heinanen\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "/*! \\file\n", " * \\brief Parser :: Allow header\n", " *\n", " * \\ingroup parser\n", " */\n", "\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"../dprint.h\"\n", "#include \"../mem/mem.h\"\n", "#include \"parse_allow.h\"\n", "#include \"parse_methods.h\"\n", "#include \"msg_parser.h\"\n", "\n", "\n", "/*! \\brief\n", " * This method is used to parse Allow header.\n", " *\n", " * \\param _hf message header field\n", " * \\return 0 on success, -1 on failure.\n", " */\n", "int parse_allow_header(struct hdr_field* _hf)\n", "{\n", "\tstruct allow_body* ab = 0;\n", "\n", "\tif (!_hf) {\n", "\t\tLM_ERR(\"invalid parameter value\\n\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\t/* maybe the header is already parsed! */\n", "\tif (_hf->parsed) {\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tab = (struct allow_body*)pkg_malloc(sizeof(struct allow_body));\n", "\tif (ab == 0) {\n", "\t\tPKG_MEM_ERROR;\n", "\t\treturn -1;\n", "\t}\n", "\tmemset(ab,'\\0', sizeof(struct allow_body));\n", "\n", "\tif (parse_methods(&(_hf->body), &(ab->allow)) !=0 ) {\n", "\t\tLM_ERR(\"bad allow body header\\n\");\n", "\t\tgoto error;\n", "\t}\n", "\n", "\tab->allow_all = 0;\n", "\t_hf->parsed = (void*)ab;\n", "\treturn 0;\n", "\n", "error:\n", "\tif (ab) pkg_free(ab);\n", "\treturn -1;\n", "}\n"], "project": "kamailio", "file": "parse_allow.pkl", "function": "parse_allow_header"}, {"comment_all": {"comment": "//\tctrl->u.card_info = *info;\n", "depth": 1, "reading_ease": -6.7, "reading_grade": 14.7, "line": 143}, "comment_text": "//\tctrl->u.card_info = *info;\n", "comment_tokens": ["ctrl-", ">", "u.card_info", "=", "info", ";"], "ccode": ["\n", "static int snd_ctl_shm_card_info(snd_ctl_t *ctl, snd_ctl_card_info_t *info)\n", "{\n", "\tsnd_ctl_shm_t *shm = ctl->private_data;\n", "\tvolatile snd_ctl_shm_ctrl_t *ctrl = shm->ctrl;\n", "\tint err;\n", "//\tctrl->u.card_info = *info;\n", "\tctrl->cmd = SNDRV_CTL_IOCTL_CARD_INFO;\n", "\terr = snd_ctl_shm_action(ctl);\n", "\tif (err < 0)\n", "\t\treturn err;\n", "\t*info = ctrl->u.card_info;\n", "\treturn err;\n", "}\n"], "project": "libasound2", "file": "control_shm.pkl", "function": "snd_ctl_shm_card_info"}, {"comment_all": {"comment": "/* Copyright (c) 2004 - 2006 Derek Foreman, Ben Jansens\n   Provided under GPL version 2 or later.\n*/", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 2}, "comment_text": "/* Copyright (c) 2004 - 2006 Derek Foreman, Ben Jansens\n   Provided under GPL version 2 or later.\n*/", "comment_tokens": ["Copyright", "(", "c", ")", "2004", "-", "2006", "Derek", "Foreman", ",", "Ben", "Jansens", "Provided", "under", "GPL", "version", "2", "or", "later", "."], "ccode": ["/* -*- indent-tabs-mode: t; tab-width: 8; c-basic-offset: 8; -*- */\n", "\n", "/* Copyright (c) 2004 - 2006 Derek Foreman, Ben Jansens\n", "   Provided under GPL version 2 or later.\n", "*/\n", "\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include \"../config.h\"\n", "#endif\n", "\n", "#include \"null.h\"\n", "#include \"libburn.h\"\n", "#include <stdlib.h>\n", "\n", "#include <string.h>\n", "int null_read(struct burn_source *source, unsigned char *buffer, int size)\n", "{\n", "\tmemset(buffer, 0, size);\n", "\treturn size;\n", "}\n"], "project": "libburn-dev", "file": "null.pkl", "function": "null_read"}, {"comment_all": {"comment": "/*\n\t\t * Set stderr to /dev/null.  Necessary so that cron does not\n\t\t * wait for cpp to finish if it's running calendar -a.\n\t\t */", "depth": 2, "reading_ease": 78.25, "reading_grade": 4.8, "line": 351}, "comment_text": "/*\n\t\t * Set stderr to /dev/null.  Necessary so that cron does not\n\t\t * wait for cpp to finish if it's running calendar -a.\n\t\t */", "comment_tokens": ["Set", "stderr", "to", "devnull", ".", "Necessary", "so", "that", "cron", "does", "not", "wait", "for", "cpp", "to", "finish", "if", "it", "'s", "running", "calendar", "-a", "."], "ccode": ["\n", "\n", "FILE *\n", "opencal(void)\n", "{\n", "\tint pdes[2], fdin;\n", "\tstruct stat st;\n", "\n", "\t/* open up calendar file as stdin */\n", "\tif ((fdin = open(calendarFile, O_RDONLY)) == -1 ||\n", "\t    fstat(fdin, &st) == -1 || !S_ISREG(st.st_mode)) {\n", "\t\tif (!doall) {\n", "\t\t\tchar *home = getenv(\"HOME\");\n", "\t\t\tif (home == NULL || *home == '\\0')\n", "\t\t\t\terrx(1, \"cannot get home directory\");\n", "\t\t\tif (!(chdir(home) == 0 &&\n", "\t\t\t    chdir(calendarHome) == 0 &&\n", "\t\t\t    (fdin = open(calendarFile, O_RDONLY)) != -1))\n", "\t\t\t\terrx(1, \"no calendar file: ``%s'' or ``~/%s/%s''\",\n", "\t\t\t\t    calendarFile, calendarHome, calendarFile);\n", "\t\t}\n", "\t}\n", "\n", "\tif (pipe(pdes) < 0) {\n", "\t\tclose(fdin);\n", "\t\treturn (NULL);\n", "\t}\n", "\tswitch (vfork()) {\n", "\tcase -1:\t\t\t/* error */\n", "\t\t(void)close(pdes[0]);\n", "\t\t(void)close(pdes[1]);\n", "\t\tclose(fdin);\n", "\t\treturn (NULL);\n", "\tcase 0:\n", "\t\tdup2(fdin, STDIN_FILENO);\n", "\t\t/* child -- set stdout to pipe input */\n", "\t\tif (pdes[1] != STDOUT_FILENO) {\n", "\t\t\t(void)dup2(pdes[1], STDOUT_FILENO);\n", "\t\t\t(void)close(pdes[1]);\n", "\t\t}\n", "\t\t(void)close(pdes[0]);\n", "\t\t/*\n", "\t\t * Set stderr to /dev/null.  Necessary so that cron does not\n", "\t\t * wait for cpp to finish if it's running calendar -a.\n", "\t\t */\n", "\t\tif (doall) {\n", "\t\t\tint fderr;\n", "\t\t\tfderr = open(_PATH_DEVNULL, O_WRONLY, 0);\n", "\t\t\tif (fderr == -1)\n", "\t\t\t\t_exit(0);\n", "\t\t\t(void)dup2(fderr, STDERR_FILENO);\n", "\t\t\t(void)close(fderr);\n", "\t\t}\n", "\t\texecl(_PATH_CPP, \"cpp\", \"-traditional\", \"-undef\", \"-U__GNUC__\",\n", "\t\t    \"-P\", \"-I.\", _PATH_INCLUDE, (char *)NULL);\n", "\t\twarn(_PATH_CPP);\n", "\t\t_exit(1);\n", "\t}\n", "\t/* parent -- set stdin to pipe output */\n", "\t(void)dup2(pdes[0], STDIN_FILENO);\n", "\t(void)close(pdes[0]);\n", "\t(void)close(pdes[1]);\n", "\n", "\t/* not reading all calendar files, just set output to stdout */\n", "\tif (!doall)\n", "\t\treturn (stdout);\n", "\n", "\t/* set output to a temporary file, so if no output don't send mail */\n", "\treturn(tmpfile());\n", "}\n"], "project": "bsdmainutils", "file": "io.pkl", "function": "opencal"}, {"comment_all": {"comment": "/* Make sure data stored in inode->i_block is neither fast symlink nor\n\t * inline data.\n\t */", "depth": 1, "reading_ease": 66.74, "reading_grade": 7.2, "line": 355}, "comment_text": "/* Make sure data stored in inode->i_block is neither fast symlink nor\n\t * inline data.\n\t */", "comment_tokens": ["Make", "sure", "data", "stored", "in", "inode-", ">", "i_block", "is", "neither", "fast", "symlink", "nor", "inline", "data", "."], "ccode": ["\n", "blk64_t ext2fs_find_inode_goal(ext2_filsys fs, ext2_ino_t ino,\n", "\t\t\t       struct ext2_inode *inode, blk64_t lblk)\n", "{\n", "\tdgrp_t\t\t\tgroup;\n", "\t__u8\t\t\tlog_flex;\n", "\tstruct ext2fs_extent\textent;\n", "\text2_extent_handle_t\thandle = NULL;\n", "\terrcode_t\t\terr;\n", "\n", "\t/* Make sure data stored in inode->i_block is neither fast symlink nor\n", "\t * inline data.\n", "\t */\n", "\tif (inode == NULL || ext2fs_is_fast_symlink(inode) ||\n", "\t    inode->i_flags & EXT4_INLINE_DATA_FL)\n", "\t\tgoto no_blocks;\n", "\n", "\tif (inode->i_flags & EXT4_EXTENTS_FL) {\n", "\t\terr = ext2fs_extent_open2(fs, ino, inode, &handle);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\terr = ext2fs_extent_goto2(handle, 0, lblk);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\terr = ext2fs_extent_get(handle, EXT2_EXTENT_CURRENT, &extent);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\text2fs_extent_free(handle);\n", "\t\treturn extent.e_pblk + (lblk - extent.e_lblk);\n", "\t}\n", "\n", "\t/* block mapped file; see if block zero is mapped? */\n", "\tif (inode->i_block[0])\n", "\t\treturn inode->i_block[0];\n", "\n", "no_blocks:\n", "\text2fs_extent_free(handle);\n", "\tlog_flex = fs->super->s_log_groups_per_flex;\n", "\tgroup = ext2fs_group_of_ino(fs, ino);\n", "\tif (log_flex)\n", "\t\tgroup = group & ~((1 << (log_flex)) - 1);\n", "\treturn ext2fs_group_first_block2(fs, group);\n", "}\n"], "project": "libss2", "file": "alloc.pkl", "function": "ext2fs_find_inode_goal"}, {"comment_all": {"comment": "/* Returns the number of bytes really read.\n   If (returned value < size) and (errno == 0), means EOF was reached.\n*/", "depth": 0, "reading_ease": 79.26, "reading_grade": 4.4, "line": 32}, "comment_text": "/* Returns the number of bytes really read.\n   If (returned value < size) and (errno == 0), means EOF was reached.\n*/", "comment_tokens": ["Returns", "the", "number", "of", "bytes", "really", "read", ".", "If", "(", "returned", "value", "<", "size", ")", "and", "(", "errno", "==", "0", ")", ",", "means", "EOF", "was", "reached", "."], "ccode": ["/*  Xlunzip - Test tool for the lzip_decompress linux module\n", "    Copyright (C) 2016-2018 Antonio Diaz Diaz.\n", "\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation, either version 2 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "\n", "    You should have received a copy of the GNU General Public License\n", "    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", "*/\n", "\n", "#define _FILE_OFFSET_BITS 64\n", "\n", "#include <errno.h>\n", "#include <limits.h>\n", "#include <stdbool.h>\n", "#include <stdint.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <unistd.h>\n", "\n", "#include \"linux_lunzip.h\"\n", "#include \"lzip.h\"\n", "\n", "\n", "/* Returns the number of bytes really read.\n", "   If (returned value < size) and (errno == 0), means EOF was reached.\n", "*/\n", "long readblock( const int fd, uint8_t * const buf, const long size )\n", "  {\n", "  long sz = 0;\n", "  errno = 0;\n", "  while( sz < size )\n", "    {\n", "    const int n = read( fd, buf + sz, min( 1L << 20, size - sz ) );\n", "    if( n > 0 ) sz += n;\n", "    else if( n == 0 ) break;\t\t\t\t/* EOF */\n", "    else if( errno != EINTR ) break;\n", "    errno = 0;\n", "    }\n", "  return sz;\n", "  }\n"], "project": "xlunzip", "file": "in_place.pkl", "function": "readblock"}, {"comment_all": {"comment": "/*\n\t\t * on 60GHz band, there are no legacy rates, so\n\t\t * n_bitrates is 0\n\t\t */", "depth": 2, "reading_ease": 93.14, "reading_grade": 3.3, "line": 814}, "comment_text": "/*\n\t\t * on 60GHz band, there are no legacy rates, so\n\t\t * n_bitrates is 0\n\t\t */", "comment_tokens": ["on", "60GHz", "band", ",", "there", "are", "no", "legacy", "rates", ",", "so", "n_bitrates", "is", "0"], "ccode": ["\n", "int wiphy_register(struct wiphy *wiphy)\n", "{\n", "\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n", "\tint res;\n", "\tenum nl80211_band band;\n", "\tstruct ieee80211_supported_band *sband;\n", "\tbool have_band = false;\n", "\tint i;\n", "\tu16 ifmodes = wiphy->interface_modes;\n", "\n", "#ifdef CONFIG_PM\n", "\tif (WARN_ON(wiphy->wowlan &&\n", "\t\t    (wiphy->wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n", "\t\t    !(wiphy->wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))\n", "\t\treturn -EINVAL;\n", "\tif (WARN_ON(wiphy->wowlan &&\n", "\t\t    !wiphy->wowlan->flags && !wiphy->wowlan->n_patterns &&\n", "\t\t    !wiphy->wowlan->tcp))\n", "\t\treturn -EINVAL;\n", "#endif\n", "\tif (WARN_ON((wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH) &&\n", "\t\t    (!rdev->ops->tdls_channel_switch ||\n", "\t\t     !rdev->ops->tdls_cancel_channel_switch)))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON((wiphy->interface_modes & BIT(NL80211_IFTYPE_NAN)) &&\n", "\t\t    (!rdev->ops->start_nan || !rdev->ops->stop_nan ||\n", "\t\t     !rdev->ops->add_nan_func || !rdev->ops->del_nan_func ||\n", "\t\t     !(wiphy->nan_supported_bands & BIT(NL80211_BAND_2GHZ)))))\n", "\t\treturn -EINVAL;\n", "\n", "#ifndef CPTCFG_WIRELESS_WDS\n", "\tif (WARN_ON(wiphy->interface_modes & BIT(NL80211_IFTYPE_WDS)))\n", "\t\treturn -EINVAL;\n", "#endif\n", "\n", "\tif (WARN_ON(wiphy->pmsr_capa && !wiphy->pmsr_capa->ftm.supported))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (wiphy->pmsr_capa && wiphy->pmsr_capa->ftm.supported) {\n", "\t\tif (WARN_ON(!wiphy->pmsr_capa->ftm.asap &&\n", "\t\t\t    !wiphy->pmsr_capa->ftm.non_asap))\n", "\t\t\treturn -EINVAL;\n", "\t\tif (WARN_ON(!wiphy->pmsr_capa->ftm.preambles ||\n", "\t\t\t    !wiphy->pmsr_capa->ftm.bandwidths))\n", "\t\t\treturn -EINVAL;\n", "\t\tif (WARN_ON(wiphy->pmsr_capa->ftm.preambles &\n", "\t\t\t\t~(BIT(NL80211_PREAMBLE_LEGACY) |\n", "\t\t\t\t  BIT(NL80211_PREAMBLE_HT) |\n", "\t\t\t\t  BIT(NL80211_PREAMBLE_VHT) |\n", "\t\t\t\t  BIT(NL80211_PREAMBLE_HE) |\n", "\t\t\t\t  BIT(NL80211_PREAMBLE_DMG))))\n", "\t\t\treturn -EINVAL;\n", "\t\tif (WARN_ON((wiphy->pmsr_capa->ftm.trigger_based ||\n", "\t\t\t     wiphy->pmsr_capa->ftm.non_trigger_based) &&\n", "\t\t\t    !(wiphy->pmsr_capa->ftm.preambles &\n", "\t\t\t      BIT(NL80211_PREAMBLE_HE))))\n", "\t\t\treturn -EINVAL;\n", "\t\tif (WARN_ON(wiphy->pmsr_capa->ftm.bandwidths &\n", "\t\t\t\t~(BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_20) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_40) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_80) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_80P80) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_160) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_5) |\n", "\t\t\t\t  BIT(NL80211_CHAN_WIDTH_10))))\n", "\t\t\treturn -EINVAL;\n", "\t}\n", "\n", "\t/*\n", "\t * if a wiphy has unsupported modes for regulatory channel enforcement,\n", "\t * opt-out of enforcement checking\n", "\t */\n", "\tif (wiphy->interface_modes & ~(BIT(NL80211_IFTYPE_STATION) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_P2P_CLIENT) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_AP) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_P2P_GO) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_ADHOC) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_P2P_DEVICE) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_NAN) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_AP_VLAN) |\n", "\t\t\t\t       BIT(NL80211_IFTYPE_MONITOR)))\n", "\t\twiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;\n", "\n", "\tif (WARN_ON((wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) &&\n", "\t\t    (wiphy->regulatory_flags &\n", "\t\t\t\t\t(REGULATORY_CUSTOM_REG |\n", "\t\t\t\t\t REGULATORY_STRICT_REG |\n", "\t\t\t\t\t REGULATORY_COUNTRY_IE_FOLLOW_POWER |\n", "\t\t\t\t\t REGULATORY_COUNTRY_IE_IGNORE))))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy->coalesce &&\n", "\t\t    (!wiphy->coalesce->n_rules ||\n", "\t\t     !wiphy->coalesce->n_patterns) &&\n", "\t\t    (!wiphy->coalesce->pattern_min_len ||\n", "\t\t     wiphy->coalesce->pattern_min_len >\n", "\t\t\twiphy->coalesce->pattern_max_len)))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy->ap_sme_capa &&\n", "\t\t    !(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME)))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy->addresses && !wiphy->n_addresses))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy->addresses &&\n", "\t\t    !is_zero_ether_addr(wiphy->perm_addr) &&\n", "\t\t    memcmp(wiphy->perm_addr, wiphy->addresses[0].addr,\n", "\t\t\t   ETH_ALEN)))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy->max_acl_mac_addrs &&\n", "\t\t    (!(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME) ||\n", "\t\t     !rdev->ops->set_mac_acl)))\n", "\t\treturn -EINVAL;\n", "\n", "\t/* assure only valid behaviours are flagged by driver\n", "\t * hence subtract 2 as bit 0 is invalid.\n", "\t */\n", "\tif (WARN_ON(wiphy->bss_select_support &&\n", "\t\t    (wiphy->bss_select_support & ~(BIT(__NL80211_BSS_SELECT_ATTR_AFTER_LAST) - 2))))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(wiphy_ext_feature_isset(&rdev->wiphy,\n", "\t\t\t\t\t    NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X) &&\n", "\t\t    (!rdev->ops->set_pmk || !rdev->ops->del_pmk)))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (WARN_ON(!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n", "\t\t    rdev->ops->update_connect_params))\n", "\t\treturn -EINVAL;\n", "\n", "\tif (wiphy->addresses)\n", "\t\tmemcpy(wiphy->perm_addr, wiphy->addresses[0].addr, ETH_ALEN);\n", "\n", "\t/* sanity check ifmodes */\n", "\tWARN_ON(!ifmodes);\n", "\tifmodes &= ((1 << NUM_NL80211_IFTYPES) - 1) & ~1;\n", "\tif (WARN_ON(ifmodes != wiphy->interface_modes))\n", "\t\twiphy->interface_modes = ifmodes;\n", "\n", "\tres = wiphy_verify_combinations(wiphy);\n", "\tif (res)\n", "\t\treturn res;\n", "\n", "\t/* sanity check supported bands/channels */\n", "\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n", "\t\tu16 types = 0;\n", "\t\tbool have_he = false;\n", "\n", "\t\tsband = wiphy->bands[band];\n", "\t\tif (!sband)\n", "\t\t\tcontinue;\n", "\n", "\t\tsband->band = band;\n", "\t\tif (WARN_ON(!sband->n_channels))\n", "\t\t\treturn -EINVAL;\n", "\t\t/*\n", "\t\t * on 60GHz band, there are no legacy rates, so\n", "\t\t * n_bitrates is 0\n", "\t\t */\n", "\t\tif (WARN_ON(band != NL80211_BAND_60GHZ &&\n", "\t\t\t    !sband->n_bitrates))\n", "\t\t\treturn -EINVAL;\n", "\n", "\t\tif (WARN_ON(band == NL80211_BAND_6GHZ &&\n", "\t\t\t    (sband->ht_cap.ht_supported ||\n", "\t\t\t     sband->vht_cap.vht_supported)))\n", "\t\t\treturn -EINVAL;\n", "\n", "\t\t/*\n", "\t\t * Since cfg80211_disable_40mhz_24ghz is global, we can\n", "\t\t * modify the sband's ht data even if the driver uses a\n", "\t\t * global structure for that.\n", "\t\t */\n", "\t\tif (cfg80211_disable_40mhz_24ghz &&\n", "\t\t    band == NL80211_BAND_2GHZ &&\n", "\t\t    sband->ht_cap.ht_supported) {\n", "\t\t\tsband->ht_cap.cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n", "\t\t\tsband->ht_cap.cap &= ~IEEE80211_HT_CAP_SGI_40;\n", "\t\t}\n", "\n", "\t\t/*\n", "\t\t * Since we use a u32 for rate bitmaps in\n", "\t\t * ieee80211_get_response_rate, we cannot\n", "\t\t * have more than 32 legacy rates.\n", "\t\t */\n", "\t\tif (WARN_ON(sband->n_bitrates > 32))\n", "\t\t\treturn -EINVAL;\n", "\n", "\t\tfor (i = 0; i < sband->n_channels; i++) {\n", "\t\t\tsband->channels[i].orig_flags =\n", "\t\t\t\tsband->channels[i].flags;\n", "\t\t\tsband->channels[i].orig_mag = INT_MAX;\n", "\t\t\tsband->channels[i].orig_mpwr =\n", "\t\t\t\tsband->channels[i].max_power;\n", "\t\t\tsband->channels[i].band = band;\n", "\t\t}\n", "\n", "\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n", "\t\t\tconst struct ieee80211_sband_iftype_data *iftd;\n", "\n", "\t\t\tiftd = &sband->iftype_data[i];\n", "\n", "\t\t\tif (WARN_ON(!iftd->types_mask))\n", "\t\t\t\treturn -EINVAL;\n", "\t\t\tif (WARN_ON(types & iftd->types_mask))\n", "\t\t\t\treturn -EINVAL;\n", "\n", "\t\t\t/* at least one piece of information must be present */\n", "\t\t\tif (WARN_ON(!iftd->he_cap.has_he))\n", "\t\t\t\treturn -EINVAL;\n", "\n", "\t\t\ttypes |= iftd->types_mask;\n", "\n", "\t\t\tif (i == 0)\n", "\t\t\t\thave_he = iftd->he_cap.has_he;\n", "\t\t\telse\n", "\t\t\t\thave_he = have_he &&\n", "\t\t\t\t\t  iftd->he_cap.has_he;\n", "\t\t}\n", "\n", "\t\tif (WARN_ON(!have_he && band == NL80211_BAND_6GHZ))\n", "\t\t\treturn -EINVAL;\n", "\n", "\t\thave_band = true;\n", "\t}\n", "\n", "\tif (!have_band) {\n", "\t\tWARN_ON(1);\n", "\t\treturn -EINVAL;\n", "\t}\n", "\n", "\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n", "\t\t/*\n", "\t\t * Validate we have a policy (can be explicitly set to\n", "\t\t * VENDOR_CMD_RAW_DATA which is non-NULL) and also that\n", "\t\t * we have at least one of doit/dumpit.\n", "\t\t */\n", "\t\tif (WARN_ON(!rdev->wiphy.vendor_commands[i].policy))\n", "\t\t\treturn -EINVAL;\n", "\t\tif (WARN_ON(!rdev->wiphy.vendor_commands[i].doit &&\n", "\t\t\t    !rdev->wiphy.vendor_commands[i].dumpit))\n", "\t\t\treturn -EINVAL;\n", "\t}\n", "\n", "#ifdef CONFIG_PM\n", "\tif (WARN_ON(rdev->wiphy.wowlan && rdev->wiphy.wowlan->n_patterns &&\n", "\t\t    (!rdev->wiphy.wowlan->pattern_min_len ||\n", "\t\t     rdev->wiphy.wowlan->pattern_min_len >\n", "\t\t\t\trdev->wiphy.wowlan->pattern_max_len)))\n", "\t\treturn -EINVAL;\n", "#endif\n", "\n", "\t/* check and set up bitrates */\n", "\tieee80211_set_bitrate_flags(wiphy);\n", "\n", "\trdev->wiphy.features |= NL80211_FEATURE_SCAN_FLUSH;\n", "\n", "\trtnl_lock();\n", "\tres = device_add(&rdev->wiphy.dev);\n", "\tif (res) {\n", "\t\trtnl_unlock();\n", "\t\treturn res;\n", "\t}\n", "\n", "\t/* set up regulatory info */\n", "\twiphy_regulatory_register(wiphy);\n", "\n", "\tlist_add_rcu(&rdev->list, &cfg80211_rdev_list);\n", "\tcfg80211_rdev_list_generation++;\n", "\n", "\t/* add to debugfs */\n", "\trdev->wiphy.debugfsdir =\n", "\t\tdebugfs_create_dir(wiphy_name(&rdev->wiphy),\n", "\t\t\t\t   ieee80211_debugfs_dir);\n", "\tif (IS_ERR(rdev->wiphy.debugfsdir))\n", "\t\trdev->wiphy.debugfsdir = NULL;\n", "\n", "\tcfg80211_debugfs_rdev_add(rdev);\n", "\tnl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);\n", "\n", "\tif (wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {\n", "\t\tstruct regulatory_request request;\n", "\n", "\t\trequest.wiphy_idx = get_wiphy_idx(wiphy);\n", "\t\trequest.initiator = NL80211_REGDOM_SET_BY_DRIVER;\n", "\t\trequest.alpha2[0] = '9';\n", "\t\trequest.alpha2[1] = '9';\n", "\n", "\t\tnl80211_send_reg_change_event(&request);\n", "\t}\n", "\n", "\t/* Check that nobody globally advertises any capabilities they do not\n", "\t * advertise on all possible interface types.\n", "\t */\n", "\tif (wiphy->extended_capabilities_len &&\n", "\t    wiphy->num_iftype_ext_capab &&\n", "\t    wiphy->iftype_ext_capab) {\n", "\t\tu8 supported_on_all, j;\n", "\t\tconst struct wiphy_iftype_ext_capab *capab;\n", "\n", "\t\tcapab = wiphy->iftype_ext_capab;\n", "\t\tfor (j = 0; j < wiphy->extended_capabilities_len; j++) {\n", "\t\t\tif (capab[0].extended_capabilities_len > j)\n", "\t\t\t\tsupported_on_all =\n", "\t\t\t\t\tcapab[0].extended_capabilities[j];\n", "\t\t\telse\n", "\t\t\t\tsupported_on_all = 0x00;\n", "\t\t\tfor (i = 1; i < wiphy->num_iftype_ext_capab; i++) {\n", "\t\t\t\tif (j >= capab[i].extended_capabilities_len) {\n", "\t\t\t\t\tsupported_on_all = 0x00;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t\tsupported_on_all &=\n", "\t\t\t\t\tcapab[i].extended_capabilities[j];\n", "\t\t\t}\n", "\t\t\tif (WARN_ON(wiphy->extended_capabilities[j] &\n", "\t\t\t\t    ~supported_on_all))\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\trdev->wiphy.registered = true;\n", "\trtnl_unlock();\n", "\n", "\tres = rfkill_register(rdev->rfkill);\n", "\tif (res) {\n", "\t\trfkill_destroy(rdev->rfkill);\n", "\t\trdev->rfkill = NULL;\n", "\t\twiphy_unregister(&rdev->wiphy);\n", "\t\treturn res;\n", "\t}\n", "\n", "\treturn 0;\n", "}\n"], "project": "backport-iwlwifi-dkms", "file": "core.pkl", "function": "wiphy_register"}, {"comment_all": {"comment": "/* structure must be of Type structure: */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 124}, "comment_text": "/* structure must be of Type structure: */", "comment_tokens": ["structure", "must", "be", "of", "Type", "structure", ":"], "ccode": ["\n", "/* ===========================================================================\n", " * Structures:\n", "\n", " (SYS::%STRUCTURE-REF type structure index) returns for a structure of\n", "   given Type type (a Symbol) the entry at index>=1.\n", " (SYS::%STRUCTURE-STORE type structure index object) stores object as\n", "   Entry index in a structure of given Type type and returns object.\n", " (SYS::%MAKE-STRUCTURE type length) creates a structure with length>=1\n", "   elements of Type type.\n", " (COPY-STRUCTURE structure) returns a copy of the Structure structure,\n", "   of the same type.\n", " (SYS::%STRUCTURE-TYPE-P type object) checks if object is a\n", "   structure that has the Type type, which can be recognized in\n", "   component 0. There, an object (name_1 ... name_i-1 name_i) should\n", "   be located with one of the names EQ to type.\n", "*/\n", "/* subroutine for structure-access-functions:\n", " > STACK_2: type-argument\n", " > STACK_1: structure-argument\n", " > STACK_0: index-argument\n", " < result: Address of the structure-element */\n", "local gcv_object_t* structure_up (void) {\n", "  /* structure must be of Type structure: */\n", "  if (!structurep(STACK_1)) {\n", "   error_bad_structure: /* STACK_2 = type, STACK_1 = structure */\n", "    pushSTACK(STACK_1); /* TYPE-ERROR slot DATUM */\n", "    pushSTACK(STACK_(2+1)); /* TYPE-ERROR slot EXPECTED-TYPE */\n", "    pushSTACK(STACK_(2+2));\n", "    pushSTACK(STACK_(1+3));\n", "    pushSTACK(TheSubr(subr_self)->name); /* function name */\n", "    error(type_error,GETTEXT(\"~S: ~S is not a structure of type ~S\"));\n", "  }\n", "  {var object structure = STACK_1;\n", "  /* check if type occurs in namelist = (name_1 ... name_i-1 name_i) : */\n", "  if (!nullp(memq(STACK_2,TheStructure(structure)->structure_types)))\n", "    goto yes;\n", "  /* type did not occur -> Error: */\n", "  goto error_bad_structure;\n", " yes: { /* type did occur: */\n", "    {var uintL length = (uintL)Structure_length(structure);\n", "    {var uintV index;\n", "    /* fetch index and check */\n", "    if (!(posfixnump(STACK_0) && ((index = posfixnum_to_V(STACK_0)) < length)))\n", "      error_index(length);\n", "    /* address of the structure-component */\n", "    return &TheStructure(structure)->recdata[index];\n", "  }}}\n", "}}\n"], "project": "clisp", "file": "record.pkl", "function": "structure_up"}, {"comment_all": {"comment": "/* libunwind - a platform-independent unwind library\n   Copyright (C) 2001-2002, 2005 Hewlett-Packard Co\n        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>\n\nThis file is part of libunwind.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */", "depth": 0, "reading_ease": 25.66, "reading_grade": 18.8, "line": 0}, "comment_text": "/* libunwind - a platform-independent unwind library\n   Copyright (C) 2001-2002, 2005 Hewlett-Packard Co\n        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>\n\nThis file is part of libunwind.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */", "comment_tokens": ["libunwind", "-", "a", "platform-independent", "unwind", "library", "Copyright", "(", "C", ")", "2001-2002", ",", "2005", "Hewlett-Packard", "Co", "Contributed", "by", "David", "Mosberger-Tang", "<", "davidm", "@", "hpl.hp.com", ">", "This", "file", "is", "part", "of", "libunwind", ".", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "''", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/* libunwind - a platform-independent unwind library\n", "   Copyright (C) 2001-2002, 2005 Hewlett-Packard Co\n", "        Contributed by David Mosberger-Tang <davidm@hpl.hp.com>\n", "\n", "This file is part of libunwind.\n", "\n", "Permission is hereby granted, free of charge, to any person obtaining\n", "a copy of this software and associated documentation files (the\n", "\"Software\"), to deal in the Software without restriction, including\n", "without limitation the rights to use, copy, modify, merge, publish,\n", "distribute, sublicense, and/or sell copies of the Software, and to\n", "permit persons to whom the Software is furnished to do so, subject to\n", "the following conditions:\n", "\n", "The above copyright notice and this permission notice shall be\n", "included in all copies or substantial portions of the Software.\n", "\n", "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n", "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n", "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n", "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n", "LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n", "OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n", "WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n", "\n", "#include <stdlib.h>\n", "\n", "#include \"libunwind_i.h\"\n", "#include \"remote.h\"\n", "\n", "static void\n", "free_regions (unw_dyn_region_info_t *region)\n", "{\n", "  if (region->next)\n", "    free_regions (region->next);\n", "  free (region);\n", "}\n"], "project": "libunwind-setjmp0", "file": "Gdyn-remote.pkl", "function": "free_regions"}, {"comment_all": {"comment": "// Tell it to make a realpath\n", "depth": 3, "reading_ease": 90.77, "reading_grade": 2.1, "line": 2038}, "comment_text": "// Tell it to make a realpath\n", "comment_tokens": ["Tell", "it", "to", "make", "a", "realpath"], "ccode": ["\n", "\n", "const char *auparse_interpret_realpath(auparse_state_t *au)\n", "{\n", "\tif (au->le == NULL)\n", "\t\treturn NULL;\n", "\n", "        if (au->le->e.sec) {\n", "                rnode *r = aup_list_get_cur(au->le);\n", "                if (r) {\n", "\t\t\tif (nvlist_get_cur_type(r) != AUPARSE_TYPE_ESCAPED_FILE)\n", "\t\t\t\treturn NULL;\n", "\n", "\t\t\t// Tell it to make a realpath\n", "\t\t\tr->cwd = au->le->cwd;\n", "                        return nvlist_interp_cur_val(r, au->escape_mode);\n", "\t\t}\n", "        }\n", "\treturn NULL;\n", "}\n"], "project": "audispd-plugins", "file": "auparse.pkl", "function": "auparse_interpret_realpath"}, {"comment_all": {"comment": "/*\n * return a copy of the password, reading from stdin if arg is '-'\n * trashing he argument in the process.\n */", "depth": 0, "reading_ease": 78.59, "reading_grade": 6.8, "line": 31}, "comment_text": "/*\n * return a copy of the password, reading from stdin if arg is '-'\n * trashing he argument in the process.\n */", "comment_tokens": ["return", "a", "copy", "of", "the", "password", ",", "reading", "from", "stdin", "if", "arg", "is", "'-'", "trashing", "he", "argument", "in", "the", "process", "."], "ccode": ["/* FreeTDS - Library of routines accessing Sybase and Microsoft databases\n", " * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Brian Bruns\n", " * Copyright (C) 2006, 2007, 2008, 2009, 2010  Frediano Ziglio\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "\n", "#include <config.h>\n", "\n", "#include <stdio.h>\n", "\n", "#if HAVE_STRING_H\n", "#include <string.h>\n", "#endif /* HAVE_STRING_H */\n", "\n", "#include <freetds/sysdep_private.h>\n", "#include <freetds/utils.h>\n", "\n", "/*\n", " * return a copy of the password, reading from stdin if arg is '-'\n", " * trashing he argument in the process.\n", " */\n", "char *\n", "tds_getpassarg(char *arg)\n", "{\n", "\tchar pwd[256], *ptr, *q;\n", "\n", "\tif (strcmp(arg, \"-\") == 0) {\n", "\t\tif (fgets(pwd, sizeof(pwd), stdin) == NULL)\n", "\t\t\treturn NULL;\n", "\t\tptr = strchr(pwd, '\\n');\n", "\t\tif (ptr) *ptr = '\\0';\n", "\t\targ = pwd;\n", "\t}\n", "\n", "\tptr = strdup(arg);\n", "\tmemset(pwd, 0, sizeof(pwd));\n", "\n", "\tfor (q = arg; *q; *q++ = '*')\n", "\t\tcontinue;\n", "\n", "\treturn ptr;\n", "}\n"], "project": "libct4", "file": "getpassarg.pkl", "function": "tds_getpassarg"}, {"comment_all": {"comment": "/*\n  Date: Mon, 07 Jul 2003 21:27:17 GMT\n  Last-Modified: Mon, 07 Jul 2003 21:25:26 GMT\n  Accept-Ranges: bytes\n  Content-Length: 80\n*/", "depth": 1, "reading_ease": 78.59, "reading_grade": 6.8, "line": 305}, "comment_text": "/*\n  Date: Mon, 07 Jul 2003 21:27:17 GMT\n  Last-Modified: Mon, 07 Jul 2003 21:25:26 GMT\n  Accept-Ranges: bytes\n  Content-Length: 80\n*/", "comment_tokens": ["Date", ":", "Mon", ",", "07", "Jul", "2003", "21:27:17", "GMT", "Last-Modified", ":", "Mon", ",", "07", "Jul", "2003", "21:25:26", "GMT", "Accept-Ranges", ":", "bytes", "Content-Length", ":", "80"], "ccode": ["\n", "void http_header(int conn, char *code, unsigned char complete)\n", "{\n", "  fdprintf(conn, \"HTTP/1.1 %s\\r\\n\", code);\n", "  fdprintf(conn, \"Server: %s/%s (C) %s\\r\\n\", PACKAGE, VERSION, COPYRIGHT);\n", "  fdprintf(conn, \"Connection: close\\r\\n\");\n", "  fdprintf(conn, \"Content-Type: text/html; charset=utf-8\\r\\n\");\n", "  if (complete == HEADER_COMPLETE)\n", "    fdprintf(conn, \"\\r\\n\");\n", "\n", "/*\n", "  Date: Mon, 07 Jul 2003 21:27:17 GMT\n", "  Last-Modified: Mon, 07 Jul 2003 21:25:26 GMT\n", "  Accept-Ranges: bytes\n", "  Content-Length: 80\n", "*/\n", "}\n"], "project": "fwlogwatch", "file": "net.pkl", "function": "http_header"}, {"comment_all": {"comment": "/**\n * @brief Destroy an array of Network Manager attributes\n * @ingroup globus_net_manager_attr\n * @details\n * This function deletes an array of Network Manager attributes and\n * all values contained within them. The array must be terminated by\n * the value #GLOBUS_NET_MANAGER_NULL_ATTR.\n *\n * @param[in] attrs\n *     A pointer to an array of attributes to be freed.\n */", "depth": 0, "reading_ease": 38.62, "reading_grade": 11.8, "line": 36}, "comment_text": "/**\n * @brief Destroy an array of Network Manager attributes\n * @ingroup globus_net_manager_attr\n * @details\n * This function deletes an array of Network Manager attributes and\n * all values contained within them. The array must be terminated by\n * the value #GLOBUS_NET_MANAGER_NULL_ATTR.\n *\n * @param[in] attrs\n *     A pointer to an array of attributes to be freed.\n */", "comment_tokens": ["@", "brief", "Destroy", "an", "array", "of", "Network", "Manager", "attributes", "@", "ingroup", "globus_net_manager_attr", "@", "details", "This", "function", "deletes", "an", "array", "of", "Network", "Manager", "attributes", "and", "all", "values", "contained", "within", "them", ".", "The", "array", "must", "be", "terminated", "by", "the", "value", "#", "GLOBUS_NET_MANAGER_NULL_ATTR", ".", "@", "param", "[", "in", "]", "attrs", "A", "pointer", "to", "an", "array", "of", "attributes", "to", "be", "freed", "."], "ccode": ["/*\n", " * Copyright 1999-2014 University of Chicago\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "/**\n", " * @file array_delete.c\n", " * @brief globus_net_manager_attr_array_delete()\n", " */\n", "\n", "#include \"globus_net_manager_attr.h\"\n", "#include \"globus_net_manager.h\"\n", "\n", "\n", "/**\n", " * @brief End of array value\n", " * @ingroup globus_net_manager_attr\n", " * @details\n", " * This value may be assigned to an element in an array of\n", " * Network Manager attributes to terminate the array.\n", " */\n", "const\n", "globus_net_manager_attr_t\n", "globus_net_manager_null_attr = GLOBUS_NET_MANAGER_NULL_ATTR;\n", "\n", "/**\n", " * @brief Destroy an array of Network Manager attributes\n", " * @ingroup globus_net_manager_attr\n", " * @details\n", " * This function deletes an array of Network Manager attributes and\n", " * all values contained within them. The array must be terminated by\n", " * the value #GLOBUS_NET_MANAGER_NULL_ATTR.\n", " *\n", " * @param[in] attrs\n", " *     A pointer to an array of attributes to be freed.\n", " */\n", "void\n", "globus_net_manager_attr_array_delete(\n", "    globus_net_manager_attr_t          *attrs)\n", "{\n", "    if (attrs)\n", "    {\n", "        for (int i = 0; attrs[i].scope || attrs[i].name || attrs[i].value; i++)\n", "        {\n", "            globus_net_manager_attr_destroy(&attrs[i]);\n", "        }\n", "        free(attrs);\n", "    }\n", "    return;\n", "}\n"], "project": "libglobus-xio-net-manager-driver-dev", "file": "array_delete.pkl", "function": "globus_net_manager_attr_array_delete"}, {"comment_all": {"comment": "/*\n * MU-Conference - Multi-User Conference Service\n * Copyright (c) 2002-2005 David Sutton\n *\n *\n * This program is free software; you can redistribute it and/or drvify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n */", "depth": 0, "reading_ease": 47.32, "reading_grade": 12.6, "line": 0}, "comment_text": "/*\n * MU-Conference - Multi-User Conference Service\n * Copyright (c) 2002-2005 David Sutton\n *\n *\n * This program is free software; you can redistribute it and/or drvify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n */", "comment_tokens": ["MU-Conference", "-", "Multi-User", "Conference", "Service", "Copyright", "(", "c", ")", "2002-2005", "David", "Sutton", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "drvify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE.See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA02111-1307USA"], "ccode": ["/*\n", " * MU-Conference - Multi-User Conference Service\n", " * Copyright (c) 2002-2005 David Sutton\n", " *\n", " *\n", " * This program is free software; you can redistribute it and/or drvify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n", " */\n", "\n", "/* Functions used be both conference.c and conference_room.c to respond to IQ requests */\n", "#include \"conference.h\"\n", "#include <sys/utsname.h>\n", "\n", "/* Take an iq request for version and send the response directly */\n", "void iq_get_version(jpacket jp){\n", "  struct utsname un;\n", "  xmlnode x;\n", "  jutil_iqresult(jp->x);\n", "  xmlnode_put_attrib(xmlnode_insert_tag(jp->x, \"query\"), \"xmlns\", NS_VERSION);\n", "  jpacket_reset(jp);\n", "\n", "  xmlnode_insert_cdata(xmlnode_insert_tag(jp->iq, \"name\"), NAME, -1);\n", "  xmlnode_insert_cdata(xmlnode_insert_tag(jp->iq, \"version\"), VERSION, -1);\n", "\n", "  uname(&un);\n", "  x = xmlnode_insert_tag(jp->iq,\"os\");\n", "  xmlnode_insert_cdata(x, pstrdup(jp->p, un.sysname),-1);\n", "  xmlnode_insert_cdata(x,\" \",1);\n", "  xmlnode_insert_cdata(x,pstrdup(jp->p, un.release),-1);\n", "\n", "  deliver(dpacket_new(jp->x),NULL);\n", "  return;\n", "}\n"], "project": "jabber-muc", "file": "iq.pkl", "function": "iq_get_version"}, {"comment_all": {"comment": "/* Take an incoming packet, forward it if necessary, return 2 if it needs\n   to be handled by the local node. */", "depth": 0, "reading_ease": 59.64, "reading_grade": 9.9, "line": 163}, "comment_text": "/* Take an incoming packet, forward it if necessary, return 2 if it needs\n   to be handled by the local node. */", "comment_tokens": ["Take", "an", "incoming", "packet", ",", "forward", "it", "if", "necessary", ",", "return", "2", "if", "it", "needs", "to", "be", "handled", "by", "the", "local", "node", "."], "ccode": ["\n", "/* Take an incoming packet, forward it if necessary, return 2 if it needs\n", "   to be handled by the local node. */\n", "int\n", "handle_packet(int ll, const unsigned char *buf, size_t buflen)\n", "{\n", "    if(buflen < 2) {\n", "        debugf(1, \"Received truncated packet.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(buf[0] != 43) {\n", "        debugf(1, \"Received corrupted packet.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(buf[1] != 1) {\n", "        debugf(2, \"Received packet with version %d.\\n\", buf[1]);\n", "        return 0;\n", "    }\n", "\n", "    if(buflen < 24) {\n", "        debugf(1, \"Received truncated packet.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(buf[2] <= 0 || buf[3] <= 0 || buf[2] > buf[3]) {\n", "        debugf(1, \"Received packet with zero hop count.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(memcmp(buf + 8, zeroes, 8) == 0 || memcmp(buf + 8, ones, 8) == 0) {\n", "        debugf(1, \"Received packet with martian source.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(memcmp(buf + 16, zeroes, 8) == 0) {\n", "        debugf(1, \"Received packet with martian destination.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    /* The following tests do trigger in normal operation. */\n", "\n", "    if(memcmp(buf + 8, myid, 8) == 0) {\n", "        debugf(3, \"Suppressed packet from self.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    if(check_duplicate(buf)) {\n", "        debugf(3, \"Suppressed duplicate.\\n\");\n", "        return 0;\n", "    }\n", "\n", "    record_duplicate(buf);\n", "\n", "    if(memcmp(buf + 16, myid, 8) == 0)\n", "        return 2;\n", "\n", "    if(buf[2] >= 2) {\n", "        debugf(2, \"Forwarding packet, %d/%d hops left.\\n\",\n", "               buf[2] - 1, buf[3]);\n", "\n", "        usleep(random() % 50000);\n", "        really_send_packet(NULL, 0,\n", "                           buf[2] - 1, buf[3],\n", "                           buf + 4, buf + 8, buf + 16,\n", "                           buf + 24, buflen - 24);\n", "    }\n", "\n", "    if(memcmp(buf + 16, ones, 8) == 0)\n", "        return 2;\n", "    else\n", "        return 1;\n", "}\n"], "project": "ahcpd", "file": "transport.pkl", "function": "handle_packet"}, {"comment_all": {"comment": "/*\n * Does s1 contain an instance of s2 (ignoring blanks and case)?\n */", "depth": 0, "reading_ease": 77.23, "reading_grade": 5.2, "line": 281}, "comment_text": "/*\n * Does s1 contain an instance of s2 (ignoring blanks and case)?\n */", "comment_tokens": ["Does", "s1", "contain", "an", "instance", "of", "s2", "(", "ignoring", "blanks", "and", "case", ")", "?"], "ccode": ["\n", "/*\n", " * Does s1 contain an instance of s2 (ignoring blanks and case)?\n", " */\n", "\n", "const FcChar8 *\n", "FcStrContainsIgnoreBlanksAndCase (const FcChar8 *s1, const FcChar8 *s2)\n", "{\n", "    while (*s1)\n", "    {\n", "\tif (FcStrIsAtIgnoreBlanksAndCase (s1, s2))\n", "\t    return s1;\n", "\ts1++;\n", "    }\n", "    return 0;\n", "}\n"], "project": "libfontconfig1", "file": "fcstr.pkl", "function": "FcStrContainsIgnoreBlanksAndCase"}, {"comment_all": {"comment": "/* Generate two random numbers. */", "depth": 1, "reading_ease": 33.58, "reading_grade": 9.6, "line": 68}, "comment_text": "/* Generate two random numbers. */", "comment_tokens": ["Generate", "two", "random", "numbers", "."], "ccode": ["\n", "\n", "PaInt32 PaUtil_Generate16BitTriangularDither( PaUtilTriangularDitherGenerator *state )\n", "{\n", "    PaInt32 current, highPass;\n", "\n", "    /* Generate two random numbers. */\n", "    state->randSeed1 = (state->randSeed1 * 196314165) + 907633515;\n", "    state->randSeed2 = (state->randSeed2 * 196314165) + 907633515;\n", "\n", "    /* Generate triangular distribution about 0.\n", "     * Shift before adding to prevent overflow which would skew the distribution.\n", "     * Also shift an extra bit for the high pass filter. \n", "     */\n", "#define DITHER_SHIFT_  ((sizeof(PaInt32)*8 - PA_DITHER_BITS_) + 1)\n", "\t\n", "    current = (((PaInt32)state->randSeed1)>>DITHER_SHIFT_) +\n", "              (((PaInt32)state->randSeed2)>>DITHER_SHIFT_);\n", "\n", "    /* High pass filter to reduce audibility. */\n", "    highPass = current - state->previous;\n", "    state->previous = current;\n", "    return highPass;\n", "}\n"], "project": "libportaudiocpp0", "file": "pa_dither.pkl", "function": "PaUtil_Generate16BitTriangularDither"}, {"comment_all": {"comment": "/* Find number of classes in the input mapping */", "depth": 1, "reading_ease": 71.82, "reading_grade": 5.2, "line": 49}, "comment_text": "/* Find number of classes in the input mapping */", "comment_tokens": ["Find", "number", "of", "classes", "in", "the", "input", "mapping"], "ccode": ["\n", "static struct selinux_mapping *current_mapping = NULL;\n", "static security_class_t current_mapping_size = 0;\n", "\n", "/*\n", " * Mapping setting function\n", " */\n", "\n", "int\n", "selinux_set_mapping(struct security_class_mapping *map)\n", "{\n", "\tsize_t size = sizeof(struct selinux_mapping);\n", "\tsecurity_class_t i, j;\n", "\tunsigned k;\n", "\tbool print_unknown_handle = false;\n", "\tbool reject = (security_reject_unknown() == 1);\n", "\tbool deny = (security_deny_unknown() == 1);\n", "\n", "\tfree(current_mapping);\n", "\tcurrent_mapping = NULL;\n", "\tcurrent_mapping_size = 0;\n", "\n", "\tif (avc_reset() < 0)\n", "\t\tgoto err;\n", "\n", "\t/* Find number of classes in the input mapping */\n", "\tif (!map) {\n", "\t\terrno = EINVAL;\n", "\t\tgoto err;\n", "\t}\n", "\ti = 0;\n", "\twhile (map[i].name)\n", "\t\ti++;\n", "\n", "\t/* Allocate space for the class records, plus one for class zero */\n", "\tcurrent_mapping = (struct selinux_mapping *)calloc(++i, size);\n", "\tif (!current_mapping)\n", "\t\tgoto err;\n", "\n", "\t/* Store the raw class and permission values */\n", "\tj = 0;\n", "\twhile (map[j].name) {\n", "\t\tstruct security_class_mapping *p_in = map + (j++);\n", "\t\tstruct selinux_mapping *p_out = current_mapping + j;\n", "\n", "\t\tp_out->value = string_to_security_class(p_in->name);\n", "\t\tif (!p_out->value) {\n", "\t\t\tselinux_log(SELINUX_INFO,\n", "\t\t\t\t    \"SELinux: Class %s not defined in policy.\\n\",\n", "\t\t\t\t    p_in->name);\n", "\t\t\tif (reject)\n", "\t\t\t\tgoto err2;\n", "\t\t\tp_out->num_perms = 0;\n", "\t\t\tprint_unknown_handle = true;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tk = 0;\n", "\t\twhile (p_in->perms[k]) {\n", "\t\t\t/* An empty permission string skips ahead */\n", "\t\t\tif (!*p_in->perms[k]) {\n", "\t\t\t\tk++;\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\t\t\tp_out->perms[k] = string_to_av_perm(p_out->value,\n", "\t\t\t\t\t\t\t    p_in->perms[k]);\n", "\t\t\tif (!p_out->perms[k]) {\n", "\t\t\t\tselinux_log(SELINUX_INFO,\n", "\t\t\t\t\t    \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n", "\t\t\t\t\t    p_in->perms[k], p_in->name);\n", "\t\t\t\tif (reject)\n", "\t\t\t\t\tgoto err2;\n", "\t\t\t\tprint_unknown_handle = true;\n", "\t\t\t}\n", "\t\t\tk++;\n", "\t\t}\n", "\t\tp_out->num_perms = k;\n", "\t}\n", "\n", "\tif (print_unknown_handle)\n", "\t\tselinux_log(SELINUX_INFO,\n", "\t\t\t    \"SELinux: the above unknown classes and permissions will be %s\\n\",\n", "\t\t\t    deny ? \"denied\" : \"allowed\");\n", "\n", "\t/* Set the mapping size here so the above lookups are \"raw\" */\n", "\tcurrent_mapping_size = i;\n", "\treturn 0;\n", "err2:\n", "\tfree(current_mapping);\n", "\tcurrent_mapping = NULL;\n", "\tcurrent_mapping_size = 0;\n", "err:\n", "\treturn -1;\n", "}\n"], "project": "libselinux1-dev", "file": "mapping.pkl", "function": "selinux_set_mapping"}, {"comment_all": {"comment": "/*\n * Show all the routine names available for objects.\n */", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 175}, "comment_text": "/*\n * Show all the routine names available for objects.\n */", "comment_tokens": ["Show", "all", "the", "routine", "names", "available", "for", "objects", "."], "ccode": ["\n", "\n", "STATIC STRINGHEAD objectnames;\t/* names of objects */\n", "STATIC STRINGHEAD elements;\t/* element names for parts of objects */\n", "STATIC OBJECTACTIONS **objects; /* table of actions for objects */\n", "\n", "#define OBJALLOC 16\n", "STATIC long maxobjcount = 0;\n", "\n", "S_FUNC VALUE objpowi(VALUE *vp, NUMBER *q);\n", "S_FUNC BOOL objtest(OBJECT *op);\n", "S_FUNC BOOL objcmp(OBJECT *op1, OBJECT *op2);\n", "S_FUNC void objprint(OBJECT *op);\n", "\n", "\n", "/*\n", " * Show all the routine names available for objects.\n", " */\n", "void\n", "showobjfuncs(void)\n", "{\n", "\tregister struct objectinfo *oip;\n", "\n", "\tprintf(\"\\nThe following object routines are definable.\\n\");\n", "\tprintf(\"Note: xx represents the actual object type name.\\n\\n\");\n", "\tprintf(\"Name\tArgs\tComments\\n\");\n", "\tfor (oip = objectinfo; oip->name; oip++) {\n", "\t\tprintf(\"xx_%-8s %d\t%s\\n\", oip->name, oip->args,\n", "\t\t\toip->comment ? oip->comment : \"\");\n", "\t}\n", "\tprintf(\"\\n\");\n", "}\n"], "project": "apcalc-common", "file": "obj.pkl", "function": "showobjfuncs"}, {"comment_all": {"comment": "/*\n * Matrix operations library\n *\n * Copyright (C) 1999-2000\n *   Thomas Sailer, <sailer@ife.ee.ethz.ch>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "depth": 0, "reading_ease": 59.33, "reading_grade": 10.0, "line": 0}, "comment_text": "/*\n * Matrix operations library\n *\n * Copyright (C) 1999-2000\n *   Thomas Sailer, <sailer@ife.ee.ethz.ch>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "comment_tokens": ["Matrix", "operations", "library", "Copyright", "(", "C", ")", "1999-2000", "Thomas", "Sailer", ",", "<", "sailer", "@", "ife.ee.ethz.ch", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/*\n", " * Matrix operations library\n", " *\n", " * Copyright (C) 1999-2000\n", " *   Thomas Sailer, <sailer@ife.ee.ethz.ch>\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", " */\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "\n", "/* AIX requires this to be the first thing in the file.  */\n", "#ifndef __GNUC__\n", "# if HAVE_ALLOCA_H\n", "#  include <alloca.h>\n", "# else\n", "#  ifdef _AIX\n", "#pragma alloca\n", "#  else\n", "#   ifndef alloca /* predefined by HP cc +Olibcalls */\n", "char *alloca ();\n", "#   endif\n", "#  endif\n", "# endif\n", "#endif\n", "\n", "#include <string.h>\n", "#include \"mat.h\"\n", "\n", "/* c el R^{d1 x d3}, a el R^{d1 x d2}, b el R^{d2 x d3} */\n", "\n", "void frmul(float *c, const float *a, const float *b, unsigned int d1, unsigned int d2, unsigned int d3)\n", "{\n", "\tfloat *r = c, s;\n", "\tunsigned int i, j, k;\n", "\t\n", "\tif (c == a || c == b)\n", "\t\tr = alloca(d1 * d3 * sizeof(r[0]));\n", "\tfor (i = 0; i < d1; i++)\n", "\t\tfor (k = 0; k < d3; k++) {\n", "\t\t\tfor (s = 0, j = 0; j < d2; j++)\n", "\t\t\t\ts += a[i*d2+j] * b[j*d3+k];\n", "\t\t\tr[i*d3+k] = s;\n", "\t\t}\n", "\tif (r != c)\n", "\t\tmemcpy(c, r, d1 * d3 * sizeof(c[0]));\n", "}\n"], "project": "soundmodem", "file": "frmul.pkl", "function": "frmul"}, {"comment_all": {"comment": "/*register __avword\tiretreg\t __asm__(\"rax\");*/", "depth": 1, "reading_ease": 8.2, "reading_grade": 13.1, "line": 72}, "comment_text": "/* C names for registers */\n/*register __avword\tiretreg\t __asm__(\"rax\");*/\n", "comment_tokens": ["C", "names", "for", "registers", "register", "__avword", "iretreg", "__asm__", "(", "``", "rax", "''", ")", ";"], "ccode": ["/**\n", "  Copyright 1993 Bill Triggs <Bill.Triggs@inrialpes.fr>\n", "  Copyright 1995-2017 Bruno Haible <bruno@clisp.org>\n", "\n", "  This program is free software: you can redistribute it and/or modify\n", "  it under the terms of the GNU General Public License as published by\n", "  the Free Software Foundation; either version 2 of the License, or\n", "  (at your option) any later version.\n", "\n", "  This program is distributed in the hope that it will be useful,\n", "  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "  GNU General Public License for more details.\n", "\n", "  You should have received a copy of the GNU General Public License\n", "  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", "**/\n", "/*----------------------------------------------------------------------\n", "  Foreign function interface for an x86_64 (a.k.a. amd64) with gcc\n", "  using the Unix ABI ('gcc -mabi=sysv').\n", "\n", "  This calls a C function with an argument list built up using macros\n", "  defined in avcall.h.\n", "\n", "  x86_64 Argument Passing Conventions on Unix:\n", "\n", "  Documentation is at https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\n", "\n", "  * Arguments:\n", "    - Integer or pointer arguments:\n", "      The first 6 integer or pointer arguments get passed in integer\n", "      registers (%rdi, %rsi, %rdx, %rcx, %r8, %r9).\n", "      The remaining ones (as an entire word each) on the stack.\n", "    - Floating-point arguments:\n", "      Up to 8 float/double arguments are passed in SSE registers\n", "      (%xmm0..%xmm7).\n", "      The remaining ones (as an entire word each) on the stack.\n", "    - Structure arguments:\n", "      Structure args are passed as true structures embedded in the\n", "      argument stack.\n", "  * Return value:\n", "    Integers are returned in %rax, %rdx. Float/double values are returned\n", "    in %xmm0, %xmm1. To return a structure larger than 16 bytes, the called\n", "    function copies the value to space pointed to by its first argument,\n", "    and all other arguments are shifted down by one.\n", "  * Call-used registers: rax,rdx,rcx,rsi,rdi,r8-r11\n", "\n", "  ----------------------------------------------------------------------*/\n", "#include \"avcall-internal.h\"\n", "\n", "#define RETURN(TYPE,VAL)\t(*(TYPE*)l->raddr = (TYPE)(VAL))\n", "\n", "/*register __avword iarg1 __asm__(\"rdi\");*/\n", "/*register __avword iarg2 __asm__(\"rsi\");*/\n", "/*register __avword iarg3 __asm__(\"rdx\");*/\n", "/*register __avword iarg4 __asm__(\"rcx\");*/\n", "/*register __avword iarg5 __asm__(\"r8\");*/\n", "/*register __avword iarg6 __asm__(\"r9\");*/\n", "\n", "register double farg1 __asm__(\"xmm0\");\n", "register double farg2 __asm__(\"xmm1\");\n", "register double farg3 __asm__(\"xmm2\");\n", "register double farg4 __asm__(\"xmm3\");\n", "register double farg5 __asm__(\"xmm4\");\n", "register double farg6 __asm__(\"xmm5\");\n", "register double farg7 __asm__(\"xmm6\");\n", "register double farg8 __asm__(\"xmm7\");\n", "\n", "int\n", "avcall_call(av_alist* list)\n", "{\n", "  register __avword*\tsp\t__asm__(\"rsp\");\t/* C names for registers */\n", "/*register __avword\tiretreg\t __asm__(\"rax\");*/\n", "  register __avword\tiret2reg __asm__(\"rdx\");\n", "  register double\tdret\t__asm__(\"xmm0\");\n", "\n", "  __av_alist* l = &AV_LIST_INNER(list);\n", "\n", "  __avword* argframe = __builtin_alloca(__AV_ALIST_WORDS * sizeof(__avword)); /* make room for argument list */\n", "  int arglen = l->aptr - l->args;\n", "  int farglen = l->faptr - l->fargs;\n", "  __avword iret, iret2;\n", "\n", "  {\n", "    int i;\n", "    for (i = 0; i < arglen; i++)\t/* push function args onto stack */\n", "      argframe[i] = l->args[i];\n", "  }\n", "\n", "  /* Call function.\n", "     It's OK to pass 8 values in SSE registers even if the called function takes\n", "     less than 8 float/double arguments. Similarly for the integer arguments. */\n", "  if (l->rtype == __AVfloat) {\n", "    *(float*)l->raddr =\n", "      (*(float(*)())l->func)(l->iargs[0],\n", "                             l->iargs[1],\n", "                             l->iargs[2],\n", "                             l->iargs[3],\n", "                             l->iargs[4],\n", "                             l->iargs[5],\n", "                             farglen > 0 ? l->fargs[0] : 0.0,\n", "                             farglen > 1 ? l->fargs[1] : 0.0,\n", "                             farglen > 2 ? l->fargs[2] : 0.0,\n", "                             farglen > 3 ? l->fargs[3] : 0.0,\n", "                             farglen > 4 ? l->fargs[4] : 0.0,\n", "                             farglen > 5 ? l->fargs[5] : 0.0,\n", "                             farglen > 6 ? l->fargs[6] : 0.0,\n", "                             farglen > 7 ? l->fargs[7] : 0.0);\n", "  } else\n", "  if (l->rtype == __AVdouble) {\n", "    *(double*)l->raddr =\n", "      (*(double(*)())l->func)(l->iargs[0],\n", "                              l->iargs[1],\n", "                              l->iargs[2],\n", "                              l->iargs[3],\n", "                              l->iargs[4],\n", "                              l->iargs[5],\n", "                              farglen > 0 ? l->fargs[0] : 0.0,\n", "                              farglen > 1 ? l->fargs[1] : 0.0,\n", "                              farglen > 2 ? l->fargs[2] : 0.0,\n", "                              farglen > 3 ? l->fargs[3] : 0.0,\n", "                              farglen > 4 ? l->fargs[4] : 0.0,\n", "                              farglen > 5 ? l->fargs[5] : 0.0,\n", "                              farglen > 6 ? l->fargs[6] : 0.0,\n", "                              farglen > 7 ? l->fargs[7] : 0.0);\n", "  } else {\n", "    iret = (*l->func)(l->iargs[0],\n", "                      l->iargs[1],\n", "                      l->iargs[2],\n", "                      l->iargs[3],\n", "                      l->iargs[4],\n", "                      l->iargs[5],\n", "                      farglen > 0 ? l->fargs[0] : 0.0,\n", "                      farglen > 1 ? l->fargs[1] : 0.0,\n", "                      farglen > 2 ? l->fargs[2] : 0.0,\n", "                      farglen > 3 ? l->fargs[3] : 0.0,\n", "                      farglen > 4 ? l->fargs[4] : 0.0,\n", "                      farglen > 5 ? l->fargs[5] : 0.0,\n", "                      farglen > 6 ? l->fargs[6] : 0.0,\n", "                      farglen > 7 ? l->fargs[7] : 0.0);\n", "    iret2 = iret2reg;\n", "\n", "    /* save return value */\n", "    if (l->rtype == __AVvoid) {\n", "    } else\n", "    if (l->rtype == __AVword) {\n", "      RETURN(__avword, iret);\n", "    } else\n", "    if (l->rtype == __AVchar) {\n", "      RETURN(char, iret);\n", "    } else\n", "    if (l->rtype == __AVschar) {\n", "      RETURN(signed char, iret);\n", "    } else\n", "    if (l->rtype == __AVuchar) {\n", "      RETURN(unsigned char, iret);\n", "    } else\n", "    if (l->rtype == __AVshort) {\n", "      RETURN(short, iret);\n", "    } else\n", "    if (l->rtype == __AVushort) {\n", "      RETURN(unsigned short, iret);\n", "    } else\n", "    if (l->rtype == __AVint) {\n", "      RETURN(int, iret);\n", "    } else\n", "    if (l->rtype == __AVuint) {\n", "      RETURN(unsigned int, iret);\n", "    } else\n", "    if (l->rtype == __AVlong) {\n", "      RETURN(long, iret);\n", "    } else\n", "    if (l->rtype == __AVulong) {\n", "      RETURN(unsigned long, iret);\n", "    } else\n", "    if (l->rtype == __AVlonglong) {\n", "      RETURN(long long, iret);\n", "    } else\n", "    if (l->rtype == __AVulonglong) {\n", "      RETURN(unsigned long long, iret);\n", "    } else\n", "  /* see above\n", "    if (l->rtype == __AVfloat) {\n", "    } else\n", "    if (l->rtype == __AVdouble) {\n", "    } else\n", "  */\n", "    if (l->rtype == __AVvoidp) {\n", "      RETURN(void*, iret);\n", "    } else\n", "    if (l->rtype == __AVstruct) {\n", "      if (l->flags & __AV_REGISTER_STRUCT_RETURN) {\n", "        /* Return structs of size <= 16 in registers. */\n", "        if (l->rsize > 0 && l->rsize <= 16) {\n", "          void* raddr = l->raddr;\n", "          #if 0 /* Unoptimized */\n", "          if (l->rsize == 1) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "          } else\n", "          if (l->rsize == 2) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "          } else\n", "          if (l->rsize == 3) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "          } else\n", "          if (l->rsize == 4) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "            ((unsigned char *)raddr)[3] = (unsigned char)(iret>>24);\n", "          } else\n", "          if (l->rsize == 5) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "            ((unsigned char *)raddr)[3] = (unsigned char)(iret>>24);\n", "            ((unsigned char *)raddr)[4] = (unsigned char)(iret>>32);\n", "          } else\n", "          if (l->rsize == 6) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "            ((unsigned char *)raddr)[3] = (unsigned char)(iret>>24);\n", "            ((unsigned char *)raddr)[4] = (unsigned char)(iret>>32);\n", "            ((unsigned char *)raddr)[5] = (unsigned char)(iret>>40);\n", "          } else\n", "          if (l->rsize == 7) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "            ((unsigned char *)raddr)[3] = (unsigned char)(iret>>24);\n", "            ((unsigned char *)raddr)[4] = (unsigned char)(iret>>32);\n", "            ((unsigned char *)raddr)[5] = (unsigned char)(iret>>40);\n", "            ((unsigned char *)raddr)[6] = (unsigned char)(iret>>48);\n", "          } else\n", "          if (l->rsize >= 8 && l->rsize <= 16) {\n", "            ((unsigned char *)raddr)[0] = (unsigned char)(iret);\n", "            ((unsigned char *)raddr)[1] = (unsigned char)(iret>>8);\n", "            ((unsigned char *)raddr)[2] = (unsigned char)(iret>>16);\n", "            ((unsigned char *)raddr)[3] = (unsigned char)(iret>>24);\n", "            ((unsigned char *)raddr)[4] = (unsigned char)(iret>>32);\n", "            ((unsigned char *)raddr)[5] = (unsigned char)(iret>>40);\n", "            ((unsigned char *)raddr)[6] = (unsigned char)(iret>>48);\n", "            ((unsigned char *)raddr)[7] = (unsigned char)(iret>>56);\n", "            if (l->rsize == 8) {\n", "            } else\n", "            if (l->rsize == 9) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "            } else\n", "            if (l->rsize == 10) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "            } else\n", "            if (l->rsize == 11) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "            } else\n", "            if (l->rsize == 12) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "              ((unsigned char *)raddr)[8+3] = (unsigned char)(iret2>>24);\n", "            } else\n", "            if (l->rsize == 13) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "              ((unsigned char *)raddr)[8+3] = (unsigned char)(iret2>>24);\n", "              ((unsigned char *)raddr)[8+4] = (unsigned char)(iret2>>32);\n", "            } else\n", "            if (l->rsize == 14) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "              ((unsigned char *)raddr)[8+3] = (unsigned char)(iret2>>24);\n", "              ((unsigned char *)raddr)[8+4] = (unsigned char)(iret2>>32);\n", "              ((unsigned char *)raddr)[8+5] = (unsigned char)(iret2>>40);\n", "            } else\n", "            if (l->rsize == 15) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "              ((unsigned char *)raddr)[8+3] = (unsigned char)(iret2>>24);\n", "              ((unsigned char *)raddr)[8+4] = (unsigned char)(iret2>>32);\n", "              ((unsigned char *)raddr)[8+5] = (unsigned char)(iret2>>40);\n", "              ((unsigned char *)raddr)[8+6] = (unsigned char)(iret2>>48);\n", "            } else\n", "            if (l->rsize == 16) {\n", "              ((unsigned char *)raddr)[8+0] = (unsigned char)(iret2);\n", "              ((unsigned char *)raddr)[8+1] = (unsigned char)(iret2>>8);\n", "              ((unsigned char *)raddr)[8+2] = (unsigned char)(iret2>>16);\n", "              ((unsigned char *)raddr)[8+3] = (unsigned char)(iret2>>24);\n", "              ((unsigned char *)raddr)[8+4] = (unsigned char)(iret2>>32);\n", "              ((unsigned char *)raddr)[8+5] = (unsigned char)(iret2>>40);\n", "              ((unsigned char *)raddr)[8+6] = (unsigned char)(iret2>>48);\n", "              ((unsigned char *)raddr)[8+7] = (unsigned char)(iret2>>56);\n", "            }\n", "          }\n", "          #else /* Optimized: fewer conditional jumps, fewer memory accesses */\n", "          uintptr_t count = l->rsize; /* > 0, \u2264 2*sizeof(__avword) */\n", "          __avword* wordaddr = (__avword*)((uintptr_t)raddr & ~(uintptr_t)(sizeof(__avword)-1));\n", "          uintptr_t start_offset = (uintptr_t)raddr & (uintptr_t)(sizeof(__avword)-1); /* \u2265 0, < sizeof(__avword) */\n", "          uintptr_t end_offset = start_offset + count; /* > 0, < 3*sizeof(__avword) */\n", "          if (count <= sizeof(__avword)) {\n", "            /* Use iret. */\n", "            if (end_offset <= sizeof(__avword)) {\n", "              /* 0 < end_offset \u2264 sizeof(__avword) */\n", "              __avword mask0 = ((__avword)2 << (end_offset*8-1)) - ((__avword)1 << (start_offset*8));\n", "              wordaddr[0] ^= (wordaddr[0] ^ (iret << (start_offset*8))) & mask0;\n", "            } else {\n", "              /* sizeof(__avword) < end_offset < 2*sizeof(__avword), start_offset > 0 */\n", "              __avword mask0 = - ((__avword)1 << (start_offset*8));\n", "              __avword mask1 = ((__avword)2 << (end_offset*8-sizeof(__avword)*8-1)) - 1;\n", "              wordaddr[0] ^= (wordaddr[0] ^ (iret << (start_offset*8))) & mask0;\n", "              wordaddr[1] ^= (wordaddr[1] ^ (iret >> (sizeof(__avword)*8-start_offset*8))) & mask1;\n", "            }\n", "          } else {\n", "            /* Use iret, iret2. */\n", "            __avword mask0 = - ((__avword)1 << (start_offset*8));\n", "            wordaddr[0] ^= (wordaddr[0] ^ (iret << (start_offset*8))) & mask0;\n", "            if (end_offset <= 2*sizeof(__avword)) {\n", "              /* sizeof(__avword) < end_offset \u2264 2*sizeof(__avword) */\n", "              __avword mask1 = ((__avword)2 << (end_offset*8-sizeof(__avword)*8-1)) - 1;\n", "              wordaddr[1] ^= (wordaddr[1] ^ ((iret >> (sizeof(__avword)*4-start_offset*4) >> (sizeof(__avword)*4-start_offset*4)) | (iret2 << (start_offset*8)))) & mask1;\n", "            } else {\n", "              /* 2*sizeof(__avword) < end_offset < 3*sizeof(__avword), start_offset > 0 */\n", "              __avword mask2 = ((__avword)2 << (end_offset*8-2*sizeof(__avword)*8-1)) - 1;\n", "              wordaddr[1] = (iret >> (sizeof(__avword)*8-start_offset*8)) | (iret2 << (start_offset*8));\n", "              wordaddr[2] ^= (wordaddr[2] ^ (iret2 >> (sizeof(__avword)*8-start_offset*8))) & mask2;\n", "            }\n", "          }\n", "          #endif\n", "        }\n", "      }\n", "    }\n", "  }\n", "  return 0;\n", "}\n"], "project": "libffcall1-dev", "file": "avcall-x86_64.pkl", "function": "avcall_call"}, {"comment_all": {"comment": "// compatible with old format.\n", "depth": 5, "reading_ease": 33.58, "reading_grade": 9.6, "line": 91}, "comment_text": "// new format start with '=' for object name.\n// but we continue if we don't find this to be\n// compatible with old format.\n", "comment_tokens": ["new", "format", "start", "with", "'=", "'", "for", "object", "name", ".", "but", "we", "continue", "if", "we", "do", "n't", "find", "this", "to", "be", "compatible", "with", "old", "format", "."], "ccode": ["/******************************************************************************\n", "    dnet_priv_check.c from libdnet_daemon\n", "\n", "    Copyright (C) 2008-2010 Philipp 'ph3-der-loewe' Schafft <lion@lion.leolix.org>\n", "\n", "    This library is free software; you can redistribute it and/or\n", "    modify it under the terms of the GNU Lesser General Public\n", "    License as published by the Free Software Foundation; either\n", "    version 2 of the License, or (at your option) any later version.\n", "\n", "    This library is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "    Lesser General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Lesser General Public\n", "    License along with this library; if not, write to the Free Software\n", "    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", "*/\n", "\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <ctype.h>\n", "\n", "#include <netdnet/dn.h>\n", "#include <netdnet/dnetdb.h>\n", "\n", "#define LINELEN       1024\n", "#define LISTDELM      \" \\t,\"\n", "\n", "int dnet_priv_check(const char * file, const char * proc,\n", "                    const struct sockaddr_dn * local, const struct sockaddr_dn * remote) {\n", "    FILE           * fh;\n", "    char             line[LINELEN];\n", "    char           * clients;\n", "    int              match;\n", "    char           * c;\n", "    char             nodeaddr[12];\n", "    struct nodeent * ne;\n", "    char           * tokptr = NULL;\n", "\n", "    snprintf(nodeaddr, sizeof(nodeaddr), \"%i.%i\", remote->sdn_add.a_addr[1] >> 2,\n", "                               remote->sdn_add.a_addr[0] +\n", "                               ((remote->sdn_add.a_addr[1] & 0x3) << 8));\n", "    nodeaddr[sizeof(nodeaddr)-1] = 0;\n", "\n", "    if ( (fh = fopen(file, \"r\")) == NULL )\n", "\treturn -1;\n", "\n", "    // walk thru the file and search for matches\n", "    // if a match is found we return directly from within this loop.\n", "    while (fgets(line, LINELEN, fh) != NULL) {\n", "\t// skip comments.\n", "\tif ( line[0] == '#' )\n", "\t    continue;\n", "\n", "\t// split into service/daemon and clients part\n", "\tif ( (clients = strchr(line, ':')) == NULL )\n", "\t    continue;\n", "\n", "\t*clients = 0;\n", "\tclients++;\n", "\n", "\t// clean up lion endings\n", "\tc = &clients[strlen(clients) - 1];\n", "\tif ( *c == '\\n' )\n", "\t    *c = 0;\n", "\n", "\tmatch = 0; // reset match to 'no match found'\n", "\n", "\t// now walk thru the list of services/daemons/objects and\n", "\t// see if we have a match here.\n", "\tc = strtok_r(line, LISTDELM, &tokptr);\n", "\twhile (c != NULL) {\n", "\t    if ( !strcmp(c, \"ALL\") ) {      // ALL matches all services\n", "\t\tmatch = 1;\n", "\t    } else if ( *c == '$' ) {       // match local object\n", "\t\tc++;\n", "\t\tif ( *c == '#' ) {          // if this starts with '#' we mach object number\n", "\t\t   c++;\n", "\t\t   if ( isalpha(*c) ) {\n", "\t\t\tif ( getobjectbyname(c) == local->sdn_objnum )\n", "\t\t\t    match = 1; \n", "\t\t   } else {\n", "\t\t\tif ( atoi(c) == local->sdn_objnum )\n", "\t\t\t    match = 1; \n", "\t\t   }\n", "\t\t} else {\n", "\t\t    if ( *c == '=' )        // new format start with '=' for object name.\n", "\t\t\tc++;                // but we continue if we don't find this to be\n", "                                            // compatible with old format.\n", "\t\t    if ( local->sdn_objnamel &&\n", "\t\t         !strncmp(c, (char *)local->sdn_objname, local->sdn_objnamel) )\n", "\t\t\tmatch = 1;\n", "\t\t}\n", "\t    } else if (proc != NULL && !strcmp(c, proc)) {  // match process/service/... name\n", "\t\tmatch = 1;\n", "\t    }\n", "\n", "\t    if ( match ) break; // end this loop if we have a match\n", "\n", "\t    c = strtok_r(NULL, LISTDELM, &tokptr); // get next element\n", "\t}\n", "\n", "\tif ( !match ) // continue with outer loop if we have no match\n", "\t    continue;\n", "\n", "\t// we now have a object match, search for a remode node match\n", "\n", "\tmatch = 0; // reset match so we can use it for remote node matching\n", "\n", "\t// now walk thru the list of clients:\n", "\tc = strtok_r(clients, LISTDELM, &tokptr);\n", "\twhile (c != NULL) {\n", "\t    if ( !strcmp(c, \"ALL\") ) {            // test for wildcard\n", "\t\tmatch = 1;\n", "\t    } else if ( !strcmp(c, nodeaddr) ) {  // test for numerical node address\n", "\t\tmatch = 1;\n", "\t    } else if ( isalpha(*c) ) {           // test for node name\n", "\t\tif ( (ne = getnodebyname(c)) != NULL )\n", "\t\t    if ( *(int16_t*)ne->n_addr == *(int16_t*)remote->sdn_add.a_addr )\n", "\t\t\tmatch = 1;\n", "\t    }\n", "\n", "\t    // do we have a match?\n", "\t    if (match) {\n", "\t\t// do cleanup and return.\n", "\t\tfclose(fh);\n", "\t\treturn 1;\n", "\t    }\n", "\n", "\t    // get next client\n", "\t    c = strtok_r(NULL, LISTDELM, &tokptr);\n", "\t}\n", "    }\n", "    // no match was found.\n", "\n", "    // cleanup\n", "    fclose(fh);\n", "    return 0;\n", "}\n"], "project": "libdnet", "file": "dnet_priv_check.pkl", "function": "dnet_priv_check"}, {"comment_all": {"comment": "/* 0 or 1 node case */", "depth": 1, "reading_ease": 117.16, "reading_grade": -1.9, "line": 476}, "comment_text": "/* 0 or 1 node case */", "comment_tokens": ["0", "or", "1", "node", "case"], "ccode": ["\n", "static void sort_pairing_nodes(FriBidiPairingNode **nodes)\n", "{\n", "  FriBidiPairingNode *front, *back;\n", "\n", "  /* 0 or 1 node case */\n", "  if (!*nodes || !(*nodes)->next)\n", "    return;\n", "\n", "  pairing_nodes_front_back_split(*nodes, &front, &back);\n", "  sort_pairing_nodes(&front);\n", "  sort_pairing_nodes(&back);\n", "  *nodes = pairing_nodes_sorted_merge(front, back);\n", "}\n"], "project": "libfribidi-bin", "file": "fribidi-bidi.pkl", "function": "sort_pairing_nodes"}, {"comment_all": {"comment": "/* remember result of local condition for a partial reset */", "depth": 3, "reading_ease": 36.96, "reading_grade": 10.3, "line": 484}, "comment_text": "/* remember result of local condition for a partial reset */", "comment_tokens": ["remember", "result", "of", "local", "condition", "for", "a", "partial", "reset"], "ccode": ["\n", "static cond_result_t config_check_cond_cached(server *srv, connection *con, data_config *dc) {\n", "\tcond_cache_t *caches = con->cond_cache;\n", "\n", "\tif (COND_RESULT_UNSET == caches[dc->context_ndx].result) {\n", "\t\tcaches[dc->context_ndx].result = config_check_cond_nocache(srv, con, dc);\n", "\t\tswitch (caches[dc->context_ndx].result) {\n", "\t\tcase COND_RESULT_FALSE:\n", "\t\tcase COND_RESULT_TRUE:\n", "\t\t\t/* remember result of local condition for a partial reset */\n", "\t\t\tcaches[dc->context_ndx].local_result = caches[dc->context_ndx].result;\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tbreak;\n", "\t\t}\n", "\n", "\t\tif (con->conf.log_condition_handling) {\n", "\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"dss\",\n", "\t\t\t\tdc->context_ndx,\n", "\t\t\t\t\"(uncached) result:\",\n", "\t\t\t\tcond_result_to_string(caches[dc->context_ndx].result));\n", "\t\t}\n", "\t} else {\n", "\t\tif (con->conf.log_condition_handling) {\n", "\t\t\tlog_error_write(srv, __FILE__, __LINE__, \"dss\",\n", "\t\t\t\tdc->context_ndx,\n", "\t\t\t\t\"(cached) result:\",\n", "\t\t\t\tcond_result_to_string(caches[dc->context_ndx].result));\n", "\t\t}\n", "\t}\n", "\treturn caches[dc->context_ndx].result;\n", "}\n"], "project": "lighttpd-mod-authn-pam", "file": "configfile-glue.pkl", "function": "config_check_cond_cached"}, {"comment_all": {"comment": "/* Ownership of uri is transferred. */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 433}, "comment_text": "/* Ownership of uri is transferred. */", "comment_tokens": ["Ownership", "of", "uri", "is", "transferred", "."], "ccode": ["\n", "/* Ownership of uri is transferred. */\n", "static\n", "struct lttng_session_descriptor_snapshot *\n", "_lttng_session_descriptor_snapshot_local_create(const char *name,\n", "\t\tstruct lttng_uri *uri)\n", "{\n", "\tstruct lttng_session_descriptor_snapshot *descriptor;\n", "\n", "\tdescriptor = _lttng_session_descriptor_snapshot_create(name);\n", "\tif (!descriptor) {\n", "\t\tgoto error;\n", "\t}\n", "\tdescriptor->base.output_type =\n", "\t\t\tLTTNG_SESSION_DESCRIPTOR_OUTPUT_TYPE_LOCAL;\n", "\tif (uri) {\n", "\t\tif (uri->dtype != LTTNG_DST_PATH) {\n", "\t\t\tgoto error;\n", "\t\t}\n", "\t\tdescriptor->base.output.local = uri;\n", "\t\turi = NULL;\n", "\t}\n", "\treturn descriptor;\n", "error:\n", "\tfree(uri);\n", "\tlttng_session_descriptor_destroy(descriptor ? &descriptor->base : NULL);\n", "\treturn NULL;\n", "}\n"], "project": "python3-lttng", "file": "session-descriptor.pkl", "function": "_lttng_session_descriptor_snapshot_local_create"}, {"comment_all": {"comment": "/* AAARGH! No way to avoid this I think.  Happens when:\n\t  *  - program calls on_read which works, setting immediate callback;\n\t  *  - process calls the application's function, which returns\n\t  *    OOP_HALT or some such, but without calling on_cancel;\n\t  *  Now we have to set another immediate callback.\n\t  *  If this fails and we were to ignore it then:\n\t  *  - program reenters event loop, expecting to deal with the rest\n\t  *    of the oop_readable_mem data.  But we've lost the flow\n\t  *    of control and the callback never happens, so\n\t  *    oop_sys_run or whatever would (lyingly) exit straight\n\t  *    away with OOP_CONTINUE.\n\t  *  Alternatively we could ignore the application's request\n\t  *  to abort the event loop, which seems just as bad.\n\t  */", "depth": 2, "reading_ease": 58.62, "reading_grade": 10.3, "line": 58}, "comment_text": "/* AAARGH! No way to avoid this I think.  Happens when:\n\t  *  - program calls on_read which works, setting immediate callback;\n\t  *  - process calls the application's function, which returns\n\t  *    OOP_HALT or some such, but without calling on_cancel;\n\t  *  Now we have to set another immediate callback.\n\t  *  If this fails and we were to ignore it then:\n\t  *  - program reenters event loop, expecting to deal with the rest\n\t  *    of the oop_readable_mem data.  But we've lost the flow\n\t  *    of control and the callback never happens, so\n\t  *    oop_sys_run or whatever would (lyingly) exit straight\n\t  *    away with OOP_CONTINUE.\n\t  *  Alternatively we could ignore the application's request\n\t  *  to abort the event loop, which seems just as bad.\n\t  */", "comment_tokens": ["AAARGH", "!", "No", "way", "to", "avoid", "this", "I", "think", ".", "Happens", "when", ":", "-", "program", "calls", "on_read", "which", "works", ",", "setting", "immediate", "callback", ";", "-", "process", "calls", "the", "application", "'s", "function", ",", "which", "returns", "OOP_HALT", "or", "some", "such", ",", "but", "without", "calling", "on_cancel", ";", "Now", "we", "have", "to", "set", "another", "immediate", "callback", ".", "If", "this", "fails", "and", "we", "were", "to", "ignore", "it", "then", ":", "-", "program", "reenters", "event", "loop", ",", "expecting", "to", "deal", "with", "the", "rest", "of", "the", "oop_readable_mem", "data", ".", "But", "we", "'ve", "lost", "the", "flow", "of", "control", "and", "the", "callback", "never", "happens", ",", "so", "oop_sys_run", "or", "whatever", "would", "(", "lyingly", ")", "exit", "straight", "away", "with", "OOP_CONTINUE", ".", "Alternatively", "we", "could", "ignore", "the", "application", "'s", "request", "to", "abort", "the", "event", "loop", ",", "which", "seems", "just", "as", "bad", "."], "ccode": ["\n", "static void *process(oop_source *oop, struct timeval when, void *ram_void) {\n", "  ram_intern *ram= ram_void;\n", "  void *ret;\n", "  int err;\n", "\n", "  assert(oop == ram->oop);\n", "  assert(ram->processing);\n", "\n", "  ret= OOP_CONTINUE;\n", "\n", "  while (ram->state == state_active && ret == OOP_CONTINUE) {\n", "    ret= ram->call(oop,&ram->ra,ram->opaque);\n", "  }\n", "\n", "  switch (ram->state) {\n", "\n", "  case state_active:\n", "    err= set_time(ram);\n", "    if (err)\n", "      assert(!\"must not lose flow of control\");\n", "         /* AAARGH! No way to avoid this I think.  Happens when:\n", "\t  *  - program calls on_read which works, setting immediate callback;\n", "\t  *  - process calls the application's function, which returns\n", "\t  *    OOP_HALT or some such, but without calling on_cancel;\n", "\t  *  Now we have to set another immediate callback.\n", "\t  *  If this fails and we were to ignore it then:\n", "\t  *  - program reenters event loop, expecting to deal with the rest\n", "\t  *    of the oop_readable_mem data.  But we've lost the flow\n", "\t  *    of control and the callback never happens, so\n", "\t  *    oop_sys_run or whatever would (lyingly) exit straight\n", "\t  *    away with OOP_CONTINUE.\n", "\t  *  Alternatively we could ignore the application's request\n", "\t  *  to abort the event loop, which seems just as bad.\n", "\t  */\n", "    break;\n", "\n", "  case state_cancelled:\n", "    ram->processing= 0;\n", "    break;\n", "\n", "  case state_dying:\n", "    oop_free(ram);\n", "    break;\n", "  }\n", "  \n", "  return ret;\n", "}\n"], "project": "liboop-doc", "file": "read-mem.pkl", "function": "process"}, {"comment_all": {"comment": "/* Check presence of CLWB - bit 24 of EBX */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 197}, "comment_text": "/* Check presence of CLWB - bit 24 of EBX */", "comment_tokens": ["Check", "presence", "of", "CLWB", "-", "bit", "24", "of", "EBX"], "ccode": ["\n", "static uint32_t\n", "detect_clwb(void)\n", "{\n", "        /* Check presence of CLWB - bit 24 of EBX */\n", "        return (cpuid_7_0.ebx & (1 << 24));\n", "}\n"], "project": "intel-cmt-cat", "file": "membw.pkl", "function": "detect_clwb"}, {"comment_all": {"comment": "/*\n         * Temporarily clear the number of records to expect\n         *    (allows the tree to be freed in case of problems)\n         * Also handle network/host ordering\n         */", "depth": 1, "reading_ease": 57.61, "reading_grade": 10.7, "line": 460}, "comment_text": "/*\n         * Temporarily clear the number of records to expect\n         *    (allows the tree to be freed in case of problems)\n         * Also handle network/host ordering\n         */", "comment_tokens": ["Temporarily", "clear", "the", "number", "of", "records", "to", "expect", "(", "allows", "the", "tree", "to", "be", "freed", "in", "case", "of", "problems", ")", "Also", "handle", "networkhost", "ordering"], "ccode": ["\n", "\n", "\n", "\n", "        /*\n", "         *  res_parse:\n", "         *      Parse a DNS response buffer\n", "         *\n", "         *  returns a pointer to the expanded tree (or NULL on failure).\n", "         */\n", "res_response *\n", "res_parse(char *msg)\n", "{\n", "        char *cp;\n", "        HEADER *hp;\n", "        res_response *resp;\n", "        int i;\n", "\n", "        u_short qdcount, ancount, nscount, arcount;\n", "\n", "\n", "        /*\n", "         * Set up the response structure,\n", "         *  and copy across the header fields.\n", "         */\n", "        if ((resp = (res_response *)malloc(sizeof(res_response))) == NULL )\n", "                return(NULL);\n", "        memcpy((void *)&(resp->header), (void *)msg, sizeof(HEADER));\n", "        hp = &(resp->header);\n", "        cp = msg + sizeof(HEADER);\n", "\n", "\n", "        /*\n", "         * Temporarily clear the number of records to expect\n", "         *    (allows the tree to be freed in case of problems)\n", "         * Also handle network/host ordering\n", "         */\n", "        qdcount = ntohs((u_short)resp->header.qdcount); resp->header.qdcount = 0;\n", "        ancount = ntohs((u_short)resp->header.ancount); resp->header.ancount = 0;\n", "        nscount = ntohs((u_short)resp->header.nscount); resp->header.nscount = 0;\n", "        arcount = ntohs((u_short)resp->header.arcount); resp->header.arcount = 0;\n", "        resp->question = NULL;\n", "        resp->answer = NULL;\n", "        resp->authority = NULL;\n", "        resp->additional = NULL;\n", "\n", "        /*\n", "         * Handle question records.\n", "         */\n", "        if ( qdcount ) {\n", "                if ((resp->question = (s_question **)malloc(qdcount*sizeof(s_question*))) == NULL )\n", "                        return(NULL);\n", "                for ( i=0 ; i<qdcount ; i++ )           /* Clear, in case of free */\n", "                        resp->question[i] = NULL;\n", "                resp->header.qdcount = qdcount;  /* Stores swapped byte order!  Requires change to free_response. --GAT */\n", "                for ( i=0 ; i<qdcount ; i++ )\n", "                        if ((resp->question[i] = parse_question(&cp, msg)) == NULL ) {\n", "                                free_response(resp);\n", "                                free(resp);\n", "                                return(NULL);\n", "                        }\n", "        }\n", "\n", "\n", "        /*\n", "         * Handle authoritative answer records\n", "         */\n", "        if ( ancount ) {\n", "                if ((resp->answer = (s_rr **)malloc(ancount*sizeof(s_rr*))) == NULL ) {\n", "                        resp->header.ancount = 0;\n", "                        free_response(resp);\n", "                        free(resp);\n", "                        return(NULL);\n", "                }\n", "                for ( i=0 ; i<ancount ; i++ )\n", "                        resp->answer[i] = NULL;\n", "                resp->header.ancount = ancount;  /* Stores swapped byte order!  Requires change to free_response. --GAT */\n", "                for ( i=0 ; i<ancount ; i++ )\n", "                        if ((resp->answer[i] = parse_rr(&cp, msg)) == NULL ) {\n", "                                free_response(resp);\n", "                                free(resp);\n", "                                return(NULL);\n", "                        }\n", "        }\n", "\n", "\n", "        /*\n", "         * Handle name server records\n", "         */\n", "        if ( nscount ) {\n", "                if ((resp->authority = (s_rr **)malloc(nscount*sizeof(s_rr*))) == NULL ) {\n", "                        resp->header.nscount = 0;\n", "                        free_response(resp);\n", "                        free(resp);\n", "                        return(NULL);\n", "                }\n", "                for ( i=0 ; i<nscount ; i++ )\n", "                        resp->authority[i] = NULL;\n", "                resp->header.nscount = nscount;  /* Stores swapped byte order!  Requires change to free_response. --GAT */\n", "                for ( i=0 ; i<nscount ; i++ )\n", "                        if ((resp->authority[i] = parse_rr(&cp, msg)) == NULL ) {\n", "                                free_response(resp);\n", "                                free(resp);\n", "                                return(NULL);\n", "                        }\n", "        }\n", "\n", "\n", "        /*\n", "         * Handle additional records\n", "         */\n", "        if ( arcount ) {\n", "                if ((resp->additional = (s_rr **)malloc(arcount*sizeof(s_rr*))) == NULL ) {\n", "                        resp->header.arcount = 0;\n", "                        free_response(resp);\n", "                        free(resp);\n", "                        return(NULL);\n", "                }\n", "                for ( i=0 ; i<arcount ; i++ )\n", "                        resp->additional[i] = NULL;\n", "                resp->header.arcount = arcount;  /* Stores swapped byte order!  Requires change to free_response. --GAT */\n", "                for ( i=0 ; i<arcount ; i++ )\n", "                        if ((resp->additional[i] = parse_rr(&cp, msg)) == NULL ) {\n", "                                free_response(resp);\n", "                                free(resp);\n", "                                return(NULL);\n", "                        }\n", "        }\n", "\n", "        return(resp);\n", "}\n"], "project": "libsipxtapi-dev", "file": "res_parse.pkl", "function": "res_parse"}, {"comment_all": {"comment": "/*\n * Copyright (c) 1997 - 2003 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */", "depth": 0, "reading_ease": 25.53, "reading_grade": 16.8, "line": 0}, "comment_text": "/*\n * Copyright (c) 1997 - 2003 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */", "comment_tokens": ["Copyright", "(", "c", ")", "1997", "-", "2003", "Kungliga", "Tekniska", "H\u00f6gskolan", "(", "Royal", "Institute", "of", "Technology", ",", "Stockholm", ",", "Sweden", ")", ".", "All", "rights", "reserved", ".", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "1", ".", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "2", ".", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "3", ".", "Neither", "the", "name", "of", "the", "Institute", "nor", "the", "names", "of", "its", "contributors", "may", "be", "used", "to", "endorse", "or", "promote", "products", "derived", "from", "this", "software", "without", "specific", "prior", "written", "permission", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "INSTITUTE", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "INSTITUTE", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", "."], "ccode": ["/*\n", " * Copyright (c) 1997 - 2003 Kungliga Tekniska H\u00f6gskolan\n", " * (Royal Institute of Technology, Stockholm, Sweden).\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " *\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " *\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " *\n", " * 3. Neither the name of the Institute nor the names of its contributors\n", " *    may be used to endorse or promote products derived from this software\n", " *    without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "\n", "#include \"gsskrb5_locl.h\"\n", "\n", "krb5_error_code\n", "_gsskrb5_encode_om_uint32(OM_uint32 n, u_char *p)\n", "{\n", "  p[0] = (n >> 0)  & 0xFF;\n", "  p[1] = (n >> 8)  & 0xFF;\n", "  p[2] = (n >> 16) & 0xFF;\n", "  p[3] = (n >> 24) & 0xFF;\n", "  return 0;\n", "}\n"], "project": "heimdal-clients", "file": "8003.pkl", "function": "_gsskrb5_encode_om_uint32"}, {"comment_all": {"comment": "/* Use the very latest data */", "depth": 2, "reading_ease": 83.32, "reading_grade": 2.9, "line": 100}, "comment_text": "/* Use the very latest data */", "comment_tokens": ["Use", "the", "very", "latest", "data"], "ccode": ["\n", "\n", "static void synaescope_set_data(void *audio_buffer, int size)\n", "{\n", "\tshort *sound = (short *)audio_buffer;\n", "\tif (!sound) {\n", "\t\t\tmemset(&pcm_l, 0, sizeof(pcm_l));\n", "\t\t\tmemset(&pcm_r, 0, sizeof(pcm_r));\n", "\t\t\treturn;\n", "\t}\t\n", "\tif (running && size > FFT_BUFFER_SIZE * 2) {\n", "\t\tint i;\n", "\t\tsound_sample *newset_l = pcmt_l;\n", "\t\tsound_sample *newset_r = pcmt_r;\n", "\t\tsound += (size / 2 - FFT_BUFFER_SIZE) * 2; /* Use the very latest data */\n", "\t\tfor (i=0; i < FFT_BUFFER_SIZE; i++) {\n", "\t\t\t*(newset_l++) = (sound_sample)(*(sound++));\n", "\t\t\t*(newset_r++) = (sound_sample)(*(sound++));\n", "\t\t}\n", "\t}\n", "}\n"], "project": "alsaplayer-daemon", "file": "synaescope.pkl", "function": "synaescope_set_data"}, {"comment_all": {"comment": "//DBG(GENERAL, \"\\n\");\n", "depth": 1, "reading_ease": 35.61, "reading_grade": 8.8, "line": 671}, "comment_text": "//DBG(GENERAL, \"\\n\");\n", "comment_tokens": ["DBG", "(", "GENERAL", ",", "``", "\\n", "''", ")", ";"], "ccode": ["\n", "static bool global_packet_is_valid(xpacket_t *pack)\n", "{\n", "\tconst xproto_entry_t *xe;\n", "\n", "\t//DBG(GENERAL, \"\\n\");\n", "\txe = xproto_global_entry(XPACKET_OP(pack));\n", "\treturn xe != NULL;\n", "}\n"], "project": "dahdi-linux", "file": "card_global.pkl", "function": "global_packet_is_valid"}, {"comment_all": {"comment": "/*\n * Iterate over two ABDs and call func incrementally on the two ABDs' data in\n * equal-sized chunks (passed to func as raw buffers). func could be called many\n * times during this iteration.\n */", "depth": 0, "reading_ease": 72.66, "reading_grade": 7.0, "line": 1280}, "comment_text": "/*\n * Iterate over two ABDs and call func incrementally on the two ABDs' data in\n * equal-sized chunks (passed to func as raw buffers). func could be called many\n * times during this iteration.\n */", "comment_tokens": ["Iterate", "over", "two", "ABDs", "and", "call", "func", "incrementally", "on", "the", "two", "ABDs", "'", "data", "in", "equal-sized", "chunks", "(", "passed", "to", "func", "as", "raw", "buffers", ")", ".", "func", "could", "be", "called", "many", "times", "during", "this", "iteration", "."], "ccode": ["\n", "/*\n", " * Iterate over two ABDs and call func incrementally on the two ABDs' data in\n", " * equal-sized chunks (passed to func as raw buffers). func could be called many\n", " * times during this iteration.\n", " */\n", "int\n", "abd_iterate_func2(abd_t *dabd, abd_t *sabd, size_t doff, size_t soff,\n", "    size_t size, abd_iter_func2_t *func, void *private)\n", "{\n", "\tint ret = 0;\n", "\tstruct abd_iter daiter, saiter;\n", "\n", "\tabd_verify(dabd);\n", "\tabd_verify(sabd);\n", "\n", "\tASSERT3U(doff + size, <=, dabd->abd_size);\n", "\tASSERT3U(soff + size, <=, sabd->abd_size);\n", "\n", "\tabd_iter_init(&daiter, dabd, 0);\n", "\tabd_iter_init(&saiter, sabd, 1);\n", "\tabd_iter_advance(&daiter, doff);\n", "\tabd_iter_advance(&saiter, soff);\n", "\n", "\twhile (size > 0) {\n", "\t\tabd_iter_map(&daiter);\n", "\t\tabd_iter_map(&saiter);\n", "\n", "\t\tsize_t dlen = MIN(daiter.iter_mapsize, size);\n", "\t\tsize_t slen = MIN(saiter.iter_mapsize, size);\n", "\t\tsize_t len = MIN(dlen, slen);\n", "\t\tASSERT(dlen > 0 || slen > 0);\n", "\n", "\t\tret = func(daiter.iter_mapaddr, saiter.iter_mapaddr, len,\n", "\t\t    private);\n", "\n", "\t\tabd_iter_unmap(&saiter);\n", "\t\tabd_iter_unmap(&daiter);\n", "\n", "\t\tif (ret != 0)\n", "\t\t\tbreak;\n", "\n", "\t\tsize -= len;\n", "\t\tabd_iter_advance(&daiter, len);\n", "\t\tabd_iter_advance(&saiter, len);\n", "\t}\n", "\n", "\treturn (ret);\n", "}\n"], "project": "pyzfs-doc", "file": "abd.pkl", "function": "abd_iterate_func2"}, {"comment_all": {"comment": "/**\n * @file dump_config.c\n * @brief Implements dump_config.h\n */", "depth": 0, "reading_ease": 15.64, "reading_grade": 12.3, "line": 10}, "comment_text": "/**\n * @file dump_config.c\n * @brief Implements dump_config.h\n */", "comment_tokens": ["@", "file", "dump_config.c", "@", "brief", "Implements", "dump_config.h"], "ccode": ["/****************************************************************************\n", "** dump_config.c ***********************************************************\n", "****************************************************************************\n", "*\n", "* dump_config.c - dumps data structures into file\n", "*\n", "* Copyright (C) 1998 Pablo d'Angelo <pablo@ag-trek.allgaeu.org>\n", "*\n", "*/\n", "\n", "/**\n", " * @file dump_config.c\n", " * @brief Implements dump_config.h\n", " */\n", "\n", "#ifdef HAVE_CONFIG_H\n", "# include <config.h>\n", "#endif\n", "\n", "#ifdef TIME_WITH_SYS_TIME\n", "# include <sys/time.h>\n", "# include <time.h>\n", "#else\n", "# ifdef HAVE_SYS_TIME_H\n", "#  include <sys/time.h>\n", "# else\n", "#  include <time.h>\n", "# endif\n", "#endif\n", "\n", "#include <stdio.h>\n", "#include <stdint.h>\n", "\n", "#ifdef HAVE_KERNEL_LIRC_H\n", "#include <linux/lirc.h>\n", "#else\n", "#include \"media/lirc.h\"\n", "#endif\n", "\n", "#include \"lirc/config_file.h\"\n", "#include \"lirc/dump_config.h\"\n", "#include \"lirc/config_flags.h\"\n", "#include \"lirc/ir_remote_types.h\"\n", "\n", "void fprint_comment(FILE* f, const struct ir_remote* rem, const char* commandline)\n", "{\n", "\ttime_t timet;\n", "\tstruct tm* tmp;\n", "\tchar cmd[128];\n", "\tchar uname[64];\n", "\tFILE* p;\n", "\n", "\tp = popen(\"uname -r\", \"r\");\n", "\tif (p < 0) {\n", "\t\tstrcat(uname, \"Cannot run uname -r(!)\");\n", "\t} else {\n", "\t\tif (fgets(uname, sizeof(uname), p) != uname)\n", "\t\t\tstrcat(uname, \"Cannot run uname -r (!)\");\n", "\t\tpclose(p);\n", "\t}\n", "\tif (commandline)\n", "\t\tsnprintf(cmd, sizeof(cmd), \"%s\", commandline);\n", "\telse\n", "\t\tstrcat(cmd, \"\");\n", "\n", "\ttimet = time(NULL);\n", "\ttmp = localtime(&timet);\n", "\tfprintf(f,\n", "\t\t\"#\\n\"\n", "\t\t\"# This config file was automatically generated\\n\"\n", "\t\t\"# using lirc-%s(%s) on %s\"\n", "\t\t\"# Command line used: %s\\n\"\n", "\t\t\"# Kernel version (uname -r): %s\"\n", "\t\t\"#\\n\"\n", "\t\t\"# Remote name (as of config file): %s\\n\"\n", "\t\t\"# Brand of remote device, the thing you hold in your hand:\\n\"\n", "\t\t\"# Remote device model nr:\\n\"\n", "\t\t\"# Remote device info url:\\n\"\n", "\t\t\"# Does remote device has a bundled capture device e. g., a\\n\"\n", "\t\t\"#     usb dongle? :\\n\"\n", "\t\t\"# For bundled USB devices: usb vendor id, product id\\n\"\n", "\t\t\"#     and device string (use dmesg or lsusb):\\n\"\n", "\t\t\"# Type of device controlled\\n\"\n", "\t\t\"#     (TV, VCR, Audio, DVD, Satellite, Cable, HTPC, ...) :\\n\"\n", "\t\t\"# Device(s) controlled by this remote:\\n\\n\",\n", "\t\tVERSION, curr_driver->name, asctime(tmp), cmd, uname, rem->name);\n", "}\n"], "project": "liblircclient0", "file": "dump_config.pkl", "function": "fprint_comment"}, {"comment_all": {"comment": "/* Mednafen - Multi-system Emulator\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "depth": 0, "reading_ease": 47.93, "reading_grade": 12.3, "line": 0}, "comment_text": "/* Mednafen - Multi-system Emulator\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "comment_tokens": ["Mednafen", "-", "Multi-system", "Emulator", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/* Mednafen - Multi-system Emulator\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", " */\n", "\n", "#include \"mednafen-endian.h\"\n", "\n", "void Endian_A16_Swap(void *src, uint32_t nelements)\n", "{\n", "   uint32_t i;\n", "   uint8_t *nsrc = (uint8_t *)src;\n", "\n", "   for(i = 0; i < nelements; i++)\n", "   {\n", "      uint8_t tmp = nsrc[i * 2];\n", "\n", "      nsrc[i * 2] = nsrc[i * 2 + 1];\n", "      nsrc[i * 2 + 1] = tmp;\n", "   }\n", "}\n"], "project": "libretro-beetle-wswan", "file": "mednafen-endian.pkl", "function": "Endian_A16_Swap"}, {"comment_all": {"comment": "/* Try to read more data. */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 3299}, "comment_text": "/* Try to read more data. */", "comment_tokens": ["Try", "to", "read", "more", "data", "."], "ccode": ["\n", "/* yy_get_next_buffer - try to read in a new buffer\n", " *\n", " * Returns a code representing an action:\n", " *\tEOB_ACT_LAST_MATCH -\n", " *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n", " *\tEOB_ACT_END_OF_FILE - end of file\n", " */\n", "static int yy_get_next_buffer (void)\n", "{\n", "    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n", "\tchar *source = (yytext_ptr);\n", "\tint number_to_move, i;\n", "\tint ret_val;\n", "\n", "\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n", "\t\tYY_FATAL_ERROR(\n", "\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n", "\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n", "\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n", "\t\t\t{\n", "\t\t\t/* We matched a single character, the EOB, so\n", "\t\t\t * treat this as a final EOF.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_END_OF_FILE;\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\t/* We matched some text prior to the EOB, first\n", "\t\t\t * process it.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_LAST_MATCH;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t/* Try to read more data. */\n", "\n", "\t/* First move last chars to start of buffer. */\n", "\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n", "\n", "\tfor ( i = 0; i < number_to_move; ++i )\n", "\t\t*(dest++) = *(source++);\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n", "\t\t/* don't do the read, it's not guaranteed to return an EOF,\n", "\t\t * just force an EOF\n", "\t\t */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n", "\n", "\telse\n", "\t\t{\n", "\t\t\tint num_to_read =\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n", "\n", "\t\twhile ( num_to_read <= 0 )\n", "\t\t\t{ /* Not enough room in the buffer - grow it. */\n", "\n", "\t\t\t/* just a shorter name for the current buffer */\n", "\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n", "\n", "\t\t\tint yy_c_buf_p_offset =\n", "\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n", "\n", "\t\t\tif ( b->yy_is_our_buffer )\n", "\t\t\t\t{\n", "\t\t\t\tint new_size = b->yy_buf_size * 2;\n", "\n", "\t\t\t\tif ( new_size <= 0 )\n", "\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n", "\t\t\t\telse\n", "\t\t\t\t\tb->yy_buf_size *= 2;\n", "\n", "\t\t\t\tb->yy_ch_buf = (char *)\n", "\t\t\t\t\t/* Include room in for 2 EOB chars. */\n", "\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n", "\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n", "\t\t\t\t}\n", "\t\t\telse\n", "\t\t\t\t/* Can't grow it, we don't own it. */\n", "\t\t\t\tb->yy_ch_buf = NULL;\n", "\n", "\t\t\tif ( ! b->yy_ch_buf )\n", "\t\t\t\tYY_FATAL_ERROR(\n", "\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n", "\n", "\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n", "\n", "\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n", "\t\t\t\t\t\tnumber_to_move - 1;\n", "\n", "\t\t\t}\n", "\n", "\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n", "\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n", "\n", "\t\t/* Read in more data. */\n", "\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n", "\t\t\t(yy_n_chars), num_to_read );\n", "\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\tif ( (yy_n_chars) == 0 )\n", "\t\t{\n", "\t\tif ( number_to_move == YY_MORE_ADJ )\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_END_OF_FILE;\n", "\t\t\tyyrestart( yyin  );\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_LAST_MATCH;\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n", "\t\t\t\tYY_BUFFER_EOF_PENDING;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\telse\n", "\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n", "\n", "\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n", "\t\t/* Extend the array by 50%, plus the number we really need. */\n", "\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n", "\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n", "\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n", "\t\t/* \"- 2\" to take care of EOB's */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n", "\t}\n", "\n", "\t(yy_n_chars) += number_to_move;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n", "\n", "\treturn ret_val;\n", "}\n"], "project": "linux-buildinfo-5.11.0-1019-oracle", "file": "lexer.lex.pkl", "function": "yy_get_next_buffer"}, {"comment_all": {"comment": "/* Our crappy parser. A token is either a whitespace-delimited word, or a\n * bunch of words in double quotes (backslashes are permitted in either case).\n * src points to somewhere in a buffer -- the caller must save the location of\n * this buffer, because we update src to point past all the tokens found so\n * far. If we find a token, we write it into dest (caller is responsible for\n * allocating storage) and return 1. Otherwise return 0. */", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 41}, "comment_text": "/* Our crappy parser. A token is either a whitespace-delimited word, or a\n * bunch of words in double quotes (backslashes are permitted in either case).\n * src points to somewhere in a buffer -- the caller must save the location of\n * this buffer, because we update src to point past all the tokens found so\n * far. If we find a token, we write it into dest (caller is responsible for\n * allocating storage) and return 1. Otherwise return 0. */", "comment_tokens": ["Our", "crappy", "parser", ".", "A", "token", "is", "either", "a", "whitespace-delimited", "word", ",", "or", "a", "bunch", "of", "words", "in", "double", "quotes", "(", "backslashes", "are", "permitted", "in", "either", "case", ")", ".", "src", "points", "to", "somewhere", "in", "a", "buffer", "--", "the", "caller", "must", "save", "the", "location", "of", "this", "buffer", ",", "because", "we", "update", "src", "to", "point", "past", "all", "the", "tokens", "found", "so", "far", ".", "If", "we", "find", "a", "token", ",", "we", "write", "it", "into", "dest", "(", "caller", "is", "responsible", "for", "allocating", "storage", ")", "and", "return", "1", ".", "Otherwise", "return", "0", "."], "ccode": ["\n", "/* Our crappy parser. A token is either a whitespace-delimited word, or a\n", " * bunch of words in double quotes (backslashes are permitted in either case).\n", " * src points to somewhere in a buffer -- the caller must save the location of\n", " * this buffer, because we update src to point past all the tokens found so\n", " * far. If we find a token, we write it into dest (caller is responsible for\n", " * allocating storage) and return 1. Otherwise return 0. */\n", "\n", "int get_token(char **src, char *dest)\n", "{\n", "    int quoted = 0, nchars = 0;\n", "\n", "    while (**src && isspace(**src)) (*src)++;\n", "\n", "    if (**src == '\"') {\n", "        quoted = 1;\n", "        (*src)++;\n", "    }\n", "\n", "    while (**src) {\n", "        if (quoted) {\n", "            if (**src == '\"') {\n", "                (*src)++;\n", "                break;\n", "            }\n", "        } else {\n", "            if (isspace(**src))\n", "                break;\n", "        }\n", "        if (**src == '\\\\') (*src)++;\n", "        *dest++ = *(*src)++;\n", "        nchars++;\n", "    }\n", "\n", "    *dest = '\\0';\n", "    return nchars || quoted;\n", "}\n"], "project": "aewm", "file": "parser.pkl", "function": "get_token"}, {"comment_all": {"comment": "/* Only push if top exists. Otherwise, replace top. */", "depth": 1, "reading_ease": 67.42, "reading_grade": 4.9, "line": 3827}, "comment_text": "/* Only push if top exists. Otherwise, replace top. */", "comment_tokens": ["Only", "push", "if", "top", "exists", ".", "Otherwise", ",", "replace", "top", "."], "ccode": ["\n", "/** Pushes the new state onto the stack. The new state becomes\n", " *  the current state. This function will allocate the stack\n", " *  if necessary.\n", " *  @param new_buffer The new state.\n", " *  \n", " */\n", "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n", "{\n", "    \tif (new_buffer == NULL)\n", "\t\treturn;\n", "\n", "\tyyensure_buffer_stack();\n", "\n", "\t/* This block is copied from yy_switch_to_buffer. */\n", "\tif ( YY_CURRENT_BUFFER )\n", "\t\t{\n", "\t\t/* Flush out information for old buffer. */\n", "\t\t*(yy_c_buf_p) = (yy_hold_char);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\t/* Only push if top exists. Otherwise, replace top. */\n", "\tif (YY_CURRENT_BUFFER)\n", "\t\t(yy_buffer_stack_top)++;\n", "\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n", "\n", "\t/* copied from yy_switch_to_buffer. */\n", "\tyy_load_buffer_state(  );\n", "\t(yy_did_buffer_switch_on_eof) = 1;\n", "}\n"], "project": "linux-buildinfo-5.6.0-1042-oem", "file": "lexer.lex.pkl", "function": "yypush_buffer_state"}, {"comment_all": {"comment": "/* \"safe\" strncpy, saves room for \\0 at end of dest, and refuses to copy\n * more than \"n\" bytes.  Returns the number of bytes copied, or -1 if there\n * was an error.\n */", "depth": 0, "reading_ease": 89.58, "reading_grade": 4.6, "line": 41}, "comment_text": "/* \"safe\" strncpy, saves room for \\0 at end of dest, and refuses to copy\n * more than \"n\" bytes.  Returns the number of bytes copied, or -1 if there\n * was an error.\n */", "comment_tokens": ["``", "safe", "''", "strncpy", ",", "saves", "room", "for", "\\0", "at", "end", "of", "dest", ",", "and", "refuses", "to", "copy", "more", "than", "``", "n", "''", "bytes", ".", "Returns", "the", "number", "of", "bytes", "copied", ",", "or", "-1", "if", "there", "was", "an", "error", "."], "ccode": ["/*\n", " * ProFTPD - FTP server daemon\n", " * Copyright (c) 1997, 1998 Public Flood Software\n", " * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n", " * Copyright (c) 2001-2015 The ProFTPD Project team\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA.\n", " *\n", " * As a special exemption, Public Flood Software/MacGyver aka Habeeb J. Dihu\n", " * and other respective copyright holders give permission to link this program\n", " * with OpenSSL, and distribute the resulting executable, without including\n", " * the source code for OpenSSL in the source distribution.\n", " */\n", "\n", "#ifdef HAVE_CONFIG_H\n", "# include \"config.h\"\n", "#endif\n", "\n", "#include <errno.h>\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <stdarg.h>\n", "\n", "#ifdef HAVE_STRING_H\n", "# include <string.h>\n", "#endif\n", "\n", "#include \"libsupp.h\"\n", "\n", "/* \"safe\" strncpy, saves room for \\0 at end of dest, and refuses to copy\n", " * more than \"n\" bytes.  Returns the number of bytes copied, or -1 if there\n", " * was an error.\n", " */\n", "int sstrncpy(char *dst, const char *src, size_t n) {\n", "  register char *d;\n", "  int res = 0;\n", "\n", "  if (dst == NULL) {\n", "    errno = EINVAL;\n", "    return -1;\n", "  }\n", "\n", "  if (src == NULL) {\n", "    errno = EINVAL;\n", "    return -1;\n", "  }\n", "\n", "  if (n == 0) {\n", "    return 0;\n", "  }\n", "\n", "  /* Avoid attempts to overwrite memory with itself (Bug#4156). */\n", "  if (dst == src) {\n", "    return n;\n", "  }\n", "\n", "  d = dst;\n", "  if (src && *src) {\n", "    for (; *src && n > 1; n--) {\n", "      *d++ = *src++;\n", "      res++;\n", "    }\n", "  }\n", "\n", "  *d = '\\0';\n", "  return res;\n", "}\n"], "project": "proftpd-mod-sqlite", "file": "sstrncpy.pkl", "function": "sstrncpy"}, {"comment_all": {"comment": "/*-------------------------------------------------------------*\n *     Full image clear/set/set-to-arbitrary-value/invert      *\n *-------------------------------------------------------------*/", "depth": 0, "reading_ease": -109.24, "reading_grade": 29.2, "line": 759}, "comment_text": "/*-------------------------------------------------------------*\n *     Full image clear/set/set-to-arbitrary-value/invert      *\n *-------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "Full", "image", "clearsetset-to-arbitrary-valueinvert", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "\n", "/*-------------------------------------------------------------*\n", " *     Full image clear/set/set-to-arbitrary-value/invert      *\n", " *-------------------------------------------------------------*/\n", "/*!\n", " * \\brief   pixClearAll()\n", " *\n", " * \\param[in]    pix    all depths; use cmapped with caution\n", " * \\return  0 if OK, 1 on error\n", " *\n", " * <pre>\n", " * Notes:\n", " *      (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale\n", " *          or color, this is black.\n", " *      (2) Caution: for colormapped pix, this sets the color to the first\n", " *          one in the colormap.  Be sure that this is the intended color!\n", " * </pre>\n", " */\n", "l_ok\n", "pixClearAll(PIX  *pix)\n", "{\n", "    PROCNAME(\"pixClearAll\");\n", "\n", "    if (!pix)\n", "        return ERROR_INT(\"pix not defined\", procName, 1);\n", "\n", "    pixRasterop(pix, 0, 0, pixGetWidth(pix), pixGetHeight(pix),\n", "                PIX_CLR, NULL, 0, 0);\n", "    return 0;\n", "}\n"], "project": "libleptonica-dev", "file": "pix2.pkl", "function": "pixClearAll"}, {"comment_all": {"comment": "/* we trash this state. */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 453}, "comment_text": "/* we trash this state. */", "comment_tokens": ["we", "trash", "this", "state", "."], "ccode": ["\n", "static int\n", "GL_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n", "{\n", "    GL_RenderData *renderdata = (GL_RenderData *) renderer->driverdata;\n", "    const GLenum textype = renderdata->textype;\n", "    GL_TextureData *data;\n", "    GLint internalFormat;\n", "    GLenum format, type;\n", "    int texture_w, texture_h;\n", "    GLenum scaleMode;\n", "\n", "    GL_ActivateRenderer(renderer);\n", "\n", "    renderdata->drawstate.texture = NULL;  /* we trash this state. */\n", "\n", "    if (texture->access == SDL_TEXTUREACCESS_TARGET &&\n", "        !renderdata->GL_EXT_framebuffer_object_supported) {\n", "        return SDL_SetError(\"Render targets not supported by OpenGL\");\n", "    }\n", "\n", "    if (!convert_format(renderdata, texture->format, &internalFormat,\n", "                        &format, &type)) {\n", "        return SDL_SetError(\"Texture format %s not supported by OpenGL\",\n", "                            SDL_GetPixelFormatName(texture->format));\n", "    }\n", "\n", "    data = (GL_TextureData *) SDL_calloc(1, sizeof(*data));\n", "    if (!data) {\n", "        return SDL_OutOfMemory();\n", "    }\n", "\n", "    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n", "        size_t size;\n", "        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n", "        size = texture->h * data->pitch;\n", "        if (texture->format == SDL_PIXELFORMAT_YV12 ||\n", "            texture->format == SDL_PIXELFORMAT_IYUV) {\n", "            /* Need to add size for the U and V planes */\n", "            size += 2 * ((texture->h + 1) / 2) * ((data->pitch + 1) / 2);\n", "        }\n", "        if (texture->format == SDL_PIXELFORMAT_NV12 ||\n", "            texture->format == SDL_PIXELFORMAT_NV21) {\n", "            /* Need to add size for the U/V plane */\n", "            size += 2 * ((texture->h + 1) / 2) * ((data->pitch + 1) / 2);\n", "        }\n", "        data->pixels = SDL_calloc(1, size);\n", "        if (!data->pixels) {\n", "            SDL_free(data);\n", "            return SDL_OutOfMemory();\n", "        }\n", "    }\n", "\n", "    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n", "        data->fbo = GL_GetFBO(renderdata, texture->w, texture->h);\n", "    } else {\n", "        data->fbo = NULL;\n", "    }\n", "\n", "    GL_CheckError(\"\", renderer);\n", "    renderdata->glGenTextures(1, &data->texture);\n", "    if (GL_CheckError(\"glGenTextures()\", renderer) < 0) {\n", "        if (data->pixels) {\n", "            SDL_free(data->pixels);\n", "        }\n", "        SDL_free(data);\n", "        return -1;\n", "    }\n", "    texture->driverdata = data;\n", "\n", "    if (renderdata->GL_ARB_texture_non_power_of_two_supported) {\n", "        texture_w = texture->w;\n", "        texture_h = texture->h;\n", "        data->texw = 1.0f;\n", "        data->texh = 1.0f;\n", "    } else if (renderdata->GL_ARB_texture_rectangle_supported) {\n", "        texture_w = texture->w;\n", "        texture_h = texture->h;\n", "        data->texw = (GLfloat) texture_w;\n", "        data->texh = (GLfloat) texture_h;\n", "    } else {\n", "        texture_w = power_of_2(texture->w);\n", "        texture_h = power_of_2(texture->h);\n", "        data->texw = (GLfloat) (texture->w) / texture_w;\n", "        data->texh = (GLfloat) texture->h / texture_h;\n", "    }\n", "\n", "    data->format = format;\n", "    data->formattype = type;\n", "    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n", "    renderdata->glEnable(textype);\n", "    renderdata->glBindTexture(textype, data->texture);\n", "    renderdata->glTexParameteri(textype, GL_TEXTURE_MIN_FILTER, scaleMode);\n", "    renderdata->glTexParameteri(textype, GL_TEXTURE_MAG_FILTER, scaleMode);\n", "    /* According to the spec, CLAMP_TO_EDGE is the default for TEXTURE_RECTANGLE\n", "       and setting it causes an INVALID_ENUM error in the latest NVidia drivers.\n", "    */\n", "    if (textype != GL_TEXTURE_RECTANGLE_ARB) {\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_S,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_T,\n", "                                    GL_CLAMP_TO_EDGE);\n", "    }\n", "#ifdef __MACOSX__\n", "#ifndef GL_TEXTURE_STORAGE_HINT_APPLE\n", "#define GL_TEXTURE_STORAGE_HINT_APPLE       0x85BC\n", "#endif\n", "#ifndef STORAGE_CACHED_APPLE\n", "#define STORAGE_CACHED_APPLE                0x85BE\n", "#endif\n", "#ifndef STORAGE_SHARED_APPLE\n", "#define STORAGE_SHARED_APPLE                0x85BF\n", "#endif\n", "    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_STORAGE_HINT_APPLE,\n", "                                    GL_STORAGE_SHARED_APPLE);\n", "    } else {\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_STORAGE_HINT_APPLE,\n", "                                    GL_STORAGE_CACHED_APPLE);\n", "    }\n", "    if (texture->access == SDL_TEXTUREACCESS_STREAMING\n", "        && texture->format == SDL_PIXELFORMAT_ARGB8888\n", "        && (texture->w % 8) == 0) {\n", "        renderdata->glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);\n", "        renderdata->glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n", "        renderdata->glPixelStorei(GL_UNPACK_ROW_LENGTH,\n", "                          (data->pitch / SDL_BYTESPERPIXEL(texture->format)));\n", "        renderdata->glTexImage2D(textype, 0, internalFormat, texture_w,\n", "                                 texture_h, 0, format, type, data->pixels);\n", "        renderdata->glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_FALSE);\n", "    }\n", "    else\n", "#endif\n", "    {\n", "        renderdata->glTexImage2D(textype, 0, internalFormat, texture_w,\n", "                                 texture_h, 0, format, type, NULL);\n", "    }\n", "    renderdata->glDisable(textype);\n", "    if (GL_CheckError(\"glTexImage2D()\", renderer) < 0) {\n", "        return -1;\n", "    }\n", "\n", "    if (texture->format == SDL_PIXELFORMAT_YV12 ||\n", "        texture->format == SDL_PIXELFORMAT_IYUV) {\n", "        data->yuv = SDL_TRUE;\n", "\n", "        renderdata->glGenTextures(1, &data->utexture);\n", "        renderdata->glGenTextures(1, &data->vtexture);\n", "        renderdata->glEnable(textype);\n", "\n", "        renderdata->glBindTexture(textype, data->utexture);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MIN_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MAG_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_S,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_T,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexImage2D(textype, 0, internalFormat, (texture_w+1)/2,\n", "                                 (texture_h+1)/2, 0, format, type, NULL);\n", "\n", "        renderdata->glBindTexture(textype, data->vtexture);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MIN_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MAG_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_S,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_T,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexImage2D(textype, 0, internalFormat, (texture_w+1)/2,\n", "                                 (texture_h+1)/2, 0, format, type, NULL);\n", "\n", "        renderdata->glDisable(textype);\n", "    }\n", "\n", "    if (texture->format == SDL_PIXELFORMAT_NV12 ||\n", "        texture->format == SDL_PIXELFORMAT_NV21) {\n", "        data->nv12 = SDL_TRUE;\n", "\n", "        renderdata->glGenTextures(1, &data->utexture);\n", "        renderdata->glEnable(textype);\n", "\n", "        renderdata->glBindTexture(textype, data->utexture);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MIN_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_MAG_FILTER,\n", "                                    scaleMode);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_S,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexParameteri(textype, GL_TEXTURE_WRAP_T,\n", "                                    GL_CLAMP_TO_EDGE);\n", "        renderdata->glTexImage2D(textype, 0, GL_LUMINANCE_ALPHA, (texture_w+1)/2,\n", "                                 (texture_h+1)/2, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, NULL);\n", "        renderdata->glDisable(textype);\n", "    }\n", "\n", "    return GL_CheckError(\"\", renderer);\n", "}\n"], "project": "libsdl2-doc", "file": "SDL_render_gl.pkl", "function": "GL_CreateTexture"}, {"comment_all": {"comment": "/* In general, we can't use the builtin 'dirname' function if available,\n   since it has different meanings in different environments.\n   In some environments the builtin 'dirname' modifies its argument.\n\n   Return the leading directories part of FILE, allocated with malloc.\n   Works properly even if there are trailing slashes (by effectively\n   ignoring them).  Return NULL on failure.\n\n   If lstat (FILE) would succeed, then { chdir (dir_name (FILE));\n   lstat (base_name (FILE)); } will access the same file.  Likewise,\n   if the sequence { chdir (dir_name (FILE));\n   rename (base_name (FILE), \"foo\"); } succeeds, you have renamed FILE\n   to \"foo\" in the same directory FILE was in.  */", "depth": 0, "reading_ease": 66.03, "reading_grade": 7.5, "line": 55}, "comment_text": "/* In general, we can't use the builtin 'dirname' function if available,\n   since it has different meanings in different environments.\n   In some environments the builtin 'dirname' modifies its argument.\n\n   Return the leading directories part of FILE, allocated with malloc.\n   Works properly even if there are trailing slashes (by effectively\n   ignoring them).  Return NULL on failure.\n\n   If lstat (FILE) would succeed, then { chdir (dir_name (FILE));\n   lstat (base_name (FILE)); } will access the same file.  Likewise,\n   if the sequence { chdir (dir_name (FILE));\n   rename (base_name (FILE), \"foo\"); } succeeds, you have renamed FILE\n   to \"foo\" in the same directory FILE was in.  */", "comment_tokens": ["In", "general", ",", "we", "ca", "n't", "use", "the", "builtin", "'dirname", "'", "function", "if", "available", ",", "since", "it", "has", "different", "meanings", "in", "different", "environments", ".", "In", "some", "environments", "the", "builtin", "'dirname", "'", "modifies", "its", "argument", ".", "Return", "the", "leading", "directories", "part", "of", "FILE", ",", "allocated", "with", "malloc", ".", "Works", "properly", "even", "if", "there", "are", "trailing", "slashes", "(", "by", "effectively", "ignoring", "them", ")", ".", "Return", "NULL", "on", "failure", ".", "If", "lstat", "(", "FILE", ")", "would", "succeed", ",", "then", "{", "chdir", "(", "dir_name", "(", "FILE", ")", ")", ";", "lstat", "(", "base_name", "(", "FILE", ")", ")", ";", "}", "will", "access", "the", "same", "file", ".", "Likewise", ",", "if", "the", "sequence", "{", "chdir", "(", "dir_name", "(", "FILE", ")", ")", ";", "rename", "(", "base_name", "(", "FILE", ")", ",", "``", "foo", "''", ")", ";", "}", "succeeds", ",", "you", "have", "renamed", "FILE", "to", "``", "foo", "''", "in", "the", "same", "directory", "FILE", "was", "in", "."], "ccode": ["\n", "\n", "/* In general, we can't use the builtin 'dirname' function if available,\n", "   since it has different meanings in different environments.\n", "   In some environments the builtin 'dirname' modifies its argument.\n", "\n", "   Return the leading directories part of FILE, allocated with malloc.\n", "   Works properly even if there are trailing slashes (by effectively\n", "   ignoring them).  Return NULL on failure.\n", "\n", "   If lstat (FILE) would succeed, then { chdir (dir_name (FILE));\n", "   lstat (base_name (FILE)); } will access the same file.  Likewise,\n", "   if the sequence { chdir (dir_name (FILE));\n", "   rename (base_name (FILE), \"foo\"); } succeeds, you have renamed FILE\n", "   to \"foo\" in the same directory FILE was in.  */\n", "\n", "char *\n", "mdir_name (char const *file)\n", "{\n", "  size_t length = dir_len (file);\n", "  bool append_dot = (length == 0\n", "                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n", "                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n", "                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n", "  char *dir = malloc (length + append_dot + 1);\n", "  if (!dir)\n", "    return NULL;\n", "  memcpy (dir, file, length);\n", "  if (append_dot)\n", "    dir[length++] = '.';\n", "  dir[length] = '\\0';\n", "  return dir;\n", "}\n"], "project": "grub-xen-host", "file": "dirname-lgpl.pkl", "function": "mdir_name"}, {"comment_all": {"comment": "//\t0=start of the line, waiting for the relativ tokens, or a number\n", "depth": 1, "reading_ease": 67.76, "reading_grade": 6.8, "line": 29}, "comment_text": "//\t0=start of the line, waiting for the relativ tokens, or a number\n//\t1=got relative\n//\t2=reading in number\n//\t3=end of line\n", "comment_tokens": ["0=start", "of", "the", "line", ",", "waiting", "for", "the", "relativ", "tokens", ",", "or", "a", "number", "1=got", "relative", "2=reading", "in", "number", "3=end", "of", "line"], "ccode": ["\n", "int\tparsemarkerfile(tMarkers* markers,char* filename)\n", "{\n", "\ttFptr\tf;\n", "\tchar c;\n", "\ttMarkers*\ttmp;\n", "\tint\tmarkersnum=0;\n", "\ttInt8\tstate=0;\t//\t0=start of the line, waiting for the relativ tokens, or a number\n", "\t\t\t//\t1=got relative\n", "\t\t\t//\t2=reading in number\n", "\t\t\t//\t3=end of line\n", "\ttBool\thadnumber=0;\t\n", "\tint n;\n", "\ttmp=initmarkers();\n", "\tf=fopen(filename,\"r\");\n", "\tif (!f)\treturn\tRETNOK;\n", "\twhile (!feof(f) && markersnum<10)\n", "\t{\n", "\t\tn=fread(&c,sizeof(char),1,f);\n", "\t\tif (c>='a' && c<='z') c=c-32;\t// make the letters uppercase\n", "\t\tif (n && !feof(f) && c!=' ' && c!=9)\t// ignore the spaces\n", "\t\t{\n", "\t\t\tif (c=='#')\tstate=3;\t// the rest of this line is just a comment\n", "\t\t\tif (c<32)\t//\tnewline\n", "\t\t\t{\n", "\t\t\t\tif (hadnumber)\t\n", "\t\t\t\t{\n", "\t\t\t\t\tmarkersnum++;\n", "\t\t\t\t\ttmp->relative[markersnum]='=';\n", "\t\t\t\t\ttmp->cursorpos[markersnum]=0;\n", "\t\t\t\t}\n", "\t\t\t\thadnumber=0;\n", "\t\t\t\tstate=0;\n", "\t\t\t}\n", "\t\t\tif (state==1) state=2;\t// the last character was the relative, now for the number\n", "\t\t\tif (state==0 && (c=='=' || c=='+' || c=='-'))\t\n", "\t\t\t{\n", "\t\t\t\ttmp->relative[markersnum]=c;\n", "\t\t\t\tstate=1;\n", "\t\t\t}\n", "\t\t\tif (state==0 && ((c>='A' && c<='F') || (c>='0' && c<='9'))) state=2;\t// the number starts right here\n", "\t\t\tif (state==2)\n", "\t\t\t{\n", "\t\t\t\ttmp->cursorpos[markersnum]<<=4;\n", "\t\t\t\thadnumber=1;\n", "\t\t\t\tif (c>='0' && c<='9') tmp->cursorpos[markersnum]+=(c-'0');\n", "\t\t\t\telse if (c>='A' && c<='F') tmp->cursorpos[markersnum]+=(c-'A'+10);\n", "\t\t\t\telse return RETNOK;\t// illegal value\n", "\t\t\t}\n", "\t\t}\t\n", "\t}\n", "\tfclose(f);\n", "\tmemcpy(markers,tmp,sizeof(tMarkers));\n", "\tfree(tmp);\n", "\treturn\tRETOK;\n", "}\n"], "project": "dhex", "file": "markers.pkl", "function": "parsemarkerfile"}, {"comment_all": {"comment": "/*\n * Catalan numbers: catalan(n) = comb(2*n, n)/(n+1)\n * To be called only with integer q\n */", "depth": 0, "reading_ease": 59.3, "reading_grade": 8.0, "line": 1143}, "comment_text": "/*\n * Catalan numbers: catalan(n) = comb(2*n, n)/(n+1)\n * To be called only with integer q\n */", "comment_tokens": ["Catalan", "numbers", ":", "catalan", "(", "n", ")", "=", "comb", "(", "2n", ",", "n", ")", "(", "n+1", ")", "To", "be", "called", "only", "with", "integer", "q"], "ccode": ["\n", "\n", "/*\n", " * Catalan numbers: catalan(n) = comb(2*n, n)/(n+1)\n", " * To be called only with integer q\n", " */\n", "NUMBER *\n", "qcatalan(NUMBER *q)\n", "{\n", "\tNUMBER *A, *B;\n", "\tNUMBER *res;\n", "\n", "\tif (qisneg(q))\n", "\t\treturn qlink(&_qzero_);\n", "\tA = qscale(q, 1);\n", "\tB = qcomb(A, q);\n", "\tif (B == NULL)\n", "\t\treturn NULL;\n", "\tqfree(A);\n", "\tA = qinc(q);\n", "\tres = qqdiv(B, A);\n", "\tqfree(A);\n", "\tqfree(B);\n", "\treturn res;\n", "}\n"], "project": "apcalc-common", "file": "qfunc.pkl", "function": "qcatalan"}, {"comment_all": {"comment": "/* Get pid */", "depth": 3, "reading_ease": 120.21, "reading_grade": -3.1, "line": 190}, "comment_text": "/* Decode I field */\n/* Get pid */\n", "comment_tokens": ["Decode", "I", "field", "Get", "pid"], "ccode": ["/* AX25 header tracing\n", " * Copyright 1991 Phil Karn, KA9Q\n", " */\n", "#include <stdio.h>\n", "#include <ctype.h>\n", "#include <string.h>\n", "#include \"listen.h\"\n", "\n", "#define\tLAPB_UNKNOWN\t0\n", "#define\tLAPB_COMMAND\t1\n", "#define\tLAPB_RESPONSE\t2\n", "\n", "#define\tSEG_FIRST\t0x80\n", "#define\tSEG_REM\t\t0x7F\n", "\n", "#define\tPID_SEGMENT\t0x08\n", "#define\tPID_ARP\t\t0xCD\n", "#define\tPID_NETROM\t0xCF\n", "#define\tPID_IP\t\t0xCC\n", "#define\tPID_X25\t\t0x01\n", "#define\tPID_TEXNET\t0xC3\n", "#define\tPID_FLEXNET\t0xCE\n", "#define\tPID_OPENTRAC\t0x77\n", "#define\tPID_NO_L3\t0xF0\n", "\n", "#define\tI\t\t0x00\n", "#define\tS\t\t0x01\n", "#define\tRR\t\t0x01\n", "#define\tRNR\t\t0x05\n", "#define\tREJ\t\t0x09\n", "#define\tU\t\t0x03\n", "#define\tSABM\t\t0x2F\n", "#define\tSABME\t\t0x6F\n", "#define\tDISC\t\t0x43\n", "#define\tDM\t\t0x0F\n", "#define\tUA\t\t0x63\n", "#define\tFRMR\t\t0x87\n", "#define\tUI\t\t0x03\n", "#define\tPF\t\t0x10\n", "#define\tEPF\t\t0x01\n", "\n", "#define\tMMASK\t\t7\n", "\n", "#define\tHDLCAEB\t\t0x01\n", "#define\tSSID\t\t0x1E\n", "#define\tREPEATED\t0x80\n", "#define\tC\t\t0x80\n", "#define\tSSSID_SPARE\t0x40\n", "#define\tESSID_SPARE\t0x20\n", "\n", "#define\tALEN\t\t6\n", "#define\tAXLEN\t\t7\n", "\n", "#define\tW\t\t1\n", "#define\tX\t\t2\n", "#define\tY\t\t4\n", "#define\tZ\t\t8\n", "\n", "static int ftype(unsigned char *, int *, int *, int *, int *, int);\n", "static char *decode_type(int);\n", "\n", "#define NDAMA_STRING \"\"\n", "#define DAMA_STRING \" [DAMA]\"\n", "\n", "\n", "/* FlexNet header compression display by Thomas Sailer t.sailer@alumni.ethz.ch */\n", "\n", "/* Dump an AX.25 packet header */\n", "void ax25_dump(unsigned char *data, int length, int hexdump)\n", "{\n", "\tchar tmp[15];\n", "\tint ctlen, nr, ns, pf, pid, seg, type, end, cmdrsp, extseq;\n", "\tchar *dama;\n", "\n", "\t/* check for FlexNet compressed header first; FlexNet header compressed packets are at least 8 bytes long */\n", "\tif (length < 8) {\n", "\t\t/* Something wrong with the header */\n", "\t\tlprintf(T_ERROR, \"AX25: bad header!\\n\");\n", "\t\treturn;\n", "\t}\n", "\tif (data[1] & HDLCAEB) {\n", "\t\t/* this is a FlexNet compressed header */\n", "\t\tlprintf(T_PROTOCOL, \" \");\n", "\t\ttmp[6] = tmp[7] = extseq = 0;\n", "\t\ttmp[0] = ' ' + (data[2] >> 2);\n", "\t\ttmp[1] = ' ' + ((data[2] << 4) & 0x30) + (data[3] >> 4);\n", "\t\ttmp[2] = ' ' + ((data[3] << 2) & 0x3c) + (data[4] >> 6);\n", "\t\ttmp[3] = ' ' + (data[4] & 0x3f);\n", "\t\ttmp[4] = ' ' + (data[5] >> 2);\n", "\t\ttmp[5] = ' ' + ((data[5] << 4) & 0x30) + (data[6] >> 4);\n", "\t\tif (data[6] & 0xf)\n", "\t\t\tsprintf(tmp + 7, \"-%d\", data[6] & 0xf);\n", "\t\tlprintf(T_ADDR, \"%d->%s%s\",\n", "\t\t\t(data[0] << 6) | ((data[1] >> 2) & 0x3f),\n", "\t\t\tstrtok(tmp, \" \"), tmp + 7);\n", "\t\tcmdrsp = (data[1] & 2) ? LAPB_COMMAND : LAPB_RESPONSE;\n", "\t\tdama = NDAMA_STRING;\n", "\t\tdata += 7;\n", "\t\tlength -= 7;\n", "\t} else {\n", "\t\t/* Extract the address header */\n", "\t\tif (length < (AXLEN + AXLEN + 1)) {\n", "\t\t\t/* Something wrong with the header */\n", "\t\t\tlprintf(T_ERROR, \"AX25: bad header!\\n\");\n", "\t\t\treturn;\n", "\t\t}\n", "\n", "\t\tif ((data[AXLEN + ALEN] & SSSID_SPARE) == SSSID_SPARE) {\n", "\t\t\textseq = 0;\n", "/*                      lprintf(T_PROTOCOL, \" \");  */\n", "\t\t} else {\n", "\t\t\textseq = 1;\n", "\t\t\tlprintf(T_PROTOCOL, \"EAX25: \");\n", "\t\t}\n", "\n", "\t\tif ((data[AXLEN + ALEN] & ESSID_SPARE) == ESSID_SPARE)\n", "\t\t\tdama = NDAMA_STRING;\n", "\t\telse\n", "\t\t\tdama = DAMA_STRING;\n", "\n", "\t\tlprintf(T_AXHDR, \"fm \");\n", "\t\tlprintf(T_ADDR, \"%s\", pax25(tmp, data + AXLEN));\n", "\t\tlprintf(T_AXHDR, \" to \");\n", "\t\tlprintf(T_ADDR, \"%s\", pax25(tmp, data));\n", "\n", "\t\tcmdrsp = LAPB_UNKNOWN;\n", "\n", "\t\tif ((data[ALEN] & C) && !(data[AXLEN + ALEN] & C))\n", "\t\t\tcmdrsp = LAPB_COMMAND;\n", "\n", "\t\tif ((data[AXLEN + ALEN] & C) && !(data[ALEN] & C))\n", "\t\t\tcmdrsp = LAPB_RESPONSE;\n", "\n", "\t\tend = (data[AXLEN + ALEN] & HDLCAEB);\n", "\n", "\t\tdata += (AXLEN + AXLEN);\n", "\t\tlength -= (AXLEN + AXLEN);\n", "\n", "\t\tif (!end) {\n", "\t\t\tlprintf(T_AXHDR, \" via\");\n", "\n", "\t\t\twhile (!end) {\n", "\t\t\t\t/* Print digi string */\n", "\t\t\t\tlprintf(T_ADDR, \" %s%s\", pax25(tmp, data),\n", "\t\t\t\t\t(data[ALEN] & REPEATED) ? \"*\" :\n", "\t\t\t\t\t\"\");\n", "\n", "\t\t\t\tend = (data[ALEN] & HDLCAEB);\n", "\n", "\t\t\t\tdata += AXLEN;\n", "\t\t\t\tlength -= AXLEN;\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\tif (length == 0)\n", "\t\treturn;\n", "\n", "\tctlen = ftype(data, &type, &ns, &nr, &pf, extseq);\n", "\n", "\tdata += ctlen;\n", "\tlength -= ctlen;\n", "\n", "\tlprintf(T_AXHDR, \" ctl %s\", decode_type(type));\n", "\n", "\tif ((type & 0x3) != U)\t/* I or S frame? */\n", "\t\tlprintf(T_AXHDR, \"%d\", nr);\n", "\n", "\tif (type == I)\n", "\t\tlprintf(T_AXHDR, \"%d\", ns);\n", "\n", "\tswitch (cmdrsp) {\n", "\tcase LAPB_COMMAND:\n", "\t\tif (pf)\n", "\t\t\tlprintf(T_AXHDR, \"+\");\n", "\t\telse\n", "\t\t\tlprintf(T_AXHDR, \"^\");\n", "\t\tbreak;\n", "\tcase LAPB_RESPONSE:\n", "\t\tif (pf)\n", "\t\t\tlprintf(T_AXHDR, \"-\");\n", "\t\telse\n", "\t\t\tlprintf(T_AXHDR, \"v\");\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tbreak;\n", "\t}\n", "\n", "\tif (type == I || type == UI) {\n", "\t\t/* Decode I field */\n", "\t\tif (length > 0) {\t/* Get pid */\n", "\t\t\tpid = *data++;\n", "\t\t\tlength--;\n", "\n", "\t\t\tlprintf(T_AXHDR, \" pid=%X\", pid);\n", "\n", "\t\t\tswitch (pid) {\n", "\t\t\tcase PID_SEGMENT:\n", "\t\t\t\tlprintf(T_AXHDR, \"(segment)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_ARP:\n", "\t\t\t\tlprintf(T_AXHDR, \"(ARP)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_NETROM:\n", "\t\t\t\tlprintf(T_AXHDR, \"(NET/ROM)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_IP:\n", "\t\t\t\tlprintf(T_AXHDR, \"(IP)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_X25:\n", "\t\t\t\tlprintf(T_AXHDR, \"(X.25)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_TEXNET:\n", "\t\t\t\tlprintf(T_AXHDR, \"(TEXNET)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_FLEXNET:\n", "\t\t\t\tlprintf(T_AXHDR, \"(FLEXNET)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_OPENTRAC:\n", "\t\t\t\tlprintf(T_AXHDR, \"(OPENTRAC)\");\n", "\t\t\t\tbreak;\n", "\t\t\tcase PID_NO_L3:\n", "\t\t\t\tlprintf(T_AXHDR, \"(Text)\");\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tlprintf(T_AXHDR, \"%s len %d \", dama, length);\n", "\n", "\t\t\tif (timestamp)\n", "\t\t\t\tdisplay_timestamp();\n", "\n", "\t\t\tif (pid == PID_SEGMENT) {\n", "\t\t\t\tseg = *data++;\n", "\t\t\t\tlength--;\n", "\t\t\t\tlprintf(T_AXHDR, \"%s remain %u\",\n", "\t\t\t\t\tseg & SEG_FIRST ? \" First seg;\" :\n", "\t\t\t\t\t\"\", seg & SEG_REM);\n", "\n", "\t\t\t\tif (seg & SEG_FIRST) {\n", "\t\t\t\t\tpid = *data++;\n", "\t\t\t\t\tlength--;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tlprintf(T_AXHDR, \"\\n\");\n", "\n", "\t\t\tswitch (pid) {\n", "\t\t\t\tcase PID_SEGMENT:\n", "\t\t\t\t\tdata_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_ARP:\n", "\t\t\t\t\tarp_dump(data, length);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_NETROM:\n", "\t\t\t\t\tnetrom_dump(data, length, hexdump, type);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_IP:\n", "\t\t\t\t\tip_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_X25:\n", "\t\t\t\t\trose_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_TEXNET:\n", "\t\t\t\t\tdata_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_FLEXNET:\n", "\t\t\t\t\tflexnet_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_OPENTRAC:\n", "\t\t\t\t\topentrac_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase PID_NO_L3:\n", "\t\t\t\t\tdata_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tdefault:\n", "\t\t\t\t\tdata_dump(data, length, hexdump);\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t} else if (type == FRMR && length >= 3) {\n", "\t\t/* FIX ME XXX\n", "\t\t   lprintf(T_AXHDR, \": %s\", decode_type(ftype(data[0])));\n", "\t\t */\n", "\t\tlprintf(T_AXHDR, \": %02X\", data[0]);\n", "\t\tlprintf(T_AXHDR, \" Vr = %d Vs = %d\",\n", "\t\t\t(data[1] >> 5) & MMASK, (data[1] >> 1) & MMASK);\n", "\t\tif (data[2] & W)\n", "\t\t\tlprintf(T_ERROR, \" Invalid control field\");\n", "\t\tif (data[2] & X)\n", "\t\t\tlprintf(T_ERROR, \" Illegal I-field\");\n", "\t\tif (data[2] & Y)\n", "\t\t\tlprintf(T_ERROR, \" Too-long I-field\");\n", "\t\tif (data[2] & Z)\n", "\t\t\tlprintf(T_ERROR, \" Invalid seq number\");\n", "\t\tlprintf(T_AXHDR, \"%s \", dama);\n", "\n", "\t\tif (timestamp)\n", "\t\t\tdisplay_timestamp();\n", "\t\tlprintf(T_AXHDR, \"\\n\");\n", "\t} else if ((type == SABM || type == UA) && length >= 2) {\n", "\t\t/* FlexNet transmits the QSO \"handle\" for header\n", "\t\t * compression in SABM and UA frame data fields \n", "\t\t */\n", "\t\tlprintf(T_AXHDR, \" [%d]%s \", (data[0] << 8) | data[1],\n", "\t\t\tdama);\n", "\t\tif (timestamp)\n", "\t\t\tdisplay_timestamp();\n", "\t\tlprintf(T_AXHDR, \"\\n\");\n", "\t} else {\n", "\t\tlprintf(T_AXHDR, \"%s \", dama);\n", "\t\tif (timestamp)\n", "\t\t\tdisplay_timestamp();\n", "\t\tlprintf(T_AXHDR, \"\\n\");\n", "\t}\n", "}\n"], "project": "ax25-apps", "file": "ax25dump.pkl", "function": "ax25_dump"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  Write an Sub Include structure out. (An include structure that is included from another file.)\n\n  Include inc The Include structure to output.\n\n  int depth The depth of the include hierarchy.\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 72.32, "reading_grade": 5.0, "line": 348}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  Write an Sub Include structure out. (An include structure that is included from another file.)\n\n  Include inc The Include structure to output.\n\n  int depth The depth of the include hierarchy.\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "Write", "an", "Sub", "Include", "structure", "out", ".", "(", "An", "include", "structure", "that", "is", "included", "from", "another", "file", ".", ")", "Include", "inc", "The", "Include", "structure", "to", "output", ".", "int", "depth", "The", "depth", "of", "the", "include", "hierarchy", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Write an Sub Include structure out. (An include structure that is included from another file.)\n", "\n", "  Include inc The Include structure to output.\n", "\n", "  int depth The depth of the include hierarchy.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "static void WriteSGMLSubInclude(Include inc,int depth)\n", "{\n", " fprintf(of,\"<itemize>\\n\");\n", "\n", " while(inc)\n", "   {\n", "    if(inc->scope==LOCAL)\n", "       fprintf(of,\"<item><tt>#include &quot;%s&quot;</tt>\\n\",sgml(inc->name,0));\n", "    else\n", "       fprintf(of,\"<item><tt>#include &lt;%s&gt;</tt>\\n\",sgml(inc->name,0));\n", "\n", "    if(inc->includes)\n", "       WriteSGMLSubInclude(inc->includes,depth+1);\n", "\n", "    inc=inc->next;\n", "   }\n", "\n", " fprintf(of,\"</itemize>\\n\");\n", "}\n"], "project": "cxref-doc", "file": "sgml.pkl", "function": "WriteSGMLSubInclude"}, {"comment_all": {"comment": "/* sanity check */", "depth": 1, "reading_ease": 35.61, "reading_grade": 8.8, "line": 1968}, "comment_text": "/* sanity check */\n/* prepend the 0x02 (from docs) (or actually 0x04 from implementation\n\t * of openssl) for uncompressed data */\n", "comment_tokens": ["sanity", "check", "prepend", "the", "0x02", "(", "from", "docs", ")", "(", "or", "actually", "0x04", "from", "implementation", "of", "openssl", ")", "for", "uncompressed", "data"], "ccode": ["#endif /* USE_ED448 */\n", "\n", "#ifdef USE_ECDSA\n", "EVP_PKEY*\n", "ldns_ecdsa2pkey_raw(const unsigned char* key, size_t keylen, uint8_t algo)\n", "{\n", "\tunsigned char buf[256+2]; /* sufficient for 2*384/8+1 */\n", "        const unsigned char* pp = buf;\n", "        EVP_PKEY *evp_key;\n", "        EC_KEY *ec;\n", "\t/* check length, which uncompressed must be 2 bignums */\n", "        if(algo == LDNS_ECDSAP256SHA256) {\n", "\t\tif(keylen != 2*256/8) return NULL;\n", "                ec = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n", "        } else if(algo == LDNS_ECDSAP384SHA384) {\n", "\t\tif(keylen != 2*384/8) return NULL;\n", "                ec = EC_KEY_new_by_curve_name(NID_secp384r1);\n", "        } else    ec = NULL;\n", "        if(!ec) return NULL;\n", "\tif(keylen+1 > sizeof(buf))\n", "\t\treturn NULL; /* sanity check */\n", "\t/* prepend the 0x02 (from docs) (or actually 0x04 from implementation\n", "\t * of openssl) for uncompressed data */\n", "\tbuf[0] = POINT_CONVERSION_UNCOMPRESSED;\n", "\tmemmove(buf+1, key, keylen);\n", "        if(!o2i_ECPublicKey(&ec, &pp, (int)keylen+1)) {\n", "                EC_KEY_free(ec);\n", "                return NULL;\n", "        }\n", "        evp_key = EVP_PKEY_new();\n", "        if(!evp_key) {\n", "                EC_KEY_free(ec);\n", "                return NULL;\n", "        }\n", "        if (!EVP_PKEY_assign_EC_KEY(evp_key, ec)) {\n", "\t\tEVP_PKEY_free(evp_key);\n", "\t\tEC_KEY_free(ec);\n", "\t\treturn NULL;\n", "\t}\n", "        return evp_key;\n", "}\n"], "project": "python-ldns", "file": "dnssec_verify.pkl", "function": "ldns_ecdsa2pkey_raw"}, {"comment_all": {"comment": "// Returns a char* to \"/home/username/.abe/\" or \".\\\"\n// It does not mean that that directory exists.\n", "depth": 0, "reading_ease": 64.37, "reading_grade": 6.0, "line": 3}, "comment_text": "// Returns a char* to \"/home/username/.abe/\" or \".\\\"\n// It does not mean that that directory exists.\n", "comment_tokens": ["Returns", "a", "char", "to", "``", "homeusername.abe", "''", "or", "``", ".\\", "''", "It", "does", "not", "mean", "that", "that", "directory", "exists", "."], "ccode": ["#include \"Directories.h\"\n", "\n", "// Returns a char* to \"/home/username/.abe/\" or \".\\\"\n", "// It does not mean that that directory exists.\n", "char *\n", "getHomeUserAbe()\n", "{\n", "\n", "  static char path[PATH_SIZE];\n", "#ifndef WIN32\n", "  struct passwd *pwent;\n", "\n", "  pwent = getpwuid(getuid());\n", "  if(NULL == pwent) {\n", "    perror(\"getpwuid\");\n", "    exit(EXIT_FAILURE);\n", "  }\n", "\n", "  sprintf(path, \"%s%s\", pwent->pw_dir, PATH_SEP \".abe\" PATH_SEP);\n", "#else\n", "  sprintf(path, xstr(BASE_DIR) PATH_SEP);\n", "#endif\n", "\n", "  return path;\n", "}\n"], "project": "abe-data", "file": "Directories.pkl", "function": "getHomeUserAbe"}, {"comment_all": {"comment": "/**\n *\tradix_tree_tag_clear - clear a tag on a radix tree node\n *\t@root:\t\tradix tree root\n *\t@index:\t\tindex key\n *\t@tag: \t\ttag index\n *\n *\tClear the search tag (which must be < RADIX_TREE_MAX_TAGS)\n *\tcorresponding to @index in the radix tree.  If\n *\tthis causes the leaf node to have no tags set then clear the tag in the\n *\tnext-to-leaf node, etc.\n *\n *\tReturns the address of the tagged item on success, else NULL.  ie:\n *\thas the same return value and semantics as radix_tree_lookup().\n */", "depth": 0, "reading_ease": 77.77, "reading_grade": 7.1, "line": 402}, "comment_text": "/**\n *\tradix_tree_tag_clear - clear a tag on a radix tree node\n *\t@root:\t\tradix tree root\n *\t@index:\t\tindex key\n *\t@tag: \t\ttag index\n *\n *\tClear the search tag (which must be < RADIX_TREE_MAX_TAGS)\n *\tcorresponding to @index in the radix tree.  If\n *\tthis causes the leaf node to have no tags set then clear the tag in the\n *\tnext-to-leaf node, etc.\n *\n *\tReturns the address of the tagged item on success, else NULL.  ie:\n *\thas the same return value and semantics as radix_tree_lookup().\n */", "comment_tokens": ["radix_tree_tag_clear", "-", "clear", "a", "tag", "on", "a", "radix", "tree", "node", "@", "root", ":", "radix", "tree", "root", "@", "index", ":", "index", "key", "@", "tag", ":", "tag", "index", "Clear", "the", "search", "tag", "(", "which", "must", "be", "<", "RADIX_TREE_MAX_TAGS", ")", "corresponding", "to", "@", "index", "in", "the", "radix", "tree", ".", "If", "this", "causes", "the", "leaf", "node", "to", "have", "no", "tags", "set", "then", "clear", "the", "tag", "in", "the", "next-to-leaf", "node", ",", "etc", ".", "Returns", "the", "address", "of", "the", "tagged", "item", "on", "success", ",", "else", "NULL", ".", "ie", ":", "has", "the", "same", "return", "value", "and", "semantics", "as", "radix_tree_lookup", "(", ")", "."], "ccode": ["\n", "/**\n", " *\tradix_tree_tag_clear - clear a tag on a radix tree node\n", " *\t@root:\t\tradix tree root\n", " *\t@index:\t\tindex key\n", " *\t@tag: \t\ttag index\n", " *\n", " *\tClear the search tag (which must be < RADIX_TREE_MAX_TAGS)\n", " *\tcorresponding to @index in the radix tree.  If\n", " *\tthis causes the leaf node to have no tags set then clear the tag in the\n", " *\tnext-to-leaf node, etc.\n", " *\n", " *\tReturns the address of the tagged item on success, else NULL.  ie:\n", " *\thas the same return value and semantics as radix_tree_lookup().\n", " */\n", "void *radix_tree_tag_clear(struct radix_tree_root *root,\n", "\t\t\tunsigned long index, unsigned int tag)\n", "{\n", "\tstruct radix_tree_path path[RADIX_TREE_MAX_PATH], *pathp = path;\n", "\tstruct radix_tree_node *slot = NULL;\n", "\tunsigned int height, shift;\n", "\n", "\theight = root->height;\n", "\tif (index > radix_tree_maxindex(height))\n", "\t\tgoto out;\n", "\n", "\tshift = (height - 1) * RADIX_TREE_MAP_SHIFT;\n", "\tpathp->node = NULL;\n", "\tslot = root->rnode;\n", "\n", "\twhile (height > 0) {\n", "\t\tint offset;\n", "\n", "\t\tif (slot == NULL)\n", "\t\t\tgoto out;\n", "\n", "\t\toffset = (index >> shift) & RADIX_TREE_MAP_MASK;\n", "\t\tpathp[1].offset = offset;\n", "\t\tpathp[1].node = slot;\n", "\t\tslot = slot->slots[offset];\n", "\t\tpathp++;\n", "\t\tshift -= RADIX_TREE_MAP_SHIFT;\n", "\t\theight--;\n", "\t}\n", "\n", "\tif (slot == NULL)\n", "\t\tgoto out;\n", "\n", "\twhile (pathp->node) {\n", "\t\tif (!tag_get(pathp->node, tag, pathp->offset))\n", "\t\t\tgoto out;\n", "\t\ttag_clear(pathp->node, tag, pathp->offset);\n", "\t\tif (any_tag_set(pathp->node, tag))\n", "\t\t\tgoto out;\n", "\t\tpathp--;\n", "\t}\n", "\n", "\t/* clear the root's tag bit */\n", "\tif (root_tag_get(root, tag))\n", "\t\troot_tag_clear(root, tag);\n", "\n", "out:\n", "\treturn slot;\n", "}\n"], "project": "btrfs-compsize", "file": "radix-tree.pkl", "function": "radix_tree_tag_clear"}, {"comment_all": {"comment": "/*\n * Copyright (c) 2005-2018 Alon Bar-Lev <alon.barlev@gmail.com>\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, or the BSD license.\n *\n * GNU General Public License (GPL) Version 2\n * ===========================================\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program (see the file COPYING.GPL included with this\n * distribution); if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * BSD License\n * ============\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     o Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     o Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     o Neither the name of the Alon Bar-Lev nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */", "depth": 0, "reading_ease": 35.71, "reading_grade": 15.0, "line": 0}, "comment_text": "/*\n * Copyright (c) 2005-2018 Alon Bar-Lev <alon.barlev@gmail.com>\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, or the BSD license.\n *\n * GNU General Public License (GPL) Version 2\n * ===========================================\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program (see the file COPYING.GPL included with this\n * distribution); if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * BSD License\n * ============\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     o Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     o Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     o Neither the name of the Alon Bar-Lev nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */", "comment_tokens": ["Copyright", "(", "c", ")", "2005-2018", "Alon", "Bar-Lev", "<", "alon.barlev", "@", "gmail.com", ">", "This", "software", "is", "available", "to", "you", "under", "a", "choice", "of", "one", "of", "two", "licenses", ".", "You", "may", "choose", "to", "be", "licensed", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "(", "GPL", ")", "Version", "2", ",", "or", "the", "BSD", "license", ".", "GNU", "General", "Public", "License", "(", "GPL", ")", "Version", "2", "===========================================", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "version", "2", "as", "published", "by", "the", "Free", "Software", "Foundation", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", "(", "see", "the", "file", "COPYING.GPL", "included", "with", "this", "distribution", ")", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA", ".", "BSD", "License", "============", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "o", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "o", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "o", "Neither", "the", "name", "of", "the", "Alon", "Bar-Lev", "nor", "the", "names", "of", "its", "contributors", "may", "be", "used", "to", "endorse", "or", "promote", "products", "derived", "from", "this", "software", "without", "specific", "prior", "written", "permission", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "COPYRIGHT", "HOLDERS", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "COPYRIGHT", "OWNER", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", "."], "ccode": ["/*\n", " * Copyright (c) 2005-2018 Alon Bar-Lev <alon.barlev@gmail.com>\n", " *\n", " * This software is available to you under a choice of one of two\n", " * licenses.  You may choose to be licensed under the terms of the GNU\n", " * General Public License (GPL) Version 2, or the BSD license.\n", " *\n", " * GNU General Public License (GPL) Version 2\n", " * ===========================================\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License version 2\n", " * as published by the Free Software Foundation.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program (see the file COPYING.GPL included with this\n", " * distribution); if not, write to the Free Software Foundation, Inc.,\n", " * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " *\n", " * BSD License\n", " * ============\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions are met:\n", " *\n", " *     o Redistributions of source code must retain the above copyright notice,\n", " *       this list of conditions and the following disclaimer.\n", " *     o Redistributions in binary form must reproduce the above copyright\n", " *       notice, this list of conditions and the following disclaimer in the\n", " *       documentation and/or other materials provided with the distribution.\n", " *     o Neither the name of the Alon Bar-Lev nor the names of its\n", " *       contributors may be used to endorse or promote products derived from\n", " *       this software without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n", " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n", " * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n", " * POSSIBILITY OF SUCH DAMAGE.\n", " */\n", "\n", "#include \"common.h\"\n", "\n", "#include \"_pkcs11h-crypto.h\"\n", "\n", "#if defined(ENABLE_PKCS11H_ENGINE_MBEDTLS)\n", "#ifdef HAVE_MBEDTLS_X509_CRT_H\n", "#include <mbedtls/compat-1.3.h>\n", "#include <mbedtls/x509_crt.h>\n", "#else\n", "#include <polarssl/x509_crt.h>\n", "#endif\n", "\n", "static\n", "int\n", "__pkcs11h_crypto_mbedtls_initialize (\n", "\tIN void * const global_data\n", ") {\n", "\t(void)global_data;\n", "\n", "\treturn TRUE;\n", "}\n"], "project": "libpkcs11-helper1-dev", "file": "_pkcs11h-crypto-mbedtls.pkl", "function": "__pkcs11h_crypto_mbedtls_initialize"}, {"comment_all": {"comment": "/* The next ward is looked for. */", "depth": 4, "reading_ease": 116.15, "reading_grade": -1.5, "line": 277}, "comment_text": "/* The next ward is looked for. */", "comment_tokens": ["The", "next", "ward", "is", "looked", "for", "."], "ccode": ["\n", "void add_jisyo(filename)\n", "     char *filename;\n", "{\n", "    FILE *jisyo_fp;\n", "    unsigned char buffer[BUFLEN];\n", "    unsigned char *p;\n", "    unsigned char *yomi, *kanji;\n", "    int tail;\n", "    extern char *ialloc();\n", "\n", "    if ((jisyo_fp = fopen(filename, \"rb\")) == NULL) {\n", "\tperror(filename);\n", "\texit(0);\n", "    }\n", "    while(fgets((char *)buffer, BUFLEN, jisyo_fp)) {\n", "\t/* If there is the one except for the KANA at the head, to the next */\n", "\tif ((buffer[0] < 0xa0) && (buffer[0] != '\\033')) continue;\n", "\n", "\t/* A line is changed into ujis. */\n", "\tjis2ujis_jisyo(buffer);\n", "\n", "\tyomi = buffer;\n", "\t/* The next ward is looked for. */\n", "\tfor (p = buffer; (*p != ' ') && (*p != '\\011') && (*p != ','); ++ p) {\n", "\t    if ((*p == '\\0') || (*p == '\\n')) goto next_line;\n", "\t}\n", "\n", "\tif (isalpha(p[-1])) { /* An OKURIGANA is given if the last character is an alphabet. */\n", "\t    tail = p[-1];\n", "\t    p[-1] = '\\0';\n", "\t} else {\n", "\t    tail = 0;\n", "\t    p[0] = '\\0';\n", "\t}\n", "\n", "\t/* The next ward is looked for. */\n", "\tfor (++ p; (*p == ' ') || (*p == '\\011') || (*p == ','); ++ p) {\n", "\t    if ((*p == '\\0') || (*p == '\\n')) goto next_line;\n", "\t}\n", "\n", "\tif (*p == '/') { /* It seems to be the dictionary of SKK. */\n", "\t    for (;;) {\n", "\t\tkanji = p+1;\n", "\t\t/* The next ward is looked for. */\n", "\t\tfor (++ p; (*p != '/'); ++ p) {\n", "\t\t    if ((*p == '\\0')||(*p == '\\n')||(*p == '[')) goto next_line;\n", "\t\t}\n", "\t\t*p = '\\0';\n", "\t\tadd_item(yomi, kanji, tail);\n", "\t    }\n", "\t} else { /* It seems to be a standard dictionary. */\n", "\t    kanji = p;\n", "\t    /* The next ward is looked for. */\n", "\t    for (++ p; \n", "\t\t (*p != ' ') && (*p != '\\n') && (*p != '\\011') &&\n", "\t\t (*p != '\\0') && (*p != ',')\n", "\t\t ; ++ p) {\n", "\t\t;\n", "\t    }\n", "\t    *p = '\\0';\n", "\t    add_item(yomi, kanji, tail);\n", "\t}\n", "      next_line:;\n", "    }\n", "    fclose(jisyo_fp);\n", "}\n"], "project": "kakasi-dic", "file": "dict.pkl", "function": "add_jisyo"}, {"comment_all": {"comment": "/** Get the current token.\n * \n */", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 4051}, "comment_text": "/** Get the current token.\n * \n */", "comment_tokens": ["Get", "the", "current", "token", "."], "ccode": ["\n", "/** Get the current token.\n", " * \n", " */\n", "\n", "char *yyget_text  (void)\n", "{\n", "        return yytext;\n", "}\n"], "project": "linux-buildinfo-5.8.0-50-generic", "file": "lexer.lex.pkl", "function": "yyget_text"}, {"comment_all": {"comment": "/**\n * @brief Thread-safe scan wrapper to ensure there's no processs contention over use of the socket.\n *\n * This is noticeably slower, and I had no issues running smaller scale tests with it off, but better than sorry until more testing can be done.\n *\n * TODO: make this configurable?\n */", "depth": 0, "reading_ease": 73.17, "reading_grade": 6.8, "line": 104}, "comment_text": "/**\n * @brief Thread-safe scan wrapper to ensure there's no processs contention over use of the socket.\n *\n * This is noticeably slower, and I had no issues running smaller scale tests with it off, but better than sorry until more testing can be done.\n *\n * TODO: make this configurable?\n */", "comment_tokens": ["@", "brief", "Thread-safe", "scan", "wrapper", "to", "ensure", "there", "'s", "no", "processs", "contention", "over", "use", "of", "the", "socket", ".", "This", "is", "noticeably", "slower", ",", "and", "I", "had", "no", "issues", "running", "smaller", "scale", "tests", "with", "it", "off", ",", "but", "better", "than", "sorry", "until", "more", "testing", "can", "be", "done", ".", "TODO", ":", "make", "this", "configurable", "?"], "ccode": ["\n", "/**\n", " * @brief Thread-safe scan wrapper to ensure there's no processs contention over use of the socket.\n", " *\n", " * This is noticeably slower, and I had no issues running smaller scale tests with it off, but better than sorry until more testing can be done.\n", " *\n", " * TODO: make this configurable?\n", " */\n", "static cl_error_t onas_scan_safe(struct onas_scan_event *event_data, const char *fname, STATBUF sb, int *infected, int *err, cl_error_t *ret_code)\n", "{\n", "\n", "    int ret = 0;\n", "    int fd  = -1;\n", "\n", "#if defined(HAVE_SYS_FANOTIFY_H)\n", "    uint8_t b_fanotify;\n", "\n", "    b_fanotify = event_data->bool_opts & ONAS_SCTH_B_FANOTIFY ? 1 : 0;\n", "\n", "    if (b_fanotify) {\n", "        fd = event_data->fmd->fd;\n", "    }\n", "#endif\n", "\n", "    pthread_mutex_lock(&onas_scan_lock);\n", "\n", "    ret = onas_client_scan(event_data->tcpaddr, event_data->portnum, event_data->scantype, event_data->maxstream,\n", "                           fname, fd, event_data->timeout, sb, infected, err, ret_code);\n", "\n", "    pthread_mutex_unlock(&onas_scan_lock);\n", "\n", "    return ret;\n", "}\n"], "project": "clamav-freshclam", "file": "thread.pkl", "function": "onas_scan_safe"}, {"comment_all": {"comment": "/* Save the root servers tab. */", "depth": 1, "reading_ease": 117.16, "reading_grade": -1.9, "line": 41}, "comment_text": "/* Save the root servers tab. */", "comment_tokens": ["Save", "the", "root", "servers", "tab", "."], "ccode": ["/* GADMIN-BIND - An easy to use GTK+ frontend for the ISC BIND DNS Server.\n", " * Copyright (C) 2008 - 2010 Magnus Loef <magnus-swe@telia.com> \n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 3 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", " * See the GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License along\n", " * with this program; if not, write to the Free Software Foundation, Inc.,\n", " * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n", " *\n", "*/\n", "\n", "\n", "\n", "#include \"../config.h\"\n", "#include <gtk/gtk.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <string.h>\n", "#include \"widgets.h\"\n", "#include \"gettext.h\"\n", "#include \"commands.h\"\n", "#include \"populate_root_servers_tab.h\"\n", "#include \"allocate.h\"\n", "\n", "extern char CHROOT_PATH_BUF[1024];\n", "\n", "extern int activated;\n", "\n", "\n", "\n", "void save_root_servers(struct w *widgets)\n", "{\n", "    /* Save the root servers tab. */\n", "    FILE *fp;\n", "    GtkTextBuffer *rs_textbuffer;\n", "    GtkTextIter start, end;\n", "    gchar *conf = NULL;\n", "    gchar *utf8 = NULL;\n", "    gchar *root_hints;\n", "\n", "    rs_textbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(widgets->rs_textview));\n", "    gtk_text_buffer_get_bounds(rs_textbuffer, &start, &end);\n", "\n", "    conf = gtk_text_iter_get_text(&start, &end);\n", "\n", "    root_hints = g_strdup_printf(\"%s/etc/root.hints\", CHROOT_PATH_BUF);\n", "\n", "    if((fp=fopen(root_hints, \"w+\"))==NULL)\n", "    {\n", "        if( conf!=NULL )\n", "    \t  g_free(conf);\n", "\n", "\tif( utf8!=NULL )\n", "          g_free(utf8);\n", "\n", "\tg_free(root_hints);\n", "\treturn;\n", "    }\n", "    fputs(conf, fp);\n", "    fclose(fp);\n", "\n", "    g_free(root_hints);\n", "\n", "    if( conf!=NULL )\n", "      g_free(conf);\n", "\n", "    if( utf8!=NULL )\n", "      g_free(utf8);\n", "\n", "    populate_root_servers_tab(widgets);\n", "}\n"], "project": "gadmin-bind-dbg", "file": "save_root_servers.pkl", "function": "save_root_servers"}, {"comment_all": {"comment": "/* Result should not be NULL */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 82}, "comment_text": "/* Result should not be NULL */", "comment_tokens": ["Result", "should", "not", "be", "NULL"], "ccode": ["\n", "int safe_iopf(void *result, const char *const fmt, ...) {\n", "  va_list ap;\n", "  int baseline = 0; /* indicates if the base value is present */\n", "\n", "  const char *c = NULL;\n", "  safe_type_t type = SAFE_IOP_TYPE_DEFAULT;\n", "  /* Result should not be NULL */\n", "  if (!result)\n", "    return 0;\n", "\n", "  va_start(ap, fmt);\n", "  if (fmt == NULL || fmt[0] == '\\0')\n", "    return 0;\n", "  for(c=fmt;(*c);c++) {\n", "    /* Read the type if specified */\n", "    if (!_safe_op_read_type(&type, &c)) {\n", "      return 0;\n", "    }\n", "\n", "    /* Process the the operations */\n", "    switch(*c) { /* operation */\n", "      case '+': /* add */\n", "        _SAFE_IOP_OP_CASE(safe_uadd, safe_sadd);\n", "        break;\n", "      case '-': /* sub */\n", "        _SAFE_IOP_OP_CASE(safe_usub, safe_ssub);\n", "        break;\n", "      case '*': /* mul */\n", "        _SAFE_IOP_OP_CASE(safe_umul, safe_smul);\n", "        break;\n", "      case '/': /* div */\n", "        _SAFE_IOP_OP_CASE(safe_udiv, safe_sdiv);\n", "        break;\n", "      case '%': /* mod */\n", "        _SAFE_IOP_OP_CASE(safe_umod, safe_smod);\n", "        break;\n", "      default:\n", "       /* unknown op */\n", "       return 0;\n", "    }\n", "    /* Reset the type */\n", "   type = SAFE_IOP_TYPE_DEFAULT;\n", "  }\n", "  /* Success! */\n", "  return 1;\n", "}\n"], "project": "libsafe-iop0", "file": "safe_iop.pkl", "function": "safe_iopf"}, {"comment_all": {"comment": "/* total ordering for CVS revision numbers - parent always < child */", "depth": 0, "reading_ease": 36.96, "reading_grade": 10.3, "line": 83}, "comment_text": "/* total ordering for CVS revision numbers - parent always < child */", "comment_tokens": ["total", "ordering", "for", "CVS", "revision", "numbers", "-", "parent", "always", "<", "child"], "ccode": ["\n", "int\n", "cvs_number_compare(const cvs_number *a, const cvs_number *b)\n", "/* total ordering for CVS revision numbers - parent always < child */\n", "{\n", "    int n = min(a->c, b->c);\n", "    int i;\n", "\n", "    /*\n", "     * On the same branch, earlier commits compare before later ones.\n", "     * On different ranches of the same degree, the earlier one\n", "     * compares before the later one.\n", "     *\n", "     * Note that while it isn't possible to uniquely total-order\n", "     * an unlabeled tree, the CVS numbers themselves give us the\n", "     * additional info required; they impose an arrow of creation time\n", "     * on the nodes.\n", "     */\n", "    for (i = 0; i < n; i++) {\n", "\tif (a->n[i] < b->n[i])\n", "\t    return -1;\n", "\tif (a->n[i] > b->n[i])\n", "\t    return 1;\n", "    }\n", "    /*\n", "     * Branch root commits sort before any commit on their branch.\n", "     */\n", "    if (a->c < b->c)\n", "\treturn -1;\n", "    if (a->c > b->c)\n", "\treturn 1;\n", "    /*\n", "     * Can happen only if the CVS numbers are equal.\n", "     */\n", "    return 0;\n", "}\n"], "project": "cvs-fast-export", "file": "cvsnumber.pkl", "function": "cvs_number_compare"}, {"comment_all": {"comment": "/* look for a floppy *device* entry... */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 112}, "comment_text": "/* look for a floppy *device* entry... */", "comment_tokens": ["look", "for", "a", "floppy", "device", "entry", "..."], "ccode": ["#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <unistd.h>\n", "#include <fcntl.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#include <sys/ioctl.h>\n", "\n", "#include <linux/hdreg.h>\n", "\n", "#include \"hd.h\"\n", "#include \"hd_int.h\"\n", "#include \"misc.h\"\n", "#include \"klog.h\"\n", "\n", "static void read_ioports(misc_t *m);\n", "static void read_dmas(misc_t *m);\n", "static void read_irqs(misc_t *m);\n", "static int active_vga_card(hd_t *);\n", "\n", "static void dump_misc_proc_data(hd_data_t *hd_data);\n", "static void dump_misc_data(hd_data_t *hd_data);\n", "\n", "/**\n", " * @defgroup MISCint Misc information\n", " * @ingroup libhdINFOint\n", " * @brief Misc information functions\n", " *\n", " * @{\n", " */\n", "\n", "void hd_scan_misc(hd_data_t *hd_data)\n", "{\n", "  hd_t *hd;\n", "  hd_res_t *res;\n", "  int fd, i;\n", "  char *s = NULL;\n", "  bios_info_t *bt = NULL;\n", "  char par[] = \"parport0\";\n", "  int fd_ser0, fd_ser1;\n", "\n", "  if(!hd_probe_feature(hd_data, pr_misc)) return;\n", "\n", "  hd_data->module = mod_misc;\n", "\n", "  /* some clean-up */\n", "  remove_hd_entries(hd_data);\n", "  hd_data->misc = free_misc(hd_data->misc);\n", "\n", "  PROGRESS(9, 0, \"kernel log\");\n", "  read_klog(hd_data);\n", "\n", "  PROGRESS(1, 0, \"misc data\");\n", "  hd_data->misc = new_mem(sizeof *hd_data->misc);\n", "\n", "  /* this is enough to load the module */\n", "  fd_ser0 = fd_ser1 = -1;\n", "\n", "#if !defined(__sparc__)\n", "  /* On sparc, the close needs too long */\n", "  if(hd_probe_feature(hd_data, pr_misc_serial)) {\n", "    PROGRESS(1, 1, \"open serial\");\n", "    fd_ser0 = open(\"/dev/ttyS0\", O_RDONLY | O_NONBLOCK);\n", "    fd_ser1 = open(\"/dev/ttyS1\", O_RDONLY | O_NONBLOCK);\n", "    /* keep the devices open until the resources have been read */\n", "  }\n", "#endif\n", "\n", "  /* this is enough to load the module */\n", "  if(!hd_data->flags.no_parport && hd_probe_feature(hd_data, pr_misc_par)) {\n", "    PROGRESS(1, 2, \"open parallel\");\n", "    /* what can the BIOS tell us? */\n", "    for(hd = hd_data->hd; hd; hd = hd->next) {\n", "      if(\n", "        hd->base_class.id == bc_internal &&\n", "        hd->sub_class.id == sc_int_bios &&\n", "        hd->detail &&\n", "        hd->detail->type == hd_detail_bios &&\n", "        hd->detail->bios.data\n", "      ) break;\n", "    }\n", "    if(hd) {\n", "      bt = hd->detail->bios.data;\n", "      if(bt->par_port0) {\n", "        str_printf(&s, 0, \"io=0x%x\", bt->par_port0);\n", "        if(bt->par_port1) {\n", "          str_printf(&s, -1, \",0x%x\", bt->par_port1);\n", "          if(bt->par_port2) str_printf(&s, -1, \",0x%x\", bt->par_port2);\n", "        }\n", "\tstr_printf(&s, -1, \" irq=none,none,none\");\n", "      }\n", "      unload_module(hd_data, \"parport_probe\");\n", "      unload_module(hd_data, \"lp\");\n", "      unload_module(hd_data, \"parport_pc\");\n", "      unload_module(hd_data, \"parport\");\n", "\n", "      /* now load it with the right io */\n", "      load_module(hd_data, \"parport\");\n", "      load_module_with_params(hd_data, \"parport_pc\", s);\n", "      free_mem(s);\n", "    }\n", "    /* now load the rest of the modules */\n", "    fd = open(\"/dev/lp0\", O_RDONLY | O_NONBLOCK);\n", "    if(fd >= 0) close(fd);\n", "  }\n", "\n", "  /*\n", "   * floppy driver resources are allocated only temporarily,\n", "   * so we access it just before we read the resources\n", "   */\n", "  if(hd_probe_feature(hd_data, pr_misc_floppy)) {\n", "    /* look for a floppy *device* entry... */\n", "    for(hd = hd_data->hd; hd; hd = hd->next) {\n", "      if(\n", "        hd->base_class.id == bc_storage_device &&\n", "        hd->sub_class.id == sc_sdev_floppy &&\n", "        hd->unix_dev_name &&\n", "        !strncmp(hd->unix_dev_name, \"/dev/fd\", sizeof \"/dev/fd\" - 1)\n", "      ) {\n", "\n", "        PROGRESS(1, 3, \"read floppy\");\n", "        i = 5;\n", "        hd->block0 = read_block0(hd_data, hd->unix_dev_name, &i);\n", "        hd->is.notready = hd->block0 ? 0 : 1;\n", "        if(i < 0) {\n", "          hd->tag.remove = 1;\n", "          ADD2LOG(\"misc.floppy: removing floppy entry %u (timed out)\\n\", hd->idx);\n", "        }\n", "\n", "        if(!hd->is.notready) {\n", "          struct hd_geometry geo;\n", "          int fd;\n", "          unsigned size, blk_size = 0x200;\n", "\n", "          fd = open(hd->unix_dev_name, O_RDONLY | O_NONBLOCK);\n", "          if(fd >= 0) {\n", "            if(!ioctl(fd, HDIO_GETGEO, &geo)) {\n", "              ADD2LOG(\"floppy ioctl(geo) ok\\n\");\n", "              res = add_res_entry(&hd->res, new_mem(sizeof *res));\n", "              res->disk_geo.type = res_disk_geo;\n", "              res->disk_geo.cyls = geo.cylinders;\n", "              res->disk_geo.heads = geo.heads;\n", "              res->disk_geo.sectors = geo.sectors;\n", "              res->disk_geo.geotype = geo_logical;\n", "              size = geo.cylinders * geo.heads * geo.sectors;\n", "              for(res = hd->res; res; res = res->next) {\n", "                if(res->any.type == res_size && res->size.unit == size_unit_sectors) {\n", "                  res->size.val1 = size; res->size.val2 = blk_size;\n", "                  break;\n", "                }\n", "              }\n", "              if(!res) {\n", "                res = add_res_entry(&hd->res, new_mem(sizeof *res));\n", "                res->size.type = res_size;\n", "                res->size.unit = size_unit_sectors;\n", "                res->size.val1 = size; res->size.val2 = blk_size;\n", "              }\n", "            }\n", "            close(fd);\n", "          }\n", "        }\n", "\n", "        break;\n", "      }\n", "    }\n", "    remove_tagged_hd_entries(hd_data);\n", "  }\n", "\n", "  PROGRESS(2, 1, \"io\");\n", "  read_ioports(hd_data->misc);\n", "\n", "  PROGRESS(2, 2, \"dma\");\n", "  read_dmas(hd_data->misc);\n", "\n", "  PROGRESS(2, 3, \"irq\");\n", "  read_irqs(hd_data->misc);\n", "\n", "  if((hd_data->debug & HD_DEB_MISC)) dump_misc_proc_data(hd_data);\n", "\n", "  if(fd_ser0 >= 0) close(fd_ser0);\n", "  if(fd_ser1 >= 0) close(fd_ser1);\n", "\n", "  /* now create some system generic entries */\n", "\n", "  /* FPU */\n", "  PROGRESS(3, 0, \"FPU\");\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"fpu\", 0);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_internal;\n", "    hd->sub_class.id = sc_int_fpu;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* DMA */\n", "  PROGRESS(3, 1, \"DMA\");\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"dma1\", 0);\n", "  gather_resources(hd_data->misc, &res, \"dma2\", 0);\n", "  gather_resources(hd_data->misc, &res, \"dma page reg\", 0);\n", "  gather_resources(hd_data->misc, &res, \"cascade\", W_DMA);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_system;\n", "    hd->sub_class.id = sc_sys_dma;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* PIC */\n", "  PROGRESS(3, 2, \"PIC\");\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"pic1\", 0);\n", "  gather_resources(hd_data->misc, &res, \"pic2\", 0);\n", "  gather_resources(hd_data->misc, &res, \"cascade\", W_IRQ);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_system;\n", "    hd->sub_class.id = sc_sys_pic;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* timer */\n", "  PROGRESS(3, 3, \"timer\");\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"timer\", 0);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_system;\n", "    hd->sub_class.id = sc_sys_timer;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* real time clock */\n", "  PROGRESS(3, 4, \"RTC\");\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"rtc\", 0);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_system;\n", "    hd->sub_class.id = sc_sys_rtc;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* keyboard */\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"keyboard\", 0);\n", "  if(res) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_input;\n", "    hd->sub_class.id = sc_inp_keyb;\n", "    hd->res = res;\n", "  }\n", "\n", "  /* parallel ports */\n", "  for(i = 0; i < 1; i++, par[sizeof par - 2]++) {\n", "    res = NULL;\n", "    gather_resources(hd_data->misc, &res, par, 0);\n", "    if(res) {\n", "      hd = add_hd_entry(hd_data, __LINE__, 0);\n", "      hd->base_class.id = bc_comm;\n", "      hd->sub_class.id = sc_com_par;\n", "      str_printf(&hd->unix_dev_name, 0, \"/dev/lp%d\", i);\n", "      hd->res = res;\n", "    }\n", "  }\n", "\n", "  /* floppy controller */\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"floppy\", 0);\n", "  gather_resources(hd_data->misc, &res, \"floppy DIR\", 0);\n", "  if(res) {\n", "    /* look for an existing entry */\n", "    for(hd = hd_data->hd; hd; hd = hd->next) {\n", "      if(hd->base_class.id == bc_storage && hd->sub_class.id == sc_sto_floppy) break;\n", "    }\n", "\n", "    /* missing, so create one */\n", "    if(!hd) {\n", "      hd = add_hd_entry(hd_data, __LINE__, 0);\n", "      hd->base_class.id = bc_storage;\n", "      hd->sub_class.id = sc_sto_floppy;\n", "    }\n", "\n", "    hd->res = res;\n", "  }\n", "\n", "  /*\n", "   * look for PS/2 port\n", "   *\n", "   * The catch is, that sometimes /dev/psaux is accessible only for root,\n", "   * so the open() may fail but there are irq events registered.\n", "   *\n", "   */\n", "  fd = open(DEV_PSAUX, O_RDONLY | O_NONBLOCK);\n", "  if(fd >= 0) close(fd);\n", "\n", "  res = NULL;\n", "  gather_resources(hd_data->misc, &res, \"PS/2 Mouse\", 0);\n", "\n", "  if(res || fd >= 0) {\n", "    hd = add_hd_entry(hd_data, __LINE__, 0);\n", "    hd->base_class.id = bc_ps2;\n", "\n", "    if(res) {\n", "      hd->res = res;\n", "    }\n", "  }\n", "}\n"], "project": "libhd21", "file": "misc.pkl", "function": "hd_scan_misc"}, {"comment_all": {"comment": "/* Generated by: ../../../genfft/gen_hc2hc.native -compact -variables 4 -pipeline-latency 4 -sign 1 -n 16 -dif -name hb_16 -include rdft/scalar/hb.h */", "depth": 0, "reading_ease": 45.76, "reading_grade": 11.1, "line": 451}, "comment_text": "/* Generated by: ../../../genfft/gen_hc2hc.native -compact -variables 4 -pipeline-latency 4 -sign 1 -n 16 -dif -name hb_16 -include rdft/scalar/hb.h */", "comment_tokens": ["Generated", "by", ":", "......", "genfftgen_hc2hc.native", "-compact", "-variables", "4", "-pipeline-latency", "4", "-sign", "1", "-n", "16", "-dif", "-name", "hb_16", "-include", "rdftscalarhb.h"], "ccode": ["#else\n", "\n", "/* Generated by: ../../../genfft/gen_hc2hc.native -compact -variables 4 -pipeline-latency 4 -sign 1 -n 16 -dif -name hb_16 -include rdft/scalar/hb.h */\n", "\n", "/*\n", " * This function contains 174 FP additions, 84 FP multiplications,\n", " * (or, 136 additions, 46 multiplications, 38 fused multiply/add),\n", " * 50 stack variables, 3 constants, and 64 memory accesses\n", " */\n", "#include \"rdft/scalar/hb.h\"\n", "\n", "static void hb_16(R *cr, R *ci, const R *W, stride rs, INT mb, INT me, INT ms)\n", "{\n", "     DK(KP382683432, +0.382683432365089771728459984030398866761344562);\n", "     DK(KP923879532, +0.923879532511286756128183189396788286822416626);\n", "     DK(KP707106781, +0.707106781186547524400844362104849039284835938);\n", "     {\n", "\t  INT m;\n", "\t  for (m = mb, W = W + ((mb - 1) * 30); m < me; m = m + 1, cr = cr + ms, ci = ci - ms, W = W + 30, MAKE_VOLATILE_STRIDE(32, rs)) {\n", "\t       E T7, T2K, T2W, Tw, T17, T1S, T2k, T1w, Te, TD, T1x, T10, T2n, T2L, T1Z;\n", "\t       E T2X, Tm, T1z, TN, T19, T2e, T2p, T2P, T2Z, Tt, T1A, TW, T1a, T27, T2q;\n", "\t       E T2S, T30;\n", "\t       {\n", "\t\t    E T3, T1Q, T16, T1R, T6, T2i, T13, T2j;\n", "\t\t    {\n", "\t\t\t E T1, T2, T14, T15;\n", "\t\t\t T1 = cr[0];\n", "\t\t\t T2 = ci[WS(rs, 7)];\n", "\t\t\t T3 = T1 + T2;\n", "\t\t\t T1Q = T1 - T2;\n", "\t\t\t T14 = ci[WS(rs, 11)];\n", "\t\t\t T15 = cr[WS(rs, 12)];\n", "\t\t\t T16 = T14 - T15;\n", "\t\t\t T1R = T14 + T15;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4, T5, T11, T12;\n", "\t\t\t T4 = cr[WS(rs, 4)];\n", "\t\t\t T5 = ci[WS(rs, 3)];\n", "\t\t\t T6 = T4 + T5;\n", "\t\t\t T2i = T4 - T5;\n", "\t\t\t T11 = ci[WS(rs, 15)];\n", "\t\t\t T12 = cr[WS(rs, 8)];\n", "\t\t\t T13 = T11 - T12;\n", "\t\t\t T2j = T11 + T12;\n", "\t\t    }\n", "\t\t    T7 = T3 + T6;\n", "\t\t    T2K = T1Q + T1R;\n", "\t\t    T2W = T2j - T2i;\n", "\t\t    Tw = T3 - T6;\n", "\t\t    T17 = T13 - T16;\n", "\t\t    T1S = T1Q - T1R;\n", "\t\t    T2k = T2i + T2j;\n", "\t\t    T1w = T13 + T16;\n", "\t       }\n", "\t       {\n", "\t\t    E Ta, T1T, TC, T1U, Td, T1W, Tz, T1X;\n", "\t\t    {\n", "\t\t\t E T8, T9, TA, TB;\n", "\t\t\t T8 = cr[WS(rs, 2)];\n", "\t\t\t T9 = ci[WS(rs, 5)];\n", "\t\t\t Ta = T8 + T9;\n", "\t\t\t T1T = T8 - T9;\n", "\t\t\t TA = ci[WS(rs, 13)];\n", "\t\t\t TB = cr[WS(rs, 10)];\n", "\t\t\t TC = TA - TB;\n", "\t\t\t T1U = TA + TB;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tb, Tc, Tx, Ty;\n", "\t\t\t Tb = ci[WS(rs, 1)];\n", "\t\t\t Tc = cr[WS(rs, 6)];\n", "\t\t\t Td = Tb + Tc;\n", "\t\t\t T1W = Tb - Tc;\n", "\t\t\t Tx = ci[WS(rs, 9)];\n", "\t\t\t Ty = cr[WS(rs, 14)];\n", "\t\t\t Tz = Tx - Ty;\n", "\t\t\t T1X = Tx + Ty;\n", "\t\t    }\n", "\t\t    Te = Ta + Td;\n", "\t\t    TD = Tz - TC;\n", "\t\t    T1x = TC + Tz;\n", "\t\t    T10 = Ta - Td;\n", "\t\t    {\n", "\t\t\t E T2l, T2m, T1V, T1Y;\n", "\t\t\t T2l = T1T + T1U;\n", "\t\t\t T2m = T1W + T1X;\n", "\t\t\t T2n = KP707106781 * (T2l - T2m);\n", "\t\t\t T2L = KP707106781 * (T2l + T2m);\n", "\t\t\t T1V = T1T - T1U;\n", "\t\t\t T1Y = T1W - T1X;\n", "\t\t\t T1Z = KP707106781 * (T1V + T1Y);\n", "\t\t\t T2X = KP707106781 * (T1V - T1Y);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Ti, T2b, TL, T2c, Tl, T28, TI, T29, TF, TM;\n", "\t\t    {\n", "\t\t\t E Tg, Th, TJ, TK;\n", "\t\t\t Tg = cr[WS(rs, 1)];\n", "\t\t\t Th = ci[WS(rs, 6)];\n", "\t\t\t Ti = Tg + Th;\n", "\t\t\t T2b = Tg - Th;\n", "\t\t\t TJ = ci[WS(rs, 10)];\n", "\t\t\t TK = cr[WS(rs, 13)];\n", "\t\t\t TL = TJ - TK;\n", "\t\t\t T2c = TJ + TK;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tj, Tk, TG, TH;\n", "\t\t\t Tj = cr[WS(rs, 5)];\n", "\t\t\t Tk = ci[WS(rs, 2)];\n", "\t\t\t Tl = Tj + Tk;\n", "\t\t\t T28 = Tj - Tk;\n", "\t\t\t TG = ci[WS(rs, 14)];\n", "\t\t\t TH = cr[WS(rs, 9)];\n", "\t\t\t TI = TG - TH;\n", "\t\t\t T29 = TG + TH;\n", "\t\t    }\n", "\t\t    Tm = Ti + Tl;\n", "\t\t    T1z = TI + TL;\n", "\t\t    TF = Ti - Tl;\n", "\t\t    TM = TI - TL;\n", "\t\t    TN = TF - TM;\n", "\t\t    T19 = TF + TM;\n", "\t\t    {\n", "\t\t\t E T2a, T2d, T2N, T2O;\n", "\t\t\t T2a = T28 + T29;\n", "\t\t\t T2d = T2b - T2c;\n", "\t\t\t T2e = FMA(KP923879532, T2a, KP382683432 * T2d);\n", "\t\t\t T2p = FNMS(KP382683432, T2a, KP923879532 * T2d);\n", "\t\t\t T2N = T2b + T2c;\n", "\t\t\t T2O = T29 - T28;\n", "\t\t\t T2P = FNMS(KP923879532, T2O, KP382683432 * T2N);\n", "\t\t\t T2Z = FMA(KP382683432, T2O, KP923879532 * T2N);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Tp, T24, TU, T25, Ts, T21, TR, T22, TO, TV;\n", "\t\t    {\n", "\t\t\t E Tn, To, TS, TT;\n", "\t\t\t Tn = ci[0];\n", "\t\t\t To = cr[WS(rs, 7)];\n", "\t\t\t Tp = Tn + To;\n", "\t\t\t T24 = Tn - To;\n", "\t\t\t TS = ci[WS(rs, 12)];\n", "\t\t\t TT = cr[WS(rs, 11)];\n", "\t\t\t TU = TS - TT;\n", "\t\t\t T25 = TS + TT;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tq, Tr, TP, TQ;\n", "\t\t\t Tq = cr[WS(rs, 3)];\n", "\t\t\t Tr = ci[WS(rs, 4)];\n", "\t\t\t Ts = Tq + Tr;\n", "\t\t\t T21 = Tq - Tr;\n", "\t\t\t TP = ci[WS(rs, 8)];\n", "\t\t\t TQ = cr[WS(rs, 15)];\n", "\t\t\t TR = TP - TQ;\n", "\t\t\t T22 = TP + TQ;\n", "\t\t    }\n", "\t\t    Tt = Tp + Ts;\n", "\t\t    T1A = TR + TU;\n", "\t\t    TO = Tp - Ts;\n", "\t\t    TV = TR - TU;\n", "\t\t    TW = TO + TV;\n", "\t\t    T1a = TV - TO;\n", "\t\t    {\n", "\t\t\t E T23, T26, T2Q, T2R;\n", "\t\t\t T23 = T21 - T22;\n", "\t\t\t T26 = T24 - T25;\n", "\t\t\t T27 = FNMS(KP382683432, T26, KP923879532 * T23);\n", "\t\t\t T2q = FMA(KP382683432, T23, KP923879532 * T26);\n", "\t\t\t T2Q = T24 + T25;\n", "\t\t\t T2R = T21 + T22;\n", "\t\t\t T2S = FNMS(KP923879532, T2R, KP382683432 * T2Q);\n", "\t\t\t T30 = FMA(KP382683432, T2R, KP923879532 * T2Q);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Tf, Tu, T1u, T1y, T1B, T1C, T1t, T1v;\n", "\t\t    Tf = T7 + Te;\n", "\t\t    Tu = Tm + Tt;\n", "\t\t    T1u = Tf - Tu;\n", "\t\t    T1y = T1w + T1x;\n", "\t\t    T1B = T1z + T1A;\n", "\t\t    T1C = T1y - T1B;\n", "\t\t    cr[0] = Tf + Tu;\n", "\t\t    ci[0] = T1y + T1B;\n", "\t\t    T1t = W[14];\n", "\t\t    T1v = W[15];\n", "\t\t    cr[WS(rs, 8)] = FNMS(T1v, T1C, T1t * T1u);\n", "\t\t    ci[WS(rs, 8)] = FMA(T1v, T1u, T1t * T1C);\n", "\t       }\n", "\t       {\n", "\t\t    E T2U, T34, T32, T36;\n", "\t\t    {\n", "\t\t\t E T2M, T2T, T2Y, T31;\n", "\t\t\t T2M = T2K - T2L;\n", "\t\t\t T2T = T2P + T2S;\n", "\t\t\t T2U = T2M - T2T;\n", "\t\t\t T34 = T2M + T2T;\n", "\t\t\t T2Y = T2W + T2X;\n", "\t\t\t T31 = T2Z - T30;\n", "\t\t\t T32 = T2Y - T31;\n", "\t\t\t T36 = T2Y + T31;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T2J, T2V, T33, T35;\n", "\t\t\t T2J = W[20];\n", "\t\t\t T2V = W[21];\n", "\t\t\t cr[WS(rs, 11)] = FNMS(T2V, T32, T2J * T2U);\n", "\t\t\t ci[WS(rs, 11)] = FMA(T2V, T2U, T2J * T32);\n", "\t\t\t T33 = W[4];\n", "\t\t\t T35 = W[5];\n", "\t\t\t cr[WS(rs, 3)] = FNMS(T35, T36, T33 * T34);\n", "\t\t\t ci[WS(rs, 3)] = FMA(T35, T34, T33 * T36);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T3a, T3g, T3e, T3i;\n", "\t\t    {\n", "\t\t\t E T38, T39, T3c, T3d;\n", "\t\t\t T38 = T2K + T2L;\n", "\t\t\t T39 = T2Z + T30;\n", "\t\t\t T3a = T38 - T39;\n", "\t\t\t T3g = T38 + T39;\n", "\t\t\t T3c = T2W - T2X;\n", "\t\t\t T3d = T2P - T2S;\n", "\t\t\t T3e = T3c + T3d;\n", "\t\t\t T3i = T3c - T3d;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T37, T3b, T3f, T3h;\n", "\t\t\t T37 = W[12];\n", "\t\t\t T3b = W[13];\n", "\t\t\t cr[WS(rs, 7)] = FNMS(T3b, T3e, T37 * T3a);\n", "\t\t\t ci[WS(rs, 7)] = FMA(T37, T3e, T3b * T3a);\n", "\t\t\t T3f = W[28];\n", "\t\t\t T3h = W[29];\n", "\t\t\t cr[WS(rs, 15)] = FNMS(T3h, T3i, T3f * T3g);\n", "\t\t\t ci[WS(rs, 15)] = FMA(T3f, T3i, T3h * T3g);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E TY, T1e, T1c, T1g;\n", "\t\t    {\n", "\t\t\t E TE, TX, T18, T1b;\n", "\t\t\t TE = Tw + TD;\n", "\t\t\t TX = KP707106781 * (TN + TW);\n", "\t\t\t TY = TE - TX;\n", "\t\t\t T1e = TE + TX;\n", "\t\t\t T18 = T10 + T17;\n", "\t\t\t T1b = KP707106781 * (T19 + T1a);\n", "\t\t\t T1c = T18 - T1b;\n", "\t\t\t T1g = T18 + T1b;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tv, TZ, T1d, T1f;\n", "\t\t\t Tv = W[18];\n", "\t\t\t TZ = W[19];\n", "\t\t\t cr[WS(rs, 10)] = FNMS(TZ, T1c, Tv * TY);\n", "\t\t\t ci[WS(rs, 10)] = FMA(TZ, TY, Tv * T1c);\n", "\t\t\t T1d = W[2];\n", "\t\t\t T1f = W[3];\n", "\t\t\t cr[WS(rs, 2)] = FNMS(T1f, T1g, T1d * T1e);\n", "\t\t\t ci[WS(rs, 2)] = FMA(T1f, T1e, T1d * T1g);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T1k, T1q, T1o, T1s;\n", "\t\t    {\n", "\t\t\t E T1i, T1j, T1m, T1n;\n", "\t\t\t T1i = Tw - TD;\n", "\t\t\t T1j = KP707106781 * (T1a - T19);\n", "\t\t\t T1k = T1i - T1j;\n", "\t\t\t T1q = T1i + T1j;\n", "\t\t\t T1m = T17 - T10;\n", "\t\t\t T1n = KP707106781 * (TN - TW);\n", "\t\t\t T1o = T1m - T1n;\n", "\t\t\t T1s = T1m + T1n;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1h, T1l, T1p, T1r;\n", "\t\t\t T1h = W[26];\n", "\t\t\t T1l = W[27];\n", "\t\t\t cr[WS(rs, 14)] = FNMS(T1l, T1o, T1h * T1k);\n", "\t\t\t ci[WS(rs, 14)] = FMA(T1h, T1o, T1l * T1k);\n", "\t\t\t T1p = W[10];\n", "\t\t\t T1r = W[11];\n", "\t\t\t cr[WS(rs, 6)] = FNMS(T1r, T1s, T1p * T1q);\n", "\t\t\t ci[WS(rs, 6)] = FMA(T1p, T1s, T1r * T1q);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T2g, T2u, T2s, T2w;\n", "\t\t    {\n", "\t\t\t E T20, T2f, T2o, T2r;\n", "\t\t\t T20 = T1S - T1Z;\n", "\t\t\t T2f = T27 - T2e;\n", "\t\t\t T2g = T20 - T2f;\n", "\t\t\t T2u = T20 + T2f;\n", "\t\t\t T2o = T2k - T2n;\n", "\t\t\t T2r = T2p - T2q;\n", "\t\t\t T2s = T2o - T2r;\n", "\t\t\t T2w = T2o + T2r;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1P, T2h, T2t, T2v;\n", "\t\t\t T1P = W[24];\n", "\t\t\t T2h = W[25];\n", "\t\t\t cr[WS(rs, 13)] = FNMS(T2h, T2s, T1P * T2g);\n", "\t\t\t ci[WS(rs, 13)] = FMA(T2h, T2g, T1P * T2s);\n", "\t\t\t T2t = W[8];\n", "\t\t\t T2v = W[9];\n", "\t\t\t cr[WS(rs, 5)] = FNMS(T2v, T2w, T2t * T2u);\n", "\t\t\t ci[WS(rs, 5)] = FMA(T2v, T2u, T2t * T2w);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T2A, T2G, T2E, T2I;\n", "\t\t    {\n", "\t\t\t E T2y, T2z, T2C, T2D;\n", "\t\t\t T2y = T1S + T1Z;\n", "\t\t\t T2z = T2p + T2q;\n", "\t\t\t T2A = T2y - T2z;\n", "\t\t\t T2G = T2y + T2z;\n", "\t\t\t T2C = T2k + T2n;\n", "\t\t\t T2D = T2e + T27;\n", "\t\t\t T2E = T2C - T2D;\n", "\t\t\t T2I = T2C + T2D;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T2x, T2B, T2F, T2H;\n", "\t\t\t T2x = W[16];\n", "\t\t\t T2B = W[17];\n", "\t\t\t cr[WS(rs, 9)] = FNMS(T2B, T2E, T2x * T2A);\n", "\t\t\t ci[WS(rs, 9)] = FMA(T2x, T2E, T2B * T2A);\n", "\t\t\t T2F = W[0];\n", "\t\t\t T2H = W[1];\n", "\t\t\t cr[WS(rs, 1)] = FNMS(T2H, T2I, T2F * T2G);\n", "\t\t\t ci[WS(rs, 1)] = FMA(T2F, T2I, T2H * T2G);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T1G, T1M, T1K, T1O;\n", "\t\t    {\n", "\t\t\t E T1E, T1F, T1I, T1J;\n", "\t\t\t T1E = T7 - Te;\n", "\t\t\t T1F = T1A - T1z;\n", "\t\t\t T1G = T1E - T1F;\n", "\t\t\t T1M = T1E + T1F;\n", "\t\t\t T1I = T1w - T1x;\n", "\t\t\t T1J = Tm - Tt;\n", "\t\t\t T1K = T1I - T1J;\n", "\t\t\t T1O = T1J + T1I;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1D, T1H, T1L, T1N;\n", "\t\t\t T1D = W[22];\n", "\t\t\t T1H = W[23];\n", "\t\t\t cr[WS(rs, 12)] = FNMS(T1H, T1K, T1D * T1G);\n", "\t\t\t ci[WS(rs, 12)] = FMA(T1D, T1K, T1H * T1G);\n", "\t\t\t T1L = W[6];\n", "\t\t\t T1N = W[7];\n", "\t\t\t cr[WS(rs, 4)] = FNMS(T1N, T1O, T1L * T1M);\n", "\t\t\t ci[WS(rs, 4)] = FMA(T1L, T1O, T1N * T1M);\n", "\t\t    }\n", "\t       }\n", "\t  }\n", "     }\n", "}\n"], "project": "libfftw3-mpi-dev", "file": "hb_16.pkl", "function": "hb_16"}, {"comment_all": {"comment": "/********************************************************\n * An example source module to accompany...\n *\n * \"Using POSIX Threads: Programming with Pthreads\"\n *     by Brad nichols, Dick Buttlar, Jackie Farrell\n *     O'Reilly & Associates, Inc.\n *\n ********************************************************\n * rdwr.c --\n * \n * Library of functions implementing reader/writer locks\n */", "depth": 0, "reading_ease": 36.25, "reading_grade": 10.6, "line": 0}, "comment_text": "/********************************************************\n * An example source module to accompany...\n *\n * \"Using POSIX Threads: Programming with Pthreads\"\n *     by Brad nichols, Dick Buttlar, Jackie Farrell\n *     O'Reilly & Associates, Inc.\n *\n ********************************************************\n * rdwr.c --\n * \n * Library of functions implementing reader/writer locks\n */", "comment_tokens": ["An", "example", "source", "module", "to", "accompany", "...", "``", "Using", "POSIX", "Threads", ":", "Programming", "with", "Pthreads", "''", "by", "Brad", "nichols", ",", "Dick", "Buttlar", ",", "Jackie", "Farrell", "O'Reilly", "&", "Associates", ",", "Inc.", "rdwr.c", "--", "Library", "of", "functions", "implementing", "readerwriter", "locks"], "ccode": ["/********************************************************\n", " * An example source module to accompany...\n", " *\n", " * \"Using POSIX Threads: Programming with Pthreads\"\n", " *     by Brad nichols, Dick Buttlar, Jackie Farrell\n", " *     O'Reilly & Associates, Inc.\n", " *\n", " ********************************************************\n", " * rdwr.c --\n", " * \n", " * Library of functions implementing reader/writer locks\n", " */\n", "#include <pthread.h>\n", "#include \"rdwr.h\"\n", "\n", "int\n", "pthread_rdwr_init_np (pthread_rdwr_t * rdwrp)\n", "{\n", "  rdwrp->readers_reading = 0;\n", "  rdwrp->writer_writing = 0;\n", "  pthread_mutex_init (&(rdwrp->mutex), NULL);\n", "  pthread_cond_init (&(rdwrp->lock_free), NULL);\n", "  return 0;\n", "}\n"], "project": "ganglia-monitor", "file": "rdwr.pkl", "function": "pthread_rdwr_init_np"}, {"comment_all": {"comment": "// XXX: first page handling won't work with that\n", "depth": 3, "reading_ease": 105.66, "reading_grade": 0.5, "line": 149}, "comment_text": "// XXX: first page handling won't work with that\n", "comment_tokens": ["XXX", ":", "first", "page", "handling", "wo", "n't", "work", "with", "that"], "ccode": ["\n", "static int wt_textview_process(struct stfl_widget *w, struct stfl_widget *fw, struct stfl_form *f, wchar_t ch, int isfunckey)\n", "{\n", "\t//int pos = stfl_widget_getkv_int(w, \"pos\", 0);\n", "\tint offset = stfl_widget_getkv_int(w,L\"offset\",0);\n", "\tint maxoffset = -1;\n", "\n", "\tstruct stfl_widget *c = w->first_child;\n", "\twhile (c) {\n", "\t\tmaxoffset++;\n", "\t\tc = c->next_sibling;\n", "\t}\n", "\n", "\tif (offset > 0 && stfl_matchbind(w, ch, isfunckey, L\"up\", L\"UP\")) {\n", "\t\tstfl_widget_setkv_int(w, L\"offset\", offset-1);\n", "\t\t\n", "\t\t//fix_offset_pos(w);\n", "\t\treturn 1;\n", "\t}\n", "\t\t\n", "\tif (offset < maxoffset && stfl_matchbind(w, ch, isfunckey, L\"down\", L\"DOWN\")) {\n", "\t\tstfl_widget_setkv_int(w, L\"offset\", offset+1);\n", "\t\t//fix_offset_pos(w);\n", "\t\treturn 1;\n", "\t}\n", "\n", "\tif (stfl_matchbind(w, ch, isfunckey, L\"page_up\", L\"PPAGE\")) {\n", "\t\tif ((offset - w->h + 1) > 0) { // XXX: first page handling won't work with that\n", "\t\t\tstfl_widget_setkv_int(w, L\"offset\", offset - w->h + 1);\n", "\t\t} else {\n", "\t\t\tstfl_widget_setkv_int(w, L\"offset\", 0);\n", "\t\t}\n", "\t\treturn 1;\n", "\t}\n", "\n", "\tif (stfl_matchbind(w, ch, isfunckey, L\"page_down\", L\"NPAGE\")) {\n", "\t\tif ((offset + w->h - 1) < maxoffset) { // XXX: last page handling won't work with that\n", "\t\t\tstfl_widget_setkv_int(w, L\"offset\", offset + w->h - 1);\n", "\t\t} else {\n", "\t\t\tstfl_widget_setkv_int(w, L\"offset\", maxoffset);\n", "\t\t}\n", "\t\treturn 1;\n", "\t}\n", "\n", "\tif (stfl_matchbind(w, ch, isfunckey, L\"home\", L\"HOME\")) {\n", "\t\tstfl_widget_setkv_int(w, L\"offset\", 0);\n", "\t\treturn 1;\n", "\t}\n", "\n", "\tif (stfl_matchbind(w, ch, isfunckey, L\"end\", L\"END\")) {\n", "\t\tstfl_widget_setkv_int(w, L\"offset\", (maxoffset - w->h + 2) < 0 ? 0 : maxoffset - w->h + 2);\n", "\t\treturn 1;\n", "\t}\n", "\n", "\treturn 0;\n", "}\n"], "project": "libstfl-perl", "file": "wt_textview.pkl", "function": "wt_textview_process"}, {"comment_all": {"comment": "// Image has been written to a temporary file and then moved over destination.\n", "depth": 3, "reading_ease": 66.74, "reading_grade": 7.2, "line": 641}, "comment_text": "// Image has been written to a temporary file and then moved over destination.\n// This makes replacement atomic and avoids damaging destination file on write error.\n", "comment_tokens": ["Image", "has", "been", "written", "to", "a", "temporary", "file", "and", "then", "moved", "over", "destination", ".", "This", "makes", "replacement", "atomic", "and", "avoids", "damaging", "destination", "file", "on", "write", "error", "."], "ccode": ["\n", "static pngquant_error write_image(png8_image *output_image, png24_image *output_image24, const char *outname, struct pngquant_options *options)\n", "{\n", "    FILE *outfile;\n", "    char *tempname = NULL;\n", "\n", "    if (options->using_stdout) {\n", "        set_binary_mode(stdout);\n", "        outfile = stdout;\n", "\n", "        if (output_image) {\n", "            verbose_printf(options, \"  writing %d-color image to stdout\", output_image->num_palette);\n", "        } else {\n", "            verbose_printf(options, \"  writing truecolor image to stdout\");\n", "        }\n", "    } else {\n", "        tempname = temp_filename(outname);\n", "        if (!tempname) return OUT_OF_MEMORY_ERROR;\n", "\n", "        if ((outfile = fopen(tempname, \"wb\")) == NULL) {\n", "            fprintf(stderr, \"  error: cannot open '%s' for writing\\n\", tempname);\n", "            free(tempname);\n", "            return CANT_WRITE_ERROR;\n", "        }\n", "\n", "        if (output_image) {\n", "            verbose_printf(options, \"  writing %d-color image as %s\", output_image->num_palette, filename_part(outname));\n", "        } else {\n", "            verbose_printf(options, \"  writing truecolor image as %s\", filename_part(outname));\n", "        }\n", "    }\n", "\n", "    pngquant_error retval;\n", "    #pragma omp critical (libpng)\n", "    {\n", "        if (output_image) {\n", "            retval = rwpng_write_image8(outfile, output_image);\n", "        } else {\n", "            retval = rwpng_write_image24(outfile, output_image24);\n", "        }\n", "    }\n", "\n", "    if (!options->using_stdout) {\n", "        fclose(outfile);\n", "\n", "        if (SUCCESS == retval) {\n", "            // Image has been written to a temporary file and then moved over destination.\n", "            // This makes replacement atomic and avoids damaging destination file on write error.\n", "            if (!replace_file(tempname, outname, options->force)) {\n", "                retval = CANT_WRITE_ERROR;\n", "            }\n", "        }\n", "\n", "        if (retval) {\n", "            unlink(tempname);\n", "        }\n", "    }\n", "    free(tempname);\n", "\n", "    if (retval && retval != TOO_LARGE_FILE) {\n", "        fprintf(stderr, \"  error: failed writing image to %s (%d)\\n\", options->using_stdout ? \"stdout\" : outname, retval);\n", "    }\n", "\n", "    return retval;\n", "}\n"], "project": "pngquant", "file": "pngquant.pkl", "function": "write_image"}, {"comment_all": {"comment": "/*\n * do_dlm_dispatch()\n * Read an ast from the kernel.\n */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 466}, "comment_text": "/*\n * do_dlm_dispatch()\n * Read an ast from the kernel.\n */", "comment_tokens": ["do_dlm_dispatch", "(", ")", "Read", "an", "ast", "from", "the", "kernel", "."], "ccode": ["\n", "/*\n", " * do_dlm_dispatch()\n", " * Read an ast from the kernel.\n", " */\n", "\n", "static int do_dlm_dispatch_v5(int fd)\n", "{\n", "\tchar resultbuf[sizeof(struct dlm_lock_result_v5) + DLM_USER_LVB_LEN];\n", "\tstruct dlm_lock_result_v5 *result = (struct dlm_lock_result_v5 *)resultbuf;\n", "\tchar *fullresult = NULL;\n", "\tint status;\n", "\tvoid (*astaddr)(void *astarg);\n", "\n", "\tstatus = read(fd, result, sizeof(resultbuf));\n", "\tif (status <= 0)\n", "\t\treturn -1;\n", "\n", "\t/* This shouldn't happen any more, can probably be removed */\n", "\n", "\tif (result->length != status) {\n", "\t\tint newstat;\n", "\n", "\t\tfullresult = malloc(result->length);\n", "\t\tif (!fullresult)\n", "\t\t\treturn -1;\n", "\n", "\t\tnewstat = read(fd, (struct dlm_lock_result_v5 *)fullresult,\n", "\t\t\t       result->length);\n", "\n", "\t\t/* If it read OK then use the new data. otherwise we can\n", "\t\t   still deliver the AST, it just might not have all the\n", "\t\t   info in it...hmmm */\n", "\n", "\t\tif (newstat == result->length)\n", "\t\t\tresult = (struct dlm_lock_result_v5 *)fullresult;\n", "\t} else {\n", "\t\tfullresult = resultbuf;\n", "\t}\n", "\n", "\n", "\t/* Copy lksb to user's buffer - except the LVB ptr */\n", "\tmemcpy(result->user_lksb, &result->lksb,\n", "\t       sizeof(struct dlm_lksb) - sizeof(char*));\n", "\n", "\t/* Flip the status. Kernel space likes negative return codes,\n", "\t   userspace positive ones */\n", "\tresult->user_lksb->sb_status = -result->user_lksb->sb_status;\n", "\n", "\t/* Copy optional items */\n", "\tif (result->lvb_offset)\n", "\t\tmemcpy(result->user_lksb->sb_lvbptr,\n", "\t\t       fullresult + result->lvb_offset, DLM_LVB_LEN);\n", "\n", "\t/* Call AST */\n", "\tif (result->user_astaddr) {\n", "\t\tastaddr = result->user_astaddr;\n", "\t\tastaddr(result->user_astparam);\n", "\t}\n", "\n", "\tif (fullresult != resultbuf)\n", "\t\tfree(fullresult);\n", "\n", "\treturn 0;\n", "}\n"], "project": "libdlmcontrol3", "file": "libdlm.pkl", "function": "do_dlm_dispatch_v5"}, {"comment_all": {"comment": "/* Read off the type if the first value matches a type prefix\n * and consume characters if successful.\n */", "depth": 0, "reading_ease": 62.68, "reading_grade": 8.7, "line": 19}, "comment_text": "/* Read off the type if the first value matches a type prefix\n * and consume characters if successful.\n */", "comment_tokens": ["Read", "off", "the", "type", "if", "the", "first", "value", "matches", "a", "type", "prefix", "and", "consume", "characters", "if", "successful", "."], "ccode": ["/* safe_iop\n", " * License:: released in to the public domain\n", " * Author:: Will Drewry <redpig@dataspill.org>\n", " * Copyright 2007,2008 redpig@dataspill.org\n", " * Some portions copyright Google Inc, 2008.\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n", " * OF ANY KIND, either express or implied.\n", " *\n", " * See safe_iop.h for more info.\n", " */\n", "#include <stdint.h>\n", "#include <stdarg.h>\n", "#include <string.h>\n", "#include <sys/types.h>\n", "\n", "#include <safe_iop.h>\n", "\n", "/* Read off the type if the first value matches a type prefix\n", " * and consume characters if successful.\n", " */\n", "static int _safe_op_read_type(safe_type_t *type, const char **c) {\n", "  if (type == NULL) {\n", "    return 0;\n", "  }\n", "  if (c == NULL || *c == NULL || **c == '\\0') {\n", "    return 0;\n", "  }\n", "  /* Extract a type for the operation if there is one */\n", "  if (strchr(SAFE_IOP_TYPE_PREFIXES, **c) != NULL) {\n", "    switch(**c) {\n", "      case 'u':\n", "        if ((*(*c+1) && *(*c+1) == '3') &&\n", "            (*(*c+2) && *(*c+2) == '2')) {\n", "          *type = SAFE_IOP_TYPE_U32;\n", "          *c += 3; /* Advance past type */\n", "        }\n", "        break;\n", "      case 's':\n", "        if ((*(*c+1) && *(*c+1) == '3') &&\n", "            (*(*c+2) && *(*c+2) == '2')) {\n", "          *type = SAFE_IOP_TYPE_S32;\n", "          *c += 3; /* Advance past type */\n", "        }\n", "        break;\n", "      default:\n", "        /* Unknown type */\n", "        return 0;\n", "    }\n", "  }\n", "  return 1;\n", "}\n"], "project": "libsafe-iop0", "file": "safe_iop.pkl", "function": "_safe_op_read_type"}, {"comment_all": {"comment": "// note that we're setting a 'custom' optarg tag/value pair as an example here\n", "depth": 0, "reading_ease": 66.74, "reading_grade": 7.2, "line": 251}, "comment_text": "// note that we're setting a 'custom' optarg tag/value pair as an example here\n", "comment_tokens": ["note", "that", "we", "'re", "setting", "a", "'custom", "'", "optarg", "tagvalue", "pair", "as", "an", "example", "here"], "ccode": ["\n", "// note that we're setting a 'custom' optarg tag/value pair as an example here\n", "int shape_transient_eval(struct cli_def *cli, const char *name, const char *value) {\n", "  printf(\"shape_transient_eval called with <%s>\\n\", value);\n", "  if (!strcmp(value, \"rectangle\")) {\n", "    cli_set_transient_mode(cli, MODE_POLYGON_RECTANGLE);\n", "    cli_set_optarg_value(cli, \"duplicateShapeValue\", value, 0);\n", "    return CLI_OK;\n", "  } else if (!strcmp(value, \"triangle\")) {\n", "    cli_set_transient_mode(cli, MODE_POLYGON_TRIANGLE);\n", "    cli_set_optarg_value(cli, \"duplicateShapeValue\", value, 0);\n", "    return CLI_OK;\n", "  }\n", "  cli_error(cli, \"unrecognized value for setting %s -> %s\", name, value);\n", "  return CLI_ERROR;\n", "}\n"], "project": "libcli-dev", "file": "clitest.pkl", "function": "shape_transient_eval"}, {"comment_all": {"comment": "// scan for last space (' ') before \"lw\".\n", "depth": 2, "reading_ease": 99.23, "reading_grade": 0.9, "line": 87}, "comment_text": "// scan for last space (' ') before \"lw\".\n", "comment_tokens": ["scan", "for", "last", "space", "(", "'", "'", ")", "before", "``", "lw", "''", "."], "ccode": ["\n", "sl* split_long_string(const char* str, int firstlinew, int linew, sl* lst) {\n", "    const char* s;\n", "    char* added;\n", "    int lw = firstlinew;\n", "    if (!lst)\n", "        lst = sl_new(16);\n", "    assert(linew > 1);\n", "    assert(str);\n", "    s = str;\n", "    while (1) {\n", "        int brk = -1;\n", "        int i, N;\n", "        N = strlen(s);\n", "        if (!N)\n", "            break;\n", "        if (N <= lw) {\n", "            sl_append(lst, s);\n", "            break;\n", "        }\n", "        // scan for last space (' ') before \"lw\".\n", "        for (i=0; i<MIN(lw+1, N); i++) {\n", "            if (s[i] == ' ')\n", "                brk = i;\n", "        }\n", "        if (brk <= 1) {\n", "            // no space -- hard-break at \"lw\"; add hyphen.\n", "            added = sl_appendf(lst, \"%.*s-\", lw-1, s);\n", "            s += strlen(added)-1;\n", "        } else {\n", "            // trim trailing spaces...\n", "            while (brk >= 1 && s[brk-1] == ' ')\n", "                brk--;\n", "            added = sl_appendf(lst, \"%.*s\", brk, s);\n", "            s += strlen(added);\n", "            // trim spaces.\n", "            while (s && s[0]==' ') s++;\n", "        }\n", "        lw = linew;\n", "    }\n", "    return lst;\n", "}\n"], "project": "astrometry.net", "file": "ioutils.pkl", "function": "split_long_string"}, {"comment_all": {"comment": "/* Convert to wide string and send to wide console output */", "depth": 2, "reading_ease": 86.71, "reading_grade": 3.7, "line": 66}, "comment_text": "/* Convert to wide string and send to wide console output */", "comment_tokens": ["Convert", "to", "wide", "string", "and", "send", "to", "wide", "console", "output"], "ccode": ["\n", "#else\n", " #define slash_convert(a)\n", "#endif /* UNICODE */\n", "\n", "/* Print a string that is wide on Windows but normal on POSIX */\n", "extern int fwprint(FILE * const restrict stream, const char * const restrict str, const int cr)\n", "{\n", "#ifdef UNICODE\n", "  int retval;\n", "  int stream_mode = out_mode;\n", "\n", "  if (stream == stderr) stream_mode = err_mode;\n", "\n", "  if (stream_mode == _O_U16TEXT) {\n", "    /* Convert to wide string and send to wide console output */\n", "    if (!M2W(str, wstr)) return -1;\n", "    fflush(stream);\n", "    _setmode(_fileno(stream), stream_mode);\n", "    if (cr == 2) retval = fwprintf(stream, L\"%S%C\", wstr, 0);\n", "    else retval = fwprintf(stream, L\"%S%S\", wstr, cr == 1 ? L\"\\n\" : L\"\");\n", "    fflush(stream);\n", "    _setmode(_fileno(stream), _O_TEXT);\n", "    return retval;\n", "  } else {\n", "#endif\n", "    if (cr == 2) return fprintf(stream, \"%s%c\", str, 0);\n", "    else return fprintf(stream, \"%s%s\", str, cr == 1 ? \"\\n\" : \"\");\n", "#ifdef UNICODE\n", "  }\n", "#endif\n", "}\n"], "project": "jdupes", "file": "jody_win_unicode.pkl", "function": "fwprint"}, {"comment_all": {"comment": "/* This will flush remaining packets into a page (returning nonzero),\n   even if there is not enough data to trigger a flush normally\n   (undersized page). If there are no packets or partial packets to\n   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will\n   try to flush a normal sized page like ogg_stream_pageout; a call to\n   ogg_stream_flush does not guarantee that all packets have flushed.\n   Only a return value of 0 from ogg_stream_flush indicates all packet\n   data is flushed into pages.\n\n   since ogg_stream_flush will flush the last page in a stream even if\n   it's undersized, you almost certainly want to use ogg_stream_pageout\n   (and *not* ogg_stream_flush) unless you specifically need to flush\n   a page regardless of size in the middle of a stream. */", "depth": 0, "reading_ease": 55.78, "reading_grade": 11.4, "line": 479}, "comment_text": "/* This will flush remaining packets into a page (returning nonzero),\n   even if there is not enough data to trigger a flush normally\n   (undersized page). If there are no packets or partial packets to\n   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will\n   try to flush a normal sized page like ogg_stream_pageout; a call to\n   ogg_stream_flush does not guarantee that all packets have flushed.\n   Only a return value of 0 from ogg_stream_flush indicates all packet\n   data is flushed into pages.\n\n   since ogg_stream_flush will flush the last page in a stream even if\n   it's undersized, you almost certainly want to use ogg_stream_pageout\n   (and *not* ogg_stream_flush) unless you specifically need to flush\n   a page regardless of size in the middle of a stream. */", "comment_tokens": ["This", "will", "flush", "remaining", "packets", "into", "a", "page", "(", "returning", "nonzero", ")", ",", "even", "if", "there", "is", "not", "enough", "data", "to", "trigger", "a", "flush", "normally", "(", "undersized", "page", ")", ".", "If", "there", "are", "no", "packets", "or", "partial", "packets", "to", "flush", ",", "ogg_stream_flush", "returns", "0", ".", "Note", "that", "ogg_stream_flush", "will", "try", "to", "flush", "a", "normal", "sized", "page", "like", "ogg_stream_pageout", ";", "a", "call", "to", "ogg_stream_flush", "does", "not", "guarantee", "that", "all", "packets", "have", "flushed", ".", "Only", "a", "return", "value", "of", "0", "from", "ogg_stream_flush", "indicates", "all", "packet", "data", "is", "flushed", "into", "pages", ".", "since", "ogg_stream_flush", "will", "flush", "the", "last", "page", "in", "a", "stream", "even", "if", "it", "'s", "undersized", ",", "you", "almost", "certainly", "want", "to", "use", "ogg_stream_pageout", "(", "and", "not", "ogg_stream_flush", ")", "unless", "you", "specifically", "need", "to", "flush", "a", "page", "regardless", "of", "size", "in", "the", "middle", "of", "a", "stream", "."], "ccode": ["\n", "/* This will flush remaining packets into a page (returning nonzero),\n", "   even if there is not enough data to trigger a flush normally\n", "   (undersized page). If there are no packets or partial packets to\n", "   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will\n", "   try to flush a normal sized page like ogg_stream_pageout; a call to\n", "   ogg_stream_flush does not guarantee that all packets have flushed.\n", "   Only a return value of 0 from ogg_stream_flush indicates all packet\n", "   data is flushed into pages.\n", "\n", "   since ogg_stream_flush will flush the last page in a stream even if\n", "   it's undersized, you almost certainly want to use ogg_stream_pageout\n", "   (and *not* ogg_stream_flush) unless you specifically need to flush\n", "   a page regardless of size in the middle of a stream. */\n", "\n", "int ogg_stream_flush(ogg_stream_state *os,ogg_page *og){\n", "  return ogg_stream_flush_i(os,og,1,4096);\n", "}\n"], "project": "libogg-dbg", "file": "framing.pkl", "function": "ogg_stream_flush"}, {"comment_all": {"comment": "/* free up the client lib stuff \n            globus_ftp_client_handle_t          client_h;\n        */", "depth": 2, "reading_ease": 71.82, "reading_grade": 5.2, "line": 238}, "comment_text": "/* free up the client lib stuff \n            globus_ftp_client_handle_t          client_h;\n        */", "comment_tokens": ["free", "up", "the", "client", "lib", "stuff", "globus_ftp_client_handle_t", "client_h", ";"], "ccode": ["\n", "static\n", "void\n", "xio_l_gmc_handle_destroy(\n", "    xio_l_gridftp_multicast_handle_t *  handle)\n", "{\n", "    int                                 i;\n", "    xio_l_gmc_ftp_handle_t *            ftp_handle;\n", "    globus_object_t *                   err_obj;\n", "    char *                              str;\n", "\n", "    for(i = 0; i < handle->ftps_total; i++)\n", "    {\n", "        ftp_handle = &handle->ftp_handles[i];\n", "\n", "        if(ftp_handle->result != GLOBUS_SUCCESS)\n", "        {\n", "            err_obj = globus_error_get(ftp_handle->result);\n", "            globus_object_free(err_obj);\n", "        }\n", "        while(!globus_fifo_empty(&ftp_handle->url_q))\n", "        {\n", "            str = (char *) globus_fifo_dequeue(&ftp_handle->url_q);\n", "            free(str);\n", "        }\n", "        globus_fifo_destroy(&ftp_handle->url_q);\n", "\n", "        globus_free(ftp_handle->url);\n", "\n", "        if(ftp_handle->stack_str != NULL)\n", "        {\n", "            globus_free(ftp_handle->stack_str);\n", "        }\n", "\n", "        globus_ftp_client_handleattr_destroy(&ftp_handle->handle_attr);\n", "        globus_ftp_client_operationattr_destroy(&ftp_handle->op_attr);\n", "        /* free up the client lib stuff \n", "            globus_ftp_client_handle_t          client_h;\n", "        */\n", "    }\n", "\n", "    if(handle->result != GLOBUS_SUCCESS)\n", "    {\n", "        err_obj = globus_error_get(ftp_handle->result);\n", "        globus_object_free(err_obj);\n", "    }\n", "    if(handle->local_url != NULL)\n", "    {\n", "        globus_free(handle->local_url);\n", "    }\n", "\n", "    globus_mutex_destroy(&handle->mutex);\n", "    globus_free(handle->ftp_handles);\n", "    globus_free(handle);\n", "}\n"], "project": "libglobus-xio-gridftp-multicast-dev", "file": "globus_xio_gridftp_multicast_driver.pkl", "function": "xio_l_gmc_handle_destroy"}, {"comment_all": {"comment": "/*\n    NASA/TRMM, Code 910.1.\n    This is the TRMM Office Radar Software Library.\n    Copyright (C) 1996, 1997\n            John H. Merritt\n            Space Applications Corporation\n            Vienna, Virginia\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Library General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Library General Public License for more details.\n\n    You should have received a copy of the GNU Library General Public\n    License along with this library; if not, write to the Free\n    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "depth": 0, "reading_ease": 62.58, "reading_grade": 8.8, "line": 0}, "comment_text": "/*\n    NASA/TRMM, Code 910.1.\n    This is the TRMM Office Radar Software Library.\n    Copyright (C) 1996, 1997\n            John H. Merritt\n            Space Applications Corporation\n            Vienna, Virginia\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Library General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Library General Public License for more details.\n\n    You should have received a copy of the GNU Library General Public\n    License along with this library; if not, write to the Free\n    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "comment_tokens": ["NASATRMM", ",", "Code", "910.1", ".", "This", "is", "the", "TRMM", "Office", "Radar", "Software", "Library", ".", "Copyright", "(", "C", ")", "1996", ",", "1997", "John", "H.", "Merritt", "Space", "Applications", "Corporation", "Vienna", ",", "Virginia", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/*\n", "    NASA/TRMM, Code 910.1.\n", "    This is the TRMM Office Radar Software Library.\n", "    Copyright (C) 1996, 1997\n", "            John H. Merritt\n", "            Space Applications Corporation\n", "            Vienna, Virginia\n", "\n", "    This library is free software; you can redistribute it and/or\n", "    modify it under the terms of the GNU Library General Public\n", "    License as published by the Free Software Foundation; either\n", "    version 2 of the License, or (at your option) any later version.\n", "\n", "    This library is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "    Library General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Library General Public\n", "    License along with this library; if not, write to the Free\n", "    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", "*/\n", "/*\n", " * The PRUNE functions eliminate NULL or non-present (no data present)\n", " * substructures.  This tightens the structures for output.  Development\n", " * was sparked by failing NCAR UF ingest programs; they cannot handle\n", " * 0 sized volumes/sweeps/rays dispite conformity to the UF specification.\n", " *\n", " * These routines free memory that is pruned.\n", " *\n", " * John H. Merritt\n", " * Space Applications Corporation\n", " * December 12, 1995\n", " */\n", "\n", "#include \"rsl.h\"\n", "extern int radar_verbose_flag;\n", "\n", "Ray *RSL_prune_ray(Ray *ray)\n", "{\n", "  if (ray == NULL) return NULL;\n", "  if (ray->h.nbins > 0) return ray;\n", "  RSL_free_ray(ray);\n", "  return NULL;\n", "}\n"], "project": "librsl-dev", "file": "prune.pkl", "function": "RSL_prune_ray"}, {"comment_all": {"comment": "/* If no authenticated user, pass */", "depth": 1, "reading_ease": 32.56, "reading_grade": 10.0, "line": 628}, "comment_text": "/* If no authenticated user, pass */", "comment_tokens": ["If", "no", "authenticated", "user", ",", "pass"], "ccode": ["\n", "\n", "/* Handle a group check triggered by a 'Require external-group foo bar baz'\n", " * directive. */\n", "static authz_status externalgroup_check_authorization(request_rec *r,\n", "\tconst char *require_args, const void *parsed_require_args)\n", "{\n", "    authnz_external_dir_config_rec *dir= (authnz_external_dir_config_rec *)\n", "\tap_get_module_config(r->per_dir_config, &authnz_external_module);\n", "\n", "    authnz_external_svr_config_rec *svr= (authnz_external_svr_config_rec *)\n", "\tap_get_module_config(r->server->module_config, &authnz_external_module);\n", "\n", "    char *user= r->user;\n", "    char *extname= dir->group_name;\n", "    const char *extpath, *extmethod;\n", "    const char *t, *w;\n", "    int code;\n", "\n", "    /* If no authenticated user, pass */\n", "    if ( !user ) return AUTHZ_DENIED_NO_USER;\n", "\n", "    /* If no external authenticator has been configured, pass */\n", "    if ( !extname ) return AUTHZ_DENIED;\n", "\n", "    /* Get the path and method associated with that external */\n", "    if (!(extpath= apr_table_get(svr->group_path, extname)) ||\n", "\t!(extmethod= apr_table_get(svr->group_method,extname)))\n", "    {\n", "\terrno= 0;\n", "\tap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n", "\t    \"invalid GroupExternal keyword (%s)\", extname);\n", "\treturn AUTHZ_DENIED;\n", "    }\n", "\n", "    if (dir->groupsatonce)\n", "    {\n", "\t/* Pass rest of require line to authenticator */\n", "\tcode= exec_external(extpath, extmethod, r, ENV_GROUP, require_args);\n", "\tif (code == 0) return AUTHZ_GRANTED;\n", "    }\n", "    else\n", "    {\n", "\t/* Call authenticator once for each group name on line */\n", "\tt= require_args;\n", "\twhile ((w= ap_getword_conf(r->pool, &t)) && w[0])\n", "\t{\n", "\t    code= exec_external(extpath, extmethod, r, ENV_GROUP, w);\n", "\t    if (code == 0) return AUTHZ_GRANTED;\n", "\t}\n", "    }\n", "\n", "    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n", "\t\"Authorization of user %s to access %s failed. \"\n", "\t\"User not in Required group.\",\n", "    \tr->user, r->uri);\n", "\n", "    return AUTHZ_DENIED;\n", "}\n"], "project": "libapache2-mod-authnz-external", "file": "mod_authnz_external.pkl", "function": "externalgroup_check_authorization"}, {"comment_all": {"comment": "/* for loop, not exists */", "depth": 2, "reading_ease": 92.8, "reading_grade": 1.3, "line": 350}, "comment_text": "/* if findex */\n/* for loop, not exists */\n", "comment_tokens": ["if", "findex", "for", "loop", ",", "not", "exists"], "ccode": ["\n", "/* -------------- VSsetattr ---------------------------------\n", "NAME\n", "   VSsetattr -- Set attribute for a vdata or a field of a\n", "                     vdata\n", "USAGE\n", "   intn VSsetattr(int32 vsid, int32 findex, char *attrname,\n", "                 int32 datatype, int32 count, void * values)\n", "   int32 vsid;     IN: vdata access id\n", "   int32 findex; IN: number determined by assinging each field \n", "                       in a record a number starting with 0; \n", "                       _HDF_VDATA (-1) represents the entire vdata. \n", "   const char *attrname;   IN: name of the attribute\n", "   int32 datatype;   IN: data type of the attribute\n", "   int32 count;      IN: number of values the attribute has\n", "   const void * values;     IN: a buffer which contains the values of \n", "                           the attribute\n", "RETURNS\n", "   Returns SUCCEED if successful, FAIL otherwise.\n", "DESCRIPTION\n", "   Create a vdata to store this attribute.\n", "   If the field already has an attribute with the same name,\n", "   replace the current values with the new values if the \n", "   new data type and order are the same as the current ones;\n", "   changes in data type or order will be considered as errors.\n", "   No limit on max number of attributes. (int32 is the final\n", "   limit.)\n", "-----------------------------------------------------------  */\n", "intn VSsetattr(int32 vsid, int32 findex, const char *attrname,\n", "                 int32 datatype, int32 count, const void * values)\n", "{\n", "     CONSTR(FUNC, \"VSsetattr\");\n", "     vsinstance_t *vs_inst, *attr_inst;\n", "     VDATA    *vs, *attr_vs;\n", "     DYN_VWRITELIST *w, *attr_w;\n", "     intn i;\n", "     int32 nattrs, ret_value = SUCCEED;\n", "     int32 attr_vs_ref, fid, attr_vsid;\n", "\n", "     HEclear();\n", "\n", "     /* check if id is valid vdata */\n", "     if (HAatom_group(vsid) != VSIDGROUP)\n", "        HGOTO_ERROR(DFE_ARGS, FAIL);\n", "\n", "     /* check for null attribute name */\n", "     if (attrname == NULL)\n", "        HGOTO_ERROR(DFE_ARGS, FAIL);\n", "\n", "     /* locate vs' index in vstab */\n", "     if (NULL == (vs_inst = (vsinstance_t *)HAatom_object(vsid)))\n", "        HGOTO_ERROR(DFE_NOVS, FAIL);\n", "     if (NULL == (vs = vs_inst->vs))\n", "        HGOTO_ERROR(DFE_NOVS, FAIL);\n", "\n", "     /* check for read access */\n", "     if (vs->access == 'r')\n", "        HGOTO_ERROR(DFE_BADATTACH, FAIL);\n", "\n", "     w = &(vs->wlist);\n", "     /* check field index */\n", "     if ((findex >= w->n || findex < 0) && (findex != _HDF_VDATA))\n", "        HGOTO_ERROR(DFE_BADFIELDS, FAIL);\n", "     /* if the attr already exist for this field, check data type\n", "        and order */\n", "     nattrs = vs->nattrs;\n", "     fid = vs->f; /* assume attrs are in the same file */\n", "     if (nattrs && vs->alist != NULL)    {\n", "        for (i=0; i<nattrs; i++)  {\n", "            if (vs->alist[i].findex == findex) {\n", "               attr_vs_ref = (int32)vs->alist[i].aref;\n", "               attr_vsid = VSattach(fid, attr_vs_ref, \"w\");\n", "               if (attr_vsid == FAIL)\n", "                  HGOTO_ERROR(DFE_CANTATTACH, FAIL);\n", "               if (NULL == (attr_inst=(vsinstance_t *)HAatom_object(attr_vsid)))\n", "                  HGOTO_ERROR(DFE_NOVS, FAIL);\n", "               if (NULL == (attr_vs = attr_inst->vs))\n", "                  HGOTO_ERROR(DFE_BADPTR, FAIL);\n", "               if (HDstrcmp(attr_vs->vsname, attrname) == 0)  {\n", "                   attr_w = &attr_vs->wlist;\n", "                   if (attr_w->n != 1 || datatype != attr_w->type[0] ||\n", "                      count != attr_w->order[0])   {\n", "                         VSdetach(attr_vsid);\n", "                         HGOTO_ERROR(DFE_BADATTR, FAIL);\n", "                    }  /* type or order changed */\n", "                   /* replace the values  */\n", "                   if (1 != VSwrite(attr_vsid, values, 1, FULL_INTERLACE)) {\n", "                       VSdetach(attr_vsid);\n", "                       HGOTO_ERROR(DFE_VSWRITE, FAIL);\n", "                   }\n", "                   if (FAIL == VSdetach(attr_vsid))\n", "                       HGOTO_ERROR(DFE_CANTDETACH, FAIL);\n", "                   HGOTO_DONE(SUCCEED); \n", "               }  /* attr exist */\n", "               if (FAIL == VSdetach(attr_vsid))\n", "                  HGOTO_ERROR(DFE_CANTDETACH, FAIL);\n", "            } /* if findex */\n", "        }   /* for loop, not exists */ \n", "     }\n", "     /* create a vdata to store the attribute */\n", "     if (FAIL == (attr_vs_ref = VHstoredatam(fid, ATTR_FIELD_NAME, \n", "           values, 1, datatype, attrname,  _HDF_ATTRIBUTE, count)))\n", "        HGOTO_ERROR(DFE_VSCANTCREATE, FAIL);\n", "     /* add this attr to vs->alist */\n", "     if (vs->alist == NULL)    {\n", "        if (vs->nattrs > 0)\n", "           HGOTO_ERROR(DFE_BADATTR, FAIL); \n", "        vs->alist=(vs_attr_t *)HDmalloc(sizeof(vs_attr_t));\n", "     }\n", "     else  \n", "        vs->alist = HDrealloc(vs->alist,(vs->nattrs+1) * sizeof(vs_attr_t));\n", "     if (vs->alist == NULL)  \n", "           HGOTO_ERROR(DFE_NOSPACE, FAIL);\n", "     vs->alist[vs->nattrs].findex = findex;\n", "     vs->alist[vs->nattrs].atag = DFTAG_VH;\n", "     vs->alist[vs->nattrs].aref = (uint16)attr_vs_ref; \n", "     vs->nattrs++;\n", "     /* set attr flag and  version number */\n", "     vs->flags = vs->flags | VS_ATTR_SET;\n", "     vs->version = VSET_NEW_VERSION;\n", "     vs->marked = 1;\n", "     vs->new_h_sz = 1;\n", "done:\n", "    if (ret_value == FAIL)\n", "    { /* Error condition cleanup */\n", "\n", "    } /* end if */\n", "\n", "  /* Normal function cleanup */\n", "  return ret_value;\n", "}  /* VSsetattr */\n"], "project": "libhdf4-doc", "file": "vattr.pkl", "function": "VSsetattr"}, {"comment_all": {"comment": "/*!\n * \\internal\n * \\brief Encode the Amount type.\n *\n * \\param ctrl D channel controller for diagnostic messages or global options.\n * \\param pos Starting position to encode ASN.1 component.\n * \\param end End of ASN.1 encoding data buffer.\n * \\param tag Component tag to identify the encoded component.\n *   The tag should be ASN1_TAG_SEQUENCE unless the caller implicitly\n *   tags it otherwise.\n * \\param amount Amount information to encode.\n *\n * \\retval Start of the next ASN.1 component to encode on success.\n * \\retval NULL on error.\n */", "depth": 0, "reading_ease": 56.11, "reading_grade": 7.1, "line": 77}, "comment_text": "/*!\n * \\internal\n * \\brief Encode the Amount type.\n *\n * \\param ctrl D channel controller for diagnostic messages or global options.\n * \\param pos Starting position to encode ASN.1 component.\n * \\param end End of ASN.1 encoding data buffer.\n * \\param tag Component tag to identify the encoded component.\n *   The tag should be ASN1_TAG_SEQUENCE unless the caller implicitly\n *   tags it otherwise.\n * \\param amount Amount information to encode.\n *\n * \\retval Start of the next ASN.1 component to encode on success.\n * \\retval NULL on error.\n */", "comment_tokens": ["!", "\\internal", "\\brief", "Encode", "the", "Amount", "type", ".", "\\param", "ctrl", "D", "channel", "controller", "for", "diagnostic", "messages", "or", "global", "options", ".", "\\param", "pos", "Starting", "position", "to", "encode", "ASN.1", "component", ".", "\\param", "end", "End", "of", "ASN.1", "encoding", "data", "buffer", ".", "\\param", "tag", "Component", "tag", "to", "identify", "the", "encoded", "component", ".", "The", "tag", "should", "be", "ASN1_TAG_SEQUENCE", "unless", "the", "caller", "implicitly", "tags", "it", "otherwise", ".", "\\param", "amount", "Amount", "information", "to", "encode", ".", "\\retval", "Start", "of", "the", "next", "ASN.1", "component", "to", "encode", "on", "success", ".", "\\retval", "NULL", "on", "error", "."], "ccode": ["\n", "/*!\n", " * \\internal\n", " * \\brief Encode the Amount type.\n", " *\n", " * \\param ctrl D channel controller for diagnostic messages or global options.\n", " * \\param pos Starting position to encode ASN.1 component.\n", " * \\param end End of ASN.1 encoding data buffer.\n", " * \\param tag Component tag to identify the encoded component.\n", " *   The tag should be ASN1_TAG_SEQUENCE unless the caller implicitly\n", " *   tags it otherwise.\n", " * \\param amount Amount information to encode.\n", " *\n", " * \\retval Start of the next ASN.1 component to encode on success.\n", " * \\retval NULL on error.\n", " */\n", "static unsigned char *rose_enc_etsi_AOC_Amount(struct pri *ctrl, unsigned char *pos,\n", "\tunsigned char *end, unsigned tag, const struct roseEtsiAOCAmount *amount)\n", "{\n", "\tunsigned char *seq_len;\n", "\n", "\tASN1_CONSTRUCTED_BEGIN(seq_len, pos, end, tag);\n", "\n", "\tASN1_CALL(pos, asn1_enc_int(pos, end, ASN1_CLASS_CONTEXT_SPECIFIC | 1,\n", "\t\tamount->currency));\n", "\tASN1_CALL(pos, asn1_enc_int(pos, end, ASN1_CLASS_CONTEXT_SPECIFIC | 2,\n", "\t\tamount->multiplier));\n", "\n", "\tASN1_CONSTRUCTED_END(seq_len, pos, end);\n", "\n", "\treturn pos;\n", "}\n"], "project": "libpri1.4", "file": "rose_etsi_aoc.pkl", "function": "rose_enc_etsi_AOC_Amount"}, {"comment_all": {"comment": "//g_assert (!success || str [0] == buf3 [0]);\n", "depth": 3, "reading_ease": 99.23, "reading_grade": 0.9, "line": 114}, "comment_text": "//g_assert (!success || str [0] == buf3 [0]);\n", "comment_tokens": ["g_assert", "(", "!", "success", "||", "str", "[", "0", "]", "==", "buf3", "[", "0", "]", ")", ";"], "ccode": ["\n", "static RESULT\n", "test_module_get_module_filename (void)\n", "{\n", "#if _WIN32\n", "\tconst HMODULE mods [ ] = {NULL, LoadLibraryW (L\"msvcrt.dll\"), (HMODULE)(gssize)-1 };\n", "\n", "\tfor (int i = 0; i < G_N_ELEMENTS (mods); ++i) {\n", "\t\tconst HMODULE mod = mods [i];\n", "\t\tfor (int j = 0; j <= 2; ++j) {\n", "\t\t\twchar_t* str = { 0 };\n", "\t\t\tguint32 length = { 0 };\n", "\t\t\twchar_t buf2 [999] = { 0 };\n", "\t\t\twchar_t buf3 [2] = { 0 };\n", "\t\t\tgboolean success = { 0 };\n", "\t\t\tguint32 length2 = { 0 };\n", "\t\t\tgboolean success2 = { 0 };\n", "\t\t\tguint32 length3 = { 0 };\n", "\t\t\tgboolean success3 = { 0 };\n", "\n", "\t\t\tswitch (j) {\n", "\t\t\tcase 0:\n", "\t\t\t\tsuccess = mono_get_module_filename (mod, &str, &length);\n", "\t\t\t\tlength2 = GetModuleFileNameW (mod, buf2, G_N_ELEMENTS (buf2)); // large buf\n", "\t\t\t\tlength3 = GetModuleFileNameW (mod, buf3, 1); // small buf\n", "\t\t\t\tbreak;\n", "\t\t\tcase 1:\n", "\t\t\t\tsuccess = mono_get_module_filename_ex (GetCurrentProcess (), mods [i], &str, &length);\n", "\t\t\t\tlength2 = GetModuleFileNameExW (GetCurrentProcess (), mod, buf2, G_N_ELEMENTS (buf2)); // large buf\n", "\t\t\t\tlength3 = GetModuleFileNameExW (GetCurrentProcess (), mod, buf3, 1); // small buf\n", "\t\t\t\tbreak;\n", "\t\t\tcase 2:\n", "\t\t\t\tsuccess = mono_get_module_basename (GetCurrentProcess (), mod, &str, &length);\n", "\t\t\t\tlength2 = GetModuleBaseNameW (GetCurrentProcess (), mod, buf2, G_N_ELEMENTS (buf2)); // large buf\n", "\t\t\t\tlength3 = GetModuleBaseNameW (GetCurrentProcess (), mod, buf3, 1); // small buf\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tsuccess2 = length2 && length2 < G_N_ELEMENTS (buf2);\n", "\t\t\tsuccess3 = length3 == 1;\n", "\t\t\tprintf (\"j:%d s:%X s2:%X s3:%X l:%u l2:%u l3:%u str:%X b2:%X b3:%X\\n\",\n", "\t\t\t\tj,\n", "\t\t\t\tsuccess, success2, success3,\n", "\t\t\t\tlength, length2, length3,\n", "\t\t\t\tstr ? str [0] : 0, buf2 [0], buf3 [0]);\n", "\t\t\tg_assert (success == success2);\n", "\t\t\tg_assert (success == success3 || j > 0);\n", "\t\t\tg_assert (!success || str [0] == buf2 [0]);\n", "\t\t\t//g_assert (!success || str [0] == buf3 [0]);\n", "\t\t\tg_assert (length3 == 0 || length3 == 1);\n", "\t\t\tg_assert (length == (success2 ? wcslen (buf2) :0));\n", "\t\t\tg_assert (!success || !wcscmp (str, buf2));\n", "\t\t\tg_assert (!success || str);\n", "\t\t\tif (success)\n", "\t\t\t\tprintf (\"%p %ls %ls %d %d\\n\", mod, str, buf2, length, length2);\n", "\t\t\telse\n", "\t\t\t\tprintf (\"!%p %u\\n\", str, (guint)length);\n", "\t\t\tg_free (str);\n", "\t\t}\n", "\t}\n", "#endif\n", "\treturn OK;\n", "}\n"], "project": "libmono-system-net-http-webrequest4.0-cil", "file": "module.pkl", "function": "test_module_get_module_filename"}, {"comment_all": {"comment": "// deletion\n", "depth": 4, "reading_ease": 36.62, "reading_grade": 8.4, "line": 185}, "comment_text": "// deletion\n// don't do the following if D is the first or the last CIGAR\n", "comment_tokens": ["deletion", "do", "n't", "do", "the", "following", "if", "D", "is", "the", "first", "or", "the", "last", "CIGAR"], "ccode": ["\n", "// Generate CIGAR when the alignment end points are known\n", "uint32_t *bwa_gen_cigar2(const int8_t mat[25], int o_del, int e_del, int o_ins, int e_ins, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM)\n", "{\n", "\tuint32_t *cigar = 0;\n", "\tuint8_t tmp, *rseq;\n", "\tint i;\n", "\tint64_t rlen;\n", "\tkstring_t str;\n", "\tconst char *int2base;\n", "\n", "\tif (n_cigar) *n_cigar = 0;\n", "\tif (NM) *NM = -1;\n", "\tif (l_query <= 0 || rb >= re || (rb < l_pac && re > l_pac)) return 0; // reject if negative length or bridging the forward and reverse strand\n", "\trseq = bns_get_seq(l_pac, pac, rb, re, &rlen);\n", "\tif (re - rb != rlen) goto ret_gen_cigar; // possible if out of range\n", "\tif (rb >= l_pac) { // then reverse both query and rseq; this is to ensure indels to be placed at the leftmost position\n", "\t\tfor (i = 0; i < l_query>>1; ++i)\n", "\t\t\ttmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;\n", "\t\tfor (i = 0; i < rlen>>1; ++i)\n", "\t\t\ttmp = rseq[i], rseq[i] = rseq[rlen - 1 - i], rseq[rlen - 1 - i] = tmp;\n", "\t}\n", "\tif (l_query == re - rb && w_ == 0) { // no gap; no need to do DP\n", "\t\t// UPDATE: we come to this block now... FIXME: due to an issue in mem_reg2aln(), we never come to this block. This does not affect accuracy, but it hurts performance.\n", "\t\tif (n_cigar) {\n", "\t\t\tcigar = malloc(4);\n", "\t\t\tcigar[0] = l_query<<4 | 0;\n", "\t\t\t*n_cigar = 1;\n", "\t\t}\n", "\t\tfor (i = 0, *score = 0; i < l_query; ++i)\n", "\t\t\t*score += mat[rseq[i]*5 + query[i]];\n", "\t} else {\n", "\t\tint w, max_gap, max_ins, max_del, min_w;\n", "\t\t// set the band-width\n", "\t\tmax_ins = (int)((double)(((l_query+1)>>1) * mat[0] - o_ins) / e_ins + 1.);\n", "\t\tmax_del = (int)((double)(((l_query+1)>>1) * mat[0] - o_del) / e_del + 1.);\n", "\t\tmax_gap = max_ins > max_del? max_ins : max_del;\n", "\t\tmax_gap = max_gap > 1? max_gap : 1;\n", "\t\tw = (max_gap + abs((int)rlen - l_query) + 1) >> 1;\n", "\t\tw = w < w_? w : w_;\n", "\t\tmin_w = abs((int)rlen - l_query) + 3;\n", "\t\tw = w > min_w? w : min_w;\n", "\t\t// NW alignment\n", "\t\tif (bwa_verbose >= 4) {\n", "\t\t\tprintf(\"* Global bandwidth: %d\\n\", w);\n", "\t\t\tprintf(\"* Global ref:   \"); for (i = 0; i < rlen; ++i) putchar(\"ACGTN\"[(int)rseq[i]]); putchar('\\n');\n", "\t\t\tprintf(\"* Global query: \"); for (i = 0; i < l_query; ++i) putchar(\"ACGTN\"[(int)query[i]]); putchar('\\n');\n", "\t\t}\n", "\t\t*score = ksw_global2(l_query, query, rlen, rseq, 5, mat, o_del, e_del, o_ins, e_ins, w, n_cigar, &cigar);\n", "\t}\n", "\tif (NM && n_cigar) {// compute NM and MD\n", "\t\tint k, x, y, u, n_mm = 0, n_gap = 0;\n", "\t\tstr.l = str.m = *n_cigar * 4; str.s = (char*)cigar; // append MD to CIGAR\n", "\t\tint2base = rb < l_pac? \"ACGTN\" : \"TGCAN\";\n", "\t\tfor (k = 0, x = y = u = 0; k < *n_cigar; ++k) {\n", "\t\t\tint op, len;\n", "\t\t\tcigar = (uint32_t*)str.s;\n", "\t\t\top  = cigar[k]&0xf, len = cigar[k]>>4;\n", "\t\t\tif (op == 0) { // match\n", "\t\t\t\tfor (i = 0; i < len; ++i) {\n", "\t\t\t\t\tif (query[x + i] != rseq[y + i]) {\n", "\t\t\t\t\t\tkputw(u, &str);\n", "\t\t\t\t\t\tkputc(int2base[rseq[y+i]], &str);\n", "\t\t\t\t\t\t++n_mm; u = 0;\n", "\t\t\t\t\t} else ++u;\n", "\t\t\t\t}\n", "\t\t\t\tx += len; y += len;\n", "\t\t\t} else if (op == 2) { // deletion\n", "\t\t\t\tif (k > 0 && k < *n_cigar - 1) { // don't do the following if D is the first or the last CIGAR\n", "\t\t\t\t\tkputw(u, &str); kputc('^', &str);\n", "\t\t\t\t\tfor (i = 0; i < len; ++i)\n", "\t\t\t\t\t\tkputc(int2base[rseq[y+i]], &str);\n", "\t\t\t\t\tu = 0; n_gap += len;\n", "\t\t\t\t}\n", "\t\t\t\ty += len;\n", "\t\t\t} else if (op == 1) x += len, n_gap += len; // insertion\n", "\t\t}\n", "\t\tkputw(u, &str); kputc(0, &str);\n", "\t\t*NM = n_mm + n_gap;\n", "\t\tcigar = (uint32_t*)str.s;\n", "\t}\n", "\tif (rb >= l_pac) // reverse back query\n", "\t\tfor (i = 0; i < l_query>>1; ++i)\n", "\t\t\ttmp = query[i], query[i] = query[l_query - 1 - i], query[l_query - 1 - i] = tmp;\n", "\n", "ret_gen_cigar:\n", "\tfree(rseq);\n", "\treturn cigar;\n", "}\n"], "project": "bwa", "file": "bwa.pkl", "function": "bwa_gen_cigar2"}, {"comment_all": {"comment": "/****************\n * check whether the secret key is protected.\n * Returns: 0 not protected, -1 on error or the protection algorithm\n *                           -2 indicates a card stub.\n *                           -3 indicates a not-online stub.\n */", "depth": 0, "reading_ease": 62.04, "reading_grade": 6.9, "line": 287}, "comment_text": "/****************\n * check whether the secret key is protected.\n * Returns: 0 not protected, -1 on error or the protection algorithm\n *                           -2 indicates a card stub.\n *                           -3 indicates a not-online stub.\n */", "comment_tokens": ["check", "whether", "the", "secret", "key", "is", "protected", ".", "Returns", ":", "0", "not", "protected", ",", "-1", "on", "error", "or", "the", "protection", "algorithm", "-2", "indicates", "a", "card", "stub", ".", "-3", "indicates", "a", "not-online", "stub", "."], "ccode": ["\n", "/****************\n", " * check whether the secret key is protected.\n", " * Returns: 0 not protected, -1 on error or the protection algorithm\n", " *                           -2 indicates a card stub.\n", " *                           -3 indicates a not-online stub.\n", " */\n", "int\n", "is_secret_key_protected( PKT_secret_key *sk )\n", "{\n", "    return sk->is_protected?\n", "               sk->protect.s2k.mode == 1002? -2 :\n", "               sk->protect.s2k.mode == 1001? -3 : sk->protect.algo : 0;\n", "}\n"], "project": "gpgv1", "file": "seckey-cert.pkl", "function": "is_secret_key_protected"}, {"comment_all": {"comment": "/* Copyright (c) 2002-2018 Dovecot authors, see the included COPYING file */", "depth": 0, "reading_ease": 61.33, "reading_grade": 7.2, "line": 0}, "comment_text": "/* Copyright (c) 2002-2018 Dovecot authors, see the included COPYING file */", "comment_tokens": ["Copyright", "(", "c", ")", "2002-2018", "Dovecot", "authors", ",", "see", "the", "included", "COPYING", "file"], "ccode": ["/* Copyright (c) 2002-2018 Dovecot authors, see the included COPYING file */\n", "\n", "#include \"lib.h\"\n", "#include \"utc-offset.h\"\n", "\n", "#include <sys/time.h>\n", "\n", "int utc_offset(struct tm *tm, time_t t ATTR_UNUSED)\n", "{\n", "#ifdef HAVE_TM_GMTOFF\n", "\treturn (int) (tm->tm_gmtoff/60);\n", "#else\n", "\tstruct tm ltm, gtm;\n", "\tint offset;\n", "\n", "\t/* gmtime() overwrites tm, so we need to copy it elsewhere */\n", "\tltm = *tm;\n", "\ttm = gmtime(&t);\n", "\tgtm = *tm;\n", "\n", "\t/* max offset of 24 hours */\n", "\tif ((ltm.tm_yday < gtm.tm_yday && ltm.tm_year == gtm.tm_year) ||\n", "\t    ltm.tm_year < gtm.tm_year)\n", "\t\toffset = -24 * 60;\n", "\telse if ((ltm.tm_yday > gtm.tm_yday && ltm.tm_year == gtm.tm_year) ||\n", "\t\t ltm.tm_year > gtm.tm_year)\n", "\t\toffset = 24 * 60;\n", "\telse\n", "\t\toffset = 0;\n", "\n", "\toffset += (ltm.tm_hour - gtm.tm_hour) * 60;\n", "\toffset += (ltm.tm_min - gtm.tm_min);\n", "\n", "\t/* restore overwritten tm */\n", "\t*tm = ltm;\n", "\treturn offset;\n", "#endif\n", "}\n"], "project": "dovecot-lmtpd", "file": "utc-offset.pkl", "function": "utc_offset"}, {"comment_all": {"comment": "// in the 24-bit output buffer\n", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 354}, "comment_text": "// 32-bit predictor values are right-aligned but 20-bit output values should be left-aligned\n// in the 24-bit output buffer\n", "comment_tokens": ["32-bit", "predictor", "values", "are", "right-aligned", "but", "20-bit", "output", "values", "should", "be", "left-aligned", "in", "the", "24-bit", "output", "buffer"], "ccode": ["\n", "void copyPredictorTo20( int32_t * in, uint8_t * out, uint32_t stride, int32_t numSamples )\n", "{\n", "\tuint8_t *\top = out;\n", "\tint32_t\t\t\tj;\n", "\n", "\t// 32-bit predictor values are right-aligned but 20-bit output values should be left-aligned\n", "\t// in the 24-bit output buffer\n", "\tfor ( j = 0; j < numSamples; j++ )\n", "\t{\n", "\t\tint32_t\t\tval = in[j];\n", "\n", "\t\top[HBYTE] = (uint8_t)((val >> 12) & 0xffu);\n", "\t\top[MBYTE] = (uint8_t)((val >>  4) & 0xffu);\n", "\t\top[LBYTE] = (uint8_t)((val <<  4) & 0xffu);\n", "\t\top += (stride * 3);\n", "\t}\n", "}\n"], "project": "audiofile-tools", "file": "matrix_dec.pkl", "function": "copyPredictorTo20"}, {"comment_all": {"comment": "/*\n This is our own \"bind\" function.\n GCC links to the correct Unix call \"bind\", but Clang++ takes the C++ \"bind\" function.\n The function below corrects that as follows:\n It is located in this .c file.\n This .c file will be compiled through the C compiler, not the C++ compiler.\n The linker then knows not to link to the C++ \"bind\" function but to the Unix \"bind\" function.\n */", "depth": 0, "reading_ease": 83.25, "reading_grade": 5.0, "line": 23}, "comment_text": "/*\n This is our own \"bind\" function.\n GCC links to the correct Unix call \"bind\", but Clang++ takes the C++ \"bind\" function.\n The function below corrects that as follows:\n It is located in this .c file.\n This .c file will be compiled through the C compiler, not the C++ compiler.\n The linker then knows not to link to the C++ \"bind\" function but to the Unix \"bind\" function.\n */", "comment_tokens": ["This", "is", "our", "own", "``", "bind", "''", "function", ".", "GCC", "links", "to", "the", "correct", "Unix", "call", "``", "bind", "''", ",", "but", "Clang++", "takes", "the", "C++", "``", "bind", "''", "function", ".", "The", "function", "below", "corrects", "that", "as", "follows", ":", "It", "is", "located", "in", "this", ".c", "file", ".", "This", ".c", "file", "will", "be", "compiled", "through", "the", "C", "compiler", ",", "not", "the", "C++", "compiler", ".", "The", "linker", "then", "knows", "not", "to", "link", "to", "the", "C++", "``", "bind", "''", "function", "but", "to", "the", "Unix", "``", "bind", "''", "function", "."], "ccode": ["/*\n", " Copyright (\u00a9) 2003-2019 Teus Benschop.\n", " \n", " This program is free software; you can redistribute it and/or modify\n", " it under the terms of the GNU General Public License as published by\n", " the Free Software Foundation; either version 3 of the License, or\n", " (at your option) any later version.\n", " \n", " This program is distributed in the hope that it will be useful,\n", " but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " GNU General Public License for more details.\n", " \n", " You should have received a copy of the GNU General Public License\n", " along with this program; if not, write to the Free Software\n", " Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " */\n", "\n", "\n", "#include <config.h>\n", "#include <webserver/io.h>\n", "\n", "\n", "/*\n", " This is our own \"bind\" function.\n", " GCC links to the correct Unix call \"bind\", but Clang++ takes the C++ \"bind\" function.\n", " The function below corrects that as follows:\n", " It is located in this .c file.\n", " This .c file will be compiled through the C compiler, not the C++ compiler.\n", " The linker then knows not to link to the C++ \"bind\" function but to the Unix \"bind\" function.\n", " */\n", "int mybind (int socket, const struct sockaddr *address, unsigned int address_len)\n", "{\n", "  return bind (socket, address, address_len);\n", "}\n"], "project": "bibledit-data", "file": "io.pkl", "function": "mybind"}, {"comment_all": {"comment": "/*hilow table            */", "depth": 3, "reading_ease": 77.91, "reading_grade": 2.9, "line": 1827}, "comment_text": "/*decide which is more   */\n/*biased                 */\n/*left and right refer   */\n/*the columns of outputed*/\n/*hilow table            */\n", "comment_tokens": ["decide", "which", "is", "more", "biased", "left", "and", "right", "refer", "the", "columns", "of", "outputed", "hilow", "table"], "ccode": ["\n", "/************ highlow          ********************************************/\n", "/* The codon usage of the two groups on either end of the axis is assigned*/\n", "/* to low and high ... perhaps these would be better called left and right*/\n", "/* as when they are passed to this function it is not know which group is */\n", "/* lowly or highly biased. This is decided within highlow, by calculating */\n", "/* the enc (a measure of bias) for each group and assigning the group with*/\n", "/* the lowest enc as the higher biased genes. This works if the trend     */\n", "/* represented by axis1 is truly selection for optimal translation        */\n", "/* IT'S THE USERS RESPONSIBILITY TO ASSERTAIN IF THIS IS VALID            */\n", "/* This information is used to identify optimal codons, as well as        */\n", "/* calculate  putative CAI adaptive values and for the Chi squared con-   */\n", "/* tingency test, used to identify the optimal and non-optimal codons     */\n", "/**************************************************************************/\n", "\n", "void highlow(long int *low, long int *high, FILE * ssummary)\n", "{\n", "\n", "   int            *last_row, icode, outer,i,j,x ;\n", "\n", "   long int       *aa_low, *aa_high, *left, *right, *left_aa, *right_aa;\n", "   long int       *highest_x;\n", "   long int        right_tot = 0, left_tot = 0;\n", "\n", "   float           enc_low, enc_high;\n", "   float           a, b, c, d, e, f, g, h, total, hr, br, *x2;\n", "   float           w;\n", "   char           *flag, sp;\n", "\n", "   FILE           *fcai=NULL,*fhilo = NULL, *ffop = NULL;\n", "   FILE           *fcbi=NULL;\n", "\n", "   /*calloc to the pointers the required storage                          */\n", "   if ((fhilo = open_file(\"\", \"hilo.coa\", \"w\", FALSE)) == NULL)\n", "      my_exit(1, \"hilo.coa\");\n", "   if ((ffop = open_file(\"\", \"fop.coa\", \"w\", FALSE)) == NULL)\n", "      my_exit(1, \"fop.coa\");\n", "   if ((aa_low = (long int *) calloc(22, sizeof(long int))) == NULL)\n", "      my_exit(3, \"aa_low\");\n", "   if ((aa_high = (long int *) calloc(22, sizeof(long int))) == NULL)\n", "      my_exit(3, \"aa_high\");\n", "   if ((highest_x = (long int *) calloc(22, sizeof(long int))) == NULL)\n", "      my_exit(3, \"last_row\");      \n", "   if ((x2 = (float *) calloc(65, sizeof(float))) == NULL)\n", "      my_exit(3, \"x2\");\n", "   if ((flag = (char *) calloc(65, sizeof(char))) == NULL)\n", "      my_exit(3, \"flag\");\n", "   if ((last_row = (int *) calloc(65, sizeof(int))) == NULL)\n", "      my_exit(3, \"last_row\");\n", "   \n", "  \n", "   if (pm->seq_format=='M')\n", "      sp = pm->seperator;\n", "   else\n", "      sp = '\\t';\n", "\n", "   /* initialize the various arrays                                       */\n", "   for (x = 0; x < 4; x++) last_row[x] = 0;\n", "\n", "   for (x = 0; x < 22; x++){\n", "      highest_x[x]=0;\n", "      aa_low   [x]=0;\n", "      aa_high  [x]=0;\n", "      }\n", "   for (x = 0; x <65 ; x++) {\n", "      x2      [x]= (float) 0.0;\n", "      flag    [x]=0;   \n", "      last_row[x]=0;\n", "      }\n", "      \n", "      \n", "   /*count the amino acid usage for the two datasets, initially we only   */\n", "   /*have the codon usage of the two groups                               */\n", "   for (i = 1; i < 65; i++) {\n", "      aa_low[pcu->ca[i]] += low[i];\n", "      aa_high[pcu->ca[i]] += high[i];\n", "      flag[i] = ' ';                /*flag is used to identify opt codons */\n", "   }\n", "\n", "   enc_low = enc_out(fhilo, low, aa_low);         /*calc enc for each  of */\n", "   enc_high = enc_out(fhilo, high, aa_high);      /*datasets              */\n", "   fprintf(fhilo, \"\\n\");\n", "\n", "   fprintf(ssummary, \"\\nenc_left %f enc_right %f\\n\", enc_low, enc_high);\n", "\n", "   for (i = 1; i < 65; i++) {\n", "      if (*(ds + i) == 1 || pcu->ca[i] == 11)     /*skip stop and nonsynon*/\n", "     continue;\n", "\n", "      if (enc_low < enc_high) {                  /*decide which is more   */\n", "        left = low;                              /*biased                 */\n", "        right = high;                            /*left and right refer   */\n", "        left_aa = aa_low;                        /*the columns of outputed*/\n", "        right_aa = aa_high;                      /*hilow table            */\n", "        a = (float) low[i];\n", "        b = (float) high[i];\n", "        g = (float) aa_low[pcu->ca[i]];\n", "        h = (float) aa_high[pcu->ca[i]];\n", "      } else {\n", "        left = high;\n", "        right = low;\n", "        left_aa = aa_high;\n", "        right_aa = aa_low;\n", "        a = (float) high[i];\n", "        b = (float) low[i];\n", "        g = (float) aa_high[pcu->ca[i]];\n", "        h = (float) aa_low[pcu->ca[i]];\n", "     }\n", "      /* calculate the chi squared contingency value                      */\n", "      c = g - a;\n", "      d = h - b;\n", "      e = a + b;\n", "      f = c + d;\n", "      total = a + b + c + d;\n", "      if (e * f * h * g)\n", "     x2[i] = ((a * d - c * b) * (a * d - c * b)) * total / (e * f * g * h);\n", "      else\n", "     x2[i] = (float) -99.0;                   /*if 0 assign nonsense value*/\n", "\n", "      if (g * h) {\n", "     hr = a / g;\n", "     br = b / h;\n", "     if (hr > br && x2[i] > 6.635)            /* if significant at p<.99  */\n", "        flag[i] = '*';\n", "     else if (hr > br && x2[i] > 3.841)       /* if significant at p<0.05 */\n", "        flag[i] = '@';\n", "      }\n", "   }\n", "   fprintf(ssummary, \"Chi squared contingency test of genes from both\\n\"\n", "                     \"extremes of axis 1\\n\");\n", "/* this created the hi-low codon usage table                              */\n", "/* Sample output truncated (***********************************************/\n", "/*Asp   GAU   0.10 ( 10) 1.68 ( 53)   Gly   GGU   0.21 ( 12) 0.85 ( 11)   */   \n", "/*      GAC*  1.90 (184) 0.32 ( 10)         GGC*  3.13 (176) 2.00 ( 26)   */   \n", "/*Glu   GAA   0.00 (  0) 1.34 ( 55)         GGA   0.05 (  3) 0.69 (  9)   */  \n", "/*      GAG*  2.00 (255) 0.66 ( 27)         GGG   0.60 ( 34) 0.46 (  6)   */   \n", "/*                                                                        */\n", "/*                                                                        */\n", "/*        Number of codons in high bias dataset 2825                      */\n", "/*        Number of codons in low  bias dataset 1194                      */\n", "/*Note: high bias was assigned to the dataset with the lower average Nc   */\n", "/*NO Chi could be calculated for UGU                                      */\n", "/*Codon UUC (Phe) chi value was 70.175                                    */\n", "/*Codon UCC (Ser) chi value was 48.030                                    */\n", "/*Codon UAC (Tyr) chi value was 86.069                                    */\n", "/**************************************************************************/ \n", "\n", "   for (outer = 1; outer <= 3; outer += 2) {\n", "      for (x = 1; x < 5; x++) {\n", "      for (j = 1; j < 5; j++) {\n", "        icode = ((x - 1) * 16) + ((j - 1) * 4) + outer; \n", "\n", "\n", "        for (i = icode; i <= icode + 1; i++) {   /*loop twice             */\n", "            /* if the previous entry in this column codes for the same AA */\n", "            if (last_row[i % 2] != pcu->ca[i]) {\n", "\t          fprintf(fhilo, \"%s%c%s%c%c\", paa->aa3[pcu->ca[i]],\n", "\t\t              sp, paa->cod[i], flag[i], sp);\n", "\t          fprintf(ssummary, \"%s%c%s%c%c\", paa->aa3[pcu->ca[i]],\n", "\t\t              sp, paa->cod[i], flag[i], sp);\n", "\t        } else {                       \n", "\t           fprintf(fhilo, \"%c%s%c%c\", sp, paa->cod[i], flag[i], sp);\n", "\t           fprintf(ssummary, \"   %c%s%c%c\",sp,paa->cod[i],flag[i],sp);\n", "\t        }\n", "            /* write out Codon usage, RSCU and significance for both data */\n", "\t       fprintf(fhilo, \"%4.2f (%3i) %4.2f (%3i)%c\",\n", "\t\t       (left[i]) ?\n", "\t\t       ((float) left[i] / (float) left_aa[pcu->ca[i]])\n", "\t\t       * (float) (*(ds + i))\n", "\t\t       : 0.0,\n", "\t\t       (int) left[i],\n", "\t\t       (right[i]) ?\n", "\t\t       ((float) right[i] / (float) right_aa[pcu->ca[i]])\n", "\t\t       * (float) (*(ds + i))\n", "\t\t       : 0.0,\n", "\t\t       (int) right[i],sp);               /*       end of fprintf  */\n", "\t      fprintf(ssummary, \"%4.2f (%3i) %4.2f (%3i)%c\",\n", "\t\t       (left[i]) ?\n", "\t\t       ((float) left[i] / (float) left_aa[pcu->ca[i]])\n", "\t\t       * (float) (*(ds + i))\n", "\t\t       : 0.0,\n", "\t\t       (int) left[i],\n", "\t\t       (right[i]) ?\n", "\t\t       ((float) right[i] / (float) right_aa[pcu->ca[i]])\n", "\t\t       * (float) (*(ds + i))\n", "\t\t       : 0.0,\n", "\t\t       (int) right[i],sp);               /*        end of fprintf */\n", "          last_row[i % 2] = pcu->ca[i];          /* remember the last row */\n", "        }\n", "        fprintf(fhilo, \"\\n\");\n", "        fprintf(ssummary, \"\\n\");\n", "       }\n", "       fprintf(ssummary, \"\\n\");\n", "       fprintf(fhilo, \"\\n\");\n", "      }\n", "      fprintf(ssummary, \"\\n\");\n", "      fprintf(fhilo, \"\\n\");\n", "   }\n", "\n", "   for (i = 1; i < 65; i++) {                    /* count both datasets   */\n", "      right_tot += right[i];\n", "      left_tot += left[i];\n", "   }\n", "\n", "\n", "   fprintf(fhilo, \n", "       \"\\tNumber of codons in high bias dataset %li\\n\", left_tot);\n", "   fprintf(fhilo, \n", "       \"\\tNumber of codons in low  bias dataset %li\\n\", right_tot);\n", "   fprintf(fhilo, \n", "       \"Note: high bias was assigned to the dataset with the lower\"\n", "       \" average Nc\\n\");\n", "\n", "   fprintf(ssummary, \n", "       \"\\tNumber of codons in high bias dataset %li\\n\", left_tot);\n", "   fprintf(ssummary, \n", "       \"\\tNumber of codons in low  bias dataset %li\\n\", right_tot);\n", "   fprintf(ssummary, \n", "       \"Note high bias was assigned to the genes with the lower\"\n", "       \" overall Nc\\n\");\n", "\n", "   /* now printout the Chi Squared values for each significant comparison */\n", "   for (i = 1; i < 65; i++) {\n", "      if (flag[i] == '*' || flag[i] == '@') {\n", "     fprintf(fhilo, \"Codon %s (%s) chi value was %.3f\\n\", paa->cod[i],\n", "         paa->aa3[pcu->ca[i]], x2[i]);\n", "     fprintf(ssummary, \"Codon %s (%s) chi value was %.3f\\n\", paa->cod[i],\n", "         paa->aa3[pcu->ca[i]], x2[i]);\n", "      }\n", "      if (x2[i] == -99)       /* there were no codons in one of the groups*/\n", "     fprintf(fhilo, \"NO Chi could be calculated for %s\\n\", paa->cod[i]);\n", "   }\n", "   fprintf(fhilo, \"\\n\");\n", "   fprintf(ssummary, \"\\n\");\n", "\n", "   /* now write out the optimal codons as PUTATIVELY identified by codonW */\n", "   fprintf(ssummary, \"These are the PUTATIVE optimal codons\\n\"\n", "     \"This is the format required for Menu 4 option 2 (Fop) \"\n", "     \"and option 3 (CBI)\\n\"\n", "     \"This data is also duplicated in the files \\\"fop.coa\\\" \"\n", "     \"and \\\"cbi.coa\\\"\\n\"\n", "     \"The format of these files is that required for input \"\n", "     \"as a personal choice\\n\"\n", "     \"of optimal codons for these indexes\\n\");\n", "\n", "   for (i = 1; i < 65; i++) {\n", "      if( left[i] > highest_x[pcu->ca[i]])    /* used for calculating CAI */\n", "                           highest_x[pcu->ca[i]]=left[i]; \n", "      \n", "      if (*(ds + i) == 1 || pcu->ca[i] == 11) {\n", "     fprintf(ffop, \"2\");\n", "     fprintf(ssummary, \"2\");\n", "      } else if (flag[i] == '*') {\n", "     fprintf(ffop, \"3\");\n", "     fprintf(ssummary, \"3\");\n", "      } else if (((left[i]) ?\n", "          ((float) left[i] / (float) left_aa[pcu->ca[i]])\n", "          * (float) (*(ds + i))\n", "          : 0.0) < 0.1) {                        /* if RSCU <0.1 its rare */\n", "     fprintf(ffop, \"1\");\n", "     fprintf(ssummary, \"1\");\n", "      } else {\n", "     fprintf(ffop, \"2\");\n", "     fprintf(ssummary, \"2\");\n", "      }\n", "\n", "      if (!(i % 16)) {                           /* handle line wrapping  */ \n", "     fprintf(ffop, \"\\n\");\n", "     fprintf(ssummary, \"\\n\");\n", "      } else {\n", "     fprintf(ffop, \",\");\n", "     fprintf(ssummary, \",\");\n", "      }\n", "   }\n", "   fileclose(&ffop);                              /*   close the Fop file  */\n", "  \n", "   if ((fcbi = open_file(\"\", \"cbi.coa\", \"w\", FALSE)) == NULL)\n", "      my_exit(1, \"cbi.coa\");                     /*    open cbi.coa       */\n", "      \n", " for (i = 1; i < 65; i++) {                      /* write values 2 cbi.coa*/\n", "\n", "  if (flag[i] == '*')                       /* Only report optimal codons */\n", "     fprintf(fcbi, \"3\");\n", "  else\n", "     fprintf(fcbi, \"2\");                    /* ignore non optimal codons  */\n", "\n", "  if (!(i % 16)) \n", "     fprintf(fcbi, \"\\n\");\n", "  else\n", "     fprintf(fcbi, \",\");\n", "    \n", " }\n", "   \n", "  fileclose(&fcbi);   \n", "   \n", "   fprintf(ssummary, \"\\n\\n\");\n", "    \n", "   /* now calculate and write out CAI adaptiveness values                 */\n", "   fprintf(ssummary, \"These are PUTATIVE CAI adaptiveness values \"\n", "     \"identified by this programme\\n\"\n", "     \"This data is also duplicated in the file \\\"cai.coa\\\"\\n\"\n", "     \"The format of this file is compatible with the format\\n\"\n", "     \"of the file used to input a personal selection of CAI values\\n\"\n", "     \"That is, the format required for Menu 4 option 1\\n\"\n", "     \"cai.coa\\tinput file to be used for CAI calculations\\n\"\n", "     \"\\n\\nCod AA    Xi\\tWi\\t\\tCod AA    Xi\\tWi\\n\"); \n", "  \n", "   \n", "   if ((fcai = open_file(\"\", \"cai.coa\", \"w\", FALSE)) == NULL)\n", "      my_exit(1, \"cai.coa\"); \n", "  \n", "   for (i = 1, x = TRUE ; i < 65 && x ; i++) {\n", "    \n", "    /* if a stop or a non-synonymous codon w = 1                          */\n", "    if (*(ds + i) == 1 || pcu->ca[i] == 11) {  \n", "                    fprintf(fcai, \"1.0000000 \\n\");\n", "                    fprintf(ssummary,\"%s %s %6.1f %9.7f\\t\", \n", "                      paa->cod[i], \n", "                      paa->aa3[pcu->ca[i]],\n", "                      (float) left[i], 1.0000000); \n", "    } else  if ( highest_x[pcu->ca[i]] ) {\n", "      \n", "      /* if a codon is absent then adjust its frequecy to 0.5             */\n", "      if ( left[i] ) \n", "       w= (float) left[i]/ (float) highest_x[pcu->ca[i]];\n", "      else\n", "       w= (float) 0.5   / (float) highest_x[pcu->ca[i]];\n", "      fprintf(fcai, \"%9.7f \\n\", w);                    /* output CAI W    */\n", "      fprintf(ssummary,\"%s %s %6.1f %9.7f\\t\", \n", "             paa->cod[i], paa->aa3[pcu->ca[i]],\n", "             (left[i]) ? (float) left[i]:0.5 , w); \n", "    /* either strange amino acid composition or data sets where too small */               \n", "    } else {                            \n", "      fprintf(pm->my_err, \n", "          \"WARNING An attempt to calculate CAI relative \"\n", "          \"adaptivnesss FAILED\\n no %s amino acids found\"\n", "          \" in the high bias dataset \\n\",paa->aa3[pcu->ca[i]]);    \n", "      fprintf(ssummary, \n", "          \"\\nWARNING An attempt to calculate CAI relative adaptiveness \"\n", "          \"FAILED\\n no %s amino acids found in the high bias dataset \\n\",\n", "          paa->aa3[pcu->ca[i]]);\n", "      x=FALSE;\n", "   }  \n", "   if( !(i%2)) fprintf (ssummary  , \"\\n\");\n", "   } /* matches for (i = 1, x = TRUE ; i < 65 && x ; i++)                 */\n", "     \n", "   fileclose(&fcai);                              /* close files           */\n", "   fileclose(&fhilo);\n", "   free(aa_low);                                 /* free memory           */\n", "   free(aa_high);\n", "   free(highest_x);\n", "   free(x2);\n", "   free(flag);\n", "   free(last_row);\n", "   return;\n", "}\n"], "project": "codonw", "file": "codon_us.pkl", "function": "highlow"}, {"comment_all": {"comment": "/**\n * DBUS_TYPE_G_CONNECTION:\n *\n * Expands to a function call returning the boxed #GType of a #DBusGConnection.\n *\n * Returns: the GLib type\n *\n * Deprecated: New code should use GDBus instead.\n */", "depth": 0, "reading_ease": 50.84, "reading_grade": 9.2, "line": 303}, "comment_text": "/**\n * DBUS_TYPE_G_CONNECTION:\n *\n * Expands to a function call returning the boxed #GType of a #DBusGConnection.\n *\n * Returns: the GLib type\n *\n * Deprecated: New code should use GDBus instead.\n */", "comment_tokens": ["DBUS_TYPE_G_CONNECTION", ":", "Expands", "to", "a", "function", "call", "returning", "the", "boxed", "#", "GType", "of", "a", "#", "DBusGConnection", ".", "Returns", ":", "the", "GLib", "type", "Deprecated", ":", "New", "code", "should", "use", "GDBus", "instead", "."], "ccode": ["\n", "/**\n", " * DBUS_TYPE_G_CONNECTION:\n", " *\n", " * Expands to a function call returning the boxed #GType of a #DBusGConnection.\n", " *\n", " * Returns: the GLib type\n", " *\n", " * Deprecated: New code should use GDBus instead.\n", " */\n", "GType\n", "dbus_g_connection_get_g_type (void)\n", "{\n", "  static GType our_type = 0;\n", "  \n", "  if (our_type == 0)\n", "    our_type = g_boxed_type_register_static (\"DBusGConnection\",\n", "                                             (GBoxedCopyFunc) dbus_g_connection_ref,\n", "                                             (GBoxedFreeFunc) dbus_g_connection_unref);\n", "\n", "  return our_type;\n", "}\n"], "project": "libdbus-glib-1-dev", "file": "dbus-glib.pkl", "function": "dbus_g_connection_get_g_type"}, {"comment_all": {"comment": "/*\n DBG(printf(\"young heap from %p to %p\\n\", caml_young_start, caml_young_end));\n DBG(printf(\"old heap from %p to %p\\n\", caml_heap_start, caml_heap_end));\n */", "depth": 1, "reading_ease": 38.32, "reading_grade": 11.9, "line": 405}, "comment_text": "/*\n DBG(printf(\"young heap from %p to %p\\n\", caml_young_start, caml_young_end));\n DBG(printf(\"old heap from %p to %p\\n\", caml_heap_start, caml_heap_end));\n */", "comment_tokens": ["DBG", "(", "printf", "(", "``", "young", "heap", "from", "%", "p", "to", "%", "p\\n", "''", ",", "caml_young_start", ",", "caml_young_end", ")", ")", ";", "DBG", "(", "printf", "(", "``", "old", "heap", "from", "%", "p", "to", "%", "p\\n", "''", ",", "caml_heap_start", ",", "caml_heap_end", ")", ")", ";"], "ccode": ["\n", "\n", "int c_objsize(value v, value scan, value reach, size_t* headers, size_t* data, size_t* depth)\n", " {\n", " value head;\n", " int reached = 0;\n", " colors_init();\n", " rle_init();\n", " /*\n", " DBG(printf(\"young heap from %p to %p\\n\", caml_young_start, caml_young_end));\n", " DBG(printf(\"old heap from %p to %p\\n\", caml_heap_start, caml_heap_end));\n", " */\n", " DBG(printf(\"COL writing\\n\"));\n", "\n", " head = scan;\n", " while( COND_BLOCK(head) ) {\n", "\tvalue v = Field(head,0);\n", "\theader_t hd = Hd_val(v);\n", "\tint col = Colornum_hd(hd);\n", "\thead = Field(head,1);\n", "\tif( col == Col_blue ) continue;\n", "\twritecolor(col);\n", "\tHd_val(v) = Coloredhd_hd(hd, Col_blue);\n", " }\n", "\n", " acc_data = 0;\n", " acc_hdrs = 0;\n", " acc_depth = 0;\n", " if ( COND_BLOCK(v) && Colornum_hd(Hd_val(v)) != Col_blue )\n", "  {\n", "  c_rec_objsize(v, 0);\n", "  };\n", "  if( headers != NULL ) {\n", " *headers = acc_hdrs;\n", " *data = acc_data;\n", " *depth = acc_depth;\n", "  }\n", "\n", " rle_write_flush();\n", " DBG(printf(\"COL reading\\n\"));\n", " rle_init();\n", "\n", "  head = scan;\n", " while( COND_BLOCK(head) ) {\n", "\tvalue v = Field(head,0);\n", "\tint col;\n", "\thead = Field(head,1);\n", "\tif( Colornum_hd(Hd_val(v)) != Col_blue ) continue;\n", "\tcol = readcolor();\n", "\tHd_val(v) = Coloredhd_hd(Hd_val(v), col);\n", " }\n", "\n", "  while( COND_BLOCK(reach) ) {\n", "\t  value v = Field(reach,0);\n", "\t  if( Colornum_hd(Hd_val(v)) == Col_blue ) {\n", "\t\treached = 1;\n", "\t\tbreak;\n", "\t  }\n", "\t  reach = Field(reach,1);\n", "  }\n", "\n", " if ( COND_BLOCK(v) && Colornum_hd(Hd_val(v)) == Col_blue )\n", "  {\n", "  restore_colors(v);\n", "  };\n", " rle_read_flush();\n", "\n", "#if DUMP\n", " printf(\"objsize: bytes for rle data = %i\\n\", colors_readindex/8);\n", " fflush(stdout);\n", "\n", "  {\n", "  FILE* f = fopen(\"colors-dump\", \"w\");\n", "  fwrite(colors, 1, colors_readindex/8, f);\n", "  fclose(f);\n", "  };\n", "#endif\n", "\n", " colors_deinit();\n", " DBG(printf(\"c_objsize done.\\n\"));\n", "\n", " return reached;\n", " }\n"], "project": "haxe", "file": "c_objsize.pkl", "function": "c_objsize"}, {"comment_all": {"comment": "/*\n * utilHashtable.c\n *\n * (C) Copyright IBM Corp. 2005\n *\n * THIS FILE IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC LICENSE\n * (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS FILE\n * CONSTITUTES RECIPIENTS ACCEPTANCE OF THE AGREEMENT.\n *\n * You can obtain a current copy of the Eclipse Public License from\n * http://www.opensource.org/licenses/eclipse-1.0.php\n *\n * Author:        Adrian Schuur <schuur@de.ibm.com>\n *\n * Description:\n *\n * Hashtable factory support.\n *\n */", "depth": 0, "reading_ease": 45.42, "reading_grade": 9.2, "line": 11}, "comment_text": "/*\n * utilHashtable.c\n *\n * (C) Copyright IBM Corp. 2005\n *\n * THIS FILE IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC LICENSE\n * (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS FILE\n * CONSTITUTES RECIPIENTS ACCEPTANCE OF THE AGREEMENT.\n *\n * You can obtain a current copy of the Eclipse Public License from\n * http://www.opensource.org/licenses/eclipse-1.0.php\n *\n * Author:        Adrian Schuur <schuur@de.ibm.com>\n *\n * Description:\n *\n * Hashtable factory support.\n *\n */", "comment_tokens": ["utilHashtable.c", "(", "C", ")", "Copyright", "IBM", "Corp.", "2005", "THIS", "FILE", "IS", "PROVIDED", "UNDER", "THE", "TERMS", "OF", "THE", "ECLIPSE", "PUBLIC", "LICENSE", "(", "``", "AGREEMENT", "''", ")", ".", "ANY", "USE", ",", "REPRODUCTION", "OR", "DISTRIBUTION", "OF", "THIS", "FILE", "CONSTITUTES", "RECIPIENTS", "ACCEPTANCE", "OF", "THE", "AGREEMENT", ".", "You", "can", "obtain", "a", "current", "copy", "of", "the", "Eclipse", "Public", "License", "from", "http", ":", "www.opensource.orglicenseseclipse-1.0.php", "Author", ":", "Adrian", "Schuur", "<", "schuur", "@", "de.ibm.com", ">", "Description", ":", "Hashtable", "factory", "support", "."], "ccode": ["\n", "/*\n", " * utilHashtable.c\n", " *\n", " * (C) Copyright IBM Corp. 2005\n", " *\n", " * THIS FILE IS PROVIDED UNDER THE TERMS OF THE ECLIPSE PUBLIC LICENSE\n", " * (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS FILE\n", " * CONSTITUTES RECIPIENTS ACCEPTANCE OF THE AGREEMENT.\n", " *\n", " * You can obtain a current copy of the Eclipse Public License from\n", " * http://www.opensource.org/licenses/eclipse-1.0.php\n", " *\n", " * Author:        Adrian Schuur <schuur@de.ibm.com>\n", " *\n", " * Description:\n", " *\n", " * Hashtable factory support.\n", " *\n", " */\n", "\n", "#include \"utilft.h\"\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <ctype.h>\n", "#include <string.h>\n", "\n", "extern void    *HashTableCreate(long numOfBuckets);\n", "extern Util_HashTable_FT *UtilHashTableFT;\n", "\n", "static unsigned long\n", "charHashFunction(const void *key)\n", "{\n", "  const unsigned char *str = (const unsigned char *) key;\n", "  unsigned long   hashValue = 0;\n", "  int             i;\n", "\n", "  for (i = 0; str[i] != '\\0'; i++)\n", "    hashValue = hashValue * 37 + str[i];\n", "\n", "  return hashValue;\n", "}\n"], "project": "libsfcutil0-dev", "file": "utilHashtable.pkl", "function": "charHashFunction"}, {"comment_all": {"comment": "/*   Foma: a finite-state toolkit and library.                                 */", "depth": 0, "reading_ease": 56.93, "reading_grade": 6.8, "line": 0}, "comment_text": "/*   Foma: a finite-state toolkit and library.                                 */\n/*   Copyright \u00a9 2008-2015 Mans Hulden                                         */\n", "comment_tokens": ["Foma", ":", "a", "finite-state", "toolkit", "and", "library", ".", "Copyright", "\u00a9", "2008-2015", "Mans", "Hulden"], "ccode": ["/*   Foma: a finite-state toolkit and library.                                 */\n", "/*   Copyright \u00a9 2008-2015 Mans Hulden                                         */\n", "\n", "/*   This file is part of foma.                                                */\n", "\n", "/*   Licensed under the Apache License, Version 2.0 (the \"License\");           */\n", "/*   you may not use this file except in compliance with the License.          */\n", "/*   You may obtain a copy of the License at                                   */\n", "\n", "/*      http://www.apache.org/licenses/LICENSE-2.0                             */\n", "\n", "/*   Unless required by applicable law or agreed to in writing, software       */\n", "/*   distributed under the License is distributed on an \"AS IS\" BASIS,         */\n", "/*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  */\n", "/*   See the License for the specific language governing permissions and       */\n", "/*   limitations under the License.                                            */\n", "\n", "#include <stdlib.h>\n", "#include \"foma.h\"\n", "\n", "struct fsm *fsm_lower(struct fsm *net) {\n", "    struct fsm_state *fsm;\n", "    int i, prevstate, out;\n", "    fsm = net->states;\n", "    fsm_state_init(sigma_max(net->sigma));\n", "    prevstate = -1;\n", "    for (i = 0; (fsm+i)->state_no != - 1; prevstate = (fsm+i)->state_no, i++) {\n", "        if (prevstate != -1 && prevstate != (fsm+i)->state_no) {\n", "            fsm_state_end_state();\n", "        }\n", "        if (prevstate != (fsm+i)->state_no) {\n", "            fsm_state_set_current_state((fsm+i)->state_no, (fsm+i)->final_state, (fsm+i)->start_state);\n", "        }\n", "        if ((fsm+i)->target != -1) {\n", "            out = ((fsm+i)->out == UNKNOWN) ? IDENTITY : (fsm+i)->out;\n", "            fsm_state_add_arc((fsm+i)->state_no, out, out, (fsm+i)->target, (fsm+i)->final_state, (fsm+i)->start_state);\n", "        }\n", "    }\n", "    fsm_state_end_state();\n", "    xxfree(net->states);\n", "    fsm_state_close(net);\n", "    sigma_cleanup(net,0);\n", "    return(net);\n", "}\n"], "project": "foma", "file": "extract.pkl", "function": "fsm_lower"}, {"comment_all": {"comment": "/* We haven't yet run GC_init_parallel.  That means     */", "depth": 3, "reading_ease": 81.29, "reading_grade": 3.7, "line": 164}, "comment_text": "/* We haven't yet run GC_init_parallel.  That means     */\n/* we also aren't locking, so this is fairly cheap.     */\n", "comment_tokens": ["We", "have", "n't", "yet", "run", "GC_init_parallel", ".", "That", "means", "we", "also", "are", "n't", "locking", ",", "so", "this", "is", "fairly", "cheap", "."], "ccode": ["\n", "#ifdef GC_ASSERTIONS\n", "  /* Defined in pthread_support.c or win32_threads.c. */\n", "  GC_bool GC_is_thread_tsd_valid(void *tsd);\n", "#endif\n", "\n", "GC_API GC_ATTR_MALLOC void * GC_CALL GC_malloc_kind(size_t bytes, int knd)\n", "{\n", "    size_t granules;\n", "    void *tsd;\n", "    void *result;\n", "\n", "#   if MAXOBJKINDS > THREAD_FREELISTS_KINDS\n", "      if (EXPECT(knd >= THREAD_FREELISTS_KINDS, FALSE)) {\n", "        return GC_malloc_kind_global(bytes, knd);\n", "      }\n", "#   endif\n", "#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_WIN32_SPECIFIC)\n", "    {\n", "      GC_key_t k = GC_thread_key;\n", "\n", "      if (EXPECT(0 == k, FALSE)) {\n", "        /* We haven't yet run GC_init_parallel.  That means     */\n", "        /* we also aren't locking, so this is fairly cheap.     */\n", "        return GC_malloc_kind_global(bytes, knd);\n", "      }\n", "      tsd = GC_getspecific(k);\n", "    }\n", "#   else\n", "      if (!EXPECT(keys_initialized, TRUE))\n", "        return GC_malloc_kind_global(bytes, knd);\n", "      tsd = GC_getspecific(GC_thread_key);\n", "#   endif\n", "#   if !defined(USE_COMPILER_TLS) && !defined(USE_WIN32_COMPILER_TLS)\n", "      if (EXPECT(0 == tsd, FALSE)) {\n", "        return GC_malloc_kind_global(bytes, knd);\n", "      }\n", "#   endif\n", "    GC_ASSERT(GC_is_initialized);\n", "    GC_ASSERT(GC_is_thread_tsd_valid(tsd));\n", "    granules = ROUNDED_UP_GRANULES(bytes);\n", "    GC_FAST_MALLOC_GRANS(result, granules,\n", "                         ((GC_tlfs)tsd) -> _freelists[knd], DIRECT_GRANULES,\n", "                         knd, GC_malloc_kind_global(bytes, knd),\n", "                         (void)(knd == PTRFREE ? NULL\n", "                                               : (obj_link(result) = 0)));\n", "#   ifdef LOG_ALLOCS\n", "      GC_log_printf(\"GC_malloc_kind(%lu, %d) returned %p, recent GC #%lu\\n\",\n", "                    (unsigned long)bytes, knd, result,\n", "                    (unsigned long)GC_gc_no);\n", "#   endif\n", "    return result;\n", "}\n"], "project": "gauche", "file": "thread_local_alloc.pkl", "function": "GC_malloc_kind"}, {"comment_all": {"comment": "/*\n * These functions DAGify the parsed filter structure.\n * This means that we can walk all paths down the DAG\n * merely by following ->child and ->next.\n */", "depth": 0, "reading_ease": 84.68, "reading_grade": 4.4, "line": 253}, "comment_text": "/*\n * These functions DAGify the parsed filter structure.\n * This means that we can walk all paths down the DAG\n * merely by following ->child and ->next.\n */", "comment_tokens": ["These", "functions", "DAGify", "the", "parsed", "filter", "structure", ".", "This", "means", "that", "we", "can", "walk", "all", "paths", "down", "the", "DAG", "merely", "by", "following", "-", ">", "child", "and", "-", ">", "next", "."], "ccode": ["\n", "/*\n", " * These functions DAGify the parsed filter structure.\n", " * This means that we can walk all paths down the DAG\n", " * merely by following ->child and ->next.\n", " */\n", "\n", "static void filter_append(struct filter *f, struct filter *x) {\n", "  if (!f)\n", "    abort();\n", "  if (!x)\n", "    return;\n", "\n", "  /* We have to be paranoid about making loops here */\n", "  while ((f->type != F_SIBLIST) && f->child) {\n", "    if (f == x)\n", "      return;\n", "    f = f->child;\n", "  }\n", "  if (f == x)\n", "    return;\n", "\n", "  if (f->type == F_SIBLIST) {\n", "    if (f->child)\n", "      abort();\n", "    for (f = f->u.sib; f; f = f->next)\n", "      filter_append(f, x);\n", "  } else\n", "    f->child = x;\n", "}\n"], "project": "filtergen", "file": "filter.pkl", "function": "filter_append"}, {"comment_all": {"comment": "/* use this host by default */", "depth": 3, "reading_ease": 100.24, "reading_grade": 0.5, "line": 117}, "comment_text": "/* use this host by default */", "comment_tokens": ["use", "this", "host", "by", "default"], "ccode": ["/* -*-C-*-\n", " Common library code for the XEmacs server and client.\n", "\n", " This file is part of XEmacs.\n", "\n", " Copying is permitted under those conditions described by the GNU\n", " General Public License.\n", "\n", " Copyright (C) 1989 Free Software Foundation, Inc.\n", "\n", " Author: Andy Norman (ange@hplb.hpl.hp.com), based on \n", "         'etc/server.c' and 'etc/emacsclient.c' from the 18.52 GNU\n", "         Emacs distribution.\n", "\n", " Please mail bugs and suggestions to the author at the above address.\n", "*/\n", "\n", "/* HISTORY \n", " * 11-Nov-1990\t\tbristor@simba\t\n", " *    Added EOT stuff.\n", " */\n", "\n", "/*\n", " * This file incorporates new features added by Bob Weiner <weiner@mot.com>,\n", " * Darrell Kindred <dkindred@cmu.edu> and Arup Mukherjee <arup@cmu.edu>.\n", " * Please see the note at the end of the README file for details.\n", " *\n", " * (If gnuserv came bundled with your emacs, the README file is probably\n", " * ../etc/gnuserv.README relative to the directory containing this file)\n", " */\n", "\n", "#if 0\n", "static char rcsid [] = \"!Header: gnuslib.c,v 2.4 95/02/16 11:57:37 arup alpha !\";\n", "#endif\n", "\n", "#include \"gnuserv.h\"\n", "#include <errno.h>\n", "\n", "#ifdef SYSV_IPC\n", "static int connect_to_ipc_server (void);\n", "#endif\n", "#ifdef UNIX_DOMAIN_SOCKETS\n", "static int connect_to_unix_server (void);\n", "#endif\n", "#ifdef INTERNET_DOMAIN_SOCKETS\n", "static int connect_to_internet_server (char *serverhost, unsigned short port);\n", "#endif\n", "\n", "/* On some systems, e.g. DGUX, inet_addr returns a 'struct in_addr'. */\n", "#ifdef HAVE_BROKEN_INET_ADDR\n", "# define IN_ADDR struct in_addr\n", "# define NUMERIC_ADDR_ERROR (numeric_addr.s_addr == -1)\n", "#else\n", "# if (LONGBITS > 32)\n", "#  define IN_ADDR unsigned int\n", "# else\n", "#  define IN_ADDR unsigned long\n", "# endif\n", "# define NUMERIC_ADDR_ERROR (numeric_addr == (IN_ADDR) -1)\n", "#endif\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#ifdef HAVE_UNISTD_H\n", "#include <unistd.h>\n", "#endif /* HAVE_UNISTD_H */\n", "#ifdef HAVE_STRING_H\n", "#include <string.h>\n", "#endif /* HAVE_STRING_H */\n", "\n", "#include <arpa/inet.h>\n", "\n", "char *tmpdir = NULL;\n", "\n", "char *progname = NULL;\n", "\n", "int\n", "make_connection (char *hostarg, int portarg, int *s)\n", "{\n", "#ifdef INTERNET_DOMAIN_SOCKETS\n", "  char *ptr;\n", "  if (hostarg == NULL)\n", "    hostarg = getenv(\"GNU_HOST\");\n", "  if (portarg == 0 && (ptr=getenv(\"GNU_PORT\")) != NULL)\n", "    portarg = atoi(ptr);\n", "#endif\n", "\n", "  if (hostarg != NULL) {\n", "    /* hostname was given explicitly, via cmd line arg or GNU_HOST, \n", "     * so obey it. */\n", "#ifdef UNIX_DOMAIN_SOCKETS\n", "    if (!strcmp(hostarg, \"unix\")) {\n", "      *s = connect_to_unix_server();\n", "      return (int) CONN_UNIX;\n", "    } \n", "#endif /* UNIX_DOMAIN_SOCKETS */\n", "#ifdef INTERNET_DOMAIN_SOCKETS\n", "    *s = connect_to_internet_server(hostarg, portarg);\n", "    return (int) CONN_INTERNET;\n", "#endif\n", "#ifdef SYSV_IPC\n", "    return -1;              /* hostarg should always be NULL for SYSV_IPC */\n", "#endif\n", "  } else {\n", "    /* no hostname given.  Use unix-domain/sysv-ipc, or\n", "     * internet-domain connection to local host if they're not available. */\n", "#if   defined(UNIX_DOMAIN_SOCKETS)\n", "    *s = connect_to_unix_server();\n", "    return (int) CONN_UNIX;\n", "#elif defined(SYSV_IPC)\n", "    *s = connect_to_ipc_server();\n", "    return (int) CONN_IPC;\n", "#elif defined(INTERNET_DOMAIN_SOCKETS)\n", "    {\n", "      char localhost[HOSTNAMSZ];\n", "      gethostname(localhost,HOSTNAMSZ);\t  /* use this host by default */    \n", "      *s = connect_to_internet_server(localhost, portarg);\n", "      return (int) CONN_INTERNET;\n", "    }\n", "#endif /* IPC type */\n", "  }\n", "}\n"], "project": "gnuserv", "file": "gnuslib.pkl", "function": "make_connection"}, {"comment_all": {"comment": "/* This is tricky.  We're supposed to use either byte 2, or byte 5\n\t * for the bmic drive number depending on if the controller is internal\n\t * or external.  (This is an accidental difference in the firmwares that\n\t * cropped up in the '90s.)  I've found that you can just set them *both*\n\t * and it seems to work.  Which is a good thing, because there's not a \n\t * good way to tell if it's internal or external with SG_IO.\n\t */", "depth": 1, "reading_ease": 81.63, "reading_grade": 5.6, "line": 934}, "comment_text": "/* This is tricky.  We're supposed to use either byte 2, or byte 5\n\t * for the bmic drive number depending on if the controller is internal\n\t * or external.  (This is an accidental difference in the firmwares that\n\t * cropped up in the '90s.)  I've found that you can just set them *both*\n\t * and it seems to work.  Which is a good thing, because there's not a \n\t * good way to tell if it's internal or external with SG_IO.\n\t */", "comment_tokens": ["This", "is", "tricky", ".", "We", "'re", "supposed", "to", "use", "either", "byte", "2", ",", "or", "byte", "5", "for", "the", "bmic", "drive", "number", "depending", "on", "if", "the", "controller", "is", "internal", "or", "external", ".", "(", "This", "is", "an", "accidental", "difference", "in", "the", "firmwares", "that", "cropped", "up", "in", "the", "'90s", ".", ")", "I", "'ve", "found", "that", "you", "can", "just", "set", "them", "both", "and", "it", "seems", "to", "work", ".", "Which", "is", "a", "good", "thing", ",", "because", "there", "'s", "not", "a", "good", "way", "to", "tell", "if", "it", "'s", "internal", "or", "external", "with", "SG_IO", "."], "ccode": ["\n", "#ifdef HAVE_SCSI_SG_H\n", "static int do_sg_io(int fd, unsigned char *cdb, unsigned char cdblen, unsigned char *buffer,\n", "\tunsigned int buf_size, int direction);\n", "static int do_sgio_bmic_identify_physical_device(int fd, int bmic_drive_number,\n", "\tstruct identify_physical_device *id_phys_device)\n", "{\n", "\tunsigned char cdb[CISS_MAX_CDB_LEN];\n", "\tuint8_t lunzero[CISS_LUN_ADDR_SIZE];\n", "\n", "\tmemset(lunzero, 0, sizeof(lunzero));\n", "\n", "        cdb[0] = CISS_READ;\n", "\n", "\t/* This is tricky.  We're supposed to use either byte 2, or byte 5\n", "\t * for the bmic drive number depending on if the controller is internal\n", "\t * or external.  (This is an accidental difference in the firmwares that\n", "\t * cropped up in the '90s.)  I've found that you can just set them *both*\n", "\t * and it seems to work.  Which is a good thing, because there's not a \n", "\t * good way to tell if it's internal or external with SG_IO.\n", "\t */\n", "\tcdb[2] = bmic_drive_number & 0xff;\n", "\tcdb[5] = bmic_drive_number & 0xff;\n", "        cdb[6] = BMIC_IDENTIFY_PHYSICAL_DEVICE;\n", "        cdb[9] = (bmic_drive_number >> 8) & 0xff;\n", "\tset_cdb_buffer_length(cdb, sizeof(id_phys_device));\n", "\n", "\treturn do_sg_io(fd, cdb, 10, (unsigned char *) &id_phys_device,\n", "\t\tsizeof(id_phys_device), SG_DXFER_FROM_DEV);\n", "}\n"], "project": "cciss-vol-status", "file": "cciss_vol_status.pkl", "function": "do_sgio_bmic_identify_physical_device"}, {"comment_all": {"comment": "/* either no alsa mixer or alsa mixer failed */", "depth": 1, "reading_ease": 63.36, "reading_grade": 6.4, "line": 62}, "comment_text": "/* either no alsa mixer or alsa mixer failed */", "comment_tokens": ["either", "no", "alsa", "mixer", "or", "alsa", "mixer", "failed"], "ccode": ["/* tries to open a mixer device, returns NULL on error or otherwise an mixer_t\n", " * struct */\n", "mixer_t *mixer_open(char *id) {\n", "  mixer_t *result = NULL;\n", "#ifdef WIN32\n", "  result = win32_mixer->mixer_open(id);\n", "#else\n", "  #ifdef ALSA\n", "  result = alsa_mixer->mixer_open(id);\n", "  #endif\n", "  /* either no alsa mixer or alsa mixer failed */\n", "  if (result == NULL) {\n", "    result = oss_mixer->mixer_open(id);\n", "  }\n", "#endif\n", "  return result;\n", "}\n"], "project": "gkrellm-volume", "file": "mixer.pkl", "function": "mixer_open"}, {"comment_all": {"comment": "/**\n * art_alphagamma_free: Free an #ArtAlphaGamma.\n * @alphagamma: An #ArtAlphaGamma.\n *\n * Frees the #ArtAlphaGamma.\n **/", "depth": 0, "reading_ease": 0.45, "reading_grade": 14.0, "line": 74}, "comment_text": "/**\n * art_alphagamma_free: Free an #ArtAlphaGamma.\n * @alphagamma: An #ArtAlphaGamma.\n *\n * Frees the #ArtAlphaGamma.\n **/", "comment_tokens": ["art_alphagamma_free", ":", "Free", "an", "#", "ArtAlphaGamma", ".", "@", "alphagamma", ":", "An", "#", "ArtAlphaGamma", ".", "Frees", "the", "#", "ArtAlphaGamma", "."], "ccode": ["\n", "/**\n", " * art_alphagamma_free: Free an #ArtAlphaGamma.\n", " * @alphagamma: An #ArtAlphaGamma.\n", " *\n", " * Frees the #ArtAlphaGamma.\n", " **/\n", "void\n", "art_alphagamma_free (ArtAlphaGamma *alphagamma)\n", "{\n", "  art_free (alphagamma);\n", "}\n"], "project": "libart-2.0-2", "file": "art_alphagamma.pkl", "function": "art_alphagamma_free"}, {"comment_all": {"comment": "/*\n *  Eukleides version 1.5.4\n *  Copyright (c) Christian Obrecht 2004-2010\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "depth": 0, "reading_ease": 59.84, "reading_grade": 9.8, "line": 0}, "comment_text": "/*\n *  Eukleides version 1.5.4\n *  Copyright (c) Christian Obrecht 2004-2010\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "comment_tokens": ["Eukleides", "version", "1.5.4", "Copyright", "(", "c", ")", "Christian", "Obrecht", "2004-2010", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/*\n", " *  Eukleides version 1.5.4\n", " *  Copyright (c) Christian Obrecht 2004-2010\n", " *\n", " *  This program is free software; you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation; either version 3 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  This program is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License\n", " *  along with this program; if not, write to the Free Software\n", " *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", " */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <math.h>\n", "#include \"error.h\"\n", "#include \"symbol.h\"\n", "#include \"core.h\"\n", "#include \"utils.h\"\n", "#include \"parser.tab.h\"\n", "\n", "void not(void)\n", "{\n", "    PSHn(!pop_param().addr);\n", "}\n"], "project": "eukleides", "file": "test.pkl", "function": "not"}, {"comment_all": {"comment": "/*\n Copyright (\u00a9) 2003-2019 Teus Benschop.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 3 of the License, or\n (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */", "depth": 0, "reading_ease": 60.14, "reading_grade": 9.7, "line": 0}, "comment_text": "/*\n Copyright (\u00a9) 2003-2019 Teus Benschop.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 3 of the License, or\n (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */", "comment_tokens": ["Copyright", "(", "\u00a9", ")", "2003-2019", "Teus", "Benschop", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA", "."], "ccode": ["/*\n", " Copyright (\u00a9) 2003-2019 Teus Benschop.\n", " \n", " This program is free software; you can redistribute it and/or modify\n", " it under the terms of the GNU General Public License as published by\n", " the Free Software Foundation; either version 3 of the License, or\n", " (at your option) any later version.\n", " \n", " This program is distributed in the hope that it will be useful,\n", " but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " GNU General Public License for more details.\n", " \n", " You should have received a copy of the GNU General Public License\n", " along with this program; if not, write to the Free Software\n", " Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " */\n", "\n", "\n", "#include <config.h>\n", "#include <webserver/io.h>\n", "\n", "\n", "/*\n", " This is our own \"bind\" function.\n", " GCC links to the correct Unix call \"bind\", but Clang++ takes the C++ \"bind\" function.\n", " The function below corrects that as follows:\n", " It is located in this .c file.\n", " This .c file will be compiled through the C compiler, not the C++ compiler.\n", " The linker then knows not to link to the C++ \"bind\" function but to the Unix \"bind\" function.\n", " */\n", "int mybind (int socket, const struct sockaddr *address, unsigned int address_len)\n", "{\n", "  return bind (socket, address, address_len);\n", "}\n"], "project": "bibledit-data", "file": "io.pkl", "function": "mybind"}, {"comment_all": {"comment": "/* no need to resize workspace */", "depth": 2, "reading_ease": 100.24, "reading_grade": 0.5, "line": 143}, "comment_text": "/* no need to resize workspace */", "comment_tokens": ["no", "need", "to", "resize", "workspace"], "ccode": ["\n", "int idct_create_table(const int nSize)\n", "{\n", "   int k;\n", "\n", "   if (nSize == dct_table_size) {\n", "      /* no need to resize workspace */\n", "      return (0);\n", "   } else {\n", "      /* release resources to resize workspace */\n", "      if (dct_workspace != NULL) {\n", "         free(dct_workspace);\n", "         dct_workspace = NULL;\n", "      }\n", "      pLocalReal = NULL;\n", "      pLocalImag = NULL;\n", "      pWeightReal = NULL;\n", "      pWeightImag = NULL;\n", "   }\n", "\n", "   if (nSize <= 0) {\n", "      dct_table_size = 0;\n", "      fprintf(stderr, \"DCT size must be positive!\\n\");\n", "      return (-1);\n", "   } else {\n", "      dct_table_size = nSize;\n", "      dct_workspace = dgetmem(dct_table_size * 8);\n", "      pWeightReal = dct_workspace;\n", "      pWeightImag = dct_workspace + 2 * dct_table_size;\n", "      pLocalReal = dct_workspace + (4 * dct_table_size);\n", "      pLocalImag = dct_workspace + (6 * dct_table_size);\n", "\n", "      for (k = 0; k < 2 * dct_table_size; k++) {\n", "         pWeightReal[k] = cos(k * PI / (2.0 * dct_table_size))\n", "             / sqrt(2.0 * dct_table_size);\n", "         pWeightImag[k] = -sin(k * PI / (2.0 * dct_table_size))\n", "             / sqrt(2.0 * dct_table_size);\n", "      }\n", "      pWeightReal[0] *= sqrt(2.0);\n", "      pWeightImag[0] *= sqrt(2.0);\n", "   }\n", "\n", "   return (0);\n", "}\n"], "project": "sptk", "file": "idct.pkl", "function": "idct_create_table"}, {"comment_all": {"comment": "/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */", "depth": 0, "reading_ease": 67.08, "reading_grade": 9.1, "line": 195}, "comment_text": "/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */", "comment_tokens": ["===========================================================================", "Slide", "the", "hash", "table", "when", "sliding", "the", "window", "down", "(", "could", "be", "avoided", "with", "32", "bit", "values", "at", "the", "expense", "of", "memory", "usage", ")", ".", "We", "slide", "even", "when", "level", "==", "0", "to", "keep", "the", "hash", "table", "consistent", "if", "we", "switch", "back", "to", "level", ">", "0", "later", "."], "ccode": ["#endif\n", "\n", "/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n", " * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n", " * meaning.\n", " */\n", "\n", "/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */\n", "#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))\n", "\n", "/* ===========================================================================\n", " * Update a hash value with the given input byte\n", " * IN  assertion: all calls to UPDATE_HASH are made with consecutive input\n", " *    characters, so that a running hash key can be computed from the previous\n", " *    key instead of complete recalculation each time.\n", " */\n", "#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)\n", "\n", "\n", "/* ===========================================================================\n", " * Insert string str in the dictionary and set match_head to the previous head\n", " * of the hash chain (the most recent string with same hash key). Return\n", " * the previous length of the hash chain.\n", " * If this file is compiled with -DFASTEST, the compression level is forced\n", " * to 1, and no hash chains are maintained.\n", " * IN  assertion: all calls to INSERT_STRING are made with consecutive input\n", " *    characters and the first MIN_MATCH bytes of str are valid (except for\n", " *    the last MIN_MATCH-1 bytes of the input file).\n", " */\n", "#ifdef FASTEST\n", "#define INSERT_STRING(s, str, match_head) \\\n", "   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n", "    match_head = s->head[s->ins_h], \\\n", "    s->head[s->ins_h] = (Pos)(str))\n", "#else\n", "#define INSERT_STRING(s, str, match_head) \\\n", "   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n", "    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \\\n", "    s->head[s->ins_h] = (Pos)(str))\n", "#endif\n", "\n", "/* ===========================================================================\n", " * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n", " * prev[] will be initialized on the fly.\n", " */\n", "#define CLEAR_HASH(s) \\\n", "    s->head[s->hash_size-1] = NIL; \\\n", "    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));\n", "\n", "/* ===========================================================================\n", " * Slide the hash table when sliding the window down (could be avoided with 32\n", " * bit values at the expense of memory usage). We slide even when level == 0 to\n", " * keep the hash table consistent if we switch back to level > 0 later.\n", " */\n", "local void slide_hash(s)\n", "    deflate_state *s;\n", "{\n", "    unsigned n, m;\n", "    Posf *p;\n", "    uInt wsize = s->w_size;\n", "\n", "    n = s->hash_size;\n", "    p = &s->head[n];\n", "    do {\n", "        m = *--p;\n", "        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n", "    } while (--n);\n", "    n = wsize;\n", "#ifndef FASTEST\n", "    p = &s->prev[n];\n", "    do {\n", "        m = *--p;\n", "        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n", "        /* If n is not on any hash chain, prev[n] is garbage but\n", "         * its value will never be used.\n", "         */\n", "    } while (--n);\n", "#endif\n", "}\n"], "project": "libpocojson62", "file": "deflate.pkl", "function": "slide_hash"}, {"comment_all": {"comment": "/* Read file extensions of files that are not to be compressed\n * from compextsfile.\n * Extenstions in the file are seperated by whitespace.\n * a # begins a comment that lasts till the end of the line.\n */", "depth": 0, "reading_ease": 77.23, "reading_grade": 5.2, "line": 19}, "comment_text": "/* Read file extensions of files that are not to be compressed\n * from compextsfile.\n * Extenstions in the file are seperated by whitespace.\n * a # begins a comment that lasts till the end of the line.\n */", "comment_tokens": ["Read", "file", "extensions", "of", "files", "that", "are", "not", "to", "be", "compressed", "from", "compextsfile", ".", "Extenstions", "in", "the", "file", "are", "seperated", "by", "whitespace", ".", "a", "#", "begins", "a", "comment", "that", "lasts", "till", "the", "end", "of", "the", "line", "."], "ccode": ["\n", "#include <stdio.h>\n", "#include <string.h>\n", "#include <unistd.h>\n", "#include <stdlib.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "\n", "\n", "#include \"patchlevel.h\"\n", "\n", "#include \"afio.h\"\n", "\n", "\n", "struct extnode { char *ext; struct extnode *next; };\n", "\n", "/* merge in auto-generated list of default extensions mentioned in the manpage */\n", "#include \"exten_default.h\"\n", "\n", "/* Read file extensions of files that are not to be compressed\n", " * from compextsfile.\n", " * Extenstions in the file are seperated by whitespace.\n", " * a # begins a comment that lasts till the end of the line.\n", " */\n", "int readcompexts(char *compextsfile)\n", "{\n", " FILE *infile;\n", " char ex[81];\n", " int c;\n", " struct extnode *tmp;\n", "\n", " if(compextsfile[0]=='+') compextsfile++; else compexts=NULL;\n", "\n", " infile=fopen(compextsfile,\"r\");\n", " if(infile==0)\n", "   {\n", "     fprintf (stderr,\n", "\t      \"Can't read configuration file %s\\n\",\n", "\t      compextsfile);\n", "     return 0;\n", "   }\n", "\n", " while(fscanf(infile,\"%80s\",ex)!=EOF)\n", "   {\n", "     if(ex[0]=='#')\n", "       { /* throw away comment. */\n", "        do{\n", "           c=fgetc(infile);\n", "           if(c==EOF)  { fclose(infile); return 1; }\n", "          }while(c!='\\n');\n", "        continue;\n", "       }\n", "\n", "     tmp=(struct extnode *)malloc(sizeof(struct extnode));\n", "     if(tmp==NULL) break;\n", "     if((tmp->ext=strdup(ex))==NULL) break;\n", "     tmp->next=compexts;\n", "     compexts=tmp;\n", "   }\n", "\n", " fclose(infile);\n", " return 1;\n", "}\n"], "project": "afio", "file": "exten.pkl", "function": "readcompexts"}, {"comment_all": {"comment": "/* Formatted output to strings.\n   Copyright (C) 1999, 2002, 2006, 2009-2018 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, see <https://www.gnu.org/licenses/>.  */*/\n", "depth": 0, "reading_ease": 52.9, "reading_grade": 10.4, "line": 14}, "comment_text": "/* Formatted output to strings.\n   Copyright (C) 1999, 2002, 2006, 2009-2018 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, see <https://www.gnu.org/licenses/>.  */*/\n", "comment_tokens": ["Formatted", "output", "to", "strings", ".", "Copyright", "(", "C", ")", "1999", ",", "2002", ",", "2006", ",", "2009-2018", "Free", "Software", "Foundation", ",", "Inc", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "see", "<", "https", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/* Formatted output to strings.\n", "   Copyright (C) 1999, 2002, 2006, 2009-2018 Free Software Foundation, Inc.\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License along\n", "   with this program; if not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"vasnprintf.h\"\n", "\n", "#include <stdarg.h>\n", "\n", "char *\n", "asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n", "{\n", "  va_list args;\n", "  char *result;\n", "\n", "  va_start (args, format);\n", "  result = vasnprintf (resultbuf, lengthp, format, args);\n", "  va_end (args);\n", "  return result;\n", "}\n"], "project": "gzip", "file": "asnprintf.pkl", "function": "asnprintf"}, {"comment_all": {"comment": "/* Free an error and its elements\n */", "depth": 0, "reading_ease": 73.85, "reading_grade": 4.5, "line": 78}, "comment_text": "/* Free an error and its elements\n */", "comment_tokens": ["Free", "an", "error", "and", "its", "elements"], "ccode": ["\n", "/* Free an error and its elements\n", " */\n", "void libcerror_error_free(\n", "      libcerror_error_t **error )\n", "{\n", "\tlibcerror_internal_error_t *internal_error = NULL;\n", "\tint message_index                          = 0;\n", "\n", "\tif( error == NULL )\n", "\t{\n", "\t\treturn;\n", "\t}\n", "\tif( *error != NULL )\n", "\t{\n", "\t\tinternal_error = (libcerror_internal_error_t *) *error;\n", "\n", "\t\tif( internal_error->messages != NULL )\n", "\t\t{\n", "\t\t\tfor( message_index = 0;\n", "\t\t\t     message_index < internal_error->number_of_messages;\n", "\t\t\t     message_index++ )\n", "\t\t\t{\n", "\t\t\t\tif( internal_error->messages[ message_index ] != NULL )\n", "\t\t\t\t{\n", "\t\t\t\t\tmemory_free(\n", "\t\t\t\t\t internal_error->messages[ message_index ] );\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tmemory_free(\n", "\t\t\t internal_error->messages );\n", "\t\t}\n", "\t\tif( internal_error->sizes != NULL )\n", "\t\t{\n", "\t\t\tmemory_free(\n", "\t\t\t internal_error->sizes );\n", "\t\t}\n", "\t\tmemory_free(\n", "\t\t *error );\n", "\n", "\t\t*error = NULL;\n", "\t}\n", "}\n"], "project": "libewf2", "file": "libcerror_error.pkl", "function": "libcerror_error_free"}, {"comment_all": {"comment": "/* Post the event, if desired */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 816}, "comment_text": "/* Post the event, if desired */", "comment_tokens": ["Post", "the", "event", ",", "if", "desired"], "ccode": ["\n", "int\n", "SDL_SendEditingText(const char *text, int start, int length)\n", "{\n", "    SDL_Keyboard *keyboard = &SDL_keyboard;\n", "    int posted;\n", "\n", "    /* Post the event, if desired */\n", "    posted = 0;\n", "    if (SDL_GetEventState(SDL_TEXTEDITING) == SDL_ENABLE) {\n", "        SDL_Event event;\n", "        event.edit.type = SDL_TEXTEDITING;\n", "        event.edit.windowID = keyboard->focus ? keyboard->focus->id : 0;\n", "        event.edit.start = start;\n", "        event.edit.length = length;\n", "        SDL_utf8strlcpy(event.edit.text, text, SDL_arraysize(event.edit.text));\n", "        posted = (SDL_PushEvent(&event) > 0);\n", "    }\n", "    return (posted);\n", "}\n"], "project": "libsdl2-doc", "file": "SDL_keyboard.pkl", "function": "SDL_SendEditingText"}, {"comment_all": {"comment": "/*\n * Queue an OpenCL kernel that just increments a variable\n */", "depth": 0, "reading_ease": 62.34, "reading_grade": 6.8, "line": 20}, "comment_text": "/*\n * Queue an OpenCL kernel that just increments a variable\n */", "comment_tokens": ["Queue", "an", "OpenCL", "kernel", "that", "just", "increments", "a", "variable"], "ccode": ["/* StarPU --- Runtime system for heterogeneous multicore architectures.\n", " *\n", " * Copyright (C) 2012                                     Inria\n", " * Copyright (C) 2012,2015-2017                           CNRS\n", " * Copyright (C) 2014,2016                                Universit\u00e9 de Bordeaux\n", " *\n", " * StarPU is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU Lesser General Public License as published by\n", " * the Free Software Foundation; either version 2.1 of the License, or (at\n", " * your option) any later version.\n", " *\n", " * StarPU is distributed in the hope that it will be useful, but\n", " * WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", " *\n", " * See the GNU Lesser General Public License in COPYING.LGPL for more details.\n", " */\n", "\n", "#include <starpu.h>\n", "\n", "/*\n", " * Queue an OpenCL kernel that just increments a variable\n", " */\n", "\n", "extern struct starpu_opencl_program opencl_program;\n", "void increment_opencl(void *buffers[], void *args)\n", "{\n", "\t(void) args;\n", "\tint id, devid;\n", "        cl_int err;\n", "\tcl_kernel kernel;\n", "\tcl_command_queue queue;\n", "\n", "\tcl_mem val = (cl_mem)STARPU_VARIABLE_GET_PTR(buffers[0]);\n", "\n", "\tid = starpu_worker_get_id_check();\n", "\tdevid = starpu_worker_get_devid(id);\n", "\n", "\terr = starpu_opencl_load_kernel(&kernel, &queue, &opencl_program, \"_increment_opencl_codelet\", devid);\n", "\tif (err != CL_SUCCESS)\n", "\t\tSTARPU_OPENCL_REPORT_ERROR(err);\n", "\n", "\terr = clSetKernelArg(kernel, 0, sizeof(val), &val);\n", "\tif (err != CL_SUCCESS)\n", "\t\tSTARPU_OPENCL_REPORT_ERROR(err);\n", "\n", "\t{\n", "\t\tsize_t global=1;\n", "\t\tsize_t local=1;\n", "\n", "\t\terr = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &global, &local, 0, NULL, NULL);\n", "\t\tif (err != CL_SUCCESS)\n", "\t\t\tSTARPU_OPENCL_REPORT_ERROR(err);\n", "\t}\n", "\tstarpu_opencl_release_kernel(kernel);\n", "}\n"], "project": "starpu-contrib-examples", "file": "acquire_release_opencl.pkl", "function": "increment_opencl"}, {"comment_all": {"comment": "/* Store pointers to all widgets, for use by lookup_widget(). */", "depth": 1, "reading_ease": 79.26, "reading_grade": 4.4, "line": 189}, "comment_text": "/* Store pointers to all widgets, for use by lookup_widget(). */", "comment_tokens": ["Store", "pointers", "to", "all", "widgets", ",", "for", "use", "by", "lookup_widget", "(", ")", "."], "ccode": ["\n", "GtkWidget*\n", "create_fileselection_fd (void)\n", "{\n", "  GtkWidget *fileselection_fd;\n", "  GtkWidget *ok_button_fd;\n", "  GtkWidget *cancel_button_fd;\n", "\n", "  fileselection_fd = gtk_file_selection_new (\"HOZ\");\n", "  gtk_container_set_border_width (GTK_CONTAINER (fileselection_fd), 10);\n", "  gtk_window_set_position (GTK_WINDOW (fileselection_fd), GTK_WIN_POS_CENTER);\n", "  gtk_window_set_modal (GTK_WINDOW (fileselection_fd), TRUE);\n", "  gtk_window_set_destroy_with_parent (GTK_WINDOW (fileselection_fd), TRUE);\n", "\n", "  ok_button_fd = GTK_FILE_SELECTION (fileselection_fd)->ok_button;\n", "  gtk_widget_show (ok_button_fd);\n", "  GTK_WIDGET_SET_FLAGS (ok_button_fd, GTK_CAN_DEFAULT);\n", "\n", "  cancel_button_fd = GTK_FILE_SELECTION (fileselection_fd)->cancel_button;\n", "  gtk_widget_show (cancel_button_fd);\n", "  GTK_WIDGET_SET_FLAGS (cancel_button_fd, GTK_CAN_DEFAULT);\n", "\n", "  g_signal_connect_swapped ((gpointer) ok_button_fd, \"clicked\",\n", "                            G_CALLBACK (on_ok_button_fd_clicked),\n", "                            GTK_OBJECT (fileselection_fd));\n", "  g_signal_connect ((gpointer) cancel_button_fd, \"clicked\",\n", "                    G_CALLBACK (on_cancel_button_fd_clicked),\n", "                    NULL);\n", "\n", "  /* Store pointers to all widgets, for use by lookup_widget(). */\n", "  GLADE_HOOKUP_OBJECT_NO_REF (fileselection_fd, fileselection_fd, \"fileselection_fd\");\n", "  GLADE_HOOKUP_OBJECT_NO_REF (fileselection_fd, ok_button_fd, \"ok_button_fd\");\n", "  GLADE_HOOKUP_OBJECT_NO_REF (fileselection_fd, cancel_button_fd, \"cancel_button_fd\");\n", "\n", "  return fileselection_fd;\n", "}\n"], "project": "hoz", "file": "hozgtk_i.pkl", "function": "create_fileselection_fd"}, {"comment_all": {"comment": "/*FUNCTION poz: probability of normal z value */", "depth": 0, "reading_ease": 30.53, "reading_grade": 10.7, "line": 23}, "comment_text": "/*FUNCTION poz: probability of normal z value */\n/*ALGORITHM\n\tAdapted from a polynomial approximation in:\n\t\tIbbetson D, Algorithm 209\n\t\tCollected Algorithms of the CACM 1963 p. 616\n\tNote:\n\t\tThis routine has six digit accuracy, so it is only useful for absolute\n\t\tz values < 6.  For z values >= to 6.0, poz() returns 0.0.\n*/\n", "comment_tokens": ["FUNCTION", "poz", ":", "probability", "of", "normal", "z", "value", "ALGORITHM", "Adapted", "from", "a", "polynomial", "approximation", "in", ":", "Ibbetson", "D", ",", "Algorithm", "209", "Collected", "Algorithms", "of", "the", "CACM", "1963", "p.", "616", "Note", ":", "This", "routine", "has", "six", "digit", "accuracy", ",", "so", "it", "is", "only", "useful", "for", "absolute", "z", "values", "<", "6", ".", "For", "z", "values", ">", "=", "to", "6.0", ",", "poz", "(", ")", "returns", "0.0", "."], "ccode": ["/*\n", "\n", "    Compute probability of measured Chi Square value.\n", "    \n", "    This code was developed by Gary Perlman of the Wang\n", "    Institute (full citation below) and has been minimally\n", "    modified for use in this program.\n", "    \n", "*/\n", "\n", "#include <math.h>\n", "\n", "/*HEADER\n", "\tModule:       z.c\n", "\tPurpose:      compute approximations to normal z distribution probabilities\n", "\tProgrammer:   Gary Perlman\n", "\tOrganization: Wang Institute, Tyngsboro, MA 01879\n", "\tCopyright:    none\n", "\tTabstops:     4\n", "*/\n", "\n", "#define\tZ_MAX          6.0            /* maximum meaningful z value */\n", "\n", "/*FUNCTION poz: probability of normal z value */\n", "/*ALGORITHM\n", "\tAdapted from a polynomial approximation in:\n", "\t\tIbbetson D, Algorithm 209\n", "\t\tCollected Algorithms of the CACM 1963 p. 616\n", "\tNote:\n", "\t\tThis routine has six digit accuracy, so it is only useful for absolute\n", "\t\tz values < 6.  For z values >= to 6.0, poz() returns 0.0.\n", "*/\n", "static double        /*VAR returns cumulative probability from -oo to z */\n", "poz(const double z)  /*VAR normal z value */\n", "{\n", "    double y, x, w;\n", "\n", "    if (z == 0.0) {\n", "    \tx = 0.0;\n", "    } else {\n", "\ty = 0.5 * fabs(z);\n", "\tif (y >= (Z_MAX * 0.5)) {\n", "    \t    x = 1.0;\n", "\t} else if (y < 1.0) {\n", "\t   w = y * y;\n", "\t   x = ((((((((0.000124818987 * w\n", "\t\t   -0.001075204047) * w +0.005198775019) * w\n", "\t\t   -0.019198292004) * w +0.059054035642) * w\n", "\t\t   -0.151968751364) * w +0.319152932694) * w\n", "\t\t   -0.531923007300) * w +0.797884560593) * y * 2.0;\n", "\t} else {\n", "\t    y -= 2.0;\n", "\t    x = (((((((((((((-0.000045255659 * y\n", "\t\t    +0.000152529290) * y -0.000019538132) * y\n", "\t\t    -0.000676904986) * y +0.001390604284) * y\n", "\t\t    -0.000794620820) * y -0.002034254874) * y\n", "\t\t    +0.006549791214) * y -0.010557625006) * y\n", "\t\t    +0.011630447319) * y -0.009279453341) * y\n", "\t\t    +0.005353579108) * y -0.002141268741) * y\n", "\t\t    +0.000535310849) * y +0.999936657524;\n", "    \t}\n", "    }\n", "    return (z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5));\n", "}\n"], "project": "ent", "file": "chisq.pkl", "function": "poz"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  Function that is called when a function prototype is seen.\n\n  char* name The name of the function.\n\n  int in_a_function Whether the reference is from within a function or at the top level of the file.\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 76.52, "reading_grade": 5.5, "line": 46}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  Function that is called when a function prototype is seen.\n\n  char* name The name of the function.\n\n  int in_a_function Whether the reference is from within a function or at the top level of the file.\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "Function", "that", "is", "called", "when", "a", "function", "prototype", "is", "seen", ".", "char", "name", "The", "name", "of", "the", "function", ".", "int", "in_a_function", "Whether", "the", "reference", "is", "from", "within", "a", "function", "or", "at", "the", "top", "level", "of", "the", "file", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["/***************************************\n", "  $Header: /home/amb/CVS/cxref/src/func.c,v 1.20 2003-12-02 19:51:08 amb Exp $\n", "\n", "  C Cross Referencing & Documentation tool. Version 1.5f.\n", "\n", "  Handle Function stuff.\n", "  ******************/ /******************\n", "  Written by Andrew M. Bishop\n", "\n", "  This file Copyright 1995,96,97,99,2001 Andrew M. Bishop\n", "  It may be distributed under the GNU Public License, version 2, or\n", "  any higher version.  See section COPYING of the GNU Public license\n", "  for conditions under which this file may be redistributed.\n", "  ***************************************/\n", "\n", "/*+ Control the debugging information from this file. +*/\n", "#define DEBUG 0\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <string.h>\n", "\n", "#include \"memory.h\"\n", "#include \"datatype.h\"\n", "#include \"parse-yy.h\"\n", "#include \"cxref.h\"\n", "\n", "/*+ The current parsing options. +*/\n", "extern int option_xref;\n", "\n", "/*+ The current file that is being processed. +*/\n", "extern File CurFile;\n", "\n", "/*+ When in a header file include functions from that file (except inline functions). +*/\n", "extern int in_header;\n", "\n", "/*+ The current function, this is initialised by the start of a possible declaration and maintained until all of the\n", "    arguments have been added and confirmation that it is a definition and not a prototype is seen. +*/\n", "static Function cur_func=NULL;\n", "\n", "/*+ The list of function prototypes and the files that they are defined in. +*/\n", "static StringList2 prototypes=NULL;\n", "\n", "static Function NewFunctionType(char *name,char *type);\n", "\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Function that is called when a function prototype is seen.\n", "\n", "  char* name The name of the function.\n", "\n", "  int in_a_function Whether the reference is from within a function or at the top level of the file.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "void SeenFunctionProto(char* name,int in_a_function)\n", "{\n", " if(!(option_xref&XREF_FUNC))\n", "    return;\n", "\n", "#if DEBUG\n", " printf(\"#Func.c# Function prototype '%s'\\n\",name);\n", "#endif\n", "\n", " if(!in_a_function)\n", "   {\n", "    if(!prototypes)\n", "       prototypes=NewStringList2();\n", "    AddToStringList2(prototypes,name,parse_file,0,1);\n", "   }\n", " else\n", "    AddToStringList(cur_func->protos,name,0,1);\n", "}\n"], "project": "cxref-emacs", "file": "func.pkl", "function": "SeenFunctionProto"}, {"comment_all": {"comment": "/* The proc clearly exists, so create a data structure for it */", "depth": 2, "reading_ease": 68.77, "reading_grade": 6.4, "line": 365}, "comment_text": "/* The proc clearly exists, so create a data structure for it */", "comment_tokens": ["The", "proc", "clearly", "exists", ",", "so", "create", "a", "data", "structure", "for", "it"], "ccode": ["\n", "\n", "/**\n", " * Find proc_data_t container associated with given\n", " * pmix_identifier_t.\n", " */\n", "static pmix_proc_data_t* lookup_proc(pmix_hash_table_t *jtable,\n", "                                     uint64_t id, bool create)\n", "{\n", "    pmix_proc_data_t *proc_data = NULL;\n", "\n", "    pmix_hash_table_get_value_uint64(jtable, id, (void**)&proc_data);\n", "    if (NULL == proc_data && create) {\n", "        /* The proc clearly exists, so create a data structure for it */\n", "        proc_data = PMIX_NEW(pmix_proc_data_t);\n", "        if (NULL == proc_data) {\n", "            pmix_output(0, \"pmix:client:hash:lookup_pmix_proc: unable to allocate proc_data_t\\n\");\n", "            return NULL;\n", "        }\n", "        pmix_hash_table_set_value_uint64(jtable, id, proc_data);\n", "    }\n", "\n", "    return proc_data;\n", "}\n"], "project": "openmpi-common", "file": "hash.pkl", "function": "lookup_proc"}, {"comment_all": {"comment": "/* Find an appropriate join count; assumes --join was specified or implied.\n   Exit with error if no valid value is available. */", "depth": 0, "reading_ease": 61.33, "reading_grade": 7.2, "line": 291}, "comment_text": "/* Find an appropriate join count; assumes --join was specified or implied.\n   Exit with error if no valid value is available. */", "comment_tokens": ["Find", "an", "appropriate", "join", "count", ";", "assumes", "--", "join", "was", "specified", "or", "implied", ".", "Exit", "with", "error", "if", "no", "valid", "value", "is", "available", "."], "ccode": ["\n", "/* Find an appropriate join count; assumes --join was specified or implied.\n", "   Exit with error if no valid value is available. */\n", "int join_ct(int cli_ct)\n", "{\n", "   int j = 0;\n", "   char *ev_name, *ev_value;\n", "\n", "   if (cli_ct != 0) {\n", "      INFO(\"join: peer group size from command line\");\n", "      j = cli_ct;\n", "      goto end;\n", "   }\n", "\n", "   if (get_first_env(JOIN_CT_ENV, &ev_name, &ev_value)) {\n", "      INFO(\"join: peer group size from %s\", ev_name);\n", "      j = parse_int(ev_value, true, ev_name);\n", "      goto end;\n", "   }\n", "\n", "end:\n", "   Te(j > 0, \"join: no valid peer group size found\");\n", "   return j;\n", "}\n"], "project": "charliecloud", "file": "ch-run.pkl", "function": "join_ct"}, {"comment_all": {"comment": "/* \tprintf(\"sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\\n\", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */", "depth": 1, "reading_ease": 24.44, "reading_grade": 13.1, "line": 263}, "comment_text": "/* \tprintf(\"sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\\n\", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */", "comment_tokens": ["printf", "(", "``", "sizeof", "(", "struct", "chunkHeader", ")", "=", "%", "u", ",", "sizeof", "(", "struct", "chunkTrailer", ")", "=", "%", "u\\n", "''", ",", "sizeof", "(", "struct", "chunkHeader", ")", ",", "sizeof", "(", "struct", "chunkTrailer", ")", ")", ";"], "ccode": ["\n", "void *debugMalloc(uint32_t length, int32_t tag)\n", "{\n", "\tunsigned char *memory;\n", "\tstruct chunkHeader *chunkHeader;\n", "\tstruct chunkTrailer *chunkTrailer;\n", "\tunsigned char *chunk;\n", "\n", "/* \tprintf(\"sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\\n\", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */\n", "\n", "\tmemory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer) + getHeaderPad() + getTrailerPad(length));\n", "\n", "\tif (memory == NULL)\n", "\t{\n", "\t\tdebug_output( 0, \"Cannot allocate %u bytes, malloc tag = %d\\n\", (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag );\n", "\t\trestore_and_exit(0);\n", "\t}\n", "\n", "\tchunkHeader = (struct chunkHeader *)memory;\n", "\tchunk = memory + sizeof(struct chunkHeader) + getHeaderPad();\n", "\tchunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + length + getHeaderPad() + getTrailerPad(length));\n", "\n", "\tfillPadding((unsigned char*)chunkHeader + sizeof(struct chunkHeader), getHeaderPad());\n", "\tfillPadding(chunk + length, getTrailerPad(length));\n", "\n", "\tchunkHeader->length = length;\n", "\tchunkHeader->tag = tag;\n", "\tchunkHeader->magicNumber = MAGIC_NUMBER;\n", "\n", "\tchunkTrailer->magicNumber = MAGIC_NUMBER;\n", "\n", "\tpthread_mutex_lock(&chunk_mutex);\n", "\tchunkHeader->next = chunkList;\n", "\tchunkList = chunkHeader;\n", "\tpthread_mutex_unlock(&chunk_mutex);\n", "\n", "#if defined MEMORY_USAGE\n", "\n", "\taddMemory( length, tag );\n", "\n", "#endif\n", "\n", "\treturn chunk;\n", "}\n"], "project": "batmand", "file": "allocate.pkl", "function": "debugMalloc"}, {"comment_all": {"comment": "/** Get the output stream.\n * \n */", "depth": 0, "reading_ease": 92.8, "reading_grade": 1.3, "line": 3957}, "comment_text": "/** Get the output stream.\n * \n */", "comment_tokens": ["Get", "the", "output", "stream", "."], "ccode": ["\n", "/** Get the output stream.\n", " * \n", " */\n", "FILE *yyget_out  (void)\n", "{\n", "        return yyout;\n", "}\n"], "project": "linux-buildinfo-5.10.0-1029-oem", "file": "lexer.lex.pkl", "function": "yyget_out"}, {"comment_all": {"comment": "/*\n *  handle_sigwinch()\n *      flag window resize on SIGWINCH\n */", "depth": 0, "reading_ease": 31.55, "reading_grade": 10.4, "line": 348}, "comment_text": "/*\n *  handle_sigwinch()\n *      flag window resize on SIGWINCH\n */", "comment_tokens": ["handle_sigwinch", "(", ")", "flag", "window", "resize", "on", "SIGWINCH"], "ccode": ["\n", "/*\n", " *  handle_sigwinch()\n", " *      flag window resize on SIGWINCH\n", " */\n", "static void handle_sigwinch(int sig)\n", "{\n", "\t(void)sig;\n", "\n", "\tresized = true;\n", "}\n"], "project": "cpustat", "file": "cpustat.pkl", "function": "handle_sigwinch"}, {"comment_all": {"comment": "/* Returns the number of devices a mixer has */", "depth": 0, "reading_ease": 71.82, "reading_grade": 5.2, "line": 82}, "comment_text": "/* Returns the number of devices a mixer has */", "comment_tokens": ["Returns", "the", "number", "of", "devices", "a", "mixer", "has"], "ccode": ["\n", "/* Returns the number of devices a mixer has */\n", "int mixer_get_nr_devices(mixer_t *mixer) {\n", "  return mixer->nrdevices;\n", "}\n"], "project": "gkrellm-volume", "file": "mixer.pkl", "function": "mixer_get_nr_devices"}, {"comment_all": {"comment": "/* double size */", "depth": 4, "reading_ease": 77.91, "reading_grade": 2.9, "line": 1363}, "comment_text": "/* double height */\n/* double width */\n/* double size */\n", "comment_tokens": ["double", "height", "double", "width", "double", "size"], "ccode": ["\n", "static void\n", "enhance_flush(struct enhance_state *es, int column)\n", "{\n", "\tint row = es->inv_row + es->active_row;\n", "\tint i;\n", "\n", "\tif (row >= ROWS)\n", "\t\treturn;\n", "\n", "\tif (es->type == OBJECT_TYPE_PASSIVE && !es->mac.unicode) {\n", "\t\tes->active_column = column;\n", "\t\treturn;\n", "\t}\n", "\n", "\tprintv(\"flush [%04x%c,F%d%c,B%d%c,S%d%c,O%d%c,H%d%c] %d ... %d\\n\",\n", "\t       es->ac.unicode, es->mac.unicode ? '*' : ' ',\n", "\t       es->ac.foreground, es->mac.foreground ? '*' : ' ',\n", "\t       es->ac.background, es->mac.background ? '*' : ' ',\n", "\t       es->ac.size, es->mac.size ? '*' : ' ',\n", "\t       es->ac.opacity, es->mac.opacity ? '*' : ' ',\n", "\t       es->ac.flash, es->mac.flash ? '*' : ' ',\n", "\t       es->active_column, column - 1);\n", "\n", "\tfor (i = es->inv_column + es->active_column; i < es->inv_column + column;) {\n", "\t\tvbi_char c;\n", "\n", "\t\tif (i > 39)\n", "\t\t\tbreak;\n", "\n", "\t\tc = es->acp[i];\n", "\n", "\t\tif (es->mac.underline) {\n", "\t\t\tint u = es->ac.underline;\n", "\n", "\t\t\tif (!es->mac.unicode)\n", "\t\t\t\tes->ac.unicode = c.unicode;\n", "\n", "\t\t\tif (vbi_is_gfx(es->ac.unicode)) {\n", "\t\t\t\tif (u)\n", "\t\t\t\t\tes->ac.unicode &= ~0x20; /* separated */\n", "\t\t\t\telse\n", "\t\t\t\t\tes->ac.unicode |= 0x20; /* contiguous */\n", "\t\t\t\tes->mac.unicode = ~0;\n", "\t\t\t\tu = 0;\n", "\t\t\t}\n", "\n", "\t\t\tc.underline = u;\n", "\t\t}\n", "\t\tif (es->mac.foreground)\n", "\t\t\tc.foreground = (es->ac.foreground != VBI_TRANSPARENT_BLACK) ?\n", "\t\t\t\tes->ac.foreground : (es->row_color_transparent) ?\n", "\t\t\t\tVBI_TRANSPARENT_BLACK : es->row_color;\n", "\t\tif (es->mac.background)\n", "\t\t\tc.background = (es->ac.background != VBI_TRANSPARENT_BLACK) ?\n", "\t\t\t\tes->ac.background : (es->row_color_transparent) ?\n", "\t\t\t\tVBI_TRANSPARENT_BLACK : es->row_color;\n", "\t\tif (es->invert) {\n", "\t\t\tint t = c.foreground;\n", "\n", "\t\t\tc.foreground = c.background;\n", "\t\t\tc.background = t;\n", "\t\t}\n", "\t\tif (es->mac.opacity)\n", "\t\t\tc.opacity = es->ac.opacity;\n", "\t\tif (es->mac.flash)\n", "\t\t\tc.flash = es->ac.flash;\n", "\t\tif (es->mac.conceal)\n", "\t\t\tc.conceal = es->ac.conceal;\n", "\t\tif (es->mac.unicode) {\n", "\t\t\tc.unicode = es->ac.unicode;\n", "\t\t\tes->mac.unicode = 0;\n", "\n", "\t\t\tif (es->mac.size)\n", "\t\t\t\tc.size = es->ac.size;\n", "\t\t\telse if (c.size > VBI_DOUBLE_SIZE)\n", "\t\t\t\tc.size = VBI_NORMAL_SIZE;\n", "\t\t}\n", "\n", "\t\tes->acp[i] = c;\n", "\n", "\t\tif (es->type == OBJECT_TYPE_PASSIVE)\n", "\t\t\tbreak;\n", "\n", "\t\ti++;\n", "\n", "\t\tif (es->type != OBJECT_TYPE_PASSIVE\n", "\t\t    && es->type != OBJECT_TYPE_ADAPTIVE) {\n", "\t\t\tint raw;\n", "\n", "\t\t\traw = (row == 0 && i < 9) ?\n", "\t\t\t\t0x20 : vbi_unpar8 (es->vtp->data.lop.raw[row][i - 1]);\n", "\n", "\t\t\t/* set-after spacing attributes cancelling non-spacing */\n", "\n", "\t\t\tswitch (raw) {\n", "\t\t\tcase 0x00 ... 0x07:\t/* alpha + foreground color */\n", "\t\t\tcase 0x10 ... 0x17:\t/* mosaic + foreground color */\n", "\t\t\t\tprintv(\"... fg term %d %02x\\n\", i, raw);\n", "\t\t\t\tes->mac.foreground = 0;\n", "\t\t\t\tes->mac.conceal = 0;\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase 0x08:\t\t/* flash */\n", "\t\t\t\tes->mac.flash = 0;\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase 0x0A:\t\t/* end box */\n", "\t\t\tcase 0x0B:\t\t/* start box */\n", "\t\t\t\tif (i < COLUMNS && vbi_unpar8 (es->vtp->data.lop.raw[row][i]) == raw) {\n", "\t\t\t\t\tprintv(\"... boxed term %d %02x\\n\", i, raw);\n", "\t\t\t\t\tes->mac.opacity = 0;\n", "\t\t\t\t}\n", "\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase 0x0D:\t\t/* double height */\n", "\t\t\tcase 0x0E:\t\t/* double width */\n", "\t\t\tcase 0x0F:\t\t/* double size */\n", "\t\t\t\tprintv(\"... size term %d %02x\\n\", i, raw);\n", "\t\t\t\tes->mac.size = 0;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tif (i > 39)\n", "\t\t\t\tbreak;\n", "\n", "\t\t\traw = (row == 0 && i < 8) ?\n", "\t\t\t\t0x20 : vbi_unpar8 (es->vtp->data.lop.raw[row][i]);\n", "\n", "\t\t\t/* set-at spacing attributes cancelling non-spacing */\n", "\n", "\t\t\tswitch (raw) {\n", "\t\t\tcase 0x09:\t\t/* steady */\n", "\t\t\t\tes->mac.flash = 0;\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase 0x0C:\t\t/* normal size */\n", "\t\t\t\tprintv(\"... size term %d %02x\\n\", i, raw);\n", "\t\t\t\tes->mac.size = 0;\n", "\t\t\t\tbreak;\n", "\n", "\t\t\tcase 0x18:\t\t/* conceal */\n", "\t\t\t\tes->mac.conceal = 0;\n", "\t\t\t\tbreak;\n", "\n", "\t\t\t\t/*\n", "\t\t\t\t *  Non-spacing underlined/separated display attribute\n", "\t\t\t\t *  cannot be cancelled by a subsequent spacing attribute.\n", "\t\t\t\t */\n", "\n", "\t\t\tcase 0x1C:\t\t/* black background */\n", "\t\t\tcase 0x1D:\t\t/* new background */\n", "\t\t\t\tprintv(\"... bg term %d %02x\\n\", i, raw);\n", "\t\t\t\tes->mac.background = 0;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\tes->active_column = column;\n", "}\n"], "project": "libzvbi-common", "file": "teletext.pkl", "function": "enhance_flush"}, {"comment_all": {"comment": "/**\n * map the error code to a system error code. This is used\n * for the drop-in replacement functions to return a value\n * that can be interpreted correctly by code sections that\n * are unaware of the fact they their => open(2) call had been\n * diverted to a file inside a zip-archive.\n */", "depth": 0, "reading_ease": 64.04, "reading_grade": 10.3, "line": 137}, "comment_text": "/**\n * map the error code to a system error code. This is used\n * for the drop-in replacement functions to return a value\n * that can be interpreted correctly by code sections that\n * are unaware of the fact they their => open(2) call had been\n * diverted to a file inside a zip-archive.\n */", "comment_tokens": ["map", "the", "error", "code", "to", "a", "system", "error", "code", ".", "This", "is", "used", "for", "the", "drop-in", "replacement", "functions", "to", "return", "a", "value", "that", "can", "be", "interpreted", "correctly", "by", "code", "sections", "that", "are", "unaware", "of", "the", "fact", "they", "their", "=", ">", "open", "(", "2", ")", "call", "had", "been", "diverted", "to", "a", "file", "inside", "a", "zip-archive", "."], "ccode": ["/* *INDENT-ON* */\n", "\n", "/**\n", " * map the error code to a system error code. This is used\n", " * for the drop-in replacement functions to return a value\n", " * that can be interpreted correctly by code sections that\n", " * are unaware of the fact they their => open(2) call had been\n", " * diverted to a file inside a zip-archive.\n", " */\n", "int\n", "zzip_errno(int errcode)\n", "{\n", "    if (errcode >= -1)\n", "    {\n", "        return errno;\n", "    } else\n", "    {\n", "        struct errnolistentry *err = errnolist;\n", "\n", "        for (; err->code; err++)\n", "        {\n", "            if (err->code == errcode)\n", "                return err->e_no;\n", "        }\n", "        return EINVAL;\n", "    }\n", "}\n"], "project": "zziplib-bin", "file": "err.pkl", "function": "zzip_errno"}, {"comment_all": {"comment": "/* Set center sky coordinates in strings */", "depth": 0, "reading_ease": 56.93, "reading_grade": 6.8, "line": 616}, "comment_text": "/* Set center sky coordinates in strings */", "comment_tokens": ["Set", "center", "sky", "coordinates", "in", "strings"], "ccode": ["\n", "void\n", "setsys (comsys0)\t\t/* Set WCS coordinates as FK4 */\n", "int comsys0;\n", "{ comsys = comsys0; return; }\n", "\n", "void\n", "setcenter (rastr, decstr)\t/* Set center sky coordinates in strings */\n", "char *rastr, *decstr;\n", "{\n", "    ra0 = str2ra (rastr);\n", "    dec0 = str2dec (decstr);\n", "    return;\n", "}\n"], "project": "libwcstools-dev", "file": "imgetwcs.pkl", "function": "setcenter"}, {"comment_all": {"comment": "/*\n * Copyright (C) 1999, 2000 Red Hat, Inc.\n * All rights reserved.\n *\n * This file is part of the Gnome Library.\n *\n * The Gnome Library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * The Gnome Library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with the Gnome Library; see the file COPYING.LIB.  If not,\n * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 64.0, "reading_grade": 8.2, "line": 0}, "comment_text": "/*\n * Copyright (C) 1999, 2000 Red Hat, Inc.\n * All rights reserved.\n *\n * This file is part of the Gnome Library.\n *\n * The Gnome Library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * The Gnome Library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with the Gnome Library; see the file COPYING.LIB.  If not,\n * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["Copyright", "(", "C", ")", "1999", ",", "2000", "Red", "Hat", ",", "Inc.", "All", "rights", "reserved", ".", "This", "file", "is", "part", "of", "the", "Gnome", "Library", ".", "The", "Gnome", "Library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "The", "Gnome", "Library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "the", "Gnome", "Library", ";", "see", "the", "file", "COPYING.LIB", ".", "If", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/*\n", " * Copyright (C) 1999, 2000 Red Hat, Inc.\n", " * All rights reserved.\n", " *\n", " * This file is part of the Gnome Library.\n", " *\n", " * The Gnome Library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public License as\n", " * published by the Free Software Foundation; either version 2 of the\n", " * License, or (at your option) any later version.\n", " *\n", " * The Gnome Library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with the Gnome Library; see the file COPYING.LIB.  If not,\n", " * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "/*\n", "  @NOTATION@\n", " */\n", "\n", "#include <config.h>\n", "#include <glib-object.h>\n", "\n", "#include <libgnomecanvas/libgnomecanvas.h>\n", "\n", "GType\n", "gnome_canvas_points_get_type (void)\n", "{\n", "    static GType type_canvas_points = 0;\n", "\n", "    if (!type_canvas_points)\n", "\ttype_canvas_points = g_boxed_type_register_static\n", "\t    (\"GnomeCanvasPoints\", \n", "\t     (GBoxedCopyFunc) gnome_canvas_points_ref,\n", "\t     (GBoxedFreeFunc) gnome_canvas_points_unref);\n", "\n", "    return type_canvas_points;\n", "}\n"], "project": "libgnomecanvas2-0", "file": "libgnomecanvastypes.pkl", "function": "gnome_canvas_points_get_type"}, {"comment_all": {"comment": "/* We must send a reset because we need to reset the list of\n     signers.  Note that RESET does not reset OPTION commands. */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 954}, "comment_text": "/* We must send a reset because we need to reset the list of\n     signers.  Note that RESET does not reset OPTION commands. */", "comment_tokens": ["We", "must", "send", "a", "reset", "because", "we", "need", "to", "reset", "the", "list", "of", "signers", ".", "Note", "that", "RESET", "does", "not", "reset", "OPTION", "commands", "."], "ccode": ["\n", "\n", "static gpgme_error_t\n", "uiserver_reset (void *engine)\n", "{\n", "  engine_uiserver_t uiserver = engine;\n", "\n", "  /* We must send a reset because we need to reset the list of\n", "     signers.  Note that RESET does not reset OPTION commands. */\n", "  return uiserver_assuan_simple_command (uiserver, \"RESET\", NULL, NULL);\n", "}\n"], "project": "libqgpgme7", "file": "engine-uiserver.pkl", "function": "uiserver_reset"}, {"comment_all": {"comment": "/*\n * Remove the \"identifier\" status from a character.\n */", "depth": 0, "reading_ease": 30.53, "reading_grade": 10.7, "line": 410}, "comment_text": "/*\n * Remove the \"identifier\" status from a character.\n */", "comment_tokens": ["Remove", "the", "``", "identifier", "''", "status", "from", "a", "character", "."], "ccode": ["\n", "/*\n", " * Remove the \"identifier\" status from a character.\n", " */\n", "void unset_identifier_char(int c)\n", "{\n", "\tcppm[S_START][c] = S_ILL;\n", "\tcppm[S_NAME][c] = FRZ(STO(NAME));\n", "}\n"], "project": "libucpp-dev", "file": "lexer.pkl", "function": "unset_identifier_char"}, {"comment_all": {"comment": "/* Compare two netspecs, for searching. Test if key (only min) is inside range */", "depth": 0, "reading_ease": 81.8, "reading_grade": 3.5, "line": 315}, "comment_text": "/* Compare two netspecs, for searching. Test if key (only min) is inside range */", "comment_tokens": ["Compare", "two", "netspecs", ",", "for", "searching", ".", "Test", "if", "key", "(", "only", "min", ")", "is", "inside", "range"], "ccode": ["\n", "\n", "/* Compare two netspecs, for searching. Test if key (only min) is inside range */\n", "int netsearch(const void* a, const void* b)\n", "{\n", "\tunsigned int key = ((struct netspec*)a)->min;\n", "\tunsigned int min = ((struct netspec*)b)->min;\n", "\tunsigned int max = ((struct netspec*)b)->max;\n", "\tif (key < min) return -1;\n", "\tif (key > max) return +1;\n", "\treturn 0;\n", "}\n"], "project": "grepcidr", "file": "grepcidr.pkl", "function": "netsearch"}, {"comment_all": {"comment": "/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */", "depth": 1, "reading_ease": 59.64, "reading_grade": 9.9, "line": 3638}, "comment_text": "/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */", "comment_tokens": ["yy_ch_buf", "has", "to", "be", "2", "characters", "longer", "than", "the", "size", "given", "because", "we", "need", "to", "put", "in", "2", "end-of-buffer", "characters", "."], "ccode": ["\n", "/** Allocate and initialize an input buffer state.\n", " * @param file A readable stream.\n", " * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.\n", " * \n", " * @return the allocated buffer state.\n", " */\n", "    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "    \n", "\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n", "\n", "\tb->yy_buf_size = size;\n", "\n", "\t/* yy_ch_buf has to be 2 characters longer than the size given because\n", "\t * we need to put in 2 end-of-buffer characters.\n", "\t */\n", "\tb->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );\n", "\tif ( ! b->yy_ch_buf )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n", "\n", "\tb->yy_is_our_buffer = 1;\n", "\n", "\tyy_init_buffer( b, file );\n", "\n", "\treturn b;\n", "}\n"], "project": "linux-aws-5.11-headers-5.11.0-1021", "file": "lexer.lex.pkl", "function": "yy_create_buffer"}, {"comment_all": {"comment": "/* Return 0 if on or 1 if off */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 111}, "comment_text": "/* Return 0 if on or 1 if off */", "comment_tokens": ["Return", "0", "if", "on", "or", "1", "if", "off"], "ccode": ["/*\n", " * Copyright (c) 1980 The Regents of the University of California.\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " * 3. All advertising materials mentioning features or use of this software\n", " *    must display the following acknowledgement:\n", " *\tThis product includes software developed by the University of\n", " *\tCalifornia, Berkeley and its contributors.\n", " * 4. Neither the name of the University nor the names of its contributors\n", " *    may be used to endorse or promote products derived from this software\n", " *    without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "\n", "char copyright[] =\n", "\"@(#) Copyright (c) 1980 The Regents of the University of California.\\n\"\n", "\"All rights reserved.\\n\";\n", "\n", "/*\n", " * From: @(#)biff.c\t5.3 (Berkeley) 6/1/90\n", " */\n", "char rcsid[] = \"$Id: biff.c,v 1.11 1999/12/12 13:19:27 dholland Exp $\";\n", "\n", "/*\n", " * biff\n", " */\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <sys/stat.h>\n", "#include \"../version.h\"\n", "\n", "int \n", "main(int argc, char *argv[])\n", "{\n", "\tchar *tty;       /* name of tty */\n", "\tstruct stat stb; /* storage for return of stat on tty */\n", "  \n", "\t/* \n", "\t * ttyname() returns a pointer to the pathname of the\n", "\t * terminal device that is open on the specified file\n", "\t * descriptor. If this fails tell the user.\n", "\t */\n", "  \n", "\ttty = ttyname(STDERR_FILENO);\n", "\n", "\tif (tty == NULL) {\n", "\t\tfprintf(stderr, \"stderr is not a tty - where are you?\\n\");\n", "\t\texit(1);\n", "\t}\n", "  \n", "\t/* stat() the tty */\n", "  \n", "\tif (stat(tty, &stb)==-1) {\n", "\t\tperror(tty);\n", "\t\texit(1);\n", "\t}\n", "  \n", "\t/* \n", "\t * If no command line arguments are specified then simply return\n", "\t * the current status to the user.\n", "\t */\n", "  \n", "\tif (argc == 1)  {\n", "\t\t/* if user execute bit is on (ie biff y) */\n", "\t\tif(stb.st_mode&0100) {\n", "\t\t\tprintf(\"is y\\n\");\n", "\t\t} else {\n", "\t\t\tprintf(\"is n\\n\");\n", "\t\t}\n", "\t} else {\n", "\t\t/* If there's a command line argument... */\n", "\t\t/* switch based on argument */\n", "\t\tswitch (argv[1][0]) {\n", "\t\tcase 'y': \n", "\t\t\t/* user entered biff y */\n", "\t\t\tif (chmod(tty, stb.st_mode|0100) == -1)\n", "\t\t\t\tperror(tty);\n", "\t\t\tbreak;\n", "\n", "\t\tcase 'n': \n", "\t\t\t/* user entered biff n */\n", "\t\t\tif (chmod(tty, stb.st_mode&~0100) == -1)\n", "\t\t\t\tperror(tty);\n", "\t\t\tbreak;\n", "      \n", "\t\tdefault: \n", "\t\t\t/* They used neither of the correct arguments -Doh! */\n", "\t\t\tfprintf(stderr, \"usage: biff [y|n]\\n\");\n", "\t\t}\n", "\t}\n", "\t\n", "\treturn (stb.st_mode&0100) ? 0 : 1; /* Return 0 if on or 1 if off */\n", "}\n"], "project": "biff", "file": "biff.pkl", "function": "main"}, {"comment_all": {"comment": "/* If P is null, allocate a block of at least *PN bytes; otherwise,\n   reallocate P so that it contains more than *PN bytes.  *PN must be\n   nonzero unless P is null.  Set *PN to the new block's size, and\n   return the pointer to the new block.  *PN is never set to zero, and\n   the returned pointer is never null.  */", "depth": 0, "reading_ease": 81.83, "reading_grade": 5.5, "line": 66}, "comment_text": "/* If P is null, allocate a block of at least *PN bytes; otherwise,\n   reallocate P so that it contains more than *PN bytes.  *PN must be\n   nonzero unless P is null.  Set *PN to the new block's size, and\n   return the pointer to the new block.  *PN is never set to zero, and\n   the returned pointer is never null.  */", "comment_tokens": ["If", "P", "is", "null", ",", "allocate", "a", "block", "of", "at", "least", "PN", "bytes", ";", "otherwise", ",", "reallocate", "P", "so", "that", "it", "contains", "more", "than", "PN", "bytes", ".", "PN", "must", "be", "nonzero", "unless", "P", "is", "null", ".", "Set", "PN", "to", "the", "new", "block", "'s", "size", ",", "and", "return", "the", "pointer", "to", "the", "new", "block", ".", "PN", "is", "never", "set", "to", "zero", ",", "and", "the", "returned", "pointer", "is", "never", "null", "."], "ccode": ["\n", "/* If P is null, allocate a block of at least *PN bytes; otherwise,\n", "   reallocate P so that it contains more than *PN bytes.  *PN must be\n", "   nonzero unless P is null.  Set *PN to the new block's size, and\n", "   return the pointer to the new block.  *PN is never set to zero, and\n", "   the returned pointer is never null.  */\n", "\n", "void *\n", "x2realloc (void *p, size_t *pn)\n", "{\n", "  return x2nrealloc (p, pn, 1);\n", "}\n"], "project": "libgsasl7-dev", "file": "xmalloc.pkl", "function": "x2realloc"}, {"comment_all": {"comment": "/*      -*- linux-c -*-\n *\n * (C) Copright IBM Corp 2004,2006\n * (C) Copyright Pigeon Point Systems. 2010\n * (C) Copyright Nokia Siemens Networks 2010\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This\n * file and program are licensed under a BSD style license.  See\n * the Copying file included with the OpenHPI distribution for\n * full licensing terms.\n *\n * Authors:\n *     Renier Morales <renier@openhpi.org>\n *     Anton Pak <anton.pak@pigeonpoint.com>\n *     Ulrich Kleber <ulikleber@users.sourceforge.net>\n */", "depth": 0, "reading_ease": 51.24, "reading_grade": 9.0, "line": 0}, "comment_text": "/*      -*- linux-c -*-\n *\n * (C) Copright IBM Corp 2004,2006\n * (C) Copyright Pigeon Point Systems. 2010\n * (C) Copyright Nokia Siemens Networks 2010\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This\n * file and program are licensed under a BSD style license.  See\n * the Copying file included with the OpenHPI distribution for\n * full licensing terms.\n *\n * Authors:\n *     Renier Morales <renier@openhpi.org>\n *     Anton Pak <anton.pak@pigeonpoint.com>\n *     Ulrich Kleber <ulikleber@users.sourceforge.net>\n */", "comment_tokens": ["--", "linux-c", "--", "(", "C", ")", "Copright", "IBM", "Corp", "2004,2006", "(", "C", ")", "Copyright", "Pigeon", "Point", "Systems", ".", "2010", "(", "C", ")", "Copyright", "Nokia", "Siemens", "Networks", "2010", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "This", "file", "and", "program", "are", "licensed", "under", "a", "BSD", "style", "license", ".", "See", "the", "Copying", "file", "included", "with", "the", "OpenHPI", "distribution", "for", "full", "licensing", "terms", ".", "Authors", ":", "Renier", "Morales", "<", "renier", "@", "openhpi.org", ">", "Anton", "Pak", "<", "anton.pak", "@", "pigeonpoint.com", ">", "Ulrich", "Kleber", "<", "ulikleber", "@", "users.sourceforge.net", ">"], "ccode": ["/*      -*- linux-c -*-\n", " *\n", " * (C) Copright IBM Corp 2004,2006\n", " * (C) Copyright Pigeon Point Systems. 2010\n", " * (C) Copyright Nokia Siemens Networks 2010\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This\n", " * file and program are licensed under a BSD style license.  See\n", " * the Copying file included with the OpenHPI distribution for\n", " * full licensing terms.\n", " *\n", " * Authors:\n", " *     Renier Morales <renier@openhpi.org>\n", " *     Anton Pak <anton.pak@pigeonpoint.com>\n", " *     Ulrich Kleber <ulikleber@users.sourceforge.net>\n", " */\n", "\n", "#include <string.h>\n", "\n", "#include <oHpi.h>\n", "\n", "#include <config.h>\n", "\n", "#include <oh_domain.h>\n", "#include <oh_error.h>\n", "#include <oh_plugin.h>\n", "#include <oh_session.h>\n", "#include <oh_utils.h>\n", "#include <sahpimacros.h>\n", "\n", "#include \"conf.h\"\n", "#include \"event.h\"\n", "#include \"init.h\"\n", "#include \"lock.h\"\n", "\n", "\n", "/**\n", " * oHpiVersionGet\n", " */\n", "SaHpiUint64T oHpiVersionGet()\n", "{\n", "        SaHpiUint64T v = 0;\n", "\n", "\tOHPI_VERSION_GET(v, VERSION);\n", "\n", "        return v;\n", "}\n"], "project": "openhpi-plugin-watchdog", "file": "ohpi.pkl", "function": "oHpiVersionGet"}, {"comment_all": {"comment": "/*  Find translation spec by its ID (SpecID).\n *  Arguments:\n *\tSpec ID (an int).\n *  Return:\n *\tPointer to translation spec that matches name.\n */", "depth": 0, "reading_ease": 73.13, "reading_grade": 4.7, "line": 591}, "comment_text": "/*  Find translation spec by its ID (SpecID).\n *  Arguments:\n *\tSpec ID (an int).\n *  Return:\n *\tPointer to translation spec that matches name.\n */", "comment_tokens": ["Find", "translation", "spec", "by", "its", "ID", "(", "SpecID", ")", ".", "Arguments", ":", "Spec", "ID", "(", "an", "int", ")", ".", "Return", ":", "Pointer", "to", "translation", "spec", "that", "matches", "name", "."], "ccode": ["\n", "/*  Find translation spec by its ID (SpecID).\n", " *  Arguments:\n", " *\tSpec ID (an int).\n", " *  Return:\n", " *\tPointer to translation spec that matches name.\n", " */\n", "Trans_t *\n", "FindTranByID(int n)\n", "{\n", "    Trans_t\t*t;\n", "\n", "    for (t=TrSpecs; t; t=t->next)\n", "\tif (n == t->my_id) return t;\n", "    return NULL;\n", "}\n"], "project": "docbook-to-man", "file": "translate.pkl", "function": "FindTranByID"}, {"comment_all": {"comment": "/* probably use 'size-allocate' signal later */", "depth": 2, "reading_ease": 15.64, "reading_grade": 12.3, "line": 1187}, "comment_text": "/* FIXME: update drawing of scrolled window */\n/* probably use 'size-allocate' signal later */\n", "comment_tokens": ["FIXME", ":", "update", "drawing", "of", "scrolled", "window", "probably", "use", "'size-allocate", "'", "signal", "later"], "ccode": ["\n", "/*------------------------------------------------------------------------------*/\n", "\n", "void\n", "readonly_toggle_cb (GtkToggleButton *togglebutton, gpointer data) {\n", "\n", "    GUI *appGUI = (GUI *)data;\n", "\tGtkAdjustment *vadj = NULL;\n", "\tgint nbtns, i;\n", "\tgboolean s = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (appGUI->nte->readonly_checkbutton));\n", "\n", "\tgtk_text_view_set_editable (GTK_TEXT_VIEW (appGUI->nte->editor_textview), !s);\n", "\tgtk_text_view_set_cursor_visible (GTK_TEXT_VIEW (appGUI->nte->editor_textview), !s);\n", "\tgtk_widget_set_sensitive (appGUI->nte->font_picker, !s);\n", "\n", "\tif (s == TRUE) {    /* read-only */\n", "\n", "\t\tupdate_readonly_view (appGUI);\n", "\n", "\t\tgtk_label_set_text(GTK_LABEL(appGUI->nte->nrow_label), \"-\");\n", "\t\tgtk_label_set_text(GTK_LABEL(appGUI->nte->ncol_label), \"-\");\n", "#ifdef HAVE_LIBWEBKIT\n", "\t\tgtk_widget_hide(appGUI->nte->editor_viewport);\n", "\t\tgtk_widget_show(appGUI->nte->ro_editor_viewport);\n", "#endif /* HAVE_LIBWEBKIT */\n", "\n", "\t\twhile (gtk_events_pending ()) gtk_main_iteration ();    /* FIXME: update drawing of scrolled window */\n", "                                                                /* probably use 'size-allocate' signal later */\n", "\n", "\t\tvadj = gtk_scrolled_window_get_vadjustment (GTK_SCROLLED_WINDOW(appGUI->nte->ro_editor_scrolledwindow));\n", "\t\tgtk_adjustment_set_value(GTK_ADJUSTMENT(vadj), appGUI->nte->htmlViewPosition);\n", "\t\tgtk_scrolled_window_set_vadjustment (GTK_SCROLLED_WINDOW(appGUI->nte->ro_editor_scrolledwindow), GTK_ADJUSTMENT(vadj));\n", "\t\n", "\t} else {\n", "\t\t\n", "\t\tvadj = gtk_scrolled_window_get_vadjustment (GTK_SCROLLED_WINDOW(appGUI->nte->ro_editor_scrolledwindow));\n", "\t\tappGUI->nte->htmlViewPosition = gtk_adjustment_get_value(GTK_ADJUSTMENT(vadj));\n", "\n", "#ifdef HAVE_LIBWEBKIT\n", "\t\tgtk_widget_show(appGUI->nte->editor_viewport);\n", "\t\tgtk_widget_hide(appGUI->nte->ro_editor_viewport);\n", "#endif /* HAVE_LIBWEBKIT */\n", "\n", "\t\teditor_cursor_move_cb (gtk_text_view_get_buffer (GTK_TEXT_VIEW (appGUI->nte->editor_textview)),\n", "\t\t\t\t\t\t\t   NULL, NULL, appGUI);\n", "\t\tgtk_widget_grab_focus (appGUI->nte->editor_textview);\n", "\t}\n", "\n", "\tappGUI->nte->note_read_only = s;\n", "\n", "\tfor (i = 0, nbtns = gtk_toolbar_get_n_items(appGUI->nte->editor_toolbar) - 1; i < nbtns; i++) {\n", "\t\tGtkToolItem *item = gtk_toolbar_get_nth_item(appGUI->nte->editor_toolbar, i);\n", "\t\tif (GTK_IS_TOOL_BUTTON(item) == TRUE) {\n", "\t\t\tgtk_widget_set_sensitive(GTK_WIDGET(item), !s);\n", "\t\t}\n", "\t}\n", "\n", "}\n"], "project": "osmo", "file": "notes.pkl", "function": "readonly_toggle_cb"}, {"comment_all": {"comment": "/* libmypaint - The MyPaint Brush Library\n * Copyright (C) 2012 Jon Nordby <jononor@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */", "depth": 0, "reading_ease": 40.52, "reading_grade": 15.2, "line": 0}, "comment_text": "/* libmypaint - The MyPaint Brush Library\n * Copyright (C) 2012 Jon Nordby <jononor@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */", "comment_tokens": ["libmypaint", "-", "The", "MyPaint", "Brush", "Library", "Copyright", "(", "C", ")", "2012", "Jon", "Nordby", "<", "jononor", "@", "gmail.com", ">", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "andor", "distribute", "this", "software", "for", "any", "purpose", "with", "or", "without", "fee", "is", "hereby", "granted", ",", "provided", "that", "the", "above", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "all", "copies", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", "AND", "THE", "AUTHOR", "DISCLAIMS", "ALL", "WARRANTIES", "WITH", "REGARD", "TO", "THIS", "SOFTWARE", "INCLUDING", "ALL", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHOR", "BE", "LIABLE", "FOR", "ANY", "SPECIAL", ",", "DIRECT", ",", "INDIRECT", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "OR", "ANY", "DAMAGES", "WHATSOEVER", "RESULTING", "FROM", "LOSS", "OF", "USE", ",", "DATA", "OR", "PROFITS", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "NEGLIGENCE", "OR", "OTHER", "TORTIOUS", "ACTION", ",", "ARISING", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "USE", "OR", "PERFORMANCE", "OF", "THIS", "SOFTWARE", "."], "ccode": ["/* libmypaint - The MyPaint Brush Library\n", " * Copyright (C) 2012 Jon Nordby <jononor@gmail.com>\n", " *\n", " * Permission to use, copy, modify, and/or distribute this software for any\n", " * purpose with or without fee is hereby granted, provided that the above\n", " * copyright notice and this permission notice appear in all copies.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n", " * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n", " * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n", " * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n", " * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n", " * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n", " * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <assert.h>\n", "\n", "#include \"mypaint-utils-stroke-player.h\"\n", "\n", "int lines_in_string(const char *str) {\n", "    int lines = 0;\n", "    while (*str) {\n", "        if (*str == '\\n') {\n", "            lines++;\n", "        }\n", "        str++;\n", "    }\n", "    return lines;\n", "}\n"], "project": "libmypaint-dev", "file": "mypaint-utils-stroke-player.pkl", "function": "lines_in_string"}, {"comment_all": {"comment": "/* Like sdscpylen() but 't' must be a null-termined string so that the length\n * of the string is obtained with strlen(). */", "depth": 0, "reading_ease": 85.02, "reading_grade": 6.4, "line": 415}, "comment_text": "/* Like sdscpylen() but 't' must be a null-termined string so that the length\n * of the string is obtained with strlen(). */", "comment_tokens": ["Like", "sdscpylen", "(", ")", "but", "'t", "'", "must", "be", "a", "null-termined", "string", "so", "that", "the", "length", "of", "the", "string", "is", "obtained", "with", "strlen", "(", ")", "."], "ccode": ["\n", "/* Like sdscpylen() but 't' must be a null-termined string so that the length\n", " * of the string is obtained with strlen(). */\n", "sds sdscpy(sds s, const char *t) {\n", "    return sdscpylen(s, t, strlen(t));\n", "}\n"], "project": "libhiredis0.14", "file": "sds.pkl", "function": "sdscpy"}, {"comment_all": {"comment": "/*\n     * if a tty, make it raw as the hp echos _everything_, including\n     * passwords.\n     */", "depth": 1, "reading_ease": 75.2, "reading_grade": 6.0, "line": 226}, "comment_text": "/*\n     * if a tty, make it raw as the hp echos _everything_, including\n     * passwords.\n     */", "comment_tokens": ["if", "a", "tty", ",", "make", "it", "raw", "as", "the", "hp", "echos", "_everything_", ",", "including", "passwords", "."], "ccode": ["/*\n", " * Copyright (c) 1997-2019 by Henry Kilmer and John Heasley\n", " * All rights reserved.\n", " *\n", " * This code is derived from software contributed to and maintained by\n", " * Henry Kilmer, John Heasley, Andrew Partan,\n", " * Pete Whiting, Austin Schutz, and Andrew Fort.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " * 3. Neither the name of RANCID nor the names of its\n", " *    contributors may be used to endorse or promote products derived from\n", " *    this software without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY Henry Kilmer, John Heasley AND CONTRIBUTORS\n", " * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n", " * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n", " * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COMPANY OR CONTRIBUTORS\n", " * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n", " * POSSIBILITY OF SUCH DAMAGE.\n", " *\n", " * It is the request of the authors, but not a condition of license, that\n", " * parties packaging or redistributing RANCID NOT distribute altered versions\n", " * of the etc/rancid.types.base file nor alter how this file is processed nor\n", " * when in relation to etc/rancid.types.conf.  The goal of this is to help\n", " * suppress our support costs.  If it becomes a problem, this could become a\n", " * condition of license.\n", " *\n", " * Modified openpty() from NetBSD:\n", " * Copyright (c) 1990, 1993, 1994\n", " *\tThe Regents of the University of California.  All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " * 3. Neither the name of the University nor the names of its contributors\n", " *    may be used to endorse or promote products derived from this software\n", " *    without specific prior written permission.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " */\n", "\n", "\n", "#include \"config.h\"\n", "#include \"version.h\"\n", "\n", "#if HAVE_UNISTD_H\n", "# include <unistd.h>\n", "#endif\n", "\n", "#if HAVE_CTYPE_H\n", "# include <ctype.h>\n", "#endif\n", "#include <stdio.h>\n", "#include <limits.h>\n", "#include <fcntl.h>\n", "#include <poll.h>\n", "#if HAVE_PTY_H\n", "# include <pty.h>\n", "#endif\n", "#include <regex.h>\n", "#include <signal.h>\n", "#if HAVE_STRING_H\n", "# if !STDC_HEADERS && HAVE_MEMORY_H\n", "#  include <memory.h>\n", "# endif\n", "# include <string.h>\n", "#endif\n", "#if HAVE_STRINGS_H\n", "# include <strings.h>\n", "#endif\n", "#if HAVE_PTMX && HAVE_STROPTS_H\n", "# include <stropts.h>\n", "#endif\n", "#include <sys/ioctl.h>\n", "#if HAVE_SYS_RESOURCE_H\n", "# include <sys/resource.h>\n", "#endif\n", "#include <sys/stat.h>\n", "#include <sys/time.h>\n", "#include <termios.h>\n", "#if HAVE_WAIT_H\n", "# include <wait.h>\n", "#elif HAVE_SYS_WAIT_H\n", "# include <sys/wait.h>\n", "#endif\n", "#if HAVE_UTIL_H\n", "# include <util.h>\n", "#elif HAVE_LIBUTIL_H\n", "# include <libutil.h>\n", "#endif\n", "\n", "#define\tBUFSZ\t(LINE_MAX * 2)\n", "#define\tESC\t0x1b\n", "\n", "char\t\t**environ,\n", "\t\t*progname;\n", "int\t\tdebug,\n", "\t\tsigrx,\n", "\t\ttimeo = 5;\t\t\t\t/* default timeout   */\n", "pid_t\t\tchild;\n", "\n", "int\t\tcomplete_esc(char *buf, int len);\n", "int\t\tfilter(char *, int);\n", "size_t\t\tmystrcspn(const char *, const char *);\n", "RETSIGTYPE\treapchild(int);\n", "#if !HAVE_OPENPTY\n", "int\t\topenpty(int *, int *, char *, struct termios *,\n", "\t\t\tstruct winsize *);\n", "#endif\n", "RETSIGTYPE\tsighdlr(int);\n", "#if !HAVE_UNSETENV\n", "int\t\tunsetenv(const char *);\n", "#endif\n", "void\t\tusage(void);\n", "void\t\tvers(void);\n", "\n", "int\n", "main(int argc, char **argv, char **ev)\n", "{\n", "    extern char\t\t*optarg;\n", "    extern int\t\toptind;\n", "    char\t\thbuf[BUFSZ],\t\t/* hlogin buffer */\n", "\t\t\tptyname[FILENAME_MAX + 1],\n", "\t\t\ttbuf[BUFSZ],\t\t/* telnet/ssh buffer */\n", "\t\t\ttbufstr[5] = {ESC, '\\x07', '\\r', '\\n', '\\0'};\n", "    int\t\t\tbytes,\t\t\t/* bytes read/written */\n", "\t\t\tdevnull,\n", "\t\t\ti,\n", "\t\t\trval = EX_OK,\n", "\t\t\tptym,\t\t\t/* master pty */\n", "\t\t\tptys;\t\t\t/* slave pty */\n", "    ssize_t\t\tidx,\t\t\t/* strcspan span */\n", "\t\t\thlen = 0,\t\t/* len of hbuf */\n", "\t\t\ttlen = 0;\t\t/* len of tbuf */\n", "    struct pollfd\tpfds[3];\n", "    struct termios\ttios;\n", "\n", "    environ = ev;\n", "\n", "    /* get just the basename() of our exec() name and strip a .* off the end */\n", "    if ((progname = strrchr(argv[0], '/')) != NULL)\n", "\tprogname += 1;\n", "    else\n", "\tprogname = argv[0];\n", "    if (strrchr(progname, '.') != NULL)\n", "\t*(strrchr(progname, '.')) = '\\0';\n", "\n", "    while ((i = getopt(argc, argv, \"dhvt:\")) != -1 )\n", "\tswitch (i) {\n", "\tcase 'd':\n", "\t    debug++;\n", "\t    break;\n", "\tcase 't':\n", "\t    timeo = atoi(optarg);\n", "\t    if (timeo < 1)\n", "\t\ttimeo = 1;\n", "\t    break;\n", "\tcase 'v':\n", "\t    vers();\n", "\t    return(EX_OK);\n", "\tcase 'h':\n", "\tdefault:\n", "\t    usage();\n", "\t    return(EX_USAGE);\n", "\t}\n", "\n", "    if (argc - optind < 2) {\n", "\tusage();\n", "\treturn(EX_USAGE);\n", "    }\n", "\n", "    unsetenv(\"DISPLAY\");\n", "\n", "    for (sigrx = 3; sigrx < 10; sigrx++)\n", "\tclose(sigrx);\n", "\n", "    /* allocate pty for telnet/ssh, then fork and exec */\n", "    if (openpty(&ptym, &ptys, ptyname, NULL, NULL)) {\n", "\tfprintf(stderr, \"%s: could not allocate pty: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\treturn(EX_TEMPFAIL);\n", "    }\n", "    /* make the pty raw */\n", "    if (tcgetattr(ptys, &tios)) {\n", "\tfprintf(stderr, \"%s: tcgetattr() failed: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\treturn(EX_OSERR);\n", "    }\n", "    tios.c_lflag &= ~ICANON;\n", "#ifdef VMIN\n", "    tios.c_cc[VMIN] = 1;\n", "    tios.c_cc[VTIME] = 0;\n", "#endif\n", "    if (tcsetattr(ptys, TCSANOW, &tios)) {\n", "\tfprintf(stderr, \"%s: tcsetattr() failed: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\treturn(EX_OSERR);\n", "    }\n", "\n", "    /*\n", "     * if a tty, make it raw as the hp echos _everything_, including\n", "     * passwords.\n", "     */\n", "    tios.c_lflag &= ~ECHO;\n", "    if (isatty(fileno(stdin))) {\n", "\tif (tcgetattr(fileno(stdin), &tios)) {\n", "\t    fprintf(stderr, \"%s: tcgetattr() failed: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\t    return(EX_OSERR);\n", "\t}\n", "\ttios.c_lflag &= ~ECHO;\n", "\ttios.c_lflag &= ~ICANON;\n", "#ifdef VMIN\n", "\ttios.c_cc[VMIN] = 1;\n", "\ttios.c_cc[VTIME] = 0;\n", "#endif\n", "\tif (tcsetattr(fileno(stdin), TCSANOW, &tios)) {\n", "\t    fprintf(stderr, \"%s: tcsetattr() failed: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\t    return(EX_OSERR);\n", "\t}\n", "    }\n", "\n", "    /* zero the buffers */\n", "    memset(hbuf, 0, BUFSZ);\n", "    memset(tbuf, 0, BUFSZ);\n", "\n", "    /* reap our children, must be set-up *after* openpty() */\n", "    signal(SIGCHLD, reapchild);\n", "\n", "    if ((child = fork()) == -1) {\n", "\tfprintf(stderr, \"%s: fork() failed: %s\\n\", progname, strerror(errno));\n", "\treturn(EX_TEMPFAIL);\n", "    }\n", "\n", "    if (child == 0) {\n", "\tstruct winsize ws;\n", "\n", "\t/*\n", "\t * Make sure our terminal length and width are something greater\n", "\t * than 1, for pagers on stupid boxes.\n", "\t */\n", "\tioctl(ptys, TIOCGWINSZ, &ws);\n", "\tws.ws_row = 24;\n", "\tws.ws_col = 132;\n", "\tioctl(ptys, TIOCSWINSZ, &ws);\n", "\n", "\tsignal(SIGCHLD, SIG_DFL);\n", "\t/* close the master pty & std* inherited from the parent */\n", "\tclose(ptym);\n", "\tif (ptys != 0)\n", "\t    close(0);\n", "\tif (ptys != 1)\n", "\t    close(1);\n", "\tif (ptys != 2)\n", "\t    close(2);\n", "#ifdef TIOCSCTTY\n", "\tsetsid();\n", "\tif (ioctl(ptys, TIOCSCTTY, NULL) == -1) {\n", "\t    snprintf(ptyname, FILENAME_MAX, \"%s: could not set controlling \"\n", "\t\t     \"tty: %s\\n\", progname, strerror(errno));\n", "\t    write(0, ptyname, strlen(ptyname));\n", "\t    return(EX_OSERR);\n", "\t}\n", "#endif\n", "\n", "\t/* close stdin/out/err and attach them to the pipes */\n", "\tif (dup2(ptys, 0) == -1 || dup2(ptys, 1) == -1 || dup2(ptys, 2) == -1) {\n", "\t    snprintf(ptyname, FILENAME_MAX, \"%s: dup2() failed: %s\\n\", progname,\n", "\t\t     strerror(errno));\n", "\t    write(0, ptyname, strlen(ptyname));\n", "\t    return(EX_OSERR);\n", "\t}\n", "\tif (ptys > 2)\n", "\t    close(ptys);\n", "\n", "\t/* exec telnet/ssh */\n", "\texecvp(argv[optind], argv + optind);\n", "\tsnprintf(ptyname, FILENAME_MAX, \"%s: execvp() failed: %s\\n\", progname,\n", "\t\t strerror(errno));\n", "\twrite(0, ptyname, strlen(ptyname));\n", "\treturn(EX_TEMPFAIL);\n", "\t/*NOTREACHED*/\n", "    }\n", "\n", "    /* parent */\n", "    if (debug)\n", "\tfprintf(stderr, \"child %d\\n\", (int)child);\n", "\n", "    signal(SIGHUP, sighdlr);\n", "\n", "    /* close the slave pty */\n", "    close(ptys);\n", "\n", "    devnull = open(\"/dev/null\", O_RDWR);\n", "\n", "    /* make FDs non-blocking */\n", "    if (fcntl(ptym, F_SETFL, O_NONBLOCK) ||\n", "\tfcntl(fileno(stdin), F_SETFL, O_NONBLOCK) ||\n", "\tfcntl(fileno(stdout), F_SETFL, O_NONBLOCK)) {\n", "\tfprintf(stderr, \"%s: fcntl(NONBLOCK) failed: %s\\n\", progname,\n", "\t\tstrerror(errno));\n", "\texit(EX_OSERR);\n", "    }\n", "\n", "    /* loop to read on stdin and ptym */\n", "#define\tPOLLEXP\t(POLLERR | POLLHUP | POLLNVAL)\n", "    pfds[0].fd = fileno(stdin);\n", "    pfds[0].events = POLLIN | POLLEXP;\n", "    pfds[1].fd = fileno(stdout);\n", "    pfds[1].events = POLLEXP;\n", "    pfds[2].fd = ptym;\n", "    pfds[2].events = POLLIN | POLLEXP;\n", "\n", "    /* shuffle data across the pipes until we see EOF or a read/write error */\n", "    sigrx = 0;\n", "    while (1) {\n", "\tbytes = poll(pfds, 3, (timeo * 1000));\n", "\tif (bytes == 0) {\n", "\t    if (sigrx)\n", "\t\tbreak;\n", "\t    /* timeout */\n", "\t    continue;\n", "\t}\n", "\tif (bytes == -1) {\n", "\t    switch (errno) {\n", "\t    case EAGAIN:\n", "\t    case EINTR:\n", "\t\tbreak;\n", "\t    default:\n", "\t\trval = EX_IOERR;\n", "\t\tbreak;\n", "\t    }\n", "\t    continue;\n", "\t}\n", "\n", "\t/*\n", "\t * write buffers first\n", "\t * write hbuf (aka hlogin/stdin/pfds[0]) -> telnet (aka ptym/pfds[2])\n", "\t */\n", "\tif ((pfds[2].revents & POLLOUT) && hlen) {\n", "\t    if ((bytes = write(pfds[2].fd, hbuf, hlen)) < 0 &&\n", "\t\terrno != EINTR && errno != EAGAIN) {\n", "\t\tfprintf(stderr, \"%s: write() failed: %s\\n\", progname,\n", "\t\t\tstrerror(errno));\n", "\t\thlen = 0;\n", "\t\thbuf[0] = '\\0';\n", "\t\tbreak;\n", "\t    } else if (bytes > 0) {\n", "\t\thlen -= bytes;\n", "\t\tif (hlen < 1) {\n", "\t\t    pfds[2].events &= ~POLLOUT;\n", "\t\t    hbuf[0] = '\\0';\n", "\t\t} else\n", "\t\t    memmove(hbuf, hbuf + bytes, hlen + 1);\n", "\t    }\n", "\t}\n", "\tif (pfds[2].revents & POLLEXP) {\n", "\t    hlen = 0;\n", "\t    hbuf[0] = '\\0';\n", "\t    break;\n", "\t}\n", "\n", "\t/* write tbuf (aka telnet/ptym/pfds[2]) -> hlogin (stdout/pfds[1]) */\n", "\tif ((pfds[1].revents & POLLOUT) && tlen) {\n", "\t    /*\n", "\t     * if there is an escape char that was not filtered by filter(),\n", "\t     * we need to write only up to that point and wait for\n", "\t     * the bits that complete the escape sequence.  if at least\n", "\t     * two bytes follow it and it doesn't look like we should expect\n", "\t     * more data, write it anyway as filter() didnt match it.\n", "\t     */\n", "\t    bytes = tlen;\n", "\t    idx = mystrcspn(tbuf, tbufstr);\n", "\t    if (idx) {\n", "\t\tif (tbuf[idx] == ESC)\n", "\t\t    bytes = idx + complete_esc(&tbuf[idx], tlen - idx);\n", "\t\tif (tbuf[idx] == '\\r' || tbuf[idx] == '\\n') {\n", "\t\t    bytes = ++idx;\n", "\t\t    if (tbuf[idx] == '\\r' || tbuf[idx] == '\\n')\n", "\t\t\tbytes++;\n", "\t\t}\n", "\t    } else {\n", "\t\tif (tbuf[0] == ESC)\n", "\t\t    bytes = complete_esc(tbuf, tlen);\n", "\t\tif (tbuf[0] == '\\r' || tbuf[0] == '\\n') {\n", "\t\t    bytes = 1;\n", "\t\t    if (tbuf[1] == '\\r' || tbuf[1] == '\\n')\n", "\t\t\tbytes++;\n", "\t\t}\n", "\t    }\n", "\n", "\t    if ((bytes = write(pfds[1].fd, tbuf, bytes)) < 0 &&\n", "\t\terrno != EINTR && errno != EAGAIN) {\n", "\t\tfprintf(stderr, \"%s: write() failed: %s\\n\", progname,\n", "\t\t\tstrerror(errno));\n", "\t\t/* dont bother trying to flush tbuf */\n", "\t\ttlen = 0;\n", "\t\ttbuf[0] = '\\0';\n", "\t\tbreak;\n", "\t    } else if (bytes > 0) {\n", "\t\ttlen -= bytes;\n", "\t\tif (tlen < 1) {\n", "\t\t    tbuf[0] = '\\0';\n", "\t\t    pfds[1].events &= ~POLLOUT;\n", "\t\t} else\n", "\t\t    memmove(tbuf, tbuf + bytes, tlen + 1);\n", "\t    }\n", "\t}\n", "\tif (pfds[1].revents & POLLEXP) {\n", "\t    /* dont bother trying to flush tbuf */\n", "\t    tlen = 0;\n", "\t    tbuf[0] = '\\0';\n", "\t    break;\n", "\t}\n", "\n", "\t/* read hlogin (aka stdin/pfds[0]) -> hbuf */\n", "\tif (pfds[0].revents & POLLIN) {\n", "\t    if (BUFSZ - hlen > 1) {\n", "\t\tbytes = read(pfds[0].fd, hbuf + hlen, (BUFSZ - 1) - hlen);\n", "\t\tif (bytes > 0) {\n", "\t\t    hlen += bytes;\n", "\t\t    hbuf[hlen] = '\\0';\n", "\t\t    pfds[2].events |= POLLOUT;\n", "\t\t} else if (bytes < 0 && errno != EAGAIN && errno != EINTR) {\n", "\t\t    /* read error */\n", "\t\t    break;\n", "\t\t}\n", "\t    }\n", "\t}\n", "\tif (pfds[0].revents & POLLEXP)\n", "\t    break;\n", "\n", "\t/* read telnet/ssh (aka ptym/pfds[2]) -> tbuf, then filter */\n", "\tif (pfds[2].revents & POLLIN) {\n", "\t    if (BUFSZ - tlen > 1) {\n", "\t\tbytes = read(pfds[2].fd, tbuf + tlen, (BUFSZ - 1) - tlen);\n", "\t\tif (bytes > 0) {\n", "\t\t    tlen += bytes;\n", "\t\t    tbuf[tlen] = '\\0';\n", "\t\t    tlen = filter(tbuf, tlen);\n", "\t\t    if (tlen > 0)\n", "\t\t\tpfds[1].events |= POLLOUT;\n", "\t\t} else if (bytes < 0 && errno != EAGAIN && errno != EINTR) {\n", "\t\t    /* read error */\n", "\t\t    break;\n", "\t\t}\n", "\t    }\n", "\t}\n", "\tif (pfds[2].revents & POLLEXP)\n", "\t    break;\n", "    }\n", "    /* try to flush any remaining data from our buffers */\n", "    if (hlen) {\n", "\t(void)write(pfds[2].fd, hbuf, hlen);\n", "\thlen = 0;\n", "    }\n", "    if (tlen) {\n", "\t(void)write(pfds[1].fd, tbuf, tlen);\n", "\ttlen = 0;\n", "    }\n", "    if ((bytes = read(pfds[2].fd, tbuf, (BUFSZ - 1))) > 0) {\n", "\ttbuf[bytes] = '\\0';\n", "\ttlen = filter(tbuf, bytes);\n", "\t(void)write(pfds[1].fd, tbuf, tlen);\n", "    }\n", "    tcdrain(pfds[1].fd);\n", "    if ((hlen = read(pfds[0].fd, hbuf, (BUFSZ - 1))) > 0) {\n", "\t(void)write(pfds[2].fd, hbuf, hlen);\n", "    }\n", "    tcdrain(pfds[2].fd);\n", "\n", "    if (child && ! kill(child, SIGINT))\n", "\treapchild(SIGCHLD);\n", "\n", "    return(rval);\n", "}\n"], "project": "rancid-cgi", "file": "hpuifilter.pkl", "function": "main"}, {"comment_all": {"comment": "/******************************************************************************\n * $Id: shptest.c,v 1.8 2016-12-05 12:44:06 erouault Exp $\n *\n * Project:  Shapelib\n * Purpose:  Application for generating sample Shapefiles of various types.\n *           Used by the stream2.sh test script.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1999, Frank Warmerdam\n *\n * This software is available under the following \"MIT Style\" license,\n * or at the option of the licensee under the LGPL (see COPYING).  This\n * option is discussed in more detail in shapelib.html.\n *\n * --\n * \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ******************************************************************************\n *\n * $Log: shptest.c,v $\n * Revision 1.8  2016-12-05 12:44:06  erouault\n * * Major overhaul of Makefile build system to use autoconf/automake.\n *\n * * Warning fixes in contrib/\n *\n * Revision 1.7  2004-09-26 20:09:35  fwarmerdam\n * avoid rcsid warnings\n *\n * Revision 1.6  2002/01/15 14:36:07  warmerda\n * updated email address\n *\n * Revision 1.5  2001/06/22 02:18:20  warmerda\n * Added null shape support\n *\n * Revision 1.4  2000/07/07 13:39:45  warmerda\n * removed unused variables, and added system include files\n *\n * Revision 1.3  1999/11/05 14:12:05  warmerda\n * updated license terms\n *\n * Revision 1.2  1998/12/16 05:15:20  warmerda\n * Added support for writing multipatch.\n *\n * Revision 1.1  1998/11/09 20:18:42  warmerda\n * Initial revision\n *\n */", "depth": 0, "reading_ease": 54.93, "reading_grade": 9.6, "line": 0}, "comment_text": "/******************************************************************************\n * $Id: shptest.c,v 1.8 2016-12-05 12:44:06 erouault Exp $\n *\n * Project:  Shapelib\n * Purpose:  Application for generating sample Shapefiles of various types.\n *           Used by the stream2.sh test script.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1999, Frank Warmerdam\n *\n * This software is available under the following \"MIT Style\" license,\n * or at the option of the licensee under the LGPL (see COPYING).  This\n * option is discussed in more detail in shapelib.html.\n *\n * --\n * \n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ******************************************************************************\n *\n * $Log: shptest.c,v $\n * Revision 1.8  2016-12-05 12:44:06  erouault\n * * Major overhaul of Makefile build system to use autoconf/automake.\n *\n * * Warning fixes in contrib/\n *\n * Revision 1.7  2004-09-26 20:09:35  fwarmerdam\n * avoid rcsid warnings\n *\n * Revision 1.6  2002/01/15 14:36:07  warmerda\n * updated email address\n *\n * Revision 1.5  2001/06/22 02:18:20  warmerda\n * Added null shape support\n *\n * Revision 1.4  2000/07/07 13:39:45  warmerda\n * removed unused variables, and added system include files\n *\n * Revision 1.3  1999/11/05 14:12:05  warmerda\n * updated license terms\n *\n * Revision 1.2  1998/12/16 05:15:20  warmerda\n * Added support for writing multipatch.\n *\n * Revision 1.1  1998/11/09 20:18:42  warmerda\n * Initial revision\n *\n */", "comment_tokens": ["$", "Id", ":", "shptest.c", ",", "v", "1.8", "2016-12-05", "12:44:06", "erouault", "Exp", "$", "Project", ":", "Shapelib", "Purpose", ":", "Application", "for", "generating", "sample", "Shapefiles", "of", "various", "types", ".", "Used", "by", "the", "stream2.sh", "test", "script", ".", "Author", ":", "Frank", "Warmerdam", ",", "warmerdam", "@", "pobox.com", "Copyright", "(", "c", ")", "1999", ",", "Frank", "Warmerdam", "This", "software", "is", "available", "under", "the", "following", "``", "MIT", "Style", "''", "license", ",", "or", "at", "the", "option", "of", "the", "licensee", "under", "the", "LGPL", "(", "see", "COPYING", ")", ".", "This", "option", "is", "discussed", "in", "more", "detail", "in", "shapelib.html", ".", "--", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", ".", "$", "Log", ":", "shptest.c", ",", "v", "$", "Revision", "1.8", "2016-12-05", "12:44:06", "erouault", "Major", "overhaul", "of", "Makefile", "build", "system", "to", "use", "autoconfautomake", ".", "Warning", "fixes", "in", "contrib", "Revision", "1.7", "2004-09-26", "20:09:35", "fwarmerdam", "avoid", "rcsid", "warnings", "Revision", "1.6", "20020115", "14:36:07", "warmerda", "updated", "email", "address", "Revision", "1.5", "20010622", "02:18:20", "warmerda", "Added", "null", "shape", "support", "Revision", "1.4", "20000707", "13:39:45", "warmerda", "removed", "unused", "variables", ",", "and", "added", "system", "include", "files", "Revision", "1.3", "19991105", "14:12:05", "warmerda", "updated", "license", "terms", "Revision", "1.2", "19981216", "05:15:20", "warmerda", "Added", "support", "for", "writing", "multipatch", ".", "Revision", "1.1", "19981109", "20:18:42", "warmerda", "Initial", "revision"], "ccode": ["/******************************************************************************\n", " * $Id: shptest.c,v 1.8 2016-12-05 12:44:06 erouault Exp $\n", " *\n", " * Project:  Shapelib\n", " * Purpose:  Application for generating sample Shapefiles of various types.\n", " *           Used by the stream2.sh test script.\n", " * Author:   Frank Warmerdam, warmerdam@pobox.com\n", " *\n", " ******************************************************************************\n", " * Copyright (c) 1999, Frank Warmerdam\n", " *\n", " * This software is available under the following \"MIT Style\" license,\n", " * or at the option of the licensee under the LGPL (see COPYING).  This\n", " * option is discussed in more detail in shapelib.html.\n", " *\n", " * --\n", " * \n", " * Permission is hereby granted, free of charge, to any person obtaining a\n", " * copy of this software and associated documentation files (the \"Software\"),\n", " * to deal in the Software without restriction, including without limitation\n", " * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n", " * and/or sell copies of the Software, and to permit persons to whom the\n", " * Software is furnished to do so, subject to the following conditions:\n", " *\n", " * The above copyright notice and this permission notice shall be included\n", " * in all copies or substantial portions of the Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n", " * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n", " * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n", " * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n", " * DEALINGS IN THE SOFTWARE.\n", " ******************************************************************************\n", " *\n", " * $Log: shptest.c,v $\n", " * Revision 1.8  2016-12-05 12:44:06  erouault\n", " * * Major overhaul of Makefile build system to use autoconf/automake.\n", " *\n", " * * Warning fixes in contrib/\n", " *\n", " * Revision 1.7  2004-09-26 20:09:35  fwarmerdam\n", " * avoid rcsid warnings\n", " *\n", " * Revision 1.6  2002/01/15 14:36:07  warmerda\n", " * updated email address\n", " *\n", " * Revision 1.5  2001/06/22 02:18:20  warmerda\n", " * Added null shape support\n", " *\n", " * Revision 1.4  2000/07/07 13:39:45  warmerda\n", " * removed unused variables, and added system include files\n", " *\n", " * Revision 1.3  1999/11/05 14:12:05  warmerda\n", " * updated license terms\n", " *\n", " * Revision 1.2  1998/12/16 05:15:20  warmerda\n", " * Added support for writing multipatch.\n", " *\n", " * Revision 1.1  1998/11/09 20:18:42  warmerda\n", " * Initial revision\n", " *\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"shapefil.h\"\n", "\n", "SHP_CVSID(\"$Id: shptest.c,v 1.8 2016-12-05 12:44:06 erouault Exp $\")\n", "\n", "/************************************************************************/\n", "/*                          Test_WritePoints()                          */\n", "/*                                                                      */\n", "/*      Write a small point file.                                       */\n", "/************************************************************************/\n", "\n", "static void Test_WritePoints( int nSHPType, const char *pszFilename )\n", "\n", "{\n", "    SHPHandle\thSHPHandle;\n", "    SHPObject\t*psShape;\n", "    double\tx, y, z, m;\n", "\n", "    hSHPHandle = SHPCreate( pszFilename, nSHPType );\n", "\n", "    x = 1.0;\n", "    y = 2.0;\n", "    z = 3.0;\n", "    m = 4.0;\n", "    psShape = SHPCreateObject( nSHPType, -1, 0, NULL, NULL,\n", "                               1, &x, &y, &z, &m );\n", "    SHPWriteObject( hSHPHandle, -1, psShape );\n", "    SHPDestroyObject( psShape );\n", "    \n", "    x = 10.0;\n", "    y = 20.0;\n", "    z = 30.0;\n", "    m = 40.0;\n", "    psShape = SHPCreateObject( nSHPType, -1, 0, NULL, NULL,\n", "                               1, &x, &y, &z, &m );\n", "    SHPWriteObject( hSHPHandle, -1, psShape );\n", "    SHPDestroyObject( psShape );\n", "\n", "    SHPClose( hSHPHandle );\n", "}\n"], "project": "libshp2", "file": "shptest.pkl", "function": "Test_WritePoints"}, {"comment_all": {"comment": "/* (!!) shouldn't we use the nb_samples field instead ? */", "depth": 2, "reading_ease": 64.37, "reading_grade": 6.0, "line": 1205}, "comment_text": "/* (!!) shouldn't we use the nb_samples field instead ? */", "comment_tokens": ["(", "!", "!", ")", "should", "n't", "we", "use", "the", "nb_samples", "field", "instead", "?"], "ccode": ["\n", "/**\n", " * Prints the characteristics of the given host:\n", " * 208.199.87.56/208.199.87.56: 15 ms, corr=0.999, invalid 23%, dropped 0%\n", " * host name and address, rtt of a 0bit packet, correlation, % invalid \n", " * measures, % dropped packets\n", " *\n", " * @param bing_stats the bing_stats\n", " * @param h the host's index\n", " */\n", "void print_host_statistics(bing_stats_t* bing_stats,int h)\n", "{\n", "    host_stats_t* host=&bing_stats->hosts[h];\n", "    double latency=DBL_MAX;\n", "    double corr;\n", "    int nb_hinvalid;\n", "    int nb_dropped;\n", "    int nb_probes=0;\n", "\n", "    printf(\"%2d %-42s \",h,host->name);\n", "    if (bing_stats->nb_methods==1) {\n", "        if (host->rtt_laws[0].host_reg.a!=0) {\n", "            latency=host->rtt_laws[0].host_reg.b;\n", "            corr=host->rtt_laws[0].host_reg.corr;\n", "        }\n", "        nb_hinvalid=host->rtt_laws[0].nb_hinvalid;\n", "        nb_dropped=host->rtt_laws[0].nb_dropped;\n", "        nb_probes=nb_dropped+host->rtt_laws[0].nb_samples;\n", "    } else {\n", "        if (host->rtt_laws[0].host_reg.a!=0) {\n", "            if (host->rtt_laws[1].host_reg.a!=0) {\n", "                latency=(host->rtt_laws[0].host_reg.b+host->rtt_laws[1].host_reg.b)/2;\n", "                corr=(host->rtt_laws[0].host_reg.corr+host->rtt_laws[1].host_reg.corr)/2;\n", "            } else {\n", "                latency=host->rtt_laws[0].host_reg.b;\n", "                corr=host->rtt_laws[0].host_reg.corr;\n", "            }\n", "        } else if (host->rtt_laws[1].host_reg.a!=0) {\n", "            latency=host->rtt_laws[1].host_reg.b;\n", "            corr=host->rtt_laws[1].host_reg.corr;\n", "        }\n", "        nb_hinvalid=host->rtt_laws[0].nb_hinvalid+host->rtt_laws[1].nb_hinvalid;\n", "        nb_dropped=host->rtt_laws[0].nb_dropped+host->rtt_laws[1].nb_dropped;\n", "        nb_probes=nb_dropped+host->rtt_laws[0].nb_samples+host->rtt_laws[1].nb_samples;\n", "    }\n", "    if (corr==0.0) {\n", "        /* (!!) shouldn't we use the nb_samples field instead ? */\n", "        printf(\"---.--- ms, -.---/--, \");\n", "    } else {\n", "        printf(\"%7.3f ms, %5.3f/%-2d, \",latency,corr,host->rtt_laws[0].host_reg.nb_samples);\n", "    }\n", "    printf(\"%5.1f%%, \",((double)100.0*nb_hinvalid)/bing_stats->nb_sizes);\n", "    if (nb_probes==0) {\n", "        printf(\"--.-%%\\n\");\n", "    } else {\n", "        printf(\"%5.1f%%\\n\",((double)100.0*nb_dropped)/nb_probes);\n", "    }\n", "}\n"], "project": "bing", "file": "bing.pkl", "function": "print_host_statistics"}, {"comment_all": {"comment": "/* Each iteration produces two values, if one exists use the value from previous call */", "depth": 1, "reading_ease": 57.27, "reading_grade": 8.8, "line": 67}, "comment_text": "/* Each iteration produces two values, if one exists use the value from previous call */", "comment_tokens": ["Each", "iteration", "produces", "two", "values", ",", "if", "one", "exists", "use", "the", "value", "from", "previous", "call"], "ccode": ["/*---------------------------------------------------------------\n", " * Copyright (c) 2017\n", " * Broadcom Corporation\n", " * All Rights Reserved.\n", " *---------------------------------------------------------------\n", " * Permission is hereby granted, free of charge, to any person\n", " * obtaining a copy of this software and associated\n", " * documentation files (the \"Software\"), to deal in the Software\n", " * without restriction, including without limitation the\n", " * rights to use, copy, modify, merge, publish, distribute,\n", " * sublicense, and/or sell copies of the Software, and to permit\n", " * persons to whom the Software is furnished to do\n", " * so, subject to the following conditions:\n", " *\n", " *\n", " * Redistributions of source code must retain the above\n", " * copyright notice, this list of conditions and\n", " * the following disclaimers.\n", " *\n", " *\n", " * Redistributions in binary form must reproduce the above\n", " * copyright notice, this list of conditions and the following\n", " * disclaimers in the documentation and/or other materials\n", " * provided with the distribution.\n", " *\n", " *\n", " * Neither the name of Broadcom Coporation,\n", " * nor the names of its contributors may be used to endorse\n", " * or promote products derived from this Software without\n", " * specific prior written permission.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n", " * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n", " * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n", " * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT\n", " * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n", " * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n", " * ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n", " * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", " * ________________________________________________________________\n", " *\n", " * pdfs.c\n", " * Produce probability distribution functions, expected to be used\n", " * for iperf client traffic emulations\n", " *\n", " * Implements the Polar form of the Box-Muller Transformation\n", " *\n", " * by Robert J. McMahon (rjmcmahon@rjmcmahon.com, bob.mcmahon@broadcom.com)\n", " * & Tim Auckland\n", " * -------------------------------------------------------------------\n", " */\n", "#ifndef _GNU_SOURCE\n", "#define _GNU_SOURCE\n", "#endif\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <time.h>\n", "#include <math.h>\n", "#include \"headers.h\"\n", "#include \"pdfs.h\"\n", "\n", "#define FALSE 0\n", "#define TRUE 1\n", "float box_muller(void) {\n", "    float x1, x2, w, y1;\n", "    static float y2;\n", "    static int generate = FALSE;\n", "    /* Each iteration produces two values, if one exists use the value from previous call */\n", "    generate = !generate;\n", "    if (!generate) {\n", "\ty1 = y2;\n", "    } else {\n", "\tint loopcontrol=100;\n", "\tdo {\n", "\t    x1 = 2.0 * (float)rand()/(float)(RAND_MAX) - 1.0;\n", "\t    x2 = 2.0 * (float)rand()/(float)(RAND_MAX) - 1.0;\n", "\t    w = x1 * x1 + x2 * x2;\n", "\t} while ( w >= 1.0 && --loopcontrol > 0);\n", "\tif (w >= 1.0) {\n", "\t    fprintf(stderr, \"pdf box_muller() rand() error\\n\");\n", "\t    return 0;\n", "\t} else {\n", "\t    w = sqrt( (-2.0 * log( w ) ) / w );\n", "\t    y1 = x1 * w;\n", "\t    y2 = x2 * w;\n", "\t}\n", "    }\n", "    return(y1);\n", "}\n"], "project": "iperf", "file": "pdfs.pkl", "function": "box_muller"}, {"comment_all": {"comment": "/* shoud instance be tighten? */", "depth": 2, "reading_ease": 75.88, "reading_grade": 3.7, "line": 1063}, "comment_text": "/* shoud instance be tighten? */", "comment_tokens": ["shoud", "instance", "be", "tighten", "?"], "ccode": ["\n", "static VALUE\n", "inst_put_obj(VALUE self, VALUE arg, const char *field)\n", "{\n", "  struct ngraph_instance *inst1, *inst2;\n", "  ngraph_value str;\n", "  char buf[128];\n", "  const char *name, *ptr;\n", "  int *ids;\n", "  struct objlist *obj;\n", "\n", "  switch (TYPE(arg)) {\n", "  case T_NIL:\n", "    ptr = NULL;\n", "    break;\n", "  case T_STRING:\n", "    ptr = StringValueCStr(arg);\n", "    obj = ngraph_get_object_instances_by_str(ptr, NULL, &ids);\n", "    if (obj == NULL) {\n", "      rb_raise(rb_eArgError, \"%s#%s: illegal instance representation (%s).\", rb_obj_classname(self), field, ptr);\n", "    }\n", "    ngraph_free(ids);\n", "    break;\n", "  default:\n", "    if (! rb_obj_is_kind_of(arg, NgraphClass)) {\n", "      rb_raise(rb_eArgError, \"%s#%s: illegal type of the argument (%s).\", rb_obj_classname(self), field, rb_obj_classname(arg));\n", "    }\n", "\n", "    inst2 = check_id(arg);\n", "    if (inst2 == NULL) {\n", "      return Qnil;\n", "    }\n", "\n", "    name = ngraph_get_object_name(inst2->obj);\n", "#if 0\n", "    snprintf(buf, sizeof(buf), \"%s:%d\", name, inst2->id);\n", "#else\n", "    snprintf(buf, sizeof(buf), \"%s:^%d\", name, inst2->oid); /* shoud instance be tighten? */\n", "#endif\n", "    ptr = buf;\n", "  }\n", "\n", "  inst1 = check_id(self);\n", "  if (inst1 == NULL) {\n", "    return Qnil;\n", "  }\n", "\n", "  str.str = ptr;\n", "  inst1->rcode = ngraph_object_put(inst1->obj, field, inst1->id, &str);\n", "  if (inst1->rcode < 0) {\n", "    return Qnil;\n", "  }\n", "\n", "  return arg;\n", "}\n"], "project": "libngraph0-dev", "file": "ngraph.pkl", "function": "inst_put_obj"}, {"comment_all": {"comment": "// buffer[pos] reserved\n", "depth": 1, "reading_ease": 35.61, "reading_grade": 8.8, "line": 43}, "comment_text": "// buffer[pos] reserved\n", "comment_tokens": ["buffer", "[", "pos", "]", "reserved"], "ccode": ["/*\n", " * ESG parser\n", " *\n", " * Copyright (C) 2006 Stephane Este-Gracias (sestegra@free.fr)\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include <libesg/encapsulation/fragment_management_information.h>\n", "\n", "struct esg_encapsulation_structure *esg_encapsulation_structure_decode(uint8_t *buffer, uint32_t size) {\n", "\tuint32_t pos;\n", "\tstruct esg_encapsulation_structure *structure;\n", "\tstruct esg_encapsulation_entry *entry;\n", "\tstruct esg_encapsulation_entry *last_entry;\n", "\n", "\tif ((buffer == NULL) || (size <= 2)) {\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tpos = 0;\n", "\n", "\tstructure = (struct esg_encapsulation_structure *) malloc(sizeof(struct esg_encapsulation_structure));\n", "\tmemset(structure, 0, sizeof(struct esg_encapsulation_structure));\n", "\tstructure->entry_list = NULL;\n", "\n", "\t// Encapsulation header\n", "\tstructure->header = (struct esg_encapsulation_header *) malloc(sizeof(struct esg_encapsulation_header));\n", "\t// buffer[pos] reserved\n", "\tstructure->header->fragment_reference_format = buffer[pos+1];\n", "\tpos += 2;\n", "\n", "\t// Encapsulation entry list\n", "\tlast_entry = NULL;\n", "\twhile (size > pos) {\n", "\t\tentry = (struct esg_encapsulation_entry *) malloc(sizeof(struct esg_encapsulation_entry));\n", "\t\tmemset(entry, 0, sizeof(struct esg_encapsulation_entry));\n", "\t\tentry->_next = NULL;\n", "\n", "\t\tif (last_entry == NULL) {\n", "\t\t\tstructure->entry_list = entry;\n", "\t\t} else {\n", "\t\t\tlast_entry->_next = entry;\n", "\t\t}\n", "\t\tlast_entry = entry;\n", "\n", "\t\t// Fragment reference\n", "\t\tswitch (structure->header->fragment_reference_format) {\n", "\t\t\tcase 0x21: {\n", "\t\t\t\tentry->fragment_reference = (struct esg_fragment_reference *) malloc(sizeof(struct esg_fragment_reference));\n", "\t\t\t\tmemset(entry->fragment_reference, 0, sizeof(struct esg_fragment_reference));\n", "\n", "\t\t\t\tentry->fragment_reference->fragment_type = buffer[pos];\n", "\t\t\t\tpos += 1;\n", "\n", "\t\t\t\tentry->fragment_reference->data_repository_offset = (buffer[pos] << 16) | (buffer[pos+1] << 8) | buffer[pos+2];\n", "\t\t\t\tpos += 3;\n", "\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t\tdefault: {\n", "\t\t\t\tesg_encapsulation_structure_free(structure);\n", "\t\t\t\treturn NULL;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\t// Fragment version & id\n", "\t\tentry->fragment_version = buffer[pos];\n", "\t\tpos += 1;\n", "\n", "\t\tentry->fragment_id = (buffer[pos] << 16) | (buffer[pos+1] << 8) | buffer[pos+2];\n", "\t\tpos += 3;\n", "\t}\n", "\n", "\treturn structure;\n", "}\n"], "project": "dvb-apps", "file": "fragment_management_information.pkl", "function": "esg_encapsulation_structure_decode"}, {"comment_all": {"comment": "/* \n * Reply to client request for list of devices in powerman configuration.\n */", "depth": 0, "reading_ease": 43.39, "reading_grade": 9.9, "line": 332}, "comment_text": "/* \n * Reply to client request for list of devices in powerman configuration.\n */", "comment_tokens": ["Reply", "to", "client", "request", "for", "list", "of", "devices", "in", "powerman", "configuration", "."], "ccode": ["\n", "/* \n", " * Reply to client request for list of devices in powerman configuration.\n", " */\n", "static void _client_query_device_reply(Client * c, char *arg)\n", "{\n", "    List devs = dev_getdevices();\n", "    Device *dev;\n", "    ListIterator itr;\n", "\n", "    if (devs) {\n", "\n", "        itr = list_iterator_create(devs);\n", "        while ((dev = list_next(itr))) {\n", "            char nodelist[CP_LINEMAX];\n", "            int con = dev->stat_successful_connects;\n", "\n", "            if (arg && !_device_matches_targets(dev, arg))\n", "                continue;\n", "\n", "            if (_make_pluglist(dev, nodelist, sizeof(nodelist))) {\n", "                _client_printf(c, CP_INFO_DEVICE, \n", "                        dev->name,\n", "                        dev->connect_state == DEV_CONNECTED ? \"connected\"\n", "                          : dev->connect_state == DEV_CONNECTING ? \"connecting\"\n", "                          : \"disconnected\",\n", "                        con > 0 ? con - 1 : 0, \n", "                        dev->stat_successful_actions,\n", "                        dev->specname,\n", "                        nodelist);\n", "            }\n", "        }\n", "        list_iterator_destroy(itr);\n", "    }\n", "    _client_printf(c, CP_RSP_QRY_COMPLETE);\n", "}\n"], "project": "powerman", "file": "client.pkl", "function": "_client_query_device_reply"}, {"comment_all": {"comment": "/* eq_pset() takes two position sets and checks to see if they are\n   equal.  It returns 1 if the sets are equal, 0 if they are not.\t*/", "depth": 0, "reading_ease": 100.58, "reading_grade": 2.5, "line": 130}, "comment_text": "/* eq_pset() takes two position sets and checks to see if they are\n   equal.  It returns 1 if the sets are equal, 0 if they are not.\t*/", "comment_tokens": ["eq_pset", "(", ")", "takes", "two", "position", "sets", "and", "checks", "to", "see", "if", "they", "are", "equal", ".", "It", "returns", "1", "if", "the", "sets", "are", "equal", ",", "0", "if", "they", "are", "not", "."], "ccode": ["\n", "/* eq_pset() takes two position sets and checks to see if they are\n", "   equal.  It returns 1 if the sets are equal, 0 if they are not.\t*/\n", "int\n", "subset_pset(s1, s2)\n", "Pset s1, s2;\n", "{\n", "\tint subs = 1;\n", "\n", "\twhile (s1 != NULL && subs != 0) {\n", "\t\tsubs = 0;\n", "\t\twhile (s2 != NULL && subs != 1)\n", "\t\t\tif (s1->posnum == s2->posnum) subs = 1;\n", "\t\t\telse s2 = s2->nextpos;\n", "\t\ts1 = s1->nextpos;\n", "\t}\n", "\treturn subs;\n", "}\t\n"], "project": "agrep", "file": "utilities.pkl", "function": "subset_pset"}, {"comment_all": {"comment": "/*\n * merge_isofs:  Scan an existing image, and return a pointer\n * to the root directory for this image.\n */", "depth": 0, "reading_ease": 55.24, "reading_grade": 9.5, "line": 1116}, "comment_text": "/*\n * merge_isofs:  Scan an existing image, and return a pointer\n * to the root directory for this image.\n */", "comment_tokens": ["merge_isofs", ":", "Scan", "an", "existing", "image", ",", "and", "return", "a", "pointer", "to", "the", "root", "directory", "for", "this", "image", "."], "ccode": ["\n", "/*\n", " * merge_isofs:  Scan an existing image, and return a pointer\n", " * to the root directory for this image.\n", " */\n", "struct iso_directory_record *\n", "merge_isofs(char *path)\n", "{\n", "\tchar\t\tbuffer[SECTOR_SIZE];\n", "\tint\t\tfile_addr;\n", "\tint\t\ti;\n", "\tstruct iso_primary_descriptor *pri = NULL;\n", "\tstruct iso_directory_record *rootp;\n", "\tstruct iso_volume_descriptor *vdp;\n", "\n", "\t/*\n", "\t * Start by searching for the volume header. Ultimately, we need to\n", "\t * search for volume headers in multiple places because we might be\n", "\t * starting with a multisession image. FIXME(eric).\n", "\t */\n", "\tget_session_start(&file_addr);\n", "\n", "\tfor (i = 0; i < 100; i++) {\n", "\t\tif (readsecs(file_addr, buffer,\n", "\t\t\t\tsizeof (buffer) / SECTOR_SIZE) != sizeof (buffer)) {\n", "#ifdef\tUSE_LIBSCHILY\n", "\t\t\tcomerr(\" Read error on old image %s\\n\", path);\n", "#else\n", "\t\t\tfprintf(stderr, \" Read error on old image %s\\n\", path);\n", "\t\t\texit(10);\n", "#endif\n", "\t\t}\n", "\t\tvdp = (struct iso_volume_descriptor *) buffer;\n", "\n", "\t\tif ((strncmp(vdp->id, ISO_STANDARD_ID, sizeof (vdp->id)) == 0) &&\n", "\t\t    (isonum_711((unsigned char *) vdp->type) == ISO_VD_PRIMARY)) {\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\tfile_addr += 1;\n", "\t}\n", "\n", "\tif (i == 100) {\n", "\t\treturn (NULL);\n", "\t}\n", "\tpri = (struct iso_primary_descriptor *) vdp;\n", "\n", "\t/* Check the blocksize of the image to make sure it is compatible. */\n", "\tif (isonum_723((unsigned char *) pri->logical_block_size) != SECTOR_SIZE) {\n", "\t\terrmsgno(EX_BAD,\n", "\t\t\t\"Previous session has incompatible sector size %d.\\n\",\n", "\t\t\tisonum_723((unsigned char *) pri->logical_block_size));\n", "\t\treturn (NULL);\n", "\t}\n", "\tif (isonum_723((unsigned char *) pri->volume_set_size) != 1) {\n", "\t\terrmsgno(EX_BAD,\n", "\t\t\t\"Previous session has volume set size %d (must be 1).\\n\",\n", "\t\t\tisonum_723((unsigned char *) pri->volume_set_size));\n", "\t\treturn (NULL);\n", "\t}\n", "\t/* Get the location and size of the root directory. */\n", "\trootp = (struct iso_directory_record *)\n", "\t\te_malloc(sizeof (struct iso_directory_record));\n", "\n", "\tmemcpy(rootp, pri->root_directory_record, sizeof (*rootp));\n", "\n", "\treturn (rootp);\n", "}\n"], "project": "cdrkit-doc", "file": "multi.pkl", "function": "merge_isofs"}, {"comment_all": {"comment": "/* get the actual socket handle */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 211}, "comment_text": "/* get the actual socket handle */", "comment_tokens": ["get", "the", "actual", "socket", "handle"], "ccode": ["\n", "FILE *socket_init(const char *server, short int port)\n", "{\n", "  struct hostent *host;\n", "  struct sockaddr_in socket_address;\n", "  int hsocket;\n", "\n", "  /* see if some default values have been set */\n", "  if (server == NULL) {\n", "    return NULL;\n", "  }\n", "\n", "  host = gethostbyname(server);\n", "  if (host == NULL)\n", "    return NULL;\t\t/* we don't know the host */\n", "\n", "  /* set socket address */\n", "  memset(&socket_address, 0, sizeof(socket_address));\n", "  memcpy((char *) &socket_address.sin_addr, host->h_addr, host->h_length);\n", "  socket_address.sin_family = host->h_addrtype;\n", "  socket_address.sin_port = htons(port);\n", "\n", "  /* get the actual socket handle */\n", "  hsocket = socket(host->h_addrtype, SOCK_STREAM, 0);\n", "  if (hsocket < 0)\t\t/* we couldn't grab the socket */\n", "    return NULL;\n", "\n", "  if (connect(hsocket, (struct sockaddr *) &socket_address,\n", "\t      sizeof(socket_address)) < 0)\n", "    return NULL;\n", "\n", "  return fdopen(hsocket, \"r+\");\t/* we made it */\n", "}\n"], "project": "cccd", "file": "misc.pkl", "function": "socket_init"}, {"comment_all": {"comment": "/* $Aumix: aumix/src/gpm-xterm.c,v 1.2 2002/03/28 09:37:26 trevor Exp $\n * gpm-xterm.c - pseudo client for non-Linux xterm-only mouse support.\n *               This code has been extracted from libgpm-0.18 and then\n *               took its own way.\n *\n * Copyright (C) 1994, 1995  rubini@linux.it (Alessandro Rubini)\n * Copyright (C) 1994        Janne Kukonlehto\n *\n * This file is part of aumix.\n *\n * Aumix is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * Aumix is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * aumix; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 57.06, "reading_grade": 8.8, "line": 0}, "comment_text": "/* $Aumix: aumix/src/gpm-xterm.c,v 1.2 2002/03/28 09:37:26 trevor Exp $\n * gpm-xterm.c - pseudo client for non-Linux xterm-only mouse support.\n *               This code has been extracted from libgpm-0.18 and then\n *               took its own way.\n *\n * Copyright (C) 1994, 1995  rubini@linux.it (Alessandro Rubini)\n * Copyright (C) 1994        Janne Kukonlehto\n *\n * This file is part of aumix.\n *\n * Aumix is free software; you can redistribute it and/or modify it under the\n * terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * Aumix is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * aumix; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["$", "Aumix", ":", "aumixsrcgpm-xterm.c", ",", "v", "1.2", "20020328", "09:37:26", "trevor", "Exp", "$", "gpm-xterm.c", "-", "pseudo", "client", "for", "non-Linux", "xterm-only", "mouse", "support", ".", "This", "code", "has", "been", "extracted", "from", "libgpm-0.18", "and", "then", "took", "its", "own", "way", ".", "Copyright", "(", "C", ")", "1994", ",", "1995", "rubini", "@", "linux.it", "(", "Alessandro", "Rubini", ")", "Copyright", "(", "C", ")", "1994", "Janne", "Kukonlehto", "This", "file", "is", "part", "of", "aumix", ".", "Aumix", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "Aumix", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "aumix", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/* $Aumix: aumix/src/gpm-xterm.c,v 1.2 2002/03/28 09:37:26 trevor Exp $\n", " * gpm-xterm.c - pseudo client for non-Linux xterm-only mouse support.\n", " *               This code has been extracted from libgpm-0.18 and then\n", " *               took its own way.\n", " *\n", " * Copyright (C) 1994, 1995  rubini@linux.it (Alessandro Rubini)\n", " * Copyright (C) 1994        Janne Kukonlehto\n", " *\n", " * This file is part of aumix.\n", " *\n", " * Aumix is free software; you can redistribute it and/or modify it under the\n", " * terms of the GNU General Public License as published by the Free Software\n", " * Foundation; either version 2 of the License, or (at your option) any later\n", " * version.\n", " *\n", " * Aumix is distributed in the hope that it will be useful, but WITHOUT ANY\n", " * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n", " * A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License along with\n", " * aumix; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n", " * Suite 330, Boston, MA 02111-1307, USA.\n", " */\n", "\n", "#include \"common.h\"\n", "#if defined(HAVE_CURSES) && !defined(HAVE_LIBGPM)\n", "#include \"gpm-xterm.h\"\n", "\n", "#ifdef HAVE_USEKEYPAD\n", "int             gpm_keypad(WINDOW * win, int new)\n", "{\n", "\tint             old;\n", "\told = win->_use_keypad;\n", "\twin->_use_keypad = new;\n", "\treturn old;\n", "}\n"], "project": "aumix-common", "file": "gpm-xterm.pkl", "function": "gpm_keypad"}, {"comment_all": {"comment": "/* A function called through the vtable to get the address of\n   a symbol loaded from a particular module.  */", "depth": 0, "reading_ease": 70.13, "reading_grade": 8.0, "line": 221}, "comment_text": "/* A function called through the vtable to get the address of\n   a symbol loaded from a particular module.  */", "comment_tokens": ["A", "function", "called", "through", "the", "vtable", "to", "get", "the", "address", "of", "a", "symbol", "loaded", "from", "a", "particular", "module", "."], "ccode": ["\n", "\n", "/* A function called through the vtable to get the address of\n", "   a symbol loaded from a particular module.  */\n", "static void *\n", "vm_sym (lt_user_data LT__UNUSED loader_data, lt_module module, const char *name)\n", "{\n", "  void *address = dlsym (module, name);\n", "\n", "  if (!address)\n", "    {\n", "      DL__SETERROR (SYMBOL_NOT_FOUND);\n", "    }\n", "\n", "  return address;\n", "}\n"], "project": "pcmanx-gtk2", "file": "dlopen.pkl", "function": "vm_sym"}, {"comment_all": {"comment": "/** Get the current line number.\n * \n */", "depth": 0, "reading_ease": 83.32, "reading_grade": 2.9, "line": 3940}, "comment_text": "/** Get the current line number.\n * \n */", "comment_tokens": ["Get", "the", "current", "line", "number", "."], "ccode": ["\twhile ( 0 )\n", "\n", "/* Accessor  methods (get/set functions) to struct members. */\n", "\n", "/** Get the current line number.\n", " * \n", " */\n", "int yyget_lineno  (void)\n", "{\n", "    \n", "    return yylineno;\n", "}\n"], "project": "linux-buildinfo-5.10.0-1011-oem", "file": "lexer.lex.pkl", "function": "yyget_lineno"}, {"comment_all": {"comment": "/* Depending on the mode (write_perm) string this is tested 3 ways    */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 108}, "comment_text": "/* At this point infile_name contains a possible filename             */\n/* Depending on the mode (write_perm) string this is tested 3 ways    */\n", "comment_tokens": ["At", "this", "point", "infile_name", "contains", "a", "possible", "filename", "Depending", "on", "the", "mode", "(", "write_perm", ")", "string", "this", "is", "tested", "3", "ways"], "ccode": ["/**************************************************************************/\n", "/* CodonW codon usage analysis package                                    */\n", "/* Copyright (C) 2005            John F. Peden                            */\n", "/* This program is free software; you can redistribute                    */\n", "/* it and/or modify it under the terms of the GNU General Public License  */\n", "/* as published by the Free Software Foundation; version 2 of the         */\n", "/* License,                                                               */\n", "/*                                                                        */\n", "/* This program is distributed in the hope that it will be useful, but    */\n", "/* WITHOUT ANY WARRANTY; without even the implied warranty of             */\n", "/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           */\n", "/* GNU General Public License for more details.                           */\n", "/* You should have received a copy of the GNU General Public License along*/\n", "/* with this program; if not, write to the Free Software Foundation, Inc.,*/\n", "/* 675 Mass Ave, Cambridge, MA 02139, USA.                                */\n", "/*                                                                        */\n", "/*                                                                        */\n", "/* The author can be contacted by email (jfp#hanson-codonw@yahoo.com Anti-*/\n", "/* Spam please change the # in my email to an _)                          */\n", "/*                                                                        */\n", "/* For the latest version and information see                             */\n", "/* http://codonw.sourceforge.net \t\t\t\t\t  */\n", "/**************************************************************************/\n", "\n", "/* This is a general subroutine, so we might as well redefine TRUE & FALSE*/\n", "#ifndef TRUE\n", "#define TRUE 1\n", "#endif\n", "#ifndef FALSE\n", "#define FALSE 0\n", "#endif\n", "\n", "/* What to do if we can't locate the file we where asked to open          */\n", "/* On most systems we will try and be nice and show a choice of filenames */\n", "\n", "#ifdef _DOS\n", "#define no_file_found() system(\"dir/w\");\n", "#elif BSD || SYSV            \n", "#define no_file_found() system(\"ls -F\");\n", "#elif defined (WIN32) || defined (_WIN) \n", "#define no_file_found() system(\"dir/w\");\n", "#else\n", "#define no_file_found() printf(\"This would have presented a list of files\\n\\tbut I do not know howto your operating system\\n\");\n", "#endif\n", "\n", "/* Include header files                                                   */\n", "#include <stdio.h>             \n", "#include <limits.h> \n", "#include <stdlib.h>  \n", "#include <string.h>\n", "#include <ctype.h>         \n", "#include \"codonW.h\"\n", "\n", "/************** open_file **************************************************/\n", "/* This subroutine is a front end to fopen open. It takes four parameters  */\n", "/* the parameters are used to generate a user prompt for the               */\n", "/* filename, and to give a suggested filename, to give the write perms     */\n", "/* for the file, and whether or not to overwrite existing files.           */\n", "/* File_needed is just a description of the file being opened. It is       */\n", "/* assumed that if this descriptor is missing the file is to be opened     */\n", "/* without further user input. If default_filename is blank then there is  */\n", "/* no default_filename                                                     */\n", "/* write_perm sets up the type of file being opened                        */\n", "/* verbose tells this function whether to check if there is a         */\n", "/* previous version of any file being opened for writing                   */\n", "/***************************************************************************/\n", "\n", "FILE *open_file(char *file_needed, char *default_filename, \n", "char *write_perm, int  verbose )\n", "{\n", "    char   infile_name[MAX_FILENAME_LEN]=\"\";\n", "    FILE  *input=NULL;\n", "    char   temp[4];\n", "    char  *answer = pm->junk;\n", "\n", "    /**********************************************************************/\n", "    /* If a string has been given for file_needed it is assumed           */\n", "    /* that the user will have a choice of file_names to choose           */\n", "    /* therefore (s)he will be prompted for a name                        */\n", "    /* if a default filename was supplied by the calling function this    */\n", "    /* will be suggested as well, otherwise there is no default           */\n", "    /**********************************************************************/\n", "\n", "    if ( strlen(file_needed)) {\n", "        while (!strlen(infile_name) )  {\n", "            printf(\"\\nName of %s (h for help) [%s] \", \n", "                      file_needed,default_filename);\n", "            gets(infile_name);                          /* get filename   */\n", "            \n", "            if ( WasHelpCalled ( infile_name ) ) {\n", "                     chelp(\"open_file_query\");          /* Help ....      */\n", "                     infile_name[0]='\\0';\n", "                     continue;\n", "                }\n", "\n", "            if ( !strlen(infile_name) && default_filename )\n", "                strcpy(infile_name, default_filename);\n", "        }                                         /* end of get filename  */\n", "    } else if ( strlen(default_filename) )        /* use default filename */\n", "        strcpy(infile_name, default_filename);\n", "    else {                                        /* not enough info      */\n", "        fprintf(stderr, \"Programming error: no filename supplied\\n\");\n", "        my_exit (0,\"open file\");\n", "    }\n", "\n", "\n", "    /**********************************************************************/\n", "    /* At this point infile_name contains a possible filename             */\n", "    /* Depending on the mode (write_perm) string this is tested 3 ways    */\n", "    /*                                                                    */\n", "    /* (r or r+) Test if the file exists if not, all the files in the     */\n", "    /* current directory are listed and the the user is prompted for      */\n", "    /* an alternative name or they may quit the programme                 */\n", "    /*                                                                    */\n", "    /* (a, a+) Not tested, just open the file                             */\n", "    /*                                                                    */\n", "    /* (w, w+) If the variable verbose = FALSE then no test          */\n", "    /* If verbose == TRUE then the file is checked to see if         */\n", "    /* it already exsists, if it does then the user is prompted for       */\n", "    /* either for permission to overwrite this file or to                 */\n", "    /* suggest an alternative file_name which is then tested as well      */\n", "    /* the user can type q to quit at any stage of this prompting process */\n", "    /**********************************************************************/\n", "\n", "    if ( !strcmp(write_perm, \"r\") || !strcmp(write_perm, \"r+\") \n", "       ||!strcmp(write_perm, \"rb\") ){\n", "        while ( !(input = fopen (infile_name , write_perm )))  {\n", "            fprintf(stderr,\"\\nThese are the files in the current directory \"\n", "                \"I cannot find %.*s \\n\\n\",strlen(infile_name),infile_name);\n", "            no_file_found();\n", "            fprintf(stderr, \"\\n\\nPlease enter another filename, \"\n", "                \" (Q)uit, (H)elp [%s] \",infile_name);\n", "            gets(answer);\n", "            \n", "            if (strlen (answer)==1 && \n", "                   ((char)toupper((int)answer[0])=='Q'))\n", "                   my_exit(2,\"open_file\");\n", "            else if (WasHelpCalled ( infile_name )){\n", "                   chelp (\"File_not_found\");\n", "                }\n", "            else if (strlen (answer))\n", "                strcpy (infile_name, answer);  \n", "\t\t}                                     /* end of while loop */       \n", "        strcpy ( answer,infile_name);           /* allow transfer    */\n", "        return input;\n", "    }                                               \n", "\n", "    /************************* Append  ***********************************/\n", "    else if ( !strcmp(write_perm, \"a\") || !strcmp(write_perm, \"a+\")\n", "           || !strcmp(write_perm, \"ab\") ) {\n", "        input = fopen (infile_name, write_perm);\n", "        strcpy ( answer,infile_name);      \n", "        return input;\n", "    }                                              \n", "    /************************* Write    **********************************/\n", "    else if ( !strcmp( write_perm, \"w\") || !strcmp(write_perm, \"w+\") \n", "            ||!strcmp( write_perm, \"wb\") ) {\n", "\n", "         while ( verbose == TRUE ) {\n", "            if ( (input = fopen (infile_name , \"r\")) ) {\n", "                fclose(input);                  /* close the filehandle  */\n", "                fprintf(stderr, \"\\nWarning :File %.*s \"\n", "                    \"exists already \\n\\tDo you wish to\"\n", "                    \" overwrite ? (y/n/h/q)\\t [y] \",\n", "                    strlen(infile_name), infile_name);\n", "                fgets(temp, 3, stdin);\n", "\n", "                switch (toupper( (int) temp[0])) {\n", "                case 'Y': \n", "                case '\\0': \n", "                case '\\n':\n", "                    verbose = FALSE;\n", "                    continue;\n", "                case 'Q':\n", "                    my_exit(2,\"open_file2\");\n", "                    break;\n", "                case 'H':\n", "                    chelp(\"file_exists\");\n", "                    continue;\n", "                    break;\n", "                default:\n", "                    fprintf(stderr, \n", "                        \"\\nYou decided not to overwrite, please enter\\n\"\n", "                        \" another filename, (q)uit, (a)ppend, (h)elp \\n\"\n", "                        \" (a/q/h/filename)\\t[a] \");\n", "                    gets(answer);\n", "                }\n", "\n", "                /* if the answer is 'a' then the default file is opened  */\n", "                /* as appendable else if 'q' then the programme exits    */\n", "                /* anything else is taken as a file name                 */\n", "\n", "                if ( strlen(answer) <= 1 ) {\n", "                    switch (toupper( (int) answer[0])) {\n", "                    case 'Q':\n", "                        return (NULL);\n", "                    case 'A':\n", "                    case '\\0':\n", "                    case'\\n':\n", "                        verbose = FALSE;  /* leave the while loop   */\n", "                        strcpy(write_perm, \"a+\");\n", "                        break;\n", "                    case 'H':\n", "                     chelp(\"file_append\");        \n", "                     continue;\n", "                     break;\n", "                    default:\n", "                        continue;\n", "                    };                                /* end of switch   */\n", "                }               \n", "            } else                              /* filename is unique    */\n", "              verbose = FALSE;             /* exit the while loop   */\n", "              }                                 /* match while preserve  */\n", "        input = fopen (infile_name,write_perm); /* opens filehandle      */\n", "        strcpy ( answer,infile_name);         \n", "        return input;\n", "    }                                           /* matchs if w or w+     */\n", "    return (NULL);\n", "}\n"], "project": "codonw", "file": "open_fil.pkl", "function": "open_file"}, {"comment_all": {"comment": "/* K & R C programming 2nd ed. page 120. Some sort of quicksort.*/", "depth": 0, "reading_ease": 90.77, "reading_grade": 2.1, "line": 31}, "comment_text": "/* The following sorting functions is a copy of the example in  */\n/* K & R C programming 2nd ed. page 120. Some sort of quicksort.*/\n", "comment_tokens": ["The", "following", "sorting", "functions", "is", "a", "copy", "of", "the", "example", "in", "K", "&", "R", "C", "programming", "2nd", "ed", ".", "page", "120", ".", "Some", "sort", "of", "quicksort", "."], "ccode": ["/*\n", "                                                                                                                                                                    \n", "g3data : A program for grabbing data from scanned graphs\n", "Copyright (C) 2000 Jonas Frantz\n", "                                                                                                                                                                    \n", "    This file is part of g3data.\n", "                                                                                                                                                                    \n", "    g3data is free software; you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation; either version 2 of the License, or\n", "    (at your option) any later version.\n", "                                                                                                                                                                    \n", "    g3data is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "                                                                                                                                                                    \n", "    You should have received a copy of the GNU General Public License\n", "    along with this program; if not, write to the Free Software\n", "    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", "                                                                                                                                                                    \n", "                                                                                                                                                                    \n", "Authors email : jonas.frantz@welho.com\n", "                                                                                                                                                                    \n", "*/\n", "\n", "#include <gtk/gtk.h>\n", "#include \"main.h\"\n", "\n", "/****************************************************************/\n", "/* The following sorting functions is a copy of the example in  */\n", "/* K & R C programming 2nd ed. page 120. Some sort of quicksort.*/\n", "/****************************************************************/\n", "void swap3(struct PointValue *RealPos, gint i, gint j)\n", "{\n", "  struct PointValue tmp;\n", "\n", "    tmp.Xv = RealPos[i].Xv;\n", "    tmp.Yv = RealPos[i].Yv;\n", "    tmp.Xerr = RealPos[i].Xerr;\n", "    tmp.Yerr = RealPos[i].Yerr;\n", "    RealPos[i].Xv = RealPos[j].Xv;\n", "    RealPos[i].Yv = RealPos[j].Yv;\n", "    RealPos[i].Xerr = RealPos[j].Xerr;\n", "    RealPos[i].Yerr = RealPos[j].Yerr;\n", "    RealPos[j].Xv = tmp.Xv;\n", "    RealPos[j].Yv = tmp.Yv;\n", "    RealPos[j].Xerr = tmp.Xerr;\n", "    RealPos[j].Yerr = tmp.Yerr;\n", "}\n"], "project": "g3data", "file": "sort.pkl", "function": "swap3"}, {"comment_all": {"comment": "/* Does a down on the appropriate semaphore */", "depth": 0, "reading_ease": 55.91, "reading_grade": 7.2, "line": 204}, "comment_text": "/* Does a down on the appropriate semaphore */", "comment_tokens": ["Does", "a", "down", "on", "the", "appropriate", "semaphore"], "ccode": ["\n", "/* Does a down on the appropriate semaphore */\n", "void down(int *semblk, int xsemnum)\n", "{\n", "    struct sembuf sbuf;\n", "\n", "    sbuf.sem_num = xsemnum%SEMMSL;\n", "    sbuf.sem_op = -1;\n", "    sbuf.sem_flg = 0;\n", "\n", "    while (semop(semblk[xsemnum/SEMMSL], &sbuf, 1) == -1)\n", "      if (errno != EINTR) {\n", "\tperror(\"semop\");\n", "\tbreak;\n", "      }\n", "}\n"], "project": "bplay", "file": "shmbuf.pkl", "function": "down"}, {"comment_all": {"comment": "/* ---------------------------------------------------------------------\n * Auxiliary functions.\n * --------------------------------------------------------------------- */", "depth": 0, "reading_ease": -6.7, "reading_grade": 14.7, "line": 43}, "comment_text": "/* ---------------------------------------------------------------------\n * Auxiliary functions.\n * --------------------------------------------------------------------- */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "Auxiliary", "functions", ".", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["/* Copyright (c) 2007 The NetBSD Foundation, Inc.\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND\n", " * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n", " * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n", " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n", " * IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS BE LIABLE FOR ANY\n", " * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n", " * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n", " * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n", " * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n", " * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n", "\n", "#include <sys/types.h>\n", "#include <sys/wait.h>\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "\n", "#include <signal.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include <atf-c.h>\n", "\n", "#include \"atf-c/detail/env.h\"\n", "#include \"atf-c/detail/fs.h\"\n", "#include \"atf-c/detail/test_helpers.h\"\n", "#include \"atf-c/detail/text.h\"\n", "#include \"atf-c/error.h\"\n", "\n", "/* ---------------------------------------------------------------------\n", " * Auxiliary functions.\n", " * --------------------------------------------------------------------- */\n", "\n", "static\n", "void\n", "safe_remove(const char* path)\n", "{\n", "    if (unlink(path) == -1)\n", "        atf_tc_fail(\"unlink(2) of %s failed\", path);\n", "}\n"], "project": "libatf-c++-2", "file": "c_helpers.pkl", "function": "safe_remove"}, {"comment_all": {"comment": "/* Parameter is the first character in command after the first space.\n      param will be NULL if:\n      1. There was no space\n      2. There was a space but it was the last character in command, in which case\n         param = '\\0'\n   */", "depth": 1, "reading_ease": 86.91, "reading_grade": 3.6, "line": 169}, "comment_text": "/* Parameter is the first character in command after the first space.\n      param will be NULL if:\n      1. There was no space\n      2. There was a space but it was the last character in command, in which case\n         param = '\\0'\n   */", "comment_tokens": ["Parameter", "is", "the", "first", "character", "in", "command", "after", "the", "first", "space", ".", "param", "will", "be", "NULL", "if", ":", "1", ".", "There", "was", "no", "space", "2", ".", "There", "was", "a", "space", "but", "it", "was", "the", "last", "character", "in", "command", ",", "in", "which", "case", "param", "=", "'\\0", "'"], "ccode": ["\n", "\n", "/* command_parse\n", " *\n", " *    Parse a command to bopm (sent to a channel bopm is on). The command is parsed\n", " *    from the parameters, and if it is a known command it is stored in a queue. A\n", " *    userhost is performed on the user to check if they are an IRC operator. When\n", " *    a reply is returned (command_userhost), the command will be executed.\n", " *\n", " * Parameters:\n", " *    command: Command sent (including parameters)\n", " *    msg: Original PRIVMSG containing the command\n", " *    target: Channel command was sent to (we only got this far if there was only one recipient)\n", " *    source_p: Operator (hopefully) that sent the command.\n", " *\n", " */\n", "\n", "void command_parse(char *command, char *msg, struct ChannelConf *target,\n", "      struct UserInfo *source_p)\n", "{\n", "   unsigned int i;\n", "   char *param; /* Parsed parameters */\n", "\n", "   struct Command *cs;\n", "   node_t *node;\n", "\n", "   USE_VAR(msg);\n", "\n", "   if(OPT_DEBUG)\n", "   {\n", "      log_printf(\"COMMAND -> Parsing command (%s) from %s [%s]\", command,\n", "            source_p->irc_nick, target->name);\n", "   }\n", "\n", "   /* Only allow COMMANDMAX commands in the queue */\n", "   if(LIST_SIZE(COMMANDS) >= COMMANDMAX)\n", "      return;\n", "\n", "   /* Parameter is the first character in command after the first space.\n", "      param will be NULL if:\n", "      1. There was no space\n", "      2. There was a space but it was the last character in command, in which case\n", "         param = '\\0'\n", "   */\n", "\n", "   /* Skip past the botname/!all */\n", "   command = strchr(command, ' ');\n", "\n", "   /* There is no command OR\n", "      there is at least nothing\n", "      past that first space.  */\n", "   if(command == NULL ||\n", "         command++ == NULL)\n", "      return;\n", "\n", "\n", "   /* Find the parameters */\n", "   param = strchr(command, ' ');\n", "\n", "   if(param != NULL)\n", "   {\n", "      *param = '\\0';\n", "      param++;\n", "   }\n", "   else\n", "      param = \"\";\n", "\n", "   log_printf(\"COMMAND -> parsed [%s] [%s]\", command, param);\n", "\n", "   /* Lookup the command in the table */\n", "   for(i = 0; i < sizeof(COMMAND_TABLE) / sizeof(struct OperCommandHash); i++)\n", "   {\n", "      if(strcasecmp(command, COMMAND_TABLE[i].command) == 0)\n", "      {\n", "         /* Queue this command */\n", "         cs = command_create(i, param, source_p->irc_nick, target);\n", "         node = node_create(cs);\n", "         list_add(COMMANDS, node);\n", "      }\n", "   }\n", "\n", "   irc_send(\"USERHOST %s\", source_p->irc_nick);\n", "}\n"], "project": "bopm", "file": "opercmd.pkl", "function": "command_parse"}, {"comment_all": {"comment": "/*\n *  Copyright (C) Samuel Thibault <samuel.thibault@ens-lyon.org>\n *\n * This program is free software ; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation ; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY ; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with the program ; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "depth": 0, "reading_ease": 60.35, "reading_grade": 9.6, "line": 0}, "comment_text": "/*\n *  Copyright (C) Samuel Thibault <samuel.thibault@ens-lyon.org>\n *\n * This program is free software ; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation ; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY ; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with the program ; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "comment_tokens": ["Copyright", "(", "C", ")", "Samuel", "Thibault", "<", "samuel.thibault", "@", "ens-lyon.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "the", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/*\n", " *  Copyright (C) Samuel Thibault <samuel.thibault@ens-lyon.org>\n", " *\n", " * This program is free software ; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation ; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY ; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with the program ; if not, write to the Free Software\n", " * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", " */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include \"psf.h\"\n", "int main(int argc, char *argv[]) {\n", "  unsigned base;\n", "  unsigned width, height, mask;\n", "  char *end;\n", "\n", "  if (argc != 4) {\n", "    printf(\"Usage: %s [height] [width] xyz00\\n\", argv[0]);\n", "    printf(\"where xyz00 is the hex value for the desired unicode block\\n\");\n", "    exit(EXIT_FAILURE);\n", "  }\n", "\n", "  height = strtol(argv[1], &end, 10);\n", "  if (end == argv[1] || *end != '\\0') {\n", "    fprintf(stderr,\"Invalid height '%s'\\n\", argv[1]);\n", "    exit(EXIT_FAILURE);\n", "  }\n", "\n", "  width = strtol(argv[2], &end, 10);\n", "  if (end == argv[2] || *end != '\\0') {\n", "    fprintf(stderr,\"Invalid width '%s'\\n\", argv[2]);\n", "    exit(EXIT_FAILURE);\n", "  }\n", "\n", "  base = strtol(argv[3], &end, 16);\n", "  if (end == argv[3] || *end != '\\0') {\n", "    fprintf(stderr,\"Invalid block value '%s'\\n\", argv[3]);\n", "    exit(EXIT_FAILURE);\n", "  }\n", "\n", "  int i, j;\n", "  header(width, height, 256, 1);\n", "  mask = ((1U << (width/2)) - 1) << (width/4);\n", "\n", "  for (i=0;i<256;i++) {\n", "    for (j=0;j<height;j++) {\n", "      if (j >= height/4 && j < 3*height/4)\n", "\tif (width <= 8)\n", "\t  printf(\"%c\", mask);\n", "\telse\n", "\t  printf(\"%c%c\", mask >> 8, mask & 0xff);\n", "      else\n", "\tif (width <= 8)\n", "\t  printf(\"%c\", 0);\n", "\telse\n", "\t  printf(\"%c%c\", 0, 0);\n", "    }\n", "  }\n", "\n", "  for (i=0;i<256;i++)\n", "    sfm(base+i);\n", "  return 0;\n", "}\n"], "project": "console-braille", "file": "gen-psf-block.pkl", "function": "main"}, {"comment_all": {"comment": "/* not supported */", "depth": 2, "reading_ease": 35.61, "reading_grade": 8.8, "line": 164}, "comment_text": "/* not supported */\n/* not supported */\n/* not supported */\n/* not supported */\n/* not supported */\n/* not supported */\n/* not supported */\n/* not supported */\n", "comment_tokens": ["not", "supported", "not", "supported", "not", "supported", "not", "supported", "not", "supported", "not", "supported", "not", "supported", "not", "supported"], "ccode": ["\n", "int pa_oss_auto_format(int fd, pa_sample_spec *ss) {\n", "    int format, channels, speed, reqformat;\n", "    pa_sample_format_t orig_format;\n", "\n", "    static const int format_trans[PA_SAMPLE_MAX] = {\n", "        [PA_SAMPLE_U8] = AFMT_U8,\n", "        [PA_SAMPLE_ALAW] = AFMT_A_LAW,\n", "        [PA_SAMPLE_ULAW] = AFMT_MU_LAW,\n", "        [PA_SAMPLE_S16LE] = AFMT_S16_LE,\n", "        [PA_SAMPLE_S16BE] = AFMT_S16_BE,\n", "        [PA_SAMPLE_FLOAT32LE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_FLOAT32BE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S32LE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S32BE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S24LE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S24BE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S24_32LE] = AFMT_QUERY, /* not supported */\n", "        [PA_SAMPLE_S24_32BE] = AFMT_QUERY, /* not supported */\n", "    };\n", "\n", "    pa_assert(fd >= 0);\n", "    pa_assert(ss);\n", "\n", "    orig_format = ss->format;\n", "\n", "    reqformat = format = format_trans[ss->format];\n", "    if (reqformat == AFMT_QUERY || ioctl(fd, SNDCTL_DSP_SETFMT, &format) < 0 || format != reqformat) {\n", "        format = AFMT_S16_NE;\n", "        if (ioctl(fd, SNDCTL_DSP_SETFMT, &format) < 0 || format != AFMT_S16_NE) {\n", "            int f = AFMT_S16_NE == AFMT_S16_LE ? AFMT_S16_BE : AFMT_S16_LE;\n", "            format = f;\n", "            if (ioctl(fd, SNDCTL_DSP_SETFMT, &format) < 0 || format != f) {\n", "                format = AFMT_U8;\n", "                if (ioctl(fd, SNDCTL_DSP_SETFMT, &format) < 0 || format != AFMT_U8) {\n", "                    pa_log(\"SNDCTL_DSP_SETFMT: %s\", format != AFMT_U8 ? \"No supported sample format\" : pa_cstrerror(errno));\n", "                    return -1;\n", "                } else\n", "                    ss->format = PA_SAMPLE_U8;\n", "            } else\n", "                ss->format = f == AFMT_S16_LE ? PA_SAMPLE_S16LE : PA_SAMPLE_S16BE;\n", "        } else\n", "            ss->format = PA_SAMPLE_S16NE;\n", "    }\n", "\n", "    if (orig_format != ss->format)\n", "        pa_log_warn(\"device doesn't support sample format %s, changed to %s.\",\n", "               pa_sample_format_to_string(orig_format),\n", "               pa_sample_format_to_string(ss->format));\n", "\n", "    channels = ss->channels;\n", "    if (ioctl(fd, SNDCTL_DSP_CHANNELS, &channels) < 0) {\n", "        pa_log(\"SNDCTL_DSP_CHANNELS: %s\", pa_cstrerror(errno));\n", "        return -1;\n", "    }\n", "    pa_assert(channels > 0);\n", "\n", "    if (ss->channels != channels) {\n", "        pa_log_warn(\"device doesn't support %i channels, using %i channels.\", ss->channels, channels);\n", "        ss->channels = (uint8_t) channels;\n", "    }\n", "\n", "    speed = (int) ss->rate;\n", "    if (ioctl(fd, SNDCTL_DSP_SPEED, &speed) < 0) {\n", "        pa_log(\"SNDCTL_DSP_SPEED: %s\", pa_cstrerror(errno));\n", "        return -1;\n", "    }\n", "    pa_assert(speed > 0);\n", "\n", "    if (ss->rate != (unsigned) speed) {\n", "        pa_log_warn(\"device doesn't support %i Hz, changed to %i Hz.\", ss->rate, speed);\n", "\n", "        /* If the sample rate deviates too much, we need to resample */\n", "        if (speed < ss->rate*.95 || speed > ss->rate*1.05)\n", "            ss->rate = (uint32_t) speed;\n", "    }\n", "\n", "    return 0;\n", "}\n"], "project": "pulseaudio-module-jack", "file": "oss-util.pkl", "function": "pa_oss_auto_format"}, {"comment_all": {"comment": "/* Set the lock replacement. */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 1198}, "comment_text": "/* Set the lock replacement. */", "comment_tokens": ["Set", "the", "lock", "replacement", "."], "ccode": ["\n", "DirectResult\n", "fusion_reactor_set_lock_only( FusionReactor  *reactor,\n", "                              FusionSkirmish *lock )\n", "{\n", "     D_MAGIC_ASSERT( reactor, FusionReactor );\n", "     D_ASSERT( lock != NULL );\n", "\n", "     D_DEBUG_AT( Fusion_Reactor, \"fusion_reactor_set_lock_only( %p [%d], lock %p [%d] ) <- old %p [%d]\\n\",\n", "                 reactor, reactor->id, lock, lock->multi.id, reactor->globals_lock, reactor->globals_lock->multi.id );\n", "\n", "     D_ASSUME( reactor->globals_lock != lock );\n", "\n", "     /* Set the lock replacement. */\n", "     reactor->globals_lock = lock;\n", "\n", "     return DR_OK;\n", "}\n"], "project": "libdirectfb-bin", "file": "reactor.pkl", "function": "fusion_reactor_set_lock_only"}, {"comment_all": {"comment": "/* copy string of length at most n, set to zero trailing chars */", "depth": 0, "reading_ease": 93.14, "reading_grade": 3.3, "line": 194}, "comment_text": "/* copy string of length at most n, set to zero trailing chars */", "comment_tokens": ["copy", "string", "of", "length", "at", "most", "n", ",", "set", "to", "zero", "trailing", "chars"], "ccode": ["#define GETSTRINGPARAM(index) Tcl_GetString(objv[index]);\n", "#define RETURNINT(value) \\\n", "   Tcl_SetObjResult(interp,Tcl_NewIntObj(value)); \\\n", "   return TCL_OK;\n", "#define RETURNLIST(number,vec) \\\n", "   Tcl_SetObjResult(interp,Tcl_NewListObj(number,vec)); \\\n", "    return TCL_OK;\n", "\n", "\n", "void cpstrclean(char *s, char *dest, int n)\n", "     /* copy string of length at most n, set to zero trailing chars */\n", "{\n", "  while ((*dest++=*s++) && n--);\n", "  if (! n)  *--dest = 0;\n", "  else  while (n--) *dest++ = 0;\n", "}\n"], "project": "gpsmanshp", "file": "gpsmanshp.pkl", "function": "cpstrclean"}, {"comment_all": {"comment": "/* avoid zombies when spawning processes */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 418}, "comment_text": "/* avoid zombies when spawning processes */", "comment_tokens": ["avoid", "zombies", "when", "spawning", "processes"], "ccode": ["\n", "int main(int argc, char *argv[])\n", "{\n", "    XIEventMask mask;\n", "    int xi_opcode;\n", "    int event, error;\n", "    int opt;\n", "    bool foreground = false, bootstrap = false;\n", "\n", "    #if HAVE_HEADER_IXP_H\n", "    IxpClient *client;\n", "\n", "    char * address = getenv_dup(\"WMII_ADDRESS\");\n", "    char * path = strdup(\"/event\");\n", "    #endif\n", "    #ifdef HAVE_PIDFILE\n", "    char * pidfile = NULL;\n", "    #endif\n", "\n", "    while (((opt = getopt(argc, argv, IXP_GETOPT \"vhnd0c:\" PIDFILE_GETOPT)) != -1) ||\n", "           ((opt == -1) && (command == NULL))) {\n", "        switch (opt) {\n", "            case 'v':\n", "                verbose = true;\n", "                break;\n", "            case 'n':\n", "                no_act = true;\n", "                foreground = true;\n", "                break;\n", "            case 'd':\n", "                foreground = true;\n", "                break;\n", "            case '0':\n", "                bootstrap = true;\n", "                break;\n", "            case 'c':\n", "                if (command)\n", "                    free(command);\n", "                command = realpath(optarg, NULL);\n", "                break;\n", "            #if HAVE_HEADER_IXP_H\n", "            case 'a':\n", "                if (address)\n", "                    free(address);\n", "                address = strdup(optarg);\n", "                break;\n", "            case 'f':\n", "                if (path)\n", "                    free(path);\n", "                path = strdup(optarg);\n", "                break;\n", "            #endif\n", "            #ifdef HAVE_PIDFILE\n", "            case 'p':\n", "                if (pidfile)\n", "                    free(pidfile);\n", "                pidfile = strdup(optarg);\n", "                break;\n", "            #endif\n", "            default:\n", "                fprintf(stderr, \"Usage: %s \"\n", "                #ifdef HAVE_HEADER_IXP_H\n", "                \"[-a address] [-f path] \"\n", "                #endif\n", "                #ifdef HAVE_PIDFILE\n", "                    \"[-p pidfile] \"\n", "                #endif\n", "                \"[-v] [-n] [-d] -c command-prefix\\n\", argv[0]);\n", "                exit(opt == 'h' ? EXIT_SUCCESS : EXIT_FAILURE);\n", "        }\n", "    }\n", "\n", "    Display *display;\n", "    display = XOpenDisplay(NULL);\n", "\n", "    if (display == NULL) {\n", "        fprintf(stderr, \"Can't open X display.\\n\");\n", "        return EXIT_FAILURE;\n", "    }\n", "\n", "    if (!XQueryExtension(display, \"XInputExtension\", &xi_opcode, &event, &error)) {\n", "        printf(\"X Input extension not available.\\n\");\n", "        goto out;\n", "    }\n", "\n", "    XCloseDisplay(display);\n", "\n", "    #if HAVE_HEADER_IXP_H\n", "    if (address) {\n", "        if (*address) {\n", "            if (verbose) {\n", "                fprintf(stderr, \"Connecting to 9P server at %s.\\n\", address);\n", "            }\n", "            client = ixp_mount(address);\n", "        } else {\n", "            if (verbose) {\n", "                fprintf(stderr, \"Connecting to wmii 9P server.\\n\");\n", "            }\n", "            client = ixp_nsmount(\"wmii\");\n", "        }\n", "        if (client == NULL) {\n", "            fprintf(stderr, \"Failed to connect to 9P server: %s\\n\", ixp_errbuf());\n", "            free(address);\n", "            address = NULL;\n", "        } else {\n", "            ixp_unmount(client);\n", "        }\n", "    }\n", "    #endif\n", "\n", "    #ifdef HAVE_PIDFILE\n", "    if (pidfile) {\n", "        pid_t otherpid;\n", "        pfh = pidfile_open(pidfile, 0600, &otherpid);\n", "        if (pfh == NULL) {\n", "            if (errno == EEXIST) {\n", "                fprintf(stderr, \"Already running as %ju.\\n\", (uintmax_t)otherpid);\n", "                exit(EXIT_FAILURE);\n", "            }\n", "            fprintf(stderr, \"Can't open or create pidfile.\\n\");\n", "        }\n", "    }\n", "    #endif\n", "\n", "    if (!foreground) {\n", "        pid_t pid;\n", "        if ((pid = daemonise()) != 0) {\n", "            if (verbose) {\n", "                fprintf(stderr, \"Daemonised as %ju.\\n\", (uintmax_t)pid);\n", "            }\n", "            exit(EXIT_SUCCESS);\n", "        }\n", "    }\n", "\n", "    #ifdef HAVE_PIDFILE\n", "    if (pidfile && pfh) {\n", "        pidfile_write(pfh);\n", "    }\n", "    #endif\n", "\n", "    display = XOpenDisplay(NULL);\n", "\n", "    if (bootstrap) {\n", "        XIDeviceInfo *info;\n", "        int num_devices;\n", "        info = XIQueryDevice(display, XIAllDevices, &num_devices);\n", "\n", "        int i;\n", "        for (i = 0; i < num_devices; i++) {\n", "            switch (info[i].use) {\n", "            case XIMasterPointer:\n", "            case XIMasterKeyboard:\n", "                handle_device(info[i].deviceid, info[i].use, XIMasterAdded, info[i].name);\n", "                break;\n", "            case XISlavePointer:\n", "            case XISlaveKeyboard:\n", "                handle_device(info[i].deviceid, info[i].use, XISlaveAdded, info[i].name);\n", "                handle_device(info[i].deviceid, info[i].use, XIDeviceEnabled, info[i].name);\n", "                break;\n", "            }\n", "        }\n", "        XIFreeDeviceInfo(info);\n", "    }\n", "\n", "    mask.deviceid = XIAllDevices;\n", "    mask.mask_len = XIMaskLen(XI_LASTEVENT);\n", "    mask.mask = calloc(mask.mask_len, sizeof(char));\n", "    XISetMask(mask.mask, XI_HierarchyChanged);\n", "    XISelectEvents(display, DefaultRootWindow(display), &mask, 1);\n", "    XSync(display, False);\n", "\n", "    free(mask.mask);\n", "\n", "    /* avoid zombies when spawning processes */\n", "    struct sigaction sigchld_action = {\n", "        .sa_handler = SIG_DFL,\n", "#ifdef SA_NOCLDWAIT\n", "        .sa_flags = SA_NOCLDWAIT\n", "#endif\n", "    };\n", "    sigaction(SIGCHLD, &sigchld_action, NULL);\n", "\n", "    #if HAVE_HEADER_IXP_H\n", "    if (address) {\n", "        if (*address) {\n", "            client = ixp_mount(address);\n", "        } else {\n", "            client = ixp_nsmount(\"wmii\");\n", "        }\n", "        if (client != NULL) {\n", "            fid = ixp_open(client, path, P9_OWRITE);\n", "        }\n", "    }\n", "    #endif\n", "\n", "    while(1) {\n", "        XEvent ev;\n", "        XGenericEventCookie *cookie = (XGenericEventCookie*)&ev.xcookie;\n", "        XNextEvent(display, (XEvent*)&ev);\n", "\n", "        if (XGetEventData(display, cookie)) {\n", "            if (cookie->type == GenericEvent &&\n", "                cookie->extension == xi_opcode &&\n", "                cookie->evtype == XI_HierarchyChanged) {\n", "                    parse_event(cookie->data);\n", "            }\n", "            XFreeEventData(display, cookie);\n", "        }\n", "    }\n", "\n", "\n", "    XSync(display, False);\n", "out:\n", "    XCloseDisplay(display);\n", "\n", "    return EXIT_SUCCESS;\n", "}\n"], "project": "inputplug", "file": "inputplug.pkl", "function": "main"}, {"comment_all": {"comment": "/*\n * Parse an I2CBUS command line argument and return the corresponding\n * bus number, or a negative value if the bus is invalid.\n */", "depth": 0, "reading_ease": 50.16, "reading_grade": 11.5, "line": 353}, "comment_text": "/*\n * Parse an I2CBUS command line argument and return the corresponding\n * bus number, or a negative value if the bus is invalid.\n */", "comment_tokens": ["Parse", "an", "I2CBUS", "command", "line", "argument", "and", "return", "the", "corresponding", "bus", "number", ",", "or", "a", "negative", "value", "if", "the", "bus", "is", "invalid", "."], "ccode": ["\n", "/*\n", " * Parse an I2CBUS command line argument and return the corresponding\n", " * bus number, or a negative value if the bus is invalid.\n", " */\n", "int lookup_i2c_bus(const char *i2cbus_arg)\n", "{\n", "\tunsigned long i2cbus;\n", "\tchar *end;\n", "\n", "\ti2cbus = strtoul(i2cbus_arg, &end, 0);\n", "\tif (*end || !*i2cbus_arg) {\n", "\t\t/* Not a number, maybe a name? */\n", "\t\treturn lookup_i2c_bus_by_name(i2cbus_arg);\n", "\t}\n", "\tif (i2cbus > 0xFFFFF) {\n", "\t\tfprintf(stderr, \"Error: I2C bus out of range!\\n\");\n", "\t\treturn -2;\n", "\t}\n", "\n", "\treturn i2cbus;\n", "}\n"], "project": "libi2c-dev", "file": "i2cbusses.pkl", "function": "lookup_i2c_bus"}, {"comment_all": {"comment": "/**\n * flickcurl_tags_getRelated:\n * @fc: flickcurl context\n * @tag: tag to fetch related tags for\n *\n * Get a list of tags 'related' to the given tag, based on clustered usage analysis.\n *\n * Implements flickr.tags.getRelated (0.9)\n * \n * Return value: array of #flickcurl_tag or NULL on failure\n **/", "depth": 0, "reading_ease": 35.27, "reading_grade": 13.1, "line": 530}, "comment_text": "/**\n * flickcurl_tags_getRelated:\n * @fc: flickcurl context\n * @tag: tag to fetch related tags for\n *\n * Get a list of tags 'related' to the given tag, based on clustered usage analysis.\n *\n * Implements flickr.tags.getRelated (0.9)\n * \n * Return value: array of #flickcurl_tag or NULL on failure\n **/", "comment_tokens": ["flickcurl_tags_getRelated", ":", "@", "fc", ":", "flickcurl", "context", "@", "tag", ":", "tag", "to", "fetch", "related", "tags", "for", "Get", "a", "list", "of", "tags", "'related", "'", "to", "the", "given", "tag", ",", "based", "on", "clustered", "usage", "analysis", ".", "Implements", "flickr.tags.getRelated", "(", "0.9", ")", "Return", "value", ":", "array", "of", "#", "flickcurl_tag", "or", "NULL", "on", "failure"], "ccode": ["\n", "\n", "/**\n", " * flickcurl_tags_getRelated:\n", " * @fc: flickcurl context\n", " * @tag: tag to fetch related tags for\n", " *\n", " * Get a list of tags 'related' to the given tag, based on clustered usage analysis.\n", " *\n", " * Implements flickr.tags.getRelated (0.9)\n", " * \n", " * Return value: array of #flickcurl_tag or NULL on failure\n", " **/\n", "flickcurl_tag**\n", "flickcurl_tags_getRelated(flickcurl* fc, const char* tag)\n", "{\n", "  xmlDocPtr doc = NULL;\n", "  xmlXPathContextPtr xpathCtx = NULL; \n", "  flickcurl_tag** tags = NULL;\n", "\n", "  flickcurl_init_params(fc, 0);\n", "\n", "  if(!tag)\n", "    return NULL;\n", "  \n", "  flickcurl_add_param(fc, \"tag\", tag);\n", "\n", "  flickcurl_end_params(fc);\n", "\n", "  if(flickcurl_prepare(fc, \"flickr.tags.getRelated\"))\n", "    goto tidy;\n", "\n", "  doc = flickcurl_invoke(fc);\n", "  if(!doc)\n", "    goto tidy;\n", "\n", "  xpathCtx = xmlXPathNewContext(doc);\n", "  if(!xpathCtx) {\n", "    flickcurl_error(fc, \"Failed to create XPath context for document\");\n", "    fc->failed = 1;\n", "    goto tidy;\n", "  }\n", "\n", "  tags = flickcurl_build_tags(fc, NULL,\n", "                            xpathCtx, \n", "                            (xmlChar*)\"/rsp/tags/tag\", \n", "                            NULL);\n", "\n", "  tidy:\n", "  if(xpathCtx)\n", "    xmlXPathFreeContext(xpathCtx);\n", "\n", "  if(fc->failed) {\n", "    if(tags)\n", "      flickcurl_free_tags(tags);\n", "    tags = NULL;\n", "  }\n", "\n", "  return tags;\n", "}\n"], "project": "libflickcurl0", "file": "tags-api.pkl", "function": "flickcurl_tags_getRelated"}, {"comment_all": {"comment": "// list has some items, we need to find the end\n", "depth": 2, "reading_ease": 112.09, "reading_grade": 0.1, "line": 394}, "comment_text": "// list has some items, we need to find the end\n", "comment_tokens": ["list", "has", "some", "items", ",", "we", "need", "to", "find", "the", "end"], "ccode": ["\n", "void add_snk (snkptr *snk_list_ptr, snkptr snk) {\n", "\n", "    // list has no items\n", "    if (*snk_list_ptr == NULL) {\n", "\n", "        *snk_list_ptr = snk;\n", "\n", "    } else {\n", "\n", "    // list has some items, we need to find the end\n", "\n", "        snkptr i;\n", "\n", "        for (i = *snk_list_ptr; i->next != NULL; i = i->next);\n", "\n", "        i->next = snk;\n", "    }\n", "\n", "}\n"], "project": "qflow-tech-osu035", "file": "spice2delay.pkl", "function": "add_snk"}, {"comment_all": {"comment": "// offset in cabinet file where datablocks start\n", "depth": 0, "reading_ease": 64.37, "reading_grade": 6.0, "line": 27}, "comment_text": "// offset in cabinet file where datablocks start\n", "comment_tokens": ["offset", "in", "cabinet", "file", "where", "datablocks", "start"], "ccode": ["\n", "// offset in cabinet file where datablocks start\n", "void cfolder_offsetdata( struct cfolder *cf, int offset ) \n", "{ \n", "\tcf->offsetdata = offset; \n", "}\n"], "project": "lcab", "file": "cfolder.pkl", "function": "cfolder_offsetdata"}, {"comment_all": {"comment": "/***********************************************************************************\n *\n * Name:\trrbb_get_audio_level\t\n *\n * Purpose:\tGet audio level at time the frame was received.\n *\n * Inputs:\tb\tHandle for bit array.\n *\t\t\n ***********************************************************************************/", "depth": 0, "reading_ease": 53.88, "reading_grade": 8.0, "line": 402}, "comment_text": "/***********************************************************************************\n *\n * Name:\trrbb_get_audio_level\t\n *\n * Purpose:\tGet audio level at time the frame was received.\n *\n * Inputs:\tb\tHandle for bit array.\n *\t\t\n ***********************************************************************************/", "comment_tokens": ["Name", ":", "rrbb_get_audio_level", "Purpose", ":", "Get", "audio", "level", "at", "time", "the", "frame", "was", "received", ".", "Inputs", ":", "b", "Handle", "for", "bit", "array", "."], "ccode": ["\n", "\n", "/***********************************************************************************\n", " *\n", " * Name:\trrbb_get_audio_level\t\n", " *\n", " * Purpose:\tGet audio level at time the frame was received.\n", " *\n", " * Inputs:\tb\tHandle for bit array.\n", " *\t\t\n", " ***********************************************************************************/\n", "\n", "alevel_t rrbb_get_audio_level (rrbb_t b)\n", "{\n", "\tassert (b != NULL);\n", "\tassert (b->magic1 == MAGIC1);\n", "\tassert (b->magic2 == MAGIC2);\n", "\n", "\treturn (b->alevel);\n", "}\n"], "project": "direwolf", "file": "rrbb.pkl", "function": "rrbb_get_audio_level"}, {"comment_all": {"comment": "/*\n\t\t * Exact match to an existing ref.\n\t\t */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 312}, "comment_text": "/*\n\t\t * Exact match to an existing ref.\n\t\t */", "comment_tokens": ["Exact", "match", "to", "an", "existing", "ref", "."], "ccode": ["\n", "static void describe_commit(struct object_id *oid, struct strbuf *dst)\n", "{\n", "\tstruct commit *cmit, *gave_up_on = NULL;\n", "\tstruct commit_list *list;\n", "\tstruct commit_name *n;\n", "\tstruct possible_tag all_matches[MAX_TAGS];\n", "\tunsigned int match_cnt = 0, annotated_cnt = 0, cur_match;\n", "\tunsigned long seen_commits = 0;\n", "\tunsigned int unannotated_cnt = 0;\n", "\n", "\tcmit = lookup_commit_reference(the_repository, oid);\n", "\n", "\tn = find_commit_name(&cmit->object.oid);\n", "\tif (n && (tags || all || n->prio == 2)) {\n", "\t\t/*\n", "\t\t * Exact match to an existing ref.\n", "\t\t */\n", "\t\tappend_name(n, dst);\n", "\t\tif (longformat)\n", "\t\t\tappend_suffix(0, n->tag ? get_tagged_oid(n->tag) : oid, dst);\n", "\t\tif (suffix)\n", "\t\t\tstrbuf_addstr(dst, suffix);\n", "\t\treturn;\n", "\t}\n", "\n", "\tif (!max_candidates)\n", "\t\tdie(_(\"no tag exactly matches '%s'\"), oid_to_hex(&cmit->object.oid));\n", "\tif (debug)\n", "\t\tfprintf(stderr, _(\"No exact match on refs or tags, searching to describe\\n\"));\n", "\n", "\tif (!have_util) {\n", "\t\tstruct hashmap_iter iter;\n", "\t\tstruct commit *c;\n", "\t\tstruct commit_name *n;\n", "\n", "\t\tinit_commit_names(&commit_names);\n", "\t\thashmap_for_each_entry(&names, &iter, n,\n", "\t\t\t\t\tentry /* member name */) {\n", "\t\t\tc = lookup_commit_reference_gently(the_repository,\n", "\t\t\t\t\t\t\t   &n->peeled, 1);\n", "\t\t\tif (c)\n", "\t\t\t\t*commit_names_at(&commit_names, c) = n;\n", "\t\t}\n", "\t\thave_util = 1;\n", "\t}\n", "\n", "\tlist = NULL;\n", "\tcmit->object.flags = SEEN;\n", "\tcommit_list_insert(cmit, &list);\n", "\twhile (list) {\n", "\t\tstruct commit *c = pop_commit(&list);\n", "\t\tstruct commit_list *parents = c->parents;\n", "\t\tstruct commit_name **slot;\n", "\n", "\t\tseen_commits++;\n", "\t\tslot = commit_names_peek(&commit_names, c);\n", "\t\tn = slot ? *slot : NULL;\n", "\t\tif (n) {\n", "\t\t\tif (!tags && !all && n->prio < 2) {\n", "\t\t\t\tunannotated_cnt++;\n", "\t\t\t} else if (match_cnt < max_candidates) {\n", "\t\t\t\tstruct possible_tag *t = &all_matches[match_cnt++];\n", "\t\t\t\tt->name = n;\n", "\t\t\t\tt->depth = seen_commits - 1;\n", "\t\t\t\tt->flag_within = 1u << match_cnt;\n", "\t\t\t\tt->found_order = match_cnt;\n", "\t\t\t\tc->object.flags |= t->flag_within;\n", "\t\t\t\tif (n->prio == 2)\n", "\t\t\t\t\tannotated_cnt++;\n", "\t\t\t}\n", "\t\t\telse {\n", "\t\t\t\tgave_up_on = c;\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t\tfor (cur_match = 0; cur_match < match_cnt; cur_match++) {\n", "\t\t\tstruct possible_tag *t = &all_matches[cur_match];\n", "\t\t\tif (!(c->object.flags & t->flag_within))\n", "\t\t\t\tt->depth++;\n", "\t\t}\n", "\t\tif (annotated_cnt && !list) {\n", "\t\t\tif (debug)\n", "\t\t\t\tfprintf(stderr, _(\"finished search at %s\\n\"),\n", "\t\t\t\t\toid_to_hex(&c->object.oid));\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\twhile (parents) {\n", "\t\t\tstruct commit *p = parents->item;\n", "\t\t\tparse_commit(p);\n", "\t\t\tif (!(p->object.flags & SEEN))\n", "\t\t\t\tcommit_list_insert_by_date(p, &list);\n", "\t\t\tp->object.flags |= c->object.flags;\n", "\t\t\tparents = parents->next;\n", "\n", "\t\t\tif (first_parent)\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\tif (!match_cnt) {\n", "\t\tstruct object_id *cmit_oid = &cmit->object.oid;\n", "\t\tif (always) {\n", "\t\t\tstrbuf_add_unique_abbrev(dst, cmit_oid, abbrev);\n", "\t\t\tif (suffix)\n", "\t\t\t\tstrbuf_addstr(dst, suffix);\n", "\t\t\treturn;\n", "\t\t}\n", "\t\tif (unannotated_cnt)\n", "\t\t\tdie(_(\"No annotated tags can describe '%s'.\\n\"\n", "\t\t\t    \"However, there were unannotated tags: try --tags.\"),\n", "\t\t\t    oid_to_hex(cmit_oid));\n", "\t\telse\n", "\t\t\tdie(_(\"No tags can describe '%s'.\\n\"\n", "\t\t\t    \"Try --always, or create some tags.\"),\n", "\t\t\t    oid_to_hex(cmit_oid));\n", "\t}\n", "\n", "\tQSORT(all_matches, match_cnt, compare_pt);\n", "\n", "\tif (gave_up_on) {\n", "\t\tcommit_list_insert_by_date(gave_up_on, &list);\n", "\t\tseen_commits--;\n", "\t}\n", "\tseen_commits += finish_depth_computation(&list, &all_matches[0]);\n", "\tfree_commit_list(list);\n", "\n", "\tif (debug) {\n", "\t\tstatic int label_width = -1;\n", "\t\tif (label_width < 0) {\n", "\t\t\tint i, w;\n", "\t\t\tfor (i = 0; i < ARRAY_SIZE(prio_names); i++) {\n", "\t\t\t\tw = strlen(_(prio_names[i]));\n", "\t\t\t\tif (label_width < w)\n", "\t\t\t\t\tlabel_width = w;\n", "\t\t\t}\n", "\t\t}\n", "\t\tfor (cur_match = 0; cur_match < match_cnt; cur_match++) {\n", "\t\t\tstruct possible_tag *t = &all_matches[cur_match];\n", "\t\t\tfprintf(stderr, \" %-*s %8d %s\\n\",\n", "\t\t\t\tlabel_width, _(prio_names[t->name->prio]),\n", "\t\t\t\tt->depth, t->name->path);\n", "\t\t}\n", "\t\tfprintf(stderr, _(\"traversed %lu commits\\n\"), seen_commits);\n", "\t\tif (gave_up_on) {\n", "\t\t\tfprintf(stderr,\n", "\t\t\t\t_(\"more than %i tags found; listed %i most recent\\n\"\n", "\t\t\t\t\"gave up search at %s\\n\"),\n", "\t\t\t\tmax_candidates, max_candidates,\n", "\t\t\t\toid_to_hex(&gave_up_on->object.oid));\n", "\t\t}\n", "\t}\n", "\n", "\tappend_name(all_matches[0].name, dst);\n", "\tif (abbrev)\n", "\t\tappend_suffix(all_matches[0].depth, &cmit->object.oid, dst);\n", "\tif (suffix)\n", "\t\tstrbuf_addstr(dst, suffix);\n", "}\n"], "project": "git-email", "file": "describe.pkl", "function": "describe_commit"}, {"comment_all": {"comment": "/**\n *  This function deletes a track from a playlist.\n *\n * @param pl the playlist that the track shall be removed from\n * @param pos the position in the playlist to be deleted\n * @see NJB_Playlist_Addtrack()\n * @see NJB_Playlist_Deltrack_TrackID()\n */", "depth": 0, "reading_ease": 71.65, "reading_grade": 7.4, "line": 193}, "comment_text": "/**\n *  This function deletes a track from a playlist.\n *\n * @param pl the playlist that the track shall be removed from\n * @param pos the position in the playlist to be deleted\n * @see NJB_Playlist_Addtrack()\n * @see NJB_Playlist_Deltrack_TrackID()\n */", "comment_tokens": ["This", "function", "deletes", "a", "track", "from", "a", "playlist", ".", "@", "param", "pl", "the", "playlist", "that", "the", "track", "shall", "be", "removed", "from", "@", "param", "pos", "the", "position", "in", "the", "playlist", "to", "be", "deleted", "@", "see", "NJB_Playlist_Addtrack", "(", ")", "@", "see", "NJB_Playlist_Deltrack_TrackID", "(", ")"], "ccode": ["\n", "/**\n", " *  This function deletes a track from a playlist.\n", " *\n", " * @param pl the playlist that the track shall be removed from\n", " * @param pos the position in the playlist to be deleted\n", " * @see NJB_Playlist_Addtrack()\n", " * @see NJB_Playlist_Deltrack_TrackID()\n", " */\n", "void NJB_Playlist_Deltrack(njb_playlist_t *pl, unsigned int pos)\n", "{\n", "  __dsub = \"NJB_Playlist_Deltrack\";\n", "  njb_playlist_track_t *track;\n", "  \n", "  __enter;\n", "  \n", "  if ( pos > pl->ntracks ) pos = NJB_PL_END;\n", "  \n", "  pl->_state = NJB_PL_CHTRACKS;\n", "  \n", "  if ( pos == NJB_PL_START ) {\n", "    track = pl->first;\n", "    pl->first = pl->first->next;\n", "    if (pl->first != NULL) {\n", "      pl->first->prev = NULL;\n", "    }\n", "  } else if ( pos == NJB_PL_END ) {\n", "    track = pl->last;\n", "    pl->last = pl->last->prev;\n", "    if (pl->last != NULL) {\n", "      pl->last->next = NULL;\n", "    }\n", "  } else {\n", "    int i = 1;\n", "    \n", "    NJB_Playlist_Reset_Gettrack(pl);\n", "    while ( (track = NJB_Playlist_Gettrack(pl)) ) {\n", "      if ( i == pos ) {\n", "\tif ( track->prev != NULL ) {\n", "\t  track->prev->next = track->next;\n", "\t}\n", "\tif ( track->next != NULL ) {\n", "\t  track->next->prev = track->prev;\n", "\t}\n", "\t\n", "\tNJB_Playlist_Track_Destroy(track);\n", "\tpl->ntracks--;\n", "\t\n", "\t__leave;\n", "\treturn;\n", "      }\n", "      i++;\n", "    }\n", "  }\n", "  \n", "  NJB_Playlist_Track_Destroy(track);\n", "  pl->ntracks--;\n", "  \n", "  __leave;\n", "}\n"], "project": "libnjb-tools", "file": "playlist.pkl", "function": "NJB_Playlist_Deltrack"}, {"comment_all": {"comment": "/* datablock->types[i] = reallocx( datablock->types[i],\n                                      sizeof(datablock->types[0][0]) * capacity,\n                                      &inner ); */", "depth": 3, "reading_ease": -120.74, "reading_grade": 31.6, "line": 536}, "comment_text": "/* datablock->types[i] = reallocx( datablock->types[i],\n                                      sizeof(datablock->types[0][0]) * capacity,\n                                      &inner ); */", "comment_tokens": ["datablock-", ">", "types", "[", "i", "]", "=", "reallocx", "(", "datablock-", ">", "types", "[", "i", "]", ",", "sizeof", "(", "datablock-", ">", "types", "[", "0", "]", "[", "0", "]", ")", "capacity", ",", "&", "inner", ")", ";"], "ccode": ["\n", "void datablock_push_loop_cifvalue( DATABLOCK * datablock, CIFVALUE *value,\n", "                                   cexception_t *ex )\n", "{\n", "    cexception_t inner;\n", "    ssize_t i, j, capacity;\n", "\n", "    assert( datablock->loop_start < datablock->length );\n", "    assert( datablock->loop_current < datablock->length );\n", "\n", "    cexception_guard( inner ) {\n", "        i = datablock->loop_current;\n", "        j = datablock->value_lengths[i];\n", "        capacity = datablock->value_capacities[i];\n", "        if( j >= capacity ) {\n", "            //FIXME: the '... += DELTA_CAPACITY' algorithm is fine for\n", "            // \"small\" CIFs, but may exhibit quadratic performance\n", "            // when large CIFs (> 1M values in a loop) are\n", "            // encountered. To avoid excessive run times, the doubling\n", "            // of the allocated memory, 'capacity *= 2', as below, is\n", "            // advised. To avoid overusing memory, however, we need\n", "            // to reallocate back to realistic capacities at the very\n", "            // end of the CIF data structure construction. Synthetic\n", "            // tests for the performance of the suggested code need to\n", "            // be built first. (S.G.).\n", "\n", "            // capacity *= 2;\n", "            capacity += DELTA_CAPACITY;\n", "            datablock->values[i] = reallocx( datablock->values[i],\n", "                                       sizeof(datablock->values[0][0]) * capacity,\n", "                                       &inner );\n", "            /* datablock->types[i] = reallocx( datablock->types[i],\n", "                                      sizeof(datablock->types[0][0]) * capacity,\n", "                                      &inner ); */\n", "            datablock->value_capacities[i] = capacity;\n", "        }\n", "        datablock->value_lengths[i] = j + 1;\n", "        datablock->values[i][j] = value;\n", "        datablock->loop_current++;\n", "        if( datablock->loop_current >= datablock->length ) {\n", "            datablock->loop_current = datablock->loop_start;\n", "        }\n", "    }\n", "    cexception_catch {\n", "        cexception_reraise( inner, ex );\n", "    }\n", "}\n"], "project": "libcodcif2", "file": "datablock.pkl", "function": "datablock_push_loop_cifvalue"}, {"comment_all": {"comment": "/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 2016}, "comment_text": "/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */", "comment_tokens": ["It", "'s", "okay", "to", "grow", "etc", ".", "this", "buffer", ",", "and", "we", "should", "throw", "it", "away", "when", "we", "'re", "done", "."], "ccode": ["\n", "/** Setup the input buffer state to scan the given bytes. The next call to yylex() will\n", " * scan from a @e copy of @a bytes.\n", " * @param yybytes the byte buffer to scan\n", " * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n", " * \n", " * @return the newly allocated buffer state object.\n", " */\n", "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "\tchar *buf;\n", "\tyy_size_t n;\n", "\tint i;\n", "    \n", "\t/* Get memory for full buffer, including space for trailing EOB's. */\n", "\tn = _yybytes_len + 2;\n", "\tbuf = (char *) yyalloc(n  );\n", "\tif ( ! buf )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n", "\n", "\tfor ( i = 0; i < _yybytes_len; ++i )\n", "\t\tbuf[i] = yybytes[i];\n", "\n", "\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\tb = yy_scan_buffer(buf,n );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n", "\n", "\t/* It's okay to grow etc. this buffer, and we should throw it\n", "\t * away when we're done.\n", "\t */\n", "\tb->yy_is_our_buffer = 1;\n", "\n", "\treturn b;\n", "}\n"], "project": "esmtp", "file": "lexer.pkl", "function": "yy_scan_bytes"}, {"comment_all": {"comment": "/* XXX: need to be able to reload configurations... */", "depth": 1, "reading_ease": 71.82, "reading_grade": 5.2, "line": 227}, "comment_text": "/* XXX: need to be able to reload configurations... */\n/* already succesfully initialized */\n", "comment_tokens": ["XXX", ":", "need", "to", "be", "able", "to", "reload", "configurations", "...", "already", "succesfully", "initialized"], "ccode": ["\n", "int nfs4_init_name_mapping(char *conffile)\n", "{\n", "\tint ret = -ENOENT;\n", "\tint dflt = 0;\n", "\tstruct conf_list *nfs4_methods, *gss_methods;\n", "\n", "\t/* XXX: need to be able to reload configurations... */\n", "\tif (nfs4_plugins) /* already succesfully initialized */\n", "\t\treturn 0;\n", "\tif (conffile)\n", "\t\tconf_path = conffile;\n", "\telse\n", "\t\tconf_path = PATH_IDMAPDCONF;\n", "\tconf_init();\n", "\tdefault_domain = conf_get_str(\"General\", \"Domain\");\n", "\tif (default_domain == NULL) {\n", "\t\tdflt = 1;\n", "\t\tret = domain_from_dns(&default_domain);\n", "\t\tif (ret) {\n", "\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Unable to determine \"\n", "\t\t\t\t  \"the NFSv4 domain; Using '%s' as the NFSv4 domain \"\n", "\t\t\t\t  \"which means UIDs will be mapped to the 'Nobody-User' \"\n", "\t\t\t\t  \"user defined in %s\\n\", \n", "\t\t\t\t  IDMAPD_DEFAULT_DOMAIN, PATH_IDMAPDCONF));\n", "\t\t\tdefault_domain = IDMAPD_DEFAULT_DOMAIN;\n", "\t\t}\n", "\t}\n", "\tIDMAP_LOG(1, (\"libnfsidmap: using%s domain: %s\",\n", "\t\t(dflt ? \" (default)\" : \"\"), default_domain));\n", "\n", "\t/* Get list of \"local equivalent\" realms.  Meaning the list of realms\n", "\t * where john@REALM.A is considered the same user as john@REALM.B\n", "\t * If not specified, default to upper-case of local domain name */\n", "\tlocal_realms = conf_get_list(\"General\", \"Local-Realms\");\n", "\tif (local_realms == NULL) {\n", "\t\tstruct conf_list_node *node;\n", "\n", "\t\tlocal_realms = malloc(sizeof *local_realms);\n", "\t\tif (local_realms == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\tlocal_realms->cnt = 0;\n", "\t\tTAILQ_INIT(&local_realms->fields);\n", "\n", "\t\tnode = calloc(1, sizeof *node);\n", "\t\tif (node == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\tnode->field = strdup(get_default_domain());\n", "\t\tif (node->field == NULL)\n", "\t\t\treturn -ENOMEM;\n", "\t\ttoupper_str(node->field);\n", "\n", "\t\tTAILQ_INSERT_TAIL(&local_realms->fields, node, link);\n", "\t\tlocal_realms->cnt++;\n", "\t}\n", "\n", "\tif (idmap_verbosity >= 1) {\n", "\t\tstruct conf_list_node *r;\n", "\t\tchar *buf = NULL;\n", "\t\tint siz=0;\n", "\n", "\t\tif (local_realms) {\n", "\t\t\tTAILQ_FOREACH(r, &local_realms->fields, link) {\n", "\t\t\t\tsiz += (strlen(r->field)+4);\n", "\t\t\t}\n", "\t\t\tbuf = malloc(siz);\n", "\t\t\tif (buf) {\n", "\t\t\t\tTAILQ_FOREACH(r, &local_realms->fields, link) {\n", "\t\t\t\t\tsprintf(buf, \"'%s' \", r->field);\n", "\t\t\t\t}\n", "\t\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Realms list: %s\", buf));\n", "\t\t\t\tfree(buf);\n", "\t\t\t}\n", "\t\t} else \n", "\t\t\tIDMAP_LOG(1, (\"libnfsidmap: Realms list: <NULL> \"));\n", "\t}\n", "\n", "\tnfs4_methods = conf_get_list(\"Translation\", \"Method\");\n", "\tif (nfs4_methods) {\n", "\t\tIDMAP_LOG(1, (\"libnfsidmap: processing 'Method' list\"));\n", "\t\tif (load_plugins(nfs4_methods, &nfs4_plugins) == -1)\n", "\t\t\treturn -ENOENT;\n", "\t} else {\n", "\t\tstruct conf_list list;\n", "\t\tstruct conf_list_node node;\n", "\n", "\t\tTAILQ_INIT(&list.fields);\n", "\t\tlist.cnt = 1;\n", "\t\tnode.field = \"nsswitch\";\n", "\t\tTAILQ_INSERT_TAIL (&list.fields, &node, link);\n", "\n", "\t\tif (load_plugins(&list, &nfs4_plugins) == -1)\n", "\t\t\treturn -ENOENT;\n", "\t}\n", "\n", "\tgss_methods = conf_get_list(\"Translation\", \"GSS-Methods\");\n", "\tif (gss_methods) {\n", "\t\tIDMAP_LOG(1, (\"libnfsidmap: processing 'GSS-Methods' list\"));\n", "\t\tif (load_plugins(gss_methods, &gss_plugins) == -1)\n", "\t\t\tgoto out;\n", "\t}\n", "\tret = 0;\n", "out:\n", "\tif (ret) {\n", "\t\tif (nfs4_plugins)\n", "\t\t\tunload_plugins(nfs4_plugins);\n", "\t\tif (gss_plugins)\n", "\t\t\tunload_plugins(gss_plugins);\n", "\t\tnfs4_plugins = gss_plugins = NULL;\n", "\t}\n", "\n", "\treturn ret ? -ENOENT: 0;\n", "}\n"], "project": "libnfsidmap-dev", "file": "libnfsidmap.pkl", "function": "nfs4_init_name_mapping"}, {"comment_all": {"comment": "/* No match, output the query instead */", "depth": 2, "reading_ease": 90.77, "reading_grade": 2.1, "line": 136}, "comment_text": "/* No match, output the query instead */", "comment_tokens": ["No", "match", ",", "output", "the", "query", "instead"], "ccode": ["\n", "static void action_emit(tty_interface_t *state) {\n", "\tupdate_state(state);\n", "\n", "\t/* Reset the tty as close as possible to the previous state */\n", "\tclear(state);\n", "\n", "\t/* ttyout should be flushed before outputting on stdout */\n", "\ttty_close(state->tty);\n", "\n", "\tconst char *selection = choices_get(state->choices, state->choices->selection);\n", "\tif (selection) {\n", "\t\t/* output the selected result */\n", "\t\tprintf(\"%s\\n\", selection);\n", "\t} else {\n", "\t\t/* No match, output the query instead */\n", "\t\tprintf(\"%s\\n\", state->search);\n", "\t}\n", "\n", "\tstate->exit = EXIT_SUCCESS;\n", "}\n"], "project": "fzy", "file": "tty_interface.pkl", "function": "action_emit"}, {"comment_all": {"comment": "/* Read literal in specified radix  */", "depth": 0, "reading_ease": 49.48, "reading_grade": 7.6, "line": 687}, "comment_text": "/* Read literal in specified radix  */\n/* from input of the form 0c{digs}  */\n", "comment_tokens": ["Read", "literal", "in", "specified", "radix", "from", "input", "of", "the", "form", "0c", "{", "digs", "}"], "ccode": ["\n", "static Cell local readRadixNumber(r)   /* Read literal in specified radix  */\n", "Int r; {                               /* from input of the form 0c{digs}  */\n", "    Int d;\t\t\t       \t\t\t\t\t   \n", "    skip();                            /* skip leading zero                */\n", "    if ((d=readHexDigit(c1))<0 || d>=r)/* Special case; no digits, lex as  */\n", "\treturn mkInt(0);               /* if it had been written \"0 c...\"  */\n", "    else {\n", "\tInt  n = 0;\n", "#if BIGNUMS\n", "\tCell big = NIL;\n", "#endif\n", "\tskip();\n", "\tdo {\n", "#if BIGNUMS\n", "\t    if (nonNull(big))\n", "\t\tbig = bigShift(big,d,r);\n", "\t    else if (overflows(n,r,d,MAXPOSINT))\n", "\t\tbig = bigShift(bigInt(n),d,r);\n", "\t    else\n", "#else\n", "\t    if (overflows(n,r,d,MAXPOSINT)) {\n", "\t\tERRMSG(row) \"Integer literal out of range\"\n", "\t\tEEND;\n", "\t    }\n", "\t    else\n", "#endif\n", "\t\tn = r*n + d;\n", "\t    skip();\n", "\t    d = readHexDigit(c0);\n", "\t} while (d>=0 && d<r);\n", "#if BIGNUMS\n", "\treturn nonNull(big) ? big : mkInt(n);\n", "#else\n", "\treturn mkInt(n);\n", "#endif\n", "    }\n", "}\n"], "project": "libhugs-network-bundled", "file": "input.pkl", "function": "readRadixNumber"}, {"comment_all": {"comment": "/*--------------------------------------------------------------------------*\\\n *  NAME:\n *      HashTableGet() - retrieves the value of a key in a HashTable\n *  DESCRIPTION:\n *      Retrieves the value of the specified key in the specified HashTable.\n *      Uses the comparison function specified by\n *      HashTableSetKeyComparisonFunction().\n *  EFFICIENCY:\n *      O(1), assuming a good hash function and element-to-bucket ratio\n *  ARGUMENTS:\n *      hashTable    - the HashTable to search\n *      key          - the key whose value is desired\n *  RETURNS:\n *      void *       - the value of the specified key, or NULL if the key\n *                     doesn't exist in the HashTable\n\\*--------------------------------------------------------------------------*/", "depth": 0, "reading_ease": 47.42, "reading_grade": 12.5, "line": 277}, "comment_text": "/*--------------------------------------------------------------------------*\\\n *  NAME:\n *      HashTableGet() - retrieves the value of a key in a HashTable\n *  DESCRIPTION:\n *      Retrieves the value of the specified key in the specified HashTable.\n *      Uses the comparison function specified by\n *      HashTableSetKeyComparisonFunction().\n *  EFFICIENCY:\n *      O(1), assuming a good hash function and element-to-bucket ratio\n *  ARGUMENTS:\n *      hashTable    - the HashTable to search\n *      key          - the key whose value is desired\n *  RETURNS:\n *      void *       - the value of the specified key, or NULL if the key\n *                     doesn't exist in the HashTable\n\\*--------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "\\", "NAME", ":", "HashTableGet", "(", ")", "-", "retrieves", "the", "value", "of", "a", "key", "in", "a", "HashTable", "DESCRIPTION", ":", "Retrieves", "the", "value", "of", "the", "specified", "key", "in", "the", "specified", "HashTable", ".", "Uses", "the", "comparison", "function", "specified", "by", "HashTableSetKeyComparisonFunction", "(", ")", ".", "EFFICIENCY", ":", "O", "(", "1", ")", ",", "assuming", "a", "good", "hash", "function", "and", "element-to-bucket", "ratio", "ARGUMENTS", ":", "hashTable", "-", "the", "HashTable", "to", "search", "key", "-", "the", "key", "whose", "value", "is", "desired", "RETURNS", ":", "void", "-", "the", "value", "of", "the", "specified", "key", ",", "or", "NULL", "if", "the", "key", "does", "n't", "exist", "in", "the", "HashTable", "\\", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["\n", "/*--------------------------------------------------------------------------*\\\n", " *  NAME:\n", " *      HashTableGet() - retrieves the value of a key in a HashTable\n", " *  DESCRIPTION:\n", " *      Retrieves the value of the specified key in the specified HashTable.\n", " *      Uses the comparison function specified by\n", " *      HashTableSetKeyComparisonFunction().\n", " *  EFFICIENCY:\n", " *      O(1), assuming a good hash function and element-to-bucket ratio\n", " *  ARGUMENTS:\n", " *      hashTable    - the HashTable to search\n", " *      key          - the key whose value is desired\n", " *  RETURNS:\n", " *      void *       - the value of the specified key, or NULL if the key\n", " *                     doesn't exist in the HashTable\n", "\\*--------------------------------------------------------------------------*/\n", "\n", "static void    *\n", "HashTableGet(const HashTable * hashTable, const void *key)\n", "{\n", "  long            hashValue =\n", "      hashTable->hashFunction(key) % hashTable->numOfBuckets;\n", "  KeyValuePair   *pair = hashTable->bucketArray[hashValue];\n", "\n", "  while (pair != NULL && hashTable->keycmp(key, pair->key) != 0)\n", "    pair = pair->next;\n", "\n", "  return (pair == NULL) ? NULL : pair->value;\n", "}\n"], "project": "libsfcutil0", "file": "hashtable.pkl", "function": "HashTableGet"}, {"comment_all": {"comment": "/* getting into that safe state is expensive.)\t\t\t\t*/", "depth": 0, "reading_ease": 64.37, "reading_grade": 6.0, "line": 1030}, "comment_text": "/* Returns true if it is worth calling GC_invoke_finalizers. (Useful if\t*/\n/* finalizers can only be called from some kind of `safe state' and\t*/\n/* getting into that safe state is expensive.)\t\t\t\t*/\n", "comment_tokens": ["Returns", "true", "if", "it", "is", "worth", "calling", "GC_invoke_finalizers", ".", "(", "Useful", "if", "finalizers", "can", "only", "be", "called", "from", "some", "kind", "of", "`", "safe", "state", "'", "and", "getting", "into", "that", "safe", "state", "is", "expensive", ".", ")"], "ccode": ["#endif\n", "\n", "/* Returns true if it is worth calling GC_invoke_finalizers. (Useful if\t*/\n", "/* finalizers can only be called from some kind of `safe state' and\t*/\n", "/* getting into that safe state is expensive.)\t\t\t\t*/\n", "int GC_should_invoke_finalizers GC_PROTO((void))\n", "{\n", "    return GC_finalize_now != 0;\n", "}\n"], "project": "libmono-tasklets4.0-cil", "file": "finalize.pkl", "function": "GC_should_invoke_finalizers"}, {"comment_all": {"comment": "/*\n * ***************************************************************************\n * Routine:  Vpup_execCmd\n *\n * Purpose:  A simple shell command exec.\n *\n * Author:   Michael Holst\n * ***************************************************************************\n */", "depth": 0, "reading_ease": 48.97, "reading_grade": 7.8, "line": 334}, "comment_text": "/*\n * ***************************************************************************\n * Routine:  Vpup_execCmd\n *\n * Purpose:  A simple shell command exec.\n *\n * Author:   Michael Holst\n * ***************************************************************************\n */", "comment_tokens": ["Routine", ":", "Vpup_execCmd", "Purpose", ":", "A", "simple", "shell", "command", "exec", ".", "Author", ":", "Michael", "Holst"], "ccode": ["#else\n", "\n", "/*\n", " * ***************************************************************************\n", " * Routine:  Vpup_execCmd\n", " *\n", " * Purpose:  A simple shell command exec.\n", " *\n", " * Author:   Michael Holst\n", " * ***************************************************************************\n", " */\n", "VPUBLIC void Vpup_execCmd(const char *PR, int argc, char **argv, char *inbuf)\n", "{\n", "    Vnm_exec(argc,argv);\n", "}\n"], "project": "libmaloc1", "file": "vpup.pkl", "function": "Vpup_execCmd"}, {"comment_all": {"comment": "/*\n\n Init, read, write handler for the \"colr\" (Clean Aperture) atom.\n\n*/", "depth": 0, "reading_ease": 95.17, "reading_grade": 2.5, "line": 24}, "comment_text": "/*\n\n Init, read, write handler for the \"colr\" (Clean Aperture) atom.\n\n*/", "comment_tokens": ["Init", ",", "read", ",", "write", "handler", "for", "the", "``", "colr", "''", "(", "Clean", "Aperture", ")", "atom", "."], "ccode": ["/*******************************************************************************\n", " colr.c\n", "\n", " libquicktime - A library for reading and writing quicktime/avi/mp4 files.\n", " http://libquicktime.sourceforge.net\n", "\n", " Copyright (C) 2002 Heroine Virtual Ltd.\n", " Copyright (C) 2002-2011 Members of the libquicktime project.\n", "\n", " This library is free software; you can redistribute it and/or modify it under\n", " the terms of the GNU Lesser General Public License as published by the Free\n", " Software Foundation; either version 2.1 of the License, or (at your option)\n", " any later version.\n", "\n", " This library is distributed in the hope that it will be useful, but WITHOUT\n", " ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n", " FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n", " details.\n", "\n", " You should have received a copy of the GNU Lesser General Public License along\n", " with this library; if not, write to the Free Software Foundation, Inc., 51\n", " Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n", "*******************************************************************************/ \n", "\n", "/*\n", "\n", " Init, read, write handler for the \"colr\" (Clean Aperture) atom.\n", "\n", "*/\n", "\n", "#include \"lqt_private.h\"\n", "#include <string.h>\n", "\n", "void quicktime_colr_init(quicktime_colr_t *colr)\n", "{\n", "\tmemset(colr, 0, sizeof (*colr));\n", "}\n"], "project": "quicktime-utils", "file": "colr.pkl", "function": "quicktime_colr_init"}, {"comment_all": {"comment": "/* Exclude the moved bottom segment from further swapping.  */", "depth": 3, "reading_ease": 63.36, "reading_grade": 6.4, "line": 157}, "comment_text": "/* Exclude the moved bottom segment from further swapping.  */", "comment_tokens": ["Exclude", "the", "moved", "bottom", "segment", "from", "further", "swapping", "."], "ccode": ["/* Getopt for GNU.\n", "   Copyright (C) 1987-2019 Free Software Foundation, Inc.\n", "   This file is part of the GNU C Library and is also part of gnulib.\n", "   Patches to this file should be submitted to both projects.\n", "\n", "   The GNU C Library is free software; you can redistribute it and/or\n", "   modify it under the terms of the GNU General Public\n", "   License as published by the Free Software Foundation; either\n", "   version 3 of the License, or (at your option) any later version.\n", "\n", "   The GNU C Library is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "   General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public\n", "   License along with the GNU C Library; if not, see\n", "   <https://www.gnu.org/licenses/>.  */\n", "\f\n", "#ifndef _LIBC\n", "# include <config.h>\n", "#endif\n", "\n", "#include \"getopt.h\"\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <unistd.h>\n", "\n", "#ifdef _LIBC\n", "/* When used as part of glibc, error printing must be done differently\n", "   for standards compliance.  getopt is not a cancellation point, so\n", "   it must not call functions that are, and it is specified by an\n", "   older standard than stdio locking, so it must not refer to\n", "   functions in the \"user namespace\" related to stdio locking.\n", "   Finally, it must use glibc's internal message translation so that\n", "   the messages are looked up in the proper text domain.  */\n", "# include <libintl.h>\n", "# define fprintf __fxprintf_nocancel\n", "# define flockfile(fp) _IO_flockfile (fp)\n", "# define funlockfile(fp) _IO_funlockfile (fp)\n", "#else\n", "# include \"gettext.h\"\n", "# define _(msgid) gettext (msgid)\n", "/* When used standalone, flockfile and funlockfile might not be\n", "   available.  */\n", "# if (!defined _POSIX_THREAD_SAFE_FUNCTIONS \\\n", "      || (defined _WIN32 && ! defined __CYGWIN__))\n", "#  define flockfile(fp) /* nop */\n", "#  define funlockfile(fp) /* nop */\n", "# endif\n", "/* When used standalone, do not attempt to use alloca.  */\n", "# define __libc_use_alloca(size) 0\n", "# undef alloca\n", "# define alloca(size) (abort (), (void *)0)\n", "#endif\n", "\n", "/* This implementation of 'getopt' has three modes for handling\n", "   options interspersed with non-option arguments.  It can stop\n", "   scanning for options at the first non-option argument encountered,\n", "   as POSIX specifies.  It can continue scanning for options after the\n", "   first non-option argument, but permute 'argv' as it goes so that,\n", "   after 'getopt' is done, all the options precede all the non-option\n", "   arguments and 'optind' points to the first non-option argument.\n", "   Or, it can report non-option arguments as if they were arguments to\n", "   the option character '\\x01'.\n", "\n", "   The default behavior of 'getopt_long' is to permute the argument list.\n", "   When this implementation is used standalone, the default behavior of\n", "   'getopt' is to stop at the first non-option argument, but when it is\n", "   used as part of GNU libc it also permutes the argument list.  In both\n", "   cases, setting the environment variable POSIXLY_CORRECT to any value\n", "   disables permutation.\n", "\n", "   If the first character of the OPTSTRING argument to 'getopt' or\n", "   'getopt_long' is '+', both functions will stop at the first\n", "   non-option argument.  If it is '-', both functions will report\n", "   non-option arguments as arguments to the option character '\\x01'.  */\n", "\n", "#include \"getopt_int.h\"\n", "\n", "/* For communication from 'getopt' to the caller.\n", "   When 'getopt' finds an option that takes an argument,\n", "   the argument value is returned here.\n", "   Also, when 'ordering' is RETURN_IN_ORDER,\n", "   each non-option ARGV-element is returned here.  */\n", "\n", "char *optarg;\n", "\n", "/* Index in ARGV of the next element to be scanned.\n", "   This is used for communication to and from the caller\n", "   and for communication between successive calls to 'getopt'.\n", "\n", "   On entry to 'getopt', zero means this is the first call; initialize.\n", "\n", "   When 'getopt' returns -1, this is the index of the first of the\n", "   non-option elements that the caller should itself scan.\n", "\n", "   Otherwise, 'optind' communicates from one call to the next\n", "   how much of ARGV has been scanned so far.  */\n", "\n", "/* 1003.2 says this must be 1 before any call.  */\n", "int optind = 1;\n", "\n", "/* Callers store zero here to inhibit the error message\n", "   for unrecognized options.  */\n", "\n", "int opterr = 1;\n", "\n", "/* Set to an option character which was unrecognized.\n", "   This must be initialized on some systems to avoid linking in the\n", "   system's own getopt implementation.  */\n", "\n", "int optopt = '?';\n", "\n", "/* Keep a global copy of all internal members of getopt_data.  */\n", "\n", "static struct _getopt_data getopt_data;\n", "\f\n", "/* Exchange two adjacent subsequences of ARGV.\n", "   One subsequence is elements [first_nonopt,last_nonopt)\n", "   which contains all the non-options that have been skipped so far.\n", "   The other is elements [last_nonopt,optind), which contains all\n", "   the options processed since those non-options were skipped.\n", "\n", "   'first_nonopt' and 'last_nonopt' are relocated so that they describe\n", "   the new indices of the non-options in ARGV after they are moved.  */\n", "\n", "static void\n", "exchange (char **argv, struct _getopt_data *d)\n", "{\n", "  int bottom = d->__first_nonopt;\n", "  int middle = d->__last_nonopt;\n", "  int top = d->optind;\n", "  char *tem;\n", "\n", "  /* Exchange the shorter segment with the far end of the longer segment.\n", "     That puts the shorter segment into the right place.\n", "     It leaves the longer segment in the right place overall,\n", "     but it consists of two parts that need to be swapped next.  */\n", "\n", "  while (top > middle && middle > bottom)\n", "    {\n", "      if (top - middle > middle - bottom)\n", "\t{\n", "\t  /* Bottom segment is the short one.  */\n", "\t  int len = middle - bottom;\n", "\t  int i;\n", "\n", "\t  /* Swap it with the top part of the top segment.  */\n", "\t  for (i = 0; i < len; i++)\n", "\t    {\n", "\t      tem = argv[bottom + i];\n", "\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n", "\t      argv[top - (middle - bottom) + i] = tem;\n", "\t    }\n", "\t  /* Exclude the moved bottom segment from further swapping.  */\n", "\t  top -= len;\n", "\t}\n", "      else\n", "\t{\n", "\t  /* Top segment is the short one.  */\n", "\t  int len = top - middle;\n", "\t  int i;\n", "\n", "\t  /* Swap it with the bottom part of the bottom segment.  */\n", "\t  for (i = 0; i < len; i++)\n", "\t    {\n", "\t      tem = argv[bottom + i];\n", "\t      argv[bottom + i] = argv[middle + i];\n", "\t      argv[middle + i] = tem;\n", "\t    }\n", "\t  /* Exclude the moved top segment from further swapping.  */\n", "\t  bottom += len;\n", "\t}\n", "    }\n", "\n", "  /* Update records for the slots the non-options now occupy.  */\n", "\n", "  d->__first_nonopt += (d->optind - d->__last_nonopt);\n", "  d->__last_nonopt = d->optind;\n", "}\n"], "project": "grub-ieee1275-bin", "file": "getopt.pkl", "function": "exchange"}, {"comment_all": {"comment": "/* Resizes an error\n * Returns 1 if successful or -1 on error\n */", "depth": 0, "reading_ease": 68.77, "reading_grade": 6.4, "line": 121}, "comment_text": "/* Resizes an error\n * Returns 1 if successful or -1 on error\n */", "comment_tokens": ["Resizes", "an", "error", "Returns", "1", "if", "successful", "or", "-1", "on", "error"], "ccode": ["\n", "/* Resizes an error\n", " * Returns 1 if successful or -1 on error\n", " */\n", "int libcerror_error_resize(\n", "     libcerror_internal_error_t *internal_error )\n", "{\n", "\tvoid *reallocation     = NULL;\n", "\tint message_index      = 0;\n", "\tint number_of_messages = 0;\n", "\n", "\tif( internal_error == NULL )\n", "\t{\n", "\t\treturn( -1 );\n", "\t}\n", "\tmessage_index      = internal_error->number_of_messages;\n", "\tnumber_of_messages = internal_error->number_of_messages + 1;\n", "\n", "\treallocation = memory_reallocate(\n", "\t                internal_error->messages,\n", "\t                sizeof( system_character_t * ) * number_of_messages );\n", "\n", "\tif( reallocation == NULL )\n", "\t{\n", "\t\treturn( -1 );\n", "\t}\n", "\tinternal_error->messages = (system_character_t **) reallocation;\n", "\n", "\tinternal_error->messages[ message_index ] = NULL;\n", "\n", "\treallocation = memory_reallocate(\n", "\t                internal_error->sizes,\n", "\t                sizeof( size_t ) * number_of_messages );\n", "\n", "\tif( reallocation == NULL )\n", "\t{\n", "\t\treturn( -1 );\n", "\t}\n", "\tinternal_error->sizes = (size_t *) reallocation;\n", "\n", "\tinternal_error->sizes[ message_index ] = 0;\n", "\n", "\tinternal_error->number_of_messages += 1;\n", "\n", "\treturn( 1 );\n", "}\n"], "project": "libfvde-dev", "file": "libcerror_error.pkl", "function": "libcerror_error_resize"}, {"comment_all": {"comment": "// datablock->types[i] = callocx( sizeof(datablock->types[0][0]), 1, &inner );\n", "depth": 2, "reading_ease": -52.05, "reading_grade": 21.8, "line": 443}, "comment_text": "// datablock->types[i] = callocx( sizeof(datablock->types[0][0]), 1, &inner );\n", "comment_tokens": ["datablock-", ">", "types", "[", "i", "]", "=", "callocx", "(", "sizeof", "(", "datablock-", ">", "types", "[", "0", "]", "[", "0", "]", ")", ",", "1", ",", "&", "inner", ")", ";"], "ccode": ["\n", "void datablock_insert_cifvalue( DATABLOCK * datablock, char *tag,\n", "                                CIFVALUE *value, cexception_t *ex )\n", "{\n", "    cexception_t inner;\n", "    size_t i;\n", "\n", "    cexception_guard( inner ) {\n", "        i = datablock->length;\n", "        if( datablock->length + 1 > datablock->capacity ) {\n", "            datablock->tags = reallocx( datablock->tags,\n", "                                  sizeof(datablock->tags[0]) *\n", "                                  (datablock->capacity + DELTA_CAPACITY),\n", "                                  &inner );\n", "            datablock->tags[i] = NULL;\n", "            datablock->in_loop = reallocx( datablock->in_loop,\n", "                                           sizeof(datablock->in_loop[0]) *\n", "                                           (datablock->capacity + DELTA_CAPACITY),\n", "                                           &inner );\n", "            datablock->values = reallocx( datablock->values,\n", "                                    sizeof(datablock->values[0]) *\n", "                                    (datablock->capacity + DELTA_CAPACITY),\n", "                                    &inner );\n", "            datablock->values[i] = NULL;\n", "            /* datablock->types = reallocx( datablock->types,\n", "                                   sizeof(datablock->types[0]) *\n", "                                   (datablock->capacity + DELTA_CAPACITY),\n", "                                   &inner );\n", "               datablock->types[i] = NULL; */\n", "            datablock->value_lengths = reallocx( datablock->value_lengths,\n", "                                           sizeof(datablock->value_lengths[0]) *\n", "                                           (datablock->capacity + DELTA_CAPACITY),\n", "                                           &inner );\n", "            datablock->value_lengths[i] = 0;\n", "            datablock->value_capacities = reallocx( datablock->value_capacities,\n", "                                              sizeof(datablock->value_capacities[0]) *\n", "                                              (datablock->capacity + DELTA_CAPACITY),\n", "                                              &inner );\n", "            datablock->value_capacities[i] = 0;\n", "\n", "            datablock->capacity += DELTA_CAPACITY;\n", "        }\n", "        datablock->length++;\n", "\n", "        datablock->values[i] = callocx( sizeof(datablock->values[0][0]), 1, &inner );\n", "        // datablock->types[i] = callocx( sizeof(datablock->types[0][0]), 1, &inner );\n", "        datablock->value_capacities[i] = 1;\n", "        datablock->tags[i] = strdupx( tag, &inner );\n", "        datablock->in_loop[i] = -1;\n", "\n", "        if( value ) {\n", "            datablock->value_lengths[i] = 1;\n", "            datablock->values[i][0] = value;\n", "        } else {\n", "            datablock->value_lengths[i] = 0;\n", "        }\n", "    }\n", "    cexception_catch {\n", "        cexception_reraise( inner, ex );\n", "    }\n", "}\n"], "project": "libcexceptions-dev", "file": "datablock.pkl", "function": "datablock_insert_cifvalue"}, {"comment_all": {"comment": "/* ### Modified by P.Saratxaga on 29 Oct 1995 ###\n * - deleted transcodage (outtab & intab) code (now transcodage is done by\n *   strconv() function.\n * - added IGNORE_SOFTCR option from T.Tanaka.\n * - added pgpsigned. If true then text is unchanged PGP\n */", "depth": 0, "reading_ease": 71.51, "reading_grade": 5.3, "line": 0}, "comment_text": "/* ### Modified by P.Saratxaga on 29 Oct 1995 ###\n * - deleted transcodage (outtab & intab) code (now transcodage is done by\n *   strconv() function.\n * - added IGNORE_SOFTCR option from T.Tanaka.\n * - added pgpsigned. If true then text is unchanged PGP\n */", "comment_tokens": ["#", "#", "#", "Modified", "by", "P.Saratxaga", "on", "29", "Oct", "1995", "#", "#", "#", "-", "deleted", "transcodage", "(", "outtab", "&", "intab", ")", "code", "(", "now", "transcodage", "is", "done", "by", "strconv", "(", ")", "function", ".", "-", "added", "IGNORE_SOFTCR", "option", "from", "T.Tanaka", ".", "-", "added", "pgpsigned", ".", "If", "true", "then", "text", "is", "unchanged", "PGP"], "ccode": ["/* ### Modified by P.Saratxaga on 29 Oct 1995 ###\n", " * - deleted transcodage (outtab & intab) code (now transcodage is done by\n", " *   strconv() function.\n", " * - added IGNORE_SOFTCR option from T.Tanaka.\n", " * - added pgpsigned. If true then text is unchanged PGP\n", " */\n", "#include <stdio.h>\n", "#include \"bread.h\"\n", "#include \"config.h\"\n", "\n", "#ifndef IGNORE_SOFTCR\n", "extern int pgpsigned;\n", "#endif\n", "\n", "/* read short (16bit) integer in \"standart\" byte order */\n", "int iread(fp)\n", "FILE *fp;\n", "{\n", "\tunsigned char lo,hi;\n", "\n", "\tfread(&lo,1,1,fp);\n", "\tfread(&hi,1,1,fp);\n", "\treturn (hi<<8) | lo;\n", "}\n"], "project": "ifmail", "file": "bread.pkl", "function": "iread"}, {"comment_all": {"comment": "/*-\n *-----------------------------------------------------------------------\n * CompatInterrupt --\n *\tInterrupt the creation of the current target and remove it if\n *\tit ain't precious.\n *\n * Results:\n *\tNone.\n *\n * Side Effects:\n *\tThe target is removed and the process exits. If .INTERRUPT exists,\n *\tits commands are run first WITH INTERRUPTS IGNORED..\n *\n * XXX: is .PRECIOUS supposed to inhibit .INTERRUPT? I doubt it, but I've\n * left the logic alone for now. - dholland 20160826\n *\n *-----------------------------------------------------------------------\n */", "depth": 0, "reading_ease": 68.16, "reading_grade": 6.6, "line": 142}, "comment_text": "/*-\n *-----------------------------------------------------------------------\n * CompatInterrupt --\n *\tInterrupt the creation of the current target and remove it if\n *\tit ain't precious.\n *\n * Results:\n *\tNone.\n *\n * Side Effects:\n *\tThe target is removed and the process exits. If .INTERRUPT exists,\n *\tits commands are run first WITH INTERRUPTS IGNORED..\n *\n * XXX: is .PRECIOUS supposed to inhibit .INTERRUPT? I doubt it, but I've\n * left the logic alone for now. - dholland 20160826\n *\n *-----------------------------------------------------------------------\n */", "comment_tokens": ["-", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "CompatInterrupt", "--", "Interrupt", "the", "creation", "of", "the", "current", "target", "and", "remove", "it", "if", "it", "ai", "n't", "precious", ".", "Results", ":", "None", ".", "Side", "Effects", ":", "The", "target", "is", "removed", "and", "the", "process", "exits", ".", "If", ".INTERRUPT", "exists", ",", "its", "commands", "are", "run", "first", "WITH", "INTERRUPTS", "IGNORED", "..", "XXX", ":", "is", ".PRECIOUS", "supposed", "to", "inhibit", ".INTERRUPT", "?", "I", "doubt", "it", ",", "but", "I've", "left", "the", "logic", "alone", "for", "now", ".", "-", "dholland", "20160826", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "/*-\n", " *-----------------------------------------------------------------------\n", " * CompatInterrupt --\n", " *\tInterrupt the creation of the current target and remove it if\n", " *\tit ain't precious.\n", " *\n", " * Results:\n", " *\tNone.\n", " *\n", " * Side Effects:\n", " *\tThe target is removed and the process exits. If .INTERRUPT exists,\n", " *\tits commands are run first WITH INTERRUPTS IGNORED..\n", " *\n", " * XXX: is .PRECIOUS supposed to inhibit .INTERRUPT? I doubt it, but I've\n", " * left the logic alone for now. - dholland 20160826\n", " *\n", " *-----------------------------------------------------------------------\n", " */\n", "static void\n", "CompatInterrupt(int signo)\n", "{\n", "    GNode   *gn;\n", "\n", "    CompatDeleteTarget(curTarg);\n", "\n", "    if ((curTarg != NULL) && !Targ_Precious (curTarg)) {\n", "\t/*\n", "\t * Run .INTERRUPT only if hit with interrupt signal\n", "\t */\n", "\tif (signo == SIGINT) {\n", "\t    gn = Targ_FindNode(\".INTERRUPT\", TARG_NOCREATE);\n", "\t    if (gn != NULL) {\n", "\t\tCompat_Make(gn, gn);\n", "\t    }\n", "\t}\n", "    }\n", "    if (signo == SIGQUIT)\n", "\t_exit(signo);\n", "    /*\n", "     * If there is a child running, pass the signal on\n", "     * we will exist after it has exited.\n", "     */\n", "    compatSigno = signo;\n", "    if (compatChild > 0) {\n", "\tKILLPG(compatChild, signo);\n", "    } else {\n", "\tbmake_signal(signo, SIG_DFL);\n", "\tkill(myPid, signo);\n", "    }\n", "}\n"], "project": "bmake", "file": "compat.pkl", "function": "CompatInterrupt"}, {"comment_all": {"comment": "/**\n * faked force close oneshot wrapper\n */", "depth": 0, "reading_ease": 100.24, "reading_grade": 0.5, "line": 5981}, "comment_text": "/**\n * faked force close oneshot wrapper\n */", "comment_tokens": ["faked", "force", "close", "oneshot", "wrapper"], "ccode": ["\n", "/**\n", " * faked force close oneshot wrapper\n", " */\n", "static\n", "void\n", "globus_i_ftp_client_faked_force_close_callback(\n", "    void *                              user_args)\n", "{\n", "    globus_i_ftp_client_target_t *      target;\n", "    \n", "    target = (globus_i_ftp_client_target_t *) user_args;\n", "    \n", "    globus_i_ftp_client_force_close_callback(\n", "        target,\n", "        target->control_handle,\n", "        GLOBUS_SUCCESS /* don't care */,\n", "        GLOBUS_NULL);\n", "}\n"], "project": "libglobus-ftp-client-dev", "file": "globus_ftp_client_state.pkl", "function": "globus_i_ftp_client_faked_force_close_callback"}, {"comment_all": {"comment": "/*\n * Copyright \u00a9 2003 Keith Packard\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that\n * copyright notice and this permission notice appear in supporting\n * documentation, and that the name of Keith Packard not be used in\n * advertising or publicity pertaining to distribution of the software without\n * specific, written prior permission.  Keith Packard makes no\n * representations about the suitability of this software for any purpose.  It\n * is provided \"as is\" without express or implied warranty.\n *\n * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */", "depth": 0, "reading_ease": 20.39, "reading_grade": 20.8, "line": 0}, "comment_text": "/*\n * Copyright \u00a9 2003 Keith Packard\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that\n * copyright notice and this permission notice appear in supporting\n * documentation, and that the name of Keith Packard not be used in\n * advertising or publicity pertaining to distribution of the software without\n * specific, written prior permission.  Keith Packard makes no\n * representations about the suitability of this software for any purpose.  It\n * is provided \"as is\" without express or implied warranty.\n *\n * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */", "comment_tokens": ["Copyright", "\u00a9", "2003", "Keith", "Packard", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "distribute", ",", "and", "sell", "this", "software", "and", "its", "documentation", "for", "any", "purpose", "is", "hereby", "granted", "without", "fee", ",", "provided", "that", "the", "above", "copyright", "notice", "appear", "in", "all", "copies", "and", "that", "both", "that", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "supporting", "documentation", ",", "and", "that", "the", "name", "of", "Keith", "Packard", "not", "be", "used", "in", "advertising", "or", "publicity", "pertaining", "to", "distribution", "of", "the", "software", "without", "specific", ",", "written", "prior", "permission", ".", "Keith", "Packard", "makes", "no", "representations", "about", "the", "suitability", "of", "this", "software", "for", "any", "purpose", ".", "It", "is", "provided", "``", "as", "is", "''", "without", "express", "or", "implied", "warranty", ".", "KEITH", "PACKARD", "DISCLAIMS", "ALL", "WARRANTIES", "WITH", "REGARD", "TO", "THIS", "SOFTWARE", ",", "INCLUDING", "ALL", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", ",", "IN", "NO", "EVENT", "SHALL", "KEITH", "PACKARD", "BE", "LIABLE", "FOR", "ANY", "SPECIAL", ",", "INDIRECT", "OR", "CONSEQUENTIAL", "DAMAGES", "OR", "ANY", "DAMAGES", "WHATSOEVER", "RESULTING", "FROM", "LOSS", "OF", "USE", ",", "DATA", "OR", "PROFITS", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "NEGLIGENCE", "OR", "OTHER", "TORTIOUS", "ACTION", ",", "ARISING", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "USE", "OR", "PERFORMANCE", "OF", "THIS", "SOFTWARE", "."], "ccode": ["/*\n", " * Copyright \u00a9 2003 Keith Packard\n", " *\n", " * Permission to use, copy, modify, distribute, and sell this software and its\n", " * documentation for any purpose is hereby granted without fee, provided that\n", " * the above copyright notice appear in all copies and that both that\n", " * copyright notice and this permission notice appear in supporting\n", " * documentation, and that the name of Keith Packard not be used in\n", " * advertising or publicity pertaining to distribution of the software without\n", " * specific, written prior permission.  Keith Packard makes no\n", " * representations about the suitability of this software for any purpose.  It\n", " * is provided \"as is\" without express or implied warranty.\n", " *\n", " * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n", " * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n", " * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n", " * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n", " * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n", " * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n", " * PERFORMANCE OF THIS SOFTWARE.\n", " */\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "#include <limits.h>\n", "#include \"Xfixesint.h\"\n", "\n", "XserverRegion\n", "XFixesCreateRegion (Display *dpy, XRectangle *rectangles, int nrectangles)\n", "{\n", "    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n", "    xXFixesCreateRegionReq\t*req;\n", "    long    \t\t\tlen;\n", "    XserverRegion\t\tregion;\n", "\n", "    XFixesCheckExtension (dpy, info, 0);\n", "    LockDisplay (dpy);\n", "    GetReq (XFixesCreateRegion, req);\n", "    req->reqType = info->codes->major_opcode;\n", "    req->xfixesReqType = X_XFixesCreateRegion;\n", "    region = req->region = XAllocID (dpy);\n", "    len = ((long) nrectangles) << 1;\n", "    SetReqLen (req, len, len);\n", "    len <<= 2;\n", "    Data16 (dpy, (short *) rectangles, len);\n", "    UnlockDisplay (dpy);\n", "    SyncHandle();\n", "    return region;\n", "}\n"], "project": "libxfixes-dev", "file": "Region.pkl", "function": "XFixesCreateRegion"}, {"comment_all": {"comment": "/* The first word of the RNG is defined by the LSBs of the node number   */", "depth": 1, "reading_ease": 90.09, "reading_grade": 4.4, "line": 195}, "comment_text": "/* The first word of the RNG is defined by the LSBs of the node number   */", "comment_tokens": ["The", "first", "word", "of", "the", "RNG", "is", "defined", "by", "the", "LSBs", "of", "the", "node", "number"], "ccode": ["\n", "\n", "\n", "static void get_fill(uint64 *n, uint64 *r, int param, unsigned seed)\n", "{\n", "  int i,j,k,temp[2], length;\n", "  uint64 tempui;\n", "  \n", "  length = valid[param].L;\n", "  \n", "  /* Initialize the shift register with the node number XORed with seed    */\n", "  temp[1] = highword(n[0]);\n", "  temp[0] = lowword(n[0])^seed;\n", "  if (!temp[0])\n", "    temp[0] = GS0;\n", "\n", "\n", "  advance_reg(temp); /* Advance the shift register some */\n", "  advance_reg(temp);\n", "\n", "  /* The first word of the RNG is defined by the LSBs of the node number   */\n", "  and(n[0],INT_MASK,tempui);\n", "  lshift(tempui,1,r[0]);\n", "  \n", "  /* The RNG is filled with the bits of the shift register, at each time   */\n", "  /* shifted up to make room for the bits defining the canonical form;     */\n", "  /* the node number is XORed into the fill to make the generators unique  */\n", "\n", "  for (i=1;i<length-1;i++) \n", "  {\n", "    advance_reg(temp);\n", "\n", "    seti2(temp[0],temp[1],tempui);\n", "    xor(tempui,n[i],tempui);\n", "    and(tempui,INT_MASK,tempui);\n", "    lshift(tempui,1,r[i]);\n", "  }\n", "  seti(0,r[length-1]);\n", "/*      the canonical form for the LSB is instituted here                */\n", "  k = valid[param].first + valid[param].LSBS;\n", "\n", "  for (j=valid[param].first;j<k;j++)\n", "    or(r[j],ONE,r[j]);\n", "\n", "  return;\n", "}\n"], "project": "libsprng2-doc", "file": "mlfg.pkl", "function": "get_fill"}, {"comment_all": {"comment": "/* Used only when _GD_CMalloc isn't malloc(3), and always via _GD_CStrdup */", "depth": 0, "reading_ease": 35.95, "reading_grade": 10.7, "line": 153}, "comment_text": "/* Used only when _GD_CMalloc isn't malloc(3), and always via _GD_CStrdup */", "comment_tokens": ["Used", "only", "when", "_GD_CMalloc", "is", "n't", "malloc", "(", "3", ")", ",", "and", "always", "via", "_GD_CStrdup"], "ccode": ["\n", "/* Used only when _GD_CMalloc isn't malloc(3), and always via _GD_CStrdup */\n", "static __attribute_malloc__ char *_GD_CallerStrdup(const char *str)\n", "{\n", "  char *ptr;\n", "  size_t len;\n", "  dtrace(\"%s\", str);\n", "\n", "  len = strlen(str) + 1;\n", "  ptr = _GD_CMalloc(len);\n", "  if (ptr)\n", "    memcpy(ptr, str, len);\n", "\n", "  dreturn(\"%p\", ptr);\n", "  return ptr;\n", "}\n"], "project": "libgetdata-dev", "file": "globals.pkl", "function": "_GD_CallerStrdup"}, {"comment_all": {"comment": "/* an entry for this key already exists in the cache */", "depth": 2, "reading_ease": 86.71, "reading_grade": 3.7, "line": 122}, "comment_text": "/* an entry for this key already exists in the cache */", "comment_tokens": ["an", "entry", "for", "this", "key", "already", "exists", "in", "the", "cache"], "ccode": ["\n", "PyObject* pysqlite_cache_get(pysqlite_Cache* self, PyObject* key)\n", "{\n", "    pysqlite_Node* node;\n", "    pysqlite_Node* ptr;\n", "    PyObject* data;\n", "\n", "    node = (pysqlite_Node*)PyDict_GetItemWithError(self->mapping, key);\n", "    if (node) {\n", "        /* an entry for this key already exists in the cache */\n", "\n", "        /* increase usage counter of the node found */\n", "        if (node->count < LONG_MAX) {\n", "            node->count++;\n", "        }\n", "\n", "        /* if necessary, reorder entries in the cache by swapping positions */\n", "        if (node->prev && node->count > node->prev->count) {\n", "            ptr = node->prev;\n", "\n", "            while (ptr->prev && node->count > ptr->prev->count) {\n", "                ptr = ptr->prev;\n", "            }\n", "\n", "            if (node->next) {\n", "                node->next->prev = node->prev;\n", "            } else {\n", "                self->last = node->prev;\n", "            }\n", "            if (node->prev) {\n", "                node->prev->next = node->next;\n", "            }\n", "            if (ptr->prev) {\n", "                ptr->prev->next = node;\n", "            } else {\n", "                self->first = node;\n", "            }\n", "\n", "            node->next = ptr;\n", "            node->prev = ptr->prev;\n", "            if (!node->prev) {\n", "                self->first = node;\n", "            }\n", "            ptr->prev = node;\n", "        }\n", "    }\n", "    else if (PyErr_Occurred()) {\n", "        return NULL;\n", "    }\n", "    else {\n", "        /* There is no entry for this key in the cache, yet. We'll insert a new\n", "         * entry in the cache, and make space if necessary by throwing the\n", "         * least used item out of the cache. */\n", "\n", "        if (PyDict_GET_SIZE(self->mapping) == self->size) {\n", "            if (self->last) {\n", "                node = self->last;\n", "\n", "                if (PyDict_DelItem(self->mapping, self->last->key) != 0) {\n", "                    return NULL;\n", "                }\n", "\n", "                if (node->prev) {\n", "                    node->prev->next = NULL;\n", "                }\n", "                self->last = node->prev;\n", "                node->prev = NULL;\n", "\n", "                Py_DECREF(node);\n", "            }\n", "        }\n", "\n", "        /* We cannot replace this by PyObject_CallOneArg() since\n", "         * PyObject_CallFunction() has a special case when using a\n", "         * single tuple as argument. */\n", "        data = PyObject_CallFunction(self->factory, \"O\", key);\n", "\n", "        if (!data) {\n", "            return NULL;\n", "        }\n", "\n", "        node = pysqlite_new_node(key, data);\n", "        if (!node) {\n", "            return NULL;\n", "        }\n", "        node->prev = self->last;\n", "\n", "        Py_DECREF(data);\n", "\n", "        if (PyDict_SetItem(self->mapping, key, (PyObject*)node) != 0) {\n", "            Py_DECREF(node);\n", "            return NULL;\n", "        }\n", "\n", "        if (self->last) {\n", "            self->last->next = node;\n", "        } else {\n", "            self->first = node;\n", "        }\n", "        self->last = node;\n", "    }\n", "\n", "    Py_INCREF(node->data);\n", "    return node->data;\n", "}\n"], "project": "python3.9-venv", "file": "cache.pkl", "function": "pysqlite_cache_get"}, {"comment_all": {"comment": "/**\n * Command list:\n * See https://www.meade.com/support/LX200CommandSet.pdf\n * and https://www.meade.com/support/TelescopeProtocol_2010-10.pdf for newer\n * Firmware Versions\n *\n * Not the full set of available commands is used, the list here shows\n * only the commands of the telescope used by hamlib\n *\n * All used Commands are supportet by Meade Telescopes with LX-200 protocol\n * (e.g. DS-2000 with Autostar) and should also work with the LX16 and\n * LX200GPS.\n * Tested only with DS-2000 and AutoStar 494 together with Meade 506 i2c to\n * Serial cable. But should also work with other AutoStars and the regular\n * Serial Cable.\n *\n * | Command     | Atribute | Return value | Description              |\n * --------------------------------------------------------------------\n * | :Me#        | -        | -            | Moves telescope east     |\n * | :Mn#        | -        | -            | Moves telescope north    |\n * | :Ms#        | -        | -            | Moves telescope south    |\n * | :Mw#        | -        | -            | Moves telescope west     |\n * | :AL#        | -        | -            | Set to Land mode         |\n * | :Sz DDD*MM# | D,M      | 1' == OK     | Set Target azimuth       |\n * | :SasDD*MM#  | s,D,M    | 1' == OK     | Set Target elevation     |\n * | :Mw#        | -        | -            | Moves telescope west     |\n * | :Q#         | -        | -            | Halt all slewing         |\n * | :SoDD#      | D        | '1' == OK    | Set minimal elevation    |\n * | :ShDD#      | D        | '1' == OK    | Set maximal elevation    |\n * | :MA#        | -        | '0' == OK    | GoTo Target              |\n * | :D#         | -        | 0x7F == YES  | Check if active movement |\n *\n */", "depth": 0, "reading_ease": 48.54, "reading_grade": 12.1, "line": 53}, "comment_text": "/**\n * Command list:\n * See https://www.meade.com/support/LX200CommandSet.pdf\n * and https://www.meade.com/support/TelescopeProtocol_2010-10.pdf for newer\n * Firmware Versions\n *\n * Not the full set of available commands is used, the list here shows\n * only the commands of the telescope used by hamlib\n *\n * All used Commands are supportet by Meade Telescopes with LX-200 protocol\n * (e.g. DS-2000 with Autostar) and should also work with the LX16 and\n * LX200GPS.\n * Tested only with DS-2000 and AutoStar 494 together with Meade 506 i2c to\n * Serial cable. But should also work with other AutoStars and the regular\n * Serial Cable.\n *\n * | Command     | Atribute | Return value | Description              |\n * --------------------------------------------------------------------\n * | :Me#        | -        | -            | Moves telescope east     |\n * | :Mn#        | -        | -            | Moves telescope north    |\n * | :Ms#        | -        | -            | Moves telescope south    |\n * | :Mw#        | -        | -            | Moves telescope west     |\n * | :AL#        | -        | -            | Set to Land mode         |\n * | :Sz DDD*MM# | D,M      | 1' == OK     | Set Target azimuth       |\n * | :SasDD*MM#  | s,D,M    | 1' == OK     | Set Target elevation     |\n * | :Mw#        | -        | -            | Moves telescope west     |\n * | :Q#         | -        | -            | Halt all slewing         |\n * | :SoDD#      | D        | '1' == OK    | Set minimal elevation    |\n * | :ShDD#      | D        | '1' == OK    | Set maximal elevation    |\n * | :MA#        | -        | '0' == OK    | GoTo Target              |\n * | :D#         | -        | 0x7F == YES  | Check if active movement |\n *\n */", "comment_tokens": ["Command", "list", ":", "See", "https", ":", "www.meade.comsupportLX200CommandSet.pdf", "and", "https", ":", "www.meade.comsupportTelescopeProtocol_2010-10.pdf", "for", "newer", "Firmware", "Versions", "Not", "the", "full", "set", "of", "available", "commands", "is", "used", ",", "the", "list", "here", "shows", "only", "the", "commands", "of", "the", "telescope", "used", "by", "hamlib", "All", "used", "Commands", "are", "supportet", "by", "Meade", "Telescopes", "with", "LX-200", "protocol", "(", "e.g", ".", "DS-2000", "with", "Autostar", ")", "and", "should", "also", "work", "with", "the", "LX16", "and", "LX200GPS", ".", "Tested", "only", "with", "DS-2000", "and", "AutoStar", "494", "together", "with", "Meade", "506", "i2c", "to", "Serial", "cable", ".", "But", "should", "also", "work", "with", "other", "AutoStars", "and", "the", "regular", "Serial", "Cable", ".", "|", "Command", "|", "Atribute", "|", "Return", "value", "|", "Description", "|", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "|", ":", "Me", "#", "|", "-", "|", "-", "|", "Moves", "telescope", "east", "|", "|", ":", "Mn", "#", "|", "-", "|", "-", "|", "Moves", "telescope", "north", "|", "|", ":", "Ms", "#", "|", "-", "|", "-", "|", "Moves", "telescope", "south", "|", "|", ":", "Mw", "#", "|", "-", "|", "-", "|", "Moves", "telescope", "west", "|", "|", ":", "AL", "#", "|", "-", "|", "-", "|", "Set", "to", "Land", "mode", "|", "|", ":", "Sz", "DDDMM", "#", "|", "D", ",", "M", "|", "1", "'", "==", "OK", "|", "Set", "Target", "azimuth", "|", "|", ":", "SasDDMM", "#", "|", "s", ",", "D", ",", "M", "|", "1", "'", "==", "OK", "|", "Set", "Target", "elevation", "|", "|", ":", "Mw", "#", "|", "-", "|", "-", "|", "Moves", "telescope", "west", "|", "|", ":", "Q", "#", "|", "-", "|", "-", "|", "Halt", "all", "slewing", "|", "|", ":", "SoDD", "#", "|", "D", "|", "'", "1", "'", "==", "OK", "|", "Set", "minimal", "elevation", "|", "|", ":", "ShDD", "#", "|", "D", "|", "'", "1", "'", "==", "OK", "|", "Set", "maximal", "elevation", "|", "|", ":", "MA", "#", "|", "-", "|", "'", "0", "'", "==", "OK", "|", "GoTo", "Target", "|", "|", ":", "D", "#", "|", "-", "|", "0x7F", "==", "YES", "|", "Check", "if", "active", "movement", "|"], "ccode": ["\n", "/**\n", " * Command list:\n", " * See https://www.meade.com/support/LX200CommandSet.pdf\n", " * and https://www.meade.com/support/TelescopeProtocol_2010-10.pdf for newer\n", " * Firmware Versions\n", " *\n", " * Not the full set of available commands is used, the list here shows\n", " * only the commands of the telescope used by hamlib\n", " *\n", " * All used Commands are supportet by Meade Telescopes with LX-200 protocol\n", " * (e.g. DS-2000 with Autostar) and should also work with the LX16 and\n", " * LX200GPS.\n", " * Tested only with DS-2000 and AutoStar 494 together with Meade 506 i2c to\n", " * Serial cable. But should also work with other AutoStars and the regular\n", " * Serial Cable.\n", " *\n", " * | Command     | Atribute | Return value | Description              |\n", " * --------------------------------------------------------------------\n", " * | :Me#        | -        | -            | Moves telescope east     |\n", " * | :Mn#        | -        | -            | Moves telescope north    |\n", " * | :Ms#        | -        | -            | Moves telescope south    |\n", " * | :Mw#        | -        | -            | Moves telescope west     |\n", " * | :AL#        | -        | -            | Set to Land mode         |\n", " * | :Sz DDD*MM# | D,M      | 1' == OK     | Set Target azimuth       |\n", " * | :SasDD*MM#  | s,D,M    | 1' == OK     | Set Target elevation     |\n", " * | :Mw#        | -        | -            | Moves telescope west     |\n", " * | :Q#         | -        | -            | Halt all slewing         |\n", " * | :SoDD#      | D        | '1' == OK    | Set minimal elevation    |\n", " * | :ShDD#      | D        | '1' == OK    | Set maximal elevation    |\n", " * | :MA#        | -        | '0' == OK    | GoTo Target              |\n", " * | :D#         | -        | 0x7F == YES  | Check if active movement |\n", " *\n", " */\n", "\n", "/**\n", " * meade_transaction\n", " *\n", " * cmdstr - Command to be sent to the rig.\n", " * data - Buffer for reply string.  Can be NULL, indicating that no reply is\n", " *        is needed, but answer will still be read.\n", " * data_len - in: Size of buffer. It is the caller's responsibily to provide\n", " *            a large enough buffer for all possible replies for a command.\n", " *\n", " * returns:\n", " *   RIG_OK  -  if no error occurred.\n", " *   RIG_EIO  -  if an I/O error occurred while sending/receiving data.\n", " *   RIG_ETIMEOUT  -  if timeout expires without any characters received.\n", " */\n", "static int meade_transaction (ROT *rot, const char *cmdstr,\n", "                                    char *data, size_t *data_len, size_t expected_return_length)\n", "{\n", "  struct rot_state *rs;\n", "  int return_value;\n", "  int retry_read = 0;\n", "\n", "  rs = &rot->state;\n", "\n", "  while(1) {\n", "    serial_flush(&rs->rotport);\n", "\n", "    if (cmdstr) {\n", "      return_value = write_block(&rs->rotport, cmdstr, strlen(cmdstr));\n", "      if (return_value != RIG_OK) {\n", "        return return_value;\n", "      }\n", "    }\n", "\n", "    /* Not all commands will send a return value, so use data = NULL if no\n", "       return value is expected, Strings end with '#' */\n", "    if (data != NULL) {\n", "      memset(data,0,BUFSIZE);\n", "      *data_len = read_string(&rs->rotport, data, expected_return_length + 1, \"\\n\", strlen(\"\\n\"));\n", "      if (*data_len < 0) {\n", "        if (retry_read++ >= rot->state.rotport.retry) {\n", "          return RIG_ETIMEOUT;\n", "        }\n", "      }\n", "      else {\n", "        return RIG_OK;\n", "      }\n", "    }\n", "    else {\n", "      return RIG_OK;\n", "    }\n", "  }\n", "}\n"], "project": "libhamlib-doc", "file": "meade.pkl", "function": "meade_transaction"}, {"comment_all": {"comment": "/**\n * itdb_sysinfo_properties_get_photo_formats:\n * @props: a #SysInfoIpodProperties structure\n *\n * Returns: a #GList of #Itdb_ArtworkFormat describing the photo formats\n * supported by the iPod described in @props. The returned list must not be\n * modified nor freed.\n */", "depth": 0, "reading_ease": 13.95, "reading_grade": 15.0, "line": 654}, "comment_text": "/**\n * itdb_sysinfo_properties_get_photo_formats:\n * @props: a #SysInfoIpodProperties structure\n *\n * Returns: a #GList of #Itdb_ArtworkFormat describing the photo formats\n * supported by the iPod described in @props. The returned list must not be\n * modified nor freed.\n */", "comment_tokens": ["itdb_sysinfo_properties_get_photo_formats", ":", "@", "props", ":", "a", "#", "SysInfoIpodProperties", "structure", "Returns", ":", "a", "#", "GList", "of", "#", "Itdb_ArtworkFormat", "describing", "the", "photo", "formats", "supported", "by", "the", "iPod", "described", "in", "@", "props", ".", "The", "returned", "list", "must", "not", "be", "modified", "nor", "freed", "."], "ccode": ["\n", "/**\n", " * itdb_sysinfo_properties_get_photo_formats:\n", " * @props: a #SysInfoIpodProperties structure\n", " *\n", " * Returns: a #GList of #Itdb_ArtworkFormat describing the photo formats\n", " * supported by the iPod described in @props. The returned list must not be\n", " * modified nor freed.\n", " */\n", "const GList *\n", "itdb_sysinfo_properties_get_photo_formats (const SysInfoIpodProperties *props)\n", "{\n", "    g_return_val_if_fail (props != NULL, NULL);\n", "    return props->photo_formats;\n", "}\n"], "project": "libgpod4", "file": "itdb_sysinfo_extended_parser.pkl", "function": "itdb_sysinfo_properties_get_photo_formats"}, {"comment_all": {"comment": "/* I've added st_size and st_blocks here.\n     Don't know why they were missing -- joost*/", "depth": 1, "reading_ease": 98.72, "reading_grade": 1.1, "line": 357}, "comment_text": "/* I've added st_size and st_blocks here.\n     Don't know why they were missing -- joost*/", "comment_tokens": ["I", "'ve", "added", "st_size", "and", "st_blocks", "here", ".", "Do", "n't", "know", "why", "they", "were", "missing", "--", "joost"], "ccode": ["\n", "\n", "#ifdef _LARGEFILE_SOURCE\n", "\n", "void stat64from32(struct stat64 *s64, const struct stat *s32)\n", "{\n", "  /* I've added st_size and st_blocks here.\n", "     Don't know why they were missing -- joost*/\n", "   s64->st_dev = s32->st_dev;\n", "   s64->st_ino = s32->st_ino;\n", "   s64->st_mode = s32->st_mode;\n", "   s64->st_nlink = s32->st_nlink;\n", "   s64->st_uid = s32->st_uid;\n", "   s64->st_gid = s32->st_gid;\n", "   s64->st_rdev = s32->st_rdev;\n", "   s64->st_size = s32->st_size;\n", "   s64->st_blksize = s32->st_blksize;\n", "   s64->st_blocks = s32->st_blocks;\n", "   s64->st_atime = s32->st_atime;\n", "   s64->st_mtime = s32->st_mtime;\n", "   s64->st_ctime = s32->st_ctime;\n", "}\n"], "project": "libfakeroot", "file": "communicate.pkl", "function": "stat64from32"}, {"comment_all": {"comment": "// !defined(__WIN32__)\n", "depth": 1, "reading_ease": -47.99, "reading_grade": 20.2, "line": 175}, "comment_text": "// !defined(__WIN32__)\n", "comment_tokens": ["!", "defined", "(", "__WIN32__", ")"], "ccode": ["\n", "\n", "void abort_interpreter(int exit_code, z_ucs *error_message)\n", "{\n", "#ifdef THROW_SIGFAULT_ON_ERROR\n", "  int x;\n", "#endif // THROW_SIGFAULT_ON_ERROR\n", "\n", "  deactivate_signal_handlers();\n", "\n", "#ifdef ENABLE_DEBUGGER\n", "  streams_latin1_output(\"\\nAborting due to:\\n\");\n", "  streams_z_ucs_output(error_message);\n", "  streams_latin1_output(\"\\n\");\n", "  debugger();\n", "  debugger_interpreter_stopped();\n", "#endif // ENABLE_DEBUGGER\n", "\n", "  TRACE_LOG(\"Aborting interpreter.\\n\");\n", "  if (error_message != NULL)\n", "  {\n", "    TRACE_LOG(\"Abort with exit message \\\"\");\n", "    TRACE_LOG_Z_UCS(error_message);\n", "    TRACE_LOG(\"\\\"\\n\");\n", "  }\n", "\n", "  if (active_sound_interface != NULL)\n", "  {\n", "    TRACE_LOG(\"Sound interface at %p.\\n\", active_sound_interface);\n", "    TRACE_LOG(\"Closing sound interface.\\n\");\n", "    active_sound_interface->close_sound();\n", "  }\n", "\n", "  TRACE_LOG(\"Closing streams.\\n\");\n", "  close_streams(error_message);\n", "\n", "  // From the OpenGroup: The value of status may be 0, EXIT_SUCCESS,\n", "  // EXIT_FAILURE, [CX] [Option Start]  or any other value, though only\n", "  // the least significant 8 bits (that is, status & 0377) shall be\n", "  // available to a waiting parent process. [Option End]\n", "  //  -> Thus, we print the exit code seperately.\n", "  TRACE_LOG(\"Output exit code.\\n\");\n", "  //fprintf(stderr, \"Exit code: %d.\\n\", exit_code);\n", "\n", "  //(void)signal(SIGSEGV, SIG_DFL);\n", "\n", "  TRACE_LOG(\"Exit.\\n\");\n", "\n", "#ifdef THROW_SIGFAULT_ON_ERROR\n", "  x = *((int*)NULL);\n", "#endif\n", "\n", "#if defined(__WIN32__)\n", "  exit_code = 0;\n", "#endif // !defined(__WIN32__)\n", "  exit(exit_code);\n", "}\n"], "project": "fizmo-common", "file": "misc.pkl", "function": "abort_interpreter"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  The function that is called when the heightType XSD type is seen\n\n  int heightType_function Returns 0 if no error occured or something else otherwise.\n\n  const char *_tag_ Set to the name of the element tag that triggered this function call.\n\n  int _type_ Set to XMLPARSE_TAG_START at the start of a tag and/or XMLPARSE_TAG_END at the end of a tag.\n\n  const char *limit The contents of the 'limit' attribute (or NULL if not defined).\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 69.82, "reading_grade": 8.1, "line": 449}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  The function that is called when the heightType XSD type is seen\n\n  int heightType_function Returns 0 if no error occured or something else otherwise.\n\n  const char *_tag_ Set to the name of the element tag that triggered this function call.\n\n  int _type_ Set to XMLPARSE_TAG_START at the start of a tag and/or XMLPARSE_TAG_END at the end of a tag.\n\n  const char *limit The contents of the 'limit' attribute (or NULL if not defined).\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "The", "function", "that", "is", "called", "when", "the", "heightType", "XSD", "type", "is", "seen", "int", "heightType_function", "Returns", "0", "if", "no", "error", "occured", "or", "something", "else", "otherwise", ".", "const", "char", "_tag_", "Set", "to", "the", "name", "of", "the", "element", "tag", "that", "triggered", "this", "function", "call", ".", "int", "_type_", "Set", "to", "XMLPARSE_TAG_START", "at", "the", "start", "of", "a", "tag", "andor", "XMLPARSE_TAG_END", "at", "the", "end", "of", "a", "tag", ".", "const", "char", "limit", "The", "contents", "of", "the", "'limit", "'", "attribute", "(", "or", "NULL", "if", "not", "defined", ")", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  The function that is called when the heightType XSD type is seen\n", "\n", "  int heightType_function Returns 0 if no error occured or something else otherwise.\n", "\n", "  const char *_tag_ Set to the name of the element tag that triggered this function call.\n", "\n", "  int _type_ Set to XMLPARSE_TAG_START at the start of a tag and/or XMLPARSE_TAG_END at the end of a tag.\n", "\n", "  const char *limit The contents of the 'limit' attribute (or NULL if not defined).\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "static int heightType_function(const char *_tag_,int _type_,const char *limit)\n", "{\n", " printf(\"<%s%s\",(_type_==XMLPARSE_TAG_END)?\"/\":\"\",_tag_);\n", " if(limit) printf(\" limit=\\\"%s\\\"\",ParseXML_Encode_Safe_XML(limit));\n", " printf(\"%s>\\n\",(_type_==(XMLPARSE_TAG_START|XMLPARSE_TAG_END))?\" /\":\"\");\n", " return(0);\n", "}\n"], "project": "libroutino-slim0", "file": "routino-profiles-skeleton.pkl", "function": "heightType_function"}, {"comment_all": {"comment": "/* only remove the jobfam session dir if we are the\n     * local daemon and we are finalizing our own session dir */", "depth": 1, "reading_ease": 59.64, "reading_grade": 9.9, "line": 505}, "comment_text": "/* only remove the jobfam session dir if we are the\n     * local daemon and we are finalizing our own session dir */", "comment_tokens": ["only", "remove", "the", "jobfam", "session", "dir", "if", "we", "are", "the", "local", "daemon", "and", "we", "are", "finalizing", "our", "own", "session", "dir"], "ccode": ["\n", "\n", "int\n", "orte_session_dir_finalize(orte_process_name_t *proc)\n", "{\n", "    if (!orte_create_session_dirs || orte_process_info.rm_session_dirs ) {\n", "        /* we haven't created them or RM will clean them up for us*/\n", "        return ORTE_SUCCESS;\n", "    }\n", "\n", "    if (NULL == orte_process_info.job_session_dir ||\n", "        NULL == orte_process_info.proc_session_dir) {\n", "        /* this should never happen - it means we are calling\n", "         * cleanup *before* properly setting up the session\n", "         * dir system. This leaves open the possibility of\n", "         * accidentally removing directories we shouldn't\n", "         * touch\n", "         */\n", "        return ORTE_ERR_NOT_INITIALIZED;\n", "    }\n", "\n", "    opal_os_dirpath_destroy(orte_process_info.proc_session_dir,\n", "                            false, orte_dir_check_file);\n", "\n", "    if (opal_os_dirpath_is_empty(orte_process_info.proc_session_dir)) {\n", "        if (orte_debug_flag) {\n", "            opal_output(0, \"sess_dir_finalize: found proc session dir empty - deleting\");\n", "        }\n", "        rmdir(orte_process_info.proc_session_dir);\n", "    } else {\n", "        if (orte_debug_flag) {\n", "            if (OPAL_ERR_NOT_FOUND ==\n", "                    opal_os_dirpath_access(orte_process_info.proc_session_dir, 0)) {\n", "                opal_output(0, \"sess_dir_finalize: proc session dir does not exist\");\n", "            } else {\n", "                opal_output(0, \"sess_dir_finalize: proc session dir not empty - leaving\");\n", "            }\n", "        }\n", "    }\n", "\n", "    /* special case - if a daemon is colocated with mpirun,\n", "     * then we let mpirun do the rest to avoid a race\n", "     * condition. this scenario always results in the rank=1\n", "     * daemon colocated with mpirun */\n", "    if (orte_ras_base.launch_orted_on_hn &&\n", "        ORTE_PROC_IS_DAEMON &&\n", "        1 == ORTE_PROC_MY_NAME->vpid) {\n", "        return ORTE_SUCCESS;\n", "    }\n", "\n", "    opal_os_dirpath_destroy(orte_process_info.job_session_dir,\n", "                            false, orte_dir_check_file);\n", "\n", "    /* only remove the jobfam session dir if we are the\n", "     * local daemon and we are finalizing our own session dir */\n", "    if ((ORTE_PROC_IS_HNP || ORTE_PROC_IS_DAEMON) &&\n", "        (ORTE_PROC_MY_NAME == proc)) {\n", "        opal_os_dirpath_destroy(orte_process_info.jobfam_session_dir,\n", "                                false, orte_dir_check_file);\n", "    }\n", "\n", "    if( NULL != orte_process_info.top_session_dir ){\n", "        opal_os_dirpath_destroy(orte_process_info.top_session_dir,\n", "                                false, orte_dir_check_file);\n", "    }\n", "\n", "    if (opal_os_dirpath_is_empty(orte_process_info.job_session_dir)) {\n", "        if (orte_debug_flag) {\n", "            opal_output(0, \"sess_dir_finalize: found job session dir empty - deleting\");\n", "        }\n", "        rmdir(orte_process_info.job_session_dir);\n", "    } else {\n", "        if (orte_debug_flag) {\n", "            if (OPAL_ERR_NOT_FOUND ==\n", "                    opal_os_dirpath_access(orte_process_info.job_session_dir, 0)) {\n", "                opal_output(0, \"sess_dir_finalize: job session dir does not exist\");\n", "            } else {\n", "                opal_output(0, \"sess_dir_finalize: job session dir not empty - leaving\");\n", "            }\n", "        }\n", "    }\n", "\n", "    if (opal_os_dirpath_is_empty(orte_process_info.jobfam_session_dir)) {\n", "        if (orte_debug_flag) {\n", "            opal_output(0, \"sess_dir_finalize: found jobfam session dir empty - deleting\");\n", "        }\n", "        rmdir(orte_process_info.jobfam_session_dir);\n", "    } else {\n", "        if (orte_debug_flag) {\n", "            if (OPAL_ERR_NOT_FOUND ==\n", "                    opal_os_dirpath_access(orte_process_info.jobfam_session_dir, 0)) {\n", "                opal_output(0, \"sess_dir_finalize: jobfam session dir does not exist\");\n", "            } else {\n", "                opal_output(0, \"sess_dir_finalize: jobfam session dir not empty - leaving\");\n", "            }\n", "        }\n", "    }\n", "\n", "    if (opal_os_dirpath_is_empty(orte_process_info.jobfam_session_dir)) {\n", "        if (orte_debug_flag) {\n", "            opal_output(0, \"sess_dir_finalize: found jobfam session dir empty - deleting\");\n", "        }\n", "        rmdir(orte_process_info.jobfam_session_dir);\n", "    } else {\n", "        if (orte_debug_flag) {\n", "            if (OPAL_ERR_NOT_FOUND ==\n", "                    opal_os_dirpath_access(orte_process_info.jobfam_session_dir, 0)) {\n", "                opal_output(0, \"sess_dir_finalize: jobfam session dir does not exist\");\n", "            } else {\n", "                opal_output(0, \"sess_dir_finalize: jobfam session dir not empty - leaving\");\n", "            }\n", "        }\n", "    }\n", "\n", "    if (NULL != orte_process_info.top_session_dir) {\n", "        if (opal_os_dirpath_is_empty(orte_process_info.top_session_dir)) {\n", "            if (orte_debug_flag) {\n", "                opal_output(0, \"sess_dir_finalize: found top session dir empty - deleting\");\n", "            }\n", "            rmdir(orte_process_info.top_session_dir);\n", "        } else {\n", "            if (orte_debug_flag) {\n", "                if (OPAL_ERR_NOT_FOUND ==\n", "                        opal_os_dirpath_access(orte_process_info.top_session_dir, 0)) {\n", "                    opal_output(0, \"sess_dir_finalize: top session dir does not exist\");\n", "                } else {\n", "                    opal_output(0, \"sess_dir_finalize: top session dir not empty - leaving\");\n", "                }\n", "            }\n", "        }\n", "    }\n", "\n", "    return ORTE_SUCCESS;\n", "}\n"], "project": "openmpi-bin", "file": "session_dir.pkl", "function": "orte_session_dir_finalize"}, {"comment_all": {"comment": "/*\n * Small jpeg decoder library - testing application\n *\n * Copyright (c) 2006, Luc Saillard <luc@saillard.org>\n * Copyright (c) 2012 Intel Corporation.\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * - Redistributions of source code must retain the above copyright notice,\n *  this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation\n *  and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of its contributors may be\n *  used to endorse or promote products derived from this software without\n *  specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n */", "depth": 0, "reading_ease": 25.12, "reading_grade": 17.0, "line": 0}, "comment_text": "/*\n * Small jpeg decoder library - testing application\n *\n * Copyright (c) 2006, Luc Saillard <luc@saillard.org>\n * Copyright (c) 2012 Intel Corporation.\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * - Redistributions of source code must retain the above copyright notice,\n *  this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation\n *  and/or other materials provided with the distribution.\n *\n * - Neither the name of the author nor the names of its contributors may be\n *  used to endorse or promote products derived from this software without\n *  specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n */", "comment_tokens": ["Small", "jpeg", "decoder", "library", "-", "testing", "application", "Copyright", "(", "c", ")", "2006", ",", "Luc", "Saillard", "<", "luc", "@", "saillard.org", ">", "Copyright", "(", "c", ")", "2012", "Intel", "Corporation", ".", "All", "rights", "reserved", ".", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "-", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "-", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "-", "Neither", "the", "name", "of", "the", "author", "nor", "the", "names", "of", "its", "contributors", "may", "be", "used", "to", "endorse", "or", "promote", "products", "derived", "from", "this", "software", "without", "specific", "prior", "written", "permission", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "COPYRIGHT", "HOLDERS", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "COPYRIGHT", "OWNER", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", "."], "ccode": ["/*\n", " * Small jpeg decoder library - testing application\n", " *\n", " * Copyright (c) 2006, Luc Saillard <luc@saillard.org>\n", " * Copyright (c) 2012 Intel Corporation.\n", " * All rights reserved.\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions are met:\n", " * \n", " * - Redistributions of source code must retain the above copyright notice,\n", " *  this list of conditions and the following disclaimer.\n", " *\n", " * - Redistributions in binary form must reproduce the above copyright notice,\n", " *  this list of conditions and the following disclaimer in the documentation\n", " *  and/or other materials provided with the distribution.\n", " *\n", " * - Neither the name of the author nor the names of its contributors may be\n", " *  used to endorse or promote products derived from this software without\n", " *  specific prior written permission.\n", " * \n", " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n", " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n", " * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n", " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n", " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n", " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n", " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n", " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n", " * POSSIBILITY OF SUCH DAMAGE.\n", " *\n", " */\n", "\n", "#include \"tinyjpeg.h\"\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include <time.h>\n", "#include \"va_display.h\"\n", "\n", "static void exitmessage(const char *message) __attribute__((noreturn));\n", "static void exitmessage(const char *message)\n", "{\n", "  printf(\"%s\\n\", message);\n", "  exit(0);\n", "}\n"], "project": "vainfo", "file": "loadjpeg.pkl", "function": "exitmessage"}, {"comment_all": {"comment": "/* (C) Mike Henderson <mghenderson@lanl.gov>. \n *\n *  I've converted to glib types, removed unused variables, and piped the whole\n *  thing through indent.\n *\n *  josh buhl <jbuhl@users.sourceforge.net> \n */", "depth": 0, "reading_ease": 55.61, "reading_grade": 7.3, "line": 0}, "comment_text": "/* (C) Mike Henderson <mghenderson@lanl.gov>. \n *\n *  I've converted to glib types, removed unused variables, and piped the whole\n *  thing through indent.\n *\n *  josh buhl <jbuhl@users.sourceforge.net> \n */", "comment_tokens": ["(", "C", ")", "Mike", "Henderson", "<", "mghenderson", "@", "lanl.gov", ">", ".", "I", "'ve", "converted", "to", "glib", "types", ",", "removed", "unused", "variables", ",", "and", "piped", "the", "whole", "thing", "through", "indent", ".", "josh", "buhl", "<", "jbuhl", "@", "users.sourceforge.net", ">"], "ccode": ["/* (C) Mike Henderson <mghenderson@lanl.gov>. \n", " *\n", " *  I've converted to glib types, removed unused variables, and piped the whole\n", " *  thing through indent.\n", " *\n", " *  josh buhl <jbuhl@users.sourceforge.net> \n", " */\n", "\n", "#include \"Moon.h\"\n", "#include \"MoonRise.h\"\n", "\n", "void\n", "UTTohhmm(gdouble UT, gint * h, gint * m)\n", "{\n", "\tif (UT < 0.0) {\n", "\t\t*h = -1.0;\n", "\t\t*m = -1.0;\n", "\t} else {\n", "\t\t*h = (gint) UT;\n", "\t\t*m = (gint) ((UT - (gdouble) (*h)) * 60.0 + 0.5);\n", "\t\tif (*m == 60) {\n", "\t\t\t/* \n", "\t\t\t *  If it was 23:60 this should become 24:00\n", "\t\t\t *  I prefer this designation to 00:00. So dont reset h to 0 when it goes above 24.\n", "\t\t\t */\n", "\t\t\t*h += 1;\n", "\t\t\t*m = 0;\n", "\t\t}\n", "\t}\n", "\n", "}\n"], "project": "gkrellmoon", "file": "MoonRise.pkl", "function": "UTTohhmm"}, {"comment_all": {"comment": "/* Suse Linux does not handle multiple users with UID=0 well */", "depth": 1, "reading_ease": 78.25, "reading_grade": 4.8, "line": 146}, "comment_text": "/* Suse Linux does not handle multiple users with UID=0 well */", "comment_tokens": ["Suse", "Linux", "does", "not", "handle", "multiple", "users", "with", "UID=0", "well"], "ccode": ["\n", "/*\n", " * Return an xmalloc'd string, or null on error.\n", " * Caller must free eventually.\n", " */\n", "char *uid_to_string_or_null(uid_t uid)\n", "{\n", "\tstruct passwd pwd, *result;\n", "\tchar buffer[PW_BUF_SIZE];\n", "\tchar *ustring = NULL;\n", "\tint rc;\n", "\n", "\t/* Suse Linux does not handle multiple users with UID=0 well */\n", "\tif (uid == 0)\n", "\t\treturn xstrdup(\"root\");\n", "\n", "\trc = slurm_getpwuid_r(uid, &pwd, buffer, PW_BUF_SIZE, &result);\n", "\tif (result && (rc == 0))\n", "\t\tustring = xstrdup(result->pw_name);\n", "\n", "\treturn ustring;\n", "}\n"], "project": "slurm-wlm", "file": "uid.pkl", "function": "uid_to_string_or_null"}, {"comment_all": {"comment": "/* go back to original position */", "depth": 4, "reading_ease": 49.48, "reading_grade": 7.6, "line": 57}, "comment_text": "/* go back to original position */", "comment_tokens": ["go", "back", "to", "original", "position"], "ccode": ["\n", "static void test_istream_dot_one(const struct dot_test *test,\n", "\t\t\t\t bool send_last_lf, bool test_bufsize)\n", "{\n", "\tstruct istream *test_input, *input;\n", "\tconst unsigned char *data;\n", "\tsize_t size;\n", "\tunsigned int i;\n", "\tsize_t outsize, input_len, output_len;\n", "\tstring_t *str;\n", "\tuoff_t offset;\n", "\tint ret;\n", "\n", "\ttest_input = test_istream_create(test->input);\n", "\tinput = i_stream_create_dot(test_input, send_last_lf);\n", "\n", "\tinput_len = strlen(test->input);\n", "\toutput_len = strlen(test->output);\n", "\tif (!send_last_lf &&\n", "\t    (test->input[input_len-1] == '\\n' ||\n", "\t     strstr(test->input, \"\\n.\\n\") != NULL ||\n", "\t     strstr(test->input, \"\\n.\\r\\n\") != NULL)) {\n", "\t\tif (output_len > 0 &&\n", "\t\t    test->output[output_len-1] == '\\n') {\n", "\t\t\toutput_len--;\n", "\t\t\tif (output_len > 0 &&\n", "\t\t\t    test->output[output_len-1] == '\\r')\n", "\t\t\t\toutput_len--;\n", "\t\t}\n", "\t}\n", "\n", "\tstr = t_str_new(256);\n", "\tif (!test_bufsize) {\n", "\t\toutsize = 1; i = 0;\n", "\t\ti_stream_set_max_buffer_size(input, outsize);\n", "\t\ttest_istream_set_size(test_input, 1);\n", "\t\twhile ((ret = i_stream_read(input)) != -1) {\n", "\t\t\tswitch (ret) {\n", "\t\t\tcase -2:\n", "\t\t\t\ti_stream_set_max_buffer_size(input, ++outsize);\n", "\t\t\t\toffset = test_input->v_offset;\n", "\t\t\t\t/* seek one byte backwards so stream gets\n", "\t\t\t\t   reset */\n", "\t\t\t\ti_stream_seek(test_input, offset - 1);\n", "\t\t\t\t/* go back to original position */\n", "\t\t\t\ttest_istream_set_size(test_input, offset);\n", "\t\t\t\ti_stream_skip(test_input, 1);\n", "\t\t\t\t/* and finally allow reading one more byte */\n", "\t\t\t\ttest_istream_set_size(test_input, offset + 1);\n", "\t\t\t\tbreak;\n", "\t\t\tcase 0:\n", "\t\t\t\ttest_istream_set_size(test_input, ++i);\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\ttest_assert(ret > 0);\n", "\n", "\t\t\t\tdata = i_stream_get_data(input, &size);\n", "\t\t\t\tstr_append_data(str, data, size);\n", "\t\t\t\ti_stream_skip(input, size);\n", "\t\t\t}\n", "\t\t}\n", "\t\ttest_istream_set_size(test_input, input_len);\n", "\t\t(void)i_stream_read(test_input);\n", "\t} else {\n", "\t\ttest_istream_set_size(test_input, input_len);\n", "\t\tsize = 0;\n", "\t\tfor (i = 1; i < output_len; i++) {\n", "\t\t\ti_stream_set_max_buffer_size(input, i);\n", "\t\t\ttest_assert(i_stream_read(input) == 1);\n", "\t\t\ttest_assert(i_stream_read(input) == -2);\n", "\t\t\tdata = i_stream_get_data(input, &size);\n", "\t\t\ttest_assert(memcmp(data, test->output, size) == 0);\n", "\t\t}\n", "\t\ti_stream_set_max_buffer_size(input, i+2);\n", "\t\tif (size < output_len)\n", "\t\t\ttest_assert(i_stream_read(input) == 1);\n", "\t\ttest_assert(i_stream_read(input) == -1);\n", "\n", "\t\tdata = i_stream_get_data(input, &size);\n", "\t\tif (size > 0)\n", "\t\t\tstr_append_data(str, data, size);\n", "\t}\n", "\ttest_assert(input->stream_errno == 0);\n", "\ttest_assert(str_len(str) == output_len);\n", "\ttest_assert(memcmp(str_data(str), test->output, output_len) == 0);\n", "\n", "\t/* read the data after the '.' line and verify it's still there */\n", "\ti_stream_set_max_buffer_size(test_input, (size_t)-1);\n", "\t(void)i_stream_read(test_input);\n", "\tdata = i_stream_get_data(test_input, &size);\n", "\ttest_assert(size == strlen(test->parent_input));\n", "\tif (size > 0)\n", "\t\ttest_assert(memcmp(data, test->parent_input, size) == 0);\n", "\n", "\ti_stream_unref(&test_input);\n", "\ti_stream_unref(&input);\n", "}\n"], "project": "dovecot-lmtpd", "file": "test-istream-dot.pkl", "function": "test_istream_dot_one"}, {"comment_all": {"comment": "/**\n * gnutls_record_can_use_length_hiding:\n * @session: is a #gnutls_session_t type.\n *\n * If the session supports length-hiding padding, you can\n * invoke gnutls_record_send_range() to send a message whose\n * length is hidden in the given range. If the session does not\n * support length hiding padding, you can use the standard\n * gnutls_record_send() function, or gnutls_record_send_range()\n * making sure that the range is the same as the length of the\n * message you are trying to send.\n *\n * Returns: true (1) if the current session supports length-hiding\n * padding, false (0) if the current session does not.\n **/", "depth": 0, "reading_ease": 58.82, "reading_grade": 10.2, "line": 100}, "comment_text": "/**\n * gnutls_record_can_use_length_hiding:\n * @session: is a #gnutls_session_t type.\n *\n * If the session supports length-hiding padding, you can\n * invoke gnutls_record_send_range() to send a message whose\n * length is hidden in the given range. If the session does not\n * support length hiding padding, you can use the standard\n * gnutls_record_send() function, or gnutls_record_send_range()\n * making sure that the range is the same as the length of the\n * message you are trying to send.\n *\n * Returns: true (1) if the current session supports length-hiding\n * padding, false (0) if the current session does not.\n **/", "comment_tokens": ["gnutls_record_can_use_length_hiding", ":", "@", "session", ":", "is", "a", "#", "gnutls_session_t", "type", ".", "If", "the", "session", "supports", "length-hiding", "padding", ",", "you", "can", "invoke", "gnutls_record_send_range", "(", ")", "to", "send", "a", "message", "whose", "length", "is", "hidden", "in", "the", "given", "range", ".", "If", "the", "session", "does", "not", "support", "length", "hiding", "padding", ",", "you", "can", "use", "the", "standard", "gnutls_record_send", "(", ")", "function", ",", "or", "gnutls_record_send_range", "(", ")", "making", "sure", "that", "the", "range", "is", "the", "same", "as", "the", "length", "of", "the", "message", "you", "are", "trying", "to", "send", ".", "Returns", ":", "true", "(", "1", ")", "if", "the", "current", "session", "supports", "length-hiding", "padding", ",", "false", "(", "0", ")", "if", "the", "current", "session", "does", "not", "."], "ccode": ["\n", "/**\n", " * gnutls_record_can_use_length_hiding:\n", " * @session: is a #gnutls_session_t type.\n", " *\n", " * If the session supports length-hiding padding, you can\n", " * invoke gnutls_record_send_range() to send a message whose\n", " * length is hidden in the given range. If the session does not\n", " * support length hiding padding, you can use the standard\n", " * gnutls_record_send() function, or gnutls_record_send_range()\n", " * making sure that the range is the same as the length of the\n", " * message you are trying to send.\n", " *\n", " * Returns: true (1) if the current session supports length-hiding\n", " * padding, false (0) if the current session does not.\n", " **/\n", "unsigned gnutls_record_can_use_length_hiding(gnutls_session_t session)\n", "{\n", "\tint ret;\n", "\trecord_parameters_st *record_params;\n", "\tconst version_entry_st *vers = get_version(session);\n", "\n", "\tif (unlikely(vers == NULL))\n", "\t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n", "\n", "\tif (vers->tls13_sem)\n", "\t\treturn 1;\n", "\n", "#ifdef ENABLE_SSL3\n", "\tif (vers->id == GNUTLS_SSL3)\n", "\t\treturn 0;\n", "#endif\n", "\n", "\tret =\n", "\t    _gnutls_epoch_get(session, EPOCH_WRITE_CURRENT,\n", "\t\t\t      &record_params);\n", "\tif (ret < 0) {\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tswitch (_gnutls_cipher_type(record_params->cipher)) {\n", "\tcase CIPHER_BLOCK:\n", "\t\treturn 1;\n", "\tcase CIPHER_STREAM:\n", "\tcase CIPHER_AEAD:\n", "\tdefault:\n", "\t\treturn 0;\n", "\t}\n", "}\n"], "project": "libgnutls-openssl27", "file": "range.pkl", "function": "gnutls_record_can_use_length_hiding"}, {"comment_all": {"comment": "/**\n * FIXME Implement fallback if hw is not available.\n */", "depth": 0, "reading_ease": 71.82, "reading_grade": 5.2, "line": 1463}, "comment_text": "/**\n * FIXME Implement fallback if hw is not available.\n */", "comment_tokens": ["FIXME", "Implement", "fallback", "if", "hw", "is", "not", "available", "."], "ccode": ["\n", "/**\n", " * FIXME Implement fallback if hw is not available.\n", " */\n", "int inflateBackInit_(z_streamp strm, int windowBits, unsigned char *window,\n", "\t\t     const char *version, int stream_size)\n", "{\n", "\treturn z_inflateBackInit_(strm, windowBits, window, version,\n", "\t\t\t\t  stream_size);\n", "}\n"], "project": "libzadc4", "file": "wrapper.pkl", "function": "inflateBackInit_"}, {"comment_all": {"comment": "/* Compatibility: just update the threshold for ctf_discard.  */", "depth": 0, "reading_ease": 22.07, "reading_grade": 11.9, "line": 241}, "comment_text": "/* Compatibility: just update the threshold for ctf_discard.  */", "comment_tokens": ["Compatibility", ":", "just", "update", "the", "threshold", "for", "ctf_discard", "."], "ccode": ["\n", "/* Compatibility: just update the threshold for ctf_discard.  */\n", "int\n", "ctf_update (ctf_file_t *fp)\n", "{\n", "  if (!(fp->ctf_flags & LCTF_RDWR))\n", "    return (ctf_set_errno (fp, ECTF_RDONLY));\n", "\n", "  fp->ctf_dtoldid = fp->ctf_typemax;\n", "  return 0;\n", "}\n"], "project": "binutils-hppa64-linux-gnu-dbg", "file": "ctf-create.pkl", "function": "ctf_update"}, {"comment_all": {"comment": "/* block mapped file; see if block zero is mapped? */", "depth": 1, "reading_ease": 104.64, "reading_grade": 0.9, "line": 376}, "comment_text": "/* block mapped file; see if block zero is mapped? */", "comment_tokens": ["block", "mapped", "file", ";", "see", "if", "block", "zero", "is", "mapped", "?"], "ccode": ["\n", "blk64_t ext2fs_find_inode_goal(ext2_filsys fs, ext2_ino_t ino,\n", "\t\t\t       struct ext2_inode *inode, blk64_t lblk)\n", "{\n", "\tdgrp_t\t\t\tgroup;\n", "\t__u8\t\t\tlog_flex;\n", "\tstruct ext2fs_extent\textent;\n", "\text2_extent_handle_t\thandle = NULL;\n", "\terrcode_t\t\terr;\n", "\n", "\t/* Make sure data stored in inode->i_block is neither fast symlink nor\n", "\t * inline data.\n", "\t */\n", "\tif (inode == NULL || ext2fs_is_fast_symlink(inode) ||\n", "\t    inode->i_flags & EXT4_INLINE_DATA_FL)\n", "\t\tgoto no_blocks;\n", "\n", "\tif (inode->i_flags & EXT4_EXTENTS_FL) {\n", "\t\terr = ext2fs_extent_open2(fs, ino, inode, &handle);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\terr = ext2fs_extent_goto2(handle, 0, lblk);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\terr = ext2fs_extent_get(handle, EXT2_EXTENT_CURRENT, &extent);\n", "\t\tif (err)\n", "\t\t\tgoto no_blocks;\n", "\t\text2fs_extent_free(handle);\n", "\t\treturn extent.e_pblk + (lblk - extent.e_lblk);\n", "\t}\n", "\n", "\t/* block mapped file; see if block zero is mapped? */\n", "\tif (inode->i_block[0])\n", "\t\treturn inode->i_block[0];\n", "\n", "no_blocks:\n", "\text2fs_extent_free(handle);\n", "\tlog_flex = fs->super->s_log_groups_per_flex;\n", "\tgroup = ext2fs_group_of_ino(fs, ino);\n", "\tif (log_flex)\n", "\t\tgroup = group & ~((1 << (log_flex)) - 1);\n", "\treturn ext2fs_group_first_block2(fs, group);\n", "}\n"], "project": "libss2", "file": "alloc.pkl", "function": "ext2fs_find_inode_goal"}, {"comment_all": {"comment": "/* This term is not always evenly divide so we round it up */", "depth": 1, "reading_ease": 84.68, "reading_grade": 4.4, "line": 1403}, "comment_text": "/* This term is not always evenly divide so we round it up */", "comment_tokens": ["This", "term", "is", "not", "always", "evenly", "divide", "so", "we", "round", "it", "up"], "ccode": ["\n", "SBC_EXPORT size_t sbc_get_frame_length(sbc_t *sbc)\n", "{\n", "\tint ret;\n", "\tuint8_t subbands, channels, blocks, joint, bitpool;\n", "\tstruct sbc_priv *priv;\n", "\n", "\tpriv = sbc->priv;\n", "\tif (priv->init && priv->frame.bitpool == sbc->bitpool)\n", "\t\treturn priv->frame.length;\n", "\n", "\tsubbands = sbc->subbands ? 8 : 4;\n", "\tif (priv->msbc)\n", "\t\tblocks = MSBC_BLOCKS;\n", "\telse\n", "\t\tblocks = 4 + (sbc->blocks * 4);\n", "\tchannels = sbc->mode == SBC_MODE_MONO ? 1 : 2;\n", "\tjoint = sbc->mode == SBC_MODE_JOINT_STEREO ? 1 : 0;\n", "\tbitpool = sbc->bitpool;\n", "\n", "\tret = 4 + (4 * subbands * channels) / 8;\n", "\t/* This term is not always evenly divide so we round it up */\n", "\tif (channels == 1 || sbc->mode == SBC_MODE_DUAL_CHANNEL)\n", "\t\tret += ((blocks * channels * bitpool) + 7) / 8;\n", "\telse\n", "\t\tret += (((joint ? subbands : 0) + blocks * bitpool) + 7) / 8;\n", "\n", "\treturn ret;\n", "}\n"], "project": "libsbc-dev", "file": "sbc.pkl", "function": "sbc_get_frame_length"}, {"comment_all": {"comment": "/* A realloc() that fails noisily if called with any ctf_str_num_users.  */", "depth": 0, "reading_ease": 52.87, "reading_grade": 8.4, "line": 142}, "comment_text": "/* A realloc() that fails noisily if called with any ctf_str_num_users.  */", "comment_tokens": ["A", "realloc", "(", ")", "that", "fails", "noisily", "if", "called", "with", "any", "ctf_str_num_users", "."], "ccode": ["\n", "/* A realloc() that fails noisily if called with any ctf_str_num_users.  */\n", "void *\n", "ctf_realloc (ctf_file_t *fp, void *ptr, size_t size)\n", "{\n", "  if (fp->ctf_str_num_refs > 0)\n", "    {\n", "      ctf_dprintf (\"%p: attempt to realloc() string table with %lu active refs\\n\",\n", "\t\t   (void *) fp, (unsigned long) fp->ctf_str_num_refs);\n", "      return NULL;\n", "    }\n", "  return realloc (ptr, size);\n", "}\n"], "project": "binutils-powerpc-linux-gnu", "file": "ctf-util.pkl", "function": "ctf_realloc"}, {"comment_all": {"comment": "/* Increase the buffer to prepare for a possible push. */", "depth": 2, "reading_ease": 62.34, "reading_grade": 6.8, "line": 2007}, "comment_text": "/* Increase the buffer to prepare for a possible push. */\n/* arbitrary grow size */\n", "comment_tokens": ["Increase", "the", "buffer", "to", "prepare", "for", "a", "possible", "push", ".", "arbitrary", "grow", "size"], "ccode": ["\n", "/* Allocates the stack if it does not exist.\n", " *  Guarantees space for at least one push.\n", " */\n", "static void yyensure_buffer_stack (void)\n", "{\n", "\tyy_size_t num_to_alloc;\n", "    \n", "\tif (!(yy_buffer_stack)) {\n", "\n", "\t\t/* First allocation is just for 2 elements, since we don't know if this\n", "\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n", "\t\t * immediate realloc on the next call.\n", "         */\n", "      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n", "\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n", "\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t\t(yy_buffer_stack_top) = 0;\n", "\t\treturn;\n", "\t}\n", "\n", "\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n", "\n", "\t\t/* Increase the buffer to prepare for a possible push. */\n", "\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n", "\n", "\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n", "\t\t\t\t\t\t\t\t((yy_buffer_stack),\n", "\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\t/* zero only the new slots.*/\n", "\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t}\n", "}\n"], "project": "wordnet-grind", "file": "grind-wnlex.pkl", "function": "yyensure_buffer_stack"}, {"comment_all": {"comment": "/******************************************************************************\n purpose   : Handle everything associated with equations\n ******************************************************************************/", "depth": 0, "reading_ease": -10.76, "reading_grade": 16.3, "line": 797}, "comment_text": "/******************************************************************************\n purpose   : Handle everything associated with equations\n ******************************************************************************/", "comment_tokens": ["purpose", ":", "Handle", "everything", "associated", "with", "equations"], "ccode": ["#endif\n", "\n", "/******************************************************************************\n", " purpose   : Handle everything associated with equations\n", " ******************************************************************************/\n", "void CmdEquation(int code)\n", "{\n", "    int inline_equation, number, true_code;\n", "    char *pre  = NULL;\n", "    char *eq   = NULL;\n", "    char *post = NULL;\n", "\n", "    true_code = code & ~ON;\n", "\n", "    if (!(code & ON || code==EQN_ENSUREMATH))\n", "        return;\n", "\n", "    if (code==EQN_ENSUREMATH)\n", "        eq = getBraceParam();\n", "    else\n", "        SlurpEquation(code, &pre, &eq, &post);\n", "\n", "    diagnostics(4, \"Entering CmdEquation --------%x\\n<%s>\\n<%s>\\n<%s>\", code, pre, eq, post);\n", "\n", "    inline_equation = (true_code == EQN_MATH) || \n", "                      (true_code == EQN_DOLLAR) || \n", "                      (true_code == EQN_RND_OPEN) ||\n", "                      (true_code == EQN_ENSUREMATH);\n", "\n", "    number = getCounter(\"equation\");\n", "\n", "    diagnostics(4, \"inline=%d  inline_bitmap=%d\", inline_equation, g_equation_inline_bitmap);\n", "    diagnostics(4, \"inline=%d display_bitmap=%d\", inline_equation, g_equation_display_bitmap);\n", "    diagnostics(4, \"inline=%d  inline_rtf   =%d\", inline_equation, g_equation_inline_rtf);\n", "    diagnostics(4, \"inline=%d display_rtf   =%d\", inline_equation, g_equation_display_rtf);\n", "    diagnostics(4, \"inline=%d  inline_eps   =%d\", inline_equation, g_equation_inline_eps);\n", "    diagnostics(4, \"inline=%d display_eps   =%d\", inline_equation, g_equation_display_eps);\n", "\n", "    if (g_equation_comment)\n", "        WriteEquationAsComment(pre, eq, post);\n", "\n", "    if (g_equation_raw_latex) \n", "        WriteEquationAsLatex(true_code, inline_equation, pre, eq, post);\n", "\n", "    /* bitmap versions of equations */\n", "    if (( inline_equation && g_equation_inline_bitmap ) || (!inline_equation && g_equation_display_bitmap))   \n", "\t\tWriteEquationAsBitmapOrEPS(true_code, pre, eq, post, BITMAP);\n", "\n", "    if ((inline_equation && g_equation_inline_eps) || (!inline_equation && g_equation_display_eps))\n", "\t\tWriteEquationAsBitmapOrEPS(true_code, pre, eq, post, EPS);\n", "\n", "    if ((inline_equation && g_equation_inline_rtf) || (!inline_equation && g_equation_display_rtf)) {\n", "        setCounter(\"equation\", number);\n", "        WriteEquationAsRTF(true_code, &eq);\n", "    }\n", "\n", "/* balance \\begin{xxx} with \\end{xxx} call */\n", "    if (true_code == EQN_MATH     || true_code == EQN_DISPLAYMATH   ||\n", "        true_code == EQN_EQUATION || true_code == EQN_EQUATION_STAR ||\n", "        true_code == EQN_ARRAY    || true_code == EQN_ARRAY_STAR    ||\n", "        true_code == EQN_ALIGN    || true_code == EQN_ALIGN_STAR)\n", "        ConvertString(post);\n", "\n", "    free(pre);\n", "    free(eq);\n", "    free(post);\n", "\n", "}\n"], "project": "latex2rtf-doc", "file": "equations.pkl", "function": "CmdEquation"}, {"comment_all": {"comment": "/* --------------------- MapTdgtMsg() --------------------- */", "depth": 0, "reading_ease": 36.62, "reading_grade": 8.4, "line": 199}, "comment_text": "/* --------------------- MapTdgtMsg() --------------------- */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "MapTdgtMsg", "(", ")", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "/* --------------------- MapTdgtMsg() --------------------- */\n", "\n", "static\n", "void MapTdgtMsg(pti)\n", "   TidgetInfo *pti;\n", "{\n", "   TdgtMsg *pTdgtMsg=(TdgtMsg*)(pti->tidget);\n", "\n", "#ifdef MAPBEFORESELECT\n", "   XMapWindow(mainDisplay, pTdgtMsg->pti->tci.win);\n", "   XSelectInput(mainDisplay, pTdgtMsg->pti->tci.win,\n", "         ButtonReleaseMask | ButtonPressMask | KeyPressMask | ExposureMask |\n", "         EnterWindowMask | LeaveWindowMask);\n", "#else\n", "   XSelectInput(mainDisplay, pTdgtMsg->pti->tci.win,\n", "         ButtonReleaseMask | ButtonPressMask | KeyPressMask | ExposureMask |\n", "         EnterWindowMask | LeaveWindowMask);\n", "   XMapWindow(mainDisplay, pTdgtMsg->pti->tci.win);\n", "#endif\n", "}\n"], "project": "tgif", "file": "tdgtmsg.pkl", "function": "MapTdgtMsg"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  Delete the RTF file and main file reference that belong to the named file.\n\n  char *name The name of the file to delete.\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 102.1, "reading_grade": 1.9, "line": 900}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  Delete the RTF file and main file reference that belong to the named file.\n\n  char *name The name of the file to delete.\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "Delete", "the", "RTF", "file", "and", "main", "file", "reference", "that", "belong", "to", "the", "named", "file", ".", "char", "name", "The", "name", "of", "the", "file", "to", "delete", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Delete the RTF file and main file reference that belong to the named file.\n", "\n", "  char *name The name of the file to delete.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "void WriteRTFFileDelete(char *name)\n", "{\n", " char *ofile;\n", "\n", " ofile=ConcatStrings(4,option_odir,\"/\",name,RTF_FILE);\n", " unlink(ofile);\n", "}\n"], "project": "cxref-doc", "file": "rtf.pkl", "function": "WriteRTFFileDelete"}, {"comment_all": {"comment": "/* Target IP */", "depth": 1, "reading_ease": 77.91, "reading_grade": 2.9, "line": 41}, "comment_text": "/* request op */\n/* Sender MAC */\n/* Sender IP */\n/* Target MAC */\n/* Target IP */\n", "comment_tokens": ["request", "op", "Sender", "MAC", "Sender", "IP", "Target", "MAC", "Target", "IP"], "ccode": ["#include <config.h>\n", "#include \"ucarp.h\"\n", "#include \"garp.h\"\n", "#include \"log.h\"\n", "\n", "#ifdef WITH_DMALLOC\n", "# include <dmalloc.h>\n", "#endif\n", "\n", "int gratuitous_arp(const int dev_desc_fd)\n", "{\n", "    struct ether_header eh;\n", "    static unsigned char arp[28] = {\n", "            0x00, 0x01,   /* MAC address type */\n", "            0x08, 0x00,   /* Protocol address type */\n", "            0x06, 0x04,   /* MAC address size, protocol address size */\n", "            0x00, 0x01,   /* OP (1=request, 2=reply) */\n", "            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   /* Sender MAC */\n", "            0x00, 0x00, 0x00, 0x00,               /* Sender IP */\n", "            0xff, 0xff, 0xff, 0xff, 0xff, 0xff,   /* Target MAC */\n", "            0xff, 0xff, 0xff, 0xff                /* Target IP */\n", "    };    \n", "    unsigned char *pkt;\n", "    int rc;\n", "\n", "    if (ETHER_ADDR_LEN > 6) {\n", "\tabort();\n", "    }\n", "\n", "    /*\n", "     * - Gratuitous ARPs should use requests for the highest interoperability.\n", "     * - Target MAC and IP should match sender\n", "     * http://www1.ietf.org/mail-archive/web/dhcwg/current/msg03797.html\n", "     * http://en.wikipedia.org/wiki/Address_Resolution_Protocol\n", "     * http://ettercap.sourceforge.net/forum/viewtopic.php?t=2392\n", "     * http://wiki.ethereal.com/Gratuitous_ARP\n", "     */\n", "    arp[7] = 0x01;                                 /* request op */\n", "    memcpy(&arp[8], hwaddr, sizeof hwaddr);        /* Sender MAC */\n", "    memcpy(&arp[14], &vaddr.s_addr, (size_t) 4U);  /* Sender IP */\n", "    memcpy(&arp[18], hwaddr, sizeof hwaddr);       /* Target MAC */\n", "    memcpy(&arp[24], &vaddr.s_addr, (size_t) 4U);  /* Target IP */\n", "\n", "    memset(&eh, 0, sizeof eh);\n", "    memcpy(&eh.ether_shost, hwaddr, sizeof hwaddr);\n", "    memset(&eh.ether_dhost, 0xff, ETHER_ADDR_LEN);\n", "    eh.ether_type = htons(ETHERTYPE_ARP);\n", "\n", "    if ((pkt = ALLOCA(sizeof eh + sizeof arp)) == NULL) {\n", "        logfile(LOG_ERR, _(\"out of memory to send gratuitous ARP\"));\n", "        return -1;\n", "    }\n", "    memcpy(pkt, &eh, sizeof eh);\n", "    memcpy(pkt + sizeof eh, arp, sizeof arp);\n", "\n", "    do {\n", "\trc = write(dev_desc_fd, pkt, sizeof eh + sizeof arp);\n", "    } while (rc < 0 && errno == EINTR);\n", "    if (rc < 0) {\n", "        logfile(LOG_ERR, _(\"write() in garp: %s\"), strerror(errno));\n", "        ALLOCA_FREE(pkt);\n", "        return -1;\n", "    }\n", "    ALLOCA_FREE(pkt);\n", "    \n", "    return 0;\n", "}\n"], "project": "ucarp", "file": "garp.pkl", "function": "gratuitous_arp"}, {"comment_all": {"comment": "/* Not possible to detect bind mounts */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 333}, "comment_text": "/* Not possible to detect bind mounts */", "comment_tokens": ["Not", "possible", "to", "detect", "bind", "mounts"], "ccode": ["\n", "int\n", "dir_to_device(struct mountpoint_control *ctl)\n", "{\n", "\tstruct libmnt_table *tb = mnt_new_table_from_file(_PATH_PROC_MOUNTINFO);\n", "\tstruct libmnt_fs *fs;\n", "\tstruct libmnt_cache *cache;\n", "\tint rc = -1;\n", "\n", "\tif (!tb) {\n", "\t\t/* Not possible to detect bind mounts */\n", "\n", "\t\treturn -1;\n", "\t}\n", "\n", "\t/* to canonicalize all necessary paths */\n", "\tcache = mnt_new_cache();\n", "\tmnt_table_set_cache(tb, cache);\n", "\tmnt_unref_cache(cache);\n", "\n", "\tfs = mnt_table_find_target(tb, ctl->path, MNT_ITER_BACKWARD);\n", "\tif (fs && mnt_fs_get_target(fs)) {\n", "\t\tctl->dev = mnt_fs_get_devno(fs);\n", "\t\trc = 0;\n", "\t}\n", "\n", "\tmnt_unref_table(tb);\n", "\treturn rc;\n", "}\n"], "project": "tmpreaper", "file": "tmpreaper.pkl", "function": "dir_to_device"}, {"comment_all": {"comment": "/* no \":\" in layout */", "depth": 1, "reading_ease": 93.81, "reading_grade": 0.9, "line": 78}, "comment_text": "/* no \":\" in layout */", "comment_tokens": ["no", "``", ":", "''", "in", "layout"], "ccode": ["\n", "void\n", "translate_wm_button_layout_to_gtk (char *layout)\n", "{\n", "  char *strp = layout, *left_buttons, *right_buttons;\n", "  int left_len, right_len = 0;\n", "\n", "  left_buttons = strsep (&strp, \":\");\n", "  right_buttons = strp;\n", "\n", "  translate_buttons (left_buttons, &left_len);\n", "  memmove (layout, left_buttons, left_len);\n", "\n", "  if (strp == NULL)\n", "    goto out; /* no \":\" in layout */\n", "\n", "  layout[left_len++] = ':';\n", "\n", "  translate_buttons (right_buttons, &right_len);\n", "  memmove (layout + left_len, right_buttons, right_len);\n", "\n", "out:\n", "  layout[left_len + right_len] = '\\0';\n", "}\n"], "project": "gtk-3-examples", "file": "wm-button-layout-translation.pkl", "function": "translate_wm_button_layout_to_gtk"}, {"comment_all": {"comment": "/*\n     * Verify that we loaded exactly the right number of bytes\n     */", "depth": 1, "reading_ease": 61.33, "reading_grade": 7.2, "line": 71}, "comment_text": "/*\n     * Verify that we loaded exactly the right number of bytes\n     */", "comment_tokens": ["Verify", "that", "we", "loaded", "exactly", "the", "right", "number", "of", "bytes"], "ccode": ["/*\n", " * Copyright (c) 1997,2007,2016 Andrew G Morgan <morgan@kernel.org>\n", " *\n", " * This file deals with setting capabilities on files.\n", " */\n", "\n", "#define _DEFAULT_SOURCE\n", "\n", "#include <sys/types.h>\n", "#include <byteswap.h>\n", "#include <sys/stat.h>\n", "#include <unistd.h>\n", "#include <linux/xattr.h>\n", "\n", "/*\n", " * We hardcode the prototypes for the Linux system calls here since\n", " * there are no libcap library APIs that expose the user to these\n", " * details, and that way we don't need to force clients to link any\n", " * other libraries to access them.\n", " */\n", "extern ssize_t getxattr(const char *, const char *, void *, size_t);\n", "extern ssize_t fgetxattr(int, const char *, void *, size_t);\n", "extern int setxattr(const char *, const char *, const void *, size_t, int);\n", "extern int fsetxattr(int, const char *, const void *, size_t, int);\n", "extern int removexattr(const char *, const char *);\n", "extern int fremovexattr(int, const char *);\n", "\n", "#include \"libcap.h\"\n", "\n", "#ifdef VFS_CAP_U32\n", "\n", "#if VFS_CAP_U32 != __CAP_BLKS\n", "# error VFS representation of capabilities is not the same size as kernel\n", "#endif\n", "\n", "#if __BYTE_ORDER == __BIG_ENDIAN\n", "#define FIXUP_32BITS(x) bswap_32(x)\n", "#else\n", "#define FIXUP_32BITS(x) (x)\n", "#endif\n", "\n", "static cap_t _fcaps_load(struct vfs_ns_cap_data *rawvfscap, cap_t result,\n", "\t\t\t int bytes)\n", "{\n", "    __u32 magic_etc;\n", "    unsigned tocopy, i;\n", "\n", "    magic_etc = FIXUP_32BITS(rawvfscap->magic_etc);\n", "    switch (magic_etc & VFS_CAP_REVISION_MASK) {\n", "    case VFS_CAP_REVISION_1:\n", "\ttocopy = VFS_CAP_U32_1;\n", "\tbytes -= XATTR_CAPS_SZ_1;\n", "\tbreak;\n", "\n", "    case VFS_CAP_REVISION_2:\n", "\ttocopy = VFS_CAP_U32_2;\n", "\tbytes -= XATTR_CAPS_SZ_2;\n", "\tbreak;\n", "\n", "    case VFS_CAP_REVISION_3:\n", "\ttocopy = VFS_CAP_U32_3;\n", "\tbytes -= XATTR_CAPS_SZ_3;\n", "\tresult->rootid = FIXUP_32BITS(rawvfscap->rootid);\n", "\tbreak;\n", "\n", "    default:\n", "\tcap_free(result);\n", "\tresult = NULL;\n", "\treturn result;\n", "    }\n", "\n", "    /*\n", "     * Verify that we loaded exactly the right number of bytes\n", "     */\n", "    if (bytes != 0) {\n", "\tcap_free(result);\n", "\tresult = NULL;\n", "\treturn result;\n", "    }\n", "\n", "    for (i=0; i < tocopy; i++) {\n", "\tresult->u[i].flat[CAP_INHERITABLE]\n", "\t    = FIXUP_32BITS(rawvfscap->data[i].inheritable);\n", "\tresult->u[i].flat[CAP_PERMITTED]\n", "\t    = FIXUP_32BITS(rawvfscap->data[i].permitted);\n", "\tif (magic_etc & VFS_CAP_FLAGS_EFFECTIVE) {\n", "\t    result->u[i].flat[CAP_EFFECTIVE]\n", "\t\t= result->u[i].flat[CAP_INHERITABLE]\n", "\t\t| result->u[i].flat[CAP_PERMITTED];\n", "\t}\n", "    }\n", "    while (i < __CAP_BLKS) {\n", "\tresult->u[i].flat[CAP_INHERITABLE]\n", "\t    = result->u[i].flat[CAP_PERMITTED]\n", "\t    = result->u[i].flat[CAP_EFFECTIVE] = 0;\n", "\ti++;\n", "    }\n", "\n", "    return result;\n", "}\n"], "project": "libcap-dev", "file": "cap_file.pkl", "function": "_fcaps_load"}, {"comment_all": {"comment": "/**\n * calculate greatest common divisor GCD(a,b)\n * @param a the first number\n * @param b the second number\n * @return GCD(a,b)\n */", "depth": 0, "reading_ease": 54.22, "reading_grade": 9.9, "line": 716}, "comment_text": "/**\n * calculate greatest common divisor GCD(a,b)\n * @param a the first number\n * @param b the second number\n * @return GCD(a,b)\n */", "comment_tokens": ["calculate", "greatest", "common", "divisor", "GCD", "(", "a", ",", "b", ")", "@", "param", "a", "the", "first", "number", "@", "param", "b", "the", "second", "number", "@", "return", "GCD", "(", "a", ",", "b", ")"], "ccode": ["\n", "/**\n", " * calculate greatest common divisor GCD(a,b)\n", " * @param a the first number\n", " * @param b the second number\n", " * @return GCD(a,b)\n", " */\n", "int pagerender_gcd(int a,int b) {\n", "  int r;\n", "  if (a==0) return b;\n", "  if (b==0) return a;\n", "  while (b!=0) {\n", "    r = a%b;\n", "    a = b;\n", "    b = r;\n", "  }\n", "  return a;    \n", "}\n"], "project": "darnwdl", "file": "pagerender.pkl", "function": "pagerender_gcd"}, {"comment_all": {"comment": "/* (just in case it would not end with all signals blocked) */", "depth": 1, "reading_ease": 102.61, "reading_grade": 1.7, "line": 481}, "comment_text": "/* (just in case it would not end with all signals blocked) */", "comment_tokens": ["(", "just", "in", "case", "it", "would", "not", "end", "with", "all", "signals", "blocked", ")"], "ccode": ["\n", "\n", "/* ts A61230 */\n", "static void *format_worker_func(struct w_list *w)\n", "{\n", "\n", "#define Libburn_protect_format_threaD 1\n", "\n", "#ifdef Libburn_protect_format_threaD\n", "\tsigset_t sigset, oldset;\n", "\n", "\t/* Protect format thread from being interrupted by external signals */\n", "\tsigfillset(&sigset);\n", "\tsigdelset(&sigset, SIGSEGV);\n", "\tsigdelset(&sigset, SIGILL);\n", "\tpthread_sigmask(SIG_SETMASK, &sigset, &oldset);\n", "#endif /* Libburn_protect_format_threaD */\n", "\n", "\tburn_disc_format_sync(w->u.format.drive, w->u.format.size,\n", "\t\t\t\tw->u.format.flag);\n", "\tremove_worker(pthread_self());\n", "\n", "#ifdef Libburn_protect_format_threaD\n", "\t/* (just in case it would not end with all signals blocked) */\n", "\tpthread_sigmask(SIG_SETMASK, &oldset, NULL);\n", "#endif /* Libburn_protect_format_threaD */\n", "\n", "\treturn NULL;\n", "}\n"], "project": "libburn-dev", "file": "async.pkl", "function": "format_worker_func"}, {"comment_all": {"comment": "/* The default choose_target function.  */", "depth": 0, "reading_ease": 33.58, "reading_grade": 9.6, "line": 188}, "comment_text": "/* The default choose_target function.  */", "comment_tokens": ["The", "default", "choose_target", "function", "."], "ccode": ["\n", "\n", "/* The default choose_target function.  */\n", "\n", "char *\n", "ldemul_default_target (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n", "{\n", "  char *from_outside = getenv (TARGET_ENVIRON);\n", "  if (from_outside != (char *) NULL)\n", "    return from_outside;\n", "  return ld_emulation->target_name;\n", "}\n"], "project": "binutils-arm-linux-gnueabihf-dbg", "file": "ldemul.pkl", "function": "ldemul_default_target"}, {"comment_all": {"comment": "/* Copy markers saved in the given source object to the destination object.\n * This should be called just after jpeg_start_compress() or\n * jpeg_write_coefficients().\n * Note that those routines will have written the SOI, and also the\n * JFIF APP0 or Adobe APP14 markers if selected.\n */", "depth": 0, "reading_ease": 57.57, "reading_grade": 8.6, "line": 2383}, "comment_text": "/* Copy markers saved in the given source object to the destination object.\n * This should be called just after jpeg_start_compress() or\n * jpeg_write_coefficients().\n * Note that those routines will have written the SOI, and also the\n * JFIF APP0 or Adobe APP14 markers if selected.\n */", "comment_tokens": ["Copy", "markers", "saved", "in", "the", "given", "source", "object", "to", "the", "destination", "object", ".", "This", "should", "be", "called", "just", "after", "jpeg_start_compress", "(", ")", "or", "jpeg_write_coefficients", "(", ")", ".", "Note", "that", "those", "routines", "will", "have", "written", "the", "SOI", ",", "and", "also", "the", "JFIF", "APP0", "or", "Adobe", "APP14", "markers", "if", "selected", "."], "ccode": ["\n", "/* Copy markers saved in the given source object to the destination object.\n", " * This should be called just after jpeg_start_compress() or\n", " * jpeg_write_coefficients().\n", " * Note that those routines will have written the SOI, and also the\n", " * JFIF APP0 or Adobe APP14 markers if selected.\n", " */\n", "\n", "GLOBAL(void)\n", "jcopy_markers_execute (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n", "\t\t       JCOPY_OPTION option)\n", "{\n", "  jpeg_saved_marker_ptr marker;\n", "\n", "  /* In the current implementation, we don't actually need to examine the\n", "   * option flag here; we just copy everything that got saved.\n", "   * But to avoid confusion, we do not output JFIF and Adobe APP14 markers\n", "   * if the encoder library already wrote one.\n", "   */\n", "  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {\n", "    if (dstinfo->write_JFIF_header &&\n", "\tmarker->marker == JPEG_APP0 &&\n", "\tmarker->data_length >= 5 &&\n", "\tGETJOCTET(marker->data[0]) == 0x4A &&\n", "\tGETJOCTET(marker->data[1]) == 0x46 &&\n", "\tGETJOCTET(marker->data[2]) == 0x49 &&\n", "\tGETJOCTET(marker->data[3]) == 0x46 &&\n", "\tGETJOCTET(marker->data[4]) == 0)\n", "      continue;\t\t\t/* reject duplicate JFIF */\n", "    if (dstinfo->write_Adobe_marker &&\n", "\tmarker->marker == JPEG_APP0+14 &&\n", "\tmarker->data_length >= 5 &&\n", "\tGETJOCTET(marker->data[0]) == 0x41 &&\n", "\tGETJOCTET(marker->data[1]) == 0x64 &&\n", "\tGETJOCTET(marker->data[2]) == 0x6F &&\n", "\tGETJOCTET(marker->data[3]) == 0x62 &&\n", "\tGETJOCTET(marker->data[4]) == 0x65)\n", "      continue;\t\t\t/* reject duplicate Adobe */\n", "#ifdef NEED_FAR_POINTERS\n", "    /* We could use jpeg_write_marker if the data weren't FAR... */\n", "    {\n", "      unsigned int i;\n", "      jpeg_write_m_header(dstinfo, marker->marker, marker->data_length);\n", "      for (i = 0; i < marker->data_length; i++)\n", "\tjpeg_write_m_byte(dstinfo, marker->data[i]);\n", "    }\n", "#else\n", "    jpeg_write_marker(dstinfo, marker->marker,\n", "\t\t      marker->data, marker->data_length);\n", "#endif\n", "  }\n", "}\n"], "project": "libjpeg9", "file": "transupp.pkl", "function": "jcopy_markers_execute"}, {"comment_all": {"comment": "/* get decoding tree from\n\t\t\t\t\t\t * file */", "depth": 2, "reading_ease": 83.32, "reading_grade": 2.9, "line": 74}, "comment_text": "/* get decoding tree from\n\t\t\t\t\t\t * file */", "comment_tokens": ["get", "decoding", "tree", "from", "file"], "ccode": ["\n", "VOID\n", "init_usq(f)\t\t\t/* initialize Huffman unsqueezing */\n", "\tFILE\t       *f;\t/* file containing squeezed data */\n", "{\n", "\tint\t\ti;\t/* node index */\n", "\tu_int\t\tinlen;\n", "\n", "\tbpos = 99;\t\t/* force initial read */\n", "\n", "\tinlen = getb_unp(f);\n", "\tinbeg = pinbuf;\n", "\tinend = &pinbuf[inlen];\n", "\n", "\tGET_INT(numnodes);\n", "\n", "\tif (numnodes < 0 || numnodes >= NUMVALS)\n", "\t\tarcdie(\"File has an invalid decode tree\");\n", "\n", "\t/* initialize for possible empty tree (SPEOF only) */\n", "\n", "\tnode[0].child[0] = -(SPEOF + 1);\n", "\tnode[0].child[1] = -(SPEOF + 1);\n", "\n", "\tfor (i = 0; i < numnodes; ++i) {\t/* get decoding tree from\n", "\t\t\t\t\t\t * file */\n", "\t\tGET_INT(node[i].child[0]);\n", "\t\tGET_INT(node[i].child[1]);\n", "\t}\n", "}\n"], "project": "arc", "file": "arcusq.pkl", "function": "init_usq"}, {"comment_all": {"comment": "/* Only supported for root marshaller */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 232}, "comment_text": "/* Only supported for root marshaller */", "comment_tokens": ["Only", "supported", "for", "root", "marshaller"], "ccode": ["\n", "void spice_marshaller_destroy(SpiceMarshaller *m)\n", "{\n", "    MarshallerBuffer *buf, *next;\n", "    SpiceMarshallerData *d;\n", "\n", "    /* Only supported for root marshaller */\n", "    assert(m->data->marshallers == m);\n", "\n", "    spice_marshaller_reset(m);\n", "\n", "    free_items(m);\n", "\n", "    d = m->data;\n", "\n", "    buf = d->buffers->next;\n", "    while (buf != NULL) {\n", "        next = buf->next;\n", "        free(buf);\n", "        buf = next;\n", "    }\n", "\n", "    free(d);\n", "}\n"], "project": "libspice-client-gtk-3.0-5", "file": "marshaller.pkl", "function": "spice_marshaller_destroy"}, {"comment_all": {"comment": "/*\n * Determine the time that has passed since the search was started. If the\n * elapsed time exceeds the target(ResponseTime + ExtraTime) then set timeout\n * to true which will terminate the search.\n * iop = COMPUTE_MODE calculate et, bump ETnodes\n * iop = COMPUTE_AND_INIT_MODE calculate et, set timeout if time exceeded,\n *     set reference time\n */", "depth": 0, "reading_ease": 55.54, "reading_grade": 9.4, "line": 352}, "comment_text": "/*\n * Determine the time that has passed since the search was started. If the\n * elapsed time exceeds the target(ResponseTime + ExtraTime) then set timeout\n * to true which will terminate the search.\n * iop = COMPUTE_MODE calculate et, bump ETnodes\n * iop = COMPUTE_AND_INIT_MODE calculate et, set timeout if time exceeded,\n *     set reference time\n */", "comment_tokens": ["Determine", "the", "time", "that", "has", "passed", "since", "the", "search", "was", "started", ".", "If", "the", "elapsed", "time", "exceeds", "the", "target", "(", "ResponseTime", "+", "ExtraTime", ")", "then", "set", "timeout", "to", "true", "which", "will", "terminate", "the", "search", ".", "iop", "=", "COMPUTE_MODE", "calculate", "et", ",", "bump", "ETnodes", "iop", "=", "COMPUTE_AND_INIT_MODE", "calculate", "et", ",", "set", "timeout", "if", "time", "exceeded", ",", "set", "reference", "time"], "ccode": ["\n", "\n", "/*\n", " * Determine the time that has passed since the search was started. If the\n", " * elapsed time exceeds the target(ResponseTime + ExtraTime) then set timeout\n", " * to true which will terminate the search.\n", " * iop = COMPUTE_MODE calculate et, bump ETnodes\n", " * iop = COMPUTE_AND_INIT_MODE calculate et, set timeout if time exceeded,\n", " *     set reference time\n", " */\n", "void\n", "ElapsedTime(ElapsedTime_mode iop)\n", "{\n", "    long current_time;\n", "#ifdef HAVE_GETTIMEOFDAY\n", "    struct timeval tv;\n", "#endif\n", "\n", "    PollForInput();\n", "\n", "#ifdef HAVE_GETTIMEOFDAY\n", "    gettimeofday(&tv, NULL);\n", "    current_time = tv.tv_sec*100 + (tv.tv_usec/10000);\n", "#else\n", "    et = ((current_time = time((long *) 0)) - time0) * 100;\n", "#endif\n", "\n", "#ifdef INTERRUPT_TEST\n", "    if (iop == INIT_INTERRUPT_MODE)\n", "    {\n", "        itime0 = current_time;\n", "    }\n", "    else if (iop == COMPUTE_INTERRUPT_MODE)\n", "    {\n", "        it = current_time - itime0;\n", "    }\n", "    else\n", "#endif\n", "    {\n", "#ifdef HAVE_GETTIMEOFDAY\n", "        et = current_time - time0;\n", "#endif\n", "        ETnodes = NodeCnt + znodes;\n", "\n", "        if (et < 0)\n", "        {\n", "#ifdef INTERRUPT_TEST\n", "            printf(\"elapsed time %ld not positive\\n\", et);\n", "#endif\n", "            et = 0;\n", "        }\n", "\n", "        if (iop == COMPUTE_AND_INIT_MODE)\n", "        {\n", "            if ((et > (ResponseTime + ExtraTime)) && (Sdepth > MINDEPTH))\n", "                flag.timeout = true;\n", "\n", "            time0 = current_time;\n", "        }\n", "\n", "#ifdef QUIETBACKGROUND\n", "        if (!background)\n", "#endif\n", "            UpdateClocks();\n", "    }\n", "}\n"], "project": "gnuminishogi", "file": "tcontrl.pkl", "function": "ElapsedTime"}, {"comment_all": {"comment": "/*printf(\"%s:resetfn(%p)\\n\",__FILE__,parent);*/", "depth": 1, "reading_ease": -470.99, "reading_grade": 79.2, "line": 46}, "comment_text": "/*printf(\"%s:resetfn(%p)\\n\",__FILE__,parent);*/", "comment_tokens": ["printf", "(", "``", "%", "s", ":", "resetfn", "(", "%", "p", ")", "\\n", "''", ",", "__FILE__", ",", "parent", ")", ";"], "ccode": ["/*********************************************************************\n", "This file is part of the argtable2 library.\n", "Copyright (C) 1998-2001,2003-2011 Stewart Heitmann\n", "sheitmann@users.sourceforge.net\n", "\n", "The argtable2 library is free software; you can redistribute it and/or\n", "modify it under the terms of the GNU Library General Public License as\n", "published by the Free Software Foundation; either version 2 of the\n", "License, or (at your option) any later version.\n", "\n", "This software is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "Library General Public License for more details.\n", "\n", "You should have received a copy of the GNU Library General Public\n", "License along with this library; if not, write to the Free Software\n", "Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n", "USA.\n", "**********************************************************************/\n", "/* glibc2 needs this for strptime */\n", "#define _XOPEN_SOURCE \n", "\n", "/* SunOS also requires this for strptime */\n", "#define _XOPEN_VERSION 4 \n", "\n", "/* config.h must be included before anything else */\n", "#ifdef HAVE_CONFIG_H\n", "#include \"config.h\"\n", "#endif\n", "\n", "#ifdef HAVE_STDLIB_H\n", "#include <stdlib.h>\n", "#endif\n", "\n", "#ifdef HAVE_STRINGS_H\n", "#include <strings.h>\n", "#endif\n", "\n", "#include \"argtable2.h\"\n", "\n", "/* local error codes  */\n", "enum {EMINCOUNT=1,EMAXCOUNT,EBADDATE};\n", "\n", "static void resetfn(struct arg_date *parent)\n", "    {\n", "    /*printf(\"%s:resetfn(%p)\\n\",__FILE__,parent);*/\n", "    parent->count=0;\n", "    }\n"], "project": "libargtable2-dev", "file": "arg_date.pkl", "function": "resetfn"}, {"comment_all": {"comment": "/* See the comments in dynamic_annotations.h */", "depth": 0, "reading_ease": -18.21, "reading_grade": 17.0, "line": 164}, "comment_text": "/* See the comments in dynamic_annotations.h */", "comment_tokens": ["See", "the", "comments", "in", "dynamic_annotations.h"], "ccode": ["\n", "#endif  /* DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL == 0 */\n", "\n", "/* See the comments in dynamic_annotations.h */\n", "double ValgrindSlowdown(void) {\n", "  /* Same initialization hack as in RunningOnValgrind(). */\n", "  static volatile double slowdown = 0.0;\n", "  double local_slowdown = slowdown;\n", "  ANNOTATE_BENIGN_RACE(&slowdown, \"safe hack\");\n", "  if (RunningOnValgrind() == 0) {\n", "    return 1.0;\n", "  }\n", "  if (local_slowdown == 0.0) {\n", "    char *env = getenv(\"VALGRIND_SLOWDOWN\");\n", "    slowdown = local_slowdown = env ? atof(env) : 50.0;\n", "  }\n", "  return local_slowdown;\n", "}\n"], "project": "libgoogle-perftools-dev", "file": "dynamic_annotations.pkl", "function": "ValgrindSlowdown"}, {"comment_all": {"comment": "/* skip if getting name failed */", "depth": 3, "reading_ease": 100.24, "reading_grade": 0.5, "line": 323}, "comment_text": "/* skip if getting name failed */", "comment_tokens": ["skip", "if", "getting", "name", "failed"], "ccode": ["\n", "/*! @decl mapping info()\n", " *! @returns\n", " *!   @mapping\n", " *!     @member string \"family\"\n", " *!       The font family, or the string \"unknown\"\n", " *!     @member string \"style_name\"\n", " *!       The name of the font style, or \"unknown\"\n", " *!     @member int \"face_flags\"\n", " *!     @member int \"face_count\"\n", " *!       The number of faces contained within the font file.\n", " *!     @member int \"style_flags\"\n", " *!       The sum of all face/style flags respectively.\n", " *!   @endmapping\n", " */\n", "static void image_ft_face_info( INT32 args )\n", "{\n", "  int element_count = 10;\n", "\n", "  pop_n_elems( args );\n", "  push_text( \"family\" );\n", "  if( TFACE->family_name )\n", "    push_text( TFACE->family_name );\n", "  else\n", "    push_text( \"unknown\" );\n", "  push_text( \"face_count\" );\n", "  push_int(TFACE->num_faces);\n", "  push_text( \"style\" );\n", "  if( TFACE->style_name )\n", "    push_text( TFACE->style_name );\n", "  else\n", "    push_text( \"unknown\" );\n", "  push_text( \"face_flags\" );  push_int( TFACE->face_flags );\n", "  push_text( \"style_flags\" );  push_int( TFACE->style_flags );\n", "\n", "  if (1) /* get ps_name attribute also, if possible */\n", "  {\n", "    int sfnt_count = FT_Get_Sfnt_Name_Count(TFACE);\n", "    char ps_name[64];\n", "    int i;\n", "\n", "    for(i = 0; i < sfnt_count; ++i)\n", "    {\n", "      FT_SfntName name;\n", "      unsigned int len;\n", "\n", "      if (FT_Get_Sfnt_Name(TFACE, i, &name) != 0)\n", "        continue; /* skip if getting name failed */\n", "      if (name.name_id != TT_NAME_ID_PS_NAME)\n", "        continue; /* skip if it isn't the interesting bit */\n", "\n", "      len = name.string_len;\n", "      if (len >= sizeof(ps_name))\n", "        len = sizeof(ps_name)-1;\n", "\n", "      memcpy(ps_name, name.string, len);\n", "      ps_name[len] = 0;\n", "      push_text(\"ps_name\");\n", "      push_text(ps_name);\n", "      element_count += 2;\n", "      break;\n", "    }\n", "\n", "  }\n", "\n", "  f_aggregate_mapping( element_count );\n", "}\n"], "project": "pike8.0-fuse", "file": "freetype.pkl", "function": "image_ft_face_info"}, {"comment_all": {"comment": "/* IPv6 presentation address can start with \":\", but valid domain names\n\t      cannot start with \"-\" so prepend a zero in that case. */", "depth": 3, "reading_ease": 68.1, "reading_grade": 8.7, "line": 241}, "comment_text": "/* IPv6 presentation address can start with \":\", but valid domain names\n\t      cannot start with \"-\" so prepend a zero in that case. */", "comment_tokens": ["IPv6", "presentation", "address", "can", "start", "with", "``", ":", "''", ",", "but", "valid", "domain", "names", "can", "not", "start", "with", "``", "-", "''", "so", "prepend", "a", "zero", "in", "that", "case", "."], "ccode": ["\n", "\n", "int is_rev_synth(int flag, struct all_addr *addr, char *name)\n", "{\n", "   struct cond_domain *c;\n", "\n", "   if (flag & F_IPV4 && (c = search_domain(addr->addr.addr4, daemon->synth_domains))) \n", "     {\n", "       char *p;\n", "       \n", "       *name = 0;\n", "       if (c->indexed)\n", "\t {\n", "\t   unsigned int index = ntohl(addr->addr.addr4.s_addr) - ntohl(c->start.s_addr);\n", "\t   snprintf(name, MAXDNAME, \"%s%u\", c->prefix ? c->prefix : \"\", index);\n", "\t }\n", "       else\n", "\t {\n", "\t   if (c->prefix)\n", "\t     strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);\n", "       \n", "       \t   inet_ntop(AF_INET, &addr->addr.addr4, name + strlen(name), ADDRSTRLEN);\n", "\t   for (p = name; *p; p++)\n", "\t     if (*p == '.')\n", "\t       *p = '-';\n", "\t }\n", "       \n", "       strncat(name, \".\", MAXDNAME);\n", "       strncat(name, c->domain, MAXDNAME);\n", "\n", "       return 1;\n", "     }\n", "\n", "#ifdef HAVE_IPV6\n", "   if (flag & F_IPV6 && (c = search_domain6(&addr->addr.addr6, daemon->synth_domains))) \n", "     {\n", "       char *p;\n", "       \n", "       *name = 0;\n", "       if (c->indexed)\n", "\t {\n", "\t   u64 index = addr6part(&addr->addr.addr6) - addr6part(&c->start6);\n", "\t   snprintf(name, MAXDNAME, \"%s%llu\", c->prefix ? c->prefix : \"\", index);\n", "\t }\n", "       else\n", "\t {\n", "\t   if (c->prefix)\n", "\t     strncpy(name, c->prefix, MAXDNAME - ADDRSTRLEN);\n", "       \n", "\t   inet_ntop(AF_INET6, &addr->addr.addr6, name + strlen(name), ADDRSTRLEN);\n", "\n", "\t   /* IPv6 presentation address can start with \":\", but valid domain names\n", "\t      cannot start with \"-\" so prepend a zero in that case. */\n", "\t   if (!c->prefix && *name == ':')\n", "\t     {\n", "\t       *name = '0';\n", "\t       inet_ntop(AF_INET6, &addr->addr.addr6, name+1, ADDRSTRLEN);\n", "\t     }\n", "\t   \n", "\t   /* V4-mapped have periods.... */\n", "\t   for (p = name; *p; p++)\n", "\t     if (*p == ':' || *p == '.')\n", "\t       *p = '-';\n", "\t   \n", "\t }\n", "\n", "       strncat(name, \".\", MAXDNAME);\n", "       strncat(name, c->domain, MAXDNAME);\n", "       \n", "       return 1;\n", "     }\n", "#endif\n", "   \n", "   return 0;\n", "}\n"], "project": "dnsmasq-utils", "file": "domain.pkl", "function": "is_rev_synth"}, {"comment_all": {"comment": "/* calls exit(1) if not found */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 40}, "comment_text": "/* calls exit(1) if not found */", "comment_tokens": ["calls", "exit", "(", "1", ")", "if", "not", "found"], "ccode": ["\n", "void playqueue_is_queued (int argc, char * * argv)\n", "{\n", "    int pos = check_args_playlist_pos (argc, argv);\n", "    find_in_queue (pos - 1); /* calls exit(1) if not found */\n", "\n", "    exit (0);\n", "}\n"], "project": "audacious", "file": "handlers_playqueue.pkl", "function": "playqueue_is_queued"}, {"comment_all": {"comment": "/* these functions all flush to ensure that the test runner knows the action\n * that has been taken even if the subsequent test etc takes a long time or\n * never completes (i.e. a segfault).\n */", "depth": 0, "reading_ease": 63.36, "reading_grade": 12.6, "line": 43}, "comment_text": "/* these functions all flush to ensure that the test runner knows the action\n * that has been taken even if the subsequent test etc takes a long time or\n * never completes (i.e. a segfault).\n */", "comment_tokens": ["these", "functions", "all", "flush", "to", "ensure", "that", "the", "test", "runner", "knows", "the", "action", "that", "has", "been", "taken", "even", "if", "the", "subsequent", "test", "etc", "takes", "a", "long", "time", "or", "never", "completes", "(", "i.e", ".", "a", "segfault", ")", "."], "ccode": ["\n", "/* these functions all flush to ensure that the test runner knows the action\n", " * that has been taken even if the subsequent test etc takes a long time or\n", " * never completes (i.e. a segfault).\n", " */\n", "\n", "void\n", "subunit_test_start(char const * const name)\n", "{\n", "  subunit_send_event(\"test\", name, NULL);\n", "}\n"], "project": "python3-subunit", "file": "child.pkl", "function": "subunit_test_start"}, {"comment_all": {"comment": "/* we can fully determine this match now */", "depth": 3, "reading_ease": 81.29, "reading_grade": 3.7, "line": 118}, "comment_text": "/* we can fully determine this match now */", "comment_tokens": ["we", "can", "fully", "determine", "this", "match", "now"], "ccode": ["\n", "bool str_find_more(struct str_find_context *ctx,\n", "\t\t    const unsigned char *data, size_t size)\n", "{\n", "\tunsigned int key_len = ctx->key_len;\n", "\tunsigned int i, j, a, b;\n", "\tint bad_value;\n", "\n", "\tfor (i = j = 0; i < ctx->match_count; i++) {\n", "\t\ta = ctx->matches[i];\n", "\t\tif (ctx->matches[i] + size >= key_len) {\n", "\t\t\t/* we can fully determine this match now */\n", "\t\t\tfor (; a < key_len; a++) {\n", "\t\t\t\tif (ctx->key[a] != data[a - ctx->matches[i]])\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tif (a == key_len) {\n", "\t\t\t\tctx->match_end_pos = key_len - ctx->matches[i];\n", "\t\t\t\treturn TRUE;\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\tfor (b = 0; b < size; b++) {\n", "\t\t\t\tif (ctx->key[a+b] != data[b])\n", "\t\t\t\t\tbreak;\n", "\t\t\t}\n", "\n", "\t\t\tif (b == size)\n", "\t\t\t\tctx->matches[j++] = a + size;\n", "\t\t}\n", "\t}\n", "\tif (j > 0) {\n", "\t\ti_assert(j + size < key_len);\n", "\t\tctx->match_count = j;\n", "\t\tj = 0;\n", "\t} else {\n", "\t\t/* Boyer-Moore searching */\n", "\t\tj = 0;\n", "\t\twhile (j + key_len <= size) {\n", "\t\t\ti = key_len - 1;\n", "\t\t\twhile (ctx->key[i] == data[i + j]) {\n", "\t\t\t\tif (i == 0) {\n", "\t\t\t\t\tctx->match_end_pos = j + key_len;\n", "\t\t\t\t\treturn TRUE;\n", "\t\t\t\t}\n", "\t\t\t\ti--;\n", "\t\t\t}\n", "\n", "\t\t\tbad_value = (int)(ctx->badtab[data[i + j]] + i + 1) -\n", "\t\t\t\t(int)key_len;\n", "\t\t\tj += I_MAX(ctx->goodtab[i], bad_value);\n", "\t\t}\n", "\t\ti_assert(j <= size);\n", "\t\tctx->match_count = 0;\n", "\t}\n", "\n", "\tfor (; j < size; j++) {\n", "\t\tfor (i = j; i < size; i++) {\n", "\t\t\tif (ctx->key[i-j] != data[i])\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t\tif (i == size)\n", "\t\t\tctx->matches[ctx->match_count++] = size - j;\n", "\t}\n", "\treturn FALSE;\n", "}\n"], "project": "dovecot-lmtpd", "file": "str-find.pkl", "function": "str_find_more"}, {"comment_all": {"comment": "/** => __zzip_get32\n * This function does the same for a 16 bit value.\n */", "depth": 0, "reading_ease": 94.15, "reading_grade": 2.9, "line": 93}, "comment_text": "/** => __zzip_get32\n * This function does the same for a 16 bit value.\n */", "comment_tokens": ["=", ">", "__zzip_get32", "This", "function", "does", "the", "same", "for", "a", "16", "bit", "value", "."], "ccode": ["\n", "/** => __zzip_get32\n", " * This function does the same for a 16 bit value.\n", " */\n", "void\n", "__zzip_set16(unsigned char *s, uint16_t v)\n", "{\n", "#if defined __ZZIP_SET16\n", "    return __ZZIP_SET16(s, v);\n", "#else\n", "    /* *INDENT-OFF* */\n", "    s[0] = (unsigned char) (v); v >>= 8;\n", "    s[1] = (unsigned char) (v);\n", "    /* *INDENT-ON* */\n", "#endif\n", "}\n"], "project": "zziplib-bin", "file": "fetch.pkl", "function": "__zzip_set16"}, {"comment_all": {"comment": "/* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */", "depth": 1, "reading_ease": 82.65, "reading_grade": 5.2, "line": 3685}, "comment_text": "/* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */", "comment_tokens": ["If", "b", "is", "the", "current", "buffer", ",", "then", "yy_init_buffer", "was", "_probably_", "called", "from", "yyrestart", "(", ")", "or", "through", "yy_get_next_buffer", ".", "In", "that", "case", ",", "we", "do", "n't", "want", "to", "reset", "the", "lineno", "or", "column", "."], "ccode": ["\n", "/* Initializes or reinitializes a buffer.\n", " * This function is sometimes called more than once on the same buffer,\n", " * such as during a yyrestart() or at EOF.\n", " */\n", "    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n", "\n", "{\n", "\tint oerrno = errno;\n", "    \n", "\tyy_flush_buffer( b );\n", "\n", "\tb->yy_input_file = file;\n", "\tb->yy_fill_buffer = 1;\n", "\n", "    /* If b is the current buffer, then yy_init_buffer was _probably_\n", "     * called from yyrestart() or through yy_get_next_buffer.\n", "     * In that case, we don't want to reset the lineno or column.\n", "     */\n", "    if (b != YY_CURRENT_BUFFER){\n", "        b->yy_bs_lineno = 1;\n", "        b->yy_bs_column = 0;\n", "    }\n", "\n", "        b->yy_is_interactive = 0;\n", "    \n", "\terrno = oerrno;\n", "}\n"], "project": "linux-aws-5.11-tools-5.11.0-1022", "file": "lexer.lex.pkl", "function": "yy_init_buffer"}, {"comment_all": {"comment": "/* Make sure our structure is not NULL, first. */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 107}, "comment_text": "/* Make sure our structure is not NULL, first. */", "comment_tokens": ["Make", "sure", "our", "structure", "is", "not", "NULL", ",", "first", "."], "ccode": ["\n", "\n", "/**\n", " * Free a single cgroup_group_spec structure\n", " * <--->@param cl The structure to free from memory.\n", " */\n", "void cgroup_free_group_spec(struct cgroup_group_spec *cl)\n", "{\n", "\t/* Loop variable */\n", "\tint i = 0;\n", "\n", "\t/* Make sure our structure is not NULL, first. */\n", "\tif (!cl) {\n", "\t\tcgroup_dbg(\"Warning: Attempted to free NULL rule.\\n\");\n", "\t\treturn;\n", "\t}\n", "\n", "\t/* We must free any used controller strings, too. */\n", "\tfor (i = 0; i < CG_CONTROLLER_MAX; i++) {\n", "\t\tif (cl->controllers[i])\n", "\t\t\tfree(cl->controllers[i]);\n", "\t}\n", "\n", "\tfree(cl);\n", "}\n"], "project": "libpam-cgroup", "file": "tools-common.pkl", "function": "cgroup_free_group_spec"}, {"comment_all": {"comment": "/* If name and displayname point to the same place, only free one of them */", "depth": 1, "reading_ease": 91.11, "reading_grade": 4.0, "line": 177}, "comment_text": "/* If name and displayname point to the same place, only free one of them */", "comment_tokens": ["If", "name", "and", "displayname", "point", "to", "the", "same", "place", ",", "only", "free", "one", "of", "them"], "ccode": ["\n", "static void free_reference(struct reference *ref)\n", "{\n", "\t/* If name and displayname point to the same place, only free one of them */\n", "\tif (ref->name == ref->displayname) {\n", "\t\txmlFree((void *) ref->name);\n", "\t} else {\n", "\t\txmlFree((void *) ref->name);\n", "\t\txmlFree((void *) ref->displayname);\n", "\t}\n", "\n", "\tfree(ref);\n", "}\n"], "project": "asterisk-ooh323", "file": "menuselect.pkl", "function": "free_reference"}, {"comment_all": {"comment": "/* If the file gets closed notify */", "depth": 2, "reading_ease": 90.77, "reading_grade": 2.1, "line": 199}, "comment_text": "/* If the file gets closed notify */", "comment_tokens": ["If", "the", "file", "gets", "closed", "notify"], "ccode": ["#else\n", "#define poll_check_ok(pop)\n", "#endif\n", "\n", "static int\n", "poll_dispatch(struct event_base *base, struct timeval *tv)\n", "{\n", "\tint res, i, j, nfds;\n", "\tlong msec = -1;\n", "\tstruct pollop *pop = base->evbase;\n", "\tstruct pollfd *event_set;\n", "\n", "\tpoll_check_ok(pop);\n", "\n", "\tnfds = pop->nfds;\n", "\n", "#ifndef EVENT__DISABLE_THREAD_SUPPORT\n", "\tif (base->th_base_lock) {\n", "\t\t/* If we're using this backend in a multithreaded setting,\n", "\t\t * then we need to work on a copy of event_set, so that we can\n", "\t\t * let other threads modify the main event_set while we're\n", "\t\t * polling. If we're not multithreaded, then we'll skip the\n", "\t\t * copy step here to save memory and time. */\n", "\t\tif (pop->realloc_copy) {\n", "\t\t\tstruct pollfd *tmp = mm_realloc(pop->event_set_copy,\n", "\t\t\t    pop->event_count * sizeof(struct pollfd));\n", "\t\t\tif (tmp == NULL) {\n", "\t\t\t\tevent_warn(\"realloc\");\n", "\t\t\t\treturn -1;\n", "\t\t\t}\n", "\t\t\tpop->event_set_copy = tmp;\n", "\t\t\tpop->realloc_copy = 0;\n", "\t\t}\n", "\t\tmemcpy(pop->event_set_copy, pop->event_set,\n", "\t\t    sizeof(struct pollfd)*nfds);\n", "\t\tevent_set = pop->event_set_copy;\n", "\t} else {\n", "\t\tevent_set = pop->event_set;\n", "\t}\n", "#else\n", "\tevent_set = pop->event_set;\n", "#endif\n", "\n", "\tif (tv != NULL) {\n", "\t\tmsec = evutil_tv_to_msec_(tv);\n", "\t\tif (msec < 0 || msec > INT_MAX)\n", "\t\t\tmsec = INT_MAX;\n", "\t}\n", "\n", "\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n", "\n", "\tres = poll(event_set, nfds, msec);\n", "\n", "\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n", "\n", "\tif (res == -1) {\n", "\t\tif (errno != EINTR) {\n", "\t\t\tevent_warn(\"poll\");\n", "\t\t\treturn (-1);\n", "\t\t}\n", "\n", "\t\treturn (0);\n", "\t}\n", "\n", "\tevent_debug((\"%s: poll reports %d\", __func__, res));\n", "\n", "\tif (res == 0 || nfds == 0)\n", "\t\treturn (0);\n", "\n", "\ti = evutil_weakrand_range_(&base->weakrand_seed, nfds);\n", "\tfor (j = 0; j < nfds; j++) {\n", "\t\tint what;\n", "\t\tif (++i == nfds)\n", "\t\t\ti = 0;\n", "\t\twhat = event_set[i].revents;\n", "\t\tif (!what)\n", "\t\t\tcontinue;\n", "\n", "\t\tres = 0;\n", "\n", "\t\t/* If the file gets closed notify */\n", "\t\tif (what & (POLLHUP|POLLERR|POLLNVAL))\n", "\t\t\twhat |= POLLIN|POLLOUT;\n", "\t\tif (what & POLLIN)\n", "\t\t\tres |= EV_READ;\n", "\t\tif (what & POLLOUT)\n", "\t\t\tres |= EV_WRITE;\n", "\t\tif (res == 0)\n", "\t\t\tcontinue;\n", "\n", "\t\tevmap_io_active_(base, event_set[i].fd, res);\n", "\t}\n", "\n", "\treturn (0);\n", "}\n"], "project": "libevent-dev", "file": "poll.pkl", "function": "poll_dispatch"}, {"comment_all": {"comment": "/* parse arguments of get command */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 336}, "comment_text": "/* parse arguments of get command */", "comment_tokens": ["parse", "arguments", "of", "get", "command"], "ccode": ["\n", "\n", "/* parse arguments of get command */\n", "int runget(int argc, char **argv){\n", "  char *name, *key, *kbuf;\n", "  int i, opts, kx, ki, ox, nb, start, max, ksiz, rv;\n", "  name = NULL;\n", "  opts = 0;\n", "  kx = FALSE;\n", "  ki = FALSE;\n", "  ox = FALSE;\n", "  nb = FALSE;\n", "  start = 0;\n", "  max = -1;\n", "  key = NULL;\n", "  for(i = 2; i < argc; i++){\n", "    if(!name && argv[i][0] == '-'){\n", "      if(!strcmp(argv[i], \"-nl\")){\n", "        opts |= DP_ONOLCK;\n", "      } else if(!strcmp(argv[i], \"-kx\")){\n", "        kx = TRUE;\n", "      } else if(!strcmp(argv[i], \"-ki\")){\n", "        ki = TRUE;\n", "      } else if(!strcmp(argv[i], \"-ox\")){\n", "        ox = TRUE;\n", "      } else if(!strcmp(argv[i], \"-n\")){\n", "        nb = TRUE;\n", "      } else if(!strcmp(argv[i], \"-start\")){\n", "        if(++i >= argc) usage();\n", "        start = atoi(argv[i]);\n", "      } else if(!strcmp(argv[i], \"-max\")){\n", "        if(++i >= argc) usage();\n", "        max = atoi(argv[i]);\n", "      } else {\n", "        usage();\n", "      }\n", "    } else if(!name){\n", "      name = argv[i];\n", "    } else if(!key){\n", "      key = argv[i];\n", "    } else {\n", "      usage();\n", "    }\n", "  }\n", "  if(!name || !key || start < 0) usage();\n", "  if(kx){\n", "    kbuf = hextoobj(key, &ksiz);\n", "  } else if(ki){\n", "    kbuf = dectoiobj(key, &ksiz);\n", "  } else {\n", "    kbuf = cbmemdup(key, -1);\n", "    ksiz = -1;\n", "  }\n", "  if(kbuf){\n", "    rv = doget(name, opts, kbuf, ksiz, start, max, ox, nb);\n", "  } else {\n", "    fprintf(stderr, \"%s: out of memory\\n\", progname);\n", "    rv = 1;\n", "  }\n", "  free(kbuf);\n", "  return rv;\n", "}\n"], "project": "libqdbm3++c2", "file": "dpmgr.pkl", "function": "runget"}, {"comment_all": {"comment": "/* Create the module and add the functions and documentation */", "depth": 1, "reading_ease": 45.42, "reading_grade": 9.2, "line": 682}, "comment_text": "/* Create the module and add the functions and documentation */", "comment_tokens": ["Create", "the", "module", "and", "add", "the", "functions", "and", "documentation"], "ccode": ["\n", "PyMODINIT_FUNC\n", "PyInit_fcntl(void)\n", "{\n", "    PyObject *m;\n", "\n", "    /* Create the module and add the functions and documentation */\n", "    m = PyModule_Create(&fcntlmodule);\n", "    if (m == NULL)\n", "        return NULL;\n", "\n", "    /* Add some symbolic constants to the module */\n", "    if (all_ins(m) < 0) {\n", "        Py_DECREF(m);\n", "        return NULL;\n", "    }\n", "\n", "    return m;\n", "}\n"], "project": "libpython3.9", "file": "fcntlmodule.pkl", "function": "PyInit_fcntl"}, {"comment_all": {"comment": "/* Set up array of projection types */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 650}, "comment_text": "/* Set up array of projection types */", "comment_tokens": ["Set", "up", "array", "of", "projection", "types"], "ccode": ["\n", "void\n", "setdcenter (ra, dec)\t\t/* Set center sky coordinates in degrees */\n", "double ra, dec;\n", "{ ra0 = ra; dec0 = dec; return; }\n", "\n", "void\n", "getcenter (ra, dec)\t\t/* Return initial reference sky coordinates */\n", "double *ra, *dec;\n", "{ *ra = ra0; *dec = dec0; return; }\n", "\n", "void\n", "setrefpix (x, y)\t\t/* Set reference pixel image coordinates */\n", "double x, y;\n", "{ xref0 = x; yref0 = y; return; }\n", "\n", "void\n", "getrefpix (x, y)\t\t/* Return initial ref pixel image coordinates */\n", "double *x, *y;\n", "{ *x = xref0; *y = yref0; return; }\n", "\n", "void\n", "setproj (ptype)\n", "char*\tptype;\n", "{\n", "    int i;\n", "\n", "    /* Set up array of projection types */\n", "    strcpy (ctypes[0], \"LIN\");\n", "    strcpy (ctypes[1], \"AZP\");\n", "    strcpy (ctypes[2], \"SZP\");\n", "    strcpy (ctypes[3], \"TAN\");\n", "    strcpy (ctypes[4], \"SIN\");\n", "    strcpy (ctypes[5], \"STG\");\n", "    strcpy (ctypes[6], \"ARC\");\n", "    strcpy (ctypes[7], \"ZPN\");\n", "    strcpy (ctypes[8], \"ZEA\");\n", "    strcpy (ctypes[9], \"AIR\");\n", "    strcpy (ctypes[10], \"CYP\");\n", "    strcpy (ctypes[11], \"CAR\");\n", "    strcpy (ctypes[12], \"MER\");\n", "    strcpy (ctypes[13], \"CEA\");\n", "    strcpy (ctypes[14], \"COP\");\n", "    strcpy (ctypes[15], \"COD\");\n", "    strcpy (ctypes[16], \"COE\");\n", "    strcpy (ctypes[17], \"COO\");\n", "    strcpy (ctypes[18], \"BON\");\n", "    strcpy (ctypes[19], \"PCO\");\n", "    strcpy (ctypes[20], \"SFL\");\n", "    strcpy (ctypes[21], \"PAR\");\n", "    strcpy (ctypes[22], \"AIT\");\n", "    strcpy (ctypes[23], \"MOL\");\n", "    strcpy (ctypes[24], \"CSC\");\n", "    strcpy (ctypes[25], \"QSC\");\n", "    strcpy (ctypes[26], \"TSC\");\n", "    strcpy (ctypes[27], \"NCP\");\n", "    strcpy (ctypes[28], \"GLS\");\n", "    strcpy (ctypes[29], \"DSS\");\n", "    strcpy (ctypes[30], \"PLT\");\n", "    strcpy (ctypes[31], \"TNX\");\n", "    strcpy (ctypes[32], \"ZPX\");\n", "    strcpy (ctypes[33], \"TPV\");\n", "\n", "    ptype0 = -1;\n", "    ptype[3] = (char) 0;\n", "    for (i = 0; i < nctype; i++) {\n", "\tif (!strcasecmp (ptype, ctypes[i]))\n", "\t    ptype0 = i;\n", "\t}\n", "    return;\n", "}\n"], "project": "libwcstools1", "file": "imgetwcs.pkl", "function": "setproj"}, {"comment_all": {"comment": "/* always remove this one, but we may have reinstalled another one. */", "depth": 1, "reading_ease": 68.77, "reading_grade": 6.4, "line": 221}, "comment_text": "/* always remove this one, but we may have reinstalled another one. */", "comment_tokens": ["always", "remove", "this", "one", ",", "but", "we", "may", "have", "reinstalled", "another", "one", "."], "ccode": ["\n", "static gboolean\n", "startup_timeout (void *data)\n", "{\n", "  StartupTimeoutData *std;\n", "  GSList *tmp;\n", "  GTimeVal now;\n", "  int min_timeout;\n", "\n", "  std = data;\n", "\n", "  min_timeout = STARTUP_TIMEOUT_LENGTH;\n", "\n", "  g_get_current_time (&now);\n", "\n", "  tmp = std->contexts;\n", "  while (tmp != NULL)\n", "    {\n", "      StartupNotificationData *sn_data;\n", "      GSList *next;\n", "      double elapsed;\n", "\n", "      sn_data = tmp->data;\n", "      next = tmp->next;\n", "\n", "      elapsed =\n", "        ((((double) now.tv_sec - sn_data->time.tv_sec) * G_USEC_PER_SEC +\n", "          (now.tv_usec - sn_data->time.tv_usec))) / 1000.0;\n", "\n", "      if (elapsed >= STARTUP_TIMEOUT_LENGTH)\n", "        {\n", "          std->contexts = g_slist_remove (std->contexts, sn_data);\n", "          end_startup_notification (sn_data->display, sn_data->startup_id);\n", "          free_startup_notification_data (sn_data);\n", "        }\n", "      else\n", "        {\n", "          min_timeout = MIN (min_timeout, (STARTUP_TIMEOUT_LENGTH - elapsed));\n", "        }\n", "\n", "      tmp = next;\n", "    }\n", "\n", "  if (std->contexts == NULL)\n", "    std->timeout_id = 0;\n", "  else {\n", "    std->timeout_id = g_timeout_add_seconds ((min_timeout + 500)/1000, startup_timeout, std);\n", "    g_source_set_name_by_id (std->timeout_id, \"[gtk+] startup_timeout\");\n", "  }\n", "\n", "  /* always remove this one, but we may have reinstalled another one. */\n", "  return G_SOURCE_REMOVE;\n", "}\n"], "project": "libgail-3-0", "file": "gdkapplaunchcontext-x11.pkl", "function": "startup_timeout"}, {"comment_all": {"comment": "/* store response as PAM item */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 151}, "comment_text": "/* store response as PAM item */", "comment_tokens": ["store", "response", "as", "PAM", "item"], "ccode": ["\n", "/*\n", " * Issue password prompt with challenge and receive response from user\n", " * \n", " * (based on _set_auth_tok from pam_pwdfile.c, originally based\n", " * on pam_unix/support.c but that no longer seems to exist)\n", " */\n", "static int get_response(pam_handle_t *pamh, char *challenge, int debug)\n", "{\n", "  int retval;\n", "  volatile char *p;\n", "  struct pam_message msg, *pmsg[1];\n", "  struct pam_response *resp;\n", "  char message[81];\n", "\n", "  /* format password prompt */\n", "  snprintf(message, sizeof(message), \"Password %s: \", challenge);\n", "\n", "  /* set up conversation call */\n", "  pmsg[0] = &msg;\n", "  msg.msg_style = PAM_PROMPT_ECHO_OFF;\n", "  msg.msg = message;\n", "  resp = NULL;\n", "  \n", "  /* call conversation function */\n", "  if ((retval = converse(pamh, 1, pmsg, &resp, debug)) != PAM_SUCCESS) {\n", "    /* converse has already output a warning log message here */\n", "    return retval;\n", "  }\n", "\n", "  /* error handling (just to be safe) */\n", "  if (!resp) {\n", "    log_message(LOG_WARNING, pamh, \"get_response(): resp==NULL\");\n", "    return PAM_CONV_ERR;\n", "  }\n", "  if (!resp[0].resp) {\n", "    log_message(LOG_WARNING, pamh, \"get_response(): resp[0].resp==NULL\");\n", "    free(resp);\n", "    return PAM_CONV_ERR;\n", "  }\n", "\n", "  /* store response as PAM item */\n", "  pam_set_item(pamh, PAM_AUTHTOK, resp[0].resp);\n", "  /* sanitize and free buffer */\n", "  for (p = resp[0].resp; *p; p++)\n", "    *p = 0;\n", "  free(resp[0].resp);\n", "  free(resp);\n", "\n", "  return PAM_SUCCESS;\n", "}\n"], "project": "libpam-otpw", "file": "pam_otpw.pkl", "function": "get_response"}, {"comment_all": {"comment": "/* !__linux__ */", "depth": 0, "reading_ease": 36.62, "reading_grade": 8.4, "line": 395}, "comment_text": "/* !__linux__ */\n/* Stubs that don't do anything on non-Linux systems. */\n", "comment_tokens": ["!", "__linux__", "Stubs", "that", "do", "n't", "do", "anything", "on", "non-Linux", "systems", "."], "ccode": ["#else  /* !__linux__ */\n", "/* Stubs that don't do anything on non-Linux systems. */\n", "\n", "void\n", "ovs_cmdl_proctitle_init(int argc OVS_UNUSED, char **argv OVS_UNUSED)\n", "{\n", "}\n"], "project": "openvswitch-doc", "file": "command-line.pkl", "function": "ovs_cmdl_proctitle_init"}, {"comment_all": {"comment": "/* do an entire buffer at once */", "depth": 0, "reading_ease": 90.77, "reading_grade": 2.1, "line": 205}, "comment_text": "/* do an entire buffer at once */", "comment_tokens": ["do", "an", "entire", "buffer", "at", "once"], "ccode": ["\n", "\n", "/* do an entire buffer at once */\n", "void utf8_to_local(char *d, const char *s)\n", "{\n", "    mbstate_t cs;\n", "\n", "    PROFPUSH(\"conv: utf8->local\");\n", "    memset(&cs, 0, sizeof(cs));\n", "    utf8_to_mb(&d, s, &cs);\n", "    *d=0;\n", "    PROFPOP;\n", "}\n"], "project": "kbtin", "file": "unicode.pkl", "function": "utf8_to_local"}, {"comment_all": {"comment": "/* order from closest to the border of the screen to farthest */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 774}, "comment_text": "/* order from closest to the border of the screen to farthest */", "comment_tokens": ["order", "from", "closest", "to", "the", "border", "of", "the", "screen", "to", "farthest"], "ccode": ["\n", "static void updateMoveData(WWindow * wwin, MoveData * data)\n", "{\n", "\tWScreen *scr = wwin->screen_ptr;\n", "\tWWindow *tmp;\n", "\tint i;\n", "\n", "\tdata->count = 0;\n", "\ttmp = scr->focused_window;\n", "\twhile (tmp) {\n", "\t\tif (tmp != wwin && scr->current_workspace == tmp->frame->workspace\n", "\t\t    && !tmp->flags.miniaturized\n", "\t\t    && !tmp->flags.hidden && !tmp->flags.obscured && !WFLAGP(tmp, sunken)) {\n", "\t\t\tdata->topList[data->count] = tmp;\n", "\t\t\tdata->leftList[data->count] = tmp;\n", "\t\t\tdata->rightList[data->count] = tmp;\n", "\t\t\tdata->bottomList[data->count] = tmp;\n", "\t\t\tdata->count++;\n", "\t\t}\n", "\t\ttmp = tmp->prev;\n", "\t}\n", "\n", "\tif (data->count == 0) {\n", "\t\tdata->topIndex = 0;\n", "\t\tdata->leftIndex = 0;\n", "\t\tdata->rightIndex = 0;\n", "\t\tdata->bottomIndex = 0;\n", "\t\treturn;\n", "\t}\n", "\n", "\t/* order from closest to the border of the screen to farthest */\n", "\n", "\tqsort(data->topList, data->count, sizeof(data->topList[0]), compareWTop);\n", "\tqsort(data->leftList, data->count, sizeof(data->leftList[0]), compareWLeft);\n", "\tqsort(data->rightList, data->count, sizeof(data->rightList[0]), compareWRight);\n", "\tqsort(data->bottomList, data->count, sizeof(data->bottomList[0]), compareWBottom);\n", "\n", "\t/* figure the position of the window relative to the others */\n", "\n", "\tdata->topIndex = -1;\n", "\tdata->leftIndex = -1;\n", "\tdata->rightIndex = -1;\n", "\tdata->bottomIndex = -1;\n", "\n", "\tif (WTOP(wwin) < WBOTTOM(data->bottomList[0])) {\n", "\t\tdata->bottomIndex = 0;\n", "\t}\n", "\tif (WLEFT(wwin) < WRIGHT(data->rightList[0])) {\n", "\t\tdata->rightIndex = 0;\n", "\t}\n", "\tif (WRIGHT(wwin) > WLEFT(data->leftList[0])) {\n", "\t\tdata->leftIndex = 0;\n", "\t}\n", "\tif (WBOTTOM(wwin) > WTOP(data->topList[0])) {\n", "\t\tdata->topIndex = 0;\n", "\t}\n", "\tfor (i = 0; i < data->count; i++) {\n", "\t\tif (WTOP(wwin) >= WBOTTOM(data->bottomList[i])) {\n", "\t\t\tdata->bottomIndex = i + 1;\n", "\t\t}\n", "\t\tif (WLEFT(wwin) >= WRIGHT(data->rightList[i])) {\n", "\t\t\tdata->rightIndex = i + 1;\n", "\t\t}\n", "\t\tif (WRIGHT(wwin) <= WLEFT(data->leftList[i])) {\n", "\t\t\tdata->leftIndex = i + 1;\n", "\t\t}\n", "\t\tif (WBOTTOM(wwin) <= WTOP(data->topList[i])) {\n", "\t\t\tdata->topIndex = i + 1;\n", "\t\t}\n", "\t}\n", "}\n"], "project": "wmaker-common", "file": "moveres.pkl", "function": "updateMoveData"}, {"comment_all": {"comment": "/*\n * Insert a glob match.\n * If there were words to prepend given by the P glob qualifier, do so.\n */", "depth": 0, "reading_ease": 87.72, "reading_grade": 3.3, "line": 1090}, "comment_text": "/*\n * Insert a glob match.\n * If there were words to prepend given by the P glob qualifier, do so.\n */", "comment_tokens": ["Insert", "a", "glob", "match", ".", "If", "there", "were", "words", "to", "prepend", "given", "by", "the", "P", "glob", "qualifier", ",", "do", "so", "."], "ccode": ["\n", "/*\n", " * Insert a glob match.\n", " * If there were words to prepend given by the P glob qualifier, do so.\n", " */\n", "static void\n", "insert_glob_match(LinkList list, LinkNode next, char *data)\n", "{\n", "    if (gf_pre_words) {\n", "\tLinkNode added;\n", "\tfor (added = firstnode(gf_pre_words); added; incnode(added)) {\n", "\t    next = insertlinknode(list, next, dupstring(getdata(added)));\n", "\t}\n", "    }\n", "\n", "    next = insertlinknode(list, next, data);\n", "\n", "    if (gf_post_words) {\n", "\tLinkNode added;\n", "\tfor (added = firstnode(gf_post_words); added; incnode(added)) {\n", "\t    next = insertlinknode(list, next, dupstring(getdata(added)));\n", "\t}\n", "    }\n", "}\n"], "project": "zsh-static", "file": "glob.pkl", "function": "insert_glob_match"}, {"comment_all": {"comment": "/* ===========================================================================\n * Write out any remaining bits in an incomplete byte.\n */", "depth": 0, "reading_ease": 79.26, "reading_grade": 4.4, "line": 1908}, "comment_text": "/* ===========================================================================\n * Write out any remaining bits in an incomplete byte.\n */", "comment_tokens": ["===========================================================================", "Write", "out", "any", "remaining", "bits", "in", "an", "incomplete", "byte", "."], "ccode": ["\n", "/* ===========================================================================\n", " * Write out any remaining bits in an incomplete byte.\n", " */\n", "local void bi_windup(DeflateHandler encoder)\n", "{\n", "    if(encoder->bi_valid > 8) {\n", "\tput_short(encoder->bi_buf);\n", "    } else if(encoder->bi_valid > 0) {\n", "\tput_byte(encoder->bi_buf);\n", "    }\n", "    encoder->bi_buf = 0;\n", "    encoder->bi_valid = 0;\n", "}\n"], "project": "timidity", "file": "deflate.pkl", "function": "bi_windup"}, {"comment_all": {"comment": "/* Counts digrams, sorts them, and loads the top `tgt_size` into tgt[] */", "depth": 0, "reading_ease": 85.69, "reading_grade": 4.0, "line": 51}, "comment_text": "/* Counts digrams, sorts them, and loads the top `tgt_size` into tgt[] */", "comment_tokens": ["Counts", "digrams", ",", "sorts", "them", ",", "and", "loads", "the", "top", "`", "tgt_size", "`", "into", "tgt", "[", "]"], "ccode": ["\n", "/* Counts digrams, sorts them, and loads the top `tgt_size` into tgt[] */\n", "void count_digrams(char *text, int input_size, digram *tgt, int tgt_size)\n", "{\n", "  int i, h, j, ch1, ch2;\n", "  digram digrams[26 * 26];\n", "\n", "  /* Setup */\n", "  h = 0;\n", "  for (i = 0; i < 26; i++) for (j = 0; j < 26; j++) \n", "  {\n", "    digrams[h].digram_ch1 = i;\n", "    digrams[h].digram_ch2 = j;\n", "    digrams[h].digram_value = 0;\n", "    h++;\n", "  }\n", "\n", "  /* Count */\n", "  h = input_size - 1;\n", "  for (i = 0; i < h; i++)\n", "  {\n", "    ch1 = CHARNUM(*(text + i));\n", "    ch2 = CHARNUM(*(text + i + 1));\n", "\n", "    if (ch1 != -1 && ch2 != -1)   digrams[((ch1 * 26) + ch2)].digram_value++;\n", "  }\n", "\n", "  /* No point sorting if we only want one */\n", "  if (tgt_size == 1)\n", "  {\n", "    tgt[0] = best_digram(digrams, 26 * 26);\n", "    return;\n", "  }\n", "\n", "  /* Sort */\n", "  insertion_sort_digram(digrams, 26 * 26);\n", "\n", "  /* Grab the top few */\n", "  j = min(tgt_size, 26 * 26);\n", "  for (i = 0; i < j; i++)\n", "  {\n", "    h = (26 * 26) - 1 - i;\n", "    tgt[i] = digrams[h];\n", "  }\n", "}\n"], "project": "cifer", "file": "frequency_data.pkl", "function": "count_digrams"}, {"comment_all": {"comment": "//av_log(NULL, AV_LOG_DEBUG, \"%d %d %d\\n\", c->dst_incr, c->ideal_dst_incr, c->compensation_distance);\n", "depth": 2, "reading_ease": 4.14, "reading_grade": 14.7, "line": 338}, "comment_text": "//av_log(NULL, AV_LOG_DEBUG, \"%d %d %d\\n\", c->dst_incr, c->ideal_dst_incr, c->compensation_distance);\n", "comment_tokens": ["av_log", "(", "NULL", ",", "AV_LOG_DEBUG", ",", "``", "%", "d", "%", "d", "%", "d\\n", "''", ",", "c-", ">", "dst_incr", ",", "c-", ">", "ideal_dst_incr", ",", "c-", ">", "compensation_distance", ")", ";"], "ccode": ["\n", "/**\n", " * resamples.\n", " * @param src an array of unconsumed samples\n", " * @param consumed the number of samples of src which have been consumed are returned here\n", " * @param src_size the number of unconsumed samples available\n", " * @param dst_size the amount of space in samples available in dst\n", " * @param update_ctx if this is 0 then the context wont be modified, that way several channels can be resampled with the same context\n", " * @return the number of samples written in dst or -1 if an error occured\n", " */\n", "int av_resample(AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx){\n", "    int dst_index, i;\n", "    int index= c->index;\n", "    int frac= c->frac;\n", "    int dst_incr_frac= c->dst_incr % c->src_incr;\n", "    int dst_incr=      c->dst_incr / c->src_incr;\n", "    int compensation_distance= c->compensation_distance;\n", "\n", "  if(compensation_distance == 0 && c->filter_length == 1 && c->phase_shift==0){\n", "        int64_t index2= ((int64_t)index)<<32;\n", "        int64_t incr= (1LL<<32) * c->dst_incr / c->src_incr;\n", "        dst_size= FFMIN(dst_size, (src_size-1-index) * (int64_t)c->src_incr / c->dst_incr);\n", "\n", "        for(dst_index=0; dst_index < dst_size; dst_index++){\n", "            dst[dst_index] = src[index2>>32];\n", "            index2 += incr;\n", "        }\n", "        frac += dst_index * dst_incr_frac;\n", "        index += dst_index * dst_incr;\n", "        index += frac / c->src_incr;\n", "        frac %= c->src_incr;\n", "  }else{\n", "    for(dst_index=0; dst_index < dst_size; dst_index++){\n", "        FELEM *filter= c->filter_bank + c->filter_length*(index & c->phase_mask);\n", "        int sample_index= index >> c->phase_shift;\n", "        FELEM2 val=0;\n", "\n", "        if(sample_index < 0){\n", "            for(i=0; i<c->filter_length; i++)\n", "                val += src[FFABS(sample_index + i) % src_size] * filter[i];\n", "        }else if(sample_index + c->filter_length > src_size){\n", "            break;\n", "        }else if(c->linear){\n", "            FELEM2 v2=0;\n", "            for(i=0; i<c->filter_length; i++){\n", "                val += src[sample_index + i] * (FELEM2)filter[i];\n", "                v2  += src[sample_index + i] * (FELEM2)filter[i + c->filter_length];\n", "            }\n", "            val+=(v2-val)*(FELEML)frac / c->src_incr;\n", "        }else{\n", "            for(i=0; i<c->filter_length; i++){\n", "                val += src[sample_index + i] * (FELEM2)filter[i];\n", "            }\n", "        }\n", "\n", "#ifdef CONFIG_RESAMPLE_AUDIOPHILE_KIDDY_MODE\n", "        dst[dst_index] = av_clip_int16(lrintf(val));\n", "#else\n", "        val = (val + (1<<(FILTER_SHIFT-1)))>>FILTER_SHIFT;\n", "        dst[dst_index] = (unsigned)(val + 32768) > 65535 ? (val>>31) ^ 32767 : val;\n", "#endif\n", "\n", "        frac += dst_incr_frac;\n", "        index += dst_incr;\n", "        if(frac >= c->src_incr){\n", "            frac -= c->src_incr;\n", "            index++;\n", "        }\n", "\n", "        if(dst_index + 1 == compensation_distance){\n", "            compensation_distance= 0;\n", "            dst_incr_frac= c->ideal_dst_incr % c->src_incr;\n", "            dst_incr=      c->ideal_dst_incr / c->src_incr;\n", "        }\n", "    }\n", "  }\n", "    *consumed= FFMAX(index, 0) >> c->phase_shift;\n", "    if(index>=0) index &= c->phase_mask;\n", "\n", "    if(compensation_distance){\n", "        compensation_distance -= dst_index;\n", "        if(!(compensation_distance > 0)) return(-1);\n", "    }\n", "    if(update_ctx){\n", "        c->frac= frac;\n", "        c->index= index;\n", "        c->dst_incr= dst_incr_frac + c->src_incr*dst_incr;\n", "        c->compensation_distance= compensation_distance;\n", "    }\n", "#if 0\n", "    if(update_ctx && !c->compensation_distance){\n", "#undef rand\n", "        av_resample_compensate(c, rand() % (8000*2) - 8000, 8000*2);\n", "//av_log(NULL, AV_LOG_DEBUG, \"%d %d %d\\n\", c->dst_incr, c->ideal_dst_incr, c->compensation_distance);\n", "    }\n", "#endif\n", "\n", "    return dst_index;\n", "}\n"], "project": "dtmf2num", "file": "resample2.pkl", "function": "av_resample"}, {"comment_all": {"comment": "/*\n             * now find median by (shell-)sorting the arrays and\n             * picking the center value\n             */", "depth": 3, "reading_ease": 50.84, "reading_grade": 9.2, "line": 926}, "comment_text": "/*\n             * now find median by (shell-)sorting the arrays and\n             * picking the center value\n             */", "comment_tokens": ["now", "find", "median", "by", "(", "shell-", ")", "sorting", "the", "arrays", "and", "picking", "the", "center", "value"], "ccode": ["\n", "\n", "#define SWAP(a, b)\t{ int t = (a); (a) = (b); (b) = t; }\n", "\n", "void\n", "ImageDespeckle (gpaint_image * input, gpaint_image * output)\n", "{\n", "    int width = image_width (input);\n", "    int height = image_height (input);\n", "\n", "    unsigned char *op, *rgb;\n", "    int x, y, xx, yy, mask, mask2, i, j, k, l;\n", "    int *ra, *ga, *ba;\n", "\n", "    mask = ImgProcessInfo.despeckleMask;\n", "    if (mask > width)\n", "        mask = width;\n", "    if (mask > height)\n", "        mask = height;\n", "    mask2 = mask / 2;\n", "\n", "    /* arrays for storing pixels inside mask */\n", "    ra = malloc (mask * mask * sizeof (int));\n", "    ga = malloc (mask * mask * sizeof (int));\n", "    ba = malloc (mask * mask * sizeof (int));\n", "\n", "    op = image_pixels (output);\n", "    for (y = 0; y < height; ++y)\n", "    {\n", "        for (x = 0; x < width; ++x)\n", "        {\n", "            i = 0;\n", "            for (yy = MAX (0, y - mask2); yy < MIN (height, y + mask2); ++yy)\n", "                for (xx = MAX (0, x - mask2); xx < MIN (width, x + mask2);\n", "                     ++xx)\n", "                {\n", "                    rgb = ImagePixel (input, xx, yy);\n", "                    ra[i] = *rgb++;\n", "                    ga[i] = *rgb++;\n", "                    ba[i] = *rgb;\n", "                    ++i;\n", "                }\n", "            /*\n", "             * now find median by (shell-)sorting the arrays and\n", "             * picking the center value\n", "             */\n", "            for (j = i / 2; j > 0; j = j / 2)\n", "                for (k = j; k < i; k++)\n", "                {\n", "                    for (l = k - j; l >= 0 && ra[l] > ra[l + j]; l -= j)\n", "                        SWAP (ra[l], ra[l + j]);\n", "                    for (l = k - j; l >= 0 && ga[l] > ga[l + j]; l -= j)\n", "                        SWAP (ga[l], ga[l + j]);\n", "                    for (l = k - j; l >= 0 && ba[l] > ba[l + j]; l -= j)\n", "                        SWAP (ba[l], ba[l + j]);\n", "                }\n", "            if (i & 1)\n", "            {                   /* uneven number of data points */\n", "                *op++ = ra[i / 2];\n", "                *op++ = ga[i / 2];\n", "                *op++ = ba[i / 2];\n", "            }\n", "            else\n", "            {                   /* even, take average */\n", "                *op++ = (ra[i / 2 - 1] + ra[i / 2]) / 2;\n", "                *op++ = (ga[i / 2 - 1] + ga[i / 2]) / 2;\n", "                *op++ = (ba[i / 2 - 1] + ba[i / 2]) / 2;\n", "            }\n", "            op += image_pixelsize (output) - 3;\n", "        }\n", "        if (y % 16 == 0)\n", "            StateTimeStep ();\n", "        op += image_rowstride (output) - width * image_pixelsize (output);\n", "\n", "    }\n", "\n", "    free (ra);\n", "    free (ga);\n", "    free (ba);\n", "\n", "\n", "}\n"], "project": "gpaint", "file": "image_processing.pkl", "function": "ImageDespeckle"}, {"comment_all": {"comment": "// Print(L\"Got argc/argv from shell params proto\\n\");\n", "depth": 2, "reading_ease": 90.77, "reading_grade": 2.1, "line": 113}, "comment_text": "// Print(L\"Got argc/argv from shell params proto\\n\");\n", "comment_tokens": ["Print", "(", "L", "''", "Got", "argcargv", "from", "shell", "params", "proto\\n", "''", ")", ";"], "ccode": ["\n", "INTN GetShellArgcArgv(EFI_HANDLE ImageHandle, CHAR16 **Argv[])\n", "{\n", "  // Code inspired from EDK2's\n", "  // ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.c (BSD)\n", "  EFI_STATUS Status;\n", "  static const EFI_GUID EfiShellParametersProtocolGuid\n", "      = EFI_SHELL_PARAMETERS_PROTOCOL_GUID;\n", "  static const EFI_GUID ShellInterfaceProtocolGuid\n", "      = SHELL_INTERFACE_PROTOCOL_GUID;\n", "  EFI_SHELL_PARAMETERS_PROTOCOL *EfiShellParametersProtocol = NULL;\n", "  EFI_SHELL_INTERFACE *EfiShellInterfaceProtocol = NULL;\n", "\n", "  Status = uefi_call_wrapper(BS->OpenProtocol, 6,\n", "                             ImageHandle,\n", "                             (EFI_GUID*)&EfiShellParametersProtocolGuid,\n", "                             (VOID **)&EfiShellParametersProtocol,\n", "                             ImageHandle,\n", "                             NULL,\n", "                             EFI_OPEN_PROTOCOL_GET_PROTOCOL\n", "                             );\n", "  if (!EFI_ERROR(Status))\n", "  {\n", "    // use shell 2.0 interface\n", "    // Print(L\"Got argc/argv from shell intf proto\\n\");\n", "    *Argv = EfiShellParametersProtocol->Argv;\n", "    return EfiShellParametersProtocol->Argc;\n", "  }\n", "\n", "  // try to get shell 1.0 interface instead.\n", "  Status = uefi_call_wrapper(BS->OpenProtocol, 6,\n", "                             ImageHandle,\n", "                             (EFI_GUID*)&ShellInterfaceProtocolGuid,\n", "                             (VOID **)&EfiShellInterfaceProtocol,\n", "                             ImageHandle,\n", "                             NULL,\n", "                             EFI_OPEN_PROTOCOL_GET_PROTOCOL\n", "                             );\n", "  if (!EFI_ERROR(Status))\n", "  {\n", "    // Print(L\"Got argc/argv from shell params proto\\n\");\n", "    *Argv = EfiShellInterfaceProtocol->Argv;\n", "    return EfiShellInterfaceProtocol->Argc;\n", "  }\n", "\n", "  // shell 1.0 and 2.0 interfaces failed\n", "  return GetShellArgcArgvFromLoadedImage(ImageHandle, Argv);\n", "}\n"], "project": "gnu-efi", "file": "cmdline.pkl", "function": "GetShellArgcArgv"}, {"comment_all": {"comment": "/* parsing a Way (callback function)*/", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 86}, "comment_text": "/* parsing a Way (callback function)*/", "comment_tokens": ["parsing", "a", "Way", "(", "callback", "function", ")"], "ccode": ["\n", "static int\n", "parse_way (const void *user_data, const readosm_way * way)\n", "{\n", "/* parsing a Way (callback function)*/\n", "\n", "    /* casting the USER_DATA pointer to osm_helper */\n", "    struct osm_helper *helper = (struct osm_helper *) user_data;\n", "\n", "    if (way != NULL)\n", "\tway = NULL;\t\t/* silencing stupid compiler warnings */\n", "\n", "    helper->read_count++;\n", "    if (eval_abort (helper))\n", "\treturn READOSM_ABORT;\n", "    printf (\"Way#%d\\n\", helper->read_count);\n", "    return READOSM_OK;\n", "}\n"], "project": "libreadosm1", "file": "test_osm3.pkl", "function": "parse_way"}, {"comment_all": {"comment": "/*\n * avl_search:\n * Return a pointer to a node with the given item in the tree.\n * If no such item is in the tree, then NULL is returned.\n */", "depth": 0, "reading_ease": 92.12, "reading_grade": 3.6, "line": 167}, "comment_text": "/*\n * avl_search:\n * Return a pointer to a node with the given item in the tree.\n * If no such item is in the tree, then NULL is returned.\n */", "comment_tokens": ["avl_search", ":", "Return", "a", "pointer", "to", "a", "node", "with", "the", "given", "item", "in", "the", "tree", ".", "If", "no", "such", "item", "is", "in", "the", "tree", ",", "then", "NULL", "is", "returned", "."], "ccode": ["\n", "/*\n", " * avl_search:\n", " * Return a pointer to a node with the given item in the tree.\n", " * If no such item is in the tree, then NULL is returned.\n", " */\n", "avl_node_t *avl_search(const avl_tree_t *avltree, const void *item) {\n", "\tavl_node_t *node;\n", "\treturn avl_search_closest(avltree, item, &node) ? NULL : node;\n", "}\n"], "project": "libavl1", "file": "avl.pkl", "function": "avl_search"}, {"comment_all": {"comment": "/*! \\brief Finds a category with the given name or creates it if not found */", "depth": 0, "reading_ease": 74.19, "reading_grade": 6.4, "line": 152}, "comment_text": "/*! \\brief Finds a category with the given name or creates it if not found */", "comment_tokens": ["!", "\\brief", "Finds", "a", "category", "with", "the", "given", "name", "or", "creates", "it", "if", "not", "found"], "ccode": ["\n", "/*! \\brief Finds a category with the given name or creates it if not found */\n", "static struct category *category_find_or_create(const char *name)\n", "{\n", "\tstruct category *c;\n", "\n", "\tAST_LIST_TRAVERSE(&categories, c, list) {\n", "\t\tif (!strcmp(c->name, name)) {\n", "\t\t\txmlFree((void *) name);\n", "\t\t\treturn c;\n", "\t\t}\n", "\t}\n", "\n", "\tif (!(c = calloc(1, sizeof(*c)))) {\n", "\t\treturn NULL;\n", "\t}\n", "\n", "\tc->name = name;\n", "\n", "\tAST_LIST_INSERT_TAIL(&categories, c, list);\n", "\n", "\treturn c;\n", "}\n"], "project": "asterisk-dahdi", "file": "menuselect.pkl", "function": "category_find_or_create"}, {"comment_all": {"comment": "/* Generated by: ../../../genfft/gen_notw.native -compact -variables 4 -pipeline-latency 4 -n 64 -name n1_64 -include dft/scalar/n.h */", "depth": 0, "reading_ease": 40.35, "reading_grade": 11.1, "line": 1558}, "comment_text": "/* Generated by: ../../../genfft/gen_notw.native -compact -variables 4 -pipeline-latency 4 -n 64 -name n1_64 -include dft/scalar/n.h */", "comment_tokens": ["Generated", "by", ":", "......", "genfftgen_notw.native", "-compact", "-variables", "4", "-pipeline-latency", "4", "-n", "64", "-name", "n1_64", "-include", "dftscalarn.h"], "ccode": ["\n", "#else\n", "\n", "/* Generated by: ../../../genfft/gen_notw.native -compact -variables 4 -pipeline-latency 4 -n 64 -name n1_64 -include dft/scalar/n.h */\n", "\n", "/*\n", " * This function contains 912 FP additions, 248 FP multiplications,\n", " * (or, 808 additions, 144 multiplications, 104 fused multiply/add),\n", " * 172 stack variables, 15 constants, and 256 memory accesses\n", " */\n", "#include \"dft/scalar/n.h\"\n", "\n", "static void n1_64(const R *ri, const R *ii, R *ro, R *io, stride is, stride os, INT v, INT ivs, INT ovs)\n", "{\n", "     DK(KP773010453, +0.773010453362736960810906609758469800971041293);\n", "     DK(KP634393284, +0.634393284163645498215171613225493370675687095);\n", "     DK(KP098017140, +0.098017140329560601994195563888641845861136673);\n", "     DK(KP995184726, +0.995184726672196886244836953109479921575474869);\n", "     DK(KP881921264, +0.881921264348355029712756863660388349508442621);\n", "     DK(KP471396736, +0.471396736825997648556387625905254377657460319);\n", "     DK(KP290284677, +0.290284677254462367636192375817395274691476278);\n", "     DK(KP956940335, +0.956940335732208864935797886980269969482849206);\n", "     DK(KP831469612, +0.831469612302545237078788377617905756738560812);\n", "     DK(KP555570233, +0.555570233019602224742830813948532874374937191);\n", "     DK(KP195090322, +0.195090322016128267848284868477022240927691618);\n", "     DK(KP980785280, +0.980785280403230449126182236134239036973933731);\n", "     DK(KP923879532, +0.923879532511286756128183189396788286822416626);\n", "     DK(KP382683432, +0.382683432365089771728459984030398866761344562);\n", "     DK(KP707106781, +0.707106781186547524400844362104849039284835938);\n", "     {\n", "\t  INT i;\n", "\t  for (i = v; i > 0; i = i - 1, ri = ri + ivs, ii = ii + ivs, ro = ro + ovs, io = io + ovs, MAKE_VOLATILE_STRIDE(256, is), MAKE_VOLATILE_STRIDE(256, os)) {\n", "\t       E T37, T7B, T8F, T5Z, Tf, Td9, TbB, TcB, T62, T7C, T2i, TdH, Tah, Tcb, T3e;\n", "\t       E T8G, Tu, TdI, Tak, TbD, Tan, TbC, T2x, Tda, T3m, T65, T7G, T8J, T7J, T8I;\n", "\t       E T3t, T64, TK, Tdd, Tas, Tce, Tav, Tcf, T2N, Tdc, T3G, T6G, T7O, T9k, T7R;\n", "\t       E T9l, T3N, T6H, T1L, Tdv, Tbs, Tcw, TdC, Teo, T5j, T6V, T5Q, T6Y, T8y, T9C;\n", "\t       E Tbb, Tct, T8n, T9z, TZ, Tdf, Taz, Tch, TaC, Tci, T32, Tdg, T3Z, T6J, T7V;\n", "\t       E T9n, T7Y, T9o, T46, T6K, T1g, Tdp, Tb1, Tcm, Tdm, Tej, T4q, T6R, T4X, T6O;\n", "\t       E T8f, T9s, TaK, Tcp, T84, T9v, T1v, Tdn, Tb4, Tcq, Tds, Tek, T4N, T6P, T50;\n", "\t       E T6S, T8i, T9w, TaV, Tcn, T8b, T9t, T20, TdD, Tbv, Tcu, Tdy, Tep, T5G, T6Z;\n", "\t       E T5T, T6W, T8B, T9A, Tbm, Tcx, T8u, T9D;\n", "\t       {\n", "\t\t    E T3, T35, T26, T5Y, T6, T5X, T29, T36, Ta, T39, T2d, T38, Td, T3b, T2g;\n", "\t\t    E T3c;\n", "\t\t    {\n", "\t\t\t E T1, T2, T24, T25;\n", "\t\t\t T1 = ri[0];\n", "\t\t\t T2 = ri[WS(is, 32)];\n", "\t\t\t T3 = T1 + T2;\n", "\t\t\t T35 = T1 - T2;\n", "\t\t\t T24 = ii[0];\n", "\t\t\t T25 = ii[WS(is, 32)];\n", "\t\t\t T26 = T24 + T25;\n", "\t\t\t T5Y = T24 - T25;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4, T5, T27, T28;\n", "\t\t\t T4 = ri[WS(is, 16)];\n", "\t\t\t T5 = ri[WS(is, 48)];\n", "\t\t\t T6 = T4 + T5;\n", "\t\t\t T5X = T4 - T5;\n", "\t\t\t T27 = ii[WS(is, 16)];\n", "\t\t\t T28 = ii[WS(is, 48)];\n", "\t\t\t T29 = T27 + T28;\n", "\t\t\t T36 = T27 - T28;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T8, T9, T2b, T2c;\n", "\t\t\t T8 = ri[WS(is, 8)];\n", "\t\t\t T9 = ri[WS(is, 40)];\n", "\t\t\t Ta = T8 + T9;\n", "\t\t\t T39 = T8 - T9;\n", "\t\t\t T2b = ii[WS(is, 8)];\n", "\t\t\t T2c = ii[WS(is, 40)];\n", "\t\t\t T2d = T2b + T2c;\n", "\t\t\t T38 = T2b - T2c;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tb, Tc, T2e, T2f;\n", "\t\t\t Tb = ri[WS(is, 56)];\n", "\t\t\t Tc = ri[WS(is, 24)];\n", "\t\t\t Td = Tb + Tc;\n", "\t\t\t T3b = Tb - Tc;\n", "\t\t\t T2e = ii[WS(is, 56)];\n", "\t\t\t T2f = ii[WS(is, 24)];\n", "\t\t\t T2g = T2e + T2f;\n", "\t\t\t T3c = T2e - T2f;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7, Te, T2a, T2h;\n", "\t\t\t T37 = T35 - T36;\n", "\t\t\t T7B = T35 + T36;\n", "\t\t\t T8F = T5Y - T5X;\n", "\t\t\t T5Z = T5X + T5Y;\n", "\t\t\t T7 = T3 + T6;\n", "\t\t\t Te = Ta + Td;\n", "\t\t\t Tf = T7 + Te;\n", "\t\t\t Td9 = T7 - Te;\n", "\t\t\t {\n", "\t\t\t      E Tbz, TbA, T60, T61;\n", "\t\t\t      Tbz = T26 - T29;\n", "\t\t\t      TbA = Td - Ta;\n", "\t\t\t      TbB = Tbz - TbA;\n", "\t\t\t      TcB = TbA + Tbz;\n", "\t\t\t      T60 = T3b - T3c;\n", "\t\t\t      T61 = T39 + T38;\n", "\t\t\t      T62 = KP707106781 * (T60 - T61);\n", "\t\t\t      T7C = KP707106781 * (T61 + T60);\n", "\t\t\t }\n", "\t\t\t T2a = T26 + T29;\n", "\t\t\t T2h = T2d + T2g;\n", "\t\t\t T2i = T2a + T2h;\n", "\t\t\t TdH = T2a - T2h;\n", "\t\t\t {\n", "\t\t\t      E Taf, Tag, T3a, T3d;\n", "\t\t\t      Taf = T3 - T6;\n", "\t\t\t      Tag = T2d - T2g;\n", "\t\t\t      Tah = Taf - Tag;\n", "\t\t\t      Tcb = Taf + Tag;\n", "\t\t\t      T3a = T38 - T39;\n", "\t\t\t      T3d = T3b + T3c;\n", "\t\t\t      T3e = KP707106781 * (T3a - T3d);\n", "\t\t\t      T8G = KP707106781 * (T3a + T3d);\n", "\t\t\t }\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Ti, T3j, T2l, T3h, Tl, T3g, T2o, T3k, Tp, T3q, T2s, T3o, Ts, T3n, T2v;\n", "\t\t    E T3r;\n", "\t\t    {\n", "\t\t\t E Tg, Th, T2j, T2k;\n", "\t\t\t Tg = ri[WS(is, 4)];\n", "\t\t\t Th = ri[WS(is, 36)];\n", "\t\t\t Ti = Tg + Th;\n", "\t\t\t T3j = Tg - Th;\n", "\t\t\t T2j = ii[WS(is, 4)];\n", "\t\t\t T2k = ii[WS(is, 36)];\n", "\t\t\t T2l = T2j + T2k;\n", "\t\t\t T3h = T2j - T2k;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tj, Tk, T2m, T2n;\n", "\t\t\t Tj = ri[WS(is, 20)];\n", "\t\t\t Tk = ri[WS(is, 52)];\n", "\t\t\t Tl = Tj + Tk;\n", "\t\t\t T3g = Tj - Tk;\n", "\t\t\t T2m = ii[WS(is, 20)];\n", "\t\t\t T2n = ii[WS(is, 52)];\n", "\t\t\t T2o = T2m + T2n;\n", "\t\t\t T3k = T2m - T2n;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tn, To, T2q, T2r;\n", "\t\t\t Tn = ri[WS(is, 60)];\n", "\t\t\t To = ri[WS(is, 28)];\n", "\t\t\t Tp = Tn + To;\n", "\t\t\t T3q = Tn - To;\n", "\t\t\t T2q = ii[WS(is, 60)];\n", "\t\t\t T2r = ii[WS(is, 28)];\n", "\t\t\t T2s = T2q + T2r;\n", "\t\t\t T3o = T2q - T2r;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tq, Tr, T2t, T2u;\n", "\t\t\t Tq = ri[WS(is, 12)];\n", "\t\t\t Tr = ri[WS(is, 44)];\n", "\t\t\t Ts = Tq + Tr;\n", "\t\t\t T3n = Tq - Tr;\n", "\t\t\t T2t = ii[WS(is, 12)];\n", "\t\t\t T2u = ii[WS(is, 44)];\n", "\t\t\t T2v = T2t + T2u;\n", "\t\t\t T3r = T2t - T2u;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tm, Tt, Tai, Taj;\n", "\t\t\t Tm = Ti + Tl;\n", "\t\t\t Tt = Tp + Ts;\n", "\t\t\t Tu = Tm + Tt;\n", "\t\t\t TdI = Tt - Tm;\n", "\t\t\t Tai = T2l - T2o;\n", "\t\t\t Taj = Ti - Tl;\n", "\t\t\t Tak = Tai - Taj;\n", "\t\t\t TbD = Taj + Tai;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tal, Tam, T2p, T2w;\n", "\t\t\t Tal = Tp - Ts;\n", "\t\t\t Tam = T2s - T2v;\n", "\t\t\t Tan = Tal + Tam;\n", "\t\t\t TbC = Tal - Tam;\n", "\t\t\t T2p = T2l + T2o;\n", "\t\t\t T2w = T2s + T2v;\n", "\t\t\t T2x = T2p + T2w;\n", "\t\t\t Tda = T2p - T2w;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T3i, T3l, T7E, T7F;\n", "\t\t\t T3i = T3g + T3h;\n", "\t\t\t T3l = T3j - T3k;\n", "\t\t\t T3m = FNMS(KP923879532, T3l, KP382683432 * T3i);\n", "\t\t\t T65 = FMA(KP923879532, T3i, KP382683432 * T3l);\n", "\t\t\t T7E = T3h - T3g;\n", "\t\t\t T7F = T3j + T3k;\n", "\t\t\t T7G = FNMS(KP382683432, T7F, KP923879532 * T7E);\n", "\t\t\t T8J = FMA(KP382683432, T7E, KP923879532 * T7F);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7H, T7I, T3p, T3s;\n", "\t\t\t T7H = T3o - T3n;\n", "\t\t\t T7I = T3q + T3r;\n", "\t\t\t T7J = FMA(KP923879532, T7H, KP382683432 * T7I);\n", "\t\t\t T8I = FNMS(KP382683432, T7H, KP923879532 * T7I);\n", "\t\t\t T3p = T3n + T3o;\n", "\t\t\t T3s = T3q - T3r;\n", "\t\t\t T3t = FMA(KP382683432, T3p, KP923879532 * T3s);\n", "\t\t\t T64 = FNMS(KP923879532, T3p, KP382683432 * T3s);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Ty, T3H, T2B, T3x, TB, T3w, T2E, T3I, TI, T3L, T2L, T3B, TF, T3K, T2I;\n", "\t\t    E T3E;\n", "\t\t    {\n", "\t\t\t E Tw, Tx, T2C, T2D;\n", "\t\t\t Tw = ri[WS(is, 2)];\n", "\t\t\t Tx = ri[WS(is, 34)];\n", "\t\t\t Ty = Tw + Tx;\n", "\t\t\t T3H = Tw - Tx;\n", "\t\t\t {\n", "\t\t\t      E T2z, T2A, Tz, TA;\n", "\t\t\t      T2z = ii[WS(is, 2)];\n", "\t\t\t      T2A = ii[WS(is, 34)];\n", "\t\t\t      T2B = T2z + T2A;\n", "\t\t\t      T3x = T2z - T2A;\n", "\t\t\t      Tz = ri[WS(is, 18)];\n", "\t\t\t      TA = ri[WS(is, 50)];\n", "\t\t\t      TB = Tz + TA;\n", "\t\t\t      T3w = Tz - TA;\n", "\t\t\t }\n", "\t\t\t T2C = ii[WS(is, 18)];\n", "\t\t\t T2D = ii[WS(is, 50)];\n", "\t\t\t T2E = T2C + T2D;\n", "\t\t\t T3I = T2C - T2D;\n", "\t\t\t {\n", "\t\t\t      E TG, TH, T3z, T2J, T2K, T3A;\n", "\t\t\t      TG = ri[WS(is, 58)];\n", "\t\t\t      TH = ri[WS(is, 26)];\n", "\t\t\t      T3z = TG - TH;\n", "\t\t\t      T2J = ii[WS(is, 58)];\n", "\t\t\t      T2K = ii[WS(is, 26)];\n", "\t\t\t      T3A = T2J - T2K;\n", "\t\t\t      TI = TG + TH;\n", "\t\t\t      T3L = T3z + T3A;\n", "\t\t\t      T2L = T2J + T2K;\n", "\t\t\t      T3B = T3z - T3A;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E TD, TE, T3C, T2G, T2H, T3D;\n", "\t\t\t      TD = ri[WS(is, 10)];\n", "\t\t\t      TE = ri[WS(is, 42)];\n", "\t\t\t      T3C = TD - TE;\n", "\t\t\t      T2G = ii[WS(is, 10)];\n", "\t\t\t      T2H = ii[WS(is, 42)];\n", "\t\t\t      T3D = T2G - T2H;\n", "\t\t\t      TF = TD + TE;\n", "\t\t\t      T3K = T3D - T3C;\n", "\t\t\t      T2I = T2G + T2H;\n", "\t\t\t      T3E = T3C + T3D;\n", "\t\t\t }\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TC, TJ, Taq, Tar;\n", "\t\t\t TC = Ty + TB;\n", "\t\t\t TJ = TF + TI;\n", "\t\t\t TK = TC + TJ;\n", "\t\t\t Tdd = TC - TJ;\n", "\t\t\t Taq = T2B - T2E;\n", "\t\t\t Tar = TI - TF;\n", "\t\t\t Tas = Taq - Tar;\n", "\t\t\t Tce = Tar + Taq;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tat, Tau, T2F, T2M;\n", "\t\t\t Tat = Ty - TB;\n", "\t\t\t Tau = T2I - T2L;\n", "\t\t\t Tav = Tat - Tau;\n", "\t\t\t Tcf = Tat + Tau;\n", "\t\t\t T2F = T2B + T2E;\n", "\t\t\t T2M = T2I + T2L;\n", "\t\t\t T2N = T2F + T2M;\n", "\t\t\t Tdc = T2F - T2M;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T3y, T3F, T7M, T7N;\n", "\t\t\t T3y = T3w + T3x;\n", "\t\t\t T3F = KP707106781 * (T3B - T3E);\n", "\t\t\t T3G = T3y - T3F;\n", "\t\t\t T6G = T3y + T3F;\n", "\t\t\t T7M = T3x - T3w;\n", "\t\t\t T7N = KP707106781 * (T3K + T3L);\n", "\t\t\t T7O = T7M - T7N;\n", "\t\t\t T9k = T7M + T7N;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7P, T7Q, T3J, T3M;\n", "\t\t\t T7P = T3H + T3I;\n", "\t\t\t T7Q = KP707106781 * (T3E + T3B);\n", "\t\t\t T7R = T7P - T7Q;\n", "\t\t\t T9l = T7P + T7Q;\n", "\t\t\t T3J = T3H - T3I;\n", "\t\t\t T3M = KP707106781 * (T3K - T3L);\n", "\t\t\t T3N = T3J - T3M;\n", "\t\t\t T6H = T3J + T3M;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T1z, T53, T5L, Tbo, T1C, T5I, T56, Tbp, T1J, Tb9, T5h, T5N, T1G, Tb8, T5c;\n", "\t\t    E T5O;\n", "\t\t    {\n", "\t\t\t E T1x, T1y, T54, T55;\n", "\t\t\t T1x = ri[WS(is, 63)];\n", "\t\t\t T1y = ri[WS(is, 31)];\n", "\t\t\t T1z = T1x + T1y;\n", "\t\t\t T53 = T1x - T1y;\n", "\t\t\t {\n", "\t\t\t      E T5J, T5K, T1A, T1B;\n", "\t\t\t      T5J = ii[WS(is, 63)];\n", "\t\t\t      T5K = ii[WS(is, 31)];\n", "\t\t\t      T5L = T5J - T5K;\n", "\t\t\t      Tbo = T5J + T5K;\n", "\t\t\t      T1A = ri[WS(is, 15)];\n", "\t\t\t      T1B = ri[WS(is, 47)];\n", "\t\t\t      T1C = T1A + T1B;\n", "\t\t\t      T5I = T1A - T1B;\n", "\t\t\t }\n", "\t\t\t T54 = ii[WS(is, 15)];\n", "\t\t\t T55 = ii[WS(is, 47)];\n", "\t\t\t T56 = T54 - T55;\n", "\t\t\t Tbp = T54 + T55;\n", "\t\t\t {\n", "\t\t\t      E T1H, T1I, T5d, T5e, T5f, T5g;\n", "\t\t\t      T1H = ri[WS(is, 55)];\n", "\t\t\t      T1I = ri[WS(is, 23)];\n", "\t\t\t      T5d = T1H - T1I;\n", "\t\t\t      T5e = ii[WS(is, 55)];\n", "\t\t\t      T5f = ii[WS(is, 23)];\n", "\t\t\t      T5g = T5e - T5f;\n", "\t\t\t      T1J = T1H + T1I;\n", "\t\t\t      Tb9 = T5e + T5f;\n", "\t\t\t      T5h = T5d + T5g;\n", "\t\t\t      T5N = T5d - T5g;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T1E, T1F, T5b, T58, T59, T5a;\n", "\t\t\t      T1E = ri[WS(is, 7)];\n", "\t\t\t      T1F = ri[WS(is, 39)];\n", "\t\t\t      T5b = T1E - T1F;\n", "\t\t\t      T58 = ii[WS(is, 7)];\n", "\t\t\t      T59 = ii[WS(is, 39)];\n", "\t\t\t      T5a = T58 - T59;\n", "\t\t\t      T1G = T1E + T1F;\n", "\t\t\t      Tb8 = T58 + T59;\n", "\t\t\t      T5c = T5a - T5b;\n", "\t\t\t      T5O = T5b + T5a;\n", "\t\t\t }\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1D, T1K, Tbq, Tbr;\n", "\t\t\t T1D = T1z + T1C;\n", "\t\t\t T1K = T1G + T1J;\n", "\t\t\t T1L = T1D + T1K;\n", "\t\t\t Tdv = T1D - T1K;\n", "\t\t\t Tbq = Tbo - Tbp;\n", "\t\t\t Tbr = T1J - T1G;\n", "\t\t\t Tbs = Tbq - Tbr;\n", "\t\t\t Tcw = Tbr + Tbq;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TdA, TdB, T57, T5i;\n", "\t\t\t TdA = Tbo + Tbp;\n", "\t\t\t TdB = Tb8 + Tb9;\n", "\t\t\t TdC = TdA - TdB;\n", "\t\t\t Teo = TdA + TdB;\n", "\t\t\t T57 = T53 - T56;\n", "\t\t\t T5i = KP707106781 * (T5c - T5h);\n", "\t\t\t T5j = T57 - T5i;\n", "\t\t\t T6V = T57 + T5i;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T5M, T5P, T8w, T8x;\n", "\t\t\t T5M = T5I + T5L;\n", "\t\t\t T5P = KP707106781 * (T5N - T5O);\n", "\t\t\t T5Q = T5M - T5P;\n", "\t\t\t T6Y = T5M + T5P;\n", "\t\t\t T8w = T5L - T5I;\n", "\t\t\t T8x = KP707106781 * (T5c + T5h);\n", "\t\t\t T8y = T8w - T8x;\n", "\t\t\t T9C = T8w + T8x;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tb7, Tba, T8l, T8m;\n", "\t\t\t Tb7 = T1z - T1C;\n", "\t\t\t Tba = Tb8 - Tb9;\n", "\t\t\t Tbb = Tb7 - Tba;\n", "\t\t\t Tct = Tb7 + Tba;\n", "\t\t\t T8l = T53 + T56;\n", "\t\t\t T8m = KP707106781 * (T5O + T5N);\n", "\t\t\t T8n = T8l - T8m;\n", "\t\t\t T9z = T8l + T8m;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E TN, T40, T2Q, T3Q, TQ, T3P, T2T, T41, TX, T44, T30, T3U, TU, T43, T2X;\n", "\t\t    E T3X;\n", "\t\t    {\n", "\t\t\t E TL, TM, T2R, T2S;\n", "\t\t\t TL = ri[WS(is, 62)];\n", "\t\t\t TM = ri[WS(is, 30)];\n", "\t\t\t TN = TL + TM;\n", "\t\t\t T40 = TL - TM;\n", "\t\t\t {\n", "\t\t\t      E T2O, T2P, TO, TP;\n", "\t\t\t      T2O = ii[WS(is, 62)];\n", "\t\t\t      T2P = ii[WS(is, 30)];\n", "\t\t\t      T2Q = T2O + T2P;\n", "\t\t\t      T3Q = T2O - T2P;\n", "\t\t\t      TO = ri[WS(is, 14)];\n", "\t\t\t      TP = ri[WS(is, 46)];\n", "\t\t\t      TQ = TO + TP;\n", "\t\t\t      T3P = TO - TP;\n", "\t\t\t }\n", "\t\t\t T2R = ii[WS(is, 14)];\n", "\t\t\t T2S = ii[WS(is, 46)];\n", "\t\t\t T2T = T2R + T2S;\n", "\t\t\t T41 = T2R - T2S;\n", "\t\t\t {\n", "\t\t\t      E TV, TW, T3S, T2Y, T2Z, T3T;\n", "\t\t\t      TV = ri[WS(is, 54)];\n", "\t\t\t      TW = ri[WS(is, 22)];\n", "\t\t\t      T3S = TV - TW;\n", "\t\t\t      T2Y = ii[WS(is, 54)];\n", "\t\t\t      T2Z = ii[WS(is, 22)];\n", "\t\t\t      T3T = T2Y - T2Z;\n", "\t\t\t      TX = TV + TW;\n", "\t\t\t      T44 = T3S + T3T;\n", "\t\t\t      T30 = T2Y + T2Z;\n", "\t\t\t      T3U = T3S - T3T;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E TS, TT, T3V, T2V, T2W, T3W;\n", "\t\t\t      TS = ri[WS(is, 6)];\n", "\t\t\t      TT = ri[WS(is, 38)];\n", "\t\t\t      T3V = TS - TT;\n", "\t\t\t      T2V = ii[WS(is, 6)];\n", "\t\t\t      T2W = ii[WS(is, 38)];\n", "\t\t\t      T3W = T2V - T2W;\n", "\t\t\t      TU = TS + TT;\n", "\t\t\t      T43 = T3W - T3V;\n", "\t\t\t      T2X = T2V + T2W;\n", "\t\t\t      T3X = T3V + T3W;\n", "\t\t\t }\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TR, TY, Tax, Tay;\n", "\t\t\t TR = TN + TQ;\n", "\t\t\t TY = TU + TX;\n", "\t\t\t TZ = TR + TY;\n", "\t\t\t Tdf = TR - TY;\n", "\t\t\t Tax = T2Q - T2T;\n", "\t\t\t Tay = TX - TU;\n", "\t\t\t Taz = Tax - Tay;\n", "\t\t\t Tch = Tay + Tax;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TaA, TaB, T2U, T31;\n", "\t\t\t TaA = TN - TQ;\n", "\t\t\t TaB = T2X - T30;\n", "\t\t\t TaC = TaA - TaB;\n", "\t\t\t Tci = TaA + TaB;\n", "\t\t\t T2U = T2Q + T2T;\n", "\t\t\t T31 = T2X + T30;\n", "\t\t\t T32 = T2U + T31;\n", "\t\t\t Tdg = T2U - T31;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T3R, T3Y, T7T, T7U;\n", "\t\t\t T3R = T3P + T3Q;\n", "\t\t\t T3Y = KP707106781 * (T3U - T3X);\n", "\t\t\t T3Z = T3R - T3Y;\n", "\t\t\t T6J = T3R + T3Y;\n", "\t\t\t T7T = T40 + T41;\n", "\t\t\t T7U = KP707106781 * (T3X + T3U);\n", "\t\t\t T7V = T7T - T7U;\n", "\t\t\t T9n = T7T + T7U;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7W, T7X, T42, T45;\n", "\t\t\t T7W = T3Q - T3P;\n", "\t\t\t T7X = KP707106781 * (T43 + T44);\n", "\t\t\t T7Y = T7W - T7X;\n", "\t\t\t T9o = T7W + T7X;\n", "\t\t\t T42 = T40 - T41;\n", "\t\t\t T45 = KP707106781 * (T43 - T44);\n", "\t\t\t T46 = T42 - T45;\n", "\t\t\t T6K = T42 + T45;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T14, T4P, T4d, TaG, T17, T4a, T4S, TaH, T1e, TaZ, T4j, T4V, T1b, TaY, T4o;\n", "\t\t    E T4U;\n", "\t\t    {\n", "\t\t\t E T12, T13, T4Q, T4R;\n", "\t\t\t T12 = ri[WS(is, 1)];\n", "\t\t\t T13 = ri[WS(is, 33)];\n", "\t\t\t T14 = T12 + T13;\n", "\t\t\t T4P = T12 - T13;\n", "\t\t\t {\n", "\t\t\t      E T4b, T4c, T15, T16;\n", "\t\t\t      T4b = ii[WS(is, 1)];\n", "\t\t\t      T4c = ii[WS(is, 33)];\n", "\t\t\t      T4d = T4b - T4c;\n", "\t\t\t      TaG = T4b + T4c;\n", "\t\t\t      T15 = ri[WS(is, 17)];\n", "\t\t\t      T16 = ri[WS(is, 49)];\n", "\t\t\t      T17 = T15 + T16;\n", "\t\t\t      T4a = T15 - T16;\n", "\t\t\t }\n", "\t\t\t T4Q = ii[WS(is, 17)];\n", "\t\t\t T4R = ii[WS(is, 49)];\n", "\t\t\t T4S = T4Q - T4R;\n", "\t\t\t TaH = T4Q + T4R;\n", "\t\t\t {\n", "\t\t\t      E T1c, T1d, T4f, T4g, T4h, T4i;\n", "\t\t\t      T1c = ri[WS(is, 57)];\n", "\t\t\t      T1d = ri[WS(is, 25)];\n", "\t\t\t      T4f = T1c - T1d;\n", "\t\t\t      T4g = ii[WS(is, 57)];\n", "\t\t\t      T4h = ii[WS(is, 25)];\n", "\t\t\t      T4i = T4g - T4h;\n", "\t\t\t      T1e = T1c + T1d;\n", "\t\t\t      TaZ = T4g + T4h;\n", "\t\t\t      T4j = T4f - T4i;\n", "\t\t\t      T4V = T4f + T4i;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T19, T1a, T4k, T4l, T4m, T4n;\n", "\t\t\t      T19 = ri[WS(is, 9)];\n", "\t\t\t      T1a = ri[WS(is, 41)];\n", "\t\t\t      T4k = T19 - T1a;\n", "\t\t\t      T4l = ii[WS(is, 9)];\n", "\t\t\t      T4m = ii[WS(is, 41)];\n", "\t\t\t      T4n = T4l - T4m;\n", "\t\t\t      T1b = T19 + T1a;\n", "\t\t\t      TaY = T4l + T4m;\n", "\t\t\t      T4o = T4k + T4n;\n", "\t\t\t      T4U = T4n - T4k;\n", "\t\t\t }\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T18, T1f, TaX, Tb0;\n", "\t\t\t T18 = T14 + T17;\n", "\t\t\t T1f = T1b + T1e;\n", "\t\t\t T1g = T18 + T1f;\n", "\t\t\t Tdp = T18 - T1f;\n", "\t\t\t TaX = T14 - T17;\n", "\t\t\t Tb0 = TaY - TaZ;\n", "\t\t\t Tb1 = TaX - Tb0;\n", "\t\t\t Tcm = TaX + Tb0;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tdk, Tdl, T4e, T4p;\n", "\t\t\t Tdk = TaG + TaH;\n", "\t\t\t Tdl = TaY + TaZ;\n", "\t\t\t Tdm = Tdk - Tdl;\n", "\t\t\t Tej = Tdk + Tdl;\n", "\t\t\t T4e = T4a + T4d;\n", "\t\t\t T4p = KP707106781 * (T4j - T4o);\n", "\t\t\t T4q = T4e - T4p;\n", "\t\t\t T6R = T4e + T4p;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4T, T4W, T8d, T8e;\n", "\t\t\t T4T = T4P - T4S;\n", "\t\t\t T4W = KP707106781 * (T4U - T4V);\n", "\t\t\t T4X = T4T - T4W;\n", "\t\t\t T6O = T4T + T4W;\n", "\t\t\t T8d = T4P + T4S;\n", "\t\t\t T8e = KP707106781 * (T4o + T4j);\n", "\t\t\t T8f = T8d - T8e;\n", "\t\t\t T9s = T8d + T8e;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TaI, TaJ, T82, T83;\n", "\t\t\t TaI = TaG - TaH;\n", "\t\t\t TaJ = T1e - T1b;\n", "\t\t\t TaK = TaI - TaJ;\n", "\t\t\t Tcp = TaJ + TaI;\n", "\t\t\t T82 = T4d - T4a;\n", "\t\t\t T83 = KP707106781 * (T4U + T4V);\n", "\t\t\t T84 = T82 - T83;\n", "\t\t\t T9v = T82 + T83;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T1j, TaR, T1m, TaS, T4G, T4L, TaT, TaQ, T89, T88, T1q, TaM, T1t, TaN, T4v;\n", "\t\t    E T4A, TaO, TaL, T86, T85;\n", "\t\t    {\n", "\t\t\t E T4H, T4F, T4C, T4K;\n", "\t\t\t {\n", "\t\t\t      E T1h, T1i, T4D, T4E;\n", "\t\t\t      T1h = ri[WS(is, 5)];\n", "\t\t\t      T1i = ri[WS(is, 37)];\n", "\t\t\t      T1j = T1h + T1i;\n", "\t\t\t      T4H = T1h - T1i;\n", "\t\t\t      T4D = ii[WS(is, 5)];\n", "\t\t\t      T4E = ii[WS(is, 37)];\n", "\t\t\t      T4F = T4D - T4E;\n", "\t\t\t      TaR = T4D + T4E;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T1k, T1l, T4I, T4J;\n", "\t\t\t      T1k = ri[WS(is, 21)];\n", "\t\t\t      T1l = ri[WS(is, 53)];\n", "\t\t\t      T1m = T1k + T1l;\n", "\t\t\t      T4C = T1k - T1l;\n", "\t\t\t      T4I = ii[WS(is, 21)];\n", "\t\t\t      T4J = ii[WS(is, 53)];\n", "\t\t\t      T4K = T4I - T4J;\n", "\t\t\t      TaS = T4I + T4J;\n", "\t\t\t }\n", "\t\t\t T4G = T4C + T4F;\n", "\t\t\t T4L = T4H - T4K;\n", "\t\t\t TaT = TaR - TaS;\n", "\t\t\t TaQ = T1j - T1m;\n", "\t\t\t T89 = T4H + T4K;\n", "\t\t\t T88 = T4F - T4C;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4r, T4z, T4w, T4u;\n", "\t\t\t {\n", "\t\t\t      E T1o, T1p, T4x, T4y;\n", "\t\t\t      T1o = ri[WS(is, 61)];\n", "\t\t\t      T1p = ri[WS(is, 29)];\n", "\t\t\t      T1q = T1o + T1p;\n", "\t\t\t      T4r = T1o - T1p;\n", "\t\t\t      T4x = ii[WS(is, 61)];\n", "\t\t\t      T4y = ii[WS(is, 29)];\n", "\t\t\t      T4z = T4x - T4y;\n", "\t\t\t      TaM = T4x + T4y;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T1r, T1s, T4s, T4t;\n", "\t\t\t      T1r = ri[WS(is, 13)];\n", "\t\t\t      T1s = ri[WS(is, 45)];\n", "\t\t\t      T1t = T1r + T1s;\n", "\t\t\t      T4w = T1r - T1s;\n", "\t\t\t      T4s = ii[WS(is, 13)];\n", "\t\t\t      T4t = ii[WS(is, 45)];\n", "\t\t\t      T4u = T4s - T4t;\n", "\t\t\t      TaN = T4s + T4t;\n", "\t\t\t }\n", "\t\t\t T4v = T4r - T4u;\n", "\t\t\t T4A = T4w + T4z;\n", "\t\t\t TaO = TaM - TaN;\n", "\t\t\t TaL = T1q - T1t;\n", "\t\t\t T86 = T4z - T4w;\n", "\t\t\t T85 = T4r + T4u;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1n, T1u, Tb2, Tb3;\n", "\t\t\t T1n = T1j + T1m;\n", "\t\t\t T1u = T1q + T1t;\n", "\t\t\t T1v = T1n + T1u;\n", "\t\t\t Tdn = T1u - T1n;\n", "\t\t\t Tb2 = TaT - TaQ;\n", "\t\t\t Tb3 = TaL + TaO;\n", "\t\t\t Tb4 = KP707106781 * (Tb2 - Tb3);\n", "\t\t\t Tcq = KP707106781 * (Tb2 + Tb3);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tdq, Tdr, T4B, T4M;\n", "\t\t\t Tdq = TaR + TaS;\n", "\t\t\t Tdr = TaM + TaN;\n", "\t\t\t Tds = Tdq - Tdr;\n", "\t\t\t Tek = Tdq + Tdr;\n", "\t\t\t T4B = FNMS(KP923879532, T4A, KP382683432 * T4v);\n", "\t\t\t T4M = FMA(KP923879532, T4G, KP382683432 * T4L);\n", "\t\t\t T4N = T4B - T4M;\n", "\t\t\t T6P = T4M + T4B;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4Y, T4Z, T8g, T8h;\n", "\t\t\t T4Y = FNMS(KP923879532, T4L, KP382683432 * T4G);\n", "\t\t\t T4Z = FMA(KP382683432, T4A, KP923879532 * T4v);\n", "\t\t\t T50 = T4Y - T4Z;\n", "\t\t\t T6S = T4Y + T4Z;\n", "\t\t\t T8g = FNMS(KP382683432, T89, KP923879532 * T88);\n", "\t\t\t T8h = FMA(KP923879532, T86, KP382683432 * T85);\n", "\t\t\t T8i = T8g - T8h;\n", "\t\t\t T9w = T8g + T8h;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TaP, TaU, T87, T8a;\n", "\t\t\t TaP = TaL - TaO;\n", "\t\t\t TaU = TaQ + TaT;\n", "\t\t\t TaV = KP707106781 * (TaP - TaU);\n", "\t\t\t Tcn = KP707106781 * (TaU + TaP);\n", "\t\t\t T87 = FNMS(KP382683432, T86, KP923879532 * T85);\n", "\t\t\t T8a = FMA(KP382683432, T88, KP923879532 * T89);\n", "\t\t\t T8b = T87 - T8a;\n", "\t\t\t T9t = T8a + T87;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T1O, Tbc, T1R, Tbd, T5o, T5t, Tbf, Tbe, T8p, T8o, T1V, Tbi, T1Y, Tbj, T5z;\n", "\t\t    E T5E, Tbk, Tbh, T8s, T8r;\n", "\t\t    {\n", "\t\t\t E T5p, T5n, T5k, T5s;\n", "\t\t\t {\n", "\t\t\t      E T1M, T1N, T5l, T5m;\n", "\t\t\t      T1M = ri[WS(is, 3)];\n", "\t\t\t      T1N = ri[WS(is, 35)];\n", "\t\t\t      T1O = T1M + T1N;\n", "\t\t\t      T5p = T1M - T1N;\n", "\t\t\t      T5l = ii[WS(is, 3)];\n", "\t\t\t      T5m = ii[WS(is, 35)];\n", "\t\t\t      T5n = T5l - T5m;\n", "\t\t\t      Tbc = T5l + T5m;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T1P, T1Q, T5q, T5r;\n", "\t\t\t      T1P = ri[WS(is, 19)];\n", "\t\t\t      T1Q = ri[WS(is, 51)];\n", "\t\t\t      T1R = T1P + T1Q;\n", "\t\t\t      T5k = T1P - T1Q;\n", "\t\t\t      T5q = ii[WS(is, 19)];\n", "\t\t\t      T5r = ii[WS(is, 51)];\n", "\t\t\t      T5s = T5q - T5r;\n", "\t\t\t      Tbd = T5q + T5r;\n", "\t\t\t }\n", "\t\t\t T5o = T5k + T5n;\n", "\t\t\t T5t = T5p - T5s;\n", "\t\t\t Tbf = T1O - T1R;\n", "\t\t\t Tbe = Tbc - Tbd;\n", "\t\t\t T8p = T5p + T5s;\n", "\t\t\t T8o = T5n - T5k;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T5A, T5y, T5v, T5D;\n", "\t\t\t {\n", "\t\t\t      E T1T, T1U, T5w, T5x;\n", "\t\t\t      T1T = ri[WS(is, 59)];\n", "\t\t\t      T1U = ri[WS(is, 27)];\n", "\t\t\t      T1V = T1T + T1U;\n", "\t\t\t      T5A = T1T - T1U;\n", "\t\t\t      T5w = ii[WS(is, 59)];\n", "\t\t\t      T5x = ii[WS(is, 27)];\n", "\t\t\t      T5y = T5w - T5x;\n", "\t\t\t      Tbi = T5w + T5x;\n", "\t\t\t }\n", "\t\t\t {\n", "\t\t\t      E T1W, T1X, T5B, T5C;\n", "\t\t\t      T1W = ri[WS(is, 11)];\n", "\t\t\t      T1X = ri[WS(is, 43)];\n", "\t\t\t      T1Y = T1W + T1X;\n", "\t\t\t      T5v = T1W - T1X;\n", "\t\t\t      T5B = ii[WS(is, 11)];\n", "\t\t\t      T5C = ii[WS(is, 43)];\n", "\t\t\t      T5D = T5B - T5C;\n", "\t\t\t      Tbj = T5B + T5C;\n", "\t\t\t }\n", "\t\t\t T5z = T5v + T5y;\n", "\t\t\t T5E = T5A - T5D;\n", "\t\t\t Tbk = Tbi - Tbj;\n", "\t\t\t Tbh = T1V - T1Y;\n", "\t\t\t T8s = T5A + T5D;\n", "\t\t\t T8r = T5y - T5v;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1S, T1Z, Tbt, Tbu;\n", "\t\t\t T1S = T1O + T1R;\n", "\t\t\t T1Z = T1V + T1Y;\n", "\t\t\t T20 = T1S + T1Z;\n", "\t\t\t TdD = T1Z - T1S;\n", "\t\t\t Tbt = Tbh - Tbk;\n", "\t\t\t Tbu = Tbf + Tbe;\n", "\t\t\t Tbv = KP707106781 * (Tbt - Tbu);\n", "\t\t\t Tcu = KP707106781 * (Tbu + Tbt);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tdw, Tdx, T5u, T5F;\n", "\t\t\t Tdw = Tbc + Tbd;\n", "\t\t\t Tdx = Tbi + Tbj;\n", "\t\t\t Tdy = Tdw - Tdx;\n", "\t\t\t Tep = Tdw + Tdx;\n", "\t\t\t T5u = FNMS(KP923879532, T5t, KP382683432 * T5o);\n", "\t\t\t T5F = FMA(KP382683432, T5z, KP923879532 * T5E);\n", "\t\t\t T5G = T5u - T5F;\n", "\t\t\t T6Z = T5u + T5F;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T5R, T5S, T8z, T8A;\n", "\t\t\t T5R = FNMS(KP923879532, T5z, KP382683432 * T5E);\n", "\t\t\t T5S = FMA(KP923879532, T5o, KP382683432 * T5t);\n", "\t\t\t T5T = T5R - T5S;\n", "\t\t\t T6W = T5S + T5R;\n", "\t\t\t T8z = FNMS(KP382683432, T8r, KP923879532 * T8s);\n", "\t\t\t T8A = FMA(KP382683432, T8o, KP923879532 * T8p);\n", "\t\t\t T8B = T8z - T8A;\n", "\t\t\t T9A = T8A + T8z;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tbg, Tbl, T8q, T8t;\n", "\t\t\t Tbg = Tbe - Tbf;\n", "\t\t\t Tbl = Tbh + Tbk;\n", "\t\t\t Tbm = KP707106781 * (Tbg - Tbl);\n", "\t\t\t Tcx = KP707106781 * (Tbg + Tbl);\n", "\t\t\t T8q = FNMS(KP382683432, T8p, KP923879532 * T8o);\n", "\t\t\t T8t = FMA(KP923879532, T8r, KP382683432 * T8s);\n", "\t\t\t T8u = T8q - T8t;\n", "\t\t\t T9D = T8q + T8t;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T11, TeD, TeG, TeI, T22, T23, T34, TeH;\n", "\t\t    {\n", "\t\t\t E Tv, T10, TeE, TeF;\n", "\t\t\t Tv = Tf + Tu;\n", "\t\t\t T10 = TK + TZ;\n", "\t\t\t T11 = Tv + T10;\n", "\t\t\t TeD = Tv - T10;\n", "\t\t\t TeE = Tej + Tek;\n", "\t\t\t TeF = Teo + Tep;\n", "\t\t\t TeG = TeE - TeF;\n", "\t\t\t TeI = TeE + TeF;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T1w, T21, T2y, T33;\n", "\t\t\t T1w = T1g + T1v;\n", "\t\t\t T21 = T1L + T20;\n", "\t\t\t T22 = T1w + T21;\n", "\t\t\t T23 = T21 - T1w;\n", "\t\t\t T2y = T2i + T2x;\n", "\t\t\t T33 = T2N + T32;\n", "\t\t\t T34 = T2y - T33;\n", "\t\t\t TeH = T2y + T33;\n", "\t\t    }\n", "\t\t    ro[WS(os, 32)] = T11 - T22;\n", "\t\t    io[WS(os, 32)] = TeH - TeI;\n", "\t\t    ro[0] = T11 + T22;\n", "\t\t    io[0] = TeH + TeI;\n", "\t\t    io[WS(os, 16)] = T23 + T34;\n", "\t\t    ro[WS(os, 16)] = TeD + TeG;\n", "\t\t    io[WS(os, 48)] = T34 - T23;\n", "\t\t    ro[WS(os, 48)] = TeD - TeG;\n", "\t       }\n", "\t       {\n", "\t\t    E Teh, Tex, Tev, TeB, Tem, Tey, Ter, Tez;\n", "\t\t    {\n", "\t\t\t E Tef, Teg, Tet, Teu;\n", "\t\t\t Tef = Tf - Tu;\n", "\t\t\t Teg = T2N - T32;\n", "\t\t\t Teh = Tef + Teg;\n", "\t\t\t Tex = Tef - Teg;\n", "\t\t\t Tet = T2i - T2x;\n", "\t\t\t Teu = TZ - TK;\n", "\t\t\t Tev = Tet - Teu;\n", "\t\t\t TeB = Teu + Tet;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tei, Tel, Ten, Teq;\n", "\t\t\t Tei = T1g - T1v;\n", "\t\t\t Tel = Tej - Tek;\n", "\t\t\t Tem = Tei + Tel;\n", "\t\t\t Tey = Tel - Tei;\n", "\t\t\t Ten = T1L - T20;\n", "\t\t\t Teq = Teo - Tep;\n", "\t\t\t Ter = Ten - Teq;\n", "\t\t\t Tez = Ten + Teq;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tes, TeC, Tew, TeA;\n", "\t\t\t Tes = KP707106781 * (Tem + Ter);\n", "\t\t\t ro[WS(os, 40)] = Teh - Tes;\n", "\t\t\t ro[WS(os, 8)] = Teh + Tes;\n", "\t\t\t TeC = KP707106781 * (Tey + Tez);\n", "\t\t\t io[WS(os, 40)] = TeB - TeC;\n", "\t\t\t io[WS(os, 8)] = TeB + TeC;\n", "\t\t\t Tew = KP707106781 * (Ter - Tem);\n", "\t\t\t io[WS(os, 56)] = Tev - Tew;\n", "\t\t\t io[WS(os, 24)] = Tev + Tew;\n", "\t\t\t TeA = KP707106781 * (Tey - Tez);\n", "\t\t\t ro[WS(os, 56)] = Tex - TeA;\n", "\t\t\t ro[WS(os, 24)] = Tex + TeA;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Tdb, TdV, Te5, TdJ, Tdi, Te6, Te3, Teb, TdM, TdW, Tdu, TdQ, Te0, Tea, TdF;\n", "\t\t    E TdR;\n", "\t\t    {\n", "\t\t\t E Tde, Tdh, Tdo, Tdt;\n", "\t\t\t Tdb = Td9 - Tda;\n", "\t\t\t TdV = Td9 + Tda;\n", "\t\t\t Te5 = TdI + TdH;\n", "\t\t\t TdJ = TdH - TdI;\n", "\t\t\t Tde = Tdc - Tdd;\n", "\t\t\t Tdh = Tdf + Tdg;\n", "\t\t\t Tdi = KP707106781 * (Tde - Tdh);\n", "\t\t\t Te6 = KP707106781 * (Tde + Tdh);\n", "\t\t\t {\n", "\t\t\t      E Te1, Te2, TdK, TdL;\n", "\t\t\t      Te1 = Tdv + Tdy;\n", "\t\t\t      Te2 = TdD + TdC;\n", "\t\t\t      Te3 = FNMS(KP382683432, Te2, KP923879532 * Te1);\n", "\t\t\t      Teb = FMA(KP923879532, Te2, KP382683432 * Te1);\n", "\t\t\t      TdK = Tdf - Tdg;\n", "\t\t\t      TdL = Tdd + Tdc;\n", "\t\t\t      TdM = KP707106781 * (TdK - TdL);\n", "\t\t\t      TdW = KP707106781 * (TdL + TdK);\n", "\t\t\t }\n", "\t\t\t Tdo = Tdm - Tdn;\n", "\t\t\t Tdt = Tdp - Tds;\n", "\t\t\t Tdu = FMA(KP923879532, Tdo, KP382683432 * Tdt);\n", "\t\t\t TdQ = FNMS(KP923879532, Tdt, KP382683432 * Tdo);\n", "\t\t\t {\n", "\t\t\t      E TdY, TdZ, Tdz, TdE;\n", "\t\t\t      TdY = Tdn + Tdm;\n", "\t\t\t      TdZ = Tdp + Tds;\n", "\t\t\t      Te0 = FMA(KP382683432, TdY, KP923879532 * TdZ);\n", "\t\t\t      Tea = FNMS(KP382683432, TdZ, KP923879532 * TdY);\n", "\t\t\t      Tdz = Tdv - Tdy;\n", "\t\t\t      TdE = TdC - TdD;\n", "\t\t\t      TdF = FNMS(KP923879532, TdE, KP382683432 * Tdz);\n", "\t\t\t      TdR = FMA(KP382683432, TdE, KP923879532 * Tdz);\n", "\t\t\t }\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tdj, TdG, TdT, TdU;\n", "\t\t\t Tdj = Tdb + Tdi;\n", "\t\t\t TdG = Tdu + TdF;\n", "\t\t\t ro[WS(os, 44)] = Tdj - TdG;\n", "\t\t\t ro[WS(os, 12)] = Tdj + TdG;\n", "\t\t\t TdT = TdJ + TdM;\n", "\t\t\t TdU = TdQ + TdR;\n", "\t\t\t io[WS(os, 44)] = TdT - TdU;\n", "\t\t\t io[WS(os, 12)] = TdT + TdU;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TdN, TdO, TdP, TdS;\n", "\t\t\t TdN = TdJ - TdM;\n", "\t\t\t TdO = TdF - Tdu;\n", "\t\t\t io[WS(os, 60)] = TdN - TdO;\n", "\t\t\t io[WS(os, 28)] = TdN + TdO;\n", "\t\t\t TdP = Tdb - Tdi;\n", "\t\t\t TdS = TdQ - TdR;\n", "\t\t\t ro[WS(os, 60)] = TdP - TdS;\n", "\t\t\t ro[WS(os, 28)] = TdP + TdS;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TdX, Te4, Ted, Tee;\n", "\t\t\t TdX = TdV + TdW;\n", "\t\t\t Te4 = Te0 + Te3;\n", "\t\t\t ro[WS(os, 36)] = TdX - Te4;\n", "\t\t\t ro[WS(os, 4)] = TdX + Te4;\n", "\t\t\t Ted = Te5 + Te6;\n", "\t\t\t Tee = Tea + Teb;\n", "\t\t\t io[WS(os, 36)] = Ted - Tee;\n", "\t\t\t io[WS(os, 4)] = Ted + Tee;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Te7, Te8, Te9, Tec;\n", "\t\t\t Te7 = Te5 - Te6;\n", "\t\t\t Te8 = Te3 - Te0;\n", "\t\t\t io[WS(os, 52)] = Te7 - Te8;\n", "\t\t\t io[WS(os, 20)] = Te7 + Te8;\n", "\t\t\t Te9 = TdV - TdW;\n", "\t\t\t Tec = Tea - Teb;\n", "\t\t\t ro[WS(os, 52)] = Te9 - Tec;\n", "\t\t\t ro[WS(os, 20)] = Te9 + Tec;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Tcd, TcP, TcD, TcZ, Tck, Td0, TcX, Td5, Tcs, TcK, TcG, TcQ, TcU, Td4, Tcz;\n", "\t\t    E TcL, Tcc, TcC;\n", "\t\t    Tcc = KP707106781 * (TbD + TbC);\n", "\t\t    Tcd = Tcb - Tcc;\n", "\t\t    TcP = Tcb + Tcc;\n", "\t\t    TcC = KP707106781 * (Tak + Tan);\n", "\t\t    TcD = TcB - TcC;\n", "\t\t    TcZ = TcB + TcC;\n", "\t\t    {\n", "\t\t\t E Tcg, Tcj, TcV, TcW;\n", "\t\t\t Tcg = FNMS(KP382683432, Tcf, KP923879532 * Tce);\n", "\t\t\t Tcj = FMA(KP923879532, Tch, KP382683432 * Tci);\n", "\t\t\t Tck = Tcg - Tcj;\n", "\t\t\t Td0 = Tcg + Tcj;\n", "\t\t\t TcV = Tct + Tcu;\n", "\t\t\t TcW = Tcw + Tcx;\n", "\t\t\t TcX = FNMS(KP195090322, TcW, KP980785280 * TcV);\n", "\t\t\t Td5 = FMA(KP195090322, TcV, KP980785280 * TcW);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tco, Tcr, TcE, TcF;\n", "\t\t\t Tco = Tcm - Tcn;\n", "\t\t\t Tcr = Tcp - Tcq;\n", "\t\t\t Tcs = FMA(KP555570233, Tco, KP831469612 * Tcr);\n", "\t\t\t TcK = FNMS(KP831469612, Tco, KP555570233 * Tcr);\n", "\t\t\t TcE = FNMS(KP382683432, Tch, KP923879532 * Tci);\n", "\t\t\t TcF = FMA(KP382683432, Tce, KP923879532 * Tcf);\n", "\t\t\t TcG = TcE - TcF;\n", "\t\t\t TcQ = TcF + TcE;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TcS, TcT, Tcv, Tcy;\n", "\t\t\t TcS = Tcm + Tcn;\n", "\t\t\t TcT = Tcp + Tcq;\n", "\t\t\t TcU = FMA(KP980785280, TcS, KP195090322 * TcT);\n", "\t\t\t Td4 = FNMS(KP195090322, TcS, KP980785280 * TcT);\n", "\t\t\t Tcv = Tct - Tcu;\n", "\t\t\t Tcy = Tcw - Tcx;\n", "\t\t\t Tcz = FNMS(KP831469612, Tcy, KP555570233 * Tcv);\n", "\t\t\t TcL = FMA(KP831469612, Tcv, KP555570233 * Tcy);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tcl, TcA, TcN, TcO;\n", "\t\t\t Tcl = Tcd + Tck;\n", "\t\t\t TcA = Tcs + Tcz;\n", "\t\t\t ro[WS(os, 42)] = Tcl - TcA;\n", "\t\t\t ro[WS(os, 10)] = Tcl + TcA;\n", "\t\t\t TcN = TcD + TcG;\n", "\t\t\t TcO = TcK + TcL;\n", "\t\t\t io[WS(os, 42)] = TcN - TcO;\n", "\t\t\t io[WS(os, 10)] = TcN + TcO;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TcH, TcI, TcJ, TcM;\n", "\t\t\t TcH = TcD - TcG;\n", "\t\t\t TcI = Tcz - Tcs;\n", "\t\t\t io[WS(os, 58)] = TcH - TcI;\n", "\t\t\t io[WS(os, 26)] = TcH + TcI;\n", "\t\t\t TcJ = Tcd - Tck;\n", "\t\t\t TcM = TcK - TcL;\n", "\t\t\t ro[WS(os, 58)] = TcJ - TcM;\n", "\t\t\t ro[WS(os, 26)] = TcJ + TcM;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TcR, TcY, Td7, Td8;\n", "\t\t\t TcR = TcP + TcQ;\n", "\t\t\t TcY = TcU + TcX;\n", "\t\t\t ro[WS(os, 34)] = TcR - TcY;\n", "\t\t\t ro[WS(os, 2)] = TcR + TcY;\n", "\t\t\t Td7 = TcZ + Td0;\n", "\t\t\t Td8 = Td4 + Td5;\n", "\t\t\t io[WS(os, 34)] = Td7 - Td8;\n", "\t\t\t io[WS(os, 2)] = Td7 + Td8;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Td1, Td2, Td3, Td6;\n", "\t\t\t Td1 = TcZ - Td0;\n", "\t\t\t Td2 = TcX - TcU;\n", "\t\t\t io[WS(os, 50)] = Td1 - Td2;\n", "\t\t\t io[WS(os, 18)] = Td1 + Td2;\n", "\t\t\t Td3 = TcP - TcQ;\n", "\t\t\t Td6 = Td4 - Td5;\n", "\t\t\t ro[WS(os, 50)] = Td3 - Td6;\n", "\t\t\t ro[WS(os, 18)] = Td3 + Td6;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E Tap, TbR, TbF, Tc1, TaE, Tc2, TbZ, Tc7, Tb6, TbM, TbI, TbS, TbW, Tc6, Tbx;\n", "\t\t    E TbN, Tao, TbE;\n", "\t\t    Tao = KP707106781 * (Tak - Tan);\n", "\t\t    Tap = Tah - Tao;\n", "\t\t    TbR = Tah + Tao;\n", "\t\t    TbE = KP707106781 * (TbC - TbD);\n", "\t\t    TbF = TbB - TbE;\n", "\t\t    Tc1 = TbB + TbE;\n", "\t\t    {\n", "\t\t\t E Taw, TaD, TbX, TbY;\n", "\t\t\t Taw = FNMS(KP923879532, Tav, KP382683432 * Tas);\n", "\t\t\t TaD = FMA(KP382683432, Taz, KP923879532 * TaC);\n", "\t\t\t TaE = Taw - TaD;\n", "\t\t\t Tc2 = Taw + TaD;\n", "\t\t\t TbX = Tbb + Tbm;\n", "\t\t\t TbY = Tbs + Tbv;\n", "\t\t\t TbZ = FNMS(KP555570233, TbY, KP831469612 * TbX);\n", "\t\t\t Tc7 = FMA(KP831469612, TbY, KP555570233 * TbX);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TaW, Tb5, TbG, TbH;\n", "\t\t\t TaW = TaK - TaV;\n", "\t\t\t Tb5 = Tb1 - Tb4;\n", "\t\t\t Tb6 = FMA(KP980785280, TaW, KP195090322 * Tb5);\n", "\t\t\t TbM = FNMS(KP980785280, Tb5, KP195090322 * TaW);\n", "\t\t\t TbG = FNMS(KP923879532, Taz, KP382683432 * TaC);\n", "\t\t\t TbH = FMA(KP923879532, Tas, KP382683432 * Tav);\n", "\t\t\t TbI = TbG - TbH;\n", "\t\t\t TbS = TbH + TbG;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TbU, TbV, Tbn, Tbw;\n", "\t\t\t TbU = TaK + TaV;\n", "\t\t\t TbV = Tb1 + Tb4;\n", "\t\t\t TbW = FMA(KP555570233, TbU, KP831469612 * TbV);\n", "\t\t\t Tc6 = FNMS(KP555570233, TbV, KP831469612 * TbU);\n", "\t\t\t Tbn = Tbb - Tbm;\n", "\t\t\t Tbw = Tbs - Tbv;\n", "\t\t\t Tbx = FNMS(KP980785280, Tbw, KP195090322 * Tbn);\n", "\t\t\t TbN = FMA(KP195090322, Tbw, KP980785280 * Tbn);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TaF, Tby, TbP, TbQ;\n", "\t\t\t TaF = Tap + TaE;\n", "\t\t\t Tby = Tb6 + Tbx;\n", "\t\t\t ro[WS(os, 46)] = TaF - Tby;\n", "\t\t\t ro[WS(os, 14)] = TaF + Tby;\n", "\t\t\t TbP = TbF + TbI;\n", "\t\t\t TbQ = TbM + TbN;\n", "\t\t\t io[WS(os, 46)] = TbP - TbQ;\n", "\t\t\t io[WS(os, 14)] = TbP + TbQ;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TbJ, TbK, TbL, TbO;\n", "\t\t\t TbJ = TbF - TbI;\n", "\t\t\t TbK = Tbx - Tb6;\n", "\t\t\t io[WS(os, 62)] = TbJ - TbK;\n", "\t\t\t io[WS(os, 30)] = TbJ + TbK;\n", "\t\t\t TbL = Tap - TaE;\n", "\t\t\t TbO = TbM - TbN;\n", "\t\t\t ro[WS(os, 62)] = TbL - TbO;\n", "\t\t\t ro[WS(os, 30)] = TbL + TbO;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E TbT, Tc0, Tc9, Tca;\n", "\t\t\t TbT = TbR + TbS;\n", "\t\t\t Tc0 = TbW + TbZ;\n", "\t\t\t ro[WS(os, 38)] = TbT - Tc0;\n", "\t\t\t ro[WS(os, 6)] = TbT + Tc0;\n", "\t\t\t Tc9 = Tc1 + Tc2;\n", "\t\t\t Tca = Tc6 + Tc7;\n", "\t\t\t io[WS(os, 38)] = Tc9 - Tca;\n", "\t\t\t io[WS(os, 6)] = Tc9 + Tca;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Tc3, Tc4, Tc5, Tc8;\n", "\t\t\t Tc3 = Tc1 - Tc2;\n", "\t\t\t Tc4 = TbZ - TbW;\n", "\t\t\t io[WS(os, 54)] = Tc3 - Tc4;\n", "\t\t\t io[WS(os, 22)] = Tc3 + Tc4;\n", "\t\t\t Tc5 = TbR - TbS;\n", "\t\t\t Tc8 = Tc6 - Tc7;\n", "\t\t\t ro[WS(os, 54)] = Tc5 - Tc8;\n", "\t\t\t ro[WS(os, 22)] = Tc5 + Tc8;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T6F, T7h, T7m, T7w, T7p, T7x, T6M, T7s, T6U, T7c, T75, T7r, T78, T7i, T71;\n", "\t\t    E T7d;\n", "\t\t    {\n", "\t\t\t E T6D, T6E, T7k, T7l;\n", "\t\t\t T6D = T37 + T3e;\n", "\t\t\t T6E = T65 + T64;\n", "\t\t\t T6F = T6D - T6E;\n", "\t\t\t T7h = T6D + T6E;\n", "\t\t\t T7k = T6O + T6P;\n", "\t\t\t T7l = T6R + T6S;\n", "\t\t\t T7m = FMA(KP956940335, T7k, KP290284677 * T7l);\n", "\t\t\t T7w = FNMS(KP290284677, T7k, KP956940335 * T7l);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7n, T7o, T6I, T6L;\n", "\t\t\t T7n = T6V + T6W;\n", "\t\t\t T7o = T6Y + T6Z;\n", "\t\t\t T7p = FNMS(KP290284677, T7o, KP956940335 * T7n);\n", "\t\t\t T7x = FMA(KP290284677, T7n, KP956940335 * T7o);\n", "\t\t\t T6I = FNMS(KP555570233, T6H, KP831469612 * T6G);\n", "\t\t\t T6L = FMA(KP831469612, T6J, KP555570233 * T6K);\n", "\t\t\t T6M = T6I - T6L;\n", "\t\t\t T7s = T6I + T6L;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6Q, T6T, T73, T74;\n", "\t\t\t T6Q = T6O - T6P;\n", "\t\t\t T6T = T6R - T6S;\n", "\t\t\t T6U = FMA(KP471396736, T6Q, KP881921264 * T6T);\n", "\t\t\t T7c = FNMS(KP881921264, T6Q, KP471396736 * T6T);\n", "\t\t\t T73 = T5Z + T62;\n", "\t\t\t T74 = T3m + T3t;\n", "\t\t\t T75 = T73 - T74;\n", "\t\t\t T7r = T73 + T74;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T76, T77, T6X, T70;\n", "\t\t\t T76 = FNMS(KP555570233, T6J, KP831469612 * T6K);\n", "\t\t\t T77 = FMA(KP555570233, T6G, KP831469612 * T6H);\n", "\t\t\t T78 = T76 - T77;\n", "\t\t\t T7i = T77 + T76;\n", "\t\t\t T6X = T6V - T6W;\n", "\t\t\t T70 = T6Y - T6Z;\n", "\t\t\t T71 = FNMS(KP881921264, T70, KP471396736 * T6X);\n", "\t\t\t T7d = FMA(KP881921264, T6X, KP471396736 * T70);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6N, T72, T7f, T7g;\n", "\t\t\t T6N = T6F + T6M;\n", "\t\t\t T72 = T6U + T71;\n", "\t\t\t ro[WS(os, 43)] = T6N - T72;\n", "\t\t\t ro[WS(os, 11)] = T6N + T72;\n", "\t\t\t T7f = T75 + T78;\n", "\t\t\t T7g = T7c + T7d;\n", "\t\t\t io[WS(os, 43)] = T7f - T7g;\n", "\t\t\t io[WS(os, 11)] = T7f + T7g;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T79, T7a, T7b, T7e;\n", "\t\t\t T79 = T75 - T78;\n", "\t\t\t T7a = T71 - T6U;\n", "\t\t\t io[WS(os, 59)] = T79 - T7a;\n", "\t\t\t io[WS(os, 27)] = T79 + T7a;\n", "\t\t\t T7b = T6F - T6M;\n", "\t\t\t T7e = T7c - T7d;\n", "\t\t\t ro[WS(os, 59)] = T7b - T7e;\n", "\t\t\t ro[WS(os, 27)] = T7b + T7e;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7j, T7q, T7z, T7A;\n", "\t\t\t T7j = T7h + T7i;\n", "\t\t\t T7q = T7m + T7p;\n", "\t\t\t ro[WS(os, 35)] = T7j - T7q;\n", "\t\t\t ro[WS(os, 3)] = T7j + T7q;\n", "\t\t\t T7z = T7r + T7s;\n", "\t\t\t T7A = T7w + T7x;\n", "\t\t\t io[WS(os, 35)] = T7z - T7A;\n", "\t\t\t io[WS(os, 3)] = T7z + T7A;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T7t, T7u, T7v, T7y;\n", "\t\t\t T7t = T7r - T7s;\n", "\t\t\t T7u = T7p - T7m;\n", "\t\t\t io[WS(os, 51)] = T7t - T7u;\n", "\t\t\t io[WS(os, 19)] = T7t + T7u;\n", "\t\t\t T7v = T7h - T7i;\n", "\t\t\t T7y = T7w - T7x;\n", "\t\t\t ro[WS(os, 51)] = T7v - T7y;\n", "\t\t\t ro[WS(os, 19)] = T7v + T7y;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T9j, T9V, Ta0, Taa, Ta3, Tab, T9q, Ta6, T9y, T9Q, T9J, Ta5, T9M, T9W, T9F;\n", "\t\t    E T9R;\n", "\t\t    {\n", "\t\t\t E T9h, T9i, T9Y, T9Z;\n", "\t\t\t T9h = T7B + T7C;\n", "\t\t\t T9i = T8J + T8I;\n", "\t\t\t T9j = T9h - T9i;\n", "\t\t\t T9V = T9h + T9i;\n", "\t\t\t T9Y = T9s + T9t;\n", "\t\t\t T9Z = T9v + T9w;\n", "\t\t\t Ta0 = FMA(KP995184726, T9Y, KP098017140 * T9Z);\n", "\t\t\t Taa = FNMS(KP098017140, T9Y, KP995184726 * T9Z);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Ta1, Ta2, T9m, T9p;\n", "\t\t\t Ta1 = T9z + T9A;\n", "\t\t\t Ta2 = T9C + T9D;\n", "\t\t\t Ta3 = FNMS(KP098017140, Ta2, KP995184726 * Ta1);\n", "\t\t\t Tab = FMA(KP098017140, Ta1, KP995184726 * Ta2);\n", "\t\t\t T9m = FNMS(KP195090322, T9l, KP980785280 * T9k);\n", "\t\t\t T9p = FMA(KP195090322, T9n, KP980785280 * T9o);\n", "\t\t\t T9q = T9m - T9p;\n", "\t\t\t Ta6 = T9m + T9p;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T9u, T9x, T9H, T9I;\n", "\t\t\t T9u = T9s - T9t;\n", "\t\t\t T9x = T9v - T9w;\n", "\t\t\t T9y = FMA(KP634393284, T9u, KP773010453 * T9x);\n", "\t\t\t T9Q = FNMS(KP773010453, T9u, KP634393284 * T9x);\n", "\t\t\t T9H = T8F + T8G;\n", "\t\t\t T9I = T7G + T7J;\n", "\t\t\t T9J = T9H - T9I;\n", "\t\t\t Ta5 = T9H + T9I;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T9K, T9L, T9B, T9E;\n", "\t\t\t T9K = FNMS(KP195090322, T9o, KP980785280 * T9n);\n", "\t\t\t T9L = FMA(KP980785280, T9l, KP195090322 * T9k);\n", "\t\t\t T9M = T9K - T9L;\n", "\t\t\t T9W = T9L + T9K;\n", "\t\t\t T9B = T9z - T9A;\n", "\t\t\t T9E = T9C - T9D;\n", "\t\t\t T9F = FNMS(KP773010453, T9E, KP634393284 * T9B);\n", "\t\t\t T9R = FMA(KP773010453, T9B, KP634393284 * T9E);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T9r, T9G, T9T, T9U;\n", "\t\t\t T9r = T9j + T9q;\n", "\t\t\t T9G = T9y + T9F;\n", "\t\t\t ro[WS(os, 41)] = T9r - T9G;\n", "\t\t\t ro[WS(os, 9)] = T9r + T9G;\n", "\t\t\t T9T = T9J + T9M;\n", "\t\t\t T9U = T9Q + T9R;\n", "\t\t\t io[WS(os, 41)] = T9T - T9U;\n", "\t\t\t io[WS(os, 9)] = T9T + T9U;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T9N, T9O, T9P, T9S;\n", "\t\t\t T9N = T9J - T9M;\n", "\t\t\t T9O = T9F - T9y;\n", "\t\t\t io[WS(os, 57)] = T9N - T9O;\n", "\t\t\t io[WS(os, 25)] = T9N + T9O;\n", "\t\t\t T9P = T9j - T9q;\n", "\t\t\t T9S = T9Q - T9R;\n", "\t\t\t ro[WS(os, 57)] = T9P - T9S;\n", "\t\t\t ro[WS(os, 25)] = T9P + T9S;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T9X, Ta4, Tad, Tae;\n", "\t\t\t T9X = T9V + T9W;\n", "\t\t\t Ta4 = Ta0 + Ta3;\n", "\t\t\t ro[WS(os, 33)] = T9X - Ta4;\n", "\t\t\t ro[WS(os, 1)] = T9X + Ta4;\n", "\t\t\t Tad = Ta5 + Ta6;\n", "\t\t\t Tae = Taa + Tab;\n", "\t\t\t io[WS(os, 33)] = Tad - Tae;\n", "\t\t\t io[WS(os, 1)] = Tad + Tae;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E Ta7, Ta8, Ta9, Tac;\n", "\t\t\t Ta7 = Ta5 - Ta6;\n", "\t\t\t Ta8 = Ta3 - Ta0;\n", "\t\t\t io[WS(os, 49)] = Ta7 - Ta8;\n", "\t\t\t io[WS(os, 17)] = Ta7 + Ta8;\n", "\t\t\t Ta9 = T9V - T9W;\n", "\t\t\t Tac = Taa - Tab;\n", "\t\t\t ro[WS(os, 49)] = Ta9 - Tac;\n", "\t\t\t ro[WS(os, 17)] = Ta9 + Tac;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T3v, T6j, T6o, T6y, T6r, T6z, T48, T6u, T52, T6e, T67, T6t, T6a, T6k, T5V;\n", "\t\t    E T6f;\n", "\t\t    {\n", "\t\t\t E T3f, T3u, T6m, T6n;\n", "\t\t\t T3f = T37 - T3e;\n", "\t\t\t T3u = T3m - T3t;\n", "\t\t\t T3v = T3f - T3u;\n", "\t\t\t T6j = T3f + T3u;\n", "\t\t\t T6m = T4q + T4N;\n", "\t\t\t T6n = T4X + T50;\n", "\t\t\t T6o = FMA(KP634393284, T6m, KP773010453 * T6n);\n", "\t\t\t T6y = FNMS(KP634393284, T6n, KP773010453 * T6m);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6p, T6q, T3O, T47;\n", "\t\t\t T6p = T5j + T5G;\n", "\t\t\t T6q = T5Q + T5T;\n", "\t\t\t T6r = FNMS(KP634393284, T6q, KP773010453 * T6p);\n", "\t\t\t T6z = FMA(KP773010453, T6q, KP634393284 * T6p);\n", "\t\t\t T3O = FNMS(KP980785280, T3N, KP195090322 * T3G);\n", "\t\t\t T47 = FMA(KP195090322, T3Z, KP980785280 * T46);\n", "\t\t\t T48 = T3O - T47;\n", "\t\t\t T6u = T3O + T47;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T4O, T51, T63, T66;\n", "\t\t\t T4O = T4q - T4N;\n", "\t\t\t T51 = T4X - T50;\n", "\t\t\t T52 = FMA(KP995184726, T4O, KP098017140 * T51);\n", "\t\t\t T6e = FNMS(KP995184726, T51, KP098017140 * T4O);\n", "\t\t\t T63 = T5Z - T62;\n", "\t\t\t T66 = T64 - T65;\n", "\t\t\t T67 = T63 - T66;\n", "\t\t\t T6t = T63 + T66;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T68, T69, T5H, T5U;\n", "\t\t\t T68 = FNMS(KP980785280, T3Z, KP195090322 * T46);\n", "\t\t\t T69 = FMA(KP980785280, T3G, KP195090322 * T3N);\n", "\t\t\t T6a = T68 - T69;\n", "\t\t\t T6k = T69 + T68;\n", "\t\t\t T5H = T5j - T5G;\n", "\t\t\t T5U = T5Q - T5T;\n", "\t\t\t T5V = FNMS(KP995184726, T5U, KP098017140 * T5H);\n", "\t\t\t T6f = FMA(KP098017140, T5U, KP995184726 * T5H);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T49, T5W, T6h, T6i;\n", "\t\t\t T49 = T3v + T48;\n", "\t\t\t T5W = T52 + T5V;\n", "\t\t\t ro[WS(os, 47)] = T49 - T5W;\n", "\t\t\t ro[WS(os, 15)] = T49 + T5W;\n", "\t\t\t T6h = T67 + T6a;\n", "\t\t\t T6i = T6e + T6f;\n", "\t\t\t io[WS(os, 47)] = T6h - T6i;\n", "\t\t\t io[WS(os, 15)] = T6h + T6i;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6b, T6c, T6d, T6g;\n", "\t\t\t T6b = T67 - T6a;\n", "\t\t\t T6c = T5V - T52;\n", "\t\t\t io[WS(os, 63)] = T6b - T6c;\n", "\t\t\t io[WS(os, 31)] = T6b + T6c;\n", "\t\t\t T6d = T3v - T48;\n", "\t\t\t T6g = T6e - T6f;\n", "\t\t\t ro[WS(os, 63)] = T6d - T6g;\n", "\t\t\t ro[WS(os, 31)] = T6d + T6g;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6l, T6s, T6B, T6C;\n", "\t\t\t T6l = T6j + T6k;\n", "\t\t\t T6s = T6o + T6r;\n", "\t\t\t ro[WS(os, 39)] = T6l - T6s;\n", "\t\t\t ro[WS(os, 7)] = T6l + T6s;\n", "\t\t\t T6B = T6t + T6u;\n", "\t\t\t T6C = T6y + T6z;\n", "\t\t\t io[WS(os, 39)] = T6B - T6C;\n", "\t\t\t io[WS(os, 7)] = T6B + T6C;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T6v, T6w, T6x, T6A;\n", "\t\t\t T6v = T6t - T6u;\n", "\t\t\t T6w = T6r - T6o;\n", "\t\t\t io[WS(os, 55)] = T6v - T6w;\n", "\t\t\t io[WS(os, 23)] = T6v + T6w;\n", "\t\t\t T6x = T6j - T6k;\n", "\t\t\t T6A = T6y - T6z;\n", "\t\t\t ro[WS(os, 55)] = T6x - T6A;\n", "\t\t\t ro[WS(os, 23)] = T6x + T6A;\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E T7L, T8X, T92, T9c, T95, T9d, T80, T98, T8k, T8S, T8L, T97, T8O, T8Y, T8D;\n", "\t\t    E T8T;\n", "\t\t    {\n", "\t\t\t E T7D, T7K, T90, T91;\n", "\t\t\t T7D = T7B - T7C;\n", "\t\t\t T7K = T7G - T7J;\n", "\t\t\t T7L = T7D - T7K;\n", "\t\t\t T8X = T7D + T7K;\n", "\t\t\t T90 = T84 + T8b;\n", "\t\t\t T91 = T8f + T8i;\n", "\t\t\t T92 = FMA(KP471396736, T90, KP881921264 * T91);\n", "\t\t\t T9c = FNMS(KP471396736, T91, KP881921264 * T90);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T93, T94, T7S, T7Z;\n", "\t\t\t T93 = T8n + T8u;\n", "\t\t\t T94 = T8y + T8B;\n", "\t\t\t T95 = FNMS(KP471396736, T94, KP881921264 * T93);\n", "\t\t\t T9d = FMA(KP881921264, T94, KP471396736 * T93);\n", "\t\t\t T7S = FNMS(KP831469612, T7R, KP555570233 * T7O);\n", "\t\t\t T7Z = FMA(KP831469612, T7V, KP555570233 * T7Y);\n", "\t\t\t T80 = T7S - T7Z;\n", "\t\t\t T98 = T7S + T7Z;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T8c, T8j, T8H, T8K;\n", "\t\t\t T8c = T84 - T8b;\n", "\t\t\t T8j = T8f - T8i;\n", "\t\t\t T8k = FMA(KP956940335, T8c, KP290284677 * T8j);\n", "\t\t\t T8S = FNMS(KP956940335, T8j, KP290284677 * T8c);\n", "\t\t\t T8H = T8F - T8G;\n", "\t\t\t T8K = T8I - T8J;\n", "\t\t\t T8L = T8H - T8K;\n", "\t\t\t T97 = T8H + T8K;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T8M, T8N, T8v, T8C;\n", "\t\t\t T8M = FNMS(KP831469612, T7Y, KP555570233 * T7V);\n", "\t\t\t T8N = FMA(KP555570233, T7R, KP831469612 * T7O);\n", "\t\t\t T8O = T8M - T8N;\n", "\t\t\t T8Y = T8N + T8M;\n", "\t\t\t T8v = T8n - T8u;\n", "\t\t\t T8C = T8y - T8B;\n", "\t\t\t T8D = FNMS(KP956940335, T8C, KP290284677 * T8v);\n", "\t\t\t T8T = FMA(KP290284677, T8C, KP956940335 * T8v);\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T81, T8E, T8V, T8W;\n", "\t\t\t T81 = T7L + T80;\n", "\t\t\t T8E = T8k + T8D;\n", "\t\t\t ro[WS(os, 45)] = T81 - T8E;\n", "\t\t\t ro[WS(os, 13)] = T81 + T8E;\n", "\t\t\t T8V = T8L + T8O;\n", "\t\t\t T8W = T8S + T8T;\n", "\t\t\t io[WS(os, 45)] = T8V - T8W;\n", "\t\t\t io[WS(os, 13)] = T8V + T8W;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T8P, T8Q, T8R, T8U;\n", "\t\t\t T8P = T8L - T8O;\n", "\t\t\t T8Q = T8D - T8k;\n", "\t\t\t io[WS(os, 61)] = T8P - T8Q;\n", "\t\t\t io[WS(os, 29)] = T8P + T8Q;\n", "\t\t\t T8R = T7L - T80;\n", "\t\t\t T8U = T8S - T8T;\n", "\t\t\t ro[WS(os, 61)] = T8R - T8U;\n", "\t\t\t ro[WS(os, 29)] = T8R + T8U;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T8Z, T96, T9f, T9g;\n", "\t\t\t T8Z = T8X + T8Y;\n", "\t\t\t T96 = T92 + T95;\n", "\t\t\t ro[WS(os, 37)] = T8Z - T96;\n", "\t\t\t ro[WS(os, 5)] = T8Z + T96;\n", "\t\t\t T9f = T97 + T98;\n", "\t\t\t T9g = T9c + T9d;\n", "\t\t\t io[WS(os, 37)] = T9f - T9g;\n", "\t\t\t io[WS(os, 5)] = T9f + T9g;\n", "\t\t    }\n", "\t\t    {\n", "\t\t\t E T99, T9a, T9b, T9e;\n", "\t\t\t T99 = T97 - T98;\n", "\t\t\t T9a = T95 - T92;\n", "\t\t\t io[WS(os, 53)] = T99 - T9a;\n", "\t\t\t io[WS(os, 21)] = T99 + T9a;\n", "\t\t\t T9b = T8X - T8Y;\n", "\t\t\t T9e = T9c - T9d;\n", "\t\t\t ro[WS(os, 53)] = T9b - T9e;\n", "\t\t\t ro[WS(os, 21)] = T9b + T9e;\n", "\t\t    }\n", "\t       }\n", "\t  }\n", "     }\n", "}\n"], "project": "libfftw3-mpi-dev", "file": "n1_64.pkl", "function": "n1_64"}, {"comment_all": {"comment": "/*\n\t * TODO: validate the interface and mac address!\n\t * Otherwise, there's a race condition as soon as\n\t * the kernel starts sending mpath notifications.\n\t */", "depth": 1, "reading_ease": 43.9, "reading_grade": 9.7, "line": 23}, "comment_text": "/*\n\t * TODO: validate the interface and mac address!\n\t * Otherwise, there's a race condition as soon as\n\t * the kernel starts sending mpath notifications.\n\t */", "comment_tokens": ["TODO", ":", "validate", "the", "interface", "and", "mac", "address", "!", "Otherwise", ",", "there", "'s", "a", "race", "condition", "as", "soon", "as", "the", "kernel", "starts", "sending", "mpath", "notifications", "."], "ccode": ["#include <net/if.h>\n", "#include <errno.h>\n", "\n", "#include <netlink/genl/genl.h>\n", "#include <netlink/genl/family.h>\n", "#include <netlink/genl/ctrl.h>\n", "#include <netlink/msg.h>\n", "#include <netlink/attr.h>\n", "\n", "#include \"nl80211.h\"\n", "#include \"iw.h\"\n", "\n", "SECTION(mpp);\n", "\n", "static int print_mpp_handler(struct nl_msg *msg, void *arg)\n", "{\n", "\tstruct nlattr *tb[NL80211_ATTR_MAX + 1];\n", "\tstruct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));\n", "\tchar dst[20], next_hop[20], dev[20];\n", "\n", "\tnla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\n", "\t\t  genlmsg_attrlen(gnlh, 0), NULL);\n", "\n", "\t/*\n", "\t * TODO: validate the interface and mac address!\n", "\t * Otherwise, there's a race condition as soon as\n", "\t * the kernel starts sending mpath notifications.\n", "\t */\n", "\n", "\tmac_addr_n2a(dst, nla_data(tb[NL80211_ATTR_MAC]));\n", "\tmac_addr_n2a(next_hop, nla_data(tb[NL80211_ATTR_MPATH_NEXT_HOP]));\n", "\tif_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);\n", "\tprintf(\"%s %s %s\\n\", dst, next_hop, dev);\n", "\n", "\treturn NL_SKIP;\n", "}\n"], "project": "iw", "file": "mpp.pkl", "function": "print_mpp_handler"}, {"comment_all": {"comment": "/* distribution. Note that the formula used has been empirically derived, */", "depth": 1, "reading_ease": 27.49, "reading_grade": 11.9, "line": 98}, "comment_text": "/* State error in using the normal distribution instead of the exact      */\n/* distribution. Note that the formula used has been empirically derived, */\n/* and verified only for NTESTS*groupsize <= 10^5                         */\n", "comment_tokens": ["State", "error", "in", "using", "the", "normal", "distribution", "instead", "of", "the", "exact", "distribution", ".", "Note", "that", "the", "formula", "used", "has", "been", "empirically", "derived", ",", "and", "verified", "only", "for", "NTESTSgroupsize", "<", "=", "10^5"], "ccode": ["\n", "\n", "\n", "\n", "double test_normal(double *array, int n)\n", "{\n", "  double mean1, sd1, mean2, sd2, result, percent;\n", "  int i;\n", "  double result_min, result_max, error;\n", "  \n", "  mean2 = NTESTS*(group_size/2.0);\n", "  sd2 = sqrt( (double) NTESTS*(group_size/12.0) );\n", "  for(i=0; i<n; i++)\n", "    array[i] = (array[i] - mean2)/sd2;\n", "  \n", "  mean_sd(array,n,&mean1,&sd1);\n", "  printf(\"\\tMean = %f\\tstandard deviation = %f\\n\", mean1, sd1);\n", "  \n", "  set_normal_params(0.0, 1.0);\n", "  result = KS(array,n,normalF);\n", "\n", "  /* State error in using the normal distribution instead of the exact      */\n", "  /* distribution. Note that the formula used has been empirically derived, */\n", "  /* and verified only for NTESTS*groupsize <= 10^5                         */\n", "  error = 0.0275/NTESTS/group_size*sqrt((double) n);\n", "  printf(\"\\tKS range = [%f, %f]%%\\n\", 100*KSpercent(max(0.0,result-error),n),\n", "\t 100*KSpercent(min(sqrt((double) n),result+error),n) );\n", "  \n", "  percent = KSpercent(result,n);\n", "\n", "  return percent;\n", "}\n"], "project": "libsprng2", "file": "sum.pkl", "function": "test_normal"}, {"comment_all": {"comment": "/* jpnevulator - serial reader/writer\n * Copyright (C) 2006-2016 Freddy Spierenburg\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */", "depth": 0, "reading_ease": 46.91, "reading_grade": 12.7, "line": 0}, "comment_text": "/* jpnevulator - serial reader/writer\n * Copyright (C) 2006-2016 Freddy Spierenburg\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */", "comment_tokens": ["jpnevulator", "-", "serial", "readerwriter", "Copyright", "(", "C", ")", "2006-2016", "Freddy", "Spierenburg", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "St", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA"], "ccode": ["/* jpnevulator - serial reader/writer\n", " * Copyright (C) 2006-2016 Freddy Spierenburg\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " * \n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " * \n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <fcntl.h>\n", "#include <termios.h>\n", "#include <sys/ioctl.h>\n", "\n", "#include \"jpnevulator.h\"\n", "#include \"interface.h\"\n", "#include \"tty.h\"\n", "\n", "static int ttyOpen(char *name,int length) {\n", "\treturn(open(name,O_RDWR));\n", "}\n"], "project": "jpnevulator", "file": "tty.pkl", "function": "ttyOpen"}, {"comment_all": {"comment": "/*\n * Copyright (c) 1998, 2015 Todd C. Miller <Todd.Miller@courtesan.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */", "depth": 0, "reading_ease": 41.23, "reading_grade": 14.9, "line": 2}, "comment_text": "/*\n * Copyright (c) 1998, 2015 Todd C. Miller <Todd.Miller@courtesan.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */", "comment_tokens": ["Copyright", "(", "c", ")", "1998", ",", "2015", "Todd", "C.", "Miller", "<", "Todd.Miller", "@", "courtesan.com", ">", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "and", "distribute", "this", "software", "for", "any", "purpose", "with", "or", "without", "fee", "is", "hereby", "granted", ",", "provided", "that", "the", "above", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "all", "copies", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", "AND", "THE", "AUTHOR", "DISCLAIMS", "ALL", "WARRANTIES", "WITH", "REGARD", "TO", "THIS", "SOFTWARE", "INCLUDING", "ALL", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHOR", "BE", "LIABLE", "FOR", "ANY", "SPECIAL", ",", "DIRECT", ",", "INDIRECT", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "OR", "ANY", "DAMAGES", "WHATSOEVER", "RESULTING", "FROM", "LOSS", "OF", "USE", ",", "DATA", "OR", "PROFITS", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "NEGLIGENCE", "OR", "OTHER", "TORTIOUS", "ACTION", ",", "ARISING", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "USE", "OR", "PERFORMANCE", "OF", "THIS", "SOFTWARE", "."], "ccode": ["/*\t$OpenBSD: strlcpy.c,v 1.12 2015/01/15 03:54:12 millert Exp $\t*/\n", "\n", "/*\n", " * Copyright (c) 1998, 2015 Todd C. Miller <Todd.Miller@courtesan.com>\n", " *\n", " * Permission to use, copy, modify, and distribute this software for any\n", " * purpose with or without fee is hereby granted, provided that the above\n", " * copyright notice and this permission notice appear in all copies.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n", " * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n", " * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n", " * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n", " * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n", " * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n", " * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n", " */\n", "\n", "/* OPENBSD ORIGINAL: lib/libc/string/strlcpy.c */\n", "\n", "#include <sys/types.h>\n", "#include <string.h>\n", "#include \"calmwm.h\"\n", "\n", "#ifndef HAVE_STRLCPY\n", "\n", "/*\n", " * Copy string src to buffer dst of size dsize.  At most dsize-1\n", " * chars will be copied.  Always NUL terminates (unless dsize == 0).\n", " * Returns strlen(src); if retval >= dsize, truncation occurred.\n", " */\n", "size_t\n", "strlcpy(char *dst, const char *src, size_t dsize)\n", "{\n", "\tconst char *osrc = src;\n", "\tsize_t nleft = dsize;\n", "\n", "\t/* Copy as many bytes as will fit. */\n", "\tif (nleft != 0) {\n", "\t\twhile (--nleft != 0) {\n", "\t\t\tif ((*dst++ = *src++) == '\\0')\n", "\t\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\t/* Not enough room in dst, add NUL and traverse rest of src. */\n", "\tif (nleft == 0) {\n", "\t\tif (dsize != 0)\n", "\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n", "\t\twhile (*src++)\n", "\t\t\t;\n", "\t}\n", "\n", "\treturn(src - osrc - 1);\t/* count does not include NUL */\n", "}\n"], "project": "cwm", "file": "strlcpy.pkl", "function": "strlcpy"}, {"comment_all": {"comment": "/*\n * bzerofast.c\n *\n * Copyright (C) 1996 Limit Point Systems, Inc.\n *\n * Author: Ida Nielsen <ibniels@ca.sandia.gov>\n * Maintainer: LPS\n *\n * This file is part of the SC Toolkit.\n *\n * The SC Toolkit is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Library General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * The SC Toolkit is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with the SC Toolkit; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * The U.S. Government is granted a limited license as per AL 91-7.\n */", "depth": 0, "reading_ease": 62.88, "reading_grade": 8.7, "line": 0}, "comment_text": "/*\n * bzerofast.c\n *\n * Copyright (C) 1996 Limit Point Systems, Inc.\n *\n * Author: Ida Nielsen <ibniels@ca.sandia.gov>\n * Maintainer: LPS\n *\n * This file is part of the SC Toolkit.\n *\n * The SC Toolkit is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Library General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * The SC Toolkit is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with the SC Toolkit; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * The U.S. Government is granted a limited license as per AL 91-7.\n */", "comment_tokens": ["bzerofast.c", "Copyright", "(", "C", ")", "1996", "Limit", "Point", "Systems", ",", "Inc", ".", "Author", ":", "Ida", "Nielsen", "<", "ibniels", "@", "ca.sandia.gov", ">", "Maintainer", ":", "LPS", "This", "file", "is", "part", "of", "the", "SC", "Toolkit", ".", "The", "SC", "Toolkit", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "The", "SC", "Toolkit", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "the", "SC", "Toolkit", ";", "see", "the", "file", "COPYING.LIB", ".", "If", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", ".", "The", "U.S.", "Government", "is", "granted", "a", "limited", "license", "as", "per", "AL", "91-7", "."], "ccode": ["/*\n", " * bzerofast.c\n", " *\n", " * Copyright (C) 1996 Limit Point Systems, Inc.\n", " *\n", " * Author: Ida Nielsen <ibniels@ca.sandia.gov>\n", " * Maintainer: LPS\n", " *\n", " * This file is part of the SC Toolkit.\n", " *\n", " * The SC Toolkit is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU Library General Public License as published by\n", " * the Free Software Foundation; either version 2, or (at your option)\n", " * any later version.\n", " *\n", " * The SC Toolkit is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public License\n", " * along with the SC Toolkit; see the file COPYING.LIB.  If not, write to\n", " * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n", " *\n", " * The U.S. Government is granted a limited license as per AL 91-7.\n", " */\n", "\n", "#include <chemistry/qc/mbpt/bzerofast.h>\n", "\n", "/* Commented out this version since the compiler\n", " * cannot handle it */\n", "/*int bzerofast(double *d, int dimension)\n", "  {\n", "    int i;\n", "  \n", "    for (i=dimension; i; i--) {\n", "      *d++ = 0.0;\n", "      }\n", "  \n", "    return(0);\n", "  }                     */\n", "int bzerofast(double *d, int dimension)\n", "{\n", "  int i;\n", "\n", "  for (i=0; i<dimension; i++) {\n", "    *d++ = 0.0;\n", "    }\n", "\n", "  return(0);\n", "}\n"], "project": "libsc7v5", "file": "bzerofast.pkl", "function": "bzerofast"}, {"comment_all": {"comment": "/* We could have foo/bar\\\\baz, or foo\\\\bar, or d:bar.  */", "depth": 2, "reading_ease": 80.28, "reading_grade": 4.1, "line": 494}, "comment_text": "/* We could have foo/bar\\\\baz, or foo\\\\bar, or d:bar.  */", "comment_tokens": ["We", "could", "have", "foobar\\\\baz", ",", "or", "foo\\\\bar", ",", "or", "d", ":", "bar", "."], "ccode": ["\n", "/* Return a path for a new temporary file in the same directory\n", "   as file PATH.  */\n", "\n", "static char *\n", "template_in_dir (const char *path)\n", "{\n", "#define template \"stXXXXXX\"\n", "  const char *slash = strrchr (path, '/');\n", "  char *tmpname;\n", "  size_t len;\n", "\n", "#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n", "  {\n", "    /* We could have foo/bar\\\\baz, or foo\\\\bar, or d:bar.  */\n", "    char *bslash = strrchr (path, '\\\\');\n", "\n", "    if (slash == NULL || (bslash != NULL && bslash > slash))\n", "      slash = bslash;\n", "    if (slash == NULL && path[0] != '\\0' && path[1] == ':')\n", "      slash = path + 1;\n", "  }\n", "#endif\n", "\n", "  if (slash != (char *) NULL)\n", "    {\n", "      len = slash - path;\n", "      tmpname = (char *) xmalloc (len + sizeof (template) + 2);\n", "      memcpy (tmpname, path, len);\n", "\n", "#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n", "      /* If tmpname is \"X:\", appending a slash will make it a root\n", "\t directory on drive X, which is NOT the same as the current\n", "\t directory on drive X.  */\n", "      if (len == 2 && tmpname[1] == ':')\n", "\ttmpname[len++] = '.';\n", "#endif\n", "      tmpname[len++] = '/';\n", "    }\n", "  else\n", "    {\n", "      tmpname = (char *) xmalloc (sizeof (template));\n", "      len = 0;\n", "    }\n", "\n", "  memcpy (tmpname + len, template, sizeof (template));\n", "  return tmpname;\n", "#undef template\n", "}\n"], "project": "binutils-multiarch-dbg", "file": "bucomm.pkl", "function": "template_in_dir"}, {"comment_all": {"comment": "/*\n * add_to_list: This will add an element to a list.  The requirements for the\n * list are that the first element in each list structure be a pointer to the\n * next element in the list, and the second element in the list structure be\n * a pointer to a character (char *) which represents the sort key.  For\n * example \n *\n * struct my_list{ struct my_list *next; char *name; <whatever else you want>}; \n *\n * The parameters are:  \"list\" which is a pointer to the head of the list. \"add\"\n * which is a pre-allocated element to be added to the list.\n */", "depth": 0, "reading_ease": 65.05, "reading_grade": 9.9, "line": 54}, "comment_text": "/*\n * add_to_list: This will add an element to a list.  The requirements for the\n * list are that the first element in each list structure be a pointer to the\n * next element in the list, and the second element in the list structure be\n * a pointer to a character (char *) which represents the sort key.  For\n * example \n *\n * struct my_list{ struct my_list *next; char *name; <whatever else you want>}; \n *\n * The parameters are:  \"list\" which is a pointer to the head of the list. \"add\"\n * which is a pre-allocated element to be added to the list.\n */", "comment_tokens": ["add_to_list", ":", "This", "will", "add", "an", "element", "to", "a", "list", ".", "The", "requirements", "for", "the", "list", "are", "that", "the", "first", "element", "in", "each", "list", "structure", "be", "a", "pointer", "to", "the", "next", "element", "in", "the", "list", ",", "and", "the", "second", "element", "in", "the", "list", "structure", "be", "a", "pointer", "to", "a", "character", "(", "char", ")", "which", "represents", "the", "sort", "key", ".", "For", "example", "struct", "my_list", "{", "struct", "my_list", "next", ";", "char", "name", ";", "<", "whatever", "else", "you", "want", ">", "}", ";", "The", "parameters", "are", ":", "``", "list", "''", "which", "is", "a", "pointer", "to", "the", "head", "of", "the", "list", ".", "``", "add", "''", "which", "is", "a", "pre-allocated", "element", "to", "be", "added", "to", "the", "list", "."], "ccode": ["\n", "/*\n", " * add_to_list: This will add an element to a list.  The requirements for the\n", " * list are that the first element in each list structure be a pointer to the\n", " * next element in the list, and the second element in the list structure be\n", " * a pointer to a character (char *) which represents the sort key.  For\n", " * example \n", " *\n", " * struct my_list{ struct my_list *next; char *name; <whatever else you want>}; \n", " *\n", " * The parameters are:  \"list\" which is a pointer to the head of the list. \"add\"\n", " * which is a pre-allocated element to be added to the list.\n", " */\n", "void \tadd_to_list (List **list, List *add)\n", "{\n", "\tList\t*tmp,\n", "\t\t*last = NULL;\n", "\n", "\tfor (tmp = *list; tmp; tmp = tmp->next)\n", "\t{\n", "\t\tif (add_list_strcmp(tmp, add) > 0)\n", "\t\t\tbreak;\n", "\t\tlast = tmp;\n", "\t}\n", "\n", "\tif (last)\n", "\t\tlast->next = add;\n", "\telse\n", "\t\t*list = add;\n", "\n", "\tadd->next = tmp;\n", "\treturn;\n", "}\n"], "project": "epic4", "file": "list.pkl", "function": "add_to_list"}, {"comment_all": {"comment": "/* Find smallest element in first threshold and place it at the\n           array's beginning.  This is the smallest array element,\n           and the operation speeds up insertion sort's inner loop. */", "depth": 2, "reading_ease": 57.27, "reading_grade": 8.8, "line": 1216}, "comment_text": "/* Find smallest element in first threshold and place it at the\n           array's beginning.  This is the smallest array element,\n           and the operation speeds up insertion sort's inner loop. */", "comment_tokens": ["Find", "smallest", "element", "in", "first", "threshold", "and", "place", "it", "at", "the", "array", "'s", "beginning", ".", "This", "is", "the", "smallest", "array", "element", ",", "and", "the", "operation", "speeds", "up", "insertion", "sort", "'s", "inner", "loop", "."], "ccode": ["\n", "#define is_smaller_pair(a, b) \\\n", "    ((a)->z < (b)->z || ((a)->z == (b)->z && (a)->k < (b)->k))\n", "\n", "#define PSWAP(x, y) GWY_SWAP(Pair, x, y)\n", "\n", "#define STACK_SIZE      (CHAR_BIT * sizeof(gsize))\n", "#define PUSH(low, high) ((void) ((top->lo = (low)), (top->hi = (high)), ++top))\n", "#define POP(low, high)  ((void) (--top, (low = top->lo), (high = top->hi)))\n", "#define STACK_NOT_EMPTY (stack < top)\n", "\n", "/* Order size using quicksort.  This implementation incorporates\n", "   four optimizations discussed in Sedgewick:\n", "\n", "   1. Non-recursive, using an explicit stack of pointer that store the\n", "   next array partition to sort.  To save time, this maximum amount\n", "   of space required to store an array of SIZE_MAX is allocated on the\n", "   stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs\n", "   only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).\n", "   Pretty cheap, actually.\n", "\n", "   2. Chose the pivot element using a median-of-three decision tree.\n", "   This reduces the probability of selecting a bad pivot value and\n", "   eliminates certain extraneous comparisons.\n", "\n", "   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving\n", "   insertion sort to order the MAX_THRESH items within each partition.\n", "   This is a big win, since insertion sort is faster for small, mostly\n", "   sorted array segments.\n", "\n", "   4. The larger of the two sub-partitions is always pushed onto the\n", "   stack first, with the algorithm then concentrating on the\n", "   smaller partition.  This *guarantees* no more than log(n)\n", "   stack size is needed (actually O(1) in this case)!  */\n", "\n", "static void\n", "sort_pairs(Pair *array,\n", "           gsize n)\n", "{\n", "    /* Note: Specialization makes the insertion sort part relatively more\n", "     * efficient, after some benchmarking this seems be about the best value\n", "     * on Athlon 64. */\n", "    enum { MAX_THRESH = 20 };\n", "\n", "    // Stack node declarations used to store unfulfilled partition obligations.\n", "    typedef struct {\n", "        Pair *lo;\n", "        Pair *hi;\n", "    } stack_node;\n", "\n", "    if (n < 2)\n", "        /* Avoid lossage with unsigned arithmetic below.  */\n", "        return;\n", "\n", "    if (n > MAX_THRESH) {\n", "        Pair *lo = array;\n", "        Pair *hi = lo + (n - 1);\n", "        stack_node stack[STACK_SIZE];\n", "        stack_node *top = stack + 1;\n", "\n", "        while (STACK_NOT_EMPTY) {\n", "            Pair *left_ptr;\n", "            Pair *right_ptr;\n", "\n", "            /* Select median value from among LO, MID, and HI. Rearrange\n", "               LO and HI so the three values are sorted. This lowers the\n", "               probability of picking a pathological pivot value and\n", "               skips a comparison for both the LEFT_PTR and RIGHT_PTR in\n", "               the while loops. */\n", "\n", "            Pair *mid = lo + ((hi - lo) >> 1);\n", "\n", "            if (is_smaller_pair(mid, lo))\n", "                PSWAP(*mid, *lo);\n", "            if (is_smaller_pair(hi, mid))\n", "                PSWAP(*mid, *hi);\n", "            else\n", "                goto jump_over;\n", "            if (is_smaller_pair(mid, lo))\n", "                PSWAP(*mid, *lo);\n", "\n", "jump_over:\n", "          left_ptr  = lo + 1;\n", "          right_ptr = hi - 1;\n", "\n", "          /* Here's the famous ``collapse the walls'' section of quicksort.\n", "             Gotta like those tight inner loops!  They are the main reason\n", "             that this algorithm runs much faster than others. */\n", "          do {\n", "              while (is_smaller_pair(left_ptr, mid))\n", "                  left_ptr++;\n", "\n", "              while (is_smaller_pair(mid, right_ptr))\n", "                  right_ptr--;\n", "\n", "              if (left_ptr < right_ptr) {\n", "                  PSWAP(*left_ptr, *right_ptr);\n", "                  if (mid == left_ptr)\n", "                      mid = right_ptr;\n", "                  else if (mid == right_ptr)\n", "                      mid = left_ptr;\n", "                  left_ptr++;\n", "                  right_ptr--;\n", "              }\n", "              else if (left_ptr == right_ptr) {\n", "                  left_ptr++;\n", "                  right_ptr--;\n", "                  break;\n", "              }\n", "          }\n", "          while (left_ptr <= right_ptr);\n", "\n", "          /* Set up pointers for next iteration.  First determine whether\n", "             left and right partitions are below the threshold size.  If so,\n", "             ignore one or both.  Otherwise, push the larger partition's\n", "             bounds on the stack and continue sorting the smaller one. */\n", "\n", "          if ((gsize)(right_ptr - lo) <= MAX_THRESH) {\n", "              if ((gsize)(hi - left_ptr) <= MAX_THRESH)\n", "                  /* Ignore both small partitions. */\n", "                  POP(lo, hi);\n", "              else\n", "                  /* Ignore small left partition. */\n", "                  lo = left_ptr;\n", "          }\n", "          else if ((gsize)(hi - left_ptr) <= MAX_THRESH)\n", "              /* Ignore small right partition. */\n", "              hi = right_ptr;\n", "          else if ((right_ptr - lo) > (hi - left_ptr)) {\n", "              /* Push larger left partition indices. */\n", "              PUSH(lo, right_ptr);\n", "              lo = left_ptr;\n", "          }\n", "          else {\n", "              /* Push larger right partition indices. */\n", "              PUSH(left_ptr, hi);\n", "              hi = right_ptr;\n", "          }\n", "        }\n", "    }\n", "\n", "    /* Once the BASE_PTR array is partially sorted by quicksort the rest\n", "       is completely sorted using insertion sort, since this is efficient\n", "       for partitions below MAX_THRESH size. BASE_PTR points to the beginning\n", "       of the array to sort, and END_PTR points at the very last element in\n", "       the array (*not* one beyond it!). */\n", "\n", "    {\n", "        Pair *const end_ptr = array + (n - 1);\n", "        Pair *tmp_ptr = array;\n", "        Pair *thresh = MIN(end_ptr, array + MAX_THRESH);\n", "        Pair *run_ptr;\n", "\n", "        /* Find smallest element in first threshold and place it at the\n", "           array's beginning.  This is the smallest array element,\n", "           and the operation speeds up insertion sort's inner loop. */\n", "\n", "        for (run_ptr = tmp_ptr + 1; run_ptr <= thresh; run_ptr++) {\n", "            if (is_smaller_pair(run_ptr, tmp_ptr))\n", "                tmp_ptr = run_ptr;\n", "        }\n", "\n", "        if (tmp_ptr != array)\n", "            PSWAP(*tmp_ptr, *array);\n", "\n", "        /* Insertion sort, running from left-hand-side up to right-hand-side.\n", "         */\n", "\n", "        run_ptr = array + 1;\n", "        while (++run_ptr <= end_ptr) {\n", "            tmp_ptr = run_ptr - 1;\n", "            while (is_smaller_pair(run_ptr, tmp_ptr))\n", "                tmp_ptr--;\n", "\n", "            tmp_ptr++;\n", "            if (tmp_ptr != run_ptr) {\n", "                Pair *hi, *lo;\n", "                Pair d;\n", "\n", "                d = *run_ptr;\n", "                for (hi = lo = run_ptr; --lo >= tmp_ptr; hi = lo)\n", "                    *hi = *lo;\n", "                *hi = d;\n", "            }\n", "        }\n", "    }\n", "}\n"], "project": "gwyddion", "file": "grains-wshed.pkl", "function": "sort_pairs"}, {"comment_all": {"comment": "/**\n * trace_seq_init - initialize the trace_seq structure\n * @s: a pointer to the trace_seq structure to initialize\n */", "depth": 0, "reading_ease": 40.35, "reading_grade": 11.1, "line": 38}, "comment_text": "/**\n * trace_seq_init - initialize the trace_seq structure\n * @s: a pointer to the trace_seq structure to initialize\n */", "comment_tokens": ["trace_seq_init", "-", "initialize", "the", "trace_seq", "structure", "@", "s", ":", "a", "pointer", "to", "the", "trace_seq", "structure", "to", "initialize"], "ccode": ["\n", "/**\n", " * trace_seq_init - initialize the trace_seq structure\n", " * @s: a pointer to the trace_seq structure to initialize\n", " */\n", "void trace_seq_init(struct trace_seq *s)\n", "{\n", "\ts->len = 0;\n", "\ts->readpos = 0;\n", "\ts->buffer_size = TRACE_SEQ_BUF_SIZE;\n", "\ts->buffer = malloc_or_die(s->buffer_size);\n", "}\n"], "project": "rasdaemon", "file": "trace-seq.pkl", "function": "trace_seq_init"}, {"comment_all": {"comment": "/* Support for 32-bit programs running in 64-bit HP-UX.\n             The documented way to do this is to use the same source code\n             as above, but in a compilation unit where '#define _PSTAT64 1'\n             is in effect.  I prefer a single compilation unit; the struct\n             size and the offsets are not going to change.  */", "depth": 3, "reading_ease": 79.3, "reading_grade": 6.5, "line": 142}, "comment_text": "/* Support for 32-bit programs running in 64-bit HP-UX.\n             The documented way to do this is to use the same source code\n             as above, but in a compilation unit where '#define _PSTAT64 1'\n             is in effect.  I prefer a single compilation unit; the struct\n             size and the offsets are not going to change.  */", "comment_tokens": ["Support", "for", "32-bit", "programs", "running", "in", "64-bit", "HP-UX", ".", "The", "documented", "way", "to", "do", "this", "is", "to", "use", "the", "same", "source", "code", "as", "above", ",", "but", "in", "a", "compilation", "unit", "where", "'", "#", "define", "_PSTAT64", "1'", "is", "in", "effect", ".", "I", "prefer", "a", "single", "compilation", "unit", ";", "the", "struct", "size", "and", "the", "offsets", "are", "not", "going", "to", "change", "."], "ccode": ["/* Program name management.\n", "   Copyright (C) 2016-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"getprogname.h\"\n", "\n", "#include <errno.h> /* get program_invocation_name declaration */\n", "#include <stdlib.h> /* get __argv declaration */\n", "\n", "#ifdef _AIX\n", "# include <unistd.h>\n", "# include <procinfo.h>\n", "# include <string.h>\n", "#endif\n", "\n", "#ifdef __MVS__\n", "# ifndef _OPEN_SYS\n", "#  define _OPEN_SYS\n", "# endif\n", "# include <string.h>\n", "# include <sys/ps.h>\n", "#endif\n", "\n", "#ifdef __hpux\n", "# include <unistd.h>\n", "# include <sys/param.h>\n", "# include <sys/pstat.h>\n", "# include <string.h>\n", "#endif\n", "\n", "#ifdef __sgi\n", "# include <string.h>\n", "# include <unistd.h>\n", "# include <stdio.h>\n", "# include <fcntl.h>\n", "# include <sys/procfs.h>\n", "#endif\n", "\n", "#include \"dirname.h\"\n", "\n", "#ifndef HAVE_GETPROGNAME             /* not Mac OS X, FreeBSD, NetBSD, OpenBSD >= 5.4, Cygwin */\n", "char const *\n", "getprogname (void)\n", "{\n", "# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n", "  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n", "  return program_invocation_short_name;\n", "# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n", "  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n", "  return last_component (program_invocation_name);\n", "# elif HAVE_GETEXECNAME                                     /* Solaris */\n", "  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n", "  const char *p = getexecname ();\n", "  if (!p)\n", "    p = \"?\";\n", "  return last_component (p);\n", "# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n", "  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n", "  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n", "  return last_component (p);\n", "# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n", "  /* https://man.openbsd.org/style.9 */\n", "  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n", "  /* Be careful to declare this only when we absolutely need it\n", "     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n", "     its mere declaration makes program_invocation_short_name\n", "     malfunction (have zero length) with Fedora 25's glibc.  */\n", "  extern char *__progname;\n", "  const char *p = __progname;\n", "  return p && p[0] ? p : \"?\";\n", "# elif _AIX                                                 /* AIX */\n", "  /* Idea by Bastien ROUCARI\u00c8S,\n", "     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n", "     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n", "  */\n", "  static char *p;\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      first = 0;\n", "      pid_t pid = getpid ();\n", "      struct procentry64 procs;\n", "      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n", "           ? strdup (procs.pi_comm)\n", "           : NULL);\n", "      if (!p)\n", "        p = \"?\";\n", "    }\n", "  return p;\n", "# elif defined __hpux\n", "  static char *p;\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      first = 0;\n", "      pid_t pid = getpid ();\n", "      struct pst_status status;\n", "      if (pstat_getproc (&status, sizeof status, 0, pid) > 0)\n", "        {\n", "          char *ucomm = status.pst_ucomm;\n", "          char *cmd = status.pst_cmd;\n", "          if (strlen (ucomm) < PST_UCOMMLEN - 1)\n", "            p = ucomm;\n", "          else\n", "            {\n", "              /* ucomm is truncated to length PST_UCOMMLEN - 1.\n", "                 Look at cmd instead.  */\n", "              char *space = strchr (cmd, ' ');\n", "              if (space != NULL)\n", "                *space = '\\0';\n", "              p = strrchr (cmd, '/');\n", "              if (p != NULL)\n", "                p++;\n", "              else\n", "                p = cmd;\n", "              if (strlen (p) > PST_UCOMMLEN - 1\n", "                  && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n", "                /* p is less truncated than ucomm.  */\n", "                ;\n", "              else\n", "                p = ucomm;\n", "            }\n", "          p = strdup (p);\n", "        }\n", "      else\n", "        {\n", "#  if !defined __LP64__\n", "          /* Support for 32-bit programs running in 64-bit HP-UX.\n", "             The documented way to do this is to use the same source code\n", "             as above, but in a compilation unit where '#define _PSTAT64 1'\n", "             is in effect.  I prefer a single compilation unit; the struct\n", "             size and the offsets are not going to change.  */\n", "          char status64[1216];\n", "          if (__pstat_getproc64 (status64, sizeof status64, 0, pid) > 0)\n", "            {\n", "              char *ucomm = status64 + 288;\n", "              char *cmd = status64 + 168;\n", "              if (strlen (ucomm) < PST_UCOMMLEN - 1)\n", "                p = ucomm;\n", "              else\n", "                {\n", "                  /* ucomm is truncated to length PST_UCOMMLEN - 1.\n", "                     Look at cmd instead.  */\n", "                  char *space = strchr (cmd, ' ');\n", "                  if (space != NULL)\n", "                    *space = '\\0';\n", "                  p = strrchr (cmd, '/');\n", "                  if (p != NULL)\n", "                    p++;\n", "                  else\n", "                    p = cmd;\n", "                  if (strlen (p) > PST_UCOMMLEN - 1\n", "                      && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n", "                    /* p is less truncated than ucomm.  */\n", "                    ;\n", "                  else\n", "                    p = ucomm;\n", "                }\n", "              p = strdup (p);\n", "            }\n", "          else\n", "#  endif\n", "            p = NULL;\n", "        }\n", "      if (!p)\n", "        p = \"?\";\n", "    }\n", "  return p;\n", "# elif __MVS__                                              /* z/OS */\n", "  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n", "  static char *p = \"?\";\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      pid_t pid = getpid ();\n", "      int token;\n", "      W_PSPROC buf;\n", "      first = 0;\n", "      memset (&buf, 0, sizeof(buf));\n", "      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n", "      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n", "      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n", "      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n", "        {\n", "          for (token = 0; token >= 0;\n", "               token = w_getpsent (token, &buf, sizeof(buf)))\n", "            {\n", "              if (token > 0 && buf.ps_pid == pid)\n", "                {\n", "                  char *s = strdup (last_component (buf.ps_pathptr));\n", "                  if (s)\n", "                    p = s;\n", "                  break;\n", "                }\n", "            }\n", "        }\n", "      free (buf.ps_cmdptr);\n", "      free (buf.ps_conttyptr);\n", "      free (buf.ps_pathptr);\n", "    }\n", "  return p;\n", "# elif defined __sgi                                        /* IRIX */\n", "  char filename[50];\n", "  int fd;\n", "\n", "  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n", "  fd = open (filename, O_RDONLY);\n", "  if (0 <= fd)\n", "    {\n", "      prpsinfo_t buf;\n", "      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n", "      close (fd);\n", "      if (ioctl_ok)\n", "        {\n", "          char *name = buf.pr_fname;\n", "          size_t namesize = sizeof buf.pr_fname;\n", "          char *namenul = memchr (name, '\\0', namesize);\n", "          size_t namelen = namenul ? namenul - name : namesize;\n", "          char *namecopy = malloc (namelen + 1);\n", "          if (namecopy)\n", "            {\n", "              namecopy[namelen] = 0;\n", "              return memcpy (namecopy, name, namelen);\n", "            }\n", "        }\n", "    }\n", "  return NULL;\n", "# else\n", "#  error \"getprogname module not ported to this OS\"\n", "# endif\n", "}\n"], "project": "grub-ieee1275-bin", "file": "getprogname.pkl", "function": "getprogname"}, {"comment_all": {"comment": "/*\n * Calculate the number of words to use.  The first word is always present\n * (hence the \"1 +\" and the \"- WORD_BITS\").  Each one of the following words,\n * if any, is prefixed by a separator character, so we use SWORD_BITS when\n * calculating how many additional words to use.  We divide \"bits - WORD_BITS\"\n * by SWORD_BITS with rounding up (hence the addition of \"SWORD_BITS - 1\").\n */", "depth": 1, "reading_ease": 64.71, "reading_grade": 8.0, "line": 96}, "comment_text": "/*\n * Calculate the number of words to use.  The first word is always present\n * (hence the \"1 +\" and the \"- WORD_BITS\").  Each one of the following words,\n * if any, is prefixed by a separator character, so we use SWORD_BITS when\n * calculating how many additional words to use.  We divide \"bits - WORD_BITS\"\n * by SWORD_BITS with rounding up (hence the addition of \"SWORD_BITS - 1\").\n */", "comment_tokens": ["Calculate", "the", "number", "of", "words", "to", "use", ".", "The", "first", "word", "is", "always", "present", "(", "hence", "the", "``", "1", "+", "''", "and", "the", "``", "-", "WORD_BITS", "''", ")", ".", "Each", "one", "of", "the", "following", "words", ",", "if", "any", ",", "is", "prefixed", "by", "a", "separator", "character", ",", "so", "we", "use", "SWORD_BITS", "when", "calculating", "how", "many", "additional", "words", "to", "use", ".", "We", "divide", "``", "bits", "-", "WORD_BITS", "''", "by", "SWORD_BITS", "with", "rounding", "up", "(", "hence", "the", "addition", "of", "``", "SWORD_BITS", "-", "1", "''", ")", "."], "ccode": ["\n", "char *passwdqc_random(const passwdqc_params_qc_t *params)\n", "{\n", "\tchar output[0x100], *retval;\n", "\tint bits;\n", "\tint word_count, trailing_separator, use_separators, toggle_case;\n", "\tint i;\n", "\tunsigned int max_length, length, extra;\n", "\tconst char *start, *end;\n", "\tint fd;\n", "\tunsigned char bytes[3];\n", "\n", "\tbits = params->random_bits;\n", "\tif (bits < BITS_MIN || bits > BITS_MAX)\n", "\t\treturn NULL;\n", "\n", "/*\n", " * Calculate the number of words to use.  The first word is always present\n", " * (hence the \"1 +\" and the \"- WORD_BITS\").  Each one of the following words,\n", " * if any, is prefixed by a separator character, so we use SWORD_BITS when\n", " * calculating how many additional words to use.  We divide \"bits - WORD_BITS\"\n", " * by SWORD_BITS with rounding up (hence the addition of \"SWORD_BITS - 1\").\n", " */\n", "\tword_count = 1 + (bits + (SWORD_BITS - 1 - WORD_BITS)) / SWORD_BITS;\n", "\n", "/*\n", " * Special case: would we still encode enough bits if we omit the final word,\n", " * but keep the would-be-trailing separator?\n", " */\n", "\ttrailing_separator = (SWORD_BITS * (word_count - 1) >= bits);\n", "\tword_count -= trailing_separator;\n", "\n", "/*\n", " * To determine whether we need to use different separator characters or maybe\n", " * not, calculate the number of words we'd need to use if we don't use\n", " * different separators.  We calculate it by dividing \"bits\" by WORD_BITS with\n", " * rounding up (hence the addition of \"WORD_BITS - 1\").  The resulting number\n", " * is either the same as or greater than word_count.  Use different separators\n", " * only if their use, in the word_count calculation above, has helped reduce\n", " * word_count.\n", " */\n", "\tuse_separators = ((bits + (WORD_BITS - 1)) / WORD_BITS != word_count);\n", "\ttrailing_separator &= use_separators;\n", "\n", "/*\n", " * Toggle case of the first character of each word only if we wouldn't achieve\n", " * sufficient entropy otherwise.\n", " */\n", "\ttoggle_case = (bits >\n", "\t    ((WORD_BITS - 1) * word_count) +\n", "\t    (use_separators ?\n", "\t    (SEPARATOR_BITS * (word_count - !trailing_separator)) : 0));\n", "\n", "/*\n", " * Calculate and check the maximum possible length of a \"passphrase\" we may\n", " * generate for a given word_count.  We add 1 to WORDSET_4K_LENGTH_MAX to\n", " * account for separators (whether different or not).  When there's no\n", " * trailing separator, we subtract 1.  The check against sizeof(output) uses\n", " * \">=\" to account for NUL termination.\n", " */\n", "\tmax_length = word_count * (WORDSET_4K_LENGTH_MAX + 1) -\n", "\t    !trailing_separator;\n", "\tif (max_length >= sizeof(output) || (int)max_length > params->max)\n", "\t\treturn NULL;\n", "\n", "\tif ((fd = open(\"/dev/urandom\", O_RDONLY)) < 0)\n", "\t\treturn NULL;\n", "\n", "\tretval = NULL;\n", "\tlength = 0;\n", "\tdo {\n", "\t\tif (read_loop(fd, bytes, sizeof(bytes)) != sizeof(bytes))\n", "\t\t\tgoto out;\n", "\n", "/*\n", " * Append a word.  Treating bytes as little-endian, we use bits 0 to 11 for the\n", " * word index, and bit 13 for toggling the case of the first character.  Bits\n", " * 12, 14, and 15 are left unused.  Bits 16 to 23 are left for the separator.\n", " */\n", "\t\ti = (((int)bytes[1] & 0x0f) << 8) | (int)bytes[0];\n", "\t\tstart = _passwdqc_wordset_4k[i];\n", "\t\tend = memchr(start, '\\0', WORDSET_4K_LENGTH_MAX);\n", "\t\tif (!end)\n", "\t\t\tend = start + WORDSET_4K_LENGTH_MAX;\n", "\t\textra = end - start;\n", "/* The \">=\" leaves room for either one more separator or NUL */\n", "\t\tif (length + extra >= sizeof(output))\n", "\t\t\tgoto out;\n", "\t\tmemcpy(&output[length], start, extra);\n", "\t\tif (toggle_case) {\n", "/* Toggle case if bit set (we assume ASCII) */\n", "\t\t\toutput[length] ^= bytes[1] & 0x20;\n", "\t\t\tbits--;\n", "\t\t}\n", "\t\tlength += extra;\n", "\t\tbits -= WORD_BITS - 1;\n", "\n", "\t\tif (bits <= 0)\n", "\t\t\tbreak;\n", "\n", "/*\n", " * Append a separator character.  We use bits 16 to 19.  Bits 20 to 23 are left\n", " * unused.\n", " *\n", " * Special case: we may happen to leave a trailing separator if it provides\n", " * enough bits on its own.  With WORD_BITS 13 and SEPARATOR_BITS 4, this\n", " * happens e.g. for bits values from 31 to 34, 48 to 51, 65 to 68.\n", " */\n", "\t\tif (use_separators) {\n", "\t\t\ti = bytes[2] & 0x0f;\n", "\t\t\toutput[length++] = SEPARATORS[i];\n", "\t\t\tbits -= SEPARATOR_BITS;\n", "\t\t} else\n", "\t\t\toutput[length++] = SEPARATORS[0];\n", "\t} while (bits > 0);\n", "\n", "/*\n", " * Since we may have added a separator after the check in the loop above, we\n", " * must check again now.\n", " */\n", "\tif (length < sizeof(output)) {\n", "\t\toutput[length] = '\\0';\n", "\t\tretval = strdup(output);\n", "\t}\n", "\n", "out:\n", "\tmemset(bytes, 0, sizeof(bytes));\n", "\tmemset(output, 0, length);\n", "\n", "\tclose(fd);\n", "\n", "\treturn retval;\n", "}\n"], "project": "libpasswdqc-dev", "file": "passwdqc_random.pkl", "function": "passwdqc_random"}, {"comment_all": {"comment": "/* Provide human readable information about errors */", "depth": 0, "reading_ease": 14.63, "reading_grade": 12.7, "line": 101}, "comment_text": "/* Provide human readable information about errors */", "comment_tokens": ["Provide", "human", "readable", "information", "about", "errors"], "ccode": ["\n", "/* Provide human readable information about errors */\n", "static canl_err_code\n", "update_error_msg(canl_ctx cc, const char *new_msg)\n", "{\n", "    int error_length = 0;\n", "    char *new_error = NULL;\n", "    char code_str[ERR_CODE_LEN];\n", "    int code_len = 0;\n", "    char *separ = \": \";\n", "    char *separ_2 = \"; \";\n", "    int separ_len = 0;\n", "    int separ_2_len = 0;\n", "    int err_old_msg_len = 0;\n", "    int err_new_msg_len = 0;\n", "    glb_ctx *ctx = (glb_ctx*) cc;\n", "\n", "    code_str[0] = '\\0';\n", "\n", "    /*check cc*/\n", "    if (!ctx) {\n", "        return EINVAL;\n", "    }\n", "\n", "    if (ctx->err_msg)\n", "        err_old_msg_len = strlen(ctx->err_msg);\n", "    \n", "    if (new_msg)\n", "        err_new_msg_len = strlen(new_msg);\n", "\n", "    /* get human readable error code */\n", "    get_error_string(cc, code_str);\n", "    code_len = strlen(code_str);\n", "\n", "    separ_len = strlen(separ);\n", "    separ_2_len = strlen(separ_2);\n", "    error_length = err_new_msg_len + err_old_msg_len + code_len + \n", "        (2*separ_len) + 1;\n", "    new_error = (char *) malloc ((error_length) * sizeof (char));\n", "    if (!new_error) {\n", "        return set_error(ctx, ENOMEM, POSIX_ERROR, \"cannot get error message\");\n", "    }\n", "    \n", "    new_error[0] = '\\0';\n", "    if (new_msg) {\n", "        strncpy(new_error, new_msg, err_new_msg_len + 1);\n", "        strncat(new_error, separ, separ_len + 1);\n", "    }\n", "    strncat(new_error, code_str, code_len + 1);\n", "    strncat(new_error, separ_2, separ_2_len + 1);\n", "    if (ctx->err_msg) {\n", "        strncat(new_error, ctx->err_msg, err_old_msg_len + 1);\n", "    }\n", "\n", "    if (ctx->err_msg)\n", "        free(ctx->err_msg);\n", "    ctx->err_msg = new_error;\n", "    return 0;\n", "}\n"], "project": "libcanl-c-examples", "file": "canl_err.pkl", "function": "update_error_msg"}, {"comment_all": {"comment": "/* Try not to leave state in memory. */", "depth": 1, "reading_ease": 89.75, "reading_grade": 2.5, "line": 386}, "comment_text": "/* Try not to leave state in memory. */", "comment_tokens": ["Try", "not", "to", "leave", "state", "in", "memory", "."], "ccode": ["\n", "\n", "static void\n", "py_blake2s_dealloc(PyObject *self)\n", "{\n", "    BLAKE2sObject *obj = (BLAKE2sObject *)self;\n", "\n", "    /* Try not to leave state in memory. */\n", "    secure_zero_memory(&obj->param, sizeof(obj->param));\n", "    secure_zero_memory(&obj->state, sizeof(obj->state));\n", "    if (obj->lock) {\n", "        PyThread_free_lock(obj->lock);\n", "        obj->lock = NULL;\n", "    }\n", "    PyObject_Del(self);\n", "}\n"], "project": "libpython3.9-minimal", "file": "blake2s_impl.pkl", "function": "py_blake2s_dealloc"}, {"comment_all": {"comment": "/* Print out a known name to stop repeated calls */", "depth": 1, "reading_ease": 96.18, "reading_grade": 2.1, "line": 705}, "comment_text": "/* Print out a known name to stop repeated calls */", "comment_tokens": ["Print", "out", "a", "known", "name", "to", "stop", "repeated", "calls"], "ccode": ["\n", "/* Takes an address and returns useful bits of the name after lookup,\n", "   this was a separate program, but it is more compact to have both\n", "   together.  17/02/94  JSP */\n", "\n", "int in2host(char *address,\n", "\t    int bp_pr)\n", "{\n", "  struct in_addr sin_addr;\n", "  struct hostent *hp;\n", "  char *c ;\n", "\n", "  printflag=bp_pr ;\n", "\n", "/* convert to standard network form */\n", "  sin_addr.s_addr = inet_addr(address);\n", "\n", "/* perform lookup, must have DNS running or have local hosts file at\n", "   this point */\n", "\n", "  hp = gethostbyaddr((char *)&sin_addr, sizeof(sin_addr), AF_INET) ;\n", "\n", "  if (hp == NULL) {\n", "    perror (\"bootpc: gethostbyaddr\") ;\n", "    return -1;\n", "  }\n", "\n", "/* Print out a known name to stop repeated calls */\n", "  OutString(\"DONEIN2HOST\",(unsigned char *)\"1\", -1) ;\n", "\n", "/* Print out full name as returned by the call */\n", "  OutString(\"HOSTFULL\", (unsigned char *)(hp->h_name), -1) ;\n", "\n", "  for(c=(char *)hp->h_name; *c ; ++c)\n", "    if(*c == '.') {\n", "/* Zap first 'dot' to give leaf and domain names */\n", "      OutString(\"HOSTDOMAIN\", (unsigned char *)(c+1), -1) ;\n", "      OutSearch(\"HOSTSEARCH\", (unsigned char *)(c+1), strlen(c+1)) ;\n", "      *c = 0 ;\n", "      OutString(\"HOSTLEAF\", (unsigned char *)(hp->h_name), -1) ;\n", "      return 0 ;\n", "    }\n", "  return 0 ;\n", "}\n"], "project": "bootpc", "file": "bootpc.pkl", "function": "in2host"}, {"comment_all": {"comment": "//alsaplayer_error(\"short_mask = 0x%X\", short_mask);\t\n", "depth": 1, "reading_ease": -50.02, "reading_grade": 21.0, "line": 113}, "comment_text": "//alsaplayer_error(\"short_mask = 0x%X\", short_mask);\t\n", "comment_tokens": ["alsaplayer_error", "(", "``", "short_mask", "=", "0x", "%", "X", "''", ",", "short_mask", ")", ";"], "ccode": ["\n", "\n", "static int sndfile_open (input_object *obj, const char *name)\n", "{\n", "\tstruct sf_local_data *data;\n", "\tchar *p;\n", "\tint short_mask;\n", "\n", "\tif (!obj)\n", "\t\treturn 0;\n", "\n", "\tobj->local_data = malloc(sizeof(struct sf_local_data));\n", "\n", "\tif (!obj->local_data)\n", "\t{\n", "\t\treturn 0;\n", "\t}\n", "\tobj->nr_frames = 0;\n", "\n", "\tdata = (struct sf_local_data *) obj->local_data;\n", "\n", "\tdata->sfhandle = sf_open(name, SFM_READ, &data->sfinfo);\n", "\tdata->framesize = FRAME_SIZE;\n", "\n", "\tif (data->sfhandle == NULL)\n", "\t{\n", "\t\tfree(obj->local_data);\n", "\t\tobj->local_data = NULL;\n", "\t\treturn 0;\n", "\t}\n", "\tp = strrchr(name, '/');\n", "\tif (p) {\n", "\t\tstrcpy(data->filename, ++p);\n", "\t} else {\n", "\t\tstrcpy(data->filename, name);\n", "\t}\n", "\n", "\tdata->width = 1;\n", "\tshort_mask = (data->sfinfo.format & 0xFF);\n", "\tswitch (short_mask) {\n", "\t\tcase SF_FORMAT_PCM_S8:\n", "\t\t     \tdata->width = 1;\n", "\t\t\tbreak;\n", "\t\tcase SF_FORMAT_PCM_16:\n", "\t\t\tdata->width = 2;\n", "\t\t\tbreak;\n", "\t\tcase SF_FORMAT_PCM_24:\n", "\t\t\tdata->width = 3;\n", "\t\t\tbreak;\n", "\t\tcase SF_FORMAT_PCM_32:\n", "\t\t\tdata->width = 4;\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\talsaplayer_error(\"short_mask = 0x%X\", short_mask);\n", "\t\t\tdata->width = 2;\n", "\t\t\tbreak;\n", "\t}\t\t\n", "\t//alsaplayer_error(\"short_mask = 0x%X\", short_mask);\t\n", "\t\n", "\tstrcpy(data->path, name);\n", "\tif (data->sfinfo.seekable)\n", "\t\tobj->flags = P_SEEK;\n", "\treturn 1;\n", "}\n"], "project": "alsaplayer-xosd", "file": "sndfile_engine.pkl", "function": "sndfile_open"}, {"comment_all": {"comment": "/* tries to open a mixer device, returns NULL on error or otherwise an mixer_t\n * struct */", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 42}, "comment_text": "/* tries to open a mixer device, returns NULL on error or otherwise an mixer_t\n * struct */", "comment_tokens": ["tries", "to", "open", "a", "mixer", "device", ",", "returns", "NULL", "on", "error", "or", "otherwise", "an", "mixer_t", "struct"], "ccode": ["/* GKrellM Volume plugin\n", " |  Copyright (C) 1999-2000 Sjoerd Simons\n", " |\n", " |  Author:  Sjoerd Simons  sjoerd@luon.net\n", " |\n", " |  This program is free software which I release under the GNU General Public\n", " |  License. You may redistribute and/or modify this program under the terms\n", " |  of that license as published by the Free Software Foundation; either\n", " |  version 2 of the License, or (at your option) any later version.\n", " |\n", " |  This program is distributed in the hope that it will be useful,\n", " |  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " |  GNU General Public License for more details.\n", " |\n", " |  To get a copy of the GNU General Puplic License,  write to the\n", " |  Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", " */\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <sys/ioctl.h>\n", "#include <sys/types.h>\n", "#include <sys/stat.h>\n", "#include <fcntl.h>\n", "#include <string.h>\n", "#include <glob.h>\n", "\n", "#include <sys/param.h>\n", "#if defined(__FreeBSD__) && __FreeBSD_version < 500000\n", "  #include <machine/soundcard.h>\n", "#else\n", "  #include <sys/soundcard.h>\n", "#endif\n", "\n", "#include \"mixer.h\"\n", "#include \"oss_mixer.h\"\n", "\n", "#define OSSMIXER(x) ((oss_mixer_t *)x->priv)\n", "static mixer_ops_t * get_mixer_ops(void);\n", "\n", "\n", "/* tries to open a mixer device, returns NULL on error or otherwise an mixer_t\n", " * struct */\n", "static mixer_t *\n", "oss_mixer_open(char *id) {\n", "  mixer_t *result;\n", "  oss_mixer_t *ossresult;\n", "  int fd,devices,nr,i;\n", "#ifdef SOUND_MIXER_INFO\n", "  mixer_info minfo;\n", "#endif\n", "  char *sound_labels[] = SOUND_DEVICE_LABELS;\n", "\n", "  if ((fd = open(id,O_RDWR)) == -1) return NULL;\n", "  if ( (ioctl(fd,SOUND_MIXER_READ_DEVMASK,&devices) < 0)) {\n", "    close(fd);\n", "    return NULL;\n", "  }\n", "\n", "#ifdef SOUND_MIXER_INFO\n", "  if ((ioctl(fd,SOUND_MIXER_INFO,&minfo) < 0)) {\n", "    close(fd);\n", "    return NULL;\n", "  }\n", "#endif\n", "\n", "  result = malloc(sizeof(mixer_t));\n", "#ifdef SOUND_MIXER_INFO\n", "  result->name = strdup(minfo.name);\n", "#else\n", "  result->name = strdup(id);\n", "#endif\n", "\n", "  /* get the nr of devices */\n", "  nr = 0;\n", "  for (i = 0 ; i < SOUND_MIXER_NRDEVICES; i++) { if (devices & (1<<i)) nr++; }\n", "\n", "  result->nrdevices = nr;\n", "\n", "  result->dev_realnames = malloc(nr * sizeof(char *));\n", "\n", "  result->dev_names = malloc(nr * sizeof(char*));\n", "  memset(result->dev_names,0,nr * sizeof(char *));\n", "\n", "  ossresult = malloc(sizeof(oss_mixer_t));\n", "  ossresult->fd = fd;\n", "  ossresult->table = malloc(nr * sizeof(int));\n", "\n", "  result->priv = ossresult;\n", "  result->ops = get_mixer_ops();\n", "\n", "  nr = 0;\n", "  for (i = 0 ; i < SOUND_MIXER_NRDEVICES; i++)\n", "    if (devices & (1<<i)) {\n", "      ossresult->table[nr] = i;\n", "      result->dev_realnames[nr] = strdup(sound_labels[i]);\n", "      nr++;\n", "    }\n", "  return result;\n", "}\n"], "project": "gkrellm-volume", "file": "oss_mixer.pkl", "function": "oss_mixer_open"}, {"comment_all": {"comment": "/* Pad OUT to the next aligned offset.  */", "depth": 1, "reading_ease": 106.67, "reading_grade": 0.1, "line": 136}, "comment_text": "/* Pad OUT to the next aligned offset.  */", "comment_tokens": ["Pad", "OUT", "to", "the", "next", "aligned", "offset", "."], "ccode": ["\n", "\n", "\n", "static void\n", "copy_file(FILE *in, FILE *out)\n", "{\n", "  int i;\n", "  size_t nread;\n", "  char buf[BUFSIZ];\n", "\n", "  /* Pad OUT to the next aligned offset.  */\n", "  for (i = ftell (out); i & (SECTION_ALIGNMENT - 1); i++) {\n", "    fputc (0, out);\n", "  }\n", "\n", "  /* Copy the contents.  */\n", "  rewind(in);\n", "  while ((nread = fread (buf, 1, sizeof buf, in)) > 0) {\n", "    if (fwrite (buf, 1, nread, out) < nread) {\n", "      fprintf (stderr, \"failed to write\\n\");\n", "      exit (1);\n", "    }\n", "  }\n", "\n", "  if (feof (in))\n", "    return;\n", "\n", "  fprintf (stderr, \"failed to read\\n\");\n", "  exit (1);\n", "}\n"], "project": "libanthy1", "file": "mkfiledic.pkl", "function": "copy_file"}, {"comment_all": {"comment": "/*\n\t\t\t * Here we should never be, but if, we just proceed.\n\t\t\t */", "depth": 3, "reading_ease": 95.17, "reading_grade": 2.5, "line": 28}, "comment_text": "/*\n\t\t\t * Here we should never be, but if, we just proceed.\n\t\t\t */", "comment_tokens": ["Here", "we", "should", "never", "be", ",", "but", "if", ",", "we", "just", "proceed", "."], "ccode": ["#include <stdio.h>\n", "#include \"dds2tar.h\"\n", "int dds_unquote(char*p){\n", "\tchar *q ;\n", "\n", "\t/* do nothing if there is no quote */\n", "\twhile ( *p && *p != '\\\\' ) p++ ;\n", "\tif ( *p == '\\0' ) return 1 ;\n", "\n", "\tq = p ;\n", "\twhile ( *p ){\n", "\t\tif ( *p == '\\\\' ) {\n", "\t\t\tchar c = p[1] ;\n", "\t\t\tswitch (c){\n", "\t\t\t\tcase '\\\\' : *q++ = '\\\\'   , p+=2 ; continue ;\n", "\t\t\t\tcase 't'  : *q++ = '\\t'   , p+=2 ; continue ;\n", "\t\t\t\tcase 'n'  : *q++ = '\\n'   , p+=2 ; continue ;\n", "\t\t\t\tcase 'f'  : *q++ = '\\f'   , p+=2 ; continue ;\n", "\t\t\t\tcase 'b'  : *q++ = '\\b'   , p+=2 ; continue ;\n", "\t\t\t\tcase 'r'  : *q++ = '\\r'   , p+=2 ; continue ;\n", "\t\t\t\tcase '?'  : *q++ = '\\177' , p+=2 ; continue ;\n", "\t\t\t}\n", "\t\t\tif ( '0' <= c && c <= '9' ){\n", "\t\t\t\tint x = 0 ;\n", "\t\t\t\tint n = 0 ;\n", "\t\t\t\tsscanf(p+1,\"%03o%n\",&x,&n);\n", "\t\t\t\t*q++ = x ; p+=n+1 ; continue ;\n", "\t\t\t}\n", "\t\t\t/*\n", "\t\t\t * Here we should never be, but if, we just proceed.\n", "\t\t\t */\n", "\t\t}\n", "\t\t*q++ = *p++ ;\n", "\t}\n", "\t*q++ = '\\0' ;\n", "\treturn 1 ;\n", "}\n"], "project": "dds2tar", "file": "dds_quote.pkl", "function": "dds_unquote"}, {"comment_all": {"comment": "/*(LGPL)\n---------------------------------------------------------------------------\n\te_register.c - EEL extension registry\n---------------------------------------------------------------------------\n * Copyright (C) 2002, David Olofson\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or (at\n * your option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "depth": 0, "reading_ease": 58.92, "reading_grade": 10.2, "line": 0}, "comment_text": "/*(LGPL)\n---------------------------------------------------------------------------\n\te_register.c - EEL extension registry\n---------------------------------------------------------------------------\n * Copyright (C) 2002, David Olofson\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or (at\n * your option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */", "comment_tokens": ["(", "LGPL", ")", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "e_register.c", "-", "EEL", "extension", "registry", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "Copyright", "(", "C", ")", "2002", ",", "David", "Olofson", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/*(LGPL)\n", "---------------------------------------------------------------------------\n", "\te_register.c - EEL extension registry\n", "---------------------------------------------------------------------------\n", " * Copyright (C) 2002, David Olofson\n", " *\n", " * This program is free software; you can redistribute it and/or modify it\n", " * under the terms of the GNU Lesser General Public License as published by\n", " * the Free Software Foundation; either version 2.1 of the License, or (at\n", " * your option) any later version.\n", " * \n", " * This program is distributed in the hope that it will be useful, but\n", " * WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " * \n", " * You should have received a copy of the GNU Lesser General Public License\n", " * along with this program; if not, write to the Free Software Foundation,\n", " * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", " */\n", "\n", "#include \"e_register.h\"\n", "#include \"e_symtab.h\"\n", "#include \"e_lexer.h\"\n", "\n", "eel_symbol_t *_register(const char *name, eel_symtypes_t stype,\n", "\t\teel_datatypes_t type)\n", "{\n", "\teel_symbol_t *s = eel_s_new(name, stype);\n", "\tif(!s)\n", "\t\treturn (eel_symbol_t *)0;\n", "\ts->data.type = type;\n", "\treturn s;\n", "}\n"], "project": "kobodeluxe", "file": "e_register.pkl", "function": "_register"}, {"comment_all": {"comment": "/* write default command line, descriptor table, zero sector */", "depth": 1, "reading_ease": 37.98, "reading_grade": 10.0, "line": 102}, "comment_text": "/* write default command line, descriptor table, zero sector */", "comment_tokens": ["write", "default", "command", "line", ",", "descriptor", "table", ",", "zero", "sector"], "ccode": ["\n", "#if !__MSDOS__\n", "\n", "static GEOMETRY map_geo;\n", "\n", "void map_create(char *name)\n", "{\n", "    char buffer[SECTOR_SIZE];\n", "    int fd, i;\n", "\n", "    if ((fd = creat(name,0600)) < 0) die(\"creat %s: %s\",name,strerror(errno));\n", "    (void) close(fd);\n", "    memset(buffer,0,SECTOR_SIZE);\n", "    *(unsigned short *) buffer = DC_MGOFF;\n", "    map_file = geo_open(&map_geo,name,O_RDWR);\n", "    bios_map = map_geo.device;\t/* set device code of map file */\n", "    if (do_md_install) {\n", "\tstruct stat st;\n", "\tif(fstat(map_file,&st)) die(\"map_create: cannot fstat map file\");\n", "\tif (verbose >= 2)\n", "\t    printf(\"map_create:  boot=%04X  map=%04X\\n\", \n", "\t\t\t\t\tboot_dev_nr, (int)st.st_dev);\n", "\tif (boot_dev_nr != st.st_dev  &&  extra != X_MBR_ONLY) {\n", "\t    die(\"map file must be on the boot RAID partition\");\n", "\t}\n", "    }\n", "\n", "/* write default command line, descriptor table, zero sector */\n", "\n", "    for (i=0; i<MAX_DESCR_SECS+2; i++) {\n", "\tif (write(map_file,buffer,SECTOR_SIZE) != SECTOR_SIZE)\n", "\t    die(\"write %s: %s\",name,strerror(errno));\n", "\t*(unsigned short *) buffer = 0;\n", "    }\n", "    if (!geo_comp_addr(&map_geo,SECTOR_SIZE*(MAX_DESCR_SECS+1),&zero_addr))\n", "\tdie(\"Hole found in map file (zero sector)\");\n", "}\n"], "project": "lilo", "file": "map.pkl", "function": "map_create"}, {"comment_all": {"comment": "/* If there are more plugins defined in the file, load them all! */", "depth": 1, "reading_ease": 93.14, "reading_grade": 3.3, "line": 169}, "comment_text": "/* If there are more plugins defined in the file, load them all! */", "comment_tokens": ["If", "there", "are", "more", "plugins", "defined", "in", "the", "file", ",", "load", "them", "all", "!"], "ccode": ["\n", "static void\n", "_ccze_plugin_load (const char *name, const char *path, int recurse)\n", "{\n", "  ccze_plugin_t *plugin;\n", "  char *tmp, *n;\n", "  void *dlhandle;\n", "  char **pluginlist = NULL;\n", "  int bailout = 0;\n", "  \n", "  if (_ccze_plugin_loaded (name))\n", "    return;\n", "  \n", "  dlhandle = dlopen (path, RTLD_LAZY);\n", "  if (dlerror () || !dlhandle)\n", "    return;\n", "\n", "  asprintf (&tmp, \"ccze_%s_info\", name);\n", "  plugin = (ccze_plugin_t *)dlsym (dlhandle, tmp);\n", "  free (tmp);\n", "  if (dlerror () || !plugin)\n", "    {\n", "      if (!plugin)\n", "\t{\n", "\t  n = (char *)dlsym (dlhandle, \"ccze_default_plugin\");\n", "\t  asprintf (&tmp, \"ccze_%s_info\", n);\n", "\t  plugin = (ccze_plugin_t *)dlsym (dlhandle, tmp);\n", "\t  free (tmp);\n", "\t  if (!plugin)\n", "\t    bailout = 1;\n", "\t  else\n", "\t    plugin->name = strdup (name);\n", "\t}\n", "      else\n", "\t{\n", "\t  dlclose (dlhandle);\n", "\t  return;\n", "\t}\n", "    }\n", "  if (!bailout)\n", "    {\n", "      if (plugin->abi_version != CCZE_ABI_VERSION)\n", "\t{\n", "\t  dlclose (dlhandle);\n", "\t  return;\n", "\t}\n", "  \n", "      plugin->dlhandle = dlhandle;\n", "\n", "      ccze_plugin_add (plugin);\n", "    }\n", "  \n", "  /* If there are more plugins defined in the file, load them all! */\n", "  if (recurse)\n", "    {\n", "      pluginlist = (char **)dlsym (dlhandle, \"ccze_plugin_list\");\n", "      if (pluginlist)\n", "\t{\n", "\t  int i = 0;\n", "\t  \n", "\t  while (pluginlist[i])\n", "\t    {\n", "\t      if (!_ccze_plugin_loaded (pluginlist[i]))\n", "\t\t_ccze_plugin_load (pluginlist[i], path, 0);\n", "\t      i++;\n", "\t    }\n", "\t}\n", "    }\n", "}\n"], "project": "ccze", "file": "ccze-plugin.pkl", "function": "_ccze_plugin_load"}, {"comment_all": {"comment": "/* FIXME Check the URL if you add support for databases that cannot be \n     * both input and output urls */", "depth": 2, "reading_ease": 78.59, "reading_grade": 6.8, "line": 845}, "comment_text": "/* FIXME Check the URL if you add support for databases that cannot be \n     * both input and output urls */", "comment_tokens": ["FIXME", "Check", "the", "URL", "if", "you", "add", "support", "for", "databases", "that", "can", "not", "be", "both", "input", "and", "output", "urls"], "ccode": ["\n", "void do_dbindef(char* val)\n", "{\n", "  url_t* u=NULL;\n", "\n", "  if(conf->db_in_url==NULL){\n", "    u=parse_url(val);\n", "    /* FIXME Check the URL if you add support for databases that cannot be \n", "     * both input and output urls */\n", "    if(u==NULL||u->type==url_unknown||u->type==url_stdout\n", "       ||u->type==url_stderr) {\n", "      error(0,_(\"Unsupported input URL-type:%s\\n\"),val);\n", "    }\n", "    else {\n", "      conf->db_in_url=u;\n", "    }\n", "  }\n", "\n", "  free(val);\n", "}\n"], "project": "aide", "file": "commandconf.pkl", "function": "do_dbindef"}, {"comment_all": {"comment": "/* Unlock a file descriptor. */", "depth": 0, "reading_ease": 50.5, "reading_grade": 7.2, "line": 24}, "comment_text": "/* Unlock a file descriptor. */", "comment_tokens": ["Unlock", "a", "file", "descriptor", "."], "ccode": ["\n", "/* Unlock a file descriptor. */\n", "\n", "int unlock_fd(int fd)\n", "{\n", "\tif (flock(fd, LOCK_UN)) {\n", "\t\tsyserr(\"Can't unlockfd\\n\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\treturn 0;\n", "}\n"], "project": "axmail", "file": "lock.pkl", "function": "unlock_fd"}, {"comment_all": {"comment": "/* 3-byte character, lead by 0b1110xxxx byte */", "depth": 3, "reading_ease": 90.77, "reading_grade": 2.1, "line": 377}, "comment_text": "/* 3-byte character, lead by 0b1110xxxx byte */", "comment_tokens": ["3-byte", "character", ",", "lead", "by", "0b1110xxxx", "byte"], "ccode": ["\n", "void\n", "_INTERNAL_trim_to_complete_utf8_characters(const char * from, const char ** fromLimRef)\n", "{\n", "  const char * fromLim = *fromLimRef;\n", "  size_t walked = 0;\n", "  for (; fromLim > from; fromLim--, walked++) {\n", "    const unsigned char prev = (unsigned char)fromLim[-1];\n", "    if ((prev & 0xf8u) == 0xf0u) { /* 4-byte character, lead by 0b11110xxx byte */\n", "      if (walked + 1 >= 4) {\n", "        fromLim += 4 - 1;\n", "        break;\n", "      } else {\n", "        walked = 0;\n", "      }\n", "    } else if ((prev & 0xf0u) == 0xe0u) { /* 3-byte character, lead by 0b1110xxxx byte */\n", "      if (walked + 1 >= 3) {\n", "        fromLim += 3 - 1;\n", "        break;\n", "      } else {\n", "        walked = 0;\n", "      }\n", "    } else if ((prev & 0xe0u) == 0xc0u) { /* 2-byte character, lead by 0b110xxxxx byte */\n", "      if (walked + 1 >= 2) {\n", "        fromLim += 2 - 1;\n", "        break;\n", "      } else {\n", "        walked = 0;\n", "      }\n", "    } else if ((prev & 0x80u) == 0x00u) { /* 1-byte character, matching 0b0xxxxxxx */\n", "      break;\n", "    }\n", "  }\n", "  *fromLimRef = fromLim;\n", "}\n"], "project": "libpoco-dev", "file": "xmltok.pkl", "function": "_INTERNAL_trim_to_complete_utf8_characters"}, {"comment_all": {"comment": "/*======handle ConfigureNotify event for docking window:=====================*/", "depth": 0, "reading_ease": 14.63, "reading_grade": 12.7, "line": 34}, "comment_text": "/*======handle ConfigureNotify event for docking window:=====================*/", "comment_tokens": ["======handle", "ConfigureNotify", "event", "for", "docking", "window", ":", "====================="], "ccode": ["/* Copyright (C) 2000 Damir Zucic */\n", "\n", "/*=============================================================================\n", "\n", "\t\t\t\tdocking_resize.c\n", "\n", "Purpose:\n", "\tHandle ConfigureNotify event for docking window.\n", "\n", "Input:\n", "\t(1) Pointer to RuntimeS structure.\n", "\t(2) Pointer to GUIS structure.\n", "\t(3) Pointer to XConfigureEvent structure.\n", "\n", "Output:\n", "\t(1) Two geometric parameters updated.\n", "\t(2) Return value.\n", "\n", "Return value:\n", "\t(1) Positive if geometric parameters are updated.\n", "\t(2) Zero if nothing should be done.\n", "\n", "========includes:============================================================*/\n", "\n", "#include <stdio.h>\n", "\n", "#include <X11/Xlib.h>\n", "#include <X11/Xutil.h>\n", "#include <X11/Xos.h>\n", "#include <X11/Xatom.h>\n", "\n", "#include \"defines.h\"\n", "#include \"typedefs.h\"\n", "\n", "/*======handle ConfigureNotify event for docking window:=====================*/\n", "\n", "int DockingResize_ (RuntimeS *runtimeSP, GUIS *guiSP,\n", "\t\t    XConfigureEvent *configure_eventSP)\n", "{\n", "\n", "/* If this event was not generated for docking window, do nothing: */\n", "if (configure_eventSP->window != guiSP->docking_winS.ID) return 0;\n", "\n", "/* New width and height of docking window: */\n", "guiSP->docking_winS.width = configure_eventSP->width;\n", "guiSP->docking_winS.height = configure_eventSP->height;\n", "\n", "/* Return positive value: */\n", "return 1;\n", "}\n"], "project": "garlic", "file": "docking_resize.pkl", "function": "DockingResize_"}, {"comment_all": {"comment": "/*--------------------------------------------------------------------*\n |                             NoteNumber                             |\n *--------------------------------------------------------------------*/", "depth": 0, "reading_ease": 36.62, "reading_grade": 8.4, "line": 1153}, "comment_text": "/*--------------------------------------------------------------------*\n |                             NoteNumber                             |\n *--------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "|", "NoteNumber", "|", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["\n", "\n", "\n", "/*--------------------------------------------------------------------*\n", " |                             NoteNumber                             |\n", " *--------------------------------------------------------------------*/\n", "int NoteNumber (int ledgerLine, Boolean isASharp)\n", "{\n", "   int n = 0;\n", "   \n", "   switch (ledgerLine)\n", "     {\n", "     case 1:  n = 1;  break;\n", "     case 2:  n = 3;  break;\n", "     case 3:  n = 5;  break;\n", "     case 4:  n = 6;  break;\n", "     case 5:  n = 8;  break;\n", "     case 6:  n = 10; break;\n", "     case 7:  n = 12; break;\n", "     case 8:  n = 13; break;\n", "     case 9:  n = 15; break;\n", "     case 10: n = 17; break;\n", "     case 11: n = 18; break;\n", "     case 12: n = 20; break;\n", "     }\n", "   \n", "   if (isASharp)\n", "     return (n+1);\n", "   else\n", "     return (n);\n", "}\n"], "project": "libmrm4", "file": "piano.pkl", "function": "NoteNumber"}, {"comment_all": {"comment": "/*     This file is part of ELPA. */", "depth": 0, "reading_ease": 99.23, "reading_grade": 0.9, "line": 0}, "comment_text": "/*     This file is part of ELPA. */", "comment_tokens": ["This", "file", "is", "part", "of", "ELPA", "."], "ccode": ["/*     This file is part of ELPA. */\n", "/*  */\n", "/*     The ELPA library was originally created by the ELPA consortium, */\n", "/*     consisting of the following organizations: */\n", "/*  */\n", "/*     - Max Planck Computing and Data Facility (MPCDF), formerly known as */\n", "/*       Rechenzentrum Garching der Max-Planck-Gesellschaft (RZG), */\n", "/*     - Bergische Universit\u00e4t Wuppertal, Lehrstuhl f\u00fcr angewandte */\n", "/*       Informatik, */\n", "/*     - Technische Universit\u00e4t M\u00fcnchen, Lehrstuhl f\u00fcr Informatik mit */\n", "/*       Schwerpunkt Wissenschaftliches Rechnen , */\n", "/*     - Fritz-Haber-Institut, Berlin, Abt. Theorie, */\n", "/*     - Max-Plack-Institut f\u00fcr Mathematik in den Naturwissenschaften, */\n", "/*       Leipzig, Abt. Komplexe Strukutren in Biologie und Kognition, */\n", "/*       and */\n", "/*     - IBM Deutschland GmbH */\n", "/*  */\n", "/*  */\n", "/*     More information can be found here: */\n", "/*     http://elpa.mpcdf.mpg.de/ */\n", "/*  */\n", "/*     ELPA is free software: you can redistribute it and/or modify */\n", "/*     it under the terms of the version 3 of the license of the */\n", "/*     GNU Lesser General Public License as published by the Free */\n", "/*     Software Foundation. */\n", "/*  */\n", "/*     ELPA is distributed in the hope that it will be useful, */\n", "/*     but WITHOUT ANY WARRANTY; without even the implied warranty of */\n", "/*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */\n", "/*     GNU Lesser General Public License for more details. */\n", "/*  */\n", "/*     You should have received a copy of the GNU Lesser General Public License */\n", "/*     along with ELPA.  If not, see <http://www.gnu.org/licenses/> */\n", "/*  */\n", "/*     ELPA reflects a substantial effort on the part of the original */\n", "/*     ELPA consortium, and we ask you to respect the spirit of the */\n", "/*     license that we chose: i.e., please contribute any changes you */\n", "/*     may have back to the original ELPA library distribution, and keep */\n", "/*     any derivatives of ELPA under the same license that we chose for */\n", "/*     the original distribution, the GNU Lesser General Public License. */\n", "/*  */\n", "/*  */\n", "#include <string.h>\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <elpa/elpa.h>\n", "#include <complex.h>\n", "\n", "int call_elpa1_real_solver_from_c(int na, int nev, double *a, int lda, double *ev, double *q, int ldq, int nblk, int ncols, int mpi_comm_rows, int mpi_comm_cols) {\n", "  return elpa_solve_evp_real_1stage(na, nev, a, lda, ev, q, ldq, nblk, ncols, mpi_comm_rows, mpi_comm_cols);\n", "}\n"], "project": "libelpa4", "file": "call_elpa1.pkl", "function": "call_elpa1_real_solver_from_c"}, {"comment_all": {"comment": "/* may be a PAD only interface */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 615}, "comment_text": "/* may be a PAD only interface */", "comment_tokens": ["may", "be", "a", "PAD", "only", "interface"], "ccode": ["\n", "int usbWcmGetRanges(InputInfoPtr pInfo)\n", "{\n", "\tstruct input_absinfo absinfo;\n", "\tunsigned long ev[NBITS(EV_MAX)] = {0};\n", "\tunsigned long abs[NBITS(ABS_MAX)] = {0};\n", "\tunsigned long sw[NBITS(SW_MAX)] = {0};\n", "\tWacomDevicePtr priv = (WacomDevicePtr)pInfo->private;\n", "\tWacomCommonPtr common =\tpriv->common;\n", "\twcmUSBData* private = common->private;\n", "\tint is_touch = IsTouch(priv);\n", "\n", "\t/* Devices such as Bamboo P&T may have Pad data reported in the same\n", "\t * packet as Touch.  It's normal for Pad to be called first but logic\n", "\t * requires it to act the same as Touch.\n", "\t */\n", "\tif (ISBITSET(common->wcmKeys, BTN_TOOL_DOUBLETAP)\n", "\t     && ISBITSET(common->wcmKeys, BTN_FORWARD))\n", "\t\tis_touch = 1;\n", "\n", "\tif (ioctl(pInfo->fd, EVIOCGBIT(0 /*EV*/, sizeof(ev)), ev) < 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: unable to ioctl event bits.\\n\", pInfo->name);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\tif (!ISBITSET(ev,EV_ABS))\n", "\t{\n", "\t\t/* may be an expresskey only interface */\n", "\t\tif (ISBITSET(common->wcmKeys, BTN_FORWARD) ||\n", "\t\t    ISBITSET(common->wcmKeys, BTN_0))\n", "\t\t\tgoto pad_init;\n", "\n", "\t\txf86Msg(X_ERROR, \"%s: no abs bits.\\n\", pInfo->name);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\t/* absolute values */\n", "        if (ioctl(pInfo->fd, EVIOCGBIT(EV_ABS, sizeof(abs)), abs) < 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: unable to ioctl max values.\\n\", pInfo->name);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\t/* max x */\n", "\tif (ioctl(pInfo->fd, EVIOCGABS(ABS_X), &absinfo) < 0)\n", "\t{\n", "\t\t/* may be a PAD only interface */\n", "\t\tif (ISBITSET(common->wcmKeys, BTN_FORWARD) ||\n", "\t\t    ISBITSET(common->wcmKeys, BTN_0))\n", "\t\t\tgoto pad_init;\n", "\n", "\t\txf86Msg(X_ERROR, \"%s: unable to ioctl xmax value.\\n\", pInfo->name);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\tif (absinfo.maximum <= 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: xmax value is %d, expected > 0.\\n\",\n", "\t\t\tpInfo->name, absinfo.maximum);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\tif (!is_touch)\n", "\t{\n", "\t\tcommon->wcmMinX = absinfo.minimum;\n", "\t\tcommon->wcmMaxX = absinfo.maximum;\n", "\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t\tcommon->wcmResolX = absinfo.resolution * 1000;\n", "#endif\n", "\t}\n", "\telse\n", "\t{\n", "\t\tcommon->wcmMaxTouchX = absinfo.maximum;\n", "\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t\tcommon->wcmTouchResolX = absinfo.resolution * 1000;\n", "#endif\n", "\t}\n", "\n", "\t/* max y */\n", "\tif (ioctl(pInfo->fd, EVIOCGABS(ABS_Y), &absinfo) < 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: unable to ioctl ymax value.\\n\", pInfo->name);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\tif (absinfo.maximum <= 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: ymax value is %d, expected > 0.\\n\",\n", "\t\t\tpInfo->name, absinfo.maximum);\n", "\t\treturn !Success;\n", "\t}\n", "\n", "\tif (!is_touch)\n", "\t{\n", "\t\tcommon->wcmMinY = absinfo.minimum;\n", "\t\tcommon->wcmMaxY = absinfo.maximum;\n", "\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t\tcommon->wcmResolY = absinfo.resolution * 1000;\n", "#endif\n", "\t}\n", "\telse\n", "\t{\n", "\t\tcommon->wcmMaxTouchY = absinfo.maximum;\n", "\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t\tcommon->wcmTouchResolY = absinfo.resolution * 1000;\n", "#endif\n", "\t}\n", "\n", "\t/* max finger strip X for tablets with Expresskeys\n", "\t * or physical X for touch devices in hundredths of a mm */\n", "\tif (ISBITSET(abs, ABS_RX) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_RX), &absinfo))\n", "\t{\n", "\t\tif (is_touch)\n", "\t\t\tcommon->wcmTouchResolX =\n", "\t\t\t\t(int)(((double)common->wcmMaxTouchX * 100000.0\n", "\t\t\t\t / (double)absinfo.maximum) + 0.5);\n", "\t\telse\n", "\t\t\tcommon->wcmMaxStripX = absinfo.maximum;\n", "\t}\n", "\n", "\t/* max touchring value for standalone pad tools */\n", "\tcommon->wcmMinRing = 0;\n", "\tcommon->wcmMaxRing = 71;\n", "\tif (!ISBITSET(ev,EV_MSC) && ISBITSET(abs, ABS_WHEEL) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_WHEEL), &absinfo))\n", "\t{\n", "\t\tcommon->wcmMinRing = absinfo.minimum;\n", "\t\tcommon->wcmMaxRing = absinfo.maximum;\n", "\t}\n", "\n", "\t/* X tilt range */\n", "\tif (ISBITSET(abs, ABS_TILT_X) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_TILT_X), &absinfo))\n", "\t{\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\t/* If resolution is specified */\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t{\n", "\t\t\t/* Assume the range is centered on zero */\n", "\t\t\tcommon->wcmTiltOffX = 0;\n", "\t\t\t/* Convert to resolution expected by applications */\n", "\t\t\tcommon->wcmTiltFactX = TILT_RES /\n", "\t\t\t\t\t       (double)absinfo.resolution;\n", "\t\t}\n", "\t\telse\n", "#endif\n", "\t\t{\n", "\t\t\t/*\n", "\t\t\t * Center the reported range on zero to support\n", "\t\t\t * kernel drivers still reporting non-zero-centered\n", "\t\t\t * values.\n", "\t\t\t */\n", "\t\t\tcommon->wcmTiltOffX = - (absinfo.minimum +\n", "\t\t\t\t\t\t absinfo.maximum) / 2;\n", "\t\t\t/*\n", "\t\t\t * Assume reported resolution is the one expected by\n", "\t\t\t * applications\n", "\t\t\t */\n", "\t\t\tcommon->wcmTiltFactX = 1.0;\n", "\t\t}\n", "\t\tcommon->wcmTiltMinX = round((absinfo.minimum +\n", "\t\t\t\t\t     common->wcmTiltOffX) *\n", "\t\t\t\t\t    common->wcmTiltFactX);\n", "\t\tcommon->wcmTiltMaxX = round((absinfo.maximum +\n", "\t\t\t\t\t     common->wcmTiltOffX) *\n", "\t\t\t\t\t    common->wcmTiltFactX);\n", "\t}\n", "\n", "\t/* Y tilt range */\n", "\tif (ISBITSET(abs, ABS_TILT_Y) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_TILT_Y), &absinfo))\n", "\t{\n", "#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)\n", "\t\t/* If resolution is specified */\n", "\t\tif (absinfo.resolution > 0)\n", "\t\t{\n", "\t\t\t/* Assume the range is centered on zero */\n", "\t\t\tcommon->wcmTiltOffY = 0;\n", "\t\t\t/* Convert to resolution expected by applications */\n", "\t\t\tcommon->wcmTiltFactY = TILT_RES /\n", "\t\t\t\t\t       (double)absinfo.resolution;\n", "\t\t}\n", "\t\telse\n", "#endif\n", "\t\t{\n", "\t\t\t/*\n", "\t\t\t * Center the reported range on zero to support\n", "\t\t\t * kernel drivers still reporting non-zero-centered\n", "\t\t\t * values.\n", "\t\t\t */\n", "\t\t\tcommon->wcmTiltOffY = - (absinfo.minimum +\n", "\t\t\t\t\t\t absinfo.maximum) / 2;\n", "\t\t\t/*\n", "\t\t\t * Assume reported resolution is the one expected by\n", "\t\t\t * applications\n", "\t\t\t */\n", "\t\t\tcommon->wcmTiltFactY = 1.0;\n", "\t\t}\n", "\t\tcommon->wcmTiltMinY = round((absinfo.minimum +\n", "\t\t\t\t\t     common->wcmTiltOffY) *\n", "\t\t\t\t\t    common->wcmTiltFactY);\n", "\t\tcommon->wcmTiltMaxY = round((absinfo.maximum +\n", "\t\t\t\t\t     common->wcmTiltOffY) *\n", "\t\t\t\t\t    common->wcmTiltFactY);\n", "\t}\n", "\n", "\t/* max finger strip Y for tablets with Expresskeys\n", "\t * or physical Y for touch devices in hundredths of a mm */\n", "\tif (ISBITSET(abs, ABS_RY) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_RY), &absinfo))\n", "\t{\n", "\t\tif (is_touch)\n", "\t\t\tcommon->wcmTouchResolY =\n", "\t\t\t\t (int)(((double)common->wcmMaxTouchY * 100000.0\n", "\t\t\t\t / (double)absinfo.maximum) + 0.5);\n", "\t\telse\n", "\t\t\tcommon->wcmMaxStripY = absinfo.maximum;\n", "\t}\n", "\n", "\t/* max z cannot be configured */\n", "\tif (ISBITSET(abs, ABS_PRESSURE) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_PRESSURE), &absinfo))\n", "\t\tcommon->wcmMaxZ = absinfo.maximum;\n", "\n", "\t/* max distance */\n", "\tif (ISBITSET(abs, ABS_DISTANCE) &&\n", "\t\t\t!ioctl(pInfo->fd, EVIOCGABS(ABS_DISTANCE), &absinfo))\n", "\t\tcommon->wcmMaxDist = absinfo.maximum;\n", "\n", "\tif (ISBITSET(abs, ABS_MT_SLOT))\n", "\t{\n", "\t\tprivate->wcmUseMT = 1;\n", "\n", "\t\tif (!ioctl(pInfo->fd, EVIOCGABS(ABS_MT_SLOT), &absinfo))\n", "\t\t\tcommon->wcmMaxContacts = absinfo.maximum + 1;\n", "\n", "\t\t/* pen and MT on the same logical port */\n", "\t\tif (ISBITSET(common->wcmKeys, BTN_TOOL_PEN))\n", "\t\t\tprivate->wcmPenTouch = TRUE;\n", "\t}\n", "\n", "\t/* Non-wacom devices, and Wacom devices without an ABS_MISC should be treated as generic */\n", "\tif (common->vendor_id != WACOM_VENDOR_ID || !ISBITSET(abs, ABS_MISC))\n", "\t\tcommon->wcmProtocolLevel = WCM_PROTOCOL_GENERIC;\n", "\n", "\tif (ioctl(pInfo->fd, EVIOCGBIT(EV_SW, sizeof(sw)), sw) < 0)\n", "\t{\n", "\t\txf86Msg(X_ERROR, \"%s: unable to ioctl sw bits.\\n\", pInfo->name);\n", "\t\treturn 0;\n", "\t}\n", "\telse if (ISBITSET(sw, SW_MUTE_DEVICE))\n", "\t{\n", "\t\tcommon->wcmHasHWTouchSwitch = TRUE;\n", "\n", "\t\tmemset(sw, 0, sizeof(sw));\n", "\n", "\t\tif (ioctl(pInfo->fd, EVIOCGSW(sizeof(sw)), sw) < 0)\n", "\t\t\txf86Msg(X_ERROR, \"%s: unable to ioctl sw state.\\n\", pInfo->name);\n", "\n", "\t\tif (ISBITSET(sw, SW_MUTE_DEVICE))\n", "\t\t\tcommon->wcmHWTouchSwitchState = 0;\n", "\t\telse\n", "\t\t\tcommon->wcmHWTouchSwitchState = 1;\n", "\t}\n", "\n", "pad_init:\n", "\tusbWcmInitPadState(pInfo);\n", "\n", "\treturn Success;\n", "}\n"], "project": "xserver-xorg-input-wacom", "file": "wcmUSB.pkl", "function": "usbWcmGetRanges"}, {"comment_all": {"comment": "/* 1.2.3 Computing the number of possible reference block within the\n         * lane.\n         */", "depth": 2, "reading_ease": 51.85, "reading_grade": 8.8, "line": 260}, "comment_text": "/* 1.2.3 Computing the number of possible reference block within the\n         * lane.\n         */", "comment_tokens": ["1.2.3", "Computing", "the", "number", "of", "possible", "reference", "block", "within", "the", "lane", "."], "ccode": ["\n", "void fill_segment(const argon2_instance_t *instance,\n", "                  argon2_position_t position) {\n", "    block *ref_block = NULL, *curr_block = NULL;\n", "    block address_block, input_block;\n", "    uint64_t pseudo_rand, ref_index, ref_lane;\n", "    uint32_t prev_offset, curr_offset;\n", "    uint32_t starting_index, i;\n", "#if defined(__AVX512F__)\n", "    __m512i state[ARGON2_512BIT_WORDS_IN_BLOCK];\n", "#elif defined(__AVX2__)\n", "    __m256i state[ARGON2_HWORDS_IN_BLOCK];\n", "#else\n", "    __m128i state[ARGON2_OWORDS_IN_BLOCK];\n", "#endif\n", "    int data_independent_addressing;\n", "\n", "    if (instance == NULL) {\n", "        return;\n", "    }\n", "\n", "    data_independent_addressing =\n", "        (instance->type == Argon2_i) ||\n", "        (instance->type == Argon2_id && (position.pass == 0) &&\n", "         (position.slice < ARGON2_SYNC_POINTS / 2));\n", "\n", "    if (data_independent_addressing) {\n", "        init_block_value(&input_block, 0);\n", "\n", "        input_block.v[0] = position.pass;\n", "        input_block.v[1] = position.lane;\n", "        input_block.v[2] = position.slice;\n", "        input_block.v[3] = instance->memory_blocks;\n", "        input_block.v[4] = instance->passes;\n", "        input_block.v[5] = instance->type;\n", "    }\n", "\n", "    starting_index = 0;\n", "\n", "    if ((0 == position.pass) && (0 == position.slice)) {\n", "        starting_index = 2; /* we have already generated the first two blocks */\n", "\n", "        /* Don't forget to generate the first block of addresses: */\n", "        if (data_independent_addressing) {\n", "            next_addresses(&address_block, &input_block);\n", "        }\n", "    }\n", "\n", "    /* Offset of the current block */\n", "    curr_offset = position.lane * instance->lane_length +\n", "                  position.slice * instance->segment_length + starting_index;\n", "\n", "    if (0 == curr_offset % instance->lane_length) {\n", "        /* Last block in this lane */\n", "        prev_offset = curr_offset + instance->lane_length - 1;\n", "    } else {\n", "        /* Previous block */\n", "        prev_offset = curr_offset - 1;\n", "    }\n", "\n", "    memcpy(state, ((instance->memory + prev_offset)->v), ARGON2_BLOCK_SIZE);\n", "\n", "    for (i = starting_index; i < instance->segment_length;\n", "         ++i, ++curr_offset, ++prev_offset) {\n", "        /*1.1 Rotating prev_offset if needed */\n", "        if (curr_offset % instance->lane_length == 1) {\n", "            prev_offset = curr_offset - 1;\n", "        }\n", "\n", "        /* 1.2 Computing the index of the reference block */\n", "        /* 1.2.1 Taking pseudo-random value from the previous block */\n", "        if (data_independent_addressing) {\n", "            if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {\n", "                next_addresses(&address_block, &input_block);\n", "            }\n", "            pseudo_rand = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];\n", "        } else {\n", "            pseudo_rand = instance->memory[prev_offset].v[0];\n", "        }\n", "\n", "        /* 1.2.2 Computing the lane of the reference block */\n", "        ref_lane = ((pseudo_rand >> 32)) % instance->lanes;\n", "\n", "        if ((position.pass == 0) && (position.slice == 0)) {\n", "            /* Can not reference other lanes yet */\n", "            ref_lane = position.lane;\n", "        }\n", "\n", "        /* 1.2.3 Computing the number of possible reference block within the\n", "         * lane.\n", "         */\n", "        position.index = i;\n", "        ref_index = index_alpha(instance, &position, pseudo_rand & 0xFFFFFFFF,\n", "                                ref_lane == position.lane);\n", "\n", "        /* 2 Creating a new block */\n", "        ref_block =\n", "            instance->memory + instance->lane_length * ref_lane + ref_index;\n", "        curr_block = instance->memory + curr_offset;\n", "        if (ARGON2_VERSION_10 == instance->version) {\n", "            /* version 1.2.1 and earlier: overwrite, not XOR */\n", "            fill_block(state, ref_block, curr_block, 0);\n", "        } else {\n", "            if(0 == position.pass) {\n", "                fill_block(state, ref_block, curr_block, 0);\n", "            } else {\n", "                fill_block(state, ref_block, curr_block, 1);\n", "            }\n", "        }\n", "    }\n", "}\n"], "project": "libargon2-0", "file": "opt.pkl", "function": "fill_segment"}, {"comment_all": {"comment": "/*quadlet_t resp0 = AVC1394_MASK_RESPONSE_OPERAND(response, 0);\n\tquadlet_t resp1 = AVC1394_MASK_RESPONSE_OPERAND(response, 1);*/", "depth": 1, "reading_ease": -12.79, "reading_grade": 17.0, "line": 225}, "comment_text": "/*quadlet_t resp0 = AVC1394_MASK_RESPONSE_OPERAND(response, 0);\n\tquadlet_t resp1 = AVC1394_MASK_RESPONSE_OPERAND(response, 1);*/", "comment_tokens": ["quadlet_t", "resp0", "=", "AVC1394_MASK_RESPONSE_OPERAND", "(", "response", ",", "0", ")", ";", "quadlet_t", "resp1", "=", "AVC1394_MASK_RESPONSE_OPERAND", "(", "response", ",", "1", ")", ";"], "ccode": ["\n", "char *avc1394_vcr_decode_status(quadlet_t response)\n", "{\n", "\t/*quadlet_t resp0 = AVC1394_MASK_RESPONSE_OPERAND(response, 0);\n", "\tquadlet_t resp1 = AVC1394_MASK_RESPONSE_OPERAND(response, 1);*/\n", "\tquadlet_t resp2 = AVC1394_MASK_RESPONSE_OPERAND(response, 2);\n", "\tquadlet_t resp3 = AVC1394_MASK_RESPONSE_OPERAND(response, 3);\n", "\t\n", "\tif (response == 0) {\n", "\t\treturn \"OK\";\n", "\t} else if (resp2 == AVC1394_VCR_RESPONSE_TRANSPORT_STATE_LOAD_MEDIUM) {\n", "\t\treturn(\"Loading Medium\");\n", "\t} else if (resp2 == AVC1394_VCR_RESPONSE_TRANSPORT_STATE_RECORD) {\n", "\t\tif (resp3 == AVC1394_VCR_OPERAND_RECORD_PAUSE)\n", "\t\t\treturn(\"Recording Paused\");\n", "\t\telse\n", "\t\t\treturn(\"Recording\");\n", "\t} else if (resp2 == AVC1394_VCR_RESPONSE_TRANSPORT_STATE_PLAY) {\n", "\t\tif (resp3 >= AVC1394_VCR_OPERAND_PLAY_FAST_FORWARD_1\n", "\t\t\t\t&& resp3 <= AVC1394_VCR_OPERAND_PLAY_FASTEST_FORWARD) {\n", "\t\t\treturn(\"Playing Fast Forward\");\n", "\t\t} else if (resp3 >= AVC1394_VCR_OPERAND_PLAY_FAST_REVERSE_1\n", "\t\t\t\t\t&& resp3 <= AVC1394_VCR_OPERAND_PLAY_FASTEST_REVERSE) {\n", "\t\t\treturn(\"Playing Reverse\");\n", "\t\t} else if (resp3 == AVC1394_VCR_OPERAND_PLAY_FORWARD_PAUSE) {\n", "\t\t\treturn(\"Playing Paused\");\n", "\t\t} else {\n", "\t\t\treturn(\"Playing\");\n", "\t\t}\n", "\t} else if (resp2 == AVC1394_VCR_RESPONSE_TRANSPORT_STATE_WIND) {\n", "\t\tif (resp3 == AVC1394_VCR_OPERAND_WIND_HIGH_SPEED_REWIND) {\n", "\t\t\treturn(\"Winding backward at incredible speed\");\n", "\t\t} else if (resp3 == AVC1394_VCR_OPERAND_WIND_STOP) {\n", "\t\t\treturn(\"Winding stopped\");\n", "\t\t} else if (resp3 == AVC1394_VCR_OPERAND_WIND_REWIND) {\n", "\t\t\treturn(\"Winding reverse\");\n", "\t\t} else if (resp3 == AVC1394_VCR_OPERAND_WIND_FAST_FORWARD) {\n", "\t\t\treturn(\"Winding forward\");\n", "\t\t} else {\n", "\t\t\treturn(\"Winding\");\n", "\t\t}\n", "\t} else {\n", "\t\treturn(\"Unknown\");\n", "\t}\n", "}\n"], "project": "libavc1394-dev", "file": "avc1394_vcr.pkl", "function": "avc1394_vcr_decode_status"}, {"comment_all": {"comment": "/*  int bJustifyMargin (bstring b, int width, int space)\n *\n *  Stretch a string to flush against left and right margins by evenly\n *  distributing additional white space between words.  If the line is too\n *  long to be margin justified, it is left justified.\n */", "depth": 0, "reading_ease": 68.1, "reading_grade": 8.7, "line": 162}, "comment_text": "/*  int bJustifyMargin (bstring b, int width, int space)\n *\n *  Stretch a string to flush against left and right margins by evenly\n *  distributing additional white space between words.  If the line is too\n *  long to be margin justified, it is left justified.\n */", "comment_tokens": ["int", "bJustifyMargin", "(", "bstring", "b", ",", "int", "width", ",", "int", "space", ")", "Stretch", "a", "string", "to", "flush", "against", "left", "and", "right", "margins", "by", "evenly", "distributing", "additional", "white", "space", "between", "words", ".", "If", "the", "line", "is", "too", "long", "to", "be", "margin", "justified", ",", "it", "is", "left", "justified", "."], "ccode": ["\n", "/*  int bJustifyMargin (bstring b, int width, int space)\n", " *\n", " *  Stretch a string to flush against left and right margins by evenly\n", " *  distributing additional white space between words.  If the line is too\n", " *  long to be margin justified, it is left justified.\n", " */\n", "int bJustifyMargin (bstring b, int width, int space) {\n", "struct bstrList * sl;\n", "int i, l, c;\n", "\n", "\tif (NULL == (sl = bsplit (b, (unsigned char) space))) return -__LINE__;\n", "\tfor (l=c=i=0; i < sl->qty; i++) {\n", "\t\tif (sl->entry[i]->slen > 0) {\n", "\t\t\tc ++;\n", "\t\t\tl += sl->entry[i]->slen;\n", "\t\t}\n", "\t}\n", "\n", "\tif (l + c >= width || c < 2) {\n", "\t\tbstrListDestroy (sl);\n", "\t\treturn bJustifyLeft (b, space);\n", "\t}\n", "\n", "\tb->slen = 0;\n", "\tfor (i=0; i < sl->qty; i++) {\n", "\t\tif (sl->entry[i]->slen > 0) {\n", "\t\t\tif (b->slen > 0) {\n", "\t\t\t\tint s = (width - l + (c / 2)) / c;\n", "\t\t\t\tbInsertChrs (b, b->slen, s, (unsigned char) space, (unsigned char) space);\n", "\t\t\t\tl += s;\n", "\t\t\t}\n", "\t\t\tbconcat (b, sl->entry[i]);\n", "\t\t\tc--;\n", "\t\t\tif (c <= 0) break;\n", "\t\t}\n", "\t}\n", "\n", "\tbstrListDestroy (sl);\n", "\treturn BSTR_OK;\n", "}\n"], "project": "pads", "file": "bstraux.pkl", "function": "bJustifyMargin"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  Print out the contents of a node from the routing database (as plain text).\n\n  Nodes *nodes The set of nodes to use.\n\n  index_t item The node index to print.\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 95.47, "reading_grade": 2.4, "line": 492}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  Print out the contents of a node from the routing database (as plain text).\n\n  Nodes *nodes The set of nodes to use.\n\n  index_t item The node index to print.\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "Print", "out", "the", "contents", "of", "a", "node", "from", "the", "routing", "database", "(", "as", "plain", "text", ")", ".", "Nodes", "nodes", "The", "set", "of", "nodes", "to", "use", ".", "index_t", "item", "The", "node", "index", "to", "print", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Print out the contents of a node from the routing database (as plain text).\n", "\n", "  Nodes *nodes The set of nodes to use.\n", "\n", "  index_t item The node index to print.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "static void print_node(Nodes *nodes,index_t item)\n", "{\n", " Node *nodep=LookupNode(nodes,item,1);\n", " double latitude,longitude;\n", "\n", " GetLatLong(nodes,item,nodep,&latitude,&longitude);\n", "\n", " printf(\"Node %\"Pindex_t\"\\n\",item);\n", " printf(\"  firstseg=%\"Pindex_t\"\\n\",nodep->firstseg);\n", " printf(\"  latoffset=%d lonoffset=%d (latitude=%.6f longitude=%.6f)\\n\",nodep->latoffset,nodep->lonoffset,radians_to_degrees(latitude),radians_to_degrees(longitude));\n", " printf(\"  allow=%02x (%s)\\n\",nodep->allow,TransportsNameList(nodep->allow));\n", " if(IsSuperNode(nodep))\n", "    printf(\"  Super-Node\\n\");\n", " if(nodep->flags & NODE_MINIRNDBT)\n", "    printf(\"  Mini-roundabout\\n\");\n", "}\n"], "project": "libroutino0", "file": "filedumper.pkl", "function": "print_node"}, {"comment_all": {"comment": "/*\n * Write data to a TLS/SSL connection.\n */", "depth": 0, "reading_ease": 73.85, "reading_grade": 4.5, "line": 475}, "comment_text": "/*\n * Write data to a TLS/SSL connection.\n */", "comment_tokens": ["Write", "data", "to", "a", "TLSSSL", "connection", "."], "ccode": ["\n", "\n", "/*\n", " * Write data to a TLS/SSL connection.\n", " */\n", "ssize_t\n", "socket_secure_write(session *ssn, const char *buf, size_t len)\n", "{\n", "\tint r, e;\n", "\n", "\tfor (;;) {\n", "\t\tif ((r = (ssize_t) SSL_write(ssn->sslconn, buf, len)) > 0)\n", "\t\t\tbreak;\n", "\n", "\t\tswitch (SSL_get_error(ssn->sslconn, r)) {\n", "\t\tcase SSL_ERROR_ZERO_RETURN:\n", "\t\t\terror(\"writing data through SSL; the connection has \"\n", "\t\t\t    \"been closed cleanly\\n\");\n", "\t\t\tgoto fail;\n", "\t\tcase SSL_ERROR_NONE:\n", "\t\tcase SSL_ERROR_WANT_READ:\n", "\t\tcase SSL_ERROR_WANT_WRITE:\n", "\t\tcase SSL_ERROR_WANT_CONNECT:\n", "\t\tcase SSL_ERROR_WANT_ACCEPT:\n", "\t\tcase SSL_ERROR_WANT_X509_LOOKUP:\n", "\t\t\tbreak;\n", "\t\tcase SSL_ERROR_SYSCALL:\n", "\t\t\te = ERR_get_error();\n", "\t\t\tif (e == 0 && r == 0)\n", "\t\t\t\terror(\"writing data through SSL; EOF in \"\n", "\t\t\t\t    \"violation of the protocol\\n\");\n", "\t\t\telse if (e == 0 && r == -1)\n", "\t\t\t\terror(\"writing data through SSL; %s\\n\",\n", "\t\t\t\t    strerror(errno));\n", "\t\t\telse\n", "\t\t\t\terror(\"writing data through SSL; %s\\n\",\n", "\t\t\t\t    ERR_error_string(e, NULL));\n", "\t\t\tgoto fail;\n", "\t\tcase SSL_ERROR_SSL:\n", "\t\t\terror(\"writing data through SSL; %s\\n\",\n", "\t\t\t    ERR_error_string(ERR_get_error(), NULL));\n", "\t\t\tgoto fail;\n", "\t\tdefault:\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\treturn r;\n", "fail:\n", "\tSSL_set_shutdown(ssn->sslconn, SSL_SENT_SHUTDOWN |\n", "\t    SSL_RECEIVED_SHUTDOWN);\n", "\n", "\treturn -1;\n", "}\n"], "project": "imapfilter", "file": "socket.pkl", "function": "socket_secure_write"}, {"comment_all": {"comment": "//gtk_widget_set_uposition(widget, g->x, g->y);\n", "depth": 1, "reading_ease": -134.62, "reading_grade": 32.8, "line": 1535}, "comment_text": "// This hides the window\n//gtk_widget_set_uposition(widget, g->x, g->y);\n// Do not destroy it\n", "comment_tokens": ["This", "hides", "the", "window", "gtk_widget_set_uposition", "(", "widget", ",", "g-", ">", "x", ",", "g-", ">", "y", ")", ";", "Do", "not", "destroy", "it"], "ccode": ["\n", "\n", "\n", "gint CloseWindow(GtkWidget *widget, GdkEvent *event, gpointer geom) {\n", "  struct geometry *g=geom;\n", "\n", "  gdk_window_get_root_origin(widget->window, &g->x, &g->y);\n", "  gdk_window_get_size(widget->window, &g->w, &g->h);\n", "  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g->toggler), FALSE);\t// This hides the window\n", "  //gtk_widget_set_uposition(widget, g->x, g->y);\n", "  return(TRUE);\t\t// Do not destroy it\n", "}\n"], "project": "liblo10k1-dev", "file": "echomixer.pkl", "function": "CloseWindow"}, {"comment_all": {"comment": "/* ---------------------------------------------------------\n * CAM_LIST \u306e\u30c7\u30fc\u30bf log\n *\t\n */", "depth": 0, "reading_ease": 93.81, "reading_grade": 0.9, "line": 327}, "comment_text": "/* ---------------------------------------------------------\n * CAM_LIST \u306e\u30c7\u30fc\u30bf log\n *\t\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "CAM_LIST", "\u306e\u30c7\u30fc\u30bf", "log"], "ccode": ["\n", "\n", "\n", "\n", "\n", "/* ---------------------------------------------------------\n", " * CAM_LIST \u306e\u30c7\u30fc\u30bf log\n", " *\t\n", " */\n", "void cam_list_log(void)\n", "{\n", "\tCAM_LIST *p;\n", "\tlong i = 0;\n", "\tchar str[256];\n", "\n", "\tsprintf(str, \"----- CAM \u30ea\u30b9\u30c8\u3092\u8868\u793a -----\\n\");\n", "\tOneShotLog(str);\n", "\tp = cam_list_info.head;\n", "\twhile( p != NULL) {\n", "\t\ti++;\n", "\t\tsprintf(str, \"CAM LIST %d : CAM adress = [%x]   gcode = [%d]\\n\", (int)i, (int)p->cam, p->cam->gcode);\n", "\t\tOneShotLog(str);\n", "\t\tsprintf(str, \"            : sx = [%f]   sy = [%f]   ex = [%f]   ey = [%f]\\n\", p->cam->sx, p->cam->sy, p->cam->ex, p->cam->ey);\n", "\t\tOneShotLog(str);\n", "\t\tp = p->next;\n", "\t}\n", "\tsprintf(str, \"-------------------------------\\n\");\n", "\tOneShotLog(str);\n", "}\n"], "project": "sagcad-doc", "file": "List_cam.pkl", "function": "cam_list_log"}, {"comment_all": {"comment": "/* OK, let's do the commit */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 349}, "comment_text": "/* OK, let's do the commit */", "comment_tokens": ["OK", ",", "let", "'s", "do", "the", "commit"], "ccode": ["\n", "int security_set_boolean_list(size_t boolcnt, SELboolean * boollist,\n", "\t\t\t      int permanent)\n", "{\n", "\n", "\tsize_t i;\n", "\tfor (i = 0; i < boolcnt; i++) {\n", "\t\tboollist[i].value = !!boollist[i].value;\n", "\t\tif (security_set_boolean(boollist[i].name, boollist[i].value)) {\n", "\t\t\trollback(boollist, i);\n", "\t\t\treturn -1;\n", "\t\t}\n", "\t}\n", "\n", "\t/* OK, let's do the commit */\n", "\tif (security_commit_booleans()) {\n", "\t\treturn -1;\n", "\t}\n", "\n", "\t/* Return error as flag no longer used */\n", "\tif (permanent)\n", "\t\treturn -1;\n", "\n", "\treturn 0;\n", "}\n"], "project": "libselinux1", "file": "booleans.pkl", "function": "security_set_boolean_list"}, {"comment_all": {"comment": "/* Make sure that the interface list is up-to-date.\n\t     \n\t     We do this here as we may need the results below, and\n\t     the DNS code needs them for --interface-name stuff.\n\n\t     Multiple calls to enumerate_interfaces() per select loop are\n\t     inhibited, so calls to it in the child process (which doesn't select())\n\t     have no effect. This avoids two processes reading from the same\n\t     netlink fd and screwing the pooch entirely.\n\t  */", "depth": 3, "reading_ease": 71.65, "reading_grade": 7.4, "line": 1683}, "comment_text": "/* Make sure that the interface list is up-to-date.\n\t     \n\t     We do this here as we may need the results below, and\n\t     the DNS code needs them for --interface-name stuff.\n\n\t     Multiple calls to enumerate_interfaces() per select loop are\n\t     inhibited, so calls to it in the child process (which doesn't select())\n\t     have no effect. This avoids two processes reading from the same\n\t     netlink fd and screwing the pooch entirely.\n\t  */", "comment_tokens": ["Make", "sure", "that", "the", "interface", "list", "is", "up-to-date", ".", "We", "do", "this", "here", "as", "we", "may", "need", "the", "results", "below", ",", "and", "the", "DNS", "code", "needs", "them", "for", "--", "interface-name", "stuff", ".", "Multiple", "calls", "to", "enumerate_interfaces", "(", ")", "per", "select", "loop", "are", "inhibited", ",", "so", "calls", "to", "it", "in", "the", "child", "process", "(", "which", "does", "n't", "select", "(", ")", ")", "have", "no", "effect", ".", "This", "avoids", "two", "processes", "reading", "from", "the", "same", "netlink", "fd", "and", "screwing", "the", "pooch", "entirely", "."], "ccode": ["\n", "static void check_dns_listeners(time_t now)\n", "{\n", "  struct serverfd *serverfdp;\n", "  struct listener *listener;\n", "  struct randfd_list *rfl;\n", "  int i;\n", "\n", "  for (serverfdp = daemon->sfds; serverfdp; serverfdp = serverfdp->next)\n", "    if (poll_check(serverfdp->fd, POLLIN))\n", "      reply_query(serverfdp->fd, now);\n", "  \n", "  for (i = 0; i < RANDOM_SOCKS; i++)\n", "    if (daemon->randomsocks[i].refcount != 0 && \n", "\tpoll_check(daemon->randomsocks[i].fd, POLLIN))\n", "      reply_query(daemon->randomsocks[i].fd, now);\n", "\n", "  /* Check overflow random sockets too. */\n", "  for (rfl = daemon->rfl_poll; rfl; rfl = rfl->next)\n", "    if (poll_check(rfl->rfd->fd, POLLIN))\n", "      reply_query(rfl->rfd->fd, now);\n", "  \n", "  for (listener = daemon->listeners; listener; listener = listener->next)\n", "    {\n", "      if (listener->fd != -1 && poll_check(listener->fd, POLLIN))\n", "\treceive_query(listener, now); \n", "      \n", "#ifdef HAVE_TFTP     \n", "      if (listener->tftpfd != -1 && poll_check(listener->tftpfd, POLLIN))\n", "\ttftp_request(listener, now);\n", "#endif\n", "\n", "      if (listener->tcpfd != -1 && poll_check(listener->tcpfd, POLLIN))\n", "\t{\n", "\t  int confd, client_ok = 1;\n", "\t  struct irec *iface = NULL;\n", "\t  pid_t p;\n", "\t  union mysockaddr tcp_addr;\n", "\t  socklen_t tcp_len = sizeof(union mysockaddr);\n", "\n", "\t  while ((confd = accept(listener->tcpfd, NULL, NULL)) == -1 && errno == EINTR);\n", "\t  \n", "\t  if (confd == -1)\n", "\t    continue;\n", "\t  \n", "\t  if (getsockname(confd, (struct sockaddr *)&tcp_addr, &tcp_len) == -1)\n", "\t    {\n", "\t      while (retry_send(close(confd)));\n", "\t      continue;\n", "\t    }\n", "\t  \n", "\t  /* Make sure that the interface list is up-to-date.\n", "\t     \n", "\t     We do this here as we may need the results below, and\n", "\t     the DNS code needs them for --interface-name stuff.\n", "\n", "\t     Multiple calls to enumerate_interfaces() per select loop are\n", "\t     inhibited, so calls to it in the child process (which doesn't select())\n", "\t     have no effect. This avoids two processes reading from the same\n", "\t     netlink fd and screwing the pooch entirely.\n", "\t  */\n", " \n", "\t  enumerate_interfaces(0);\n", "\t  \n", "\t  if (option_bool(OPT_NOWILD))\n", "\t    iface = listener->iface; /* May be NULL */\n", "\t  else \n", "\t    {\n", "\t      int if_index;\n", "\t      char intr_name[IF_NAMESIZE];\n", "\t      \n", "\t      /* if we can find the arrival interface, check it's one that's allowed */\n", "\t      if ((if_index = tcp_interface(confd, tcp_addr.sa.sa_family)) != 0 &&\n", "\t\t  indextoname(listener->tcpfd, if_index, intr_name))\n", "\t\t{\n", "\t\t  struct all_addr addr;\n", "\t\t  addr.addr.addr4 = tcp_addr.in.sin_addr;\n", "#ifdef HAVE_IPV6\n", "\t\t  if (tcp_addr.sa.sa_family == AF_INET6)\n", "\t\t    addr.addr.addr6 = tcp_addr.in6.sin6_addr;\n", "#endif\n", "\t\t  \n", "\t\t  for (iface = daemon->interfaces; iface; iface = iface->next)\n", "\t\t    if (iface->index == if_index)\n", "\t\t      break;\n", "\t\t  \n", "\t\t  if (!iface && !loopback_exception(listener->tcpfd, tcp_addr.sa.sa_family, &addr, intr_name))\n", "\t\t    client_ok = 0;\n", "\t\t}\n", "\t      \n", "\t      if (option_bool(OPT_CLEVERBIND))\n", "\t\tiface = listener->iface; /* May be NULL */\n", "\t      else\n", "\t\t{\n", "\t\t  /* Check for allowed interfaces when binding the wildcard address:\n", "\t\t     we do this by looking for an interface with the same address as \n", "\t\t     the local address of the TCP connection, then looking to see if that's\n", "\t\t     an allowed interface. As a side effect, we get the netmask of the\n", "\t\t     interface too, for localisation. */\n", "\t\t  \n", "\t\t  for (iface = daemon->interfaces; iface; iface = iface->next)\n", "\t\t    if (sockaddr_isequal(&iface->addr, &tcp_addr))\n", "\t\t      break;\n", "\t\t  \n", "\t\t  if (!iface)\n", "\t\t    client_ok = 0;\n", "\t\t}\n", "\t    }\n", "\t  \n", "\t  if (!client_ok)\n", "\t    {\n", "\t      shutdown(confd, SHUT_RDWR);\n", "\t      while (retry_send(close(confd)));\n", "\t    }\n", "#ifndef NO_FORK\n", "\t  else if (!option_bool(OPT_DEBUG) && (p = fork()) != 0)\n", "\t    {\n", "\t      if (p != -1)\n", "\t\t{\n", "\t\t  int i;\n", "\t\t  for (i = 0; i < MAX_PROCS; i++)\n", "\t\t    if (daemon->tcp_pids[i] == 0)\n", "\t\t      {\n", "\t\t\tdaemon->tcp_pids[i] = p;\n", "\t\t\tbreak;\n", "\t\t      }\n", "\t\t}\n", "\t      while (retry_send(close(confd)));\n", "\n", "\t      /* The child can use up to TCP_MAX_QUERIES ids, so skip that many. */\n", "\t      daemon->log_id += TCP_MAX_QUERIES;\n", "\t    }\n", "#endif\n", "\t  else\n", "\t    {\n", "\t      unsigned char *buff;\n", "\t      struct server *s; \n", "\t      int flags;\n", "\t      struct in_addr netmask;\n", "\t      int auth_dns;\n", "\n", "\t      if (iface)\n", "\t\t{\n", "\t\t  netmask = iface->netmask;\n", "\t\t  auth_dns = iface->dns_auth;\n", "\t\t}\n", "\t      else\n", "\t\t{\n", "\t\t  netmask.s_addr = 0;\n", "\t\t  auth_dns = 0;\n", "\t\t}\n", "\n", "#ifndef NO_FORK\n", "\t      /* Arrange for SIGALRM after CHILD_LIFETIME seconds to\n", "\t\t terminate the process. */\n", "\t      if (!option_bool(OPT_DEBUG))\n", "\t\talarm(CHILD_LIFETIME);\n", "#endif\n", "\n", "\t      /* start with no upstream connections. */\n", "\t      for (s = daemon->servers; s; s = s->next)\n", "\t\t s->tcpfd = -1; \n", "\t      \n", "\t      /* The connected socket inherits non-blocking\n", "\t\t attribute from the listening socket. \n", "\t\t Reset that here. */\n", "\t      if ((flags = fcntl(confd, F_GETFL, 0)) != -1)\n", "\t\tfcntl(confd, F_SETFL, flags & ~O_NONBLOCK);\n", "\t      \n", "\t      buff = tcp_request(confd, now, &tcp_addr, netmask, auth_dns);\n", "\t       \n", "\t      shutdown(confd, SHUT_RDWR);\n", "\t      while (retry_send(close(confd)));\n", "\t      \n", "\t      if (buff)\n", "\t\tfree(buff);\n", "\t      \n", "\t      for (s = daemon->servers; s; s = s->next)\n", "\t\tif (s->tcpfd != -1)\n", "\t\t  {\n", "\t\t    shutdown(s->tcpfd, SHUT_RDWR);\n", "\t\t    while (retry_send(close(s->tcpfd)));\n", "\t\t  }\n", "#ifndef NO_FORK\t\t   \n", "\t      if (!option_bool(OPT_DEBUG))\n", "\t\t{\n", "\t\t  flush_log();\n", "\t\t  _exit(0);\n", "\t\t}\n", "#endif\n", "\t    }\n", "\t}\n", "    }\n", "}\n"], "project": "dnsmasq-base", "file": "dnsmasq.pkl", "function": "check_dns_listeners"}, {"comment_all": {"comment": "// Remove from the end of the queue \n", "depth": 0, "reading_ease": 106.67, "reading_grade": 0.1, "line": 241}, "comment_text": "// Remove from the end of the queue \n", "comment_tokens": ["Remove", "from", "the", "end", "of", "the", "queue"], "ccode": ["\n", "// Remove from the end of the queue \n", "static void dequeue(Queue *queue)\n", "{\n", "\tQNode *temp = queue->end;\n", "\n", "\tif (queue_is_empty(queue))\n", "\t\treturn;\n", "\n", "\tremove_node(queue, queue->end);\n", "\n", "//\tif (queue->cleanup)\n", "//\t\tqueue->cleanup(temp->str); \n", "\tfree(temp->str);\n", "\tfree(temp);\n", " \n", "\t// decrement the total of full slots by 1\n", "\tqueue->count--;\n", "}\n"], "project": "libaudit1", "file": "lru.pkl", "function": "dequeue"}, {"comment_all": {"comment": "/* ttl of 1 combined with a NULL return distinguishes a failed lookup from DNS queries not being available */", "depth": 1, "reading_ease": 70.13, "reading_grade": 8.0, "line": 158}, "comment_text": "/* ttl of 1 combined with a NULL return distinguishes a failed lookup from DNS queries not being available */", "comment_tokens": ["ttl", "of", "1", "combined", "with", "a", "NULL", "return", "distinguishes", "a", "failed", "lookup", "from", "DNS", "queries", "not", "being", "available"], "ccode": ["\n", "#else\n", "\n", "char *\n", "dnsquery(const char *domain, int qtype, unsigned int *ttl)\n", "{\n", "    if (ttl)\n", "        *ttl = 1; /* ttl of 1 combined with a NULL return distinguishes a failed lookup from DNS queries not being available */\n", "    return NULL;\n", "}\n"], "project": "libclamav9", "file": "dns.pkl", "function": "dnsquery"}, {"comment_all": {"comment": "/*VAR returns cumulative probability from -oo to z */", "depth": 0, "reading_ease": 29.52, "reading_grade": 11.1, "line": 32}, "comment_text": "/*VAR returns cumulative probability from -oo to z */\n/*VAR normal z value */\n", "comment_tokens": ["VAR", "returns", "cumulative", "probability", "from", "-oo", "to", "z", "VAR", "normal", "z", "value"], "ccode": ["/*\n", "\n", "    Compute probability of measured Chi Square value.\n", "    \n", "    This code was developed by Gary Perlman of the Wang\n", "    Institute (full citation below) and has been minimally\n", "    modified for use in this program.\n", "    \n", "*/\n", "\n", "#include <math.h>\n", "\n", "/*HEADER\n", "\tModule:       z.c\n", "\tPurpose:      compute approximations to normal z distribution probabilities\n", "\tProgrammer:   Gary Perlman\n", "\tOrganization: Wang Institute, Tyngsboro, MA 01879\n", "\tCopyright:    none\n", "\tTabstops:     4\n", "*/\n", "\n", "#define\tZ_MAX          6.0            /* maximum meaningful z value */\n", "\n", "/*FUNCTION poz: probability of normal z value */\n", "/*ALGORITHM\n", "\tAdapted from a polynomial approximation in:\n", "\t\tIbbetson D, Algorithm 209\n", "\t\tCollected Algorithms of the CACM 1963 p. 616\n", "\tNote:\n", "\t\tThis routine has six digit accuracy, so it is only useful for absolute\n", "\t\tz values < 6.  For z values >= to 6.0, poz() returns 0.0.\n", "*/\n", "static double        /*VAR returns cumulative probability from -oo to z */\n", "poz(const double z)  /*VAR normal z value */\n", "{\n", "    double y, x, w;\n", "\n", "    if (z == 0.0) {\n", "    \tx = 0.0;\n", "    } else {\n", "\ty = 0.5 * fabs(z);\n", "\tif (y >= (Z_MAX * 0.5)) {\n", "    \t    x = 1.0;\n", "\t} else if (y < 1.0) {\n", "\t   w = y * y;\n", "\t   x = ((((((((0.000124818987 * w\n", "\t\t   -0.001075204047) * w +0.005198775019) * w\n", "\t\t   -0.019198292004) * w +0.059054035642) * w\n", "\t\t   -0.151968751364) * w +0.319152932694) * w\n", "\t\t   -0.531923007300) * w +0.797884560593) * y * 2.0;\n", "\t} else {\n", "\t    y -= 2.0;\n", "\t    x = (((((((((((((-0.000045255659 * y\n", "\t\t    +0.000152529290) * y -0.000019538132) * y\n", "\t\t    -0.000676904986) * y +0.001390604284) * y\n", "\t\t    -0.000794620820) * y -0.002034254874) * y\n", "\t\t    +0.006549791214) * y -0.010557625006) * y\n", "\t\t    +0.011630447319) * y -0.009279453341) * y\n", "\t\t    +0.005353579108) * y -0.002141268741) * y\n", "\t\t    +0.000535310849) * y +0.999936657524;\n", "    \t}\n", "    }\n", "    return (z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5));\n", "}\n"], "project": "ent", "file": "chisq.pkl", "function": "poz"}, {"comment_all": {"comment": "/****************************************************************************\nPARAMETERS:\nsegment\t- Segment to load data from\noffset\t- Offset to load data from\n\nRETURNS:\nByte value read from the absolute memory location.\n****************************************************************************/", "depth": 0, "reading_ease": 32.22, "reading_grade": 14.2, "line": 531}, "comment_text": "/****************************************************************************\nPARAMETERS:\nsegment\t- Segment to load data from\noffset\t- Offset to load data from\n\nRETURNS:\nByte value read from the absolute memory location.\n****************************************************************************/", "comment_tokens": ["PARAMETERS", ":", "segment", "-", "Segment", "to", "load", "data", "from", "offset", "-", "Offset", "to", "load", "data", "from", "RETURNS", ":", "Byte", "value", "read", "from", "the", "absolute", "memory", "location", "."], "ccode": ["\n", "/****************************************************************************\n", "PARAMETERS:\n", "segment\t- Segment to load data from\n", "offset\t- Offset to load data from\n", "\n", "RETURNS:\n", "Byte value read from the absolute memory location.\n", "****************************************************************************/\n", "u8 fetch_data_byte_abs(x86emu_t *emu, sel_t *seg, u32 ofs)\n", "{\n", "  u32 val;\n", "\n", "  check_data_access(emu, seg, ofs, 1);\n", "\n", "  decode_memio(emu, seg->base + ofs, &val, X86EMU_MEMIO_8 + X86EMU_MEMIO_R);\n", "\n", "  return val;\n", "}\n"], "project": "libx86emu-dev", "file": "decode.pkl", "function": "fetch_data_byte_abs"}, {"comment_all": {"comment": "/* \n\t   No need to use this extra level of indirection;\n\t   we handle all audio_buffer updating in mikmod_play_frame ()\n\t */", "depth": 1, "reading_ease": 46.78, "reading_grade": 10.7, "line": 35}, "comment_text": "/* \n\t   No need to use this extra level of indirection;\n\t   we handle all audio_buffer updating in mikmod_play_frame ()\n\t */", "comment_tokens": ["No", "need", "to", "use", "this", "extra", "level", "of", "indirection", ";", "we", "handle", "all", "audio_buffer", "updating", "in", "mikmod_play_frame", "(", ")"], "ccode": ["\n", "static void alsaplayer_Update (void)\n", "{\n", "\t/* \n", "\t   No need to use this extra level of indirection;\n", "\t   we handle all audio_buffer updating in mikmod_play_frame ()\n", "\t */\n", "}\n"], "project": "alsaplayer-gtk", "file": "drv_alsaplayer.pkl", "function": "alsaplayer_Update"}, {"comment_all": {"comment": "/* For abs(x) >= log(2), it's safe to evaluate exp(x) - 1 directly; this\n       also works fine for infinities and nans.\n\n       For smaller x, we can use a method due to Kahan that achieves close to\n       full accuracy.\n    */", "depth": 1, "reading_ease": 70.63, "reading_grade": 7.8, "line": 167}, "comment_text": "/* For abs(x) >= log(2), it's safe to evaluate exp(x) - 1 directly; this\n       also works fine for infinities and nans.\n\n       For smaller x, we can use a method due to Kahan that achieves close to\n       full accuracy.\n    */", "comment_tokens": ["For", "abs", "(", "x", ")", ">", "=", "log", "(", "2", ")", ",", "it", "'s", "safe", "to", "evaluate", "exp", "(", "x", ")", "-", "1", "directly", ";", "this", "also", "works", "fine", "for", "infinities", "and", "nans", ".", "For", "smaller", "x", ",", "we", "can", "use", "a", "method", "due", "to", "Kahan", "that", "achieves", "close", "to", "full", "accuracy", "."], "ccode": ["\n", "/* Mathematically, expm1(x) = exp(x) - 1.  The expm1 function is designed\n", "   to avoid the significant loss of precision that arises from direct\n", "   evaluation of the expression exp(x) - 1, for x near 0. */\n", "\n", "double\n", "_Py_expm1(double x)\n", "{\n", "    /* For abs(x) >= log(2), it's safe to evaluate exp(x) - 1 directly; this\n", "       also works fine for infinities and nans.\n", "\n", "       For smaller x, we can use a method due to Kahan that achieves close to\n", "       full accuracy.\n", "    */\n", "\n", "    if (fabs(x) < 0.7) {\n", "        double u;\n", "        u = exp(x);\n", "        if (u == 1.0)\n", "            return x;\n", "        else\n", "            return (u - 1.0) * x / log(u);\n", "    }\n", "    else\n", "        return exp(x) - 1.0;\n", "}\n"], "project": "python2.7-doc", "file": "_math.pkl", "function": "_Py_expm1"}, {"comment_all": {"comment": "/* If this is a) \\NoSelect leaf, b) not LAYOUT=index\n\t\t\t   and c) NO-NOSELECT is set, try to rmdir the leaf\n\t\t\t   directores from filesystem. (With LAYOUT=index the\n\t\t\t   \\NoSelect mailboxes aren't on the filesystem.) */", "depth": 3, "reading_ease": 64.2, "reading_grade": 8.2, "line": 199}, "comment_text": "/* If this is a) \\NoSelect leaf, b) not LAYOUT=index\n\t\t\t   and c) NO-NOSELECT is set, try to rmdir the leaf\n\t\t\t   directores from filesystem. (With LAYOUT=index the\n\t\t\t   \\NoSelect mailboxes aren't on the filesystem.) */", "comment_tokens": ["If", "this", "is", "a", ")", "\\NoSelect", "leaf", ",", "b", ")", "not", "LAYOUT=index", "and", "c", ")", "NO-NOSELECT", "is", "set", ",", "try", "to", "rmdir", "the", "leaf", "directores", "from", "filesystem", ".", "(", "With", "LAYOUT=index", "the", "\\NoSelect", "mailboxes", "are", "n't", "on", "the", "filesystem", ".", ")"], "ccode": ["\n", "const struct mailbox_info *\n", "mailbox_list_index_iter_next(struct mailbox_list_iterate_context *_ctx)\n", "{\n", "\tstruct mailbox_list_index *ilist = INDEX_LIST_CONTEXT_REQUIRE(_ctx->list);\n", "\tif (!_ctx->index_iteration) {\n", "\t\t/* index isn't being used */\n", "\t\treturn ilist->module_ctx.super.iter_next(_ctx);\n", "\t}\n", "\n", "\tstruct mailbox_list_index_iterate_context *ctx =\n", "\t\t(struct mailbox_list_index_iterate_context *)_ctx;\n", "\tbool follow_children;\n", "\tenum imap_match_result match;\n", "\n", "\t/* listing mailboxes from index */\n", "\twhile (ctx->next_node != NULL) {\n", "\t\tmailbox_list_index_update_info(ctx);\n", "\t\tmatch = imap_match(_ctx->glob, ctx->info.vname);\n", "\n", "\t\tfollow_children = (match & (IMAP_MATCH_YES |\n", "\t\t\t\t\t    IMAP_MATCH_CHILDREN)) != 0;\n", "\t\tif (match == IMAP_MATCH_YES && iter_subscriptions_ok(ctx)) {\n", "\t\t\t/* If this is a) \\NoSelect leaf, b) not LAYOUT=index\n", "\t\t\t   and c) NO-NOSELECT is set, try to rmdir the leaf\n", "\t\t\t   directores from filesystem. (With LAYOUT=index the\n", "\t\t\t   \\NoSelect mailboxes aren't on the filesystem.) */\n", "\t\t\tif (ilist->has_backing_store &&\n", "\t\t\t    mailbox_list_iter_try_delete_noselect(_ctx, &ctx->info,\n", "\t\t\t\t\t\t\t\t  str_c(ctx->path))) {\n", "\t\t\t\t/* Deleted \\NoSelect leaf. Refresh the index\n", "\t\t\t\t   later on so it gets removed from the index\n", "\t\t\t\t   as well. */\n", "\t\t\t\tmailbox_list_index_refresh_later(_ctx->list);\n", "\t\t\t} else {\n", "\t\t\t\tmailbox_list_index_update_next(ctx, TRUE);\n", "\t\t\t\treturn &ctx->info;\n", "\t\t\t}\n", "\t\t} else if ((_ctx->flags & MAILBOX_LIST_ITER_SELECT_SUBSCRIBED) != 0 &&\n", "\t\t\t   (ctx->info.flags & MAILBOX_CHILD_SUBSCRIBED) == 0) {\n", "\t\t\t/* listing only subscriptions, but there are no\n", "\t\t\t   subscribed children. */\n", "\t\t\tfollow_children = FALSE;\n", "\t\t}\n", "\t\tmailbox_list_index_update_next(ctx, follow_children);\n", "\t}\n", "\treturn mailbox_list_iter_default_next(_ctx);\n", "}\n"], "project": "dovecot-sieve", "file": "mailbox-list-index-iter.pkl", "function": "mailbox_list_index_iter_next"}, {"comment_all": {"comment": "/*\n * Clear mark bits in all allocated heap blocks.  This invalidates\n * the marker invariant, and sets GC_mark_state to reflect this.\n * (This implicitly starts marking to reestablish the invariant.)\n */", "depth": 0, "reading_ease": 53.88, "reading_grade": 8.0, "line": 212}, "comment_text": "/*\n * Clear mark bits in all allocated heap blocks.  This invalidates\n * the marker invariant, and sets GC_mark_state to reflect this.\n * (This implicitly starts marking to reestablish the invariant.)\n */", "comment_tokens": ["Clear", "mark", "bits", "in", "all", "allocated", "heap", "blocks", ".", "This", "invalidates", "the", "marker", "invariant", ",", "and", "sets", "GC_mark_state", "to", "reflect", "this", ".", "(", "This", "implicitly", "starts", "marking", "to", "reestablish", "the", "invariant", ".", ")"], "ccode": ["\n", "\n", "/*\n", " * Clear mark bits in all allocated heap blocks.  This invalidates\n", " * the marker invariant, and sets GC_mark_state to reflect this.\n", " * (This implicitly starts marking to reestablish the invariant.)\n", " */\n", "void GC_clear_marks()\n", "{\n", "    GC_apply_to_all_blocks(clear_marks_for_block, (word)0);\n", "    GC_objects_are_marked = FALSE;\n", "    GC_mark_state = MS_INVALID;\n", "    scan_ptr = 0;\n", "#   ifdef GATHERSTATS\n", "\t/* Counters reflect currently marked objects: reset here */\n", "        GC_composite_in_use = 0;\n", "        GC_atomic_in_use = 0;\n", "#   endif\n", "\n", "}\n"], "project": "libmono-system-servicemodel-discovery4.0-cil", "file": "mark.pkl", "function": "GC_clear_marks"}, {"comment_all": {"comment": "/* Change the size of an allocated block of memory P to N bytes,\n   with error checking.  */", "depth": 0, "reading_ease": 72.16, "reading_grade": 7.2, "line": 92}, "comment_text": "/* Change the size of an allocated block of memory P to N bytes,\n   with error checking.  */", "comment_tokens": ["Change", "the", "size", "of", "an", "allocated", "block", "of", "memory", "P", "to", "N", "bytes", ",", "with", "error", "checking", "."], "ccode": ["\n", "/* Change the size of an allocated block of memory P to N bytes,\n", "   with error checking.  */\n", "\n", "void *\n", "xrealloc (void *p, size_t n)\n", "{\n", "  p = realloc (p, n);\n", "  if (p == 0)\n", "    xalloc_die ();\n", "  return p;\n", "}\n"], "project": "heroes", "file": "xmalloc.pkl", "function": "xrealloc"}, {"comment_all": {"comment": "/* [SS] 2017-11-16 submitted by Jonathan Hough (msb,lsb interchanged) */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 133}, "comment_text": "/* [SS] 2017-11-16 submitted by Jonathan Hough (msb,lsb interchanged) */", "comment_tokens": ["[", "SS", "]", "2017-11-16", "submitted", "by", "Jonathan", "Hough", "(", "msb", ",", "lsb", "interchanged", ")"], "ccode": ["\n", "\n", "/* [SS] 2017-11-16 submitted by Jonathan Hough (msb,lsb interchanged) */\n", "void txt_pitchbend(chan,lsb,msb)\n", "int chan, msb, lsb;\n", "{\n", "  prtime();\n", "  printf(\"Pitchbend, chan=%d lsb=%d msb=%d\\n\",chan+1,msb,lsb);\n", "}\n"], "project": "abcmidi", "file": "mftext.pkl", "function": "txt_pitchbend"}, {"comment_all": {"comment": "/*\n * Print fmt and it's arguments (printf-style) to a newly allocated\n * buffer and return a pointer to that buffer if successful, NULL\n * if we ran out of memory.\n */", "depth": 0, "reading_ease": 44.07, "reading_grade": 13.8, "line": 156}, "comment_text": "/*\n * Print fmt and it's arguments (printf-style) to a newly allocated\n * buffer and return a pointer to that buffer if successful, NULL\n * if we ran out of memory.\n */", "comment_tokens": ["Print", "fmt", "and", "it", "'s", "arguments", "(", "printf-style", ")", "to", "a", "newly", "allocated", "buffer", "and", "return", "a", "pointer", "to", "that", "buffer", "if", "successful", ",", "NULL", "if", "we", "ran", "out", "of", "memory", "."], "ccode": ["\n", "/*\n", " * Print fmt and it's arguments (printf-style) to a newly allocated\n", " * buffer and return a pointer to that buffer if successful, NULL\n", " * if we ran out of memory.\n", " */\n", "static char *bprintf (const char *fmt, ...)\n", "{\n", "   char *buf;\n", "   va_list ap;\n", "   va_start (ap,fmt);\n", "   buf = vbprintf (fmt,ap);\n", "   va_end (ap);\n", "   return (buf);\n", "}\n"], "project": "libdebug0-dev", "file": "log.pkl", "function": "bprintf"}, {"comment_all": {"comment": "/**\n * u2fh_global_done:\n *\n * Release all resources from the library.  Call this function when no\n * further use of the library is needed.\n */", "depth": 0, "reading_ease": 70.29, "reading_grade": 5.8, "line": 41}, "comment_text": "/**\n * u2fh_global_done:\n *\n * Release all resources from the library.  Call this function when no\n * further use of the library is needed.\n */", "comment_tokens": ["u2fh_global_done", ":", "Release", "all", "resources", "from", "the", "library", ".", "Call", "this", "function", "when", "no", "further", "use", "of", "the", "library", "is", "needed", "."], "ccode": ["\n", "/**\n", " * u2fh_global_done:\n", " *\n", " * Release all resources from the library.  Call this function when no\n", " * further use of the library is needed.\n", " */\n", "void\n", "u2fh_global_done (void)\n", "{\n", "  debug = 0;\n", "}\n"], "project": "libu2f-udev", "file": "global.pkl", "function": "u2fh_global_done"}, {"comment_all": {"comment": "/* If the end of a string has been reached, no point recursing */", "depth": 1, "reading_ease": 93.14, "reading_grade": 3.3, "line": 1007}, "comment_text": "/* If the end of a string has been reached, no point recursing */", "comment_tokens": ["If", "the", "end", "of", "a", "string", "has", "been", "reached", ",", "no", "point", "recursing"], "ccode": ["\n", "static void enchant_trie_find_matches(EnchantTrie* trie,EnchantTrieMatcher *matcher)\n", "{\n", "\tint errs = 0;\n", "\tssize_t nxtChI = 0, oldPos = 0;\n", "\tchar* nxtChS = NULL;\n", "\tEnchantTrie* subtrie = NULL;\n", "\n", "\tg_return_if_fail(matcher);\n", "\n", "\t/* Can't match in the empty trie */\n", "\tif(trie == NULL) {\n", "\t\treturn;\n", "\t}\n", "\n", "\t/* Bail out if over the error limits */\n", "\tif(matcher->num_errors > matcher->max_errors){\n", "\t\treturn;\n", "\t}\n", "\n", "\t/* If the end of a string has been reached, no point recursing */\n", "\tif (trie == EOSTrie) {\n", "\t\tsize_t word_len = strlen(matcher->word);\n", "\t\terrs = matcher->num_errors;\n", "\t\tif((ssize_t)word_len > matcher->word_pos) {\n", "\t\t\tmatcher->num_errors = errs + word_len - matcher->word_pos;\n", "\t\t}\n", "\t\tif (matcher->num_errors <= matcher->max_errors) {\n", "\t\t\tmatcher->cbfunc(g_strdup(matcher->path),matcher);\n", "\t\t}\n", "\t\tmatcher->num_errors = errs;\n", "\t\treturn;\n", "\t}\n", "\n", "\t/* If there is a value, just check it, no recursion */\n", "\tif (trie->value != NULL) {\n", "\t\tgchar* value;\n", "\t\terrs = matcher->num_errors;\n", "\t\tvalue = trie->value;\n", "\t\tif(matcher->mode == case_insensitive)\n", "\t\t\t{\n", "\t\t\t\tvalue = g_utf8_strdown(value, -1);\n", "\t\t\t}\n", "\t\tmatcher->num_errors = errs + edit_dist(value, \n", "\t\t\t\t\t   &(matcher->word[matcher->word_pos]));\n", "\t\tif(matcher->mode == case_insensitive)\n", "\t\t\t{\n", "\t\t\t\tg_free(value);\n", "\t\t\t}\n", "\n", "\t\tif (matcher->num_errors <= matcher->max_errors) {\n", "\t\t\tmatcher->cbfunc(g_strconcat(matcher->path,\n", "\t\t\t\t\t\t\ttrie->value,NULL),\n", "\t\t\t\t\tmatcher);\n", "\t\t}\n", "\t\tmatcher->num_errors = errs;\n", "\t\treturn;\n", "\t}\n", "\n", "\tnxtChI = (ssize_t)(g_utf8_next_char(&matcher->word[matcher->word_pos]) - matcher->word);\n", "\tnxtChS = g_strndup(&matcher->word[matcher->word_pos],\n", "\t\t\t(nxtChI - matcher->word_pos));\n", "\n", "\t/* Precisely match the first character, and recurse */\n", "\tsubtrie = enchant_trie_get_subtrie(trie, matcher, &nxtChS);\n", "\n", "\tif (subtrie != NULL) {\n", "\t\tenchant_trie_matcher_pushpath(matcher,nxtChS);\n", "\t\toldPos = matcher->word_pos;\n", "\t\tmatcher->word_pos = nxtChI;\n", "\t\tenchant_trie_find_matches(subtrie,matcher);\n", "\t\tmatcher->word_pos = oldPos;\n", "\t\tenchant_trie_matcher_poppath(matcher,strlen(nxtChS));\n", "\t}\n", "\n", "\tg_free(nxtChS);\n", "\n", "\tmatcher->num_errors++;\n", "\tif (matcher->word[matcher->word_pos] != '\\0') {\n", "\t\t/* Match on inserting word[0] */\n", "\t\toldPos = matcher->word_pos;\n", "\t\tmatcher->word_pos = nxtChI;\n", "\t\tenchant_trie_find_matches(trie,matcher);\n", "\t\tmatcher->word_pos = oldPos;\n", "\t}\n", "\t/* for each subtrie, match on delete or substitute word[0] or transpose word[0] and word[1] */\n", "\tg_hash_table_foreach(trie->subtries,\n", "\t\t\t\tenchant_trie_find_matches_cb,\n", "\t\t\t\tmatcher);\n", "\tmatcher->num_errors--;\n", "}\n"], "project": "libenchant-dev", "file": "pwl.pkl", "function": "enchant_trie_find_matches"}, {"comment_all": {"comment": "/** \n *  gnet_uri_delete:\n *  @uri: a #GURI\n *\n *  Deletes a #GURI.\n *\n **/", "depth": 0, "reading_ease": 106.67, "reading_grade": 0.1, "line": 382}, "comment_text": "/** \n *  gnet_uri_delete:\n *  @uri: a #GURI\n *\n *  Deletes a #GURI.\n *\n **/", "comment_tokens": ["gnet_uri_delete", ":", "@", "uri", ":", "a", "#", "GURI", "Deletes", "a", "#", "GURI", "."], "ccode": ["\n", "\n", "/** \n", " *  gnet_uri_delete:\n", " *  @uri: a #GURI\n", " *\n", " *  Deletes a #GURI.\n", " *\n", " **/\n", "void\n", "gnet_uri_delete (GURI* uri)\n", "{\n", "  if (uri)\n", "    {\n", "      g_free (uri->scheme);\n", "      g_free (uri->user);\n", "      g_free (uri->passwd);\n", "      g_free (uri->hostname);\n", "      g_free (uri->path);\n", "      g_free (uri->query);\n", "      g_free (uri->fragment);\n", "      g_free (uri);\n", "    }\n", "}\n"], "project": "libmms0", "file": "uri.pkl", "function": "gnet_uri_delete"}, {"comment_all": {"comment": "/**\n * exsltDateFormatTime:\n * @dt: an #exsltDateValPtr\n *\n * Formats @dt in xs:time format.\n *\n * Returns a newly allocated string, or NULL in case of error\n */", "depth": 0, "reading_ease": 35.95, "reading_grade": 10.7, "line": 1310}, "comment_text": "/**\n * exsltDateFormatTime:\n * @dt: an #exsltDateValPtr\n *\n * Formats @dt in xs:time format.\n *\n * Returns a newly allocated string, or NULL in case of error\n */", "comment_tokens": ["exsltDateFormatTime", ":", "@", "dt", ":", "an", "#", "exsltDateValPtr", "Formats", "@", "dt", "in", "xs", ":", "time", "format", ".", "Returns", "a", "newly", "allocated", "string", ",", "or", "NULL", "in", "case", "of", "error"], "ccode": ["\n", "/**\n", " * exsltDateFormatTime:\n", " * @dt: an #exsltDateValPtr\n", " *\n", " * Formats @dt in xs:time format.\n", " *\n", " * Returns a newly allocated string, or NULL in case of error\n", " */\n", "static xmlChar *\n", "exsltDateFormatTime (const exsltDateValPtr dt)\n", "{\n", "    xmlChar buf[100], *cur = buf;\n", "\n", "    if ((dt == NULL) || !VALID_TIME(dt))\n", "\treturn NULL;\n", "\n", "    FORMAT_TIME(dt, cur);\n", "    if (dt->tz_flag || (dt->tzo != 0)) {\n", "\tFORMAT_TZ(dt->tzo, cur);\n", "    }\n", "    *cur = 0;\n", "\n", "    return xmlStrdup(buf);\n", "}\n"], "project": "libxslt1.1", "file": "date.pkl", "function": "exsltDateFormatTime"}, {"comment_all": {"comment": "/*\n * NAME:\tutf8->decode()\n * DESCRIPTION:\tdecode a complete utf8 string into a ucs4 string\n */", "depth": 0, "reading_ease": 42.38, "reading_grade": 10.3, "line": 264}, "comment_text": "/*\n * NAME:\tutf8->decode()\n * DESCRIPTION:\tdecode a complete utf8 string into a ucs4 string\n */", "comment_tokens": ["NAME", ":", "utf8-", ">", "decode", "(", ")", "DESCRIPTION", ":", "decode", "a", "complete", "utf8", "string", "into", "a", "ucs4", "string"], "ccode": ["\n", "/*\n", " * NAME:\tutf8->decode()\n", " * DESCRIPTION:\tdecode a complete utf8 string into a ucs4 string\n", " */\n", "void id3_utf8_decode(id3_utf8_t const *utf8, id3_ucs4_t *ucs4)\n", "{\n", "  do\n", "    utf8 += id3_utf8_decodechar(utf8, ucs4);\n", "  while (*ucs4++);\n", "}\n"], "project": "libid3tag0", "file": "utf8.pkl", "function": "id3_utf8_decode"}, {"comment_all": {"comment": "/**\n * Helper function that sets the timestamp for a datafile.\n * @param df the datafile to be altered.\n * @param ts the new timestamp for this datafile.\n */", "depth": 0, "reading_ease": 97.2, "reading_grade": 1.7, "line": 97}, "comment_text": "/**\n * Helper function that sets the timestamp for a datafile.\n * @param df the datafile to be altered.\n * @param ts the new timestamp for this datafile.\n */", "comment_tokens": ["Helper", "function", "that", "sets", "the", "timestamp", "for", "a", "datafile", ".", "@", "param", "df", "the", "datafile", "to", "be", "altered", ".", "@", "param", "ts", "the", "new", "timestamp", "for", "this", "datafile", "."], "ccode": ["\n", "/**\n", " * Helper function that sets the timestamp for a datafile.\n", " * @param df the datafile to be altered.\n", " * @param ts the new timestamp for this datafile.\n", " */\n", "void datafile_set_time (njb_datafile_t *df, time_t ts)\n", "{\n", "  __dsub= \"datafile_set_time\";\n", "  \n", "  __enter;\n", "  df->timestamp = (u_int32_t) ts;\n", "  __leave;\n", "}\n"], "project": "libnjb-dev", "file": "datafile.pkl", "function": "datafile_set_time"}, {"comment_all": {"comment": "/*\n * Clear the uninit block bitmap flag if necessary\n */", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 38}, "comment_text": "/*\n * Clear the uninit block bitmap flag if necessary\n */", "comment_tokens": ["Clear", "the", "uninit", "block", "bitmap", "flag", "if", "necessary"], "ccode": ["/*\n", " * alloc.c --- allocate new inodes, blocks for ext2fs\n", " *\n", " * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.\n", " *\n", " * %Begin-Header%\n", " * This file may be redistributed under the terms of the GNU Library\n", " * General Public License, version 2.\n", " * %End-Header%\n", " */\n", "\n", "#include \"config.h\"\n", "#include <stdio.h>\n", "#if HAVE_UNISTD_H\n", "#include <unistd.h>\n", "#endif\n", "#include <time.h>\n", "#include <string.h>\n", "#if HAVE_SYS_STAT_H\n", "#include <sys/stat.h>\n", "#endif\n", "#if HAVE_SYS_TYPES_H\n", "#include <sys/types.h>\n", "#endif\n", "\n", "#include \"ext2_fs.h\"\n", "#include \"ext2fs.h\"\n", "\n", "#define min(a, b) ((a) < (b) ? (a) : (b))\n", "\n", "#undef DEBUG\n", "\n", "#ifdef DEBUG\n", "# define dbg_printf(f, a...)  do {printf(f, ## a); fflush(stdout); } while (0)\n", "#else\n", "# define dbg_printf(f, a...)\n", "#endif\n", "\n", "/*\n", " * Clear the uninit block bitmap flag if necessary\n", " */\n", "void ext2fs_clear_block_uninit(ext2_filsys fs, dgrp_t group)\n", "{\n", "\tif (group >= fs->group_desc_count ||\n", "\t    !ext2fs_has_group_desc_csum(fs) ||\n", "\t    !(ext2fs_bg_flags_test(fs, group, EXT2_BG_BLOCK_UNINIT)))\n", "\t\treturn;\n", "\n", "\t/* uninit block bitmaps are now initialized in read_bitmaps() */\n", "\n", "\text2fs_bg_flags_clear(fs, group, EXT2_BG_BLOCK_UNINIT);\n", "\text2fs_group_desc_csum_set(fs, group);\n", "\text2fs_mark_super_dirty(fs);\n", "\text2fs_mark_bb_dirty(fs);\n", "}\n"], "project": "e2fslibs", "file": "alloc.pkl", "function": "ext2fs_clear_block_uninit"}, {"comment_all": {"comment": "// create alpha table(4bit to 8bit)\n", "depth": 3, "reading_ease": 83.32, "reading_grade": 2.9, "line": 266}, "comment_text": "// create alpha table(4bit to 8bit)\n", "comment_tokens": ["create", "alpha", "table", "(", "4bit", "to", "8bit", ")"], "ccode": ["\n", "guchar *ddsDecodeDXT3(int width, int height, const unsigned char *buffer) {\n", "\tint *pixels = g_try_malloc(4 * width*height);\n", "\tint index = 128;\n", "\tint w = (width + 3) / 4;\n", "\tint h = (height + 3) / 4;\n", "\tint alphaTable[16];\n", "\tfor (int i = 0; i<h; i++) {\n", "\t\tfor (int j = 0; j<w; j++) {\n", "\t\t\t// create alpha table(4bit to 8bit)\n", "\t\t\tfor (int k = 0; k<4; k++) {\n", "\t\t\t\tint a0 = (buffer[index++] & 0xFF);\n", "\t\t\t\tint a1 = (buffer[index++] & 0xFF);\n", "\t\t\t\t// 4bit alpha to 8bit alpha\n", "\t\t\t\talphaTable[4 * k + 0] = 17 * ((a0 & 0xF0) >> 4);\n", "\t\t\t\talphaTable[4 * k + 1] = 17 * (a0 & 0x0F);\n", "\t\t\t\talphaTable[4 * k + 2] = 17 * ((a1 & 0xF0) >> 4);\n", "\t\t\t\talphaTable[4 * k + 3] = 17 * (a1 & 0x0F);\n", "\t\t\t}\n", "\t\t\tint c0 = (buffer[index] & 0xFF) | (buffer[index + 1] & 0xFF) << 8; index += 2;\n", "\t\t\tint c1 = (buffer[index] & 0xFF) | (buffer[index + 1] & 0xFF) << 8; index += 2;\n", "\t\t\tfor (int k = 0; k<4; k++) {\n", "\t\t\t\tif (4 * i + k >= height) break;\n", "\t\t\t\tint t0 = (buffer[index] & 0x03);\n", "\t\t\t\tint t1 = (buffer[index] & 0x0C) >> 2;\n", "\t\t\t\tint t2 = (buffer[index] & 0x30) >> 4;\n", "\t\t\t\tint t3 = (buffer[index++] & 0xC0) >> 6;\n", "\t\t\t\tpixels[4 * width*i + 4 * j + width*k + 0] = ddsGetDXTColor(c0, c1, alphaTable[4 * k + 0], t0);\n", "\t\t\t\tif (4 * j + 1 >= width) continue;\n", "\t\t\t\tpixels[4 * width*i + 4 * j + width*k + 1] = ddsGetDXTColor(c0, c1, alphaTable[4 * k + 1], t1);\n", "\t\t\t\tif (4 * j + 2 >= width) continue;\n", "\t\t\t\tpixels[4 * width*i + 4 * j + width*k + 2] = ddsGetDXTColor(c0, c1, alphaTable[4 * k + 2], t2);\n", "\t\t\t\tif (4 * j + 3 >= width) continue;\n", "\t\t\t\tpixels[4 * width*i + 4 * j + width*k + 3] = ddsGetDXTColor(c0, c1, alphaTable[4 * k + 3], t3);\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\treturn (guchar *) pixels;\n", "}\n"], "project": "geeqie", "file": "image_load_dds.pkl", "function": "ddsDecodeDXT3"}, {"comment_all": {"comment": "/* Initializes the library. It should be safe to call this more than once at\n * any time, to allow several independant libraries to use fiu at the same\n * time without clashes. */", "depth": 0, "reading_ease": 73.17, "reading_grade": 6.8, "line": 228}, "comment_text": "/* Initializes the library. It should be safe to call this more than once at\n * any time, to allow several independant libraries to use fiu at the same\n * time without clashes. */", "comment_tokens": ["Initializes", "the", "library", ".", "It", "should", "be", "safe", "to", "call", "this", "more", "than", "once", "at", "any", "time", ",", "to", "allow", "several", "independant", "libraries", "to", "use", "fiu", "at", "the", "same", "time", "without", "clashes", "."], "ccode": ["\n", "\n", "/*\n", " * Core API\n", " */\n", "\n", "/* Initializes the library. It should be safe to call this more than once at\n", " * any time, to allow several independant libraries to use fiu at the same\n", " * time without clashes. */\n", "int fiu_init(unsigned int flags)\n", "{\n", "\tchar *static_seed_from_env;\n", "\n", "\t/* Used to avoid re-initialization, protected by enabled_fails_lock */\n", "\tstatic int initialized = 0;\n", "\n", "\trec_count++;\n", "\tef_wlock();\n", "\tif (initialized) {\n", "\t\tef_wunlock();\n", "\t\trec_count--;\n", "\t\treturn 0;\n", "\t}\n", "\n", "\tpthread_key_create(&last_failinfo_key, NULL);\n", "\n", "\tenabled_fails = wtable_create((void (*)(void *)) pf_free);\n", "\n", "\tif (pthread_atfork(NULL, NULL, atfork_child) != 0) {\n", "\t\tef_wunlock();\n", "\t\trec_count--;\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tstatic_seed_from_env = getenv(\"FIU_PRNG_SEED\");\n", "\tif (static_seed_from_env != NULL) {\n", "\t\tfiu_set_prng_seed(atoi(static_seed_from_env));\n", "\t}\n", "\n", "\tprng_seed();\n", "\n", "\tinitialized = 1;\n", "\n", "\tef_wunlock();\n", "\trec_count--;\n", "\treturn 0;\n", "}\n"], "project": "libfiu0", "file": "fiu.pkl", "function": "fiu_init"}, {"comment_all": {"comment": "//  A   M   C  E/B  A   M   C  E/B  A\n", "depth": 1, "reading_ease": 113.1, "reading_grade": -0.4, "line": 4161}, "comment_text": "// E/B  A   M   C  E/B  A   M   C  E/B\n//  C  E/B  A   M   C  E/B  A   M   C\n//  M   C  E/B  A   M   C  E/B  A   M\n//  A   M   C  E/B  A   M   C  E/B  A\n", "comment_tokens": ["EB", "A", "M", "C", "EB", "A", "M", "C", "EB", "C", "EB", "A", "M", "C", "EB", "A", "M", "C", "M", "C", "EB", "A", "M", "C", "EB", "A", "M", "A", "M", "C", "EB", "A", "M", "C", "EB", "A"], "ccode": ["\n", "static int run_dirwires(struct fpga_model* model)\n", "{\n", "\tint y, x, i;\n", "\n", "\tRC_CHECK(model);\n", "\n", "\t//\n", "\t// A EE4-wire goes through the chip from left to right like this:\n", "\t//\n", "\t// E/B  A   M   C  E/B  A   M   C  E/B\n", "\t//  C  E/B  A   M   C  E/B  A   M   C\n", "\t//  M   C  E/B  A   M   C  E/B  A   M\n", "\t//  A   M   C  E/B  A   M   C  E/B  A\n", "\t//\n", "\t// set_BAMCE_point() adds net entries for one such point, run_dirwire()\n", "\t// runs one wire through the chip, run_dirwires() goes through\n", "\t// all rows vertically.\n", "\t//\n", "\n", "\t//\n", "\t// EE4, EE2, EL1, ER1\n", "\t// WW4, WW2, WL1, WR1\n", "\t//\n", "\n", "\tfor (y = TOP_OUTER_IO; y <= model->y_height-BOT_OUTER_IO; y++) {\n", "\t\tif (is_aty(Y_ROW_HORIZ_AXSYMM|Y_CHIP_HORIZ_REGS, model, y))\n", "\t\t\tcontinue;\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE4, 'E');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE4, 'C');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE4, 'M');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE4, 'A');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE2, 'E');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EE2, 'M');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_EL1, 'E');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_ER1, 'E');\n", "\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW4, 'E');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW4, 'C');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW4, 'M');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW4, 'A');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW2, 'E');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WW2, 'M');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WL1, 'E');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_WR1, 'E');\n", "\t}\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"WW4E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"WW4E_S0\");\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"EL1E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"EL1E_S0\");\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"WR1E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"WR1E_S0\");\n", "\n", "\t\tif (!is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"WW2E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"WW2E_N3\");\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"ER1E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"ER1E_N3\");\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"WL1E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"WL1E_N3\");\n", "\t\t}\n", "\t}\n", "\n", "\t//\n", "\t// NN4, NN2, NL1, NR1\n", "\t// SS4, SS2, SL1, SR1\n", "\t//\n", "\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\n", "\t\tif (is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\tfor (i = 0; i <= 3; i++)\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1-i, x, W_NN4, 'B');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, x, W_NN2, 'B');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-2, x, W_NN2, 'B');\n", "\t\t\tadd_conn_bi_pref(model,\n", "\t\t\t\tmodel->y_height-BOT_INNER_ROW-2, x, \"NN2E0\",\n", "\t\t\t\tmodel->y_height-BOT_INNER_ROW-1, x, \"NN2E_S0\");\n", "\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, x, W_NL1, 'B');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, x, W_NR1, 'B');\n", "\n", "\t\t} else {\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN4, 'E');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN4, 'C');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN4, 'M');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN4, 'A');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN2, 'E');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NN2, 'M');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NL1, 'E');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NR1, 'E');\n", "\t\t}\n", "\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS4, 'E');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS4, 'M');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS4, 'C');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS4, 'A');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS2, 'E');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SS2, 'M');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SL1, 'E');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SR1, 'E');\n", "\t}\n", "\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"NN2E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"NN2E_S0\");\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"NL1E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"NL1E_S0\");\n", "\t\tif (!is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"SS4E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"SS4E_N3\");\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"SS2E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"SS2E_N3\");\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"SR1E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"SR1E_N3\");\n", "\t\t}\n", "\t}\n", "\n", "\t//\n", "\t// SE4, SE2, SW4, SW2\n", "\t//\n", "\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SE4, 'M');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SE4, 'A');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SE2, 'M');\n", "\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SW4, 'M');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SW4, 'A');\n", "\t\trun_dirwire_0to3(model, TOP_INNER_ROW, x, W_SW2, 'M');\n", "\n", "\t\tif (!is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"SW4E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"SW4E_N3\");\n", "\t\t\tadd_conn_bi_pref(model, model->y_height-BOT_INNER_ROW, x, \"SW2E_N3\",\n", "\t\t\t\tmodel->y_height-BOT_LAST_REGULAR_O, x, \"SW2E_N3\");\n", "\t\t}\n", "\t}\n", "\tfor (y = TOP_OUTER_IO; y <= model->y_height-BOT_OUTER_IO; y++) {\n", "\t\tif (is_aty(Y_ROW_HORIZ_AXSYMM|Y_CHIP_HORIZ_REGS, model, y))\n", "\t\t\tcontinue;\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_SE4, 'E');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_SE4, 'C');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_SE2, 'E');\n", "\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_SW4, 'E');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_SW4, 'C');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_SW2, 'E');\n", "\t}\n", "\n", "\t//\n", "\t// NE4, NE2\n", "\t//\n", "\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\n", "\t\tif (is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\t// NE2B is one major right, NE4B is two majors right\n", "\t\t\tint plus_one_major, plus_two_majors;\n", "\t\t\tplus_one_major = x+1;\n", "\t\t\twhile (plus_one_major != -1\n", "\t\t\t       && !is_atx(X_ROUTING_COL, model, plus_one_major)) {\n", "\t\t\t\tif (++plus_one_major >= model->x_width)\n", "\t\t\t\t\tplus_one_major = -1;\n", "\t\t\t}\n", "\t\t\tif (plus_one_major == -1)\n", "\t\t\t\tplus_two_majors = -1;\n", "\t\t\telse {\n", "\t\t\t\tplus_two_majors = plus_one_major + 1;\n", "\t\t\t\twhile (plus_two_majors != -1\n", "\t\t\t\t       && !is_atx(X_ROUTING_COL, model, plus_two_majors)) {\n", "\t\t\t\t\tif (++plus_two_majors >= model->x_width)\n", "\t\t\t\t\t\tplus_two_majors = -1;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif (plus_two_majors != -1) {\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, plus_two_majors, W_NE4, 'B');\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-2, plus_two_majors, W_NE4, 'B');\n", "\t\t\t}\n", "\t\t\tif (plus_one_major != -1) {\n", "\t\t\t\tstruct w_net net;\n", "\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, plus_one_major, W_NE2, 'B');\n", "\n", "\t\t\t\tnet.last_inc = 2;\n", "\t\t\t\tnet.num_pts = 0;\n", "\t\t\t\tfor (i = x; i <= plus_one_major; i++) {\n", "\t\t\t\t\tnet.pt[net.num_pts].start_count = 1;\n", "\t\t\t\t\tnet.pt[net.num_pts].y = model->y_height-BOT_INNER_ROW-1;\n", "\t\t\t\t\tnet.pt[net.num_pts].x = i;\n", "\t\t\t\t\tnet.pt[net.num_pts].name = (i == plus_one_major) ? \"NE2E%i\" : \"NE2M%i\";\n", "\t\t\t\t\tnet.num_pts++;\n", "\t\t\t\t}\n", "\t\t\t\tadd_conn_net(model, ADD_PREF, &net);\n", "\t\t\t\tadd_conn_bi_pref(model,\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW-1, plus_one_major, \"NE2E0\",\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW, plus_one_major, \"NE2E0\");\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NE4, 'M');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NE4, 'A');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NE2, 'M');\n", "\t\t}\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"NE2E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"NE2E_S0\");\n", "\t}\n", "\tfor (y = TOP_OUTER_IO; y <= model->y_height-BOT_OUTER_IO; y++) {\n", "\t\tif (is_aty(Y_ROW_HORIZ_AXSYMM|Y_CHIP_HORIZ_REGS, model, y))\n", "\t\t\tcontinue;\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_NE4, 'E');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_NE4, 'C');\n", "\t\trun_dirwire_0to3(model, y, LEFT_INNER_COL, W_NE2, 'E');\n", "\t}\n", "\n", "\t//\n", "\t// NW4, NW2\n", "\t//\n", "\n", "\tfor (x = LEFT_IO_ROUTING; x <= model->x_width-RIGHT_IO_ROUTING_O; x++) {\n", "\t\tif (!is_atx(X_ROUTING_COL, model, x))\n", "\t\t\tcontinue;\n", "\n", "\t\tif (is_atx(X_FABRIC_BRAM_ROUTING_COL, model, x)) {\n", "\t\t\t// NW2B is one major left, NW4B is two majors left\n", "\t\t\tint minus_one_major, minus_two_majors;\n", "\t\t\tminus_one_major = x-1;\n", "\t\t\twhile (minus_one_major != -1\n", "\t\t\t       && !is_atx(X_ROUTING_COL, model, minus_one_major)) {\n", "\t\t\t\tif (--minus_one_major < LEFT_IO_ROUTING)\n", "\t\t\t\t\tminus_one_major = -1;\n", "\t\t\t}\n", "\t\t\tif (minus_one_major == -1)\n", "\t\t\t\tminus_two_majors = -1;\n", "\t\t\telse {\n", "\t\t\t\tminus_two_majors = minus_one_major - 1;\n", "\t\t\t\twhile (minus_two_majors != -1\n", "\t\t\t\t       && !is_atx(X_ROUTING_COL, model, minus_two_majors)) {\n", "\t\t\t\t\tif (--minus_two_majors < LEFT_IO_ROUTING)\n", "\t\t\t\t\t\tminus_two_majors = -1;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif (minus_two_majors != -1) {\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, minus_two_majors, W_NW4, 'B');\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-2, minus_two_majors, W_NW4, 'B');\n", "\n", "\t\t\t\tadd_conn_bi_pref(model,\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW-2, minus_two_majors, \"NW4E0\",\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW-1, minus_two_majors, \"NW4E_S0\");\n", "\t\t\t\tadd_conn_bi_pref(model,\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW-1, minus_two_majors, \"NW4E0\",\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW, minus_two_majors, \"NW4E0\");\n", "\t\t\t}\n", "\t\t\tif (minus_one_major != -1) {\n", "\t\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW-1, minus_one_major, W_NW2, 'B');\n", "\t\t\t\tadd_conn_bi_pref(model,\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW-1, minus_one_major, \"NW2E0\",\n", "\t\t\t\t\tmodel->y_height-BOT_INNER_ROW, minus_one_major, \"NW2E0\");\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NW4, 'M');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NW4, 'A');\n", "\t\t\trun_dirwire_0to3(model, model->y_height-BOT_INNER_ROW, x, W_NW2, 'M');\n", "\t\t}\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"NW4E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"NW4E_S0\");\n", "\t\tadd_conn_bi_pref(model, TOP_INNER_ROW, x, \"NW2E_S0\",\n", "\t\t\tTOP_FIRST_REGULAR, x, \"NW2E_S0\");\n", "\t}\n", "\tfor (y = TOP_OUTER_IO; y <= model->y_height-BOT_OUTER_IO; y++) {\n", "\t\tif (is_aty(Y_ROW_HORIZ_AXSYMM|Y_CHIP_HORIZ_REGS, model, y))\n", "\t\t\tcontinue;\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_NW4, 'E');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_NW4, 'C');\n", "\t\trun_dirwire_0to3(model, y, model->x_width-RIGHT_INNER_O, W_NW2, 'E');\n", "\t}\n", "\tRC_RETURN(model);\n", "}\n"], "project": "libfpga0", "file": "model_conns.pkl", "function": "run_dirwires"}, {"comment_all": {"comment": "/* DB Version 2 requires DBT's to be zeroed before use. */", "depth": 1, "reading_ease": 78.25, "reading_grade": 4.8, "line": 910}, "comment_text": "/* DB Version 2 requires DBT's to be zeroed before use. */", "comment_tokens": ["DB", "Version", "2", "requires", "DBT", "'s", "to", "be", "zeroed", "before", "use", "."], "ccode": ["\n", "int\n", "chise_attribute_table_get (CHISE_Attribute_Table *db,\n", "\t\t\t   char *key, CHISE_Value *valdatum)\n", "{\n", "  DBT keydatum;\n", "  int status = 0;\n", "\n", "  /* DB Version 2 requires DBT's to be zeroed before use. */\n", "  xzero (keydatum);\n", "  xzero (*valdatum);\n", "\n", "  keydatum.data = key;\n", "  keydatum.size = strlen (key);\n", "\n", "  status = db->get (db, NULL, &keydatum, valdatum, 0);\n", "  return status;\n", "}\n"], "project": "libchise1", "file": "chise.pkl", "function": "chise_attribute_table_get"}, {"comment_all": {"comment": "/* Returns the landmarks[] array and the number of elements\n * in num_landmarks.\n */", "depth": 0, "reading_ease": 51.85, "reading_grade": 8.8, "line": 85}, "comment_text": "/* Returns the landmarks[] array and the number of elements\n * in num_landmarks.\n */", "comment_tokens": ["Returns", "the", "landmarks", "[", "]", "array", "and", "the", "number", "of", "elements", "in", "num_landmarks", "."], "ccode": ["\n", "\n", "/* Returns the landmarks[] array and the number of elements\n", " * in num_landmarks.\n", " */\n", "int32_t *cram_container_get_landmarks(cram_container *c, int32_t *num_landmarks) {\n", "    *num_landmarks = c->num_landmarks;\n", "    return c->landmark;\n", "}\n"], "project": "libhts3", "file": "cram_external.pkl", "function": "cram_container_get_landmarks"}, {"comment_all": {"comment": "/* Idea by Bastien ROUCARI\u00c8S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */", "depth": 1, "reading_ease": -185.89, "reading_grade": 40.1, "line": 88}, "comment_text": "/* Idea by Bastien ROUCARI\u00c8S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */", "comment_tokens": ["Idea", "by", "Bastien", "ROUCARI\u00c8S", ",", "https", ":", "lists.gnu.orgrbug-gnulib2010-12msg00095.html", "Reference", ":", "https", ":", "www.ibm.comsupportknowledgecenterenssw_aix_61com.ibm.aix.basetrf1getprocs.htm"], "ccode": ["/* Program name management.\n", "   Copyright (C) 2016-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"getprogname.h\"\n", "\n", "#include <errno.h> /* get program_invocation_name declaration */\n", "#include <stdlib.h> /* get __argv declaration */\n", "\n", "#ifdef _AIX\n", "# include <unistd.h>\n", "# include <procinfo.h>\n", "# include <string.h>\n", "#endif\n", "\n", "#ifdef __MVS__\n", "# ifndef _OPEN_SYS\n", "#  define _OPEN_SYS\n", "# endif\n", "# include <string.h>\n", "# include <sys/ps.h>\n", "#endif\n", "\n", "#ifdef __hpux\n", "# include <unistd.h>\n", "# include <sys/param.h>\n", "# include <sys/pstat.h>\n", "# include <string.h>\n", "#endif\n", "\n", "#ifdef __sgi\n", "# include <string.h>\n", "# include <unistd.h>\n", "# include <stdio.h>\n", "# include <fcntl.h>\n", "# include <sys/procfs.h>\n", "#endif\n", "\n", "#include \"dirname.h\"\n", "\n", "#ifndef HAVE_GETPROGNAME             /* not Mac OS X, FreeBSD, NetBSD, OpenBSD >= 5.4, Cygwin */\n", "char const *\n", "getprogname (void)\n", "{\n", "# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n", "  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n", "  return program_invocation_short_name;\n", "# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n", "  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n", "  return last_component (program_invocation_name);\n", "# elif HAVE_GETEXECNAME                                     /* Solaris */\n", "  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n", "  const char *p = getexecname ();\n", "  if (!p)\n", "    p = \"?\";\n", "  return last_component (p);\n", "# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n", "  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n", "  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n", "  return last_component (p);\n", "# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n", "  /* https://man.openbsd.org/style.9 */\n", "  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n", "  /* Be careful to declare this only when we absolutely need it\n", "     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n", "     its mere declaration makes program_invocation_short_name\n", "     malfunction (have zero length) with Fedora 25's glibc.  */\n", "  extern char *__progname;\n", "  const char *p = __progname;\n", "  return p && p[0] ? p : \"?\";\n", "# elif _AIX                                                 /* AIX */\n", "  /* Idea by Bastien ROUCARI\u00c8S,\n", "     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n", "     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n", "  */\n", "  static char *p;\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      first = 0;\n", "      pid_t pid = getpid ();\n", "      struct procentry64 procs;\n", "      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n", "           ? strdup (procs.pi_comm)\n", "           : NULL);\n", "      if (!p)\n", "        p = \"?\";\n", "    }\n", "  return p;\n", "# elif defined __hpux\n", "  static char *p;\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      first = 0;\n", "      pid_t pid = getpid ();\n", "      struct pst_status status;\n", "      if (pstat_getproc (&status, sizeof status, 0, pid) > 0)\n", "        {\n", "          char *ucomm = status.pst_ucomm;\n", "          char *cmd = status.pst_cmd;\n", "          if (strlen (ucomm) < PST_UCOMMLEN - 1)\n", "            p = ucomm;\n", "          else\n", "            {\n", "              /* ucomm is truncated to length PST_UCOMMLEN - 1.\n", "                 Look at cmd instead.  */\n", "              char *space = strchr (cmd, ' ');\n", "              if (space != NULL)\n", "                *space = '\\0';\n", "              p = strrchr (cmd, '/');\n", "              if (p != NULL)\n", "                p++;\n", "              else\n", "                p = cmd;\n", "              if (strlen (p) > PST_UCOMMLEN - 1\n", "                  && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n", "                /* p is less truncated than ucomm.  */\n", "                ;\n", "              else\n", "                p = ucomm;\n", "            }\n", "          p = strdup (p);\n", "        }\n", "      else\n", "        {\n", "#  if !defined __LP64__\n", "          /* Support for 32-bit programs running in 64-bit HP-UX.\n", "             The documented way to do this is to use the same source code\n", "             as above, but in a compilation unit where '#define _PSTAT64 1'\n", "             is in effect.  I prefer a single compilation unit; the struct\n", "             size and the offsets are not going to change.  */\n", "          char status64[1216];\n", "          if (__pstat_getproc64 (status64, sizeof status64, 0, pid) > 0)\n", "            {\n", "              char *ucomm = status64 + 288;\n", "              char *cmd = status64 + 168;\n", "              if (strlen (ucomm) < PST_UCOMMLEN - 1)\n", "                p = ucomm;\n", "              else\n", "                {\n", "                  /* ucomm is truncated to length PST_UCOMMLEN - 1.\n", "                     Look at cmd instead.  */\n", "                  char *space = strchr (cmd, ' ');\n", "                  if (space != NULL)\n", "                    *space = '\\0';\n", "                  p = strrchr (cmd, '/');\n", "                  if (p != NULL)\n", "                    p++;\n", "                  else\n", "                    p = cmd;\n", "                  if (strlen (p) > PST_UCOMMLEN - 1\n", "                      && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)\n", "                    /* p is less truncated than ucomm.  */\n", "                    ;\n", "                  else\n", "                    p = ucomm;\n", "                }\n", "              p = strdup (p);\n", "            }\n", "          else\n", "#  endif\n", "            p = NULL;\n", "        }\n", "      if (!p)\n", "        p = \"?\";\n", "    }\n", "  return p;\n", "# elif __MVS__                                              /* z/OS */\n", "  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n", "  static char *p = \"?\";\n", "  static int first = 1;\n", "  if (first)\n", "    {\n", "      pid_t pid = getpid ();\n", "      int token;\n", "      W_PSPROC buf;\n", "      first = 0;\n", "      memset (&buf, 0, sizeof(buf));\n", "      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n", "      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n", "      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n", "      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n", "        {\n", "          for (token = 0; token >= 0;\n", "               token = w_getpsent (token, &buf, sizeof(buf)))\n", "            {\n", "              if (token > 0 && buf.ps_pid == pid)\n", "                {\n", "                  char *s = strdup (last_component (buf.ps_pathptr));\n", "                  if (s)\n", "                    p = s;\n", "                  break;\n", "                }\n", "            }\n", "        }\n", "      free (buf.ps_cmdptr);\n", "      free (buf.ps_conttyptr);\n", "      free (buf.ps_pathptr);\n", "    }\n", "  return p;\n", "# elif defined __sgi                                        /* IRIX */\n", "  char filename[50];\n", "  int fd;\n", "\n", "  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n", "  fd = open (filename, O_RDONLY);\n", "  if (0 <= fd)\n", "    {\n", "      prpsinfo_t buf;\n", "      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n", "      close (fd);\n", "      if (ioctl_ok)\n", "        {\n", "          char *name = buf.pr_fname;\n", "          size_t namesize = sizeof buf.pr_fname;\n", "          char *namenul = memchr (name, '\\0', namesize);\n", "          size_t namelen = namenul ? namenul - name : namesize;\n", "          char *namecopy = malloc (namelen + 1);\n", "          if (namecopy)\n", "            {\n", "              namecopy[namelen] = 0;\n", "              return memcpy (namecopy, name, namelen);\n", "            }\n", "        }\n", "    }\n", "  return NULL;\n", "# else\n", "#  error \"getprogname module not ported to this OS\"\n", "# endif\n", "}\n"], "project": "ruby-hivex", "file": "getprogname.pkl", "function": "getprogname"}, {"comment_all": {"comment": "/**\n * Creates a new generic dup field.\n *\n * @return newly created field\n */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 34}, "comment_text": "/**\n * Creates a new generic dup field.\n *\n * @return newly created field\n */", "comment_tokens": ["Creates", "a", "new", "generic", "dup", "field", ".", "@", "return", "newly", "created", "field"], "ccode": ["/* valagenericdupfield.c generated by valac, the Vala compiler\n", " * generated from valagenericdupfield.vala, do not modify */\n", "\n", "/* valagenericdupfield.vala\n", " *\n", " * Copyright (C) 2019  Rico Tzschichholz\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", "\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", "\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n", " *\n", " * Author:\n", " * \tRico Tzschichholz <ricotz@ubuntu.com>\n", " */\n", "\n", "#include \"vala.h\"\n", "#include <glib.h>\n", "\n", "#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))\n", "\n", "static gpointer vala_generic_dup_field_parent_class = NULL;\n", "\n", "static GType vala_generic_dup_field_get_type_once (void);\n", "\n", "/**\n", " * Creates a new generic dup field.\n", " *\n", " * @return newly created field\n", " */\n", "ValaGenericDupField*\n", "vala_generic_dup_field_construct (GType object_type,\n", "                                  ValaSourceReference* source_reference)\n", "{\n", "\tValaGenericDupField* self = NULL;\n", "\tValaCodeContext* _tmp0_;\n", "\tValaCodeContext* _tmp1_;\n", "\tValaSemanticAnalyzer* _tmp2_;\n", "\tValaSemanticAnalyzer* _tmp3_;\n", "\tValaDelegateType* _tmp4_;\n", "\tg_return_val_if_fail (source_reference != NULL, NULL);\n", "\t_tmp0_ = vala_code_context_get ();\n", "\t_tmp1_ = _tmp0_;\n", "\t_tmp2_ = vala_code_context_get_analyzer (_tmp1_);\n", "\t_tmp3_ = _tmp2_;\n", "\t_tmp4_ = _tmp3_->generics_dup_func_type;\n", "\tself = (ValaGenericDupField*) vala_field_construct (object_type, \"dup\", (ValaDataType*) _tmp4_, NULL, source_reference, NULL);\n", "\t_vala_code_context_unref0 (_tmp1_);\n", "\tvala_symbol_set_external ((ValaSymbol*) self, TRUE);\n", "\treturn self;\n", "}\n"], "project": "libvala-0.48-0", "file": "valagenericdupfield.pkl", "function": "vala_generic_dup_field_construct"}, {"comment_all": {"comment": "/* and replace with var\t   */", "depth": 3, "reading_ease": 92.8, "reading_grade": 1.3, "line": 7158}, "comment_text": "/* find a sigdecl\t\t   */\n/* add to valDefns\t   */\n/* and replace with var\t   */\n", "comment_tokens": ["find", "a", "sigdecl", "add", "to", "valDefns", "and", "replace", "with", "var"], "ccode": ["\n", "static Void local addRSsigdecls(pr)\t/* add sigdecls from TYPE ... IN ..*/\n", "Pair pr; {\n", "    List vs = snd(pr);\t\t\t/* get list of variables\t   */\n", "    for (; nonNull(vs); vs=tl(vs)) {\n", "\tif (fst(hd(vs))==SIGDECL) {\t/* find a sigdecl\t\t   */\n", "\t    valDefns = cons(hd(vs),valDefns);\t/* add to valDefns\t   */\n", "\t    hd(vs)   = hd(snd3(snd(hd(vs))));\t/* and replace with var\t   */\n", "\t}\n", "    }\n", "}\n"], "project": "libhugs-time-bundled", "file": "static.pkl", "function": "addRSsigdecls"}, {"comment_all": {"comment": "/* Memory management wrappers\n * Yes, I realize we're doing a callback to a callback,\n * Deal...\n */", "depth": 0, "reading_ease": 48.81, "reading_grade": 9.9, "line": 110}, "comment_text": "/* Memory management wrappers\n * Yes, I realize we're doing a callback to a callback,\n * Deal...\n */", "comment_tokens": ["Memory", "management", "wrappers", "Yes", ",", "I", "realize", "we", "'re", "doing", "a", "callback", "to", "a", "callback", ",", "Deal", "..."], "ccode": ["\n", "#ifdef LIBSSH2_HAVE_ZLIB\n", "/* ********\n", " * zlib *\n", " ******** */\n", "\n", "/* Memory management wrappers\n", " * Yes, I realize we're doing a callback to a callback,\n", " * Deal...\n", " */\n", "\n", "static voidpf\n", "comp_method_zlib_alloc(voidpf opaque, uInt items, uInt size)\n", "{\n", "    LIBSSH2_SESSION *session = (LIBSSH2_SESSION *) opaque;\n", "\n", "    return (voidpf) LIBSSH2_ALLOC(session, items * size);\n", "}\n"], "project": "libssh2-1", "file": "comp.pkl", "function": "comp_method_zlib_alloc"}, {"comment_all": {"comment": "/* This is a big-endian file. Typically, version 2. */", "depth": 2, "reading_ease": 42.04, "reading_grade": 8.4, "line": 128}, "comment_text": "/* This is a big-endian file. Typically, version 2. */", "comment_tokens": ["This", "is", "a", "big-endian", "file", ".", "Typically", ",", "version", "2", "."], "ccode": ["\n", "static int do_swap;\n", "\n", "int nsig_endianess(NSIG_Record1 *rec1)\n", "{\n", "  /*\n", "   * If NSIG is version1 and on big-endian, then swap.\n", "   * If NSIG is version2 and on little-endian, then swap.\n", "   */\n", "  /*\n", "  printf(\"id = %d %d\\n\", (int)rec1->struct_head.id[0], (int)rec1->struct_head.id[1]);\n", "  */\n", "  if (rec1->struct_head.id[0] == 0) { /* Possible little-endian */\n", "    if (rec1->struct_head.id[1] >= 20)\n", "      /* This is a big-endian file. Typically, version 2. */\n", "      do_swap = little_endian();\n", "    else\n", "      do_swap = big_endian();\n", "  } else if ((rec1->struct_head.id[1] == 0)) { /* Possible big-endian */\n", "    if (rec1->struct_head.id[0] <= 7)\n", "      /* This is a little-endian file.  Version 1. */\n", "      do_swap = big_endian();\n", "  }\n", "  /*\n", "  printf(\"DO SWAP = %d\\n\", do_swap);\n", "  */\n", "  return do_swap;\n", "}\n"], "project": "librsl-dev", "file": "nsig.pkl", "function": "nsig_endianess"}, {"comment_all": {"comment": "/* qsort stability here and for cmp2 is only an issue if multiple\n   dynamic relocations are emitted at the same address.  But targets\n   that apply a series of dynamic relocations each operating on the\n   result of the prior relocation can't use -z combreloc as\n   implemented anyway.  Such schemes tend to be broken by sorting on\n   symbol index.  That leaves dynamic NONE relocs as the only other\n   case where ld might emit multiple relocs at the same address, and\n   those are only emitted due to target bugs.  */", "depth": 0, "reading_ease": 49.86, "reading_grade": 11.6, "line": 9111}, "comment_text": "/* qsort stability here and for cmp2 is only an issue if multiple\n   dynamic relocations are emitted at the same address.  But targets\n   that apply a series of dynamic relocations each operating on the\n   result of the prior relocation can't use -z combreloc as\n   implemented anyway.  Such schemes tend to be broken by sorting on\n   symbol index.  That leaves dynamic NONE relocs as the only other\n   case where ld might emit multiple relocs at the same address, and\n   those are only emitted due to target bugs.  */", "comment_tokens": ["qsort", "stability", "here", "and", "for", "cmp2", "is", "only", "an", "issue", "if", "multiple", "dynamic", "relocations", "are", "emitted", "at", "the", "same", "address", ".", "But", "targets", "that", "apply", "a", "series", "of", "dynamic", "relocations", "each", "operating", "on", "the", "result", "of", "the", "prior", "relocation", "ca", "n't", "use", "-z", "combreloc", "as", "implemented", "anyway", ".", "Such", "schemes", "tend", "to", "be", "broken", "by", "sorting", "on", "symbol", "index", ".", "That", "leaves", "dynamic", "NONE", "relocs", "as", "the", "only", "other", "case", "where", "ld", "might", "emit", "multiple", "relocs", "at", "the", "same", "address", ",", "and", "those", "are", "only", "emitted", "due", "to", "target", "bugs", "."], "ccode": ["\n", "/* qsort stability here and for cmp2 is only an issue if multiple\n", "   dynamic relocations are emitted at the same address.  But targets\n", "   that apply a series of dynamic relocations each operating on the\n", "   result of the prior relocation can't use -z combreloc as\n", "   implemented anyway.  Such schemes tend to be broken by sorting on\n", "   symbol index.  That leaves dynamic NONE relocs as the only other\n", "   case where ld might emit multiple relocs at the same address, and\n", "   those are only emitted due to target bugs.  */\n", "\n", "static int\n", "elf_link_sort_cmp1 (const void *A, const void *B)\n", "{\n", "  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;\n", "  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;\n", "  int relativea, relativeb;\n", "\n", "  relativea = a->type == reloc_class_relative;\n", "  relativeb = b->type == reloc_class_relative;\n", "\n", "  if (relativea < relativeb)\n", "    return 1;\n", "  if (relativea > relativeb)\n", "    return -1;\n", "  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))\n", "    return -1;\n", "  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))\n", "    return 1;\n", "  if (a->rela->r_offset < b->rela->r_offset)\n", "    return -1;\n", "  if (a->rela->r_offset > b->rela->r_offset)\n", "    return 1;\n", "  return 0;\n", "}\n"], "project": "binutils-multiarch-dev", "file": "elflink.pkl", "function": "elf_link_sort_cmp1"}, {"comment_all": {"comment": "/* parse to the end in order to get all SUPPORTED headers */", "depth": 1, "reading_ease": 77.23, "reading_grade": 5.2, "line": 42}, "comment_text": "/* parse to the end in order to get all SUPPORTED headers */", "comment_tokens": ["parse", "to", "the", "end", "in", "order", "to", "get", "all", "SUPPORTED", "headers"], "ccode": ["/*\n", " * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "/*!\n", " * \\file\n", " * \\brief Supported parser\n", " * \\ingroup parser\n", " */\n", "\n", "#include \"../mem/mem.h\"\n", "#include \"parse_supported.h\"\n", "\n", "/*!\n", " * Parse all Supported headers\n", " */\n", "int parse_supported( struct sip_msg *msg)\n", "{\n", "\tunsigned int supported;\n", "\tstruct hdr_field  *hdr;\n", "\tstruct option_tag_body *sb;\n", "\n", "\t/* maybe the header is already parsed! */\n", "\tif (msg->supported && msg->supported->parsed)\n", "\t\treturn 0;\n", "\n", "\t/* parse to the end in order to get all SUPPORTED headers */\n", "\tif (parse_headers(msg,HDR_EOH_F,0)==-1 || !msg->supported)\n", "\t\treturn -1;\n", "\n", "\t/* bad luck! :-( - we have to parse them */\n", "\tsupported = 0;\n", "\tfor( hdr=msg->supported ; hdr ; hdr=next_sibling_hdr(hdr)) {\n", "\t\tif (hdr->parsed) {\n", "\t\t\tsupported |= ((struct option_tag_body*)hdr->parsed)->option_tags;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tsb = (struct option_tag_body*)pkg_malloc(sizeof(struct option_tag_body));\n", "\t\tif (sb == 0) {\n", "\t\t\tPKG_MEM_ERROR;\n", "\t\t\treturn -1;\n", "\t\t}\n", "\n", "\t\tparse_option_tag_body(&(hdr->body), &(sb->option_tags));\n", "\t\tsb->hfree = hf_free_option_tag;\n", "\t\tsb->option_tags_all = 0;\n", "\t\thdr->parsed = (void*)sb;\n", "\t\tsupported |= sb->option_tags;\n", "\t}\n", "\n", "\t((struct option_tag_body*)msg->supported->parsed)->option_tags_all = \n", "\t\tsupported;\n", "\treturn 0;\n", "}\n"], "project": "kamailio-presence-modules", "file": "parse_supported.pkl", "function": "parse_supported"}, {"comment_all": {"comment": "/* -------------------------------------------------------------------\n * NCJ_save\n */", "depth": 0, "reading_ease": 121.22, "reading_grade": -3.5, "line": 323}, "comment_text": "/* -------------------------------------------------------------------\n * NCJ_save\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "NCJ_save"], "ccode": ["\n", "\n", "\n", "\n", "\n", "/* -------------------------------------------------------------------\n", " * NCJ_save\n", " */\n", "int NCJ_save(CAM_SET_DLG *cam_set_dlg)\n", "{\n", "\tFILE *stream;\n", "\tchar FileName[256], str[256];\n", "\n", "\n", "\tGetConfigPath(str);\n", "\tsprintf(FileName, \"%s/NoName.NCJ\", str);\n", "\tif (save_file_name_get(FileName) == -1) {\n", "\t\treturn 0;\n", "\t}\n", "\tif (FileName == NULL) {\n", "\t\treturn 0;\n", "\t}\n", "\t//g_print(\"FileName = %s\\n\", FileName);\n", "\n", "\n", "\tif( (stream\t = fopen( FileName , \"w\" )) == NULL ){\n", "\t\tprintf( _(\"The file could not be opened. [%s]\\n\") ,FileName);\n", "\t\treturn TRUE;\n", "\t}\n", "\n", "\tsprintf(str, \"%d\\n\", cam_set_dlg->AbsInc);\n", "\tfputs(str, stream );\n", "\tsprintf(str, \"%d\\n\", cam_set_dlg->RIJ);\n", "\tfputs(str, stream );\n", "\tsprintf(str, \"%d\\n\", cam_set_dlg->Heel);\n", "\tfputs(str, stream );\n", "\tsprintf(str, \"%d\\n\", cam_set_dlg->Modal);\n", "\tfputs(str, stream );\n", "\n", "\tsprintf(str, \"NC START {\\n\");\n", "\tfputs(str, stream );\n", "\tif (cam_set_dlg->start_str != NULL) {\n", "\t\tfputs(cam_set_dlg->start_str, stream);\n", "\t\tg_free(cam_set_dlg->start_str);\n", "\t\tcam_set_dlg->start_str = NULL;\n", "\t}\n", "\tfputs(\"\\n\", stream );\n", "\tfputs(\"}\\n\", stream );\n", "\n", "\tsprintf(str, \"NC END {\\n\");\n", "\tfputs(str, stream );\n", "\tif (cam_set_dlg->end_str != NULL) {\n", "\t\tfputs(cam_set_dlg->end_str, stream);\n", "\t\tg_free(cam_set_dlg->end_str);\n", "\t\tcam_set_dlg->end_str = NULL;\n", "\t}\n", "\tfputs(\"\\n\", stream );\n", "\tfputs(\"}\\n\", stream );\n", "\n", "\tsprintf(str, \"END\\n\");\n", "\tfputs(str, stream );\n", "\n", "\tfclose(stream);\n", "\tg_print(\"Save As %s\\n\", FileName);\n", "\treturn 1;\n", "}\n"], "project": "sagcad-doc", "file": "CamSetDlg.pkl", "function": "NCJ_save"}, {"comment_all": {"comment": "/* stacked for legibility & locking */", "depth": 1, "reading_ease": 8.2, "reading_grade": 13.1, "line": 1469}, "comment_text": "/* stacked for legibility & locking */", "comment_tokens": ["stacked", "for", "legibility", "&", "locking"], "ccode": ["\n", "int GC_register_my_thread (struct GC_stack_base *sb)\n", "{\n", "    struct start_info si = { 0, }; /* stacked for legibility & locking */\n", "    GC_thread me;\n", "\n", "#   ifdef DEBUG_THREADS\n", "        GC_printf1( \"GC_register_my_thread %p\\n\", &si );\n", "#   endif\n", "\n", "    si.flags = FOREIGN_THREAD;\n", "\n", "    if (!parallel_initialized) GC_init_parallel();\n", "    LOCK();\n", "    if (!GC_thr_initialized) GC_thr_init();\n", "    me = GC_lookup_thread(pthread_self());\n", "    UNLOCK();\n", "    if (me != NULL)\n", "\treturn GC_DUPLICATE;\n", "\n", "    (void)GC_start_routine_head(&si, sb -> mem_base, NULL, NULL);\n", "    return GC_SUCCESS;\n", "}\n"], "project": "libmono-system-runtime4.0-cil", "file": "pthread_support.pkl", "function": "GC_register_my_thread"}, {"comment_all": {"comment": "/* compare_rstats_t - sort by ascending spamicity */", "depth": 0, "reading_ease": -1.29, "reading_grade": 14.7, "line": 113}, "comment_text": "/* compare_rstats_t - sort by ascending spamicity */", "comment_tokens": ["compare_rstats_t", "-", "sort", "by", "ascending", "spamicity"], "ccode": ["\n", "/* compare_rstats_t - sort by ascending spamicity */\n", "\n", "static int compare_rstats_t(const void *const pv1, const void *const pv2)\n", "{\n", "    const rstats_t *r1 = (const rstats_t *)pv1;\n", "    const rstats_t *r2 = (const rstats_t *)pv2;\n", "\n", "    if (r1->prob > r2->prob) return 1;\n", "    if (r2->prob > r1->prob) return -1;\n", "\n", "    return word_cmp(r1->token, r2->token);\n", "}\n"], "project": "bogofilter-bdb", "file": "rstats.pkl", "function": "compare_rstats_t"}, {"comment_all": {"comment": "/* Delete a cJSON structure. */", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 79}, "comment_text": "/* Delete a cJSON structure. */", "comment_tokens": ["Delete", "a", "cJSON", "structure", "."], "ccode": ["\n", "/* Delete a cJSON structure. */\n", "void cJSON_Delete(cJSON *c)\n", "{\n", "\tcJSON *next;\n", "\twhile (c)\n", "\t{\n", "\t\tnext=c->next;\n", "\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n", "\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n", "\t\tif (c->string) cJSON_free(c->string);\n", "\t\tcJSON_free(c);\n", "\t\tc=next;\n", "\t}\n", "}\n"], "project": "nordugrid-arc-acix-core", "file": "cJSON.pkl", "function": "cJSON_Delete"}, {"comment_all": {"comment": "/* same as calling 'ulimit -u' */", "depth": 1, "reading_ease": 83.32, "reading_grade": 2.9, "line": 356}, "comment_text": "/* same as calling 'ulimit -u' */", "comment_tokens": ["same", "as", "calling", "'ulimit", "-u", "'"], "ccode": ["\n", "unsigned long get_os_maxNumOfProc() {\n", "  struct rlimit   rlim;\n", "  unsigned long   max = 0;\n", "  int             rc  = 0;\n", "\n", "  _OSBASE_TRACE(4,(\"--- get_os_maxNumOfProc() called\"));\n", "\n", "  rc = getrlimit(RLIMIT_NPROC, &rlim);  /* same as calling 'ulimit -u' */\n", "  if (rc == 0) { max = rlim.rlim_max; }\n", "\n", "  _OSBASE_TRACE(4,(\"--- get_os_maxNumOfProc() exited : %lu\",max));\n", "  return max;\n", "}\n"], "project": "sblim-cmpi-base", "file": "OSBase_OperatingSystem.pkl", "function": "get_os_maxNumOfProc"}, {"comment_all": {"comment": "/* argstr = all args as a single string */", "depth": 5, "reading_ease": 106.67, "reading_grade": 0.1, "line": 66}, "comment_text": "/* argstr = all args as a single string */", "comment_tokens": ["argstr", "=", "all", "args", "as", "a", "single", "string"], "ccode": ["\n", "int imv_command_exec(struct imv_commands *cmds, const char *command, void *data)\n", "{\n", "  struct list *args = list_from_string(command, ' ');\n", "  int ret = 1;\n", "\n", "  if(args->len > 0) {\n", "    for(size_t i = 0; i < cmds->command_list->len; ++i) {\n", "      struct command *cmd = cmds->command_list->items[i];\n", "      if(!strcmp(cmd->command, args->items[0])) {\n", "        if(cmd->handler) {\n", "          /* argstr = all args as a single string */\n", "          const char *argstr = command + strlen(cmd->command) + 1;\n", "          cmd->handler(args, argstr, data);\n", "          ret = 0;\n", "        } else if(cmd->alias) {\n", "          char *new_args = list_to_string(args, \" \", 1);\n", "          size_t cmd_len = strlen(cmd->alias) + 1 + strlen(new_args) + 1;\n", "          char *new_cmd = malloc(cmd_len);\n", "          snprintf(new_cmd, cmd_len, \"%s %s\", cmd->alias, new_args);\n", "          ret = imv_command_exec(cmds, new_cmd, data);\n", "          free(new_args);\n", "          free(new_cmd);\n", "        }\n", "        break;\n", "      }\n", "    }\n", "  }\n", "\n", "  list_deep_free(args);\n", "  return ret;\n", "}\n"], "project": "imv", "file": "commands.pkl", "function": "imv_command_exec"}, {"comment_all": {"comment": "/* every once in awhile, check to see if the move is done.\n * if so, delete the dialog */", "depth": 0, "reading_ease": 96.69, "reading_grade": 1.9, "line": 65}, "comment_text": "/* every once in awhile, check to see if the move is done.\n * if so, delete the dialog */", "comment_tokens": ["every", "once", "in", "awhile", ",", "check", "to", "see", "if", "the", "move", "is", "done", ".", "if", "so", ",", "delete", "the", "dialog"], "ccode": ["\n", "/* every once in awhile, check to see if the move is done.\n", " * if so, delete the dialog */\n", "static gboolean\n", "onTimer (gpointer gdata)\n", "{\n", "  struct relocate_dialog_data * data = gdata;\n", "  const int done = data->done;\n", "\n", "  if (done == TR_LOC_ERROR)\n", "    {\n", "      const int flags = GTK_DIALOG_MODAL\n", "                      | GTK_DIALOG_DESTROY_WITH_PARENT;\n", "      GtkWidget * w = gtk_message_dialog_new (GTK_WINDOW (data->message_dialog),\n", "                                              flags,\n", "                                              GTK_MESSAGE_ERROR,\n", "                                              GTK_BUTTONS_CLOSE,\n", "                                              \"%s\",\n", "                                              _(\"Couldn't move torrent\"));\n", "      gtk_dialog_run (GTK_DIALOG (w));\n", "      gtk_widget_destroy (GTK_WIDGET (data->message_dialog));\n", "    }\n", "  else if (done == TR_LOC_DONE)\n", "    {\n", "      if (data->torrent_ids != NULL)\n", "        startMovingNextTorrent (data);\n", "      else\n", "        gtk_widget_destroy (GTK_WIDGET (data->chooser_dialog));\n", "    }\n", "\n", "  return G_SOURCE_CONTINUE;\n", "}\n"], "project": "transmission-gtk", "file": "relocate.pkl", "function": "onTimer"}, {"comment_all": {"comment": "// in degrees\n", "depth": 1, "reading_ease": 77.91, "reading_grade": 2.9, "line": 210}, "comment_text": "// interpreted as range 1 - 10\n// in degrees\n// in degrees\n// in degrees\n", "comment_tokens": ["interpreted", "as", "range", "1", "-", "10", "in", "degrees", "in", "degrees", "in", "degrees"], "ccode": ["\n", "f0r_instance_t f0r_construct(unsigned int width, unsigned int height)\n", "{\n", "  colorhalftone_instance_t* inst = (colorhalftone_instance_t*)calloc(1, sizeof(*inst));\n", "  inst->width = width; \n", "  inst->height = height;\n", "  inst->dot_radius = 0.4;// interpreted as range 1 - 10\n", "  inst->cyan_angle = 108.0/360.0; // in degrees\n", "  inst->magenta_angle = 162.0/360.0; // in degrees\n", "  inst->yellow_angle = 90.0/360.0; // in degrees\n", "  return (f0r_instance_t)inst;\n", "}\n"], "project": "frei0r-plugins", "file": "colorhalftone.pkl", "function": "f0r_construct"}, {"comment_all": {"comment": "/* 101 Switching Protocols; transition to transparent proxy */", "depth": 3, "reading_ease": 30.53, "reading_grade": 10.7, "line": 933}, "comment_text": "/* 101 Switching Protocols; transition to transparent proxy */", "comment_tokens": ["101", "Switching", "Protocols", ";", "transition", "to", "transparent", "proxy"], "ccode": ["#undef PATCH_GW\n", "#undef PATCH\n", "\n", "static handler_t proxy_response_headers(server *srv, connection *con, struct http_response_opts_t *opts) {\n", "    /* response headers just completed */\n", "    handler_ctx *hctx = (handler_ctx *)opts->pdata;\n", "\n", "    if (con->response.htags & HTTP_HEADER_UPGRADE) {\n", "        if (hctx->conf.header.upgrade && con->http_status == 101) {\n", "            /* 101 Switching Protocols; transition to transparent proxy */\n", "            gw_set_transparent(srv, &hctx->gw);\n", "            http_response_upgrade_read_body_unknown(srv, con);\n", "        }\n", "        else {\n", "            con->response.htags &= ~HTTP_HEADER_UPGRADE;\n", "          #if 0\n", "            /* preserve prior questionable behavior; likely broken behavior\n", "             * anyway if backend thinks connection is being upgraded but client\n", "             * does not receive Connection: upgrade */\n", "            http_header_response_unset(con, HTTP_HEADER_UPGRADE,\n", "                                       CONST_STR_LEN(\"Upgrade\"))\n", "          #endif\n", "        }\n", "    }\n", "\n", "    /* rewrite paths, if needed */\n", "\n", "    if (NULL == hctx->conf.header.urlpaths\n", "        && NULL == hctx->conf.header.hosts_response)\n", "        return HANDLER_GO_ON;\n", "\n", "    if (con->response.htags & HTTP_HEADER_LOCATION) {\n", "        buffer *vb = http_header_response_get(con, HTTP_HEADER_LOCATION, CONST_STR_LEN(\"Location\"));\n", "        if (vb) http_header_remap_uri(vb, 0, &hctx->conf.header, 0);\n", "    }\n", "    if (con->response.htags & HTTP_HEADER_CONTENT_LOCATION) {\n", "        buffer *vb = http_header_response_get(con, HTTP_HEADER_CONTENT_LOCATION, CONST_STR_LEN(\"Content-Location\"));\n", "        if (vb) http_header_remap_uri(vb, 0, &hctx->conf.header, 0);\n", "    }\n", "    if (con->response.htags & HTTP_HEADER_SET_COOKIE) {\n", "        buffer *vb = http_header_response_get(con, HTTP_HEADER_SET_COOKIE, CONST_STR_LEN(\"Set-Cookie\"));\n", "        if (vb) http_header_remap_setcookie(vb, 0, &hctx->conf.header);\n", "    }\n", "\n", "    return HANDLER_GO_ON;\n", "}\n"], "project": "lighttpd-mod-authn-gssapi", "file": "mod_proxy.pkl", "function": "proxy_response_headers"}, {"comment_all": {"comment": "/* decode final pixels based on trailing zero bytes */", "depth": 1, "reading_ease": 63.36, "reading_grade": 6.4, "line": 783}, "comment_text": "/* decode final pixels based on trailing zero bytes */", "comment_tokens": ["decode", "final", "pixels", "based", "on", "trailing", "zero", "bytes"], "ccode": ["\n", "/*\n", " * Helper routine for processing SDNORM/SDRST marker segment\n", " * (which is found in s->buffer[0..1])\n", " */\n", "static int finish_sde(struct jbg85_dec_state *s)\n", "{\n", "  /* decode final pixels based on trailing zero bytes */\n", "  s->s.nopadding = 0;\n", "  if (decode_pscd(s, s->buffer, 2) != 2 && s->intr)\n", "    return 1;\n", "  \n", "  /* prepare decoder for next SDE */\n", "  arith_decode_init(&s->s, s->buffer[1] == MARKER_SDNORM);\n", "  s->s.nopadding = s->options & JBG_VLENGTH;\n", "\t\n", "  s->x = 0;\n", "  s->i = 0;\n", "  s->pseudo = 1;\n", "  s->at_moves = 0;\n", "  if (s->buffer[1] == MARKER_SDRST) {\n", "    s->tx = 0;\n", "    s->lntp = 1;\n", "    s->p[0] = 0;\n", "    s->p[1] = -1;\n", "    s->p[2] = -1;\n", "  }\n", "\n", "  return 0;\n", "}\n"], "project": "libjbig-dev", "file": "jbig85.pkl", "function": "finish_sde"}, {"comment_all": {"comment": "/*\n * PAM routines\n *\n * This is here for vsftpd which doesn't seem to run the session stack\n */", "depth": 0, "reading_ease": 81.63, "reading_grade": 5.6, "line": 244}, "comment_text": "/*\n * PAM routines\n *\n * This is here for vsftpd which doesn't seem to run the session stack\n */", "comment_tokens": ["PAM", "routines", "This", "is", "here", "for", "vsftpd", "which", "does", "n't", "seem", "to", "run", "the", "session", "stack"], "ccode": ["\n", "/*\n", " * PAM routines\n", " *\n", " * This is here for vsftpd which doesn't seem to run the session stack\n", " */\n", "int\n", "pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)\n", "{\n", "\treturn _pam_loginuid(pamh, flags, argc, argv);\n", "}\n"], "project": "libpam-modules", "file": "pam_loginuid.pkl", "function": "pam_sm_acct_mgmt"}, {"comment_all": {"comment": "/* make sure the actual header isn't longer than the estimate */", "depth": 1, "reading_ease": 61.33, "reading_grade": 7.2, "line": 2554}, "comment_text": "/* make sure the actual header isn't longer than the estimate */", "comment_tokens": ["make", "sure", "the", "actual", "header", "is", "n't", "longer", "than", "the", "estimate"], "ccode": ["\n", "\n", "\n", "Object _dxfExportBin_FP(Object o, int fd)\n", "{\n", "    int nh = 0;\t\t\t/* number of header bytes */\n", "    int nb = 0;\t\t\t/* number of body blocks */\n", "    HashTable hashTable = NULL;\n", "    Pointer header_base = NULL, header, hp;\n", "    struct f_label *flp;\n", "    uint byteoffset = 0;\n", "    int bodyblk;\n", "    char dataset[64];\n", "\n", "\n", "#if 0 /* broken */\n", "    oneblock = ONEBLK;\n", "#else\n", "    oneblock = HALFK;\n", "#endif\n", "\n", "\n", "    /* construct a fake name.  (the lower level read/write routines have\n", "     *  a filename as the first parm, not a file descriptor.)\n", "     */\n", "    sprintf(dataset, \"socket %x export\", fd);\n", "\n", "    /* count number of blocks (on non-ibmpvs is this 512 bytes, not 64k?)\n", "     */\n", "    hashTable = DXCreateHash(sizeof(struct hashElement), NULL, NULL);\n", "    if (!hashTable)\n", "\tgoto error;\n", "    \n", "    cutoff = 0;   /* all in header, none in body */\n", "    if (size_estimate(o, &nh, &nb, 1, cutoff, hashTable) == ERROR)\n", "\tgoto error;\n", "\n", "    DXDestroyHash(hashTable);\n", "    hashTable = NULL;\n", "\n", "\n", "    DXDebug(\"S\", \"export %s: %d headerbyte, %d bodyblocks, cutoff %d Kb\", \n", "\t  dataset, nh, nb, cutoff);\n", "\n", "    if (_dxfsock_open(dataset, fd) == ERROR)\n", "\tgoto error;\n", "\n", "    if (savecontext() != 0)\n", "\tgoto error;\n", "\n", "    nh += sizeof(struct f_label);\n", "\n", "    header_base = DXAllocate(ROUNDUP_BYTES(nh, oneblock) + ONEK);\n", "    if (!header_base)\n", "\tgoto error;\n", "\n", "    header = (Pointer)ROUNDUP_BYTES(header_base, ONEK);\n", "\n", "    /* use defaults: first element in struct is the key; and no extra\n", "     *  compare function is needed.\n", "     */\n", "    hashTable = DXCreateHash(sizeof(struct hashElement), NULL, NULL);\n", "    if (!hashTable)\n", "\tgoto error;\n", "\n", "    hp = header;\n", "    byteoffset = 0;\n", "\n", "    /* fill in label */\n", "    flp = (struct f_label *)header;\n", "    header = (Pointer)((byte *)header + sizeof(struct f_label));\n", "    byteoffset += sizeof(struct f_label);\n", "\n", "\n", "    /* version number */\n", "    flp->version = DISKVERSION_E;\n", "\n", "    /* cutoff between header and body */\n", "    flp->cutoff = cutoff;\n", "\n", "    /* blocksize */\n", "    flp->blocksize = oneblock;\n", "\n", "    /* number of header bytes */\n", "    flp->headerbytes = nh;\n", "\n", "    /* file type */\n", "    flp->type = DISKTYPE_NORMAL;\n", "\n", "    /* file format */\n", "    flp->format = DISKFORMAT_BIN;\n", "\n", "    /* number of valid bytes in the last block of ?? header or body? */\n", "    /* header for now - although i'm not sure what i'm going to do with it */\n", "    flp->leftover = LEFTOVER_BYTES(nh, oneblock);\n", "\n", "    /* the native byteorder */\n", "    flp->byteorder = MSB_MACHINE;\n", "\n", "\n", "    /* write out object */\n", "    bodyblk = PARTIAL_BLOCKS(nh, oneblock);\n", "\n", "    /* calls _dxffile_write(array bodies > cutoff) directly */\n", "    if (writeout_object(o, dataset, hashTable, &header, &byteoffset, \n", "\t\t                                      &bodyblk, 1) == ERROR)\n", "\tgoto error;\n", "\n", "    DXDebug(\"S\", \"actual bytes: %d, estimated bytes: %d\", byteoffset, nh);\n", "\n", "    /* make sure the actual header isn't longer than the estimate */\n", "    if (PARTIAL_BLOCKS(byteoffset, oneblock) > PARTIAL_BLOCKS(nh, oneblock)) {\n", "\tDXSetError(ERROR_INTERNAL, \"import header estimate too small\");\n", "\tgoto error;\n", "    }\n", "\n", "    /* nothing has been written up to this point */\n", "    if (_dxffile_write(dataset, 0, PARTIAL_BLOCKS(nh, oneblock), hp, 0)\t== ERROR)\n", "\tgoto error;\n", "\n", "\n", "    _dxfsock_close(dataset);\n", "    restorecontext();\n", "    DXFree(header_base);\n", "    DXDestroyHash(hashTable);\n", "    return o;\n", "\n", "  error:\n", "    _dxfsock_close(dataset);\n", "    restorecontext();\n", "    DXFree(header_base);\n", "    DXDestroyHash(hashTable);\n", "    return NULL;\n", "}\n"], "project": "dx", "file": "rwobject.pkl", "function": "_dxfExportBin_FP"}, {"comment_all": {"comment": "//HT enabled if num logical > num physical cores\n", "depth": 2, "reading_ease": 63.36, "reading_grade": 6.4, "line": 728}, "comment_text": "//HT enabled if num logical > num physical cores\n", "comment_tokens": ["HT", "enabled", "if", "num", "logical", ">", "num", "physical", "cores"], "ccode": ["\n", "void print_i7z ()\n", "{\n", "    struct cpu_heirarchy_info chi;\n", "    struct cpu_socket_info socket_0={.max_cpu=0, .socket_num=0, .processor_num={-1,-1,-1,-1,-1,-1,-1,-1}};\n", "    struct cpu_socket_info socket_1={.max_cpu=0, .socket_num=1, .processor_num={-1,-1,-1,-1,-1,-1,-1,-1}};\n", "\n", "    construct_CPU_Heirarchy_info(&chi);\n", "    construct_sibling_list(&chi);\n", "      //print_CPU_Heirarchy(chi);\n", "    construct_socket_information(&chi, &socket_0, &socket_1, socket_0_num, socket_1_num);\n", "\t  //print_socket_information(&socket_0);\n", "\t  //print_socket_information(&socket_1);\n", "\n", "    int printw_offset = (0) * 14;\n", "\n", "    //Make an array size max 8 (to accomdate Nehalem-EXEX -lol) to store the core-num that are candidates for a given socket\n", "    //removing it from here as it is already allocated in the function\n", "    //int *core_list, core_list_size_phy, core_list_size_log;\n", "\n", "    //iterator\n", "    int i;\n", "\n", "    //turbo_mode enabled/disabled flag\n", "    char TURBO_MODE;\n", "\n", "    double cpu_freq_cpuinfo;\n", "\n", "    cpu_freq_cpuinfo = cpufreq_info ();\n", "    //estimate the freq using the estimate_MHz() code that is almost mhz accurate\n", "    cpu_freq_cpuinfo = estimate_MHz ();\n", "\n", "    //Print a slew of information on the ncurses window\n", "    mvprintw (0, 0, \"Cpu speed from cpuinfo %0.2fMhz\\n\", cpu_freq_cpuinfo);\n", "    mvprintw (1, 0, \"True Frequency (without accounting Turbo) %0.0f MHz\\n\",cpu_freq_cpuinfo);\n", "\n", "    //MSR number and hi:low bit of that MSR\n", "    //This msr contains a lot of stuff, per socket wise\n", "    //one can pass any core number and then get in multiplier etc\n", "    int PLATFORM_INFO_MSR = 206;\t//CE 15:8\n", "    int PLATFORM_INFO_MSR_low = 8;\n", "    int PLATFORM_INFO_MSR_high = 15;\n", "\n", "    unsigned long long int old_val_CORE[2][numCPUs_max], new_val_CORE[2][numCPUs_max];\n", "    unsigned long long int old_val_REF[2][numCPUs_max], new_val_REF[2][numCPUs_max];\n", "    unsigned long long int old_val_C3[2][numCPUs_max], new_val_C3[2][numCPUs_max];\n", "    unsigned long long int old_val_C6[2][numCPUs_max], new_val_C6[2][numCPUs_max];\n", "    unsigned long long int old_val_C7[2][numCPUs_max], new_val_C7[2][numCPUs_max];\n", "\n", "    unsigned long long int old_TSC[2][numCPUs_max], new_TSC[2][numCPUs_max];\n", "    long double C0_time[2][numCPUs_max], C1_time[2][numCPUs_max],\n", "    C3_time[2][numCPUs_max], C6_time[2][numCPUs_max], C7_time[2][numCPUs_max];\n", "    double _FREQ[2][numCPUs_max], _MULT[2][numCPUs_max];\n", "    struct timeval tvstart[2][numCPUs_max], tvstop[2][numCPUs_max];\n", "\n", "    struct timespec one_second_sleep;\n", "    one_second_sleep.tv_sec = 0;\n", "    one_second_sleep.tv_nsec = 499999999;\t// 500msec\n", "\n", "\n", "\n", "    //Get turbo mode status by reading msr within turbo_status\n", "    TURBO_MODE = turbo_status ();\n", "\n", "    //Flags and other things about HT.\n", "    int HT_ON;\n", "    char HT_ON_str[30];\n", "\n", "    int kk_1 = 11, kk_2 = 11;\n", "\n", "    //below variables is used to monitor if any cores went offline etc.\n", "    int online_cpus[MAX_PROCESSORS]; //Max 2 x Nehalem-EX with total 32 threads\n", "\n", "    double estimated_mhz=0;\n", "    int socket_num;\n", "\n", "    //below variables stores how many cpus were observed till date for the socket\n", "    int max_observed_cpu_socket1 = 0, max_observed_cpu_socket2 = 0;\n", "\n", "    int k=0;\n", "    for (;;)\n", "    {\n", "        construct_CPU_Heirarchy_info(&chi);\n", "        construct_sibling_list(&chi);\n", "        construct_socket_information(&chi, &socket_0, &socket_1, socket_0_num, socket_1_num);\n", "\n", "        //HT enabled if num logical > num physical cores\n", "        if (chi.HT==1)\n", "        {\n", "            strncpy (HT_ON_str, \"Hyper Threading ON\\0\", 30);\n", "            HT_ON = 1;\n", "        } else {\n", "            strncpy (HT_ON_str, \"Hyper Threading OFF\\0\", 30);\n", "            HT_ON = 0;\n", "        }\n", "\n", "        refresh ();\n", "\n", "        SET_ONLINE_ARRAY_PLUS1(online_cpus)\n", "\n", "        //In the function calls below socket_num is set to the socket to print for\n", "        //printw_offset is the offset gap between the printing of the two sockets\n", "        //kk_1 and kk_2 are the variables that have to be set, i have to use them internally\n", "        //so in future if there are more sockets to be printed, add more kk_*\n", "        socket_num=0;\n", "        printw_offset=0;\n", "        print_i7z_socket(socket_0, printw_offset, PLATFORM_INFO_MSR,  PLATFORM_INFO_MSR_high, PLATFORM_INFO_MSR_low,\n", "                         online_cpus, cpu_freq_cpuinfo, one_second_sleep, TURBO_MODE, HT_ON_str, &kk_1, old_val_CORE[socket_num],\n", "                         old_val_REF[socket_num], old_val_C3[socket_num], old_val_C6[socket_num],old_val_C7[socket_num],\n", "                         old_TSC[socket_num], estimated_mhz, new_val_CORE[socket_num], new_val_REF[socket_num], new_val_C3[socket_num],\n", "                         new_val_C6[socket_num], new_val_C7[socket_num], new_TSC[socket_num], _FREQ[socket_num], _MULT[socket_num], C0_time[socket_num], C1_time[socket_num],\n", "                         C3_time[socket_num], C6_time[socket_num], C7_time[socket_num], tvstart[socket_num], tvstop[socket_num], &max_observed_cpu_socket1);\n", "\n", "        /*\n", "        \t  // TEST CODE FOR CHECKING DUAL SOCK CODE ON SINGLE SOCKET MACHINE\n", "        if(k<30){\n", "            socket_num=0;\n", "            printw_offset=14;\n", "            print_i7z_socket(socket_0, printw_offset, PLATFORM_INFO_MSR,  PLATFORM_INFO_MSR_high, PLATFORM_INFO_MSR_low,\n", "          \t\tonline_cpus, cpu_freq_cpuinfo, one_second_sleep, TURBO_MODE, HT_ON_str, &kk_2,\n", "          \t\told_val_CORE[socket_num], old_val_REF[socket_num], old_val_C3[socket_num], old_val_C6[socket_num],\n", "           \t\told_TSC[socket_num], estimated_mhz, new_val_CORE[socket_num], new_val_REF[socket_num], new_val_C3[socket_num],\n", "          \t\tnew_val_C6[socket_num], new_TSC[socket_num],  _FREQ[socket_num], _MULT[socket_num], C0_time[socket_num], C1_time[socket_num],\n", "          \t\tC3_time[socket_num], C6_time[socket_num], tvstart[socket_num], tvstop[socket_num], &max_observed_cpu_socket2);\n", "        }else{*/\n", "        socket_num=1;\n", "        printw_offset=14;\n", "        print_i7z_socket(socket_1, printw_offset, PLATFORM_INFO_MSR,  PLATFORM_INFO_MSR_high, PLATFORM_INFO_MSR_low,\n", "                         online_cpus, cpu_freq_cpuinfo, one_second_sleep, TURBO_MODE, HT_ON_str, &kk_2,\n", "                         old_val_CORE[socket_num], old_val_REF[socket_num], old_val_C3[socket_num], old_val_C6[socket_num], old_val_C7[socket_num],\n", "                         old_TSC[socket_num], estimated_mhz, new_val_CORE[socket_num], new_val_REF[socket_num], new_val_C3[socket_num],\n", "                         new_val_C6[socket_num], new_val_C7[socket_num], new_TSC[socket_num],  _FREQ[socket_num], _MULT[socket_num], C0_time[socket_num], C1_time[socket_num],\n", "                         C3_time[socket_num], C6_time[socket_num], C7_time[socket_num], tvstart[socket_num], tvstop[socket_num], &max_observed_cpu_socket2);\n", "        //}\n", "        k++;\n", "    }\n", "\n", "\n", "}\n"], "project": "i7z", "file": "i7z_Dual_Socket.pkl", "function": "print_i7z"}, {"comment_all": {"comment": "/* GAIL - The GNOME Accessibility Implementation Library\n * Copyright 2001 Sun Microsystems Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 49.96, "reading_grade": 11.6, "line": 0}, "comment_text": "/* GAIL - The GNOME Accessibility Implementation Library\n * Copyright 2001 Sun Microsystems Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["GAIL", "-", "The", "GNOME", "Accessibility", "Implementation", "Library", "Copyright", "2001", "Sun", "Microsystems", "Inc", ".", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/* GAIL - The GNOME Accessibility Implementation Library\n", " * Copyright 2001 Sun Microsystems Inc.\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "\n", "#include \"gailcanvaswidgetfactory.h\"\n", "#include \"gailcanvaswidget.h\"\n", "\n", "static void gail_canvas_widget_factory_class_init (GailCanvasWidgetFactoryClass *klass);\n", "\n", "static AtkObject * gail_canvas_widget_factory_create_accessible (GObject *obj);\n", "\n", "static GType gail_canvas_widget_factory_get_accessible_type (void);\n", "\n", "G_DEFINE_TYPE (GailCanvasWidgetFactory,\n", "\t       gail_canvas_widget_factory,\n", "\t       ATK_TYPE_OBJECT_FACTORY);\n", "\n", "static void\n", "gail_canvas_widget_factory_init (GailCanvasWidgetFactory *foo)\n", "{\n", "  ;\n", "}\n"], "project": "libgnomecanvas2-0", "file": "gailcanvaswidgetfactory.pkl", "function": "gail_canvas_widget_factory_init"}, {"comment_all": {"comment": "/* ykcrc.c --- Implementation of YubiKey CRC-16 function.\n *\n * Written by Simon Josefsson <simon@josefsson.org>.\n * Copyright (c) 2006-2012 Yubico AB\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *    * Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *\n *    * Redistributions in binary form must reproduce the above\n *      copyright notice, this list of conditions and the following\n *      disclaimer in the documentation and/or other materials provided\n *      with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */", "depth": 0, "reading_ease": 25.22, "reading_grade": 16.9, "line": 0}, "comment_text": "/* ykcrc.c --- Implementation of YubiKey CRC-16 function.\n *\n * Written by Simon Josefsson <simon@josefsson.org>.\n * Copyright (c) 2006-2012 Yubico AB\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *    * Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *\n *    * Redistributions in binary form must reproduce the above\n *      copyright notice, this list of conditions and the following\n *      disclaimer in the documentation and/or other materials provided\n *      with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */", "comment_tokens": ["ykcrc.c", "--", "-", "Implementation", "of", "YubiKey", "CRC-16", "function", ".", "Written", "by", "Simon", "Josefsson", "<", "simon", "@", "josefsson.org", ">", ".", "Copyright", "(", "c", ")", "2006-2012", "Yubico", "AB", "All", "rights", "reserved", ".", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "COPYRIGHT", "HOLDERS", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "COPYRIGHT", "OWNER", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", "."], "ccode": ["/* ykcrc.c --- Implementation of YubiKey CRC-16 function.\n", " *\n", " * Written by Simon Josefsson <simon@josefsson.org>.\n", " * Copyright (c) 2006-2012 Yubico AB\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions are\n", " * met:\n", " *\n", " *    * Redistributions of source code must retain the above copyright\n", " *      notice, this list of conditions and the following disclaimer.\n", " *\n", " *    * Redistributions in binary form must reproduce the above\n", " *      copyright notice, this list of conditions and the following\n", " *      disclaimer in the documentation and/or other materials provided\n", " *      with the distribution.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n", " * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n", " * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n", " * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n", " * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n", " * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n", " * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n", " * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n", " * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n", " * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n", " * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", " *\n", " */\n", "\n", "#include \"yubikey.h\"\n", "\n", "uint16_t\n", "yubikey_crc16 (const uint8_t * buf, size_t buf_size)\n", "{\n", "  uint16_t m_crc = 0xffff;\n", "\n", "  while (buf_size--)\n", "    {\n", "      int i, j;\n", "      m_crc ^= (uint8_t) * buf++ & 0xFF;\n", "      for (i = 0; i < 8; i++)\n", "\t{\n", "\t  j = m_crc & 1;\n", "\t  m_crc >>= 1;\n", "\t  if (j)\n", "\t    m_crc ^= 0x8408;\n", "\t}\n", "    }\n", "\n", "  return m_crc;\n", "}\n"], "project": "libyubikey0", "file": "ykcrc.pkl", "function": "yubikey_crc16"}, {"comment_all": {"comment": "/* Two strcpy's instead of one - this was messing up\n\t\t\t * on modern, 64-bit Linux system due to \"s\" being modified\n\t\t\t * while it is being copied.\n\t\t\t * - E.B.\n\t\t\t */", "depth": 3, "reading_ease": 63.02, "reading_grade": 10.7, "line": 1773}, "comment_text": "/* Two strcpy's instead of one - this was messing up\n\t\t\t * on modern, 64-bit Linux system due to \"s\" being modified\n\t\t\t * while it is being copied.\n\t\t\t * - E.B.\n\t\t\t */", "comment_tokens": ["Two", "strcpy", "'s", "instead", "of", "one", "-", "this", "was", "messing", "up", "on", "modern", ",", "64-bit", "Linux", "system", "due", "to", "``", "s", "''", "being", "modified", "while", "it", "is", "being", "copied", ".", "-", "E.B", "."], "ccode": ["\n", "void Info_RemoveKey (char *s, char *key)\n", "{\n", "\tchar\t*start;\n", "\tchar\tpkey[512];\n", "\tchar\tvalue[512];\n", "\tchar\t*o;\n", "\n", "\tif (strstr (key, \"\\\\\"))\n", "\t{\n", "//\t\tCom_Printf (\"Can't use a key with a \\\\\\n\");\n", "\t\treturn;\n", "\t}\n", "\n", "\twhile (1)\n", "\t{\n", "\t\tstart = s;\n", "\t\tif (*s == '\\\\')\n", "\t\t\ts++;\n", "\t\to = pkey;\n", "\t\twhile (*s != '\\\\')\n", "\t\t{\n", "\t\t\tif (!*s)\n", "\t\t\t\treturn;\n", "\t\t\t*o++ = *s++;\n", "\t\t}\n", "\t\t*o = 0;\n", "\t\ts++;\n", "\n", "\t\to = value;\n", "\t\twhile (*s != '\\\\' && *s)\n", "\t\t{\n", "\t\t\tif (!*s)\n", "\t\t\t\treturn;\n", "\t\t\t*o++ = *s++;\n", "\t\t}\n", "\t\t*o = 0;\n", "\n", "\t\tif (!strcmp (key, pkey) )\n", "\t\t{\n", "\t\t\t/* Two strcpy's instead of one - this was messing up\n", "\t\t\t * on modern, 64-bit Linux system due to \"s\" being modified\n", "\t\t\t * while it is being copied.\n", "\t\t\t * - E.B.\n", "\t\t\t */\n", "\t\t\tstrcpy( value , s );\n", "\t\t\tstrcpy( start , value );\n", "\t\t\treturn;\n", "\t\t}\n", "\n", "\t\tif (!*s)\n", "\t\t\treturn;\n", "\t}\n", "\n", "}\n"], "project": "alien-arena", "file": "q_shared.pkl", "function": "Info_RemoveKey"}, {"comment_all": {"comment": "/* do not allow empty module name or \"?\" to avoid confusing audit trail */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 654}, "comment_text": "/* do not allow empty module name or \"?\" to avoid confusing audit trail */", "comment_tokens": ["do", "not", "allow", "empty", "module", "name", "or", "``", "?", "''", "to", "avoid", "confusing", "audit", "trail"], "ccode": ["\n", "static char *\n", "extract_modulename(const char *mod_path)\n", "{\n", "  const char *p = strrchr (mod_path, '/');\n", "  char *dot, *retval;\n", "\n", "  if (p == NULL)\n", "    p = mod_path;\n", "  else\n", "    p++;\n", "\n", "  if ((retval = _pam_strdup (p)) == NULL)\n", "    return NULL;\n", "\n", "  dot = strrchr (retval, '.');\n", "  if (dot)\n", "    *dot = '\\0';\n", "\n", "  if (*retval == '\\0' || strcmp(retval, \"?\") == 0) {\n", "    /* do not allow empty module name or \"?\" to avoid confusing audit trail */\n", "    _pam_drop(retval);\n", "    return NULL;\n", "  }\n", "\n", "  return retval;\n", "}\n"], "project": "libpam0g-dev", "file": "pam_handlers.pkl", "function": "extract_modulename"}, {"comment_all": {"comment": "/**\n *\n *  subunit C child-side bindings: report on tests being run.\n *  Copyright (C) 2006  Robert Collins <robertc@robertcollins.net>\n *\n *  Licensed under either the Apache License, Version 2.0 or the BSD 3-clause\n *  license at the users choice. A copy of both licenses are available in the\n *  project source as Apache-2.0 and BSD. You may not use this file except in\n *  compliance with one of these two licences.\n *  \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under these licenses is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the license you chose for the specific language governing permissions\n *  and limitations under that license.\n **/", "depth": 0, "reading_ease": 67.45, "reading_grade": 6.9, "line": 0}, "comment_text": "/**\n *\n *  subunit C child-side bindings: report on tests being run.\n *  Copyright (C) 2006  Robert Collins <robertc@robertcollins.net>\n *\n *  Licensed under either the Apache License, Version 2.0 or the BSD 3-clause\n *  license at the users choice. A copy of both licenses are available in the\n *  project source as Apache-2.0 and BSD. You may not use this file except in\n *  compliance with one of these two licences.\n *  \n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under these licenses is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the license you chose for the specific language governing permissions\n *  and limitations under that license.\n **/", "comment_tokens": ["subunit", "C", "child-side", "bindings", ":", "report", "on", "tests", "being", "run", ".", "Copyright", "(", "C", ")", "2006", "Robert", "Collins", "<", "robertc", "@", "robertcollins.net", ">", "Licensed", "under", "either", "the", "Apache", "License", ",", "Version", "2.0", "or", "the", "BSD", "3-clause", "license", "at", "the", "users", "choice", ".", "A", "copy", "of", "both", "licenses", "are", "available", "in", "the", "project", "source", "as", "Apache-2.0", "and", "BSD", ".", "You", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "one", "of", "these", "two", "licences", ".", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing", ",", "software", "distributed", "under", "these", "licenses", "is", "distributed", "on", "an", "``", "AS", "IS", "''", "BASIS", ",", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND", ",", "either", "express", "or", "implied", ".", "See", "the", "license", "you", "chose", "for", "the", "specific", "language", "governing", "permissions", "and", "limitations", "under", "that", "license", "."], "ccode": ["/**\n", " *\n", " *  subunit C child-side bindings: report on tests being run.\n", " *  Copyright (C) 2006  Robert Collins <robertc@robertcollins.net>\n", " *\n", " *  Licensed under either the Apache License, Version 2.0 or the BSD 3-clause\n", " *  license at the users choice. A copy of both licenses are available in the\n", " *  project source as Apache-2.0 and BSD. You may not use this file except in\n", " *  compliance with one of these two licences.\n", " *  \n", " *  Unless required by applicable law or agreed to in writing, software\n", " *  distributed under these licenses is distributed on an \"AS IS\" BASIS,\n", " *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " *  See the license you chose for the specific language governing permissions\n", " *  and limitations under that license.\n", " **/\n", "\n", "#include <stdio.h>\n", "#include <string.h>\n", "#include \"subunit/child.h\"\n", "\n", "/* Write details about a test event. It is the callers responsibility to ensure\n", " * that details are only provided for events the protocol expects details on.\n", " * @event: The event - e.g. 'skip'\n", " * @name: The test name/id.\n", " * @details: The details of the event, may be NULL if no details are present.\n", " */\n", "static void\n", "subunit_send_event(char const * const event, char const * const name,\n", "\t\t   char const * const details)\n", "{\n", "  if (NULL == details) {\n", "    fprintf(stdout, \"%s: %s\\n\", event, name);\n", "  } else {\n", "    fprintf(stdout, \"%s: %s [\\n\", event, name);\n", "    fprintf(stdout, \"%s\", details);\n", "    if (details[strlen(details) - 1] != '\\n')\n", "      fprintf(stdout, \"\\n\");\n", "    fprintf(stdout, \"]\\n\");\n", "  }\n", "  fflush(stdout);\n", "}\n"], "project": "libcppunit-subunit-dev", "file": "child.pkl", "function": "subunit_send_event"}, {"comment_all": {"comment": "/*\n * b1 |= b2\n *   b1 (IN/OUT)\tfirst bitmap\n *   b2 (IN)\t\tsecond bitmap\n */", "depth": 0, "reading_ease": 78.25, "reading_grade": 4.8, "line": 668}, "comment_text": "/*\n * b1 |= b2\n *   b1 (IN/OUT)\tfirst bitmap\n *   b2 (IN)\t\tsecond bitmap\n */", "comment_tokens": ["b1", "|=", "b2", "b1", "(", "INOUT", ")", "first", "bitmap", "b2", "(", "IN", ")", "second", "bitmap"], "ccode": ["\n", "/*\n", " * b1 |= b2\n", " *   b1 (IN/OUT)\tfirst bitmap\n", " *   b2 (IN)\t\tsecond bitmap\n", " */\n", "void\n", "bit_or(bitstr_t *b1, bitstr_t *b2)\n", "{\n", "\tbitoff_t bit;\n", "\n", "\t_assert_bitstr_valid(b1);\n", "\t_assert_bitstr_valid(b2);\n", "\tassert(_bitstr_bits(b1) == _bitstr_bits(b2));\n", "\n", "\tfor (bit = 0; bit < _bitstr_bits(b1); bit += sizeof(bitstr_t)*8)\n", "\t\tb1[_bit_word(bit)] |= b2[_bit_word(bit)];\n", "}\n"], "project": "libpam-slurm", "file": "bitstring.pkl", "function": "bit_or"}, {"comment_all": {"comment": "/* Do an exact lookup first. */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 206}, "comment_text": "/* Do an exact lookup first. */", "comment_tokens": ["Do", "an", "exact", "lookup", "first", "."], "ccode": ["\n", "void *wtable_get(struct wtable *t, const char *key)\n", "{\n", "\tvoid *value;\n", "\tstruct wentry *entry;\n", "\n", "\t/* Do an exact lookup first. */\n", "\tvalue = hash_get(t->finals, key);\n", "\tif (value)\n", "\t\treturn value;\n", "\n", "\t/* Then see if we can find it in the wcache */\n", "\tif (cache_get(t->wcache, key, &value))\n", "\t\treturn value;\n", "\n", "\t/* And then walk the wildcards array. */\n", "\tentry = wildcards_find_entry(t, key, false, NULL);\n", "\tif (entry) {\n", "\t\tcache_set(t->wcache, key, entry->value);\n", "\t\treturn entry->value;\n", "\t}\n", "\n", "\t/* Cache the negative result as well. */\n", "\tcache_set(t->wcache, key, NULL);\n", "\n", "\treturn NULL;\n", "}\n"], "project": "libfiu0", "file": "wtable.pkl", "function": "wtable_get"}, {"comment_all": {"comment": "/* Get a pair of states to examine */", "depth": 2, "reading_ease": 89.75, "reading_grade": 2.5, "line": 2112}, "comment_text": "/* Get a pair of states to examine */", "comment_tokens": ["Get", "a", "pair", "of", "states", "to", "examine"], "ccode": ["\n", "\n", "struct fsm *fsm_minus(struct fsm *net1, struct fsm *net2) {\n", "    int a, b, current_state, current_start, current_final, target_number, b_has_trans, btarget, statecount;\n", "    struct fsm_state *machine_a, *machine_b;\n", "    struct state_arr *point_a, *point_b;\n", "    struct triplethash *th;\n", "    statecount = 0;\n", "\n", "    net1 = fsm_minimize(net1);\n", "    net2 = fsm_minimize(net2);\n", "    \n", "    fsm_merge_sigma(net1, net2);\n", "    \n", "    fsm_count(net1);\n", "    fsm_count(net2);\n", "    \n", "    machine_a = net1->states;\n", "    machine_b = net2->states;\n", "    \n", "    /* new state 0 = {1,1} */\n", "\n", "    int_stack_clear();\n", "    STACK_2_PUSH(1,1);\n", "\n", "    th = triplet_hash_init();\n", "    triplet_hash_insert(th, 1, 1, 0);\n", "\n", "    point_a = init_state_pointers(machine_a);\n", "    point_b = init_state_pointers(machine_b);\n", "\n", "    fsm_state_init(sigma_max(net1->sigma));\n", "\n", "  while (!int_stack_isempty()) {\n", "      statecount++;\n", "      /* Get a pair of states to examine */\n", " \n", "      a = int_stack_pop();\n", "      b = int_stack_pop();\n", "\n", "      current_state = triplet_hash_find(th, a, b, 0);\n", "      a--;\n", "      b--;\n", "    \n", "      if (b == -1) {\n", "          current_start = 0; \n", "          current_final = (point_a+a)->final; \n", "      } else { \n", "          current_start = (a == 0 && b == 0) ? 1 : 0;\n", "          current_final = (((point_a+a)->final == 1) && ((point_b+b)->final == 0)) ? 1 : 0; \n", "      } \n", "      \n", "      fsm_state_set_current_state(current_state, current_final, current_start);\n", "      \n", "      for (machine_a = (point_a+a)->transitions ; machine_a->state_no == a  ; machine_a++) {\n", "          if (machine_a->target == -1) {\n", "              break;\n", "              continue;\n", "          }\n", "          if (b == -1) {\n", "              /* b is dead */\n", "              if ((target_number = triplet_hash_find(th, (machine_a->target)+1, 0, 0)) == -1) {\n", "                  STACK_2_PUSH(0, (machine_a->target)+1);\n", "                  target_number = triplet_hash_insert(th, (machine_a->target)+1, 0, 0);\n", "              }\n", "          } else {\n", "              /* b is alive */\n", "              b_has_trans = 0;\n", "              for (machine_b = (point_b+b)->transitions ; machine_b->state_no == b ; machine_b++) {\n", "                  if (machine_a->in == machine_b->in && machine_a->out == machine_b->out) {\n", "                      b_has_trans = 1;\n", "                      btarget = machine_b->target;\n", "                      break;\n", "                  }\n", "              }\n", "              if (b_has_trans) {\n", "                  if ((target_number = triplet_hash_find(th, (machine_a->target)+1, btarget+1, 0)) == -1) {\n", "                      STACK_2_PUSH(btarget+1, (machine_a->target)+1);\n", "\t\t      target_number = triplet_hash_insert(th, (machine_a->target)+1, (machine_b->target)+1, 0);\n", "                  }\n", "              } else {\n", "                  /* b is dead */\n", "                  if ((target_number = triplet_hash_find(th, (machine_a->target)+1, 0, 0)) == -1) {\n", "                      STACK_2_PUSH(0, (machine_a->target)+1);\n", "\t\t      target_number = triplet_hash_insert(th, (machine_a->target)+1, 0, 0);\n", "                  }\n", "              }\n", "          }\n", "          fsm_state_add_arc(current_state, machine_a->in, machine_a->out, target_number, current_final, current_start);\n", "      }\n", "      fsm_state_end_state();\n", "  }\n", "  \n", "  xxfree(net1->states);\n", "  fsm_state_close(net1);\n", "  xxfree(point_a);\n", "  xxfree(point_b);\n", "  fsm_destroy(net2);\n", "  triplet_hash_free(th);\n", "  return(fsm_minimize(net1));\n", "}\n"], "project": "foma-bin", "file": "constructions.pkl", "function": "fsm_minus"}, {"comment_all": {"comment": "/* Compile with: gcc -g -c -Wall foo-v1.c  */", "depth": 0, "reading_ease": 106.67, "reading_grade": 0.1, "line": 0}, "comment_text": "/* Compile with: gcc -g -c -Wall foo-v1.c  */", "comment_tokens": ["Compile", "with", ":", "gcc", "-g", "-c", "-Wall", "foo-v1.c"], "ccode": ["/* Compile with: gcc -g -c -Wall foo-v1.c  */\n", "\n", "void\n", "to_keep()\n", "{\n", "}\n"], "project": "abigail-tools", "file": "test2-filtered-removed-fns-v1.pkl", "function": "to_keep"}, {"comment_all": {"comment": "/* \n   Stubs for SSL support when no SSL library has been configured\n   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n   MA 02111-1307, USA\n\n*/", "depth": 0, "reading_ease": 57.4, "reading_grade": 10.8, "line": 0}, "comment_text": "/* \n   Stubs for SSL support when no SSL library has been configured\n   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n   MA 02111-1307, USA\n\n*/", "comment_tokens": ["Stubs", "for", "SSL", "support", "when", "no", "SSL", "library", "has", "been", "configured", "Copyright", "(", "C", ")", "2002-2006", ",", "Joe", "Orton", "<", "joe", "@", "manyfish.co.uk", ">", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA"], "ccode": ["/* \n", "   Stubs for SSL support when no SSL library has been configured\n", "   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>\n", "\n", "   This library is free software; you can redistribute it and/or\n", "   modify it under the terms of the GNU Library General Public\n", "   License as published by the Free Software Foundation; either\n", "   version 2 of the License, or (at your option) any later version.\n", "   \n", "   This library is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "   Library General Public License for more details.\n", "\n", "   You should have received a copy of the GNU Library General Public\n", "   License along with this library; if not, write to the Free\n", "   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n", "   MA 02111-1307, USA\n", "\n", "*/\n", "\n", "#include \"config.h\"\n", "\n", "#include <stdlib.h> /* for NULL */\n", "\n", "#include \"ne_ssl.h\"\n", "#include \"ne_session.h\"\n", "\n", "char *ne_ssl_readable_dname(const ne_ssl_dname *dn)\n", "{\n", "    return NULL;\n", "}\n"], "project": "libneon27-gnutls", "file": "ne_stubssl.pkl", "function": "ne_ssl_readable_dname"}, {"comment_all": {"comment": "/*TODO every mech must have its own ctx*/", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 31}, "comment_text": "/*TODO every mech must have its own ctx*/", "comment_tokens": ["TODO", "every", "mech", "must", "have", "its", "own", "ctx"], "ccode": ["\n", "static void io_destroy(glb_ctx *cc, io_handler *io);\n", "static int init_io_content(glb_ctx *cc, io_handler *io);\n", "static int try_connect(glb_ctx *glb_cc, io_handler *io_cc, char *addr,\n", "        int addrtype, int port, struct timeval *timeout);\n", "\n", "canl_ctx canl_create_ctx()\n", "{\n", "    glb_ctx *ctx = NULL;\n", "    int  i;\n", "\n", "    /*create context*/\n", "    ctx = (glb_ctx *) calloc(1, sizeof(*ctx));\n", "    if (!ctx) \n", "        return NULL;\n", "\n", "    for (i = 0; i < sizeof(mechs)/sizeof(mechs[0]); i++)\n", "\tmechs[i]->initialize(ctx); /*TODO every mech must have its own ctx*/\n", "\n", "    return ctx;\n", "}\n"], "project": "libcanl-c-doc", "file": "canl.pkl", "function": "canl_create_ctx"}, {"comment_all": {"comment": "/* GHashTableIter was added in glib 2.16 */", "depth": 1, "reading_ease": 99.23, "reading_grade": 0.9, "line": 166}, "comment_text": "/* GHashTableIter was added in glib 2.16 */", "comment_tokens": ["GHashTableIter", "was", "added", "in", "glib", "2.16"], "ccode": ["\n", "static RESULT\n", "hash_iter (void)\n", "{\n", "#if !defined(GLIB_MAJOR_VERSION) || GLIB_CHECK_VERSION(2, 16, 0)\n", "\tGHashTable *hash = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, NULL);\n", "\tGHashTableIter iter;\n", "\tint i, sum, keys_sum, values_sum;\n", "\tgpointer key, value;\n", "\n", "\tsum = 0;\n", "\tfor (i = 0; i < 1000; i++) {\n", "\t\tsum += i;\n", "\t\tg_hash_table_insert (hash, GUINT_TO_POINTER (i), GUINT_TO_POINTER (i));\n", "\t}\n", "\n", "\tkeys_sum = values_sum = 0;\n", "\tg_hash_table_iter_init (&iter, hash);\n", "\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n", "\t\tif (key != value)\n", "\t\t\treturn FAILED (\"key != value\");\n", "\t\tkeys_sum += GPOINTER_TO_UINT (key);\n", "\t\tvalues_sum += GPOINTER_TO_UINT (value);\n", "\t}\n", "\tif (keys_sum != sum || values_sum != sum)\n", "\t\treturn FAILED (\"Did not find all key-value pairs\");\n", "\tg_hash_table_destroy (hash);\n", "\treturn NULL;\n", "#else\n", "\t/* GHashTableIter was added in glib 2.16 */\n", "\treturn NULL;\n", "#endif\n", "}\n"], "project": "libmono-system-net-http4.0-cil", "file": "hashtable.pkl", "function": "hash_iter"}, {"comment_all": {"comment": "/** Adds the assignments from the array of pointers to the environment\n * string.\n * The array must be terminated by a \\c NULL pointer, just the same as\n * the standard \\c environ array. */", "depth": 0, "reading_ease": 64.2, "reading_grade": 8.2, "line": 4}, "comment_text": "/** Adds the assignments from the array of pointers to the environment\n * string.\n * The array must be terminated by a \\c NULL pointer, just the same as\n * the standard \\c environ array. */", "comment_tokens": ["Adds", "the", "assignments", "from", "the", "array", "of", "pointers", "to", "the", "environment", "string", ".", "The", "array", "must", "be", "terminated", "by", "a", "\\c", "NULL", "pointer", ",", "just", "the", "same", "as", "the", "standard", "\\c", "environ", "array", "."], "ccode": ["#include <string.h>\n", "#include \"str.h\"\n", "#include \"envstr.h\"\n", "\n", "/** Adds the assignments from the array of pointers to the environment\n", " * string.\n", " * The array must be terminated by a \\c NULL pointer, just the same as\n", " * the standard \\c environ array. */\n", "int envstr_from_array(struct str* env, char** array, int overwrite)\n", "{\n", "  while (*array) {\n", "    if (!envstr_put(env, *array, overwrite))\n", "      return 0;\n", "    ++array;\n", "  }\n", "  return 1;\n", "}\n"], "project": "libbg-dev", "file": "env_from_array.pkl", "function": "envstr_from_array"}, {"comment_all": {"comment": "/*\n * avl_unlink_node:\n * Removes the given node.  Does not delete the item at that node.\n * The item of the node may be freed before calling avl_unlink_node.\n * (In other words, it is not referenced by this function.)\n */", "depth": 0, "reading_ease": 79.77, "reading_grade": 4.2, "line": 334}, "comment_text": "/*\n * avl_unlink_node:\n * Removes the given node.  Does not delete the item at that node.\n * The item of the node may be freed before calling avl_unlink_node.\n * (In other words, it is not referenced by this function.)\n */", "comment_tokens": ["avl_unlink_node", ":", "Removes", "the", "given", "node", ".", "Does", "not", "delete", "the", "item", "at", "that", "node", ".", "The", "item", "of", "the", "node", "may", "be", "freed", "before", "calling", "avl_unlink_node", ".", "(", "In", "other", "words", ",", "it", "is", "not", "referenced", "by", "this", "function", ".", ")"], "ccode": ["\n", "/*\n", " * avl_unlink_node:\n", " * Removes the given node.  Does not delete the item at that node.\n", " * The item of the node may be freed before calling avl_unlink_node.\n", " * (In other words, it is not referenced by this function.)\n", " */\n", "void avl_unlink_node(avl_tree_t *avltree, avl_node_t *avlnode) {\n", "\tavl_node_t *parent;\n", "\tavl_node_t **superparent;\n", "\tavl_node_t *subst, *left, *right;\n", "\tavl_node_t *balnode;\n", "\n", "\tif(avlnode->prev)\n", "\t\tavlnode->prev->next = avlnode->next;\n", "\telse\n", "\t\tavltree->head = avlnode->next;\n", "\n", "\tif(avlnode->next)\n", "\t\tavlnode->next->prev = avlnode->prev;\n", "\telse\n", "\t\tavltree->tail = avlnode->prev;\n", "\n", "\tparent = avlnode->parent;\n", "\n", "\tsuperparent = parent\n", "\t\t? avlnode == parent->left ? &parent->left : &parent->right\n", "\t\t: &avltree->top;\n", "\n", "\tleft = avlnode->left;\n", "\tright = avlnode->right;\n", "\tif(!left) {\n", "\t\t*superparent = right;\n", "\t\tif(right)\n", "\t\t\tright->parent = parent;\n", "\t\tbalnode = parent;\n", "\t} else if(!right) {\n", "\t\t*superparent = left;\n", "\t\tleft->parent = parent;\n", "\t\tbalnode = parent;\n", "\t} else {\n", "\t\tsubst = avlnode->prev;\n", "\t\tif(subst == left) {\n", "\t\t\tbalnode = subst;\n", "\t\t} else {\n", "\t\t\tbalnode = subst->parent;\n", "\t\t\tbalnode->right = subst->left;\n", "\t\t\tif(balnode->right)\n", "\t\t\t\tbalnode->right->parent = balnode;\n", "\t\t\tsubst->left = left;\n", "\t\t\tleft->parent = subst;\n", "\t\t}\n", "\t\tsubst->right = right;\n", "\t\tsubst->parent = parent;\n", "\t\tright->parent = subst;\n", "\t\t*superparent = subst;\n", "\t}\n", "\n", "\tavl_rebalance(avltree, balnode);\n", "}\n"], "project": "libavl1", "file": "avl.pkl", "function": "avl_unlink_node"}, {"comment_all": {"comment": "/* Return ASAP if there is enough space left. */", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 200}, "comment_text": "/* Return ASAP if there is enough space left. */", "comment_tokens": ["Return", "ASAP", "if", "there", "is", "enough", "space", "left", "."], "ccode": ["\n", "/* Enlarge the free space at the end of the sds string so that the caller\n", " * is sure that after calling this function can overwrite up to addlen\n", " * bytes after the end of the string, plus one more byte for nul term.\n", " *\n", " * Note: this does not change the *length* of the sds string as returned\n", " * by sdslen(), but only the free buffer space we have. */\n", "sds sdsMakeRoomFor(sds s, size_t addlen) {\n", "    void *sh, *newsh;\n", "    size_t avail = sdsavail(s);\n", "    size_t len, newlen;\n", "    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n", "    int hdrlen;\n", "\n", "    /* Return ASAP if there is enough space left. */\n", "    if (avail >= addlen) return s;\n", "\n", "    len = sdslen(s);\n", "    sh = (char*)s-sdsHdrSize(oldtype);\n", "    newlen = (len+addlen);\n", "    if (newlen < SDS_MAX_PREALLOC)\n", "        newlen *= 2;\n", "    else\n", "        newlen += SDS_MAX_PREALLOC;\n", "\n", "    type = sdsReqType(newlen);\n", "\n", "    /* Don't use type 5: the user is appending to the string and type 5 is\n", "     * not able to remember empty space, so sdsMakeRoomFor() must be called\n", "     * at every appending operation. */\n", "    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n", "\n", "    hdrlen = sdsHdrSize(type);\n", "    if (oldtype==type) {\n", "        newsh = s_realloc(sh, hdrlen+newlen+1);\n", "        if (newsh == NULL) return NULL;\n", "        s = (char*)newsh+hdrlen;\n", "    } else {\n", "        /* Since the header size changes, need to move the string forward,\n", "         * and can't use realloc */\n", "        newsh = s_malloc(hdrlen+newlen+1);\n", "        if (newsh == NULL) return NULL;\n", "        memcpy((char*)newsh+hdrlen, s, len+1);\n", "        s_free(sh);\n", "        s = (char*)newsh+hdrlen;\n", "        s[-1] = type;\n", "        sdssetlen(s, len);\n", "    }\n", "    sdssetalloc(s, newlen);\n", "    return s;\n", "}\n"], "project": "libhiredis0.14", "file": "sds.pkl", "function": "sdsMakeRoomFor"}, {"comment_all": {"comment": "/* No valid compare command! */", "depth": 2, "reading_ease": 75.88, "reading_grade": 3.7, "line": 116}, "comment_text": "/* No valid compare command! */", "comment_tokens": ["No", "valid", "compare", "command", "!"], "ccode": ["\n", "\n", "gboolean compHostWithPattern(HostNode *n, gchar *in, gsize s)\n", "{\n", " gboolean    r = FALSE;\n", " gchar       *pattern = NULL;\n", " gint        i, j, compflags = 0;\n", " COMPCMD     compcmd =  COMPCMD_HOSTNAME;\n", "\n", " if(!in || !n || strlen(in) < 1) return FALSE;\n", "\n", " if(g_str_has_prefix(in, \"~\") == TRUE && strlen(in) >= 2) {\n", "  /* Check if is a valid compare command identifier. */\n", "  for(i=0; compCmds[i].name;i++) {\n", "   if(compCmds[i].c == in[1]) {\n", "    compcmd = compCmds[i].cmd;\n", "    break;\n", "   }\n", "  }\n", "  if(!compCmds[i].name) return FALSE; /* No valid compare command! */\n", "  else pattern = g_strdup(&in[2]);\n", " }\n", " else pattern = g_strdup(in);\n", "\n", " if(!pattern) return FALSE;\n", " g_strchug(pattern);\n", "\n", " switch(compcmd) {\n", " case COMPCMD_UPDATE:\n", " case COMPCMD_PACKAGE: \n", "  {\n", "   GList *p = g_list_first(n->packages);\n", "   while(p) {\n", "    PkgNode *pn = p->data;\n", "    if((compcmd == COMPCMD_UPDATE ? pn->flag & HOST_STATUS_PKGUPDATE : TRUE) &&\n", "       compStrWithPattern(pn->package, pattern, s) == TRUE) {\n", "     r = TRUE;\n", "     break;\n", "    }\n", "   \n", "    p = g_list_next(p);\n", "   }\n", "  }\n", "  break; /* case COMPCMD_UPDATE */\n", " case COMPCMD_ALL:\n", "  r = TRUE;\n", "  break;\n", " case COMPCMD_DISTRIBUTOR:\n", "  r = n->lsb_distributor ? compStrWithPattern(n->lsb_distributor, pattern, s) : FALSE;\n", "  break;\n", " case COMPCMD_CODENAME:\n", "  r = n->lsb_codename ? compStrWithPattern(n->lsb_codename, pattern, s) : FALSE;\n", "  break;\n", " case COMPCMD_GROUP:\n", "  r = compStrWithPattern(n->group, pattern, s);\n", "  break;\n", " case COMPCMD_FLAG:\n", "  compflags=0;\n", "  for(i = 0; i < (strlen(pattern) > s ? s : strlen(pattern)); i++) {\n", "   j=0;\n", "   while(hostFlags[j].code) {\n", "    if(hostFlags[j].code[0] == pattern[i])\n", "     compflags |= hostFlags[j].flag;\n", "    j++;\n", "   }\n", "  }\n", "  if(n->status - (n->status ^ compflags) == compflags) r = TRUE;\n", "  break;\n", "#ifdef FEAT_CLUSTERS\n", " case COMPCMD_CLUSTERS:\n", "  {\n", "   GList *c = n->clusters;\n", "   while(c != NULL) {\n", "    if(compStrWithPattern(c->data, pattern, s) == TRUE) {\n", "\tr = TRUE;\n", "\tbreak;\n", "    }\n", "    c = c->next;\n", "   }\n", "  }\n", "  break;\n", "#endif\n", " case COMPCMD_HOSTNAME:\n", " default:\n", "  r = compStrWithPattern(n->hostname, pattern, s);\n", " } /* switch */\n", "\n", " g_free(pattern);\n", "\n", " return r;\n", "}\n"], "project": "apt-dater", "file": "tag.pkl", "function": "compHostWithPattern"}, {"comment_all": {"comment": "// Print a word in order byte0 byte1 byte2 byte3\n", "depth": 0, "reading_ease": 104.64, "reading_grade": 0.9, "line": 10}, "comment_text": "// Print a word in order byte0 byte1 byte2 byte3\n", "comment_tokens": ["Print", "a", "word", "in", "order", "byte0", "byte1", "byte2", "byte3"], "ccode": ["#include <stdio.h>\n", "#include <stdint.h>\n", "\n", "#include \"util.h\"\n", "\n", "const uint64_t m1  = 0x5555555555555555LL; // binary: 0101...\n", "const uint64_t m2  = 0x3333333333333333LL; // binary: 00110011..\n", "const uint64_t m4  = 0x0f0f0f0f0f0f0f0fLL; // binary:  4 zeros,  4 ones ...\n", "const uint64_t h01 = 0x0101010101010101LL; // the sum of 256 to the power of 0,1,2,3...\n", "\n", "// Print a word in order byte0 byte1 byte2 byte3\n", "void print_word(uint32_t word) {\n", "    for (int byte = 0; byte < 4; byte++)\n", "        printf(\"%02x\",get_byte(word,byte));\n", "}\n"], "project": "aeskeyfind", "file": "util.pkl", "function": "print_word"}, {"comment_all": {"comment": "/** Setup the input buffer state to scan a string. The next call to yylex() will\n * scan from a @e copy of @a str.\n * @param yystr a NUL-terminated string to scan\n * \n * @return the newly allocated buffer state object.\n * @note If you want to scan bytes that may contain NUL values, then use\n *       yy_scan_bytes() instead.\n */", "depth": 0, "reading_ease": 74.9, "reading_grade": 6.1, "line": 3938}, "comment_text": "/** Setup the input buffer state to scan a string. The next call to yylex() will\n * scan from a @e copy of @a str.\n * @param yystr a NUL-terminated string to scan\n * \n * @return the newly allocated buffer state object.\n * @note If you want to scan bytes that may contain NUL values, then use\n *       yy_scan_bytes() instead.\n */", "comment_tokens": ["Setup", "the", "input", "buffer", "state", "to", "scan", "a", "string", ".", "The", "next", "call", "to", "yylex", "(", ")", "will", "scan", "from", "a", "@", "e", "copy", "of", "@", "a", "str", ".", "@", "param", "yystr", "a", "NUL-terminated", "string", "to", "scan", "@", "return", "the", "newly", "allocated", "buffer", "state", "object", ".", "@", "note", "If", "you", "want", "to", "scan", "bytes", "that", "may", "contain", "NUL", "values", ",", "then", "use", "yy_scan_bytes", "(", ")", "instead", "."], "ccode": ["\n", "/** Setup the input buffer state to scan a string. The next call to yylex() will\n", " * scan from a @e copy of @a str.\n", " * @param yystr a NUL-terminated string to scan\n", " * \n", " * @return the newly allocated buffer state object.\n", " * @note If you want to scan bytes that may contain NUL values, then use\n", " *       yy_scan_bytes() instead.\n", " */\n", "YY_BUFFER_STATE yy_scan_string (const char * yystr )\n", "{\n", "    \n", "\treturn yy_scan_bytes( yystr, (int) strlen(yystr) );\n", "}\n"], "project": "linux-azure-5.8-tools-5.8.0-1041", "file": "lexer.lex.pkl", "function": "yy_scan_string"}, {"comment_all": {"comment": "/* daemon/packet.c\n *\n * Entropy key packet handling\n *\n * Copyright 2009 Simtec Electronics\n *\n * For licence terms refer to the COPYING file.\n */", "depth": 0, "reading_ease": 45.76, "reading_grade": 11.1, "line": 0}, "comment_text": "/* daemon/packet.c\n *\n * Entropy key packet handling\n *\n * Copyright 2009 Simtec Electronics\n *\n * For licence terms refer to the COPYING file.\n */", "comment_tokens": ["daemonpacket.c", "Entropy", "key", "packet", "handling", "Copyright", "2009", "Simtec", "Electronics", "For", "licence", "terms", "refer", "to", "the", "COPYING", "file", "."], "ccode": ["/* daemon/packet.c\n", " *\n", " * Entropy key packet handling\n", " *\n", " * Copyright 2009 Simtec Electronics\n", " *\n", " * For licence terms refer to the COPYING file.\n", " */\n", "\n", "#include <stdint.h>\n", "#include <stdbool.h>\n", "#include <unistd.h>\n", "#include <stdlib.h>\n", "#include <errno.h>\n", "#include <string.h>\n", "\n", "#include \"pem.h\"\n", "#include \"skeinwrap.h\"\n", "#include \"util.h\"\n", "\n", "#include \"stream.h\"\n", "#include \"frame.h\"\n", "#include \"packet.h\"\n", "\n", "/* exported interface documented in packet.h */\n", "epkt_state_t *\n", "epkt_open(eframe_state_t *frame_state)\n", "{\n", "    epkt_state_t *pkt_state;\n", "\n", "    if (frame_state == NULL)\n", "        return NULL;\n", "\n", "    pkt_state = calloc(1, sizeof(epkt_state_t));\n", "    if (pkt_state == NULL)\n", "        return NULL;\n", "\n", "    pkt_state->frame = frame_state;\n", "\n", "    return pkt_state;\n", "}\n"], "project": "ekeyd-egd-linux", "file": "packet.pkl", "function": "epkt_open"}, {"comment_all": {"comment": "/* fprintf(stderr, \"Parsed entry: var=%s op=%s constraint=%s\\n\", varNameS, opS, constraintS); */", "depth": 2, "reading_ease": 45.42, "reading_grade": 9.2, "line": 415}, "comment_text": "/* fprintf(stderr, \"Parsed entry: var=%s op=%s constraint=%s\\n\", varNameS, opS, constraintS); */", "comment_tokens": ["fprintf", "(", "stderr", ",", "``", "Parsed", "entry", ":", "var=", "%", "s", "op=", "%", "s", "constraint=", "%", "s\\n", "''", ",", "varNameS", ",", "opS", ",", "constraintS", ")", ";"], "ccode": ["\n", "ADIOS_QUERY_TEST_INFO * parseXml(const char *inputxml, ADIOS_FILE* f) {\n", "\tint i, j;\n", "\tFILE * fp = fopen (inputxml,\"r\");\n", "\tif (!fp){\n", "\t\tfprintf(stderr, \"missing xml input file %s \\n\", inputxml);\n", "\t\treturn NULL;\n", "\t}\n", "\tstruct stat s;\n", "\tchar * buffer = NULL;\n", "\tif (stat (inputxml, &s) == 0) {\n", "\t\tbuffer = malloc (s.st_size + 1);\n", "\t\tbuffer [s.st_size] = 0;\n", "\t}\n", "\n", "\tif (buffer)     {\n", "\t\tsize_t bytes_read = fread (buffer, 1, s.st_size, fp);\n", "\n", "\t\tif (bytes_read != s.st_size) {\n", "\t\t\tfprintf(stderr, \"error reading input xml file: %s. Expected %lld Got %lld\\n\"\n", "\t\t\t\t\t,inputxml, (long long int) s.st_size, (long long int)bytes_read );\n", "\t\t\tfclose(fp);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t}\n", "\tfclose (fp);\n", "\tmxml_node_t * root = NULL;\n", "\troot = mxmlLoadString (NULL, buffer, MXML_TEXT_CALLBACK);\n", "\tfree (buffer);\n", "\tbuffer = NULL;\n", "\n", "\tif (!root) {\n", "\t\tfprintf(stderr,  \"unknown error parsing XML (probably structural)\\n\"\n", "\t\t\t\t\"Did you remember to start the file with\\n\"\n", "\t\t\t\t\"<?xml version=\\\"1.0\\\"?>\\n\");\n", "\t\treturn NULL;\n", "\t}\n", "\tif (strcasecmp(root->value.element.name, \"query\") != 0) {\n", "\t\troot = mxmlFindElement(root, root, \"query\", NULL, NULL, MXML_DESCEND_FIRST);\n", "\t}\n", "\n", "\tconst char *numVarS=NULL;\n", "\tconst char *fromTimestepS=NULL;\n", "\tconst char *numTimestepsS=NULL;\n", "\tconst char *batchsizeS=NULL;\n", "\n", "\tint numQuery = 0;\n", "\tint fromTimestep = 1;\n", "\tint numTimesteps = 1;\n", "\tuint64_t batchsize= 1;\n", "\tfor (i = 0; i < root->value.element.num_attrs; i++) {\n", "\t\tmxml_attr_t * attr = &root->value.element.attrs [i];\n", "\t\tGET_ATTR2(\"num\",attr,numVarS,\"query\");\n", "\t\tGET_ATTR2(\"from-timestep\",attr,fromTimestepS,\"query\");\n", "\t\tGET_ATTR2(\"num-timesteps\",attr,numTimestepsS,\"query\");\n", "\t\tGET_ATTR2(\"batchsize\",attr,batchsizeS,\"query\");\n", "\t}\n", "\tif ( !numVarS || !strcmp ( numVarS, \"\")) {\n", "\t\tfprintf(stderr, \"missing values for num attribute \\n\");\n", "\t\tmxmlRelease(root);\n", "\t\treturn NULL;\n", "\t}\n", "\telse {\n", "\t\tnumQuery  = atoi(numVarS);\n", "\t\tfromTimestep  = atoi(fromTimestepS);\n", "\t\tnumTimesteps = atoi(numTimestepsS);\n", "\t\tbatchsize = strtoull(batchsizeS, NULL, 10);\n", "\t}\n", "\n", "\tmxml_node_t *outputNode     = NULL;\n", "\tconst char *outputTypeS=NULL, *outputDimS=NULL, *outputStartS=NULL, *outputCountS=NULL, *outputWbIndexS=NULL;\n", "\tint outputDim;\n", "\tint outputWbIndex;\n", "\tint selType;\n", "\tchar** outputCountTokens=NULL;\n", "\tchar** outputStartTokens=NULL;\n", "\tADIOS_SELECTION *outputBox;\n", "\n", "\t// Parse output selection info\n", "\n", "\toutputNode = mxmlFindElement(root, root, \"output\", NULL, NULL, MXML_DESCEND_FIRST);\n", "\tfor (i = 0; i < outputNode->value.element.num_attrs; i++) {\n", "\t\tmxml_attr_t * attr = &outputNode->value.element.attrs [i];\n", "\t\tGET_ATTR2(\"type\",attr,outputTypeS,\"output\");\n", "\t\tif ( strcmp(outputTypeS, \"ADIOS_SELECTION_BOUNDINGBOX\") == 0) {\n", "\t\t\tselType = ADIOS_SELECTION_BOUNDINGBOX;\n", "\t\t\tGET_ATTR2(\"dim\",attr,outputDimS,\"output\");\n", "\t\t\tGET_ATTR2(\"start\",attr,outputStartS,\"output\");\n", "\t\t\tGET_ATTR2(\"count\",attr,outputCountS,\"output\");\n", "\t\t}\n", "\t\telse if ( strcmp(outputTypeS, \"ADIOS_SELECTION_WRITEBLOCK\") == 0) {\n", "\t\t\tselType = ADIOS_SELECTION_WRITEBLOCK;\n", "\t\t\tGET_ATTR2(\"index\",attr,outputWbIndexS,\"selection\");\n", "\t\t}\n", "\t}\n", "\tif ( selType == ADIOS_SELECTION_BOUNDINGBOX ) {\n", "\t\tif ( !outputTypeS || !outputDimS || !outputStartS || !outputCountS || !strcmp (outputTypeS, \"\")|| !strcmp (outputDimS, \"\") || !strcmp (outputStartS, \"\") || !strcmp (outputCountS, \"\") ) {\n", "\t\t\tfprintf(stderr, \"missing values for output attribute \\n\");\n", "\t\t\tmxmlRelease(root);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t\telse {\n", "\t\t\tint specifiedDim = atoi(outputDimS);\n", "\t\t\tif (specifiedDim > MAXDIM) {\n", "\t\t\t\tfprintf(stderr, \"QueryDim exceeds 10, readjust MAXDIM to larger value, exiting...\\n\");\n", "\t\t\t\tabort();\n", "\t\t\t}\n", "\n", "\t\t\ta2s_tokenize_dimensions(outputStartS, &outputStartTokens, &outputDim);\n", "\t\t\ta2s_tokenize_dimensions(outputCountS, &outputCountTokens, &outputDim);\n", "\n", "            if (specifiedDim != outputDim) {\n", "                fprintf(stderr, \"Specified # of dimensions (%d)  \"\n", "                        \"!= number of dimensions (%d) in start/count, exiting...\\n\",\n", "                        specifiedDim, outputDim);\n", "                abort();\n", "            }\n", "\n", "\t\t\t// Allocate arrays to give to the bounding box constructor\n", "\t\t\tuint64_t *outputStart = malloc(outputDim * sizeof(uint64_t));\n", "\t\t\tuint64_t *outputCount = malloc(outputDim * sizeof(uint64_t));\n", "\n", "\t\t\tfor (j = 0; j < outputDim; j ++){\n", "\t\t\t\toutputStart[j] = atoi(outputStartTokens[j]);\n", "\t\t\t\toutputCount[j] = atoi(outputCountTokens[j]);\n", "\t\t\t}\n", "\t\t\t/* a2s_cleanup_dimensions(outputStartTokens, outputDim); */\n", "            /* a2s_cleanup_dimensions(outputCountTokens, outputDim); */\n", "\n", "\t\t\toutputBox = adios_selection_boundingbox(outputDim, outputStart, outputCount);\n", "\n", "\t\t\t/* fprintf(stderr, \"Selected output boundingbox: dim:%d start:\", outputDim); */\n", "\t\t\t/* for (j = 0; j < outputDim; j ++){ */\n", "\t\t\t/* \tfprintf(stderr, \" %d\", outputStart[j]); */\n", "\t\t\t/* } */\n", "\t\t\t/* fprintf(stderr, \"\\t count:\"); */\n", "\t\t\t/* for (j = 0; j < outputDim; j ++){ */\n", "\t\t\t/* \tfprintf(stderr, \" %d\", outputCount[j]); */\n", "\t\t\t/* } */\n", "\t\t\t/* fprintf(stderr, \"\\n\"); */\n", "\n", "\t\t}\n", "\n", "\t}\n", "\telse if( selType == ADIOS_SELECTION_WRITEBLOCK ) {\n", "\n", "\t\tif ( !outputWbIndexS || !strcmp (outputWbIndexS, \"\") ) {\n", "\t\t\tfprintf(stderr, \"missing values for selection attribute \\n\");\n", "\t\t\tmxmlRelease(root);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\t\telse {\n", "\t\t\toutputWbIndex = atoi(outputWbIndexS);\n", "\t\t\toutputBox = adios_selection_writeblock(outputWbIndex);\n", "\n", "\t\t\t/* fprintf(stderr, \"Selected output writeblock: %d\\n\", outputWbIndex); */\n", "\t\t}\n", "\t}\n", "\n", "\n", "\t// Iterate all combine/entry nodes in <query>\n", "\tmxml_node_t *entryNode      = NULL;\n", "\tmxml_node_t *selectionNode  = NULL;\n", "\tconst char *varNameS=NULL, *opS=NULL, *constraintS=NULL;\n", "\tconst char *typeS=NULL, *dimS=NULL, *startS=NULL, *countS=NULL, *wbIndexS=NULL;\n", "\tint entryIter;\n", "\tint queryDim;\n", "\tint wbIndex;\n", "\tADIOS_SELECTION *inputSelection;\n", "\tADIOS_QUERY *q, *q1, *q2, *qc;\n", "\tchar** queryCountTokens=NULL;\n", "\tchar** queryStartTokens=NULL;\n", "\tchar *queryCombineOp=NULL;\n", "\n", "\t// init query stack\n", "\tQueryStack queryStack;\n", "\tqueryStackInit(&queryStack);\n", "\n", "\tentryNode = mxmlFindElement(root, root, \"entry\", NULL, NULL, MXML_DESCEND_FIRST);\n", "\tentryIter = 0;\n", "\tfor ( ; entryNode; entryNode = mxmlWalkNext (entryNode, root, MXML_NO_DESCEND))\n", "    {\n", "        if (entryNode->type != MXML_ELEMENT)\n", "        {\n", "            continue;\n", "        }\n", "\n", "\t\t// check if current node is <combine>\n", "\t\tif ( strcmp(entryNode->value.element.name, \"combine\") == 0 ) {\n", "\t\t\tqueryCombineOp = (&(entryNode->value.element.attrs[0]))->value;\n", "\t\t\t/* fprintf(stderr, \"Found combine op %s\\n\", queryCombineOp); */\n", "\t\t\t// pop up two query and perform the op\n", "\t\t\tif (queryStackSize(&queryStack)<2) {\n", "\t\t\t\tfprintf(stderr, \"Popping with less than 2 queries in query stack, exiting...\\n\");\n", "\t\t\t\tabort();\n", "\t\t\t}\n", "\n", "\t\t\tq1 = queryPop(&queryStack);\n", "\t\t\tq2 = queryPop(&queryStack);\n", "\t\t\tif (strcmp(queryCombineOp, \"AND\") == 0 || strcmp(queryCombineOp, \"and\") == 0) {\n", "\t\t\t\tqc = adios_query_combine(q1, ADIOS_QUERY_OP_AND, q2);\n", "\t\t\t}\n", "\t\t\telse if (strcmp(queryCombineOp, \"OR\") == 0 || strcmp(queryCombineOp, \"or\") == 0) {\n", "\t\t\t\tqc = adios_query_combine(q1, ADIOS_QUERY_OP_OR, q2);\n", "\t\t\t}\n", "\t\t\tqueryPush(&queryStack,qc);\n", "\n", "\t\t\t//adios_query_free(q1);\n", "\t\t\t//adios_query_free(q2);\n", "\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "        if (entryIter >= numQuery)\n", "            break;\n", "\n", "\t\t// Make sure all *S are NULL for verification\n", "\t\tvarNameS=NULL, opS=NULL, constraintS=NULL;\n", "\t\ttypeS=NULL, dimS=NULL, startS=NULL, countS=NULL, wbIndexS=NULL;\n", "\n", "\t\tfor (i = 0; i < entryNode->value.element.num_attrs; i++) {\n", "\t\t\tmxml_attr_t * attr = &entryNode->value.element.attrs [i];\n", "\t\t\tGET_ATTR2(\"var\",attr,varNameS,\"entry\");\n", "\t\t\tGET_ATTR2(\"op\",attr,opS,\"entry\");\n", "\t\t\tGET_ATTR2(\"constraint\",attr,constraintS,\"entry\");\n", "\t\t}\n", "\t\tif ( !varNameS || !opS || !constraintS || !strcmp (varNameS, \"\")|| !strcmp (opS, \"\") || !strcmp (constraintS, \"\") ) {\n", "\t\t\tfprintf(stderr, \"missing values for entry attribute \\n\");\n", "\t\t\tmxmlRelease(root);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\n", "\t\t// Parse selection\n", "\t\tselectionNode = mxmlFindElement(entryNode, entryNode, \"selection\", NULL, NULL, MXML_DESCEND_FIRST);\n", "\n", "                if (selectionNode == NULL) {\n", "                    inputSelection = NULL;\n", "                }\n", "                else {\n", "                    // selection is not NULL\n", "\n", "\t\t        for (i = 0; i < selectionNode->value.element.num_attrs; i++) {\n", "\t\t        \tmxml_attr_t * attr = &selectionNode->value.element.attrs [i];\n", "\t\t        \tGET_ATTR2(\"type\",attr,typeS,\"selection\");\n", "\t\t        \tif ( strcmp(typeS, \"ADIOS_SELECTION_BOUNDINGBOX\") == 0) {\n", "\t\t        \t\tselType = ADIOS_SELECTION_BOUNDINGBOX;\n", "\t\t        \t\tGET_ATTR2(\"dim\",attr,dimS,\"selection\");\n", "\t\t        \t\tGET_ATTR2(\"start\",attr,startS,\"selection\");\n", "\t\t        \t\tGET_ATTR2(\"count\",attr,countS,\"selection\");\n", "\t\t        \t}\n", "\t\t        \telse if ( strcmp(typeS, \"ADIOS_SELECTION_WRITEBLOCK\") == 0) {\n", "\t\t        \t\tselType = ADIOS_SELECTION_WRITEBLOCK;\n", "\t\t        \t\tGET_ATTR2(\"index\",attr,wbIndexS,\"selection\");\n", "\t\t        \t}\n", "\t\t        }\n", "        \t\tif ( selType == ADIOS_SELECTION_BOUNDINGBOX ) {\n", "        \n", "        \t\t\tif ( !typeS || !dimS || !startS || !countS || !strcmp (typeS, \"\")|| !strcmp (dimS, \"\") || !strcmp (startS, \"\") || !strcmp (countS, \"\") ) {\n", "        \t\t\t\tfprintf(stderr, \"missing values for selection attribute \\n\");\n", "        \t\t\t\tmxmlRelease(root);\n", "        \t\t\t\treturn NULL;\n", "        \t\t\t}\n", "        \t\t\telse {\n", "        \t\t        int specifiedDim = atoi(dimS);\n", "        \t\t        if (specifiedDim > MAXDIM) {\n", "        \t\t\t\t    fprintf(stderr, \"QueryDim exceeds 10, readjust MAXDIM to larger value, exiting...\\n\");\n", "        \t\t\t\t\tabort();\n", "        \t\t\t\t}\n", "        \n", "        \t\t\t\ta2s_tokenize_dimensions(startS, &queryStartTokens, &queryDim);\n", "        \t\t\t\ta2s_tokenize_dimensions(countS, &queryCountTokens, &queryDim);\n", "\n", "        \t            if (specifiedDim != outputDim) {\n", "        \t                fprintf(stderr, \"Specified # of dimensions (%d)  \"\n", "        \t                        \"!= number of dimensions (%d) in start/count, exiting...\\n\",\n", "        \t                        specifiedDim, outputDim);\n", "        \t                abort();\n", "        \t            }\n", "\n", "        \t\t\t\t// Allocate arrays to give to the bounding box constructor\n", "        \t\t\t\tuint64_t *queryStart = malloc(queryDim * sizeof(uint64_t));\n", "        \t\t\t\tuint64_t *queryCount = malloc(queryDim * sizeof(uint64_t));\n", "        \n", "        \t\t\t\tfor (j = 0; j < queryDim; j ++){\n", "        \t\t\t\t\tqueryStart[j] = atoi(queryStartTokens[j]);\n", "        \t\t\t\t\tqueryCount[j] = atoi(queryCountTokens[j]);\n", "        \t\t\t\t}\n", "        \t            /* a2s_cleanup_dimensions(outputStartTokens, outputDim); */\n", "        \t            /* a2s_cleanup_dimensions(outputCountTokens, outputDim); */\n", "        \n", "        \t\t\t\tinputSelection = adios_selection_boundingbox(queryDim, queryStart, queryCount);\n", "                                }\n", "        \n", "\t\t\t\t/* fprintf(stderr, \"Selected input bounding box:  dim:%d start:\", queryDim); */\n", "\t\t\t\t/* for (j = 0; j < queryDim; j ++){ */\n", "\t\t\t\t/* \tfprintf(stderr, \" %d\", queryStart[j]); */\n", "\t\t\t\t/* } */\n", "\t\t\t\t/* fprintf(stderr, \"\\t count:\"); */\n", "\t\t\t\t/* for (j = 0; j < queryDim; j ++){ */\n", "\t\t\t\t/* \tfprintf(stderr, \" %d\", queryCount[j]); */\n", "\t\t\t\t/* } */\n", "\t\t\t\t/* fprintf(stderr, \"\\n\"); */\n", "\n", "        \t\t} // end of selType == ADIOS_SELECTION_BOUNDINGBOX\n", "\t\t        else {\n", "\t\t\t        // selType == ADIOS_SELECTION_WRITEBLOCK\n", "                                if ( !wbIndexS || !strcmp (wbIndexS, \"\") ) {\n", "\t\t\t        \tfprintf(stderr, \"missing values for selection attribute \\n\");\n", "\t\t\t        \tmxmlRelease(root);\n", "\t\t\t        \treturn NULL;\n", "\t\t\t        }\n", "\t\t\t        else {\n", "\t\t\t        \twbIndex = atoi(wbIndexS);\n", "                                }\n", "\t\t\t\t\n", "                                inputSelection = adios_selection_writeblock(wbIndex);\n", "                        }\n", "                }// end of selection is not NULL\n", "        \n", "\n", "\t\tif( strcmp(opS, \"<=\") == 0 )\n", "\t                q = adios_query_create(f, inputSelection, varNameS, ADIOS_LTEQ, constraintS);\n", "\t\telse if( strcmp(opS, \"<\") == 0 )\n", "\t\t        q = adios_query_create(f, inputSelection, varNameS, ADIOS_LT, constraintS);\n", "\t\telse if( strcmp(opS, \">=\") == 0 )\n", "\t\t\tq = adios_query_create(f, inputSelection, varNameS, ADIOS_GTEQ, constraintS);\n", "\t\telse if( strcmp(opS, \">\") == 0 )\n", "\t\t\tq = adios_query_create(f, inputSelection, varNameS, ADIOS_GT, constraintS);\n", "\t\telse {\n", "\t\t\tfprintf(stderr, \"Unsupported entry op %s\\n\", opS);\n", "\t\t\treturn NULL;\n", "\t\t}\n", "\n", "\t\tqueryPush(&queryStack,q);\n", "\t\tentryIter++;\n", "\t\t/* fprintf(stderr, \"Parsed entry: var=%s op=%s constraint=%s\\n\", varNameS, opS, constraintS); */\n", "\t}\n", "\n", "\tADIOS_QUERY_TEST_INFO *retval = (ADIOS_QUERY_TEST_INFO *)malloc(sizeof(ADIOS_QUERY_TEST_INFO));\n", "\t*retval = (ADIOS_QUERY_TEST_INFO){\n", "\t\t.query           = queryPop(&queryStack),\n", "\t\t.outputSelection = outputBox,\n", "\t\t.fromStep        = fromTimestep,\n", "\t\t.numSteps        = numTimesteps,\n", "        .batchSize       = batchsize,\n", "        .varName         = varNameS,\n", "\t};\n", "\treturn retval;\n", "}\n"], "project": "libadios-bin", "file": "adios_query_xml_parse.pkl", "function": "parseXml"}, {"comment_all": {"comment": "// #define rand_ex( min, max )   ( (rand() % (max - min)) + min )\n", "depth": 0, "reading_ease": 88.74, "reading_grade": 2.9, "line": 14}, "comment_text": "// #define rand_ex( min, max )   ( (rand() % (max - min)) + min )\n", "comment_tokens": ["#", "define", "rand_ex", "(", "min", ",", "max", ")", "(", "(", "rand", "(", ")", "%", "(", "max", "-", "min", ")", ")", "+", "min", ")"], "ccode": ["// azar.c\n", "// Macro para numeros al azar\n", "// Elige un numero entre min y max\n", "// Tomado de la internet y mejorado por Kronoman\n", "\n", "#ifndef AZAR_C\n", "#define AZAR_C\n", "\n", "#include <stdlib.h>\n", "\n", "#include \"azar.h\"\n", "/*\n", "Esta funcion explota si min - max da 0, sorry, pero la cambie...\n", "*/\n", "// #define rand_ex( min, max )   ( (rand() % (max - min)) + min )\n", "\n", "/* esta funcion es ligeramente mas lenta, pero NO explota... */\n", "int rand_ex(int min, int max)\n", "{\n", "int tmp;\n", "\n", "     if (min - max == 0) return 0 + min; /* evito division por cero */\n", "\n", "     /* correcion nueva, medio lenta, pero para corregir algunos bugs raros\n", "        intercambio min y max si estan al reves */\n", "     if (min > max)\n", "     {\n", "      tmp = min;\n", "      min = max;\n", "      max = tmp;\n", "     }\n", "\n", "     return ( rand() % (max - min) ) + min;\n", "}\n"], "project": "kraptor-data", "file": "azar.pkl", "function": "rand_ex"}, {"comment_all": {"comment": "/* this is the plain old UNIX getopt, with GNU-style extensions. */", "depth": 0, "reading_ease": 95.17, "reading_grade": 2.5, "line": 38}, "comment_text": "/* this is the plain old UNIX getopt, with GNU-style extensions. */\n/* if you're porting some piece of UNIX software, this is all you need. */\n/* this supports GNU-style permution and optional arguments */\n", "comment_tokens": ["this", "is", "the", "plain", "old", "UNIX", "getopt", ",", "with", "GNU-style", "extensions", ".", "if", "you", "'re", "porting", "some", "piece", "of", "UNIX", "software", ",", "this", "is", "all", "you", "need", ".", "this", "supports", "GNU-style", "permution", "and", "optional", "arguments"], "ccode": ["/*\n", " *  my_getopt.c - my re-implementation of getopt.\n", " *  Copyright 1997, 2000, 2001, 2002, Benjamin Sittler\n", " *  $Id: my_getopt.c 1539 2017-06-06 18:27:36Z soci $\n", " *\n", " *  Permission is hereby granted, free of charge, to any person\n", " *  obtaining a copy of this software and associated documentation\n", " *  files (the \"Software\"), to deal in the Software without\n", " *  restriction, including without limitation the rights to use, copy,\n", " *  modify, merge, publish, distribute, sublicense, and/or sell copies\n", " *  of the Software, and to permit persons to whom the Software is\n", " *  furnished to do so, subject to the following conditions:\n", " *\n", " *  The above copyright notice and this permission notice shall be\n", " *  included in all copies or substantial portions of the Software.\n", " *\n", " *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n", " *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n", " *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n", " *  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n", " *  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n", " *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n", " *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n", " *  DEALINGS IN THE SOFTWARE.\n", " */\n", "\n", "#include \"my_getopt.h\"\n", "#include \"unicode.h\"\n", "#include \"error.h\"\n", "#include <sys/types.h>\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <string.h>\n", "\n", "int my_optind = 1, my_optopt = 0;\n", "bool my_opterr = true;\n", "char *my_optarg = NULL;\n", "\n", "/* this is the plain old UNIX getopt, with GNU-style extensions. */\n", "/* if you're porting some piece of UNIX software, this is all you need. */\n", "/* this supports GNU-style permution and optional arguments */\n", "\n", "static int my_getopt(int argc, char *argv[], const char *opts)\n", "{\n", "  static int charind = 0;\n", "  const char *s;\n", "  char mode, colon_mode;\n", "  int off = 0, opt = -1;\n", "\n", "  if (getenv(\"POSIXLY_CORRECT\") != NULL) colon_mode = mode = '+';\n", "  else {\n", "    if ((colon_mode = *opts) == ':') off ++;\n", "    if (((mode = opts[off]) == '+') || (mode == '-')) {\n", "      off++;\n", "      if ((colon_mode != ':') && ((colon_mode = opts[off]) == ':'))\n", "        off ++;\n", "    }\n", "  }\n", "  my_optarg = NULL;\n", "  if (charind != 0) {\n", "    my_optopt = argv[my_optind][charind];\n", "    for (s = opts + off; *s != 0; s++) if (my_optopt == *s) {\n", "      charind++;\n", "      if ((*(++s) == ':') || ((my_optopt == 'W') && (*s == ';'))) {\n", "        if (argv[my_optind][charind] != 0) {\n", "          my_optarg = &(argv[my_optind++][charind]);\n", "          charind = 0;\n", "        } else if (*(++s) != ':') {\n", "          charind = 0;\n", "          if (++my_optind >= argc) {\n", "            if (my_opterr) {fatal_error(\"option '-\");\n", "                            putc(my_optopt, stderr);\n", "                            fputs(\"' requires an argument\", stderr); fatal_error(NULL); }\n", "            opt = (colon_mode == ':') ? ':' : '?';\n", "            goto my_getopt_ok;\n", "          }\n", "          my_optarg = argv[my_optind++];\n", "        }\n", "      }\n", "      opt = my_optopt;\n", "      goto my_getopt_ok;\n", "    }\n", "    if (my_opterr) {fatal_error(\"option '-\");\n", "                    printable_print2((const uint8_t *)argv[my_optind] + charind, stderr, ((my_optopt & 0x80) != 0) ? utf8len((unsigned int)my_optopt) : 1);\n", "                    fputs(\"' not recognized\", stderr); fatal_error(NULL); }\n", "    opt = '?';\n", "    if (argv[my_optind][++charind] == '\\0') {\n", "      my_optind++;\n", "      charind = 0;\n", "    }\n", "  my_getopt_ok:\n", "    if (charind != 0 && argv[my_optind][charind] == 0) {\n", "      my_optind++;\n", "      charind = 0;\n", "    }\n", "  } else if ((my_optind >= argc) ||\n", "             ((argv[my_optind][0] == '-') &&\n", "              (argv[my_optind][1] == '-') &&\n", "              (argv[my_optind][2] == '\\0'))) {\n", "    my_optind++;\n", "    opt = -1;\n", "  } else if ((argv[my_optind][0] != '-') ||\n", "             (argv[my_optind][1] == '\\0')) {\n", "    char *tmp;\n", "    int i, j, k;\n", "\n", "    if (mode == '+') opt = -1;\n", "    else if (mode == '-') {\n", "      my_optarg = argv[my_optind++];\n", "      charind = 0;\n", "      opt = 1;\n", "    } else {\n", "      for (i = j = my_optind; i < argc; i++) if ((argv[i][0] == '-') &&\n", "                                        (argv[i][1] != '\\0')) {\n", "        my_optind = i;\n", "        opt = my_getopt(argc, argv, opts);\n", "        while (i > j) {\n", "          tmp = argv[--i];\n", "          for (k = i; k + 1 < my_optind; k++) argv[k] = argv[k + 1];\n", "          argv[--my_optind] = tmp;\n", "        }\n", "        break;\n", "      }\n", "      if (i == argc) opt = -1;\n", "    }\n", "  } else {\n", "    charind++;\n", "    opt = my_getopt(argc, argv, opts);\n", "  }\n", "  if (my_optind > argc) my_optind = argc;\n", "  return opt;\n", "}\n"], "project": "64tass", "file": "my_getopt.pkl", "function": "my_getopt"}, {"comment_all": {"comment": "// Return whatever given formatter refers to float values\n", "depth": 0, "reading_ease": 37.98, "reading_grade": 10.0, "line": 3392}, "comment_text": "// Return whatever given formatter refers to float values\n", "comment_tokens": ["Return", "whatever", "given", "formatter", "refers", "to", "float", "values"], "ccode": ["\n", "\n", "// Return whatever given formatter refers to float values\n", "cmsBool  _cmsFormatterIsFloat(cmsUInt32Number Type)\n", "{\n", "    return T_FLOAT(Type) ? TRUE : FALSE;\n", "}\n"], "project": "liblcms2-utils", "file": "cmspack.pkl", "function": "_cmsFormatterIsFloat"}, {"comment_all": {"comment": "/***************************************************************************\n *   Copyright (C) 2003 by Danny Kurniawan                                 *\n *   danny_kurniawan@users.sourceforge.net                                 *\n *                                                                         *\n *   Contributors:                                                         *\n *   - Kerry Harris <tomatoe-source@users.sourceforge.net>                 *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *\n ***************************************************************************/", "depth": 0, "reading_ease": 53.51, "reading_grade": 10.2, "line": 0}, "comment_text": "/***************************************************************************\n *   Copyright (C) 2003 by Danny Kurniawan                                 *\n *   danny_kurniawan@users.sourceforge.net                                 *\n *                                                                         *\n *   Contributors:                                                         *\n *   - Kerry Harris <tomatoe-source@users.sourceforge.net>                 *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *\n ***************************************************************************/", "comment_tokens": ["Copyright", "(", "C", ")", "2003", "by", "Danny", "Kurniawan", "danny_kurniawan", "@", "users.sourceforge.net", "Contributors", ":", "-", "Kerry", "Harris", "<", "tomatoe-source", "@", "users.sourceforge.net", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/***************************************************************************\n", " *   Copyright (C) 2003 by Danny Kurniawan                                 *\n", " *   danny_kurniawan@users.sourceforge.net                                 *\n", " *                                                                         *\n", " *   Contributors:                                                         *\n", " *   - Kerry Harris <tomatoe-source@users.sourceforge.net>                 *\n", " *                                                                         *\n", " *   This program is free software; you can redistribute it and/or modify  *\n", " *   it under the terms of the GNU General Public License as published by  *\n", " *   the Free Software Foundation; either version 2 of the License, or     *\n", " *   (at your option) any later version.                                   *\n", " *                                                                         *\n", " *   This program is distributed in the hope that it will be useful,       *\n", " *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n", " *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n", " *   GNU General Public License for more details.                          *\n", " *                                                                         *\n", " *   You should have received a copy of the GNU General Public License     *\n", " *   along with this program; if not, write to the                         *\n", " *   Free Software Foundation, Inc.,                                       *\n", " *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *\n", " ***************************************************************************/\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "\n", "#include \"clonecd.h\"\n", "\n", "\n", "void show_help()\n", "{\n", "\tprintf(\"\\nUsage:\\n\");\n", "\tprintf(\"        ccd2iso <.img filename> <.iso filename>\\n\");\n", "\tprintf(\"        ccd2iso <option>\\n\\n\");\n", "\tprintf(\"option:\\n\");\n", "\tprintf(\"        -?  -h  --help      show this help\\n\");\n", "\tprintf(\"            -v  --version   show version number\\n\\n\");\n", "}\n"], "project": "ccd2iso", "file": "ccd2iso.pkl", "function": "show_help"}, {"comment_all": {"comment": "/* Destroy the stack itself. */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 4138}, "comment_text": "/* Destroy the stack itself. */", "comment_tokens": ["Destroy", "the", "stack", "itself", "."], "ccode": ["\n", "/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "int yylex_destroy  (void)\n", "{\n", "    \n", "    /* Pop the buffer stack, destroying each element. */\n", "\twhile(YY_CURRENT_BUFFER){\n", "\t\tyy_delete_buffer( YY_CURRENT_BUFFER  );\n", "\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n", "\t\tyypop_buffer_state();\n", "\t}\n", "\n", "\t/* Destroy the stack itself. */\n", "\tyyfree((yy_buffer_stack) );\n", "\t(yy_buffer_stack) = NULL;\n", "\n", "    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n", "     * yylex() is called, initialization will occur. */\n", "    yy_init_globals( );\n", "\n", "    return 0;\n", "}\n"], "project": "linux-cloud-tools-5.8.0-53-generic", "file": "lexer.lex.pkl", "function": "yylex_destroy"}, {"comment_all": {"comment": "/************** 'Thermalize' system so that results are not influenced\n    by the initial onditions                              *************/", "depth": 0, "reading_ease": 42.38, "reading_grade": 10.3, "line": 294}, "comment_text": "/************** 'Thermalize' system so that results are not influenced\n    by the initial onditions                              *************/", "comment_tokens": ["'Thermalize", "'", "system", "so", "that", "results", "are", "not", "influenced", "by", "the", "initial", "onditions"], "ccode": ["\n", "\n", "\n", "  /************** 'Thermalize' system so that results are not influenced\n", "    by the initial onditions                              *************/\n", "void thermalize(int block_size, int discard_blocks)\n", "{\n", "  int i, j;\n", "  \n", "  for(i=0; i<discard_blocks; i++)\n", "    for(j=0; j<block_size; j++)\n", "      Single_Cluster_Update();\n", "}\n"], "project": "libsprng2-doc", "file": "wolff.pkl", "function": "thermalize"}, {"comment_all": {"comment": "/* Switch in and out of alternate mode on the fly.  */", "depth": 0, "reading_ease": 95.17, "reading_grade": 2.5, "line": 86}, "comment_text": "/* Switch in and out of alternate mode on the fly.  */", "comment_tokens": ["Switch", "in", "and", "out", "of", "alternate", "mode", "on", "the", "fly", "."], "ccode": ["\n", "/* Switch in and out of alternate mode on the fly.  */\n", "\n", "void\n", "macro_set_alternate (int alternate)\n", "{\n", "  macro_alternate = alternate;\n", "}\n"], "project": "libbinutils-dbg", "file": "macro.pkl", "function": "macro_set_alternate"}, {"comment_all": {"comment": "/* Retrieves a string containing the value type description\n */", "depth": 0, "reading_ease": 46.44, "reading_grade": 8.8, "line": 92}, "comment_text": "/* Retrieves a string containing the value type description\n */", "comment_tokens": ["Retrieves", "a", "string", "containing", "the", "value", "type", "description"], "ccode": ["\n", "/* Retrieves a string containing the value type description\n", " */\n", "const char *libfole_value_type_get_description(\n", "             uint32_t value_type )\n", "{\n", "\tint iterator = 0;\n", "\n", "\twhile( ( libfole_value_types[ iterator ] ).value_type != (uint32_t) -1 )\n", "\t{\n", "\t\tif( ( libfole_value_types[ iterator ] ).value_type == value_type )\n", "\t\t{\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\titerator++;\n", "\t}\n", "\treturn(\n", "\t ( libfole_value_types[ iterator ] ).description );\n", "}\n"], "project": "liblnk1", "file": "libfole_value_type.pkl", "function": "libfole_value_type_get_description"}, {"comment_all": {"comment": "/* fprintf(stderr, \"enabling anisotropic filtering\\n\"); */", "depth": 5, "reading_ease": -76.41, "reading_grade": 24.9, "line": 58}, "comment_text": "/* fprintf(stderr, \"enabling anisotropic filtering\\n\"); */", "comment_tokens": ["fprintf", "(", "stderr", ",", "``", "enabling", "anisotropic", "filtering\\n", "''", ")", ";"], "ccode": ["#include \"video/video.h\"\n", "\n", "void initTexture(Visual *d) {\n", "  GLint min_filter;\n", "  char texname[120];\n", "\n", "  int i, j;\n", "\n", "  switch(getSettingi(\"mipmap_filter\")) {\n", "\tcase NEAREST:\n", "\t\tmin_filter = GL_NEAREST;\n", "\t\tbreak;\n", "\tcase LINEAR:\n", "\t\tmin_filter = GL_LINEAR;\n", "\t\tbreak;\n", "\tcase MIPMAP:\n", "\t\tmin_filter = GL_LINEAR_MIPMAP_NEAREST;\n", "\t\tbreak;\n", "\tcase TRILINEAR:\n", "\t\tmin_filter = GL_LINEAR_MIPMAP_LINEAR;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tmin_filter = GL_LINEAR_MIPMAP_LINEAR;\n", "\t}\n", "\tprintf(\"using min_filter: %d (setting: %d)\\n\", min_filter,\n", "\t\t\t\t getSettingi(\"mipmap_filter\"));\n", "\n", "  checkGLError(\"texture.c initTexture - start\");\n", "  /* todo: move that somewhere else */\n", "  glGenTextures(game_textures, d->textures);\n", "  checkGLError(\"texture.c initTexture - creating textures\");\n", "  for(i = 0; i < n_textures; i++) {\n", "    for( j = 0; j < textures[i].count; j++) {\n", "      glBindTexture(GL_TEXTURE_2D, d->textures[ textures[i].id + j ]);\n", "      /* todo: snprintf would be safer, but win32 doesn't have it */\n", "      if(textures[i].count == 1) {\n", "\t\t\t\tsprintf(texname, \"%s%s\", textures[i].name, TEX_SUFFIX);\n", "      } else {\n", "\t\t\t\tsprintf(texname, \"%s%d%s\", textures[i].name, j, TEX_SUFFIX);\n", "      }\n", "      loadTexture(texname, textures[i].type);\n", "\n", "      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, textures[i].wrap_s);\n", "      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, textures[i].wrap_t);\n", "\n", "      if(getSettingi(\"softwareRendering\")) {\n", "\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n", "\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n", "      } else {\n", "\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n", "\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, min_filter);\n", "\n", "#ifndef GL_TEXTURE_MAX_ANISOTROPY_EXT\n", "#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE\n", "#endif\n", "\n", "#if 0\n", "\t\t\t\tif(renderer.ext_filter_anisotropic) {\n", "\t\t\t\t\t/* fprintf(stderr, \"enabling anisotropic filtering\\n\"); */\n", "\t\t\t\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT,\n", "\t\t\t\t\t\t\t\t\t\t\t\t\ttextures[i].anisotropy);\n", "\t\t\t\t}\n", "#endif\n", "      }\n", "      checkGLError(\"texture.c initTextures\");\n", "    }\n", "  }\n", "}\n"], "project": "gltron", "file": "texture.pkl", "function": "initTexture"}, {"comment_all": {"comment": "/**\n * fma_menu_file_new_profile:\n * @main_window: the #FMAMainWindow main window.\n *\n * Triggers File / New profile item.\n */", "depth": 0, "reading_ease": 6.67, "reading_grade": 13.7, "line": 167}, "comment_text": "/**\n * fma_menu_file_new_profile:\n * @main_window: the #FMAMainWindow main window.\n *\n * Triggers File / New profile item.\n */", "comment_tokens": ["fma_menu_file_new_profile", ":", "@", "main_window", ":", "the", "#", "FMAMainWindow", "main", "window", ".", "Triggers", "File", "New", "profile", "item", "."], "ccode": ["\n", "/**\n", " * fma_menu_file_new_profile:\n", " * @main_window: the #FMAMainWindow main window.\n", " *\n", " * Triggers File / New profile item.\n", " */\n", "void\n", "fma_menu_file_new_profile( FMAMainWindow *main_window )\n", "{\n", "\tFMAObjectAction *action;\n", "\tFMAObjectProfile *profile;\n", "\tFMATreeView *items_view;\n", "\tGList *items;\n", "\n", "\tg_object_get(\n", "\t\t\tG_OBJECT( main_window ),\n", "\t\t\tMAIN_PROP_ITEM, &action,\n", "\t\t\tNULL );\n", "\n", "\tprofile = fma_object_profile_new_with_defaults();\n", "\tfma_object_attach_profile( action, profile );\n", "\n", "\tfma_object_set_label( profile, _( \"New profile\" ));\n", "\tfma_object_set_new_id( profile, action );\n", "\n", "\tfma_object_check_status( profile );\n", "\n", "\titems = g_list_prepend( NULL, profile );\n", "\titems_view = fma_main_window_get_items_view( main_window );\n", "\tfma_tree_ieditable_insert_items( FMA_TREE_IEDITABLE( items_view ), items, NULL );\n", "\tfma_object_free_items( items );\n", "}\n"], "project": "filemanager-actions", "file": "fma-menu-file.pkl", "function": "fma_menu_file_new_profile"}, {"comment_all": {"comment": "/*  result returned is the determinant of a matrix.  In orient2d() only,     */", "depth": 0, "reading_ease": 48.97, "reading_grade": 7.8, "line": 871}, "comment_text": "/*  The last three use exact arithmetic to ensure a correct answer.  The     */\n/*  result returned is the determinant of a matrix.  In orient2d() only,     */\n/*  this determinant is computed adaptively, in the sense that exact         */\n/*  arithmetic is used only to the degree it is needed to ensure that the    */\n/*  returned value has the correct sign.  Hence, orient2d() is usually quite */\n/*  fast, but will run more slowly when the input points are collinear or    */\n/*  nearly so.                                                               */\n", "comment_tokens": ["The", "last", "three", "use", "exact", "arithmetic", "to", "ensure", "a", "correct", "answer", ".", "The", "result", "returned", "is", "the", "determinant", "of", "a", "matrix", ".", "In", "orient2d", "(", ")", "only", ",", "this", "determinant", "is", "computed", "adaptively", ",", "in", "the", "sense", "that", "exact", "arithmetic", "is", "used", "only", "to", "the", "degree", "it", "is", "needed", "to", "ensure", "that", "the", "returned", "value", "has", "the", "correct", "sign", ".", "Hence", ",", "orient2d", "(", ")", "is", "usually", "quite", "fast", ",", "but", "will", "run", "more", "slowly", "when", "the", "input", "points", "are", "collinear", "or", "nearly", "so", "."], "ccode": ["\n", "/*****************************************************************************/\n", "/*                                                                           */\n", "/*  orient2dfast()   Approximate 2D orientation test.  Nonrobust.            */\n", "/*  orient2dexact()   Exact 2D orientation test.  Robust.                    */\n", "/*  orient2dslow()   Another exact 2D orientation test.  Robust.             */\n", "/*  orient2d()   Adaptive exact 2D orientation test.  Robust.                */\n", "/*                                                                           */\n", "/*               Return a positive value if the points pa, pb, and pc occur  */\n", "/*               in counterclockwise order; a negative value if they occur   */\n", "/*               in clockwise order; and zero if they are collinear.  The    */\n", "/*               result is also a rough approximation of twice the signed    */\n", "/*               area of the triangle defined by the three points.           */\n", "/*                                                                           */\n", "/*  Only the first and last routine should be used; the middle two are for   */\n", "/*  timings.                                                                 */\n", "/*                                                                           */\n", "/*  The last three use exact arithmetic to ensure a correct answer.  The     */\n", "/*  result returned is the determinant of a matrix.  In orient2d() only,     */\n", "/*  this determinant is computed adaptively, in the sense that exact         */\n", "/*  arithmetic is used only to the degree it is needed to ensure that the    */\n", "/*  returned value has the correct sign.  Hence, orient2d() is usually quite */\n", "/*  fast, but will run more slowly when the input points are collinear or    */\n", "/*  nearly so.                                                               */\n", "/*                                                                           */\n", "/*****************************************************************************/\n", "\n", "static REAL orient2dadapt(REAL *pa, REAL *pb, REAL *pc, REAL detsum)\n", "{\n", "  INEXACT REAL acx, acy, bcx, bcy;\n", "  REAL acxtail, acytail, bcxtail, bcytail;\n", "  INEXACT REAL detleft, detright;\n", "  REAL detlefttail, detrighttail;\n", "  REAL det, errbound;\n", "  REAL B[4], C1[8], C2[12], D[16];\n", "  INEXACT REAL B3;\n", "  int C1length, C2length, Dlength;\n", "  REAL u[4];\n", "  INEXACT REAL u3;\n", "  INEXACT REAL s1, t1;\n", "  REAL s0, t0;\n", "\n", "  INEXACT REAL bvirt;\n", "  REAL avirt, bround, around;\n", "  INEXACT REAL c;\n", "  INEXACT REAL abig;\n", "  REAL ahi, alo, bhi, blo;\n", "  REAL err1, err2, err3;\n", "  INEXACT REAL _i, _j;\n", "  REAL _0;\n", "\n", "  acx = (REAL) (pa[0] - pc[0]);\n", "  bcx = (REAL) (pb[0] - pc[0]);\n", "  acy = (REAL) (pa[1] - pc[1]);\n", "  bcy = (REAL) (pb[1] - pc[1]);\n", "\n", "  Two_Product(acx, bcy, detleft, detlefttail);\n", "  Two_Product(acy, bcx, detright, detrighttail);\n", "\n", "  Two_Two_Diff(detleft, detlefttail, detright, detrighttail,\n", "               B3, B[2], B[1], B[0]);\n", "  B[3] = B3;\n", "\n", "  det = estimate(4, B);\n", "  errbound = ccwerrboundB * detsum;\n", "  if ((det >= errbound) || (-det >= errbound)) {\n", "    return det;\n", "  }\n", "\n", "  Two_Diff_Tail(pa[0], pc[0], acx, acxtail);\n", "  Two_Diff_Tail(pb[0], pc[0], bcx, bcxtail);\n", "  Two_Diff_Tail(pa[1], pc[1], acy, acytail);\n", "  Two_Diff_Tail(pb[1], pc[1], bcy, bcytail);\n", "\n", "  if ((acxtail == 0.0) && (acytail == 0.0)\n", "      && (bcxtail == 0.0) && (bcytail == 0.0)) {\n", "    return det;\n", "  }\n", "\n", "  errbound = ccwerrboundC * detsum + resulterrbound * Absolute(det);\n", "  det += (acx * bcytail + bcy * acxtail)\n", "       - (acy * bcxtail + bcx * acytail);\n", "  if ((det >= errbound) || (-det >= errbound)) {\n", "    return det;\n", "  }\n", "\n", "  Two_Product(acxtail, bcy, s1, s0);\n", "  Two_Product(acytail, bcx, t1, t0);\n", "  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);\n", "  u[3] = u3;\n", "  C1length = fast_expansion_sum_zeroelim(4, B, 4, u, C1);\n", "\n", "  Two_Product(acx, bcytail, s1, s0);\n", "  Two_Product(acy, bcxtail, t1, t0);\n", "  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);\n", "  u[3] = u3;\n", "  C2length = fast_expansion_sum_zeroelim(C1length, C1, 4, u, C2);\n", "\n", "  Two_Product(acxtail, bcytail, s1, s0);\n", "  Two_Product(acytail, bcxtail, t1, t0);\n", "  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);\n", "  u[3] = u3;\n", "  Dlength = fast_expansion_sum_zeroelim(C2length, C2, 4, u, D);\n", "\n", "  return(D[Dlength - 1]);\n", "}\n"], "project": "pcb-lesstif", "file": "predicates.pkl", "function": "orient2dadapt"}, {"comment_all": {"comment": "/* return whole match */", "depth": 2, "reading_ease": 93.81, "reading_grade": 0.9, "line": 464}, "comment_text": "/* no explicit captures? */\n/* return whole match */\n", "comment_tokens": ["no", "explicit", "captures", "?", "return", "whole", "match"], "ccode": ["\n", "\n", "static int push_captures (MatchState *ms, const char *s, const char *e) {\n", "  int i;\n", "  luaL_checkstack(ms->L, ms->level, \"too many captures\");\n", "  if (ms->level == 0 && s) {  /* no explicit captures? */\n", "    lua_pushlstring(ms->L, s, e-s);  /* return whole match */\n", "    return 1;\n", "  }\n", "  else {  /* return all captures */\n", "    for (i=0; i<ms->level; i++)\n", "      push_onecapture(ms, i);\n", "    return ms->level;  /* number of strings pushed */\n", "  }\n", "}\n"], "project": "liblualib50-dev", "file": "lstrlib.pkl", "function": "push_captures"}, {"comment_all": {"comment": "/* Blank tags for the players */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 45}, "comment_text": "/* Blank tags for the players */", "comment_tokens": ["Blank", "tags", "for", "the", "players"], "ccode": ["/*  This routine prints a hand in PBN format \n", "    Added by Henk Uijterwaal, Feb 1999            */\n", "\n", "#include <stdio.h>\n", "\n", "#include <time.h>\n", "\n", "#include \"tree.h\"\n", "#include \"dealer.h\"\n", "#include \"pbn.h\"\n", "\n", "extern long seed;\n", "extern char* input_file;\n", "\n", "int printpbn (int board, deal d) {\n", "\n", "  /* Symbols for the cards */\n", "  char representation[] = \"23456789TJQKA\";\n", "  /* Mnemonics for vulnerability and dealer */\n", "  char *vulner_name[] = { \"None\",  \"NS\",   \"EW\",    \"All\"  };\n", "  char *dealer_name[] = { \"N\",     \"E\",    \"S\",     \"W\"    };\n", "  /* Who's vulnerable on which boards */\n", "  int board_vul[] = { 0,1,2,3, 1,2,3,0, 2,3,0,1, 3,0,1,2 };\n", "\n", "  /* Local variables */\n", "  time_t timet;\n", "  size_t len;\n", "  char timearray[12];\n", "  int player, suit, rank;\n", "\n", "  /* Suppress verbose output unless we really want it */\n", "  verbose ^= 1;\n", "\n", "  printf (\"[Event \\\"Hand simulated by dealer with file %s, seed %lu\\\"]\\n\",\n", "  input_file, seed);\n", "\n", "  printf (\"[Site \\\"-\\\"]\\n\");\n", "\n", "  /* Today's date */\n", "  timet = time(&timet);\n", "  len = strftime (timearray, 12, \"%Y.%m.%d\", localtime(&timet));\n", "  printf (\"[Date \\\"%s\\\"]\\n\", timearray);\n", "\n", "  printf (\"[Board \\\"%d\\\"]\\n\", board+1);\n", " \n", "  /* Blank tags for the players */ \n", "  printf (\"[West \\\"-\\\"]\\n\");\n", "  printf (\"[North \\\"-\\\"]\\n\");\n", "  printf (\"[East \\\"-\\\"]\\n\");\n", "  printf (\"[South \\\"-\\\"]\\n\");\n", "   \n", "  /* Dealer, rotates unless set by the user */\n", "  if ((maxdealer < 0) || (maxdealer > 3)) { \n", "     printf (\"[Dealer \\\"%s\\\"]\\n\", dealer_name[board%4]);\n", "  } else {\n", "    printf (\"[Dealer \\\"%s\\\"]\\n\", dealer_name[maxdealer]);\n", "  }\n", "  \n", "  /* Vulnerability, rotates unless set by the user */\n", "  if ((maxvuln < 0) || (maxvuln > 3)) {\n", "     printf (\"[Vulnerable \\\"%s\\\"]\\n\", vulner_name[board_vul[board%16]]);\n", "  } else {\n", "     printf (\"[Vulnerable \\\"%s\\\"]\\n\", vulner_name[maxvuln]);\n", "  }\n", "\n", "  /* Print the cards */\n", "  printf (\"[Deal \\\"N:\");\n", "  for (player=COMPASS_NORTH; player<=COMPASS_WEST; player++) {\n", "     for (suit = SUIT_SPADE; suit>= SUIT_CLUB; suit--) {\n", "        for (rank=12; rank >= 0; rank--) {\n", "          if (HAS_CARD(d, player, MAKECARD(suit,rank))) {\n", "              printf (\"%c\", representation[rank]);\n", "           }\n", "        }\n", "        if (suit > SUIT_CLUB) { printf (\".\");}\n", "     }\n", "     if (player < COMPASS_WEST) {printf (\" \");}\n", "  }\n", "  printf (\"\\\"]\\n\");\n", "\n", "  /* Blank tags for declarer etc */\n", "  printf (\"[Declarer \\\"?\\\"]\\n\");\n", "  printf (\"[Contract \\\"?\\\"]\\n\");\n", "  printf (\"[Result \\\"?\\\"]\\n\");\n", "  printf (\"\\n\");\n", "\n", "  return 0;\n", "}\n"], "project": "dealer", "file": "pbn.pkl", "function": "printpbn"}, {"comment_all": {"comment": "/* Generate triangular distribution about 0.\n     * Shift before adding to prevent overflow which would skew the distribution.\n     * Also shift an extra bit for the high pass filter. \n     */", "depth": 1, "reading_ease": 54.18, "reading_grade": 7.9, "line": 100}, "comment_text": "/* Generate triangular distribution about 0.\n     * Shift before adding to prevent overflow which would skew the distribution.\n     * Also shift an extra bit for the high pass filter. \n     */", "comment_tokens": ["Generate", "triangular", "distribution", "about", "0", ".", "Shift", "before", "adding", "to", "prevent", "overflow", "which", "would", "skew", "the", "distribution", ".", "Also", "shift", "an", "extra", "bit", "for", "the", "high", "pass", "filter", "."], "ccode": ["\n", "\n", "/* Multiply by PA_FLOAT_DITHER_SCALE_ to get a float between -2.0 and +1.99999 */\n", "#define PA_FLOAT_DITHER_SCALE_  (1.0f / ((1<<PA_DITHER_BITS_)-1))\n", "static const float const_float_dither_scale_ = PA_FLOAT_DITHER_SCALE_;\n", "\n", "float PaUtil_GenerateFloatTriangularDither( PaUtilTriangularDitherGenerator *state )\n", "{\n", "    PaInt32 current, highPass;\n", "\n", "    /* Generate two random numbers. */\n", "    state->randSeed1 = (state->randSeed1 * 196314165) + 907633515;\n", "    state->randSeed2 = (state->randSeed2 * 196314165) + 907633515;\n", "\n", "    /* Generate triangular distribution about 0.\n", "     * Shift before adding to prevent overflow which would skew the distribution.\n", "     * Also shift an extra bit for the high pass filter. \n", "     */\n", "    current = (((PaInt32)state->randSeed1)>>DITHER_SHIFT_) +\n", "              (((PaInt32)state->randSeed2)>>DITHER_SHIFT_);\n", "\n", "    /* High pass filter to reduce audibility. */\n", "    highPass = current - state->previous;\n", "    state->previous = current;\n", "    return ((float)highPass) * const_float_dither_scale_;\n", "}\n"], "project": "libportaudiocpp0", "file": "pa_dither.pkl", "function": "PaUtil_GenerateFloatTriangularDither"}, {"comment_all": {"comment": "/*just sth != 10, chitchat*/", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 31}, "comment_text": "/*just sth != 10, chitchat*/", "comment_tokens": ["just", "sth", "!", "=", "10", ",", "chitchat"], "ccode": ["static const int nod = sizeof(cdigit)/sizeof(char*);\n", "\n", "void ctoi(char* input)\n", "{\n", "    char result[BUFFER_SIZE];\n", "    int lastunit, lastdigit=0;\n", "    char* tmp;\n", "    int j = 0;\n", "    tmp = input;\n", "    while (*tmp&&*(tmp+1))\n", "    {\n", "        for (int i=0;i<nod;i++)\n", "            if (!strncmp(tmp, cdigit[i], 3))\n", "            {\n", "                if (i==14)      /* synonyms */\n", "                    i=2;\n", "                else if (i==15)\n", "                    i=13;\n", "                result[j]=i;\n", "                goto ok;\n", "            }\n", "        break;\n", "    ok:\n", "        j++;\n", "        tmp+=3;\n", "    }\n", "    result[j]=0; /*just sth != 10, chitchat*/\n", "    int num = j;\n", "    lastunit = 0;\n", "    j=0;\n", "    for (int i=0;i<num;i++)\n", "    {\n", "        if (result[i]==0)\n", "        {\n", "            if (result[i+1]!=10) continue;\n", "            else result[i]=1; /*for \u4e00\u5343\u96f6\u5341, change to \u4e00\u5343\u4e00\u5341, chitchat*/\n", "        }\n", "        if (i==0&&result[0]==10)\n", "        {\n", "            lastunit = 10;\n", "            input[j] = '1';\n", "            j++;\n", "            lastdigit = 0;\n", "        }\n", "        else if (result[i]<10)\n", "        {\n", "            if (lastunit<=10)\n", "            {\n", "                input[j] = '0' + result[i];\n", "                j++;\n", "                lastunit = 0;\n", "            }\n", "            else\n", "                lastdigit = result[i];\n", "        }\n", "        else if (result[i]<13)\n", "        {\n", "            if (lastunit>result[i]+1)\n", "                for (int k=0;k<lastunit-result[i]-1;k++)\n", "                {\n", "                    input[j] = '0';\n", "                    j++;\n", "                }\n", "            if (lastunit)\n", "            {\n", "                input[j] = '0' + lastdigit;\n", "                j++;\n", "            }\n", "            lastunit = result[i];\n", "            lastdigit = 0;\n", "        }\n", "        else if (result[i]==13)\n", "        {\n", "            if (lastunit>=10)\n", "                for (int k=0;k<lastunit-9;k++)\n", "                {\n", "                    input[j] = '0';\n", "                    j++;\n", "                }\n", "            lastunit = 13;\n", "            lastdigit = 0;\n", "        }\n", "    }\n", "    if (lastunit>=10)\n", "    {\n", "        for (int k=0;k<lastunit-9;k++)\n", "        {\n", "            input[j] = '0';\n", "            j++;\n", "        }\n", "        if (lastdigit) input[j-1]='0'+lastdigit;\n", "    }\n", "    if (!j)\n", "        input[j++]='0'; //handle #ctoi x {\u96f6}, chit, 7/10/2000\n", "    input[j] = '\\0';\n", "}\n"], "project": "kbtin", "file": "chinese.pkl", "function": "ctoi"}, {"comment_all": {"comment": "/* now len <= s->n - s->p */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 42}, "comment_text": "/* now len <= s->n - s->p */", "comment_tokens": ["now", "len", "<", "=", "s-", ">", "n", "-", "s-", ">", "p"], "ccode": ["\n", "int buffer_putalign(buffer *s,const char *buf,unsigned int len)\n", "{\n", "  unsigned int n;\n", " \n", "  while (len > (n = s->n - s->p)) {\n", "    byte_copy(s->x + s->p,n,buf); s->p += n; buf += n; len -= n;\n", "    if (buffer_flush(s) == -1) return -1;\n", "  }\n", "  /* now len <= s->n - s->p */\n", "  byte_copy(s->x + s->p,len,buf);\n", "  s->p += len;\n", "  return 0;\n", "}\n"], "project": "freecdb", "file": "buffer_put.pkl", "function": "buffer_putalign"}, {"comment_all": {"comment": "/*\n * The module interface with the rest of lbcd.\n */", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 29}, "comment_text": "/*\n * The module interface with the rest of lbcd.\n */", "comment_tokens": ["The", "module", "interface", "with", "the", "rest", "of", "lbcd", "."], "ccode": ["\n", "\n", "/*\n", " * The module interface with the rest of lbcd.\n", " */\n", "int\n", "lbcd_pop_weight(uint32_t *weight_val, uint32_t *incr_val UNUSED, int timeout,\n", "                const char *portarg UNUSED, struct lbcd_reply *lb UNUSED)\n", "{\n", "    return *weight_val = probe_pop(\"localhost\", timeout);\n", "}\n"], "project": "lbcd", "file": "pop.pkl", "function": "lbcd_pop_weight"}, {"comment_all": {"comment": "// Check if the mechanism is supported by the module\n", "depth": 1, "reading_ease": 62.34, "reading_grade": 6.8, "line": 542}, "comment_text": "// Check if the mechanism is supported by the module\n", "comment_tokens": ["Check", "if", "the", "mechanism", "is", "supported", "by", "the", "module"], "ccode": ["\n", "CK_RV check_generation_mechanism(CK_MECHANISM_PTR m) {\n", "\n", "  CK_ULONG          i;\n", "  CK_BBOOL          supported = CK_FALSE;\n", "  CK_MECHANISM_INFO info;\n", "\n", "  // Check if the mechanism is supported by the module\n", "  for (i = 0; i < sizeof(generation_mechanisms) / sizeof(CK_MECHANISM_TYPE); i++) {\n", "    if (m->mechanism == generation_mechanisms[i]) {\n", "      supported = CK_TRUE;\n", "      break;\n", "    }\n", "  }\n", "  if (supported == CK_FALSE)\n", "    return CKR_MECHANISM_INVALID;\n", "\n", "  // Check if the mechanism is supported by the token\n", "  if (get_token_mechanism_info(m->mechanism, &info) != CKR_OK)\n", "    return CKR_MECHANISM_INVALID;\n", "\n", "  // TODO: also check that parametes make sense if any? And key size is in [min max]\n", "\n", "  return CKR_OK;\n", "\n", "}\n"], "project": "libykpiv1", "file": "mechanisms.pkl", "function": "check_generation_mechanism"}, {"comment_all": {"comment": "/* if */", "depth": 1, "reading_ease": 121.22, "reading_grade": -3.5, "line": 619}, "comment_text": "/* while */\n/* if */\n/* bs2b_cross_feed_s32be() */\n", "comment_tokens": ["while", "if", "bs2b_cross_feed_s32be", "(", ")"], "ccode": ["\n", "void bs2b_cross_feed_s32be( t_bs2bdp bs2bdp, int32_t *sample, int n )\n", "{\n", "\tdouble sample_d[ 2 ];\n", "\n", "\tif( n > 0 )\n", "\t{\n", "\t\twhile( n-- )\n", "\t\t{\n", "\t\t\t#ifndef WORDS_BIGENDIAN\n", "\t\t\tint32swap( ( uint32_t * )sample );\n", "\t\t\tint32swap( ( uint32_t * )( sample + 1 ) );\n", "\t\t\t#endif\n", "\n", "\t\t\tsample_d[ 0 ] = ( double )sample[ 0 ];\n", "\t\t\tsample_d[ 1 ] = ( double )sample[ 1 ];\n", "\n", "\t\t\tcross_feed_d( bs2bdp, sample_d );\n", "\n", "\t\t\t/* Clipping of overloaded samples */\n", "\t\t\tif( sample_d[ 0 ] > MAX_INT32_VALUE ) sample_d[ 0 ] = MAX_INT32_VALUE;\n", "\t\t\tif( sample_d[ 0 ] < MIN_INT32_VALUE ) sample_d[ 0 ] = MIN_INT32_VALUE;\n", "\t\t\tif( sample_d[ 1 ] > MAX_INT32_VALUE ) sample_d[ 1 ] = MAX_INT32_VALUE;\n", "\t\t\tif( sample_d[ 1 ] < MIN_INT32_VALUE ) sample_d[ 1 ] = MIN_INT32_VALUE;\n", "\n", "\t\t\tsample[ 0 ] = ( int32_t )sample_d[ 0 ];\n", "\t\t\tsample[ 1 ] = ( int32_t )sample_d[ 1 ];\n", "\n", "\t\t\t#ifndef WORDS_BIGENDIAN\n", "\t\t\tint32swap( ( uint32_t * )sample );\n", "\t\t\tint32swap( ( uint32_t * )( sample + 1 ) );\n", "\t\t\t#endif\n", "\n", "\t\t\tsample += 2;\n", "\t\t} /* while */\n", "\t} /* if */\n", "} /* bs2b_cross_feed_s32be() */\n"], "project": "libbs2b0", "file": "bs2b.pkl", "function": "bs2b_cross_feed_s32be"}, {"comment_all": {"comment": "/*   This file is part of foma.                                                */", "depth": 0, "reading_ease": 99.23, "reading_grade": 0.9, "line": 3}, "comment_text": "/*   This file is part of foma.                                                */", "comment_tokens": ["This", "file", "is", "part", "of", "foma", "."], "ccode": ["/*   Foma: a finite-state toolkit and library.                                 */\n", "/*   Copyright \u00a9 2008-2015 Mans Hulden                                         */\n", "\n", "/*   This file is part of foma.                                                */\n", "\n", "/*   Licensed under the Apache License, Version 2.0 (the \"License\");           */\n", "/*   you may not use this file except in compliance with the License.          */\n", "/*   You may obtain a copy of the License at                                   */\n", "\n", "/*      http://www.apache.org/licenses/LICENSE-2.0                             */\n", "\n", "/*   Unless required by applicable law or agreed to in writing, software       */\n", "/*   distributed under the License is distributed on an \"AS IS\" BASIS,         */\n", "/*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  */\n", "/*   See the License for the specific language governing permissions and       */\n", "/*   limitations under the License.                                            */\n", "\n", "#include <stdlib.h>\n", "#include \"foma.h\"\n", "\n", "struct fsm *fsm_lower(struct fsm *net) {\n", "    struct fsm_state *fsm;\n", "    int i, prevstate, out;\n", "    fsm = net->states;\n", "    fsm_state_init(sigma_max(net->sigma));\n", "    prevstate = -1;\n", "    for (i = 0; (fsm+i)->state_no != - 1; prevstate = (fsm+i)->state_no, i++) {\n", "        if (prevstate != -1 && prevstate != (fsm+i)->state_no) {\n", "            fsm_state_end_state();\n", "        }\n", "        if (prevstate != (fsm+i)->state_no) {\n", "            fsm_state_set_current_state((fsm+i)->state_no, (fsm+i)->final_state, (fsm+i)->start_state);\n", "        }\n", "        if ((fsm+i)->target != -1) {\n", "            out = ((fsm+i)->out == UNKNOWN) ? IDENTITY : (fsm+i)->out;\n", "            fsm_state_add_arc((fsm+i)->state_no, out, out, (fsm+i)->target, (fsm+i)->final_state, (fsm+i)->start_state);\n", "        }\n", "    }\n", "    fsm_state_end_state();\n", "    xxfree(net->states);\n", "    fsm_state_close(net);\n", "    sigma_cleanup(net,0);\n", "    return(net);\n", "}\n"], "project": "libfoma-dev", "file": "extract.pkl", "function": "fsm_lower"}, {"comment_all": {"comment": "/* Invokes a SCSI READ BUFFER(10) command (SPC). Return of 0 -> success\n * various SG_LIB_CAT_* positive values or -1 -> other errors */", "depth": 0, "reading_ease": 53.37, "reading_grade": 8.2, "line": 1835}, "comment_text": "/* Invokes a SCSI READ BUFFER(10) command (SPC). Return of 0 -> success\n * various SG_LIB_CAT_* positive values or -1 -> other errors */", "comment_tokens": ["Invokes", "a", "SCSI", "READ", "BUFFER", "(", "10", ")", "command", "(", "SPC", ")", ".", "Return", "of", "0", "-", ">", "success", "various", "SG_LIB_CAT_", "positive", "values", "or", "-1", "-", ">", "other", "errors"], "ccode": ["\n", "/* Invokes a SCSI READ BUFFER(10) command (SPC). Return of 0 -> success\n", " * various SG_LIB_CAT_* positive values or -1 -> other errors */\n", "int\n", "sg_ll_read_buffer(int sg_fd, int mode, int buffer_id, int buffer_offset,\n", "                  void * resp, int mx_resp_len, bool noisy, int verbose)\n", "{\n", "    static const char * const cdb_name_s = \"read buffer(10)\";\n", "    int res, k, ret, sense_cat;\n", "    uint8_t rbuf_cdb[READ_BUFFER_CMDLEN] =\n", "        {READ_BUFFER_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n", "    uint8_t sense_b[SENSE_BUFF_LEN];\n", "    struct sg_pt_base * ptvp;\n", "\n", "    rbuf_cdb[1] = (uint8_t)(mode & 0x1f);\n", "    rbuf_cdb[2] = (uint8_t)(buffer_id & 0xff);\n", "    sg_put_unaligned_be24((uint32_t)buffer_offset, rbuf_cdb + 3);\n", "    sg_put_unaligned_be24((uint32_t)mx_resp_len, rbuf_cdb + 6);\n", "    if (verbose) {\n", "        pr2ws(\"    %s cdb: \", cdb_name_s);\n", "        for (k = 0; k < READ_BUFFER_CMDLEN; ++k)\n", "            pr2ws(\"%02x \", rbuf_cdb[k]);\n", "        pr2ws(\"\\n\");\n", "    }\n", "\n", "    if (NULL == ((ptvp = create_pt_obj(cdb_name_s))))\n", "        return -1;\n", "    set_scsi_pt_cdb(ptvp, rbuf_cdb, sizeof(rbuf_cdb));\n", "    set_scsi_pt_sense(ptvp, sense_b, sizeof(sense_b));\n", "    set_scsi_pt_data_in(ptvp, (uint8_t *)resp, mx_resp_len);\n", "    res = do_scsi_pt(ptvp, sg_fd, DEF_PT_TIMEOUT, verbose);\n", "    ret = sg_cmds_process_resp(ptvp, cdb_name_s, res, mx_resp_len, sense_b,\n", "                               noisy, verbose, &sense_cat);\n", "    if (-1 == ret)\n", "        ret = sg_convert_errno(get_scsi_pt_os_err(ptvp));\n", "    else if (-2 == ret) {\n", "        switch (sense_cat) {\n", "        case SG_LIB_CAT_RECOVERED:\n", "        case SG_LIB_CAT_NO_SENSE:\n", "            ret = 0;\n", "            break;\n", "        default:\n", "            ret = sense_cat;\n", "            break;\n", "        }\n", "    } else {\n", "        if ((verbose > 2) && (ret > 0)) {\n", "            pr2ws(\"    %s: response\", cdb_name_s);\n", "            if (3 == verbose) {\n", "                pr2ws(\"%s:\\n\", (ret > 256 ? \", first 256 bytes\" : \"\"));\n", "                hex2stderr((const uint8_t *)resp, (ret > 256 ? 256 : ret),\n", "                           -1);\n", "            } else {\n", "                pr2ws(\":\\n\");\n", "                hex2stderr((const uint8_t *)resp, ret, 0);\n", "            }\n", "        }\n", "        ret = 0;\n", "    }\n", "    destruct_scsi_pt_obj(ptvp);\n", "    return ret;\n", "}\n"], "project": "sg3-utils-udev", "file": "sg_cmds_extra.pkl", "function": "sg_ll_read_buffer"}, {"comment_all": {"comment": "/* don't recreate the criteria menu and entry if they will be the same*/", "depth": 1, "reading_ease": 83.66, "reading_grade": 4.8, "line": 865}, "comment_text": "/* don't recreate the criteria menu and entry if they will be the same*/", "comment_tokens": ["do", "n't", "recreate", "the", "criteria", "menu", "and", "entry", "if", "they", "will", "be", "the", "same"], "ccode": ["\n", "static void\n", "property_option_menu_changed (GtkComboBox *propmenu,\n", "\t\t\t      RBQueryCreator *creator)\n", "{\n", "\tRBQueryCreatorPrivate *priv = QUERY_CREATOR_GET_PRIVATE (creator);\n", "\tGtkWidget *row;\n", "\tGtkWidget *criteria;\n", "\tGtkWidget *entry;\n", "\tconst RBQueryCreatorPropertyOption *prop_option;\n", "\tconst RBQueryCreatorCriteriaOption *criteria_options;\n", "\tguint length;\n", "\tguint old_value;\n", "\tgboolean constrain;\n", "\n", "\tprop_option = &property_options[gtk_combo_box_get_active (propmenu)];\n", "\told_value = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (propmenu), \"prop-menu old-value\"));\n", "\n", "\t/* don't recreate the criteria menu and entry if they will be the same*/\n", "\tif (prop_option->property_type == property_options[old_value].property_type)\n", "\t\treturn;\n", "\n", "\tg_object_set_data (G_OBJECT (propmenu), \"prop-menu old-value\",\n", "\t\t\t   GINT_TO_POINTER (gtk_combo_box_get_active (propmenu)));\n", "\n", "\trow = lookup_row_by_widget (creator, GTK_WIDGET (propmenu));\n", "\n", "\tcriteria = get_box_widget_at_pos (GTK_BOX (row), 1);\n", "\tgtk_container_remove (GTK_CONTAINER (row), criteria);\n", "\n", "\tcriteria_options = prop_option->property_type->criteria_options;\n", "\tlength = prop_option->property_type->num_criteria_options;\n", "\n", "\tcriteria = create_criteria_option_menu (criteria_options, length);\n", "\tgtk_widget_show (criteria);\n", "\tgtk_size_group_add_widget (priv->criteria_size_group, criteria);\n", "\tgtk_box_pack_start (GTK_BOX (row), GTK_WIDGET (criteria), TRUE, TRUE, 0);\n", "\tgtk_box_reorder_child (GTK_BOX (row), criteria, 1);\n", "\n", "\tentry = get_box_widget_at_pos (GTK_BOX (row), 2);\n", "\tgtk_container_remove (GTK_CONTAINER (row), entry);\n", "\tentry = get_entry_for_property (creator, prop_option->strict_val,\n", "\t\t\t\t\t&constrain);\n", "\tgtk_widget_show (entry);\n", "\n", "\tif (constrain)\n", "\t\tgtk_size_group_add_widget (priv->entry_size_group, entry);\n", "\tgtk_box_pack_start (GTK_BOX (row), GTK_WIDGET (entry), TRUE, TRUE, 0);\n", "\tgtk_box_reorder_child (GTK_BOX (row), entry, 2);\n", "}\n"], "project": "rhythmbox-doc", "file": "rb-query-creator.pkl", "function": "property_option_menu_changed"}, {"comment_all": {"comment": "/* Invalidate the cache. We could be smart and walk it,\n\t\t * removing only the positive hits, but it's also more\n\t\t * expensive */", "depth": 2, "reading_ease": 61.33, "reading_grade": 7.2, "line": 352}, "comment_text": "/* Invalidate the cache. We could be smart and walk it,\n\t\t * removing only the positive hits, but it's also more\n\t\t * expensive */", "comment_tokens": ["Invalidate", "the", "cache", ".", "We", "could", "be", "smart", "and", "walk", "it", ",", "removing", "only", "the", "positive", "hits", ",", "but", "it", "'s", "also", "more", "expensive"], "ccode": ["\n", "\n", "bool wtable_del(struct wtable *t, const char *key)\n", "{\n", "\tstruct wentry *entry;\n", "\n", "\tif (is_wildcard(key, strlen(key))) {\n", "\t\tentry = wildcards_find_entry(t, key, true, NULL);\n", "\n", "\t\tif (!entry) {\n", "\t\t\t/* Key not found. */\n", "\t\t\treturn false;\n", "\t\t}\n", "\n", "\t\t/* Mark the entry as free. */\n", "\t\tfree(entry->key);\n", "\t\tentry->key = NULL;\n", "\t\tentry->key_len = 0;\n", "\t\tt->destructor(entry->value);\n", "\t\tentry->value = NULL;\n", "\t\tentry->in_use = false;\n", "\n", "\t\tt->ws_used_count--;\n", "\n", "\t\t/* Shrink if the table is less than 60% occupied. */\n", "\t\tif (t->ws_size > MIN_SIZE &&\n", "\t\t\t\t(float) t->ws_used_count / t->ws_size < 0.6) {\n", "\t\t\tif (!resize_table(t, t->ws_used_count + 3))\n", "\t\t\t\treturn false;\n", "\t\t}\n", "\n", "\t\t/* Invalidate the cache. We could be smart and walk it,\n", "\t\t * removing only the positive hits, but it's also more\n", "\t\t * expensive */\n", "\t\tcache_invalidate(t->wcache);\n", "\n", "\t\treturn true;\n", "\t} else {\n", "\t\treturn hash_del(t->finals, key);\n", "\t}\n", "}\n"], "project": "libfiu-dev", "file": "wtable.pkl", "function": "wtable_del"}, {"comment_all": {"comment": "/* xstrdup.c -- copy a string with out of memory checking\n   Copyright (C) 1990, 1996, 1998, 2001 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */", "depth": 0, "reading_ease": 58.11, "reading_grade": 10.5, "line": 0}, "comment_text": "/* xstrdup.c -- copy a string with out of memory checking\n   Copyright (C) 1990, 1996, 1998, 2001 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */", "comment_tokens": ["xstrdup.c", "--", "copy", "a", "string", "with", "out", "of", "memory", "checking", "Copyright", "(", "C", ")", "1990", ",", "1996", ",", "1998", ",", "2001", "Free", "Software", "Foundation", ",", "Inc", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/* xstrdup.c -- copy a string with out of memory checking\n", "   Copyright (C) 1990, 1996, 1998, 2001 Free Software Foundation, Inc.\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software Foundation,\n", "   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n", "\n", "#if HAVE_CONFIG_H\n", "# include <config.h>\n", "#endif\n", "\n", "#if STDC_HEADERS || HAVE_STRING_H\n", "# include <string.h>\n", "#else\n", "# include <strings.h>\n", "#endif\n", "\n", "#include <sys/types.h>\n", "\n", "#include \"xalloc.h\"\n", "\n", "/* Return a newly allocated copy of STRING.  */\n", "\n", "char *\n", "xstrdup (const char *string)\n", "{\n", "  return strcpy (xmalloc (strlen (string) + 1), string);\n", "}\n"], "project": "heroes", "file": "xstrdup.pkl", "function": "xstrdup"}, {"comment_all": {"comment": "/* Read an expression to evaluate   */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 1884}, "comment_text": "/* Read an expression to evaluate   */", "comment_tokens": ["Read", "an", "expression", "to", "evaluate"], "ccode": ["\n", "Void parseExp() {                      /* Read an expression to evaluate   */\n", "    parseInput(EXPR);\n", "    setLastExpr(inputExpr);\n", "}\n"], "project": "libhugs-time-bundled", "file": "input.pkl", "function": "parseExp"}, {"comment_all": {"comment": "/*\n          overwrite global variable bytes_in_buf only if we received something:\n          we preserve last read buffer for whoever will attach next\n        */", "depth": 2, "reading_ease": 52.19, "reading_grade": 10.7, "line": 156}, "comment_text": "/*\n          overwrite global variable bytes_in_buf only if we received something:\n          we preserve last read buffer for whoever will attach next\n        */", "comment_tokens": ["overwrite", "global", "variable", "bytes_in_buf", "only", "if", "we", "received", "something", ":", "we", "preserve", "last", "read", "buffer", "for", "whoever", "will", "attach", "next"], "ccode": ["\n", "\n", "\n", "\n", "\n", "int input_buffer_recvfd(int in_fd, int dribble_fd, int * recv_fd) {\n", "    int bytes_read = 0;\n", "#ifdef DETACHTTY_SENDFD_RECVFD\n", "    if (recv_fd != NULL)\n", "        bytes_read = recv_bytes_and_fd(in_fd, buf, buf_capacity, recv_fd);\n", "    else\n", "#endif\n", "        bytes_read = read(in_fd, buf, buf_capacity);\n", "\n", "    if (bytes_read > 0) {\n", "        /*\n", "          overwrite global variable bytes_in_buf only if we received something:\n", "          we preserve last read buffer for whoever will attach next\n", "        */\n", "        bytes_in_buf = bytes_read;\n", "        output_buffer(dribble_fd);\n", "    }\n", "    return bytes_read;\n", "}\n"], "project": "detachtty", "file": "copy-stream.pkl", "function": "input_buffer_recvfd"}, {"comment_all": {"comment": "/* NB: entries 0 and 1 are used for preview only, the default font is 4(!) */", "depth": 1, "reading_ease": 81.63, "reading_grade": 5.6, "line": 1982}, "comment_text": "/* NB: entries 0 and 1 are used for preview only, the default font is 4(!) */", "comment_tokens": ["NB", ":", "entries", "0", "and", "1", "are", "used", "for", "preview", "only", ",", "the", "default", "font", "is", "4", "(", "!", ")"], "ccode": ["\n", "int\n", "Load_Font ()\n", "/* load the normal, subscript and symbol fonts for all zoom scales */\n", "{\n", "\n", "#ifdef GTK2\n", "\n", "int i;\n", "\n", "  gchar *pangosymtype[]= {\"Symbol 8\", \"Symbol 10\", \"Symbol 12\", \"Symbol 14\",\n", "                          \"Symbol 18\", \"Symbol 20\", \"Symbol 24\" };\n", "  gchar *pangossymtype[]= {\"Symbol 8\", \"Symbol 8\", \"Symbol 10\", \"Symbol 12\",\n", "                          \"Symbol 14\", \"Symbol 18\", \"Symbol 24\" };\n", "  gchar *pangofntype[]= { \"Helvetica 8\", \"Helvetica 10\", \"Helvetica 12\",\n", "                          \"Helvetica 14\", \"Helvetica 17\", \"Helvetica 20\", \n", "                          \"Helvetica 24\"};\n", "  gchar *pangosfntype[]= { \"Helvetica 8\", \"Helvetica 8\", \"Helvetica 10\",\n", "                           \"Helvetica 12\", \"Helvetica 14\", \"Helvetica 14\", \n", "                           \"Helvetica 20\"};\n", "  gchar *pangosltype[]= { \"Helvetica oblique 8\", \"Helvetica oblique 10\",\n", "                          \"Helvetica oblique 12\",  \"Helvetica oblique 14\",\n", "                          \"Helvetica oblique 18\", \"Helvetica oblique 18\",\n", "                          \"Helvetica oblique 24\"};\n", "  gchar *pangobtype[]= { \"Helvetica bold 8\", \"Helvetica bold 10\",\n", "                         \"Helvetica bold 12\",  \"Helvetica bold 14\",\n", "                         \"Helvetica bold 18\", \"Helvetica bold 18\",\n", "                         \"Helvetica bold 24\"};\n", "  gchar *pangotexttype[]= { \"Times 8\", \"Times 10\",\n", "                            \"Times 12\",  \"Times 14\",\n", "                            \"Times 18\", \"Times 18\",\n", "                            \"Times 24\"};\n", "  for (i=0;i<7;i++){\n", "  font[i]=pango_font_description_from_string(pangofntype[i]);\n", "  symbfont[i]=pango_font_description_from_string(pangosymtype[i]);\n", "  ssymbfont[i]=pango_font_description_from_string(pangossymtype[i]);\n", "  smallfont[i]=pango_font_description_from_string(pangosfntype[i]);\n", "  slfont[i]=pango_font_description_from_string(pangosltype[i]);\n", "  boldfont[i]=pango_font_description_from_string(pangobtype[i]);\n", "  textfont[i]=pango_font_description_from_string(pangotexttype[i]);\n", "  }                                                                                                                                                                                                                                                                                                                           \n", "\n", "#else\n", "\n", "int i,fnt;\n", "\n", "/* NB: entries 0 and 1 are used for preview only, the default font is 4(!) */\n", "  gchar *symtype75[] = { \"*-symbol-*-*-8-*\", \"*-symbol-*-*-10-*\",\n", "    \"*-symbol-*-*-12-*\", \"*-symbol-*-*-14-*\", \"*-symbol-*-*-18-*\",\n", "    \"*-symbol-*-*-18-*\", \"*-symbol-*-*-24-*\"\n", "  };\n", "\n", "  gchar *ssymtype75[] = { \"*-symbol-*-*-8-*\", \"*-symbol-*-*-8-*\",\n", "    \"*-symbol-*-*-10-*\", \"*-symbol-*-*-12-*\", \"*-symbol-*-*-14-*\",\n", "    \"*-symbol-*-*-18-*\", \"*-symbol-*-*-24-*\"\n", "  };\n", "\n", "  gchar *symtype100[] = { \"*-symbol-*-*-11-*\", \"*-symbol-*-*-14-*\",\n", "    \"*-symbol-*-*-17-*\", \"*-symbol-*-*-20-*\", \"*-symbol-*-*-25-*\",\n", "    \"*-symbol-*-*-25-*\", \"*-symbol-*-*-34-*\"\n", "  };\n", "\n", "  gchar *ssymtype100[] = { \"*-symbol-*-*-11-*\", \"*-symbol-*-*-11-*\",\n", "    \"*-symbol-*-*-14-*\", \"*-symbol-*-*-17-*\", \"*-symbol-*-*-20-*\",\n", "    \"*-symbol-*-*-25-*\", \"*-symbol-*-*-34-*\"\n", "  };\n", "\n", "  gchar *fntype75[] =\n", "    { \"*-helvetica-medium-r-normal--8-*\", \"*-helvetica-medium-r-normal--10-*\",\n", "    \"*-helvetica-medium-r-normal--12-*\", \"*-helvetica-medium-r-normal--14-*\",\n", "    \"*-helvetica-medium-r-normal--18-*\",\n", "    \"*-helvetica-medium-r-normal--18-*\", \"*-helvetica-medium-r-normal--24-*\"\n", "  };\n", "\n", "  gchar *fntype100[] =\n", "    { \"*-helvetica-medium-r-normal--11-*\", \"*-helvetica-medium-r-normal--14-*\",\n", "    \"*-helvetica-medium-r-normal--17-*\", \"*-helvetica-medium-r-normal--20-*\",\n", "    \"*-helvetica-medium-r-normal--25-*\",\n", "    \"*-helvetica-medium-r-normal--25-*\", \"*-helvetica-medium-r-normal--34-*\"\n", "  };\n", "\n", "  gchar *fallback[] = { \"5x7\", \"6x10\", \"7x13\", \"9x15\", \"8x16\",\n", "    \"10x20\", \"12x24\"\n", "  };\n", "\n", "  gchar *sfntype75[] =\n", "    { \"*-helvetica-medium-r-normal--8-*\", \"*-helvetica-medium-r-normal--8-*\",\n", "    \"*-helvetica-medium-r-normal--10-*\", \"*-helvetica-medium-r-normal--12-*\",\n", "    \"*-helvetica-bold-r-normal--14-*\",\n", "    \"*-helvetica-bold-r-normal--14-*\", \"*-helvetica-medium-r-normal--20-*\"\n", "  };\n", "\n", "  gchar *sfntype100[] =\n", "    { \"*-helvetica-medium-r-normal--11-*\", \"*-helvetica-medium-r-normal--11-*\",\n", "    \"*-helvetica-medium-r-normal--14-*\", \"*-helvetica-medium-r-normal--17-*\",\n", "    \"*-helvetica-bold-r-normal--20-*\",\n", "    \"*-helvetica-bold-r-normal--20-*\", \"*-helvetica-medium-r-normal--25-*\"\n", "  };\n", "/*  {\"5x7\", \"5x7\", \"6x10\", \"8x13\", \"7x14\",\n", "   \"8x13bold\", \"10x20\"};*/\n", "\n", "  gchar *sltype75[] =\n", "    { \"*-helvetica-medium-o-normal--8-*\", \"*-helvetica-medium-o-normal--10-*\",\n", "    \"*-helvetica-medium-o-normal--12-*\", \"*-helvetica-medium-o-normal--14-*\",\n", "    \"*-helvetica-medium-o-normal--18-*\",\n", "    \"*-helvetica-medium-o-normal--18-*\", \"*-helvetica-medium-o-normal--24-*\"\n", "  };\n", "  gchar *sltype100[] =\n", "    { \"*-helvetica-medium-o-normal--11-*\", \"*-helvetica-medium-o-normal--14-*\",\n", "    \"*-helvetica-medium-o-normal--17-*\", \"*-helvetica-medium-o-normal--20-*\",\n", "    \"*-helvetica-medium-o-normal--25-*\",\n", "    \"*-helvetica-medium-o-normal--25-*\", \"*-helvetica-medium-o-normal--34-*\"\n", "  };\n", "\n", "  gchar *btype75[] =\n", "    { \"*-helvetica-bold-r-normal--8-*\", \"*-helvetica-bold-r-normal--10-*\",\n", "    \"*-helvetica-bold-r-normal--12-*\", \"*-helvetica-bold-r-normal--14-*\",\n", "    \"*-helvetica-bold-r-normal--18-*\",\n", "    \"*-helvetica-bold-r-normal--18-*\", \"*-helvetica-bold-r-normal--24-*\"\n", "  };\n", "  gchar *btype100[] =\n", "    { \"*-helvetica-bold-r-normal--11-*\", \"*-helvetica-bold-r-normal--14-*\",\n", "    \"*-helvetica-bold-r-normal--17-*\", \"*-helvetica-bold-r-normal--20-*\",\n", "    \"*-helvetica-bold-r-normal--25-*\",\n", "    \"*-helvetica-bold-r-normal--25-*\", \"*-helvetica-bold-r-normal--34-*\"\n", "  };\n", "\n", "  gchar *texttype75[] =\n", "    { \"*-times-medium-r-normal--8-*\", \"*-times-medium-r-normal--10-*\",\n", "    \"*-times-medium-r-normal--12-*\", \"*-times-medium-r-normal--14-*\",\n", "    \"*-times-medium-r-normal--18-*\",\n", "    \"*-times-medium-r-normal--18-*\", \"*-times-medium-r-normal--24-*\"\n", "  };\n", "  gchar *texttype100[] =\n", "    { \"*-times-medium-r-normal--11-*\", \"*-times-medium-r-normal--14-*\",\n", "    \"*-times-medium-r-normal--17-*\", \"*-times-medium-r-normal--20-*\",\n", "    \"*-times-medium-r-normal--25-*\",\n", "    \"*-times-medium-r-normal--25-*\", \"*-times-medium-r-normal--34-*\"\n", "  };\n", "\n", "\n", "for (i=0;i<7;i++) {\n", "\n", "  if (font[i])\n", "    gdk_font_unref (font[i]);\n", "  if (symbfont[i])\n", "    gdk_font_unref (symbfont[i]);\n", "  if (smallfont[i])\n", "    gdk_font_unref (smallfont[i]);\n", "  if (ssymbfont[i])\n", "    gdk_font_unref (ssymbfont[i]);\n", "  if (slfont[i])\n", "    gdk_font_unref (slfont[i]);\n", "  if (boldfont[i])\n", "    gdk_font_unref (boldfont[i]);\n", "  if (textfont[i])\n", "    gdk_font_unref (textfont[i]);\n", "   \n", "   fnt=i;\n", "  if ((font[i] = gdk_font_load (fntype75[fnt])) == NULL)\n", "     if((font[i] = gdk_font_load (fntype100[fnt])) == NULL)\n", "    {\n", "      fprintf (stderr, \"failed to load font %s !!!\\n\", fntype75[fnt]);\n", "      if ((font[i] = gdk_font_load (fallback[fnt])) == NULL)\n", "\treturn (0);\n", "    }\n", "  if ((symbfont[i] = gdk_font_load (symtype75[fnt])) == NULL)\n", "     if((symbfont[i] = gdk_font_load (symtype100[fnt])) == NULL)\n", "    {\n", "      fprintf (stderr, \"Failed to load symbol font, using standard font\\n\");\n", "      symbfont[i] = font[i];\n", "    }\n", "  if ((ssymbfont[i] = gdk_font_load (ssymtype75[fnt])) == NULL)\n", "  \tif((ssymbfont[i] = gdk_font_load (ssymtype100[fnt])) == NULL)\n", "   ssymbfont[i] = font[i];\n", "  if ((smallfont[i] = gdk_font_load (sfntype75[fnt])) == NULL)\n", "      if ((smallfont[i] = gdk_font_load (sfntype100[fnt])) == NULL)\n", "    smallfont[i] = font[i];\n", "  if ((slfont[i] = gdk_font_load (sltype75[fnt])) == NULL)\n", "\tif ((slfont[i] = gdk_font_load (sltype100[fnt])) == NULL) \n", "    slfont[i] = font[i];\n", "  if ((boldfont[i] = gdk_font_load (btype75[fnt])) == NULL)\n", "\tif ((boldfont[i] = gdk_font_load (btype100[fnt])) == NULL)\n", "    boldfont[i] = font[i];\n", "  if ((textfont[i] = gdk_font_load (texttype75[fnt])) == NULL)\n", "\tif ((textfont[i] = gdk_font_load (texttype100[fnt])) == NULL)\n", "    textfont[i] = font[i];\n", " } \n", "\n", "#endif\n", "\n", "  return (1);\n", "}\n"], "project": "chemtool", "file": "graph.pkl", "function": "Load_Font"}, {"comment_all": {"comment": "/* Try to identify the command line option in str, returning a unique\n\t * option/error code. The not_last variable specifies whether current\n\t * option was followed by something else (a value or another option)\n\t * on the command line.\n\t */", "depth": 1, "reading_ease": 53.71, "reading_grade": 10.1, "line": 319}, "comment_text": "/* Try to identify the command line option in str, returning a unique\n\t * option/error code. The not_last variable specifies whether current\n\t * option was followed by something else (a value or another option)\n\t * on the command line.\n\t */", "comment_tokens": ["Try", "to", "identify", "the", "command", "line", "option", "in", "str", ",", "returning", "a", "unique", "optionerror", "code", ".", "The", "not_last", "variable", "specifies", "whether", "current", "option", "was", "followed", "by", "something", "else", "(", "a", "value", "or", "another", "option", ")", "on", "the", "command", "line", "."], "ccode": ["\n", "\n", "gint\n", "my_get_opt (const gchar *str, gboolean not_last)\n", "{\n", "\t/* Try to identify the command line option in str, returning a unique\n", "\t * option/error code. The not_last variable specifies whether current\n", "\t * option was followed by something else (a value or another option)\n", "\t * on the command line.\n", "\t */\n", "\n", "\tgint opt, len;\n", "\n", "\tif (strcmp (str, \"+rv\") == 0) return OPT_RV;\n", "\tif (*str != '-') return OPT_IS_UNKNOWN;\n", "\n", "\tstr++;\n", "\tif (*str == '-') str++;\n", "\tlen = strlen (str);\n", "\n", "\tif (len > 0) {\n", "\t\tfor (opt = 0; opt < N_OPTS; opt++) {\n", "\t\t\tif (len >= option[opt].min_len &&\n", "\t\t\t    strncmp (str, option[opt].opt_str, len) == 0) {\n", "\t\t\t\tif (!option[opt].requires_arg || not_last) {\n", "\t\t\t\t\treturn opt;\n", "\t\t\t\t}\n", "\t\t\t\telse {\n", "\t\t\t\t\treturn OPT_IS_MISSING_ARG;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\treturn OPT_IS_UNKNOWN;\n", "}\n"], "project": "gxmessage", "file": "gxmessage.pkl", "function": "my_get_opt"}, {"comment_all": {"comment": "/* check and 0 pad the first data chunk */", "depth": 3, "reading_ease": 105.66, "reading_grade": 0.5, "line": 455}, "comment_text": "/* check and 0 pad the first data chunk */", "comment_tokens": ["check", "and", "0", "pad", "the", "first", "data", "chunk"], "ccode": ["\n", "static int get_header (mms_io_t *io, mmsh_t *this) {\n", "  int ret, len = 0;\n", "\n", "  this->asf_header_len = 0;\n", "  this->asf_header_read = 0;\n", "  this->buf_size = 0;\n", "\n", "  /* read chunk */\n", "  while (1) {\n", "    if ((ret = get_chunk_header(io, this)) == MMSH_SUCCESS) {\n", "      if (this->chunk_type == CHUNK_TYPE_ASF_HEADER) {\n", "        if ((this->asf_header_len + this->chunk_length) > ASF_HEADER_SIZE) {\n", "          lprintf(\"the asf header exceed %d bytes\\n\", ASF_HEADER_SIZE);\n", "          return MMSH_ERROR;\n", "        } else {\n", "          len = io_read(io, this->s, this->asf_header + this->asf_header_len,\n", "                        this->chunk_length);\n", "          if (len > 0)\n", "            this->asf_header_len += len;\n", "          if (len != this->chunk_length) {\n", "            lprintf(\"asf header chunk read failed, %d != %d\\n\", len,\n", "                     this->chunk_length);\n", "            return MMSH_ERROR;\n", "          }\n", "          interp_asf_header(this);\n", "        }\n", "      } else {\n", "        break;\n", "      }\n", "    } else {\n", "      if (this->asf_header_len == 0 || ret != EOS)\n", "        lprintf(\"get_header failed to get chunk header\\n\");\n", "      return ret;\n", "    }\n", "  }\n", "\n", "  if (this->chunk_type == CHUNK_TYPE_DATA) {\n", "    /* read the first data chunk */\n", "    len = io_read (io, this->s, this->buf, this->chunk_length);\n", "\n", "    if (len != this->chunk_length) {\n", "      lprintf(\"asf data chunk read failed, %d != %d\\n\", len,\n", "               this->chunk_length);\n", "      return MMSH_ERROR;\n", "    } else {\n", "      /* check and 0 pad the first data chunk */\n", "      if (this->chunk_length > this->asf_packet_len) {\n", "        lprintf(\"chunk_length(%d) > asf_packet_len(%d)\\n\",\n", "                this->chunk_length, this->asf_packet_len);\n", "        return MMSH_ERROR;\n", "      }\n", "\n", "      /* explicit padding with 0 */\n", "      if (this->chunk_length < this->asf_packet_len)\n", "        memset(this->buf + this->chunk_length, 0,\n", "               this->asf_packet_len - this->chunk_length);\n", "\n", "      this->buf_size = this->asf_packet_len;\n", "\n", "      return MMSH_SUCCESS;\n", "    }\n", "  } else {\n", "    /* unexpected packet type */\n", "    lprintf(\"unexpected chunk_type(0x%04x)\\n\", this->chunk_type);\n", "    return MMSH_ERROR;\n", "  }\n", "}\n"], "project": "libmms0", "file": "mmsh.pkl", "function": "get_header"}, {"comment_all": {"comment": "/* Regression test utilities\n *\n * Copyright \u00a9 2009-2018 Collabora Ltd. <http://www.collabora.co.uk/>\n * Copyright \u00a9 2009-2011 Nokia Corporation\n *\n * Licensed under the Academic Free License version 2.1\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */", "depth": 0, "reading_ease": 52.19, "reading_grade": 10.7, "line": 2}, "comment_text": "/* Regression test utilities\n *\n * Copyright \u00a9 2009-2018 Collabora Ltd. <http://www.collabora.co.uk/>\n * Copyright \u00a9 2009-2011 Nokia Corporation\n *\n * Licensed under the Academic Free License version 2.1\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301  USA\n */", "comment_tokens": ["Regression", "test", "utilities", "Copyright", "\u00a9", "2009-2018", "Collabora", "Ltd.", "<", "http", ":", "www.collabora.co.uk", ">", "Copyright", "\u00a9", "2009-2011", "Nokia", "Corporation", "Licensed", "under", "the", "Academic", "Free", "License", "version", "2.1", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA"], "ccode": ["/* Regression test utilities\n", " *\n", " * Copyright \u00a9 2009-2018 Collabora Ltd. <http://www.collabora.co.uk/>\n", " * Copyright \u00a9 2009-2011 Nokia Corporation\n", " *\n", " * Licensed under the Academic Free License version 2.1\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n", " * 02110-1301  USA\n", " */\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "\n", "#include \"util.h\"\n", "\n", "void\n", "test_run_until_disconnected (DBusConnection *connection,\n", "                             GMainContext *context)\n", "{\n", "  g_printerr (\"Disconnecting... \");\n", "\n", "  dbus_connection_set_exit_on_disconnect (connection, FALSE);\n", "  dbus_connection_close (connection);\n", "\n", "  while (dbus_connection_get_is_connected (connection))\n", "    {\n", "      g_printerr (\".\");\n", "      g_main_context_iteration (context, TRUE);\n", "    }\n", "\n", "  g_printerr (\" disconnected\\n\");\n", "}\n"], "project": "libdbus-glib-1-dev", "file": "util.pkl", "function": "test_run_until_disconnected"}, {"comment_all": {"comment": "/* special case: \".\" was normalized to \"\" */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 160}, "comment_text": "/* special case: \".\" was normalized to \"\" */", "comment_tokens": ["special", "case", ":", "``", ".", "''", "was", "normalized", "to", "``", "''"], "ccode": ["\n", "int cmd_mv(int argc, const char **argv, const char *prefix)\n", "{\n", "\tint i, flags, gitmodules_modified = 0;\n", "\tint verbose = 0, show_only = 0, force = 0, ignore_errors = 0;\n", "\tstruct option builtin_mv_options[] = {\n", "\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n", "\t\tOPT__DRY_RUN(&show_only, N_(\"dry run\")),\n", "\t\tOPT__FORCE(&force, N_(\"force move/rename even if target exists\"),\n", "\t\t\t   PARSE_OPT_NOCOMPLETE),\n", "\t\tOPT_BOOL('k', NULL, &ignore_errors, N_(\"skip move/rename errors\")),\n", "\t\tOPT_END(),\n", "\t};\n", "\tconst char **source, **destination, **dest_path, **submodule_gitfile;\n", "\tenum update_mode { BOTH = 0, WORKING_DIRECTORY, INDEX } *modes;\n", "\tstruct stat st;\n", "\tstruct string_list src_for_dst = STRING_LIST_INIT_NODUP;\n", "\tstruct lock_file lock_file = LOCK_INIT;\n", "\n", "\tgit_config(git_default_config, NULL);\n", "\n", "\targc = parse_options(argc, argv, prefix, builtin_mv_options,\n", "\t\t\t     builtin_mv_usage, 0);\n", "\tif (--argc < 1)\n", "\t\tusage_with_options(builtin_mv_usage, builtin_mv_options);\n", "\n", "\thold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);\n", "\tif (read_cache() < 0)\n", "\t\tdie(_(\"index file corrupt\"));\n", "\n", "\tsource = internal_prefix_pathspec(prefix, argv, argc, 0);\n", "\tmodes = xcalloc(argc, sizeof(enum update_mode));\n", "\t/*\n", "\t * Keep trailing slash, needed to let\n", "\t * \"git mv file no-such-dir/\" error out, except in the case\n", "\t * \"git mv directory no-such-dir/\".\n", "\t */\n", "\tflags = KEEP_TRAILING_SLASH;\n", "\tif (argc == 1 && is_directory(argv[0]) && !is_directory(argv[1]))\n", "\t\tflags = 0;\n", "\tdest_path = internal_prefix_pathspec(prefix, argv + argc, 1, flags);\n", "\tsubmodule_gitfile = xcalloc(argc, sizeof(char *));\n", "\n", "\tif (dest_path[0][0] == '\\0')\n", "\t\t/* special case: \".\" was normalized to \"\" */\n", "\t\tdestination = internal_prefix_pathspec(dest_path[0], argv, argc, DUP_BASENAME);\n", "\telse if (!lstat(dest_path[0], &st) &&\n", "\t\t\tS_ISDIR(st.st_mode)) {\n", "\t\tdest_path[0] = add_slash(dest_path[0]);\n", "\t\tdestination = internal_prefix_pathspec(dest_path[0], argv, argc, DUP_BASENAME);\n", "\t} else {\n", "\t\tif (argc != 1)\n", "\t\t\tdie(_(\"destination '%s' is not a directory\"), dest_path[0]);\n", "\t\tdestination = dest_path;\n", "\t}\n", "\n", "\t/* Checking */\n", "\tfor (i = 0; i < argc; i++) {\n", "\t\tconst char *src = source[i], *dst = destination[i];\n", "\t\tint length, src_is_dir;\n", "\t\tconst char *bad = NULL;\n", "\n", "\t\tif (show_only)\n", "\t\t\tprintf(_(\"Checking rename of '%s' to '%s'\\n\"), src, dst);\n", "\n", "\t\tlength = strlen(src);\n", "\t\tif (lstat(src, &st) < 0)\n", "\t\t\tbad = _(\"bad source\");\n", "\t\telse if (!strncmp(src, dst, length) &&\n", "\t\t\t\t(dst[length] == 0 || dst[length] == '/')) {\n", "\t\t\tbad = _(\"can not move directory into itself\");\n", "\t\t} else if ((src_is_dir = S_ISDIR(st.st_mode))\n", "\t\t\t\t&& lstat(dst, &st) == 0)\n", "\t\t\tbad = _(\"cannot move directory over file\");\n", "\t\telse if (src_is_dir) {\n", "\t\t\tint first = cache_name_pos(src, length), last;\n", "\n", "\t\t\tif (first >= 0)\n", "\t\t\t\tprepare_move_submodule(src, first,\n", "\t\t\t\t\t\t       submodule_gitfile + i);\n", "\t\t\telse if (index_range_of_same_dir(src, length,\n", "\t\t\t\t\t\t\t &first, &last) < 1)\n", "\t\t\t\tbad = _(\"source directory is empty\");\n", "\t\t\telse { /* last - first >= 1 */\n", "\t\t\t\tint j, dst_len, n;\n", "\n", "\t\t\t\tmodes[i] = WORKING_DIRECTORY;\n", "\t\t\t\tn = argc + last - first;\n", "\t\t\t\tREALLOC_ARRAY(source, n);\n", "\t\t\t\tREALLOC_ARRAY(destination, n);\n", "\t\t\t\tREALLOC_ARRAY(modes, n);\n", "\t\t\t\tREALLOC_ARRAY(submodule_gitfile, n);\n", "\n", "\t\t\t\tdst = add_slash(dst);\n", "\t\t\t\tdst_len = strlen(dst);\n", "\n", "\t\t\t\tfor (j = 0; j < last - first; j++) {\n", "\t\t\t\t\tconst char *path = active_cache[first + j]->name;\n", "\t\t\t\t\tsource[argc + j] = path;\n", "\t\t\t\t\tdestination[argc + j] =\n", "\t\t\t\t\t\tprefix_path(dst, dst_len, path + length + 1);\n", "\t\t\t\t\tmodes[argc + j] = INDEX;\n", "\t\t\t\t\tsubmodule_gitfile[argc + j] = NULL;\n", "\t\t\t\t}\n", "\t\t\t\targc += last - first;\n", "\t\t\t}\n", "\t\t} else if (cache_name_pos(src, length) < 0)\n", "\t\t\tbad = _(\"not under version control\");\n", "\t\telse if (lstat(dst, &st) == 0 &&\n", "\t\t\t (!ignore_case || strcasecmp(src, dst))) {\n", "\t\t\tbad = _(\"destination exists\");\n", "\t\t\tif (force) {\n", "\t\t\t\t/*\n", "\t\t\t\t * only files can overwrite each other:\n", "\t\t\t\t * check both source and destination\n", "\t\t\t\t */\n", "\t\t\t\tif (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {\n", "\t\t\t\t\tif (verbose)\n", "\t\t\t\t\t\twarning(_(\"overwriting '%s'\"), dst);\n", "\t\t\t\t\tbad = NULL;\n", "\t\t\t\t} else\n", "\t\t\t\t\tbad = _(\"Cannot overwrite\");\n", "\t\t\t}\n", "\t\t} else if (string_list_has_string(&src_for_dst, dst))\n", "\t\t\tbad = _(\"multiple sources for the same target\");\n", "\t\telse if (is_dir_sep(dst[strlen(dst) - 1]))\n", "\t\t\tbad = _(\"destination directory does not exist\");\n", "\t\telse\n", "\t\t\tstring_list_insert(&src_for_dst, dst);\n", "\n", "\t\tif (!bad)\n", "\t\t\tcontinue;\n", "\t\tif (!ignore_errors)\n", "\t\t\tdie(_(\"%s, source=%s, destination=%s\"),\n", "\t\t\t     bad, src, dst);\n", "\t\tif (--argc > 0) {\n", "\t\t\tint n = argc - i;\n", "\t\t\tmemmove(source + i, source + i + 1,\n", "\t\t\t\tn * sizeof(char *));\n", "\t\t\tmemmove(destination + i, destination + i + 1,\n", "\t\t\t\tn * sizeof(char *));\n", "\t\t\tmemmove(modes + i, modes + i + 1,\n", "\t\t\t\tn * sizeof(enum update_mode));\n", "\t\t\tmemmove(submodule_gitfile + i, submodule_gitfile + i + 1,\n", "\t\t\t\tn * sizeof(char *));\n", "\t\t\ti--;\n", "\t\t}\n", "\t}\n", "\n", "\tfor (i = 0; i < argc; i++) {\n", "\t\tconst char *src = source[i], *dst = destination[i];\n", "\t\tenum update_mode mode = modes[i];\n", "\t\tint pos;\n", "\t\tif (show_only || verbose)\n", "\t\t\tprintf(_(\"Renaming %s to %s\\n\"), src, dst);\n", "\t\tif (show_only)\n", "\t\t\tcontinue;\n", "\t\tif (mode != INDEX && rename(src, dst) < 0) {\n", "\t\t\tif (ignore_errors)\n", "\t\t\t\tcontinue;\n", "\t\t\tdie_errno(_(\"renaming '%s' failed\"), src);\n", "\t\t}\n", "\t\tif (submodule_gitfile[i]) {\n", "\t\t\tif (!update_path_in_gitmodules(src, dst))\n", "\t\t\t\tgitmodules_modified = 1;\n", "\t\t\tif (submodule_gitfile[i] != SUBMODULE_WITH_GITDIR)\n", "\t\t\t\tconnect_work_tree_and_git_dir(dst,\n", "\t\t\t\t\t\t\t      submodule_gitfile[i],\n", "\t\t\t\t\t\t\t      1);\n", "\t\t}\n", "\n", "\t\tif (mode == WORKING_DIRECTORY)\n", "\t\t\tcontinue;\n", "\n", "\t\tpos = cache_name_pos(src, strlen(src));\n", "\t\tassert(pos >= 0);\n", "\t\trename_cache_entry_at(pos, dst);\n", "\t}\n", "\n", "\tif (gitmodules_modified)\n", "\t\tstage_updated_gitmodules(&the_index);\n", "\n", "\tif (write_locked_index(&the_index, &lock_file,\n", "\t\t\t       COMMIT_LOCK | SKIP_IF_UNCHANGED))\n", "\t\tdie(_(\"Unable to write new index file\"));\n", "\n", "\treturn 0;\n", "}\n"], "project": "git-man", "file": "mv.pkl", "function": "cmd_mv"}, {"comment_all": {"comment": "/* need to shift things up to make room */", "depth": 2, "reading_ease": 114.12, "reading_grade": -0.8, "line": 3528}, "comment_text": "/* need to shift things up to make room */\n/* +2 for EOB chars. */\n", "comment_tokens": ["need", "to", "shift", "things", "up", "to", "make", "room", "+2", "for", "EOB", "chars", "."], "ccode": ["\n", "#ifndef YY_NO_UNPUT\n", "\n", "    static void yyunput (int c, char * yy_bp )\n", "{\n", "\tchar *yy_cp;\n", "    \n", "    yy_cp = (yy_c_buf_p);\n", "\n", "\t/* undo effects of setting up yytext */\n", "\t*yy_cp = (yy_hold_char);\n", "\n", "\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n", "\t\t{ /* need to shift things up to make room */\n", "\t\t/* +2 for EOB chars. */\n", "\t\tint number_to_move = (yy_n_chars) + 2;\n", "\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n", "\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n", "\t\tchar *source =\n", "\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n", "\n", "\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n", "\t\t\t*--dest = *--source;\n", "\n", "\t\tyy_cp += (int) (dest - source);\n", "\t\tyy_bp += (int) (dest - source);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n", "\t\t\t(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n", "\n", "\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n", "\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n", "\t\t}\n", "\n", "\t*--yy_cp = (char) c;\n", "\n", "    if ( c == '\\n' ){\n", "        --yylineno;\n", "    }\n", "\n", "\t(yytext_ptr) = yy_bp;\n", "\t(yy_hold_char) = *yy_cp;\n", "\t(yy_c_buf_p) = yy_cp;\n", "}\n"], "project": "linux-buildinfo-5.8.0-34-lowlatency", "file": "lexer.lex.pkl", "function": "yyunput"}, {"comment_all": {"comment": "/* Merge fast locals into f->f_locals */", "depth": 1, "reading_ease": 66.4, "reading_grade": 5.2, "line": 1067}, "comment_text": "/* Merge fast locals into f->f_locals */", "comment_tokens": ["Merge", "fast", "locals", "into", "f-", ">", "f_locals"], "ccode": ["\n", "int\n", "PyFrame_FastToLocalsWithError(PyFrameObject *f)\n", "{\n", "    /* Merge fast locals into f->f_locals */\n", "    PyObject *locals, *map;\n", "    PyObject **fast;\n", "    PyCodeObject *co;\n", "    Py_ssize_t j;\n", "    Py_ssize_t ncells, nfreevars;\n", "\n", "    if (f == NULL) {\n", "        PyErr_BadInternalCall();\n", "        return -1;\n", "    }\n", "    locals = f->f_locals;\n", "    if (locals == NULL) {\n", "        locals = f->f_locals = PyDict_New();\n", "        if (locals == NULL)\n", "            return -1;\n", "    }\n", "    co = f->f_code;\n", "    map = co->co_varnames;\n", "    if (!PyTuple_Check(map)) {\n", "        PyErr_Format(PyExc_SystemError,\n", "                     \"co_varnames must be a tuple, not %s\",\n", "                     Py_TYPE(map)->tp_name);\n", "        return -1;\n", "    }\n", "    fast = f->f_localsplus;\n", "    j = PyTuple_GET_SIZE(map);\n", "    if (j > co->co_nlocals)\n", "        j = co->co_nlocals;\n", "    if (co->co_nlocals) {\n", "        if (map_to_dict(map, j, locals, fast, 0) < 0)\n", "            return -1;\n", "    }\n", "    ncells = PyTuple_GET_SIZE(co->co_cellvars);\n", "    nfreevars = PyTuple_GET_SIZE(co->co_freevars);\n", "    if (ncells || nfreevars) {\n", "        if (map_to_dict(co->co_cellvars, ncells,\n", "                        locals, fast + co->co_nlocals, 1))\n", "            return -1;\n", "\n", "        /* If the namespace is unoptimized, then one of the\n", "           following cases applies:\n", "           1. It does not contain free variables, because it\n", "              uses import * or is a top-level namespace.\n", "           2. It is a class namespace.\n", "           We don't want to accidentally copy free variables\n", "           into the locals dict used by the class.\n", "        */\n", "        if (co->co_flags & CO_OPTIMIZED) {\n", "            if (map_to_dict(co->co_freevars, nfreevars,\n", "                            locals, fast + co->co_nlocals + ncells, 1) < 0)\n", "                return -1;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "project": "python3.9-examples", "file": "frameobject.pkl", "function": "PyFrame_FastToLocalsWithError"}, {"comment_all": {"comment": "/* yylex_destroy is for both reentrant and non-reentrant scanners. */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 4048}, "comment_text": "/* yylex_destroy is for both reentrant and non-reentrant scanners. */", "comment_tokens": ["yylex_destroy", "is", "for", "both", "reentrant", "and", "non-reentrant", "scanners", "."], "ccode": ["\n", "/* yylex_destroy is for both reentrant and non-reentrant scanners. */\n", "int yylex_destroy  (void)\n", "{\n", "    \n", "    /* Pop the buffer stack, destroying each element. */\n", "\twhile(YY_CURRENT_BUFFER){\n", "\t\tyy_delete_buffer( YY_CURRENT_BUFFER  );\n", "\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n", "\t\tyypop_buffer_state();\n", "\t}\n", "\n", "\t/* Destroy the stack itself. */\n", "\tyyfree((yy_buffer_stack) );\n", "\t(yy_buffer_stack) = NULL;\n", "\n", "    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n", "     * yylex() is called, initialization will occur. */\n", "    yy_init_globals( );\n", "\n", "    return 0;\n", "}\n"], "project": "linux-azure-5.11-cloud-tools-5.11.0-1027", "file": "lexer.lex.pkl", "function": "yylex_destroy"}, {"comment_all": {"comment": "/* Return the number of bytes by which the current frag can be grown.  */", "depth": 0, "reading_ease": 92.12, "reading_grade": 3.6, "line": 297}, "comment_text": "/* Return the number of bytes by which the current frag can be grown.  */", "comment_tokens": ["Return", "the", "number", "of", "bytes", "by", "which", "the", "current", "frag", "can", "be", "grown", "."], "ccode": ["\f\n", "/* Return the number of bytes by which the current frag can be grown.  */\n", "\n", "size_t\n", "frag_room (void)\n", "{\n", "  return obstack_room (&frchain_now->frch_obstack);\n", "}\n"], "project": "binutils-ia64-linux-gnu", "file": "frags.pkl", "function": "frag_room"}, {"comment_all": {"comment": "/* Find the decimal point character(s?), thousands_separator(s?), and\n   grouping description, either for the current locale if type is\n   LT_CURRENT_LOCALE, a hard-coded locale if LT_DEFAULT_LOCALE or\n   LT_UNDERSCORE_LOCALE/LT_UNDER_FOUR_LOCALE, or none if LT_NO_LOCALE. */", "depth": 0, "reading_ease": 6.0, "reading_grade": 16.0, "line": 692}, "comment_text": "/* Find the decimal point character(s?), thousands_separator(s?), and\n   grouping description, either for the current locale if type is\n   LT_CURRENT_LOCALE, a hard-coded locale if LT_DEFAULT_LOCALE or\n   LT_UNDERSCORE_LOCALE/LT_UNDER_FOUR_LOCALE, or none if LT_NO_LOCALE. */", "comment_tokens": ["Find", "the", "decimal", "point", "character", "(", "s", "?", ")", ",", "thousands_separator", "(", "s", "?", ")", ",", "and", "grouping", "description", ",", "either", "for", "the", "current", "locale", "if", "type", "is", "LT_CURRENT_LOCALE", ",", "a", "hard-coded", "locale", "if", "LT_DEFAULT_LOCALE", "or", "LT_UNDERSCORE_LOCALELT_UNDER_FOUR_LOCALE", ",", "or", "none", "if", "LT_NO_LOCALE", "."], "ccode": ["\n", "static const char no_grouping[1] = {CHAR_MAX};\n", "\n", "/* Find the decimal point character(s?), thousands_separator(s?), and\n", "   grouping description, either for the current locale if type is\n", "   LT_CURRENT_LOCALE, a hard-coded locale if LT_DEFAULT_LOCALE or\n", "   LT_UNDERSCORE_LOCALE/LT_UNDER_FOUR_LOCALE, or none if LT_NO_LOCALE. */\n", "static int\n", "get_locale_info(enum LocaleType type, LocaleInfo *locale_info)\n", "{\n", "    switch (type) {\n", "    case LT_CURRENT_LOCALE: {\n", "        struct lconv *lc = localeconv();\n", "        if (_Py_GetLocaleconvNumeric(lc,\n", "                                     &locale_info->decimal_point,\n", "                                     &locale_info->thousands_sep) < 0) {\n", "            return -1;\n", "        }\n", "\n", "        /* localeconv() grouping can become a dangling pointer or point\n", "           to a different string if another thread calls localeconv() during\n", "           the string formatting. Copy the string to avoid this risk. */\n", "        locale_info->grouping_buffer = _PyMem_Strdup(lc->grouping);\n", "        if (locale_info->grouping_buffer == NULL) {\n", "            PyErr_NoMemory();\n", "            return -1;\n", "        }\n", "        locale_info->grouping = locale_info->grouping_buffer;\n", "        break;\n", "    }\n", "    case LT_DEFAULT_LOCALE:\n", "    case LT_UNDERSCORE_LOCALE:\n", "    case LT_UNDER_FOUR_LOCALE:\n", "        locale_info->decimal_point = PyUnicode_FromOrdinal('.');\n", "        locale_info->thousands_sep = PyUnicode_FromOrdinal(\n", "            type == LT_DEFAULT_LOCALE ? ',' : '_');\n", "        if (!locale_info->decimal_point || !locale_info->thousands_sep)\n", "            return -1;\n", "        if (type != LT_UNDER_FOUR_LOCALE)\n", "            locale_info->grouping = \"\\3\"; /* Group every 3 characters.  The\n", "                                         (implicit) trailing 0 means repeat\n", "                                         infinitely. */\n", "        else\n", "            locale_info->grouping = \"\\4\"; /* Bin/oct/hex group every four. */\n", "        break;\n", "    case LT_NO_LOCALE:\n", "        locale_info->decimal_point = PyUnicode_FromOrdinal('.');\n", "        locale_info->thousands_sep = PyUnicode_New(0, 0);\n", "        if (!locale_info->decimal_point || !locale_info->thousands_sep)\n", "            return -1;\n", "        locale_info->grouping = no_grouping;\n", "        break;\n", "    }\n", "    return 0;\n", "}\n"], "project": "libpython3.8-testsuite", "file": "formatter_unicode.pkl", "function": "get_locale_info"}, {"comment_all": {"comment": "/* important - means \"start from beginning\" */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 770}, "comment_text": "/* important - means \"start from beginning\" */", "comment_tokens": ["important", "-", "means", "``", "start", "from", "beginning", "''"], "ccode": ["\n", "struct db_enumerator\n", "init_db_enumerator(int mode)\n", "{\n", "\tstruct db_enumerator e;\n", "\n", "\te.item = -1; /* important - means \"start from beginning\" */\n", "\te.mode = mode;\n", "\n", "\treturn e;\n", "}\n"], "project": "abook", "file": "database.pkl", "function": "init_db_enumerator"}, {"comment_all": {"comment": "/* Handle any remaining bytes of data. */", "depth": 1, "reading_ease": 56.93, "reading_grade": 6.8, "line": 119}, "comment_text": "/* Handle any remaining bytes of data. */", "comment_tokens": ["Handle", "any", "remaining", "bytes", "of", "data", "."], "ccode": ["\n", "/*\n", " * Update context to reflect the concatenation of another buffer full\n", " * of bytes.\n", " */\n", "void\n", "MD4Update(struct MD4Context *ctx, unsigned char const *buf, size_t len)\n", "{\n", "\tregister uint32_t t;\n", "\n", "\tt = ctx->bytes & 0x3f;\n", "\n", "\t/* Update bytecount */\n", "\tctx->bytes += len;\n", "\n", "\t/* Handle any leading odd-sized chunks */\n", "\n", "\tif (t) {\n", "\t\tunsigned char *p = (unsigned char *) ctx->in + t;\n", "\n", "\t\tt = 64 - t;\n", "\t\tif (len < t) {\n", "\t\t\tmemcpy(p, buf, len);\n", "\t\t\treturn;\n", "\t\t}\n", "\t\tmemcpy(p, buf, t);\n", "\t\tbyteReverse(ctx->in, 16);\n", "\t\tMD4Transform(ctx->buf, ctx->in);\n", "\t\tbuf += t;\n", "\t\tlen -= t;\n", "\t}\n", "\t/* Process data in 64-byte chunks */\n", "\n", "\twhile (len >= 64) {\n", "\t\tmemcpy(ctx->in, buf, 64);\n", "\t\tbyteReverse(ctx->in, 16);\n", "\t\tMD4Transform(ctx->buf, ctx->in);\n", "\t\tbuf += 64;\n", "\t\tlen -= 64;\n", "\t}\n", "\n", "\t/* Handle any remaining bytes of data. */\n", "\n", "\tmemcpy(ctx->in, buf, len);\n", "}\n"], "project": "freetds-common", "file": "md4.pkl", "function": "MD4Update"}, {"comment_all": {"comment": "/*\n\t1\t\tread paired\n\t2\t\tread mapped in proper pair\n\t4\t\tread unmapped\n\t8\t\tmate unmapped\n\t16\t\tread reverse strand\n\t32\t\tmate reverse strand\n\t64\t\tfirst in pair\n\t128\t\tsecond in pair\n\t256\t\tnot primary alignment\n\t512\t\tread fails platform/vendor quality checks\n\t1024\tread is PCR or optical duplicate\n\t2048\tsupplementary alignment\n\t\n\t1\t\ttemplate having multiple segments in sequencing\n\t2\t\teach segment properly aligned according to the aligner\n\t4\t\tsegment unmapped\n\t8\t\tnext segment in the template unmapped\n\t16\t\tSEQ being reverse complemented\n\t32\t\tSEQ of the next segment in the template being reverse complemented\n\t64\t\tthe first segment in the template\n\t128\t\tthe last segment in the template\n\t256\t\tsecondary alignment\n\t512\t\tnot passing filters, such as platform/vendor quality controls\n\t1024\tPCR or optical duplicate\n\t2048\tsupplementary alignment\n\t*/", "depth": 1, "reading_ease": -58.45, "reading_grade": 53.2, "line": 115}, "comment_text": "/* flag */\n/*\n\t1\t\tread paired\n\t2\t\tread mapped in proper pair\n\t4\t\tread unmapped\n\t8\t\tmate unmapped\n\t16\t\tread reverse strand\n\t32\t\tmate reverse strand\n\t64\t\tfirst in pair\n\t128\t\tsecond in pair\n\t256\t\tnot primary alignment\n\t512\t\tread fails platform/vendor quality checks\n\t1024\tread is PCR or optical duplicate\n\t2048\tsupplementary alignment\n\t\n\t1\t\ttemplate having multiple segments in sequencing\n\t2\t\teach segment properly aligned according to the aligner\n\t4\t\tsegment unmapped\n\t8\t\tnext segment in the template unmapped\n\t16\t\tSEQ being reverse complemented\n\t32\t\tSEQ of the next segment in the template being reverse complemented\n\t64\t\tthe first segment in the template\n\t128\t\tthe last segment in the template\n\t256\t\tsecondary alignment\n\t512\t\tnot passing filters, such as platform/vendor quality controls\n\t1024\tPCR or optical duplicate\n\t2048\tsupplementary alignment\n\t*/\n", "comment_tokens": ["flag", "1", "read", "paired", "2", "read", "mapped", "in", "proper", "pair", "4", "read", "unmapped", "8", "mate", "unmapped", "16", "read", "reverse", "strand", "32", "mate", "reverse", "strand", "64", "first", "in", "pair", "128", "second", "in", "pair", "256", "not", "primary", "alignment", "512", "read", "fails", "platformvendor", "quality", "checks", "1024", "read", "is", "PCR", "or", "optical", "duplicate", "2048", "supplementary", "alignment", "1", "template", "having", "multiple", "segments", "in", "sequencing", "2", "each", "segment", "properly", "aligned", "according", "to", "the", "aligner", "4", "segment", "unmapped", "8", "next", "segment", "in", "the", "template", "unmapped", "16", "SEQ", "being", "reverse", "complemented", "32", "SEQ", "of", "the", "next", "segment", "in", "the", "template", "being", "reverse", "complemented", "64", "the", "first", "segment", "in", "the", "template", "128", "the", "last", "segment", "in", "the", "template", "256", "secondary", "alignment", "512", "not", "passing", "filters", ",", "such", "as", "platformvendor", "quality", "controls", "1024", "PCR", "or", "optical", "duplicate", "2048", "supplementary", "alignment"], "ccode": ["\n", "int samwrite(const Qseqs *qseq, const Qseqs *header, const Qseqs *Qual, char *rname, const Aln *aligned, const int *stats) {\n", "\t\n", "\tstatic volatile int lock[1] = {0}; \n", "\tstatic Qseqs *Cigar = 0;\n", "\tint flag, pos, mapQ, pnext, tlen, size, et, score, tab;\n", "\tchar *qname, *cigar, *rnext, *qual;\n", "\tunsigned char *seq;\n", "\t\n", "\t/* flag */\n", "\t/*\n", "\t1\t\tread paired\n", "\t2\t\tread mapped in proper pair\n", "\t4\t\tread unmapped\n", "\t8\t\tmate unmapped\n", "\t16\t\tread reverse strand\n", "\t32\t\tmate reverse strand\n", "\t64\t\tfirst in pair\n", "\t128\t\tsecond in pair\n", "\t256\t\tnot primary alignment\n", "\t512\t\tread fails platform/vendor quality checks\n", "\t1024\tread is PCR or optical duplicate\n", "\t2048\tsupplementary alignment\n", "\t\n", "\t1\t\ttemplate having multiple segments in sequencing\n", "\t2\t\teach segment properly aligned according to the aligner\n", "\t4\t\tsegment unmapped\n", "\t8\t\tnext segment in the template unmapped\n", "\t16\t\tSEQ being reverse complemented\n", "\t32\t\tSEQ of the next segment in the template being reverse complemented\n", "\t64\t\tthe first segment in the template\n", "\t128\t\tthe last segment in the template\n", "\t256\t\tsecondary alignment\n", "\t512\t\tnot passing filters, such as platform/vendor quality controls\n", "\t1024\tPCR or optical duplicate\n", "\t2048\tsupplementary alignment\n", "\t*/\n", "\t\n", "\t\n", "\tqname = (char *) header->seq;\n", "\tseq = qseq->seq;\n", "\tif(Qual) {\n", "\t\tqual = (char *) Qual->seq;\n", "\t} else {\n", "\t\tqual = \"*\";\n", "\t}\n", "\tif(aligned) {\n", "\t\tmapQ = 254 < aligned->mapQ ? 254 : aligned->mapQ;\n", "\t\tet = *stats;\n", "\t\tscore = stats[1];\n", "\t\tpos = stats[2] + 1;\n", "\t\ttlen = stats[3] - pos;\n", "\t\tflag = stats[4];\n", "\t} else {\n", "\t\tmapQ = 0;\n", "\t\tet = 0;\n", "\t\tscore = 0;\n", "\t\tpos = 0;\n", "\t\ttlen = 0;\n", "\t\tet = *stats;\n", "\t\tflag = stats[1];\n", "\t\tif(rname == 0) {\n", "\t\t\trname = \"*\";\n", "\t\t}\n", "\t\tcigar = \"*\";\n", "\t}\n", "\trnext = \"*\";\n", "\tpnext = 0;\n", "\t\n", "\ttab = 0;\n", "\tif(qname) {\n", "\t\twhile(*qname) {\n", "\t\t\tif(*qname == '\\t') {\n", "\t\t\t\t*qname = 0;\n", "\t\t\t} else {\n", "\t\t\t\t++qname;\n", "\t\t\t\t++tab;\n", "\t\t\t}\n", "\t\t}\n", "\t\tqname = (char *) header->seq;\n", "\t}\n", "\t\n", "\tlock(lock);\n", "\tif(aligned) {\n", "\t\tif(Cigar == 0) {\n", "\t\t\tCigar = setQseqs(256);\n", "\t\t}\n", "\t\tcigar = makeCigar(Cigar, aligned);\n", "\t}\n", "\tsize = fprintf(stdout, \"%s\\t%d\\t%s\\t%d\\t%d\\t%s\\t%s\\t%d\\t%d\\t%s\\t%s\\tET:i:%d\\tAS:i:%d\\n\", qname, flag, rname, pos, mapQ, cigar, rnext, pnext, tlen, (char *) seq, qual, et, score);\n", "\tunlock(lock);\n", "\t\n", "\tif(tab) {\n", "\t\tqname[tab] = '\\t';\n", "\t}\n", "\t\n", "\treturn size;\n", "}\n"], "project": "kma", "file": "sam.pkl", "function": "samwrite"}, {"comment_all": {"comment": "/* collision with other robots are checked here */", "depth": 2, "reading_ease": 64.37, "reading_grade": 6.0, "line": 439}, "comment_text": "/* collision with other robots are checked here */", "comment_tokens": ["collision", "with", "other", "robots", "are", "checked", "here"], "ccode": ["\n", "/* This moves a single laser one frame. collisions with other robots or\n", "\tthe mothership is checked. */\n", "static void move_laser(struct state *st, int rindex, int index)\n", "{\n", "\tint x=0;\n", "\tint y=0;\n", "\tint z=0;\n", "\tint dx=0;\n", "\tint dy=0;\n", "\tstruct laser_state *laser;\n", "\tif(rindex>=0) {\n", "\t\tlaser = st->robots[rindex].lasers;\n", "\t}\n", "\telse {\n", "\t\tlaser = st->mother->lasers;\n", "\t}\n", "\tif(laser[index].active) {\n", "\t\t/* collision with other robots are checked here */\n", "\t\tfor(x=0;x<st->NUM_ROBOTS;x++) {\n", "\t\t\tif(x!=rindex) {\n", "\t\t\t\tif(st->robots[x].alive) {\n", "\t\t\t\t\ty = laser[index].start_x-st->robots[x].new_x;\n", "\t\t\t\t\tif(y<0) {\n", "\t\t\t\t\t\ty = st->robots[x].new_x-laser[index].start_x;\n", "\t\t\t\t\t}\n", "\t\t\t\t\tz = laser[index].start_y-st->robots[x].new_y;\n", "\t\t\t\t\tif(z<0) {\n", "\t\t\t\t\t\tz = st->robots[x].new_y-laser[index].start_y;\n", "\t\t\t\t\t}\n", "\t\t\t\t\tif((z<st->robots[x].radius-1)&&(y<st->robots[x].radius-1)) {\n", "\t\t\t\t\t\tst->robots[x].alive = 0;\n", "\t\t\t\t\t\tst->robots[x].death = 20;\n", "            if (st->black) XFillArc(st->dpy, st->window, st->black, st->robots[x].old_x, st->robots[x].old_y, st->robots[x].radius, st->robots[x].radius, 0, 360*64);\n", "            if (st->black) XFillArc(st->dpy, st->window, st->black, st->robots[x].new_x, st->robots[x].new_y, st->robots[x].radius, st->robots[x].radius, 0, 360*64);\n", "\t\t\t\t\t\tlaser[index].active = 0;\n", "\t\t\t\t\t\tx = st->NUM_ROBOTS;\n", "\t\t\t\t\t}\n", "\t\t\t\t\telse {\n", "\t\t\t\t\t\ty = laser[index].end_x-st->robots[x].new_x;\n", "\t\t\t\t\t\tif(y<0) {\n", "\t\t\t\t\t\t\ty = st->robots[x].new_x-laser[index].end_x;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tz = laser[index].end_y-st->robots[x].new_y;\n", "\t\t\t\t\t\tif(z<0) {\n", "\t\t\t\t\t\t\tz = st->robots[x].new_y-laser[index].end_y;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tif((z<st->robots[x].radius-1)&&(y<st->robots[x].radius-1)) {\n", "\t\t\t\t\t\t\tst->robots[x].alive = 0;\n", "\t\t\t\t\t\t\tst->robots[x].death = 20;\n", "            if (st->black) XFillArc(st->dpy, st->window, st->black, st->robots[x].old_x, st->robots[x].old_y, st->robots[x].radius, st->robots[x].radius, 0, 360*64);\n", "            if (st->black) XFillArc(st->dpy, st->window, st->black, st->robots[x].new_x, st->robots[x].new_y, st->robots[x].radius, st->robots[x].radius, 0, 360*64);\n", "\t\t\t\t\t\t\tlaser[index].active = 0;\n", "\t\t\t\t\t\t\tx = st->NUM_ROBOTS;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t\tif((st->MOTHER_SHIP)&&(rindex!=-1)) {\n", "\t\t\tif(laser[index].active) {\n", "\t\t\t\tif(st->mother->active) {\n", "\t\t\t\t\ty = laser[index].start_x-st->mother->new_x;\n", "\t\t\t\t\tif(y<0) {\n", "\t\t\t\t\t\ty = st->mother->new_x-laser[index].start_x;\n", "\t\t\t\t\t}\n", "\t\t\t\t\tz = laser[index].start_y-st->mother->y;\n", "\t\t\t\t\tif(z<0) {\n", "\t\t\t\t\t\tz = st->mother->y-laser[index].start_y;\n", "\t\t\t\t\t}\n", "\t\t\t\t\tif((z<st->MOTHER_SHIP_HEIGHT-1)&&(y<st->MOTHER_SHIP_WIDTH-1)) {\n", "\t\t\t\t\t\tlaser[index].active = 0;\n", "\t\t\t\t\t\tst->mother->active--;\n", "\t\t\t\t\t}\n", "\t\t\t\t\telse {\n", "\t\t\t\t\t\ty = laser[index].end_x-st->mother->new_x;\n", "\t\t\t\t\t\tif(y<0) {\n", "\t\t\t\t\t\t\ty = st->mother->new_x-laser[index].end_x;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tz = laser[index].end_y-st->mother->y;\n", "\t\t\t\t\t\tif(z<0) {\n", "\t\t\t\t\t\t\tz = st->mother->y-laser[index].end_y;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t\tif((z<st->MOTHER_SHIP_HEIGHT-1)&&(y<st->MOTHER_SHIP_WIDTH-1)) {\n", "\t\t\t\t\t\t\tlaser[index].active = 0;\n", "\t\t\t\t\t\t\tst->mother->active--;\n", "\t\t\t\t\t\t}\n", "\t\t\t\t\t}\n", "\n", "\t\t\t\t\tif(st->mother->active==0) {\n", "\t\t\t\t\t\tst->mother->death=20;\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\tif(laser[index].active) {\n", "\t\t\tdx = laser[index].start_x - laser[index].end_x;\n", "\t\t\tdy = laser[index].start_y - laser[index].end_y;\n", "\t\t\n", "\t\t\tlaser[index].start_x = laser[index].end_x;\n", "\t\t\tlaser[index].start_y = laser[index].end_y;\n", "\t\t\tlaser[index].end_x = laser[index].end_x-dx;\n", "\t\t\tlaser[index].end_y = laser[index].end_y-dy;\n", "\t\t\t\n", "\t\t\tif((laser[index].end_x < 0) || (laser[index].end_x >= st->xgwa.width) ||\n", "\t\t\t\t(laser[index].end_y < 0) || (laser[index].end_y >= st->xgwa.height)) {\n", "\t\t\t\tlaser[index].active = 0;\n", "\t\t\t}\t\t\t\t\n", "\t\t}\n", "\t}\n", "}\n"], "project": "xscreensaver-screensaver-bsod", "file": "blaster.pkl", "function": "move_laser"}, {"comment_all": {"comment": "/* Return IP header offset depending on the interface type */", "depth": 0, "reading_ease": 45.42, "reading_grade": 9.2, "line": 51}, "comment_text": "/* Return IP header offset depending on the interface type */", "comment_tokens": ["Return", "IP", "header", "offset", "depending", "on", "the", "interface", "type"], "ccode": ["\n", "/* Return IP header offset depending on the interface type */\n", "int get_packetoffset (int DataLinkType) {\n", "\n", "\tint PacketOffset;\n", "\t\n", "\tswitch (DataLinkType) {\n", "\t\tcase DLT_EN10MB:\n", "\t\tcase DLT_IEEE802:\n", "\t\t\tPacketOffset = POFF_ETH;\n", "\t\t\tbreak;\n", "\t\tcase DLT_PPP:\n", "\t\t\tPacketOffset = POFF_PPP;\n", "\t\t\tbreak;\n", "\t\tcase DLT_RAW:\n", "\t\t\tPacketOffset = POFF_RAW;\n", "\t\t\tbreak;\n", "\t\t/* For others we guess  */\n", "\t\tdefault:\n", "\t\t\tPacketOffset = 0;\n", "\t\t}\n", "\n", "\treturn PacketOffset;\n", "}\n"], "project": "ipband", "file": "pcapfunc.pkl", "function": "get_packetoffset"}, {"comment_all": {"comment": "// Android NDK does not expose sched_getaffinity\n", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 442}, "comment_text": "// Android NDK does not expose sched_getaffinity\n", "comment_tokens": ["Android", "NDK", "does", "not", "expose", "sched_getaffinity"], "ccode": ["\n", "#endif\n", "\n", "int x264_cpu_num_processors( void )\n", "{\n", "#if !HAVE_THREAD\n", "    return 1;\n", "\n", "#elif SYS_WINDOWS\n", "    return x264_pthread_num_processors_np();\n", "\n", "#elif SYS_CYGWIN || SYS_SunOS\n", "    return sysconf( _SC_NPROCESSORS_ONLN );\n", "\n", "#elif SYS_LINUX\n", "#ifdef __ANDROID__\n", "    // Android NDK does not expose sched_getaffinity\n", "    return sysconf( _SC_NPROCESSORS_CONF );\n", "#else\n", "    cpu_set_t p_aff;\n", "    memset( &p_aff, 0, sizeof(p_aff) );\n", "    if( sched_getaffinity( 0, sizeof(p_aff), &p_aff ) )\n", "        return 1;\n", "#if HAVE_CPU_COUNT\n", "    return CPU_COUNT(&p_aff);\n", "#else\n", "    int np = 0;\n", "    for( unsigned int bit = 0; bit < 8 * sizeof(p_aff); bit++ )\n", "        np += (((uint8_t *)&p_aff)[bit / 8] >> (bit % 8)) & 1;\n", "    return np;\n", "#endif\n", "#endif\n", "\n", "#elif SYS_BEOS\n", "    system_info info;\n", "    get_system_info( &info );\n", "    return info.cpu_count;\n", "\n", "#elif SYS_MACOSX || SYS_FREEBSD || SYS_OPENBSD\n", "    int ncpu;\n", "    size_t length = sizeof( ncpu );\n", "#if SYS_OPENBSD\n", "    int mib[2] = { CTL_HW, HW_NCPU };\n", "    if( sysctl(mib, 2, &ncpu, &length, NULL, 0) )\n", "#else\n", "    if( sysctlbyname(\"hw.ncpu\", &ncpu, &length, NULL, 0) )\n", "#endif\n", "    {\n", "        ncpu = 1;\n", "    }\n", "    return ncpu;\n", "\n", "#else\n", "    return 1;\n", "#endif\n", "}\n"], "project": "libx264-155", "file": "cpu.pkl", "function": "x264_cpu_num_processors"}, {"comment_all": {"comment": "/* Retrieves a string containing the language tag description\n */", "depth": 0, "reading_ease": 46.44, "reading_grade": 8.8, "line": 451}, "comment_text": "/* Retrieves a string containing the language tag description\n */", "comment_tokens": ["Retrieves", "a", "string", "containing", "the", "language", "tag", "description"], "ccode": ["\n", "/* Retrieves a string containing the language tag description\n", " */\n", "const char *libfwnt_locale_identifier_language_tag_get_description(\n", "             uint16_t lcid_language_tag )\n", "{\n", "\tint iterator = 0;\n", "\n", "\twhile( ( libfwnt_locale_identifier_language_tags[ iterator ] ).lcid_language_tag != (uint16_t) -1 )\n", "\t{\n", "\t\tif( ( libfwnt_locale_identifier_language_tags[ iterator ] ).lcid_language_tag == lcid_language_tag )\n", "\t\t{\n", "\t\t\tbreak;\n", "\t\t}\n", "\t\titerator++;\n", "\t}\n", "\treturn(\n", "\t ( libfwnt_locale_identifier_language_tags[ iterator ] ).description );\n", "}\n"], "project": "libevtx-utils", "file": "libfwnt_locale_identifier.pkl", "function": "libfwnt_locale_identifier_language_tag_get_description"}, {"comment_all": {"comment": "/* for easier debugging - removable */", "depth": 2, "reading_ease": -8.73, "reading_grade": 15.5, "line": 56}, "comment_text": "/* for easier debugging - removable */", "comment_tokens": ["for", "easier", "debugging", "-", "removable"], "ccode": ["\n", "void textblock_add(const byte *text, size_t size)\n", "{\n", "    textblock_t *t = textblocks;\n", "    size_t mem = size+sizeof(textdata_t);\n", "    textdata_t *cur = t->tail;\n", "\n", "    cur->size = size;\n", "    if (size == 0)\n", "\tcur->data = NULL;\n", "    else {\n", "\tcur->data = (byte *)xmalloc(size+D);\n", "\tmemcpy((char *)cur->data, (const char *)text, size+D);\n", "\tZ(((char *)cur->data)[size]);\t/* for easier debugging - removable */\n", "    }\n", "    cur_mem += mem;\n", "    tot_mem += mem;\n", "    max_mem = max(max_mem, cur_mem);\n", "    if (DEBUG_TEXT(2))\n", "\tfprintf(dbgout, \"%s:%d  %p %p %3lu *add* cur: %lu, max: %lu, tot: %lu\\n\", \n", "\t\t\t       __FILE__,__LINE__,\n", "\t\t\t       (void *)cur, (void *)cur->data,\n", "\t\t\t       (unsigned long)cur->size,\n", "\t\t\t       (unsigned long)cur_mem,\n", "\t\t\t       (unsigned long)max_mem,\n", "\t\t\t       (unsigned long)tot_mem );\n", "    cur = cur->next = (textdata_t *) xcalloc(1, sizeof(textdata_t));\n", "    t->tail = cur;\n", "}\n"], "project": "bogofilter", "file": "textblock.pkl", "function": "textblock_add"}, {"comment_all": {"comment": "/*************************************************************************\n  Check for valid base64url.\n*************************************************************************/", "depth": 0, "reading_ease": 118.18, "reading_grade": -2.3, "line": 364}, "comment_text": "/*************************************************************************\n  Check for valid base64url.\n*************************************************************************/", "comment_tokens": ["Check", "for", "valid", "base64url", "."], "ccode": ["\n", "/*************************************************************************\n", "  Check for valid base64url.\n", "*************************************************************************/\n", "bool is_base64url(const char *s)\n", "{\n", "  size_t i = 0;\n", "\n", "  /* must not be NULL or empty */\n", "  if (NULL == s || '\\0' == *s) {\n", "    return FALSE;\n", "  }\n", "\n", "  for (; '\\0' != s[i]; i++) {\n", "    if (NULL == strchr(base64url, s[i])) {\n", "      return FALSE;\n", "    }\n", "  }\n", "  return TRUE;\n", "}\n"], "project": "freeciv-data", "file": "shared.pkl", "function": "is_base64url"}, {"comment_all": {"comment": "/*\n *----------------------------------------------------------------------\n * RBlurImage--\n * \tApply 3x3 1 1 1 low pass, convolution mask to image.\n *                1 2 1\n *                1 1 1 /10\n *----------------------------------------------------------------------\n */", "depth": 0, "reading_ease": 87.21, "reading_grade": 3.5, "line": 29}, "comment_text": "/*\n *----------------------------------------------------------------------\n * RBlurImage--\n * \tApply 3x3 1 1 1 low pass, convolution mask to image.\n *                1 2 1\n *                1 1 1 /10\n *----------------------------------------------------------------------\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "RBlurImage", "--", "Apply", "3x3", "1", "1", "1", "low", "pass", ",", "convolution", "mask", "to", "image", ".", "1", "2", "1", "1", "1", "1", "10", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--"], "ccode": ["/*\n", " * Raster graphics library\n", " *\n", " * Copyright (c) 1997-2003 Alfredo K. Kojima\n", " *\n", " *  This library is free software; you can redistribute it and/or\n", " *  modify it under the terms of the GNU Library General Public\n", " *  License as published by the Free Software Foundation; either\n", " *  version 2 of the License, or (at your option) any later version.\n", " *\n", " *  This library is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " *  Library General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU Library General Public\n", " *  License along with this library; if not, write to the Free\n", " *  Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,\n", " *  MA 02110-1301, USA.\n", " */\n", "\n", "#include <config.h>\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <string.h>\n", "#include <X11/Xlib.h>\n", "#include \"wraster.h\"\n", "\n", "/*\n", " *----------------------------------------------------------------------\n", " * RBlurImage--\n", " * \tApply 3x3 1 1 1 low pass, convolution mask to image.\n", " *                1 2 1\n", " *                1 1 1 /10\n", " *----------------------------------------------------------------------\n", " */\n", "int RBlurImage(RImage * image)\n", "{\n", "\tregister int x, y;\n", "\tregister int tmp;\n", "\tunsigned char *ptr, *nptr;\n", "\tunsigned char *pptr = NULL, *tmpp;\n", "\tint ch = image->format == RRGBAFormat ? 4 : 3;\n", "\n", "\tpptr = malloc(image->width * ch);\n", "\tif (!pptr) {\n", "\t\tRErrorCode = RERR_NOMEMORY;\n", "\t\treturn False;\n", "\t}\n", "#define MASK(prev, cur, next, ch)\\\n", "    (*(prev-ch) + *prev + *(prev+ch)\\\n", "    +*(cur-ch) + 2 * *cur + *(cur+ch)\\\n", "    +*(next-ch) + *next + *(next+ch)) / 10\n", "\n", "\tmemcpy(pptr, image->data, image->width * ch);\n", "\n", "\tptr = image->data;\n", "\tnptr = ptr + image->width * ch;\n", "\ttmpp = pptr;\n", "\n", "\tif (ch == 3) {\n", "\t\tptr += 3;\n", "\t\tnptr += 3;\n", "\t\tpptr += 3;\n", "\n", "\t\tfor (y = 1; y < image->height - 1; y++) {\n", "\n", "\t\t\tfor (x = 1; x < image->width - 1; x++) {\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 3);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 3);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 3);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\t\t\t}\n", "\t\t\tpptr = tmpp;\n", "\t\t\tptr += 6;\n", "\t\t\tnptr += 6;\n", "\t\t\tpptr += 6;\n", "\t\t}\n", "\t} else {\n", "\t\tptr += 4;\n", "\t\tnptr += 4;\n", "\t\tpptr += 4;\n", "\n", "\t\tfor (y = 1; y < image->height - 1; y++) {\n", "\t\t\tfor (x = 1; x < image->width - 1; x++) {\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 4);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 4);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 4);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\n", "\t\t\t\ttmp = *ptr;\n", "\t\t\t\t*ptr = MASK(pptr, ptr, nptr, 4);\n", "\t\t\t\t*pptr = tmp;\n", "\t\t\t\tptr++;\n", "\t\t\t\tnptr++;\n", "\t\t\t\tpptr++;\n", "\t\t\t}\n", "\t\t\tpptr = tmpp;\n", "\t\t\tptr += 8;\n", "\t\t\tnptr += 8;\n", "\t\t\tpptr += 8;\n", "\t\t}\n", "\t}\n", "\n", "\tfree(tmpp);\n", "\n", "\treturn True;\n", "}\n"], "project": "wmaker-common", "file": "convolve.pkl", "function": "RBlurImage"}, {"comment_all": {"comment": "/* Wait until all jobs have finished */", "depth": 0, "reading_ease": 90.77, "reading_grade": 2.1, "line": 197}, "comment_text": "/* Wait until all jobs have finished */", "comment_tokens": ["Wait", "until", "all", "jobs", "have", "finished"], "ccode": ["\n", "\n", "/* Wait until all jobs have finished */\n", "void thpool_wait(thpool_* thpool_p){\n", "\tpthread_mutex_lock(&thpool_p->thcount_lock);\n", "\twhile (thpool_p->jobqueue.len || thpool_p->num_threads_working) {\n", "\t\tpthread_cond_wait(&thpool_p->threads_all_idle, &thpool_p->thcount_lock);\n", "\t}\n", "\tpthread_mutex_unlock(&thpool_p->thcount_lock);\n", "}\n"], "project": "libclamav9", "file": "thpool.pkl", "function": "thpool_wait"}, {"comment_all": {"comment": "/* If this fails, it's too late to try Timidity so pray that at least one works. */", "depth": 1, "reading_ease": 97.54, "reading_grade": 3.6, "line": 51}, "comment_text": "/* If this fails, it's too late to try Timidity so pray that at least one works. */", "comment_tokens": ["If", "this", "fails", ",", "it", "'s", "too", "late", "to", "try", "Timidity", "so", "pray", "that", "at", "least", "one", "works", "."], "ccode": ["\n", "int fluidsynth_load_soundfont(const char *path, void *data)\n", "{\n", "\t/* If this fails, it's too late to try Timidity so pray that at least one works. */\n", "\tfluidsynth.fluid_synth_sfload((fluid_synth_t*) data, path, 1);\n", "\treturn 1;\n", "}\n"], "project": "libsdl-mixer1.2", "file": "fluidsynth.pkl", "function": "fluidsynth_load_soundfont"}, {"comment_all": {"comment": "/* thread.c : glue functions for GLib.Thread\n *\n * Author: Alp Toker  <alp@atoker.com>\n *\n * Copyright (c) 2005 Alp Toker\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the Lesser GNU General \n * Public License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 62.58, "reading_grade": 8.8, "line": 0}, "comment_text": "/* thread.c : glue functions for GLib.Thread\n *\n * Author: Alp Toker  <alp@atoker.com>\n *\n * Copyright (c) 2005 Alp Toker\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the Lesser GNU General \n * Public License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["thread.c", ":", "glue", "functions", "for", "GLib.Thread", "Author", ":", "Alp", "Toker", "<", "alp", "@", "atoker.com", ">", "Copyright", "(", "c", ")", "2005", "Alp", "Toker", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "version", "2", "of", "the", "Lesser", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/* thread.c : glue functions for GLib.Thread\n", " *\n", " * Author: Alp Toker  <alp@atoker.com>\n", " *\n", " * Copyright (c) 2005 Alp Toker\n", " *\n", " * This program is free software; you can redistribute it and/or\n", " * modify it under the terms of version 2 of the Lesser GNU General \n", " * Public License as published by the Free Software Foundation.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this program; if not, write to the\n", " * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "\n", "#ifdef DISABLE_GTHREAD_CHECK\n", "#include <glib.h>\n", "#else\n", "#include <glib/gthread.h>\n", "#endif\n", "\n", "gboolean glibsharp_g_thread_supported (void);\n", "\n", "gboolean\n", "glibsharp_g_thread_supported ()\n", "{\n", "#ifdef DISABLE_GTHREAD_CHECK\n", "\treturn TRUE;\n", "#else\n", "\treturn g_thread_supported ();\n", "#endif\n", "}\n"], "project": "libglib2.0-cil", "file": "thread.pkl", "function": "glibsharp_g_thread_supported"}, {"comment_all": {"comment": "/*\n * 1394-Based Digital Camera Control Library\n * Basler Smart Feature Framework specific extensions\n * Copyright (C) 2006 Mikael Olenfalk, Tobii Technology AB, Stockholm Sweden\n *\n * Written by Mikael Olenfalk <mikael _DOT_ olenfalk _AT_ tobii _DOT_ com>\n * Version : 16/02/2005\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "depth": 0, "reading_ease": 46.1, "reading_grade": 13.0, "line": 0}, "comment_text": "/*\n * 1394-Based Digital Camera Control Library\n * Basler Smart Feature Framework specific extensions\n * Copyright (C) 2006 Mikael Olenfalk, Tobii Technology AB, Stockholm Sweden\n *\n * Written by Mikael Olenfalk <mikael _DOT_ olenfalk _AT_ tobii _DOT_ com>\n * Version : 16/02/2005\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */", "comment_tokens": ["1394-Based", "Digital", "Camera", "Control", "Library", "Basler", "Smart", "Feature", "Framework", "specific", "extensions", "Copyright", "(", "C", ")", "2006", "Mikael", "Olenfalk", ",", "Tobii", "Technology", "AB", ",", "Stockholm", "Sweden", "Written", "by", "Mikael", "Olenfalk", "<", "mikael", "_DOT_", "olenfalk", "_AT_", "tobii", "_DOT_", "com", ">", "Version", ":", "16022005", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/*\n", " * 1394-Based Digital Camera Control Library\n", " * Basler Smart Feature Framework specific extensions\n", " * Copyright (C) 2006 Mikael Olenfalk, Tobii Technology AB, Stockholm Sweden\n", " *\n", " * Written by Mikael Olenfalk <mikael _DOT_ olenfalk _AT_ tobii _DOT_ com>\n", " * Version : 16/02/2005\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", " */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <stdint.h>\n", "#include <inttypes.h>\n", "#include <string.h>\n", "\n", "#include <dc1394/dc1394.h>\n", "#include <dc1394/vendor/basler.h>\n", "\n", "int list_cameras (dc1394_t * d, dc1394camera_list_t * list)\n", "{\n", "    uint32_t i;\n", "    dc1394bool_t sff_available;\n", "    dc1394camera_t * camera;\n", "\n", "    for (i = 0; i < list->num; i++) {\n", "        sff_available = DC1394_FALSE;\n", "        camera = dc1394_camera_new (d, list->ids[i].guid);\n", "        dc1394_basler_sff_is_available (camera, &sff_available);\n", "\n", "        printf (\"%02d:0x%\"PRIx64\":%s:%s:%s\\n\", i, camera->guid,\n", "                camera->vendor, camera->model, sff_available ? \"SFF\" : \"NO SFF\");\n", "        dc1394_camera_free (camera);\n", "    }\n", "    return 0;\n", "}\n"], "project": "libdc1394-dev", "file": "basler_sff_extended_data.pkl", "function": "list_cameras"}, {"comment_all": {"comment": "/* \n   Copyright (C) Andrew Tridgell 1998\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n   \n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "depth": 0, "reading_ease": 56.39, "reading_grade": 11.2, "line": 0}, "comment_text": "/* \n   Copyright (C) Andrew Tridgell 1998\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n   \n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/", "comment_tokens": ["Copyright", "(", "C", ")", "Andrew", "Tridgell", "1998", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "675", "Mass", "Ave", ",", "Cambridge", ",", "MA", "02139", ",", "USA", "."], "ccode": ["/* \n", "   Copyright (C) Andrew Tridgell 1998\n", "   \n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2 of the License, or\n", "   (at your option) any later version.\n", "   \n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "   \n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software\n", "   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n", "*/\n", "\n", "/*\n", "  Utilities used in rzip\n", "\n", "  tridge, June 1996\n", "  */\n", "#include \"rzip.h\"\n", "\n", "\n", "void *Realloc(void *p, int size)\n", "{\n", "\tif (!p) return (void *)malloc(size);\n", "\treturn (void *)realloc(p, size);\n", "}\n"], "project": "rzip", "file": "util.pkl", "function": "Realloc"}, {"comment_all": {"comment": "/* Scrolling Menus\n\n * Copyright (C) 1998 J.A. Bezemer\n *\n * Licensed under the terms of the GNU General Public License.\n * ABSOLUTELY NO WARRANTY.\n * See the file `COPYING' in this directory.\n */", "depth": 0, "reading_ease": 64.57, "reading_grade": 5.9, "line": 0}, "comment_text": "/* Scrolling Menus\n\n * Copyright (C) 1998 J.A. Bezemer\n *\n * Licensed under the terms of the GNU General Public License.\n * ABSOLUTELY NO WARRANTY.\n * See the file `COPYING' in this directory.\n */", "comment_tokens": ["Scrolling", "Menus", "Copyright", "(", "C", ")", "1998", "J.A", ".", "Bezemer", "Licensed", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", ".", "ABSOLUTELY", "NO", "WARRANTY", ".", "See", "the", "file", "`", "COPYING", "'", "in", "this", "directory", "."], "ccode": ["/* Scrolling Menus\n", "\n", " * Copyright (C) 1998 J.A. Bezemer\n", " *\n", " * Licensed under the terms of the GNU General Public License.\n", " * ABSOLUTELY NO WARRANTY.\n", " * See the file `COPYING' in this directory.\n", " */\n", "\n", "#include \"scrollmenu.h\"\n", "#include <stdlib.h>\n", "#ifndef OLD_CURSES\n", "#include <ncurses.h>\n", "#else\n", "#include <curses.h>\n", "#endif\n", "\n", "\n", "void\n", "scrollmenu_display (scrollmenu_t * menu)\n", "{\n", "  int i, j, x1, y1;\n", "\n", "  if (menu->selected >= menu->number)\n", "    menu->selected = menu->number - 1;\n", "  /* May get selected=-1 if number==0... */\n", "  if (menu->selected < 0)\t/* ...so this one must be last! */\n", "    menu->selected = 0;\n", "  if (menu->selected < menu->firstonscreen)\n", "    menu->firstonscreen = menu->selected;\n", "  if (menu->selected >= menu->firstonscreen + menu->h)\n", "    menu->firstonscreen = menu->selected - menu->h + 1;\n", "\n", "  for (i = 0; i < menu->h; i++)\n", "    {\n", "      if (menu->firstonscreen + i == menu->selected && menu->hasfocus)\n", "\tattron (A_STANDOUT);\n", "\n", "      if (menu->firstonscreen + i < menu->number)\n", "\tmvaddnstr (menu->y + i,\n", "\t\t   menu->x,\n", "\t\t   menu->items[menu->firstonscreen + i],\n", "\t\t   menu->w);\n", "      else\n", "\tmove (menu->y + i, menu->x);\n", "\n", "      getyx (stdscr, y1, x1);\n", "\n", "      for (j = x1; j < menu->x + menu->w; j++)\n", "\taddch (' ');\n", "\n", "      if (menu->firstonscreen + i == menu->selected && menu->hasfocus)\n", "\tattroff (A_STANDOUT);\n", "    }\n", "\n", "  move (menu->y + menu->selected - menu->firstonscreen, menu->x);\n", "}\n"], "project": "gramofile", "file": "scrollmenu.pkl", "function": "scrollmenu_display"}, {"comment_all": {"comment": "/* atlc - arbitrary transmission line calculator, for the analysis of\ntransmission lines are directional couplers. \n\nCopyright (C) 2002. Dr. David Kirkby, PhD (G8WRB).\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either package_version 2\nof the License, or (at your option) any later package_version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\nUSA.\n\nDr. David Kirkby, e-mail drkirkby at gmail.com \n\n*/", "depth": 0, "reading_ease": 55.44, "reading_grade": 9.5, "line": 0}, "comment_text": "/* atlc - arbitrary transmission line calculator, for the analysis of\ntransmission lines are directional couplers. \n\nCopyright (C) 2002. Dr. David Kirkby, PhD (G8WRB).\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either package_version 2\nof the License, or (at your option) any later package_version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\nUSA.\n\nDr. David Kirkby, e-mail drkirkby at gmail.com \n\n*/", "comment_tokens": ["atlc", "-", "arbitrary", "transmission", "line", "calculator", ",", "for", "the", "analysis", "of", "transmission", "lines", "are", "directional", "couplers", ".", "Copyright", "(", "C", ")", "2002", ".", "Dr.", "David", "Kirkby", ",", "PhD", "(", "G8WRB", ")", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "package_version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "package_version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", ".", "Dr.", "David", "Kirkby", ",", "e-mail", "drkirkby", "at", "gmail.com"], "ccode": ["/* atlc - arbitrary transmission line calculator, for the analysis of\n", "transmission lines are directional couplers. \n", "\n", "Copyright (C) 2002. Dr. David Kirkby, PhD (G8WRB).\n", "\n", "This program is free software; you can redistribute it and/or\n", "modify it under the terms of the GNU General Public License\n", "as published by the Free Software Foundation; either package_version 2\n", "of the License, or (at your option) any later package_version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n", "USA.\n", "\n", "Dr. David Kirkby, e-mail drkirkby at gmail.com \n", "\n", "*/\n", "#include \"config.h\"\n", "\n", "#ifdef HAVE_STDLIB_H\n", "#include <stdlib.h>   \n", "#endif\n", "\n", "#include \"definitions.h\"\n", "#include \"exit_codes.h\"\n", "\n", "void usage_create_bmp_for_rect_in_rect(void)\n", "{\n", "      fprintf(stderr,\"Usage: create_bmp_for_rect_in_rect [-b bmp_size] [-f outfile] [-v] W H a b c d w h Er1 Er2 outfile.bmp\\n\\n\");\n", "      fprintf(stderr,\"Version %s\\n\",PACKAGE_VERSION);\n", "      fprintf(stderr,\"where W, H, a, b, c, d, w, and h  are all in mm or all in inches\\n\");      \n", "      fprintf(stderr,\"(they *must* use the same units. Non-integers allowed for all parameters)\\n\");\n", "      fprintf(stderr,\"outfile.bmp is the name of a file to writ the bitmap to\\n\");\n", "      fprintf(stderr,\"Options are:\\n\");\n", "      fprintf(stderr,\"  -C         \\n     Print copyright, licencing and distribution information.\\n\");\n", "      fprintf(stderr,\"  -b bmp_size\\n     Sets the size of the bitmap, in the range 1 to 15 (default %d).\\n\",DEFAULT_BMP_SIZE);\n", "      fprintf(stderr,\"  -v         \\n     Write diagnostic information to stderr\\n\");\n", "      fprintf(stderr,\"-----------------------------------------------------------------------  ^\\n\");\n", "      fprintf(stderr,\"|                                                                     |  |\\n\");\n", "      fprintf(stderr,\"|               Dielectric, permittivity=Er1                          |  |\\n\");\n", "      fprintf(stderr,\"|                                                                     |  |\\n\");\n", "      fprintf(stderr,\"|       <----------------d------------------------->                  |  |\\n\");\n", "      fprintf(stderr,\"|                                                                     |  |\\n\");\n", "      fprintf(stderr,\"|             <----------w----------->                                |  |\\n\");\n", "      fprintf(stderr,\"|             ------------------------   ^                            |  |\\n\");\n", "      fprintf(stderr,\"|             |                      |   |                            |  |\\n\");\n", "      fprintf(stderr,\"|             |  Metallic conductor  |   |                            |  H\\n\");\n", "      fprintf(stderr,\"|<-----b----->|  conductor (can be   |   c                            |  |\\n\");\n", "      fprintf(stderr,\"|             |  off-centre)         |   |                            |  |\\n\");\n", "      fprintf(stderr,\"|             |                      |   |                            |  |\\n\");\n", "      fprintf(stderr,\"|       |------------------------------------------- ^                |  |\\n\");\n", "      fprintf(stderr,\"|       |..........................................| |                |  |\\n\");\n", "      fprintf(stderr,\"|       |.....Dielectric, permittivity=Er2.........| |                |  |\\n\");\n", "      fprintf(stderr,\"|<--a-->|.......(can be off centre )...............| h                |  |\\n\");\n", "      fprintf(stderr,\"|       |..........................................| |                |  |\\n\");\n", "      fprintf(stderr,\"|       |..........................................| |                |  |\\n\");\n", "      fprintf(stderr,\"-----------------------------------------------------------------------  |\\n\");\n", "      fprintf(stderr,\"<----------------------------------W--------------------------------->\\n\\n\");\n", "      fprintf(stderr,\"Eg: create_bmp_for_rect_in_rect 250 100 20 100 4.25 205 45 15 1.0006 3.7 ms.bmp \\n\");\n", "      exit_with_msg_and_exit_code(\"\",PROGRAM_CALLED_WITH_WRONG_NUMBER_OF_ARGUMENTS);\n", "}\n"], "project": "atlc-examples", "file": "usage_create_bmp_for_rect_in_rect.pkl", "function": "usage_create_bmp_for_rect_in_rect"}, {"comment_all": {"comment": "// CIF2 must start with a magic code\n", "depth": 2, "reading_ease": 106.67, "reading_grade": 0.1, "line": 528}, "comment_text": "// CIF2 must start with a magic code\n", "comment_tokens": ["CIF2", "must", "start", "with", "a", "magic", "code"], "ccode": ["\n", "CIF *new_cif_from_cif_file( char *filename, cif_option_t co, cexception_t *ex )\n", "{\n", "    cexception_t inner;\n", "    FILE *in = NULL;\n", "\n", "    cexception_guard( inner ) {\n", "        if( filename ) {\n", "            in = fopenx( filename, \"r\", &inner );\n", "        } else {\n", "            in = stdin;\n", "        }\n", "    }\n", "    cexception_catch {\n", "        if( in ) {\n", "            fclosex( in, ex );\n", "            in = NULL;\n", "        }\n", "        if( co & CO_SUPPRESS_MESSAGES ) {\n", "            cexception_t inner2;\n", "            cexception_try( inner2 ) {\n", "                CIF *cif = new_cif( &inner2 );\n", "                cif_set_yyretval( cif, -1 );\n", "                cif_set_nerrors( cif, 1 );\n", "                cif_set_message( cif, filename, \"ERROR\",\n", "                                 cexception_message( &inner ),\n", "                                 cexception_syserror( &inner ),\n", "                                 &inner2 );\n", "                return cif;\n", "            }\n", "            cexception_catch {\n", "                cexception_raise\n", "                    ( ex, CIF_OUT_OF_MEMORY_ERROR,\n", "                      \"not enough memory to record CIF error message\" );\n", "            }\n", "        } else {\n", "            cexception_reraise( inner, ex );\n", "        }\n", "    }\n", "\n", "    int ch = getc( in );\n", "    if( ch == 239 ) { /* U+FEFF detected */\n", "        ch = getc( in );\n", "        ch = getc( in );\n", "        ch = getc( in );\n", "    }\n", "\n", "    // Determining the version of CIF\n", "    int is_cif2 = 1;    \n", "    if( ch != '#' ) { // CIF2 must start with a magic code\n", "        ungetc( ch, in );\n", "        is_cif2 = 0;\n", "    } else {\n", "        char header[10];\n", "        int i;\n", "        for( i = 0; i < 9; i++ ) {\n", "            ch = getc( in );\n", "            if( ch == EOF || ch == '\\r' || ch == '\\n' ) {\n", "                is_cif2 = 0;\n", "                break;\n", "            }\n", "            header[i] = ch;\n", "        }\n", "\n", "        if( is_cif2 ) {\n", "            header[9] = '\\0';\n", "            if( strcmp( header, \"\\\\#CIF_2.0\" ) ) {\n", "                is_cif2 = 0;\n", "            } else {\n", "                /* The magic code may be followed by tabs and spaces,\n", "                 * but anything else is not allowed */\n", "                while( ch != EOF && ch != '\\r' && ch != '\\n' ) {\n", "                    ch = getc( in );\n", "                    if( ch != ' ' && ch != '\\t' && ch != EOF &&\n", "                        ch != '\\r' && ch != '\\n' ) {\n", "                        is_cif2 = 0;\n", "                    }\n", "                }\n", "                \n", "            }\n", "        }\n", "\n", "        /* Eat up the rest of the comment line */\n", "        while( ch != EOF && ch != '\\t' && ch != '\\n' ) {\n", "            ch = getc( in );\n", "        }\n", "        \n", "        /* If last read character is CR, it must be checked whether it\n", "         * is CR or CR + NL type end-of-line. In any case the\n", "         * end-of-line symbol must be discarded */\n", "        if( ch == '\\r' ) {\n", "            ch = getc( in );\n", "            if( ch != '\\n' ) {\n", "                ungetc( ch, in );\n", "            }\n", "        }\n", "\n", "        /* As the first line is eaten, numeration must start from 2 */\n", "        co = cif_option_count_lines_from_2( co );\n", "    }\n", "\n", "    CIF *cif;\n", "    if( !is_cif2 ) {\n", "        cif = new_cif_from_cif1_file( in, filename, co, ex );\n", "    } else {\n", "        cif = new_cif_from_cif2_file( in, filename, co, ex );\n", "    }\n", "\n", "    fclosex( in, ex );\n", "    return cif;\n", "}\n"], "project": "libgetoptions-dev", "file": "cif_compiler.pkl", "function": "new_cif_from_cif_file"}, {"comment_all": {"comment": "/* Indicate that we're done.  */", "depth": 2, "reading_ease": 75.88, "reading_grade": 3.7, "line": 842}, "comment_text": "/* Indicate that we're done.  */", "comment_tokens": ["Indicate", "that", "we", "'re", "done", "."], "ccode": ["\f\n", "/* Parse the next argument in PARSER (as indicated by PARSER->state.next).\n", "   Any error from the parsers is returned, and *ARGP_EBADKEY indicates\n", "   whether a value of EBADKEY is due to an unrecognized argument (which is\n", "   generally not fatal).  */\n", "static error_t\n", "parser_parse_next (struct parser *parser, int *arg_ebadkey)\n", "{\n", "  int opt;\n", "  error_t err = 0;\n", "\n", "  if (parser->state.quoted && parser->state.next < parser->state.quoted)\n", "    /* The next argument pointer has been moved to before the quoted\n", "       region, so pretend we never saw the quoting \"--\", and give getopt\n", "       another chance.  If the user hasn't removed it, getopt will just\n", "       process it again.  */\n", "    parser->state.quoted = 0;\n", "\n", "  if (parser->try_getopt && !parser->state.quoted)\n", "    /* Give getopt a chance to parse this.  */\n", "    {\n", "      /* Put it back in OPTIND for getopt.  */\n", "      parser->opt_data.optind = parser->state.next;\n", "      /* Distinguish KEY_ERR from a real option.  */\n", "      parser->opt_data.optopt = KEY_END;\n", "      if (parser->state.flags & ARGP_LONG_ONLY)\n", "        opt = _getopt_long_only_r (parser->state.argc, parser->state.argv,\n", "                                   parser->short_opts, parser->long_opts, 0,\n", "                                   &parser->opt_data);\n", "      else\n", "        opt = _getopt_long_r (parser->state.argc, parser->state.argv,\n", "                              parser->short_opts, parser->long_opts, 0,\n", "                              &parser->opt_data);\n", "      /* And see what getopt did.  */\n", "      parser->state.next = parser->opt_data.optind;\n", "\n", "      if (opt == KEY_END)\n", "        /* Getopt says there are no more options, so stop using\n", "           getopt; we'll continue if necessary on our own.  */\n", "        {\n", "          parser->try_getopt = 0;\n", "          if (parser->state.next > 1\n", "              && strcmp (parser->state.argv[parser->state.next - 1], QUOTE)\n", "                   == 0)\n", "            /* Not only is this the end of the options, but it's a\n", "               \"quoted\" region, which may have args that *look* like\n", "               options, so we definitely shouldn't try to use getopt past\n", "               here, whatever happens.  */\n", "            parser->state.quoted = parser->state.next;\n", "        }\n", "      else if (opt == KEY_ERR && parser->opt_data.optopt != KEY_END)\n", "        /* KEY_ERR can have the same value as a valid user short\n", "           option, but in the case of a real error, getopt sets OPTOPT\n", "           to the offending character, which can never be KEY_END.  */\n", "        {\n", "          *arg_ebadkey = 0;\n", "          return EBADKEY;\n", "        }\n", "    }\n", "  else\n", "    opt = KEY_END;\n", "\n", "  if (opt == KEY_END)\n", "    {\n", "      /* We're past what getopt considers the options.  */\n", "      if (parser->state.next >= parser->state.argc\n", "          || (parser->state.flags & ARGP_NO_ARGS))\n", "        /* Indicate that we're done.  */\n", "        {\n", "          *arg_ebadkey = 1;\n", "          return EBADKEY;\n", "        }\n", "      else\n", "        /* A non-option arg; simulate what getopt might have done.  */\n", "        {\n", "          opt = KEY_ARG;\n", "          parser->opt_data.optarg = parser->state.argv[parser->state.next++];\n", "        }\n", "    }\n", "\n", "  if (opt == KEY_ARG)\n", "    /* A non-option argument; try each parser in turn.  */\n", "    err = parser_parse_arg (parser, parser->opt_data.optarg);\n", "  else\n", "    err = parser_parse_opt (parser, opt, parser->opt_data.optarg);\n", "\n", "  if (err == EBADKEY)\n", "    *arg_ebadkey = (opt == KEY_END || opt == KEY_ARG);\n", "\n", "  return err;\n", "}\n"], "project": "grub-xen-dbg", "file": "argp-parse.pkl", "function": "parser_parse_next"}, {"comment_all": {"comment": "/*\n * section and descriptor parser\n *\n * Copyright (C) 2005 Kenneth Aafloy (kenneth@linuxtv.org)\n * Copyright (C) 2005 Andrew de Quincey (adq_dvb@lidskialf.net)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n */", "depth": 0, "reading_ease": 63.09, "reading_grade": 8.6, "line": 0}, "comment_text": "/*\n * section and descriptor parser\n *\n * Copyright (C) 2005 Kenneth Aafloy (kenneth@linuxtv.org)\n * Copyright (C) 2005 Andrew de Quincey (adq_dvb@lidskialf.net)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n */", "comment_tokens": ["section", "and", "descriptor", "parser", "Copyright", "(", "C", ")", "2005", "Kenneth", "Aafloy", "(", "kenneth", "@", "linuxtv.org", ")", "Copyright", "(", "C", ")", "2005", "Andrew", "de", "Quincey", "(", "adq_dvb", "@", "lidskialf.net", ")", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA"], "ccode": ["/*\n", " * section and descriptor parser\n", " *\n", " * Copyright (C) 2005 Kenneth Aafloy (kenneth@linuxtv.org)\n", " * Copyright (C) 2005 Andrew de Quincey (adq_dvb@lidskialf.net)\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n", " */\n", "\n", "#include <libucsi/mpeg/cat_section.h>\n", "\n", "struct mpeg_cat_section * mpeg_cat_section_codec(struct section_ext * ext)\n", "{\n", "\tuint8_t * buf = (uint8_t *)ext;\n", "\tsize_t pos = sizeof(struct section_ext);\n", "\n", "\tif (verify_descriptors(buf + pos,\n", "\t    \t\t       section_ext_length(ext) - sizeof(struct mpeg_cat_section)))\n", "\t\treturn NULL;\n", "\n", "\treturn (struct mpeg_cat_section *)ext;\n", "}\n"], "project": "dvb-apps", "file": "cat_section.pkl", "function": "mpeg_cat_section_codec"}, {"comment_all": {"comment": "// XXX: check memory alloc\n", "depth": 2, "reading_ease": 50.5, "reading_grade": 7.2, "line": 48}, "comment_text": "// XXX: check memory alloc\n", "comment_tokens": ["XXX", ":", "check", "memory", "alloc"], "ccode": ["/*\n", "    $Id: cddb_regex.c,v 1.16 2007/08/07 03:12:53 jcaratzas Exp $\n", "\n", "    Copyright (C) 2003, 2004, 2005 Kris Verbeeck <airborne@advalvas.be>\n", "\n", "    This library is free software; you can redistribute it and/or\n", "    modify it under the terms of the GNU Library General Public\n", "    License as published by the Free Software Foundation; either\n", "    version 2 of the License, or (at your option) any later version.\n", "\n", "    This library is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "    Library General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Library General Public\n", "    License along with this library; if not, write to the\n", "    Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", "    Boston, MA  02111-1307, USA.\n", "*/\n", "\n", "#include \"cddb/cddb_ni.h\"\n", "\n", "#ifdef HAVE_REGEX_H\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"cddb/cddb_regex.h\"\n", "\n", "\n", "regex_t *REGEX_TRACK_FRAME_OFFSETS = NULL;\n", "regex_t *REGEX_TRACK_FRAME_OFFSET = NULL;\n", "regex_t *REGEX_DISC_LENGTH = NULL;\n", "regex_t *REGEX_DISC_REVISION = NULL;\n", "regex_t *REGEX_DISC_TITLE = NULL;\n", "regex_t *REGEX_DISC_YEAR = NULL;\n", "regex_t *REGEX_DISC_GENRE = NULL;\n", "regex_t *REGEX_DISC_EXT = NULL;\n", "regex_t *REGEX_TRACK_TITLE = NULL;\n", "regex_t *REGEX_TRACK_EXT = NULL;\n", "regex_t *REGEX_PLAY_ORDER = NULL;\n", "regex_t *REGEX_QUERY_MATCH = NULL;\n", "regex_t *REGEX_SITE = NULL;\n", "regex_t *REGEX_TEXT_SEARCH = NULL;\n", "\n", "\n", "static int cddb_regex_init_1(regex_t **p, const char *regex)\n", "{\n", "    if ((*p = (regex_t*)malloc(sizeof(regex_t))) == NULL) {\n", "        // XXX: check memory alloc\n", "        return -1;\n", "    }\n", "    return regcomp(*p, regex, REG_EXTENDED);\n", "}\n"], "project": "libcddb2-dev", "file": "cddb_regex.pkl", "function": "cddb_regex_init_1"}, {"comment_all": {"comment": "/*-- compute the T vector --*/", "depth": 3, "reading_ease": 75.88, "reading_grade": 3.7, "line": 534}, "comment_text": "/*-- compute the T vector --*/", "comment_tokens": ["--", "compute", "the", "T", "vector", "--"], "ccode": ["\n", "\n", "/*---------------------------------------------------*/\n", "Int32 BZ2_decompress ( DState* s )\n", "{\n", "   UChar      uc;\n", "   Int32      retVal;\n", "   Int32      minLen, maxLen;\n", "   bz_stream* strm = s->strm;\n", "\n", "   /* stuff that needs to be saved/restored */\n", "   Int32  i;\n", "   Int32  j;\n", "   Int32  t;\n", "   Int32  alphaSize;\n", "   Int32  nGroups;\n", "   Int32  nSelectors;\n", "   Int32  EOB;\n", "   Int32  groupNo;\n", "   Int32  groupPos;\n", "   Int32  nextSym;\n", "   Int32  nblockMAX;\n", "   Int32  nblock;\n", "   Int32  es;\n", "   Int32  N;\n", "   Int32  curr;\n", "   Int32  zt;\n", "   Int32  zn; \n", "   Int32  zvec;\n", "   Int32  zj;\n", "   Int32  gSel;\n", "   Int32  gMinlen;\n", "   Int32* gLimit;\n", "   Int32* gBase;\n", "   Int32* gPerm;\n", "\n", "   if (s->state == BZ_X_MAGIC_1) {\n", "      /*initialise the save area*/\n", "      s->save_i           = 0;\n", "      s->save_j           = 0;\n", "      s->save_t           = 0;\n", "      s->save_alphaSize   = 0;\n", "      s->save_nGroups     = 0;\n", "      s->save_nSelectors  = 0;\n", "      s->save_EOB         = 0;\n", "      s->save_groupNo     = 0;\n", "      s->save_groupPos    = 0;\n", "      s->save_nextSym     = 0;\n", "      s->save_nblockMAX   = 0;\n", "      s->save_nblock      = 0;\n", "      s->save_es          = 0;\n", "      s->save_N           = 0;\n", "      s->save_curr        = 0;\n", "      s->save_zt          = 0;\n", "      s->save_zn          = 0;\n", "      s->save_zvec        = 0;\n", "      s->save_zj          = 0;\n", "      s->save_gSel        = 0;\n", "      s->save_gMinlen     = 0;\n", "      s->save_gLimit      = NULL;\n", "      s->save_gBase       = NULL;\n", "      s->save_gPerm       = NULL;\n", "   }\n", "\n", "   /*restore from the save area*/\n", "   i           = s->save_i;\n", "   j           = s->save_j;\n", "   t           = s->save_t;\n", "   alphaSize   = s->save_alphaSize;\n", "   nGroups     = s->save_nGroups;\n", "   nSelectors  = s->save_nSelectors;\n", "   EOB         = s->save_EOB;\n", "   groupNo     = s->save_groupNo;\n", "   groupPos    = s->save_groupPos;\n", "   nextSym     = s->save_nextSym;\n", "   nblockMAX   = s->save_nblockMAX;\n", "   nblock      = s->save_nblock;\n", "   es          = s->save_es;\n", "   N           = s->save_N;\n", "   curr        = s->save_curr;\n", "   zt          = s->save_zt;\n", "   zn          = s->save_zn; \n", "   zvec        = s->save_zvec;\n", "   zj          = s->save_zj;\n", "   gSel        = s->save_gSel;\n", "   gMinlen     = s->save_gMinlen;\n", "   gLimit      = s->save_gLimit;\n", "   gBase       = s->save_gBase;\n", "   gPerm       = s->save_gPerm;\n", "\n", "   retVal = BZ_OK;\n", "\n", "   switch (s->state) {\n", "\n", "      GET_UCHAR(BZ_X_MAGIC_1, uc);\n", "      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n", "\n", "      GET_UCHAR(BZ_X_MAGIC_2, uc);\n", "      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n", "\n", "      GET_UCHAR(BZ_X_MAGIC_3, uc)\n", "      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n", "\n", "      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n", "      if (s->blockSize100k < (BZ_HDR_0 + 1) || \n", "          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);\n", "      s->blockSize100k -= BZ_HDR_0;\n", "\n", "      if (s->smallDecompress) {\n", "         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n", "         s->ll4  = BZALLOC( \n", "                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar) \n", "                   );\n", "         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n", "      } else {\n", "         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n", "         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n", "      }\n", "\n", "      GET_UCHAR(BZ_X_BLKHDR_1, uc);\n", "\n", "      if (uc == 0x17) goto endhdr_2;\n", "      if (uc != 0x31) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_BLKHDR_2, uc);\n", "      if (uc != 0x41) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_BLKHDR_3, uc);\n", "      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_BLKHDR_4, uc);\n", "      if (uc != 0x26) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_BLKHDR_5, uc);\n", "      if (uc != 0x53) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_BLKHDR_6, uc);\n", "      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n", "\n", "      s->currBlockNo++;\n", "      if (s->verbosity >= 2)\n", "         VPrintf1 ( \"\\n    [%d: huff+mtf \", s->currBlockNo );\n", " \n", "      s->storedBlockCRC = 0;\n", "      GET_UCHAR(BZ_X_BCRC_1, uc);\n", "      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_BCRC_2, uc);\n", "      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_BCRC_3, uc);\n", "      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_BCRC_4, uc);\n", "      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n", "\n", "      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n", "\n", "      s->origPtr = 0;\n", "      GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n", "      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n", "      GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n", "      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n", "      GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n", "      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n", "\n", "      if (s->origPtr < 0)\n", "         RETURN(BZ_DATA_ERROR);\n", "      if (s->origPtr > 10 + 100000*s->blockSize100k) \n", "         RETURN(BZ_DATA_ERROR);\n", "\n", "      /*--- Receive the mapping table ---*/\n", "      for (i = 0; i < 16; i++) {\n", "         GET_BIT(BZ_X_MAPPING_1, uc);\n", "         if (uc == 1) \n", "            s->inUse16[i] = True; else \n", "            s->inUse16[i] = False;\n", "      }\n", "\n", "      for (i = 0; i < 256; i++) s->inUse[i] = False;\n", "\n", "      for (i = 0; i < 16; i++)\n", "         if (s->inUse16[i])\n", "            for (j = 0; j < 16; j++) {\n", "               GET_BIT(BZ_X_MAPPING_2, uc);\n", "               if (uc == 1) s->inUse[i * 16 + j] = True;\n", "            }\n", "      makeMaps_d ( s );\n", "      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n", "      alphaSize = s->nInUse+2;\n", "\n", "      /*--- Now the selectors ---*/\n", "      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n", "      if (nGroups < 2 || nGroups > BZ_N_GROUPS) RETURN(BZ_DATA_ERROR);\n", "      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n", "      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n", "      for (i = 0; i < nSelectors; i++) {\n", "         j = 0;\n", "         while (True) {\n", "            GET_BIT(BZ_X_SELECTOR_3, uc);\n", "            if (uc == 0) break;\n", "            j++;\n", "            if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n", "         }\n", "         /* Having more than BZ_MAX_SELECTORS doesn't make much sense\n", "            since they will never be used, but some implementations might\n", "            \"round up\" the number of selectors, so just ignore those. */\n", "         if (i < BZ_MAX_SELECTORS)\n", "           s->selectorMtf[i] = j;\n", "      }\n", "      if (nSelectors > BZ_MAX_SELECTORS)\n", "        nSelectors = BZ_MAX_SELECTORS;\n", "\n", "      /*--- Undo the MTF values for the selectors. ---*/\n", "      {\n", "         UChar pos[BZ_N_GROUPS], tmp, v;\n", "         for (v = 0; v < nGroups; v++) pos[v] = v;\n", "   \n", "         for (i = 0; i < nSelectors; i++) {\n", "            v = s->selectorMtf[i];\n", "            tmp = pos[v];\n", "            while (v > 0) { pos[v] = pos[v-1]; v--; }\n", "            pos[0] = tmp;\n", "            s->selector[i] = tmp;\n", "         }\n", "      }\n", "\n", "      /*--- Now the coding tables ---*/\n", "      for (t = 0; t < nGroups; t++) {\n", "         GET_BITS(BZ_X_CODING_1, curr, 5);\n", "         for (i = 0; i < alphaSize; i++) {\n", "            while (True) {\n", "               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);\n", "               GET_BIT(BZ_X_CODING_2, uc);\n", "               if (uc == 0) break;\n", "               GET_BIT(BZ_X_CODING_3, uc);\n", "               if (uc == 0) curr++; else curr--;\n", "            }\n", "            s->len[t][i] = curr;\n", "         }\n", "      }\n", "\n", "      /*--- Create the Huffman decoding tables ---*/\n", "      for (t = 0; t < nGroups; t++) {\n", "         minLen = 32;\n", "         maxLen = 0;\n", "         for (i = 0; i < alphaSize; i++) {\n", "            if (s->len[t][i] > maxLen) maxLen = s->len[t][i];\n", "            if (s->len[t][i] < minLen) minLen = s->len[t][i];\n", "         }\n", "         BZ2_hbCreateDecodeTables ( \n", "            &(s->limit[t][0]), \n", "            &(s->base[t][0]), \n", "            &(s->perm[t][0]), \n", "            &(s->len[t][0]),\n", "            minLen, maxLen, alphaSize\n", "         );\n", "         s->minLens[t] = minLen;\n", "      }\n", "\n", "      /*--- Now the MTF values ---*/\n", "\n", "      EOB      = s->nInUse+1;\n", "      nblockMAX = 100000 * s->blockSize100k;\n", "      groupNo  = -1;\n", "      groupPos = 0;\n", "\n", "      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;\n", "\n", "      /*-- MTF init --*/\n", "      {\n", "         Int32 ii, jj, kk;\n", "         kk = MTFA_SIZE-1;\n", "         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {\n", "            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n", "               s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);\n", "               kk--;\n", "            }\n", "            s->mtfbase[ii] = kk + 1;\n", "         }\n", "      }\n", "      /*-- end MTF init --*/\n", "\n", "      nblock = 0;\n", "      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n", "\n", "      while (True) {\n", "\n", "         if (nextSym == EOB) break;\n", "\n", "         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {\n", "\n", "            es = -1;\n", "            N = 1;\n", "            do {\n", "               /* Check that N doesn't get too big, so that es doesn't\n", "                  go negative.  The maximum value that can be\n", "                  RUNA/RUNB encoded is equal to the block size (post\n", "                  the initial RLE), viz, 900k, so bounding N at 2\n", "                  million should guard against overflow without\n", "                  rejecting any legitimate inputs. */\n", "               if (N >= 2*1024*1024) RETURN(BZ_DATA_ERROR);\n", "               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n", "               if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n", "               N = N * 2;\n", "               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n", "            }\n", "               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);\n", "\n", "            es++;\n", "            uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];\n", "            s->unzftab[uc] += es;\n", "\n", "            if (s->smallDecompress)\n", "               while (es > 0) {\n", "                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n", "                  s->ll16[nblock] = (UInt16)uc;\n", "                  nblock++;\n", "                  es--;\n", "               }\n", "            else\n", "               while (es > 0) {\n", "                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n", "                  s->tt[nblock] = (UInt32)uc;\n", "                  nblock++;\n", "                  es--;\n", "               };\n", "\n", "            continue;\n", "\n", "         } else {\n", "\n", "            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n", "\n", "            /*-- uc = MTF ( nextSym-1 ) --*/\n", "            {\n", "               Int32 ii, jj, kk, pp, lno, off;\n", "               UInt32 nn;\n", "               nn = (UInt32)(nextSym - 1);\n", "\n", "               if (nn < MTFL_SIZE) {\n", "                  /* avoid general-case expense */\n", "                  pp = s->mtfbase[0];\n", "                  uc = s->mtfa[pp+nn];\n", "                  while (nn > 3) {\n", "                     Int32 z = pp+nn;\n", "                     s->mtfa[(z)  ] = s->mtfa[(z)-1];\n", "                     s->mtfa[(z)-1] = s->mtfa[(z)-2];\n", "                     s->mtfa[(z)-2] = s->mtfa[(z)-3];\n", "                     s->mtfa[(z)-3] = s->mtfa[(z)-4];\n", "                     nn -= 4;\n", "                  }\n", "                  while (nn > 0) { \n", "                     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--; \n", "                  };\n", "                  s->mtfa[pp] = uc;\n", "               } else { \n", "                  /* general case */\n", "                  lno = nn / MTFL_SIZE;\n", "                  off = nn % MTFL_SIZE;\n", "                  pp = s->mtfbase[lno] + off;\n", "                  uc = s->mtfa[pp];\n", "                  while (pp > s->mtfbase[lno]) { \n", "                     s->mtfa[pp] = s->mtfa[pp-1]; pp--; \n", "                  };\n", "                  s->mtfbase[lno]++;\n", "                  while (lno > 0) {\n", "                     s->mtfbase[lno]--;\n", "                     s->mtfa[s->mtfbase[lno]] \n", "                        = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];\n", "                     lno--;\n", "                  }\n", "                  s->mtfbase[0]--;\n", "                  s->mtfa[s->mtfbase[0]] = uc;\n", "                  if (s->mtfbase[0] == 0) {\n", "                     kk = MTFA_SIZE-1;\n", "                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {\n", "                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n", "                           s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n", "                           kk--;\n", "                        }\n", "                        s->mtfbase[ii] = kk + 1;\n", "                     }\n", "                  }\n", "               }\n", "            }\n", "            /*-- end uc = MTF ( nextSym-1 ) --*/\n", "\n", "            s->unzftab[s->seqToUnseq[uc]]++;\n", "            if (s->smallDecompress)\n", "               s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else\n", "               s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);\n", "            nblock++;\n", "\n", "            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n", "            continue;\n", "         }\n", "      }\n", "\n", "      /* Now we know what nblock is, we can do a better sanity\n", "         check on s->origPtr.\n", "      */\n", "      if (s->origPtr < 0 || s->origPtr >= nblock)\n", "         RETURN(BZ_DATA_ERROR);\n", "\n", "      /*-- Set up cftab to facilitate generation of T^(-1) --*/\n", "      /* Check: unzftab entries in range. */\n", "      for (i = 0; i <= 255; i++) {\n", "         if (s->unzftab[i] < 0 || s->unzftab[i] > nblock)\n", "            RETURN(BZ_DATA_ERROR);\n", "      }\n", "      /* Actually generate cftab. */\n", "      s->cftab[0] = 0;\n", "      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];\n", "      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];\n", "      /* Check: cftab entries in range. */\n", "      for (i = 0; i <= 256; i++) {\n", "         if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n", "            /* s->cftab[i] can legitimately be == nblock */\n", "            RETURN(BZ_DATA_ERROR);\n", "         }\n", "      }\n", "      /* Check: cftab entries non-descending. */\n", "      for (i = 1; i <= 256; i++) {\n", "         if (s->cftab[i-1] > s->cftab[i]) {\n", "            RETURN(BZ_DATA_ERROR);\n", "         }\n", "      }\n", "\n", "      s->state_out_len = 0;\n", "      s->state_out_ch  = 0;\n", "      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );\n", "      s->state = BZ_X_OUTPUT;\n", "      if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n", "\n", "      if (s->smallDecompress) {\n", "\n", "         /*-- Make a copy of cftab, used in generation of T --*/\n", "         for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];\n", "\n", "         /*-- compute the T vector --*/\n", "         for (i = 0; i < nblock; i++) {\n", "            uc = (UChar)(s->ll16[i]);\n", "            SET_LL(i, s->cftabCopy[uc]);\n", "            s->cftabCopy[uc]++;\n", "         }\n", "\n", "         /*-- Compute T^(-1) by pointer reversal on T --*/\n", "         i = s->origPtr;\n", "         j = GET_LL(i);\n", "         do {\n", "            Int32 tmp = GET_LL(j);\n", "            SET_LL(j, i);\n", "            i = j;\n", "            j = tmp;\n", "         }\n", "            while (i != s->origPtr);\n", "\n", "         s->tPos = s->origPtr;\n", "         s->nblock_used = 0;\n", "         if (s->blockRandomised) {\n", "            BZ_RAND_INIT_MASK;\n", "            BZ_GET_SMALL(s->k0); s->nblock_used++;\n", "            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n", "         } else {\n", "            BZ_GET_SMALL(s->k0); s->nblock_used++;\n", "         }\n", "\n", "      } else {\n", "\n", "         /*-- compute the T^(-1) vector --*/\n", "         for (i = 0; i < nblock; i++) {\n", "            uc = (UChar)(s->tt[i] & 0xff);\n", "            s->tt[s->cftab[uc]] |= (i << 8);\n", "            s->cftab[uc]++;\n", "         }\n", "\n", "         s->tPos = s->tt[s->origPtr] >> 8;\n", "         s->nblock_used = 0;\n", "         if (s->blockRandomised) {\n", "            BZ_RAND_INIT_MASK;\n", "            BZ_GET_FAST(s->k0); s->nblock_used++;\n", "            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n", "         } else {\n", "            BZ_GET_FAST(s->k0); s->nblock_used++;\n", "         }\n", "\n", "      }\n", "\n", "      RETURN(BZ_OK);\n", "\n", "\n", "\n", "    endhdr_2:\n", "\n", "      GET_UCHAR(BZ_X_ENDHDR_2, uc);\n", "      if (uc != 0x72) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_ENDHDR_3, uc);\n", "      if (uc != 0x45) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_ENDHDR_4, uc);\n", "      if (uc != 0x38) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_ENDHDR_5, uc);\n", "      if (uc != 0x50) RETURN(BZ_DATA_ERROR);\n", "      GET_UCHAR(BZ_X_ENDHDR_6, uc);\n", "      if (uc != 0x90) RETURN(BZ_DATA_ERROR);\n", "\n", "      s->storedCombinedCRC = 0;\n", "      GET_UCHAR(BZ_X_CCRC_1, uc);\n", "      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_CCRC_2, uc);\n", "      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_CCRC_3, uc);\n", "      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n", "      GET_UCHAR(BZ_X_CCRC_4, uc);\n", "      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n", "\n", "      s->state = BZ_X_IDLE;\n", "      RETURN(BZ_STREAM_END);\n", "\n", "      default: AssertH ( False, 4001 );\n", "   }\n", "\n", "   AssertH ( False, 4002 );\n", "\n", "   save_state_and_return:\n", "\n", "   s->save_i           = i;\n", "   s->save_j           = j;\n", "   s->save_t           = t;\n", "   s->save_alphaSize   = alphaSize;\n", "   s->save_nGroups     = nGroups;\n", "   s->save_nSelectors  = nSelectors;\n", "   s->save_EOB         = EOB;\n", "   s->save_groupNo     = groupNo;\n", "   s->save_groupPos    = groupPos;\n", "   s->save_nextSym     = nextSym;\n", "   s->save_nblockMAX   = nblockMAX;\n", "   s->save_nblock      = nblock;\n", "   s->save_es          = es;\n", "   s->save_N           = N;\n", "   s->save_curr        = curr;\n", "   s->save_zt          = zt;\n", "   s->save_zn          = zn;\n", "   s->save_zvec        = zvec;\n", "   s->save_zj          = zj;\n", "   s->save_gSel        = gSel;\n", "   s->save_gMinlen     = gMinlen;\n", "   s->save_gLimit      = gLimit;\n", "   s->save_gBase       = gBase;\n", "   s->save_gPerm       = gPerm;\n", "\n", "   return retVal;   \n", "}\n"], "project": "bzip2", "file": "decompress.pkl", "function": "BZ2_decompress"}, {"comment_all": {"comment": "/* re-sync libevdev's state, but we don't care about the actual\n           events here */", "depth": 2, "reading_ease": 84.68, "reading_grade": 4.4, "line": 246}, "comment_text": "/* re-sync libevdev's state, but we don't care about the actual\n           events here */", "comment_tokens": ["re-sync", "libevdev", "'s", "state", ",", "but", "we", "do", "n't", "care", "about", "the", "actual", "events", "here"], "ccode": ["\n", "static Bool\n", "EventDeviceOnHook(InputInfoPtr pInfo, SynapticsParameters * para)\n", "{\n", "    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;\n", "    struct eventcomm_proto_data *proto_data =\n", "        (struct eventcomm_proto_data *) priv->proto_data;\n", "    int ret;\n", "\n", "    if (libevdev_get_fd(proto_data->evdev) != -1) {\n", "        struct input_event ev;\n", "\n", "        libevdev_change_fd(proto_data->evdev, pInfo->fd);\n", "\n", "        /* re-sync libevdev's state, but we don't care about the actual\n", "           events here */\n", "        libevdev_next_event(proto_data->evdev, LIBEVDEV_READ_FLAG_FORCE_SYNC, &ev);\n", "        while (libevdev_next_event(proto_data->evdev,\n", "                    LIBEVDEV_READ_FLAG_SYNC, &ev) == LIBEVDEV_READ_STATUS_SYNC)\n", "            ;\n", "\n", "    } else\n", "        libevdev_set_fd(proto_data->evdev, pInfo->fd);\n", "\n", "\n", "    if (para->grab_event_device) {\n", "        /* Try to grab the event device so that data don't leak to /dev/input/mice */\n", "\n", "        ret = libevdev_grab(proto_data->evdev, LIBEVDEV_GRAB);\n", "        if (ret < 0) {\n", "            xf86IDrvMsg(pInfo, X_WARNING, \"can't grab event device, errno=%d\\n\",\n", "                        -ret);\n", "            return FALSE;\n", "        }\n", "    }\n", "\n", "    proto_data->need_grab = FALSE;\n", "\n", "    ret = libevdev_set_clock_id(proto_data->evdev, CLOCK_MONOTONIC);\n", "    proto_data->have_monotonic_clock = (ret == 0);\n", "\n", "    InitializeTouch(pInfo);\n", "\n", "    return TRUE;\n", "}\n"], "project": "xserver-xorg-input-synaptics", "file": "eventcomm.pkl", "function": "EventDeviceOnHook"}, {"comment_all": {"comment": "/* ignored, but must be passed with\n                                  * kernel < 2.6.9\n                                  */", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 213}, "comment_text": "/* ignored, but must be passed with\n                                  * kernel < 2.6.9\n                                  */", "comment_tokens": ["ignored", ",", "but", "must", "be", "passed", "with", "kernel", "<", "2.6.9"], "ccode": ["\n", "static apr_status_t impl_pollset_remove(apr_pollset_t *pollset,\n", "                                        const apr_pollfd_t *descriptor)\n", "{\n", "    pfd_elem_t *ep;\n", "    apr_status_t rv = APR_SUCCESS;\n", "    struct epoll_event ev = {0}; /* ignored, but must be passed with\n", "                                  * kernel < 2.6.9\n", "                                  */\n", "    int ret;\n", "\n", "    if (descriptor->desc_type == APR_POLL_SOCKET) {\n", "        ret = epoll_ctl(pollset->p->epoll_fd, EPOLL_CTL_DEL,\n", "                        descriptor->desc.s->socketdes, &ev);\n", "    }\n", "    else {\n", "        ret = epoll_ctl(pollset->p->epoll_fd, EPOLL_CTL_DEL,\n", "                        descriptor->desc.f->filedes, &ev);\n", "    }\n", "    if (ret < 0) {\n", "        rv = APR_NOTFOUND;\n", "    }\n", "\n", "    if (!(pollset->flags & APR_POLLSET_NOCOPY)) {\n", "        pollset_lock_rings();\n", "\n", "        for (ep = APR_RING_FIRST(&(pollset->p->query_ring));\n", "             ep != APR_RING_SENTINEL(&(pollset->p->query_ring),\n", "                                     pfd_elem_t, link);\n", "             ep = APR_RING_NEXT(ep, link)) {\n", "                \n", "            if (descriptor->desc.s == ep->pfd.desc.s) {\n", "                APR_RING_REMOVE(ep, link);\n", "                APR_RING_INSERT_TAIL(&(pollset->p->dead_ring),\n", "                                     ep, pfd_elem_t, link);\n", "                break;\n", "            }\n", "        }\n", "\n", "        pollset_unlock_rings();\n", "    }\n", "\n", "    return rv;\n", "}\n"], "project": "libapr1", "file": "epoll.pkl", "function": "impl_pollset_remove"}, {"comment_all": {"comment": "/*  ---------------------------------------------------------------------[<]-\n    Function: free_smtsmtp_chunk\n\n    Synopsis: frees a structure allocated by get_smtsmtp_chunk().\n    ---------------------------------------------------------------------[>]-*/", "depth": 0, "reading_ease": 28.5, "reading_grade": 11.5, "line": 8377}, "comment_text": "/*  ---------------------------------------------------------------------[<]-\n    Function: free_smtsmtp_chunk\n\n    Synopsis: frees a structure allocated by get_smtsmtp_chunk().\n    ---------------------------------------------------------------------[>]-*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "[", "<", "]", "-", "Function", ":", "free_smtsmtp_chunk", "Synopsis", ":", "frees", "a", "structure", "allocated", "by", "get_smtsmtp_chunk", "(", ")", ".", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-", "[", ">", "]", "-"], "ccode": ["\n", "\n", "/*  ---------------------------------------------------------------------[<]-\n", "    Function: free_smtsmtp_chunk\n", "\n", "    Synopsis: frees a structure allocated by get_smtsmtp_chunk().\n", "    ---------------------------------------------------------------------[>]-*/\n", "\n", "void\n", "free_smtsmtp_chunk (\n", "    struct_smtsmtp_chunk **params)\n", "{\n", "    mem_free ((*params)-> chunk);\n", "    mem_free (*params);\n", "    *params = NULL;\n", "}\n"], "project": "generator-scripting-language-examples", "file": "smtmsg.pkl", "function": "free_smtsmtp_chunk"}, {"comment_all": {"comment": "/* unused, dummy to suppress warning */", "depth": 1, "reading_ease": 49.48, "reading_grade": 7.6, "line": 256}, "comment_text": "/* unused, dummy to suppress warning */", "comment_tokens": ["unused", ",", "dummy", "to", "suppress", "warning"], "ccode": ["\n", "static void\n", "siginfo_handler(int sig)\n", "{\n", "    if (sig) { ; }      /* unused, dummy to suppress warning */\n", "    pr2serr(\"Progress report, continuing ...\\n\");\n", "    if (do_time)\n", "        calc_duration_throughput(1);\n", "    print_stats(\"  \");\n", "}\n"], "project": "sg3-utils-udev", "file": "sgp_dd.pkl", "function": "siginfo_handler"}, {"comment_all": {"comment": "//seconds\n", "depth": 2, "reading_ease": 36.62, "reading_grade": 8.4, "line": 223}, "comment_text": "// TODO: extract timecode from media or use time elapsed since start of app\n//frames\n//seconds\n//minutes\n//hours\n", "comment_tokens": ["TODO", ":", "extract", "timecode", "from", "media", "or", "use", "time", "elapsed", "since", "start", "of", "app", "frames", "seconds", "minutes", "hours"], "ccode": ["\n", "\n", "int subunit_status( avc1394_cmd_rsp *cr )\n", "{\n", "\tswitch ( cr->opcode )\n", "\t{\n", "\tcase AVC1394_VCR_CMD_OUTPUT_SIGNAL_MODE:\n", "\t\tcr->status = AVC1394_RESP_STABLE;\n", "\t\tcr->operand[0] = g_signal_mode;\n", "\t\tbreak;\n", "\tcase AVC1394_VCR_CMD_INPUT_SIGNAL_MODE:\n", "\t\tcr->status = AVC1394_RESP_STABLE;\n", "\t\tcr->operand[0] = g_signal_mode;\n", "\t\tbreak;\n", "\tcase AVC1394_VCR_CMD_TRANSPORT_STATE:\n", "\t\tcr->status = AVC1394_RESP_STABLE;\n", "\t\tcr->opcode = g_transport_mode;\n", "\t\tcr->operand[0] = g_transport_state;\n", "\t\tbreak;\n", "\tcase AVC1394_VCR_CMD_TIME_CODE:\n", "\t\tcr->status = AVC1394_RESP_STABLE;\n", "\t\tcr->operand[0] = AVC1394_VCR_OPERAND_RECORDING_TIME_STATUS;\n", "\t\t// TODO: extract timecode from media or use time elapsed since start of app\n", "\t\tcr->operand[1] = 1; //frames\n", "\t\tcr->operand[2] = 2; //seconds\n", "\t\tcr->operand[3] = 3; //minutes\n", "\t\tcr->operand[4] = 4; //hours\n", "\t\tbreak;\n", "\tcase AVC1394_VCR_CMD_MEDIUM_INFO:\n", "\t\tcr->status = AVC1394_RESP_STABLE;\n", "\t\tcr->operand[0] = AVC1394_VCR_OPERAND_MEDIUM_INFO_DVCR_STD;\n", "\t\tcr->operand[1] = AVC1394_VCR_OPERAND_MEDIUM_INFO_SVHS_OK;\n", "\t\tbreak;\n", "\tdefault:\n", "\t\tfprintf( stderr, \"subunit status command 0x%02x not supported\\n\", cr->opcode );\n", "\t\treturn 0;\n", "\t}\n", "\treturn 1;\n", "}\n"], "project": "libavc1394-dev", "file": "avc_vcr.pkl", "function": "subunit_status"}, {"comment_all": {"comment": "/*\n * This is the GNU Aspell Enchant Backend.\n * GNU Aspell is by Kevin Atkinson.  See http://aspell.net/\n */", "depth": 0, "reading_ease": 80.78, "reading_grade": 3.9, "line": 31}, "comment_text": "/*\n * This is the GNU Aspell Enchant Backend.\n * GNU Aspell is by Kevin Atkinson.  See http://aspell.net/\n */", "comment_tokens": ["This", "is", "the", "GNU", "Aspell", "Enchant", "Backend", ".", "GNU", "Aspell", "is", "by", "Kevin", "Atkinson", ".", "See", "http", ":", "aspell.net"], "ccode": ["/* enchant\n", " * Copyright (C) 2003,2004 Dom Lachowicz\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n", " * Boston, MA 02110-1301, USA.\n", " *\n", " * In addition, as a special exception, Dom Lachowicz\n", " * gives permission to link the code of this program with\n", " * non-LGPL Spelling Provider libraries (eg: a MSFT Office\n", " * spell checker backend) and distribute linked combinations including\n", " * the two.  You must obey the GNU Lesser General Public License in all\n", " * respects for all of the code used other than said providers.  If you modify\n", " * this file, you may extend this exception to your version of the\n", " * file, but you are not obligated to do so.  If you do not wish to\n", " * do so, delete this exception statement from your version.\n", " */\n", "\n", "/*\n", " * This is the GNU Aspell Enchant Backend.\n", " * GNU Aspell is by Kevin Atkinson.  See http://aspell.net/\n", " */\n", "\n", "#include \"config.h\"\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include <glib.h>\n", "#include <aspell.h>\n", "\n", "#include \"enchant-provider.h\"\n", "#include \"unused-parameter.h\"\n", "\n", "\n", "EnchantProvider *init_enchant_provider (void);\n", "\n", "static int\n", "aspell_dict_check (EnchantDict * me, const char *const word, size_t len)\n", "{\n", "\tAspellSpeller *manager = (AspellSpeller *) me->user_data;\n", "\n", "\tchar *normalizedWord = g_utf8_normalize (word, len, G_NORMALIZE_NFC);\n", "\tint val = aspell_speller_check (manager, normalizedWord, strlen(normalizedWord));\n", "\tg_free(normalizedWord);\n", "\n", "\tif (val == 0)\n", "\t\treturn 1;\n", "\telse if (val > 0)\n", "\t\treturn 0;\n", "\telse {\n", "\t\tenchant_dict_set_error (me, aspell_speller_error_message (manager));\n", "\t\treturn -1;\n", "\t}\n", "}\n"], "project": "libenchant-2-dev", "file": "enchant_aspell.pkl", "function": "aspell_dict_check"}, {"comment_all": {"comment": "/* \"- 2\" to take care of EOB's */", "depth": 1, "reading_ease": 116.15, "reading_grade": -1.5, "line": 3923}, "comment_text": "/* \"- 2\" to take care of EOB's */", "comment_tokens": ["``", "-", "2", "''", "to", "take", "care", "of", "EOB", "'s"], "ccode": ["\n", "/** Setup the input buffer state to scan directly from a user-specified character buffer.\n", " * @param base the character buffer\n", " * @param size the size in bytes of the character buffer\n", " * \n", " * @return the newly allocated buffer state object.\n", " */\n", "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n", "{\n", "\tYY_BUFFER_STATE b;\n", "    \n", "\tif ( size < 2 ||\n", "\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n", "\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n", "\t\t/* They forgot to leave room for the EOB's. */\n", "\t\treturn NULL;\n", "\n", "\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n", "\tif ( ! b )\n", "\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n", "\n", "\tb->yy_buf_size = (int) (size - 2);\t/* \"- 2\" to take care of EOB's */\n", "\tb->yy_buf_pos = b->yy_ch_buf = base;\n", "\tb->yy_is_our_buffer = 0;\n", "\tb->yy_input_file = NULL;\n", "\tb->yy_n_chars = b->yy_buf_size;\n", "\tb->yy_is_interactive = 0;\n", "\tb->yy_at_bol = 1;\n", "\tb->yy_fill_buffer = 0;\n", "\tb->yy_buffer_status = YY_BUFFER_NEW;\n", "\n", "\tyy_switch_to_buffer( b  );\n", "\n", "\treturn b;\n", "}\n"], "project": "linux-gcp-5.8-headers-5.8.0-1038", "file": "lexer.lex.pkl", "function": "yy_scan_buffer"}, {"comment_all": {"comment": "// a chain of switches, and if the caller wants the source\n", "depth": 1, "reading_ease": 94.15, "reading_grade": 2.9, "line": 1532}, "comment_text": "// fmt_swset_el() prints only the destination side of the\n// switch (!from_to), because it is the significant one in\n// a chain of switches, and if the caller wants the source\n// side they can add it outside.\n", "comment_tokens": ["fmt_swset_el", "(", ")", "prints", "only", "the", "destination", "side", "of", "the", "switch", "(", "!", "from_to", ")", ",", "because", "it", "is", "the", "significant", "one", "in", "a", "chain", "of", "switches", ",", "and", "if", "the", "caller", "wants", "the", "source", "side", "they", "can", "add", "it", "outside", "."], "ccode": ["\n", "#define SW_BUF_SIZE\t256\n", "#define NUM_SW_BUFS\t64\n", "\n", "static const char* fmt_swset_el(struct fpga_model* model, int y, int x,\n", "\tswidx_t sw, int from_to)\n", "{\n", "\tstatic char sw_buf[NUM_SW_BUFS][SW_BUF_SIZE];\n", "\tstatic int last_buf = 0;\n", "\tchar midstr[64];\n", "\n", "\tlast_buf = (last_buf+1)%NUM_SW_BUFS;\n", "\tif (fpga_switch_is_bidir(model, y, x, sw))\n", "\t\tstrcpy(midstr, \"<->\");\n", "\telse\n", "\t\tstrcpy(midstr, \"->\");\n", "\t// fmt_swset_el() prints only the destination side of the\n", "\t// switch (!from_to), because it is the significant one in\n", "\t// a chain of switches, and if the caller wants the source\n", "\t// side they can add it outside.\n", "\tsnprintf(sw_buf[last_buf], sizeof(sw_buf[0]), \"%s%s%s\",\n", "\t\t(from_to == SW_FROM) ? \"\"\n", "\t\t\t: fpga_switch_str(model, y, x, sw, SW_FROM),\n", "\t\tmidstr,\n", "\t\t(from_to == SW_TO) ? \"\"\n", "\t\t\t: fpga_switch_str(model, y, x, sw, SW_TO));\n", "\n", "\treturn sw_buf[last_buf];\n", "}\n"], "project": "libfpga0", "file": "control.pkl", "function": "fmt_swset_el"}, {"comment_all": {"comment": "/* Implements managements and declarations of CIF options, that can be\n   used, for instance, to modify behaviour of a CIF compiler. */", "depth": 0, "reading_ease": 34.26, "reading_grade": 13.5, "line": 7}, "comment_text": "/* Implements managements and declarations of CIF options, that can be\n   used, for instance, to modify behaviour of a CIF compiler. */", "comment_tokens": ["Implements", "managements", "and", "declarations", "of", "CIF", "options", ",", "that", "can", "be", "used", ",", "for", "instance", ",", "to", "modify", "behaviour", "of", "a", "CIF", "compiler", "."], "ccode": ["/*---------------------------------------------------------------------------*\\\n", "**$Author: antanas $\n", "**$Date: 2019-11-15 20:06:25 +0200 (Fri, 15 Nov 2019) $ \n", "**$Revision: 7424 $\n", "**$URL: svn://www.crystallography.net/cod-tools/tags/v2.10/src/components/codcif/cif_options.c $\n", "\\*---------------------------------------------------------------------------*/\n", "\n", "/* Implements managements and declarations of CIF options, that can be\n", "   used, for instance, to modify behaviour of a CIF compiler. */\n", "\n", "/* exports: */\n", "#include <cif_options.h>\n", "\n", "/* uses: */\n", "#include <cif_grammar_flex.h>\n", "\n", "cif_option_t cif_option_default( void )\n", "{\n", "    return 0;\n", "}\n"], "project": "libgetoptions0", "file": "cif_options.pkl", "function": "cif_option_default"}, {"comment_all": {"comment": "/* For the \"%m\" test.  */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 92}, "comment_text": "/* For the \"%m\" test.  */", "comment_tokens": ["For", "the", "``", "%", "m", "''", "test", "."], "ccode": ["\n", "\n", "\n", "static void\n", "one_test_x0 (const char *format, ...)\n", "{\n", "  va_list arg_ptr;\n", "\n", "  show (\"format: ->%s<-\\n\", format);\n", "\n", "  errno = ENOENT; /* For the \"%m\" test.  */\n", "  va_start (arg_ptr, format);\n", "#ifdef HAVE_VASPRINTF\n", "  one_test_rc1 = vasprintf (&one_test_buf1, format, arg_ptr);\n", "#else\n", "  one_test_rc1 = -1;\n", "#endif\n", "  va_end (arg_ptr);\n", "  if (one_test_rc1 == -1)\n", "    {\n", "      fail (\"   sys: errno=%d (%s)\\n\", errno, strerror (errno));\n", "      one_test_buf1 = NULL;\n", "    }\n", "  else\n", "    show (\"   sys: ->%s<-\\n\", one_test_buf1);\n", "}\n"], "project": "libgpg-error-mingw-w64-dev", "file": "t-printf.pkl", "function": "one_test_x0"}, {"comment_all": {"comment": "// from the last 28 bytes of compressed bgzf files.\n", "depth": 1, "reading_ease": 104.64, "reading_grade": 0.9, "line": 484}, "comment_text": "// Last 28 bytes of an uncompressed bgzf file which are different\n// from the last 28 bytes of compressed bgzf files.\n", "comment_tokens": ["Last", "28", "bytes", "of", "an", "uncompressed", "bgzf", "file", "which", "are", "different", "from", "the", "last", "28", "bytes", "of", "compressed", "bgzf", "files", "."], "ccode": ["\n", "int bgzf_check_EOF(BGZF *fp)\n", "{\n", "\tstatic uint8_t magic[28] = \"\\037\\213\\010\\4\\0\\0\\0\\0\\0\\377\\6\\0\\102\\103\\2\\0\\033\\0\\3\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n", "        // Last 28 bytes of an uncompressed bgzf file which are different\n", "        // from the last 28 bytes of compressed bgzf files.\n", "        static uint8_t magic2[28] = \"\\4\\0\\0\\0\\0\\0\\377\\6\\0\\102\\103\\2\\0\\036\\0\\1\\0\\0\\377\\377\\0\\0\\0\\0\\0\\0\\0\\0\";\n", "\tuint8_t buf[28];\n", "\toff_t offset;\n", "\toffset = _bgzf_tell((_bgzf_file_t)fp->fp);\n", "\tif (_bgzf_seek(fp->fp, -28, SEEK_END) < 0) return 0;\n", "\tint count = _bgzf_read(fp->fp, buf, 28);\n", "        if(count != 28)\n", "        {\n", "            fp->errcode |= BGZF_ERR_IO; // possibly truncated file\n", "            return(0);\n", "        }\n", "\t_bgzf_seek(fp->fp, offset, SEEK_SET);\n", "        if((memcmp(magic, buf, 28) == 0) || (memcmp(magic2, buf, 28) == 0))\n", "        {\n", "            return(1);\n", "        }\n", "        return(0);\n", "}\n"], "project": "libstatgen-dev", "file": "bgzf.pkl", "function": "bgzf_check_EOF"}, {"comment_all": {"comment": "/* so we don't copy twice at loop end */", "depth": 5, "reading_ease": 114.12, "reading_grade": -0.8, "line": 269}, "comment_text": "/* so we don't copy twice at loop end */\n/* exit loop after first substitution */\n", "comment_tokens": ["so", "we", "do", "n't", "copy", "twice", "at", "loop", "end", "exit", "loop", "after", "first", "substitution"], "ccode": ["\n", "\n", "void\n", "fix_month(VOID)\t\t\t/* convert full month names to macros*/\n", "{\t\t\t\t/* for better style-file customization */\n", "    size_t k;\t\t\t\t/* index into month_pair[] and s[] */\n", "    size_t token_length;\t\t/* token length */\n", "    const char *p;\t\t\t/* pointer to current_value[] */\n", "    char *s = shared_string;\t\t/* memory-saving device */\n", "    const char *token;\t\t\t/* pointer into current_value[] */\n", "\n", "    for (p = current_value;\n", "\t (token = month_token(p,&token_length)) != (const char*)NULL;\n", "\t p = (const char*)NULL)\n", "    {\n", "\tif (token_length == 1)\t\t/* just copy single-char tokens\t */\n", "\t   *s++ = *token;\n", "\telse\n", "\t{\n", "\t    for (k = 0; month_pair[k].old_name != (const char*)NULL; ++k)\n", "\t    {\n", "\t\tif ((strlen(month_pair[k].old_name) == token_length) &&\n", "\t\t    (strnicmp(month_pair[k].old_name,token,token_length) == 0))\n", "\t\t{\t\t\t/* change \"January\" to jan etc. */\n", "\t\t    (void)strcpy(s,\"\\\" # \");\n", "\t\t    if ((s >= (shared_string + 1)) &&\n", "\t\t\t(strncmp(s-1,\"\\\"\\\" # \",5) == 0))\n", "\t\t    {\t/* eliminate any concatenation with an empty string */\n", "\t\t\ts--;\n", "\t\t\t*s = '\\0';\t/* need string terminator for strcat() */\n", "\t\t    }\n", "\t\t    (void)strcat(s,month_pair[k].new_name);\n", "\t\t    (void)strcat(s,\" # \\\"\");\n", "\t\t    s = strchr(s,'\\0');\n", "\t\t    token_length = 0;\t/* so we don't copy twice at loop end */\n", "\t\t    break;\t\t/* exit loop after first substitution */\n", "\t\t}\n", "\t    }\t\t\t\t/* end for (k = 0, ...) */\n", "\t    (void)strncpy(s,token,token_length); /* no definition, just copy */\n", "\t    s += token_length;\n", "\t}\n", "\tif ((s >= (shared_string + 5)) && (strncmp(s-5,\" # \\\"\\\"\",5) == 0))\n", "\t    s -= 5;\t/* eliminate any concatenation with an empty string */\n", "    }\n", "    *s = '\\0';\t\t\t\t/* supply string terminator */\n", "    k = (size_t)(s - shared_string);\n", "    s = shared_string;\n", "    if (strncmp(s,\"\\\"\\\" # \",5) == 0)\n", "\t(void)strcpy(current_value,&s[5]); /* discard initial empty string */\n", "    else\n", "\t(void)strcpy(current_value,s);\n", "}\n"], "project": "bibclean", "file": "fix.pkl", "function": "fix_month"}, {"comment_all": {"comment": "/*\n   (c) Copyright 2012-2013  DirectFB integrated media GmbH\n   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)\n   (c) Copyright 2000-2004  Convergence (integrated media) GmbH\n\n   All rights reserved.\n\n   Written by Denis Oliver Kropp <dok@directfb.org>,\n              Andreas Shimokawa <andi@directfb.org>,\n              Marek Pikarski <mass@directfb.org>,\n              Sven Neumann <neo@directfb.org>,\n              Ville Syrj\u00e4l\u00e4 <syrjala@sci.fi> and\n              Claudio Ciccani <klan@users.sf.net>.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the\n   Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n*/", "depth": 0, "reading_ease": 58.48, "reading_grade": 8.3, "line": 0}, "comment_text": "/*\n   (c) Copyright 2012-2013  DirectFB integrated media GmbH\n   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)\n   (c) Copyright 2000-2004  Convergence (integrated media) GmbH\n\n   All rights reserved.\n\n   Written by Denis Oliver Kropp <dok@directfb.org>,\n              Andreas Shimokawa <andi@directfb.org>,\n              Marek Pikarski <mass@directfb.org>,\n              Sven Neumann <neo@directfb.org>,\n              Ville Syrj\u00e4l\u00e4 <syrjala@sci.fi> and\n              Claudio Ciccani <klan@users.sf.net>.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the\n   Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n*/", "comment_tokens": ["(", "c", ")", "Copyright", "2012-2013", "DirectFB", "integrated", "media", "GmbH", "(", "c", ")", "Copyright", "2001-2013", "The", "world", "wide", "DirectFB", "Open", "Source", "Community", "(", "directfb.org", ")", "(", "c", ")", "Copyright", "2000-2004", "Convergence", "(", "integrated", "media", ")", "GmbH", "All", "rights", "reserved", ".", "Written", "by", "Denis", "Oliver", "Kropp", "<", "dok", "@", "directfb.org", ">", ",", "Andreas", "Shimokawa", "<", "andi", "@", "directfb.org", ">", ",", "Marek", "Pikarski", "<", "mass", "@", "directfb.org", ">", ",", "Sven", "Neumann", "<", "neo", "@", "directfb.org", ">", ",", "Ville", "Syrj\u00e4l\u00e4", "<", "syrjala", "@", "sci.fi", ">", "and", "Claudio", "Ciccani", "<", "klan", "@", "users.sf.net", ">", ".", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/*\n", "   (c) Copyright 2012-2013  DirectFB integrated media GmbH\n", "   (c) Copyright 2001-2013  The world wide DirectFB Open Source Community (directfb.org)\n", "   (c) Copyright 2000-2004  Convergence (integrated media) GmbH\n", "\n", "   All rights reserved.\n", "\n", "   Written by Denis Oliver Kropp <dok@directfb.org>,\n", "              Andreas Shimokawa <andi@directfb.org>,\n", "              Marek Pikarski <mass@directfb.org>,\n", "              Sven Neumann <neo@directfb.org>,\n", "              Ville Syrj\u00e4l\u00e4 <syrjala@sci.fi> and\n", "              Claudio Ciccani <klan@users.sf.net>.\n", "\n", "   This library is free software; you can redistribute it and/or\n", "   modify it under the terms of the GNU Lesser General Public\n", "   License as published by the Free Software Foundation; either\n", "   version 2 of the License, or (at your option) any later version.\n", "\n", "   This library is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", "   Lesser General Public License for more details.\n", "\n", "   You should have received a copy of the GNU Lesser General Public\n", "   License along with this library; if not, write to the\n", "   Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", "   Boston, MA 02111-1307, USA.\n", "*/\n", "\n", "\n", "\n", "#include <config.h>\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <string.h>\n", "#include <dfb_types.h>\n", "\n", "#include <pthread.h>\n", "\n", "#include <directfb.h>\n", "\n", "#include <core/core.h>\n", "#include <core/coredefs.h>\n", "#include <core/coretypes.h>\n", "\n", "#include <core/gfxcard.h>\n", "#include <core/state.h>\n", "#include <core/palette.h>\n", "\n", "#include <misc/gfx_util.h>\n", "#include <misc/util.h>\n", "#include <misc/conf.h>\n", "\n", "#include <direct/clock.h>\n", "#include <direct/mem.h>\n", "#include <direct/memcpy.h>\n", "#include <direct/messages.h>\n", "#include <direct/util.h>\n", "\n", "#include <gfx/convert.h>\n", "#include <gfx/util.h>\n", "\n", "#include \"generic.h\"\n", "\n", "/**********************************************************************************************************************/\n", "/**********************************************************************************************************************/\n", "\n", "void gFillRectangle( CardState *state, DFBRectangle *rect )\n", "{\n", "     int          h;\n", "     GenefxState *gfxs = state->gfxs;\n", "\n", "     D_ASSERT( gfxs != NULL );\n", "\n", "     if (dfb_config->software_warn) {\n", "          D_WARN( \"FillRectangle (%4d,%4d-%4dx%4d) %6s, flags 0x%08x, color 0x%02x%02x%02x%02x\",\n", "                  DFB_RECTANGLE_VALS(rect), dfb_pixelformat_name(gfxs->dst_format), state->drawingflags,\n", "                  state->color.a, state->color.r, state->color.g, state->color.b );\n", "     }\n", "\n", "     D_ASSERT( state->clip.x1 <= rect->x );\n", "     D_ASSERT( state->clip.y1 <= rect->y );\n", "     D_ASSERT( state->clip.x2 >= (rect->x + rect->w - 1) );\n", "     D_ASSERT( state->clip.y2 >= (rect->y + rect->h - 1) );\n", "\n", "     CHECK_PIPELINE();\n", "\n", "     if (!Genefx_ABacc_prepare( gfxs, rect->w ))\n", "          return;\n", "\n", "     gfxs->length = rect->w;\n", "\n", "     Genefx_Aop_xy( gfxs, rect->x, rect->y );\n", "\n", "     h = rect->h;\n", "     while (h--) {\n", "          RUN_PIPELINE();\n", "\n", "          Genefx_Aop_next( gfxs );\n", "     }\n", "\n", "     Genefx_ABacc_flush( gfxs );\n", "}\n"], "project": "libdirectfb-bin", "file": "generic_fill_rectangle.pkl", "function": "gFillRectangle"}, {"comment_all": {"comment": "/* put an extra byte to the left */", "depth": 3, "reading_ease": 106.67, "reading_grade": 0.1, "line": 87}, "comment_text": "/* put an extra byte to the left */", "comment_tokens": ["put", "an", "extra", "byte", "to", "the", "left"], "ccode": ["\n", "static void array_generator(char **js, uint8_t **mp, size_t *mplen, size_t s)\n", "{\n", "  assert(s >= 0x10);\n", "  *js = jsbuf;\n", "  *mp = mpbuf;\n", "  (*js)[0] = '[';\n", "  size_t jsoff = 1;\n", "  size_t mpoff = 1;\n", "  char js_item_pattern[] = \"{\\\"mpack\\\":true,\\\"version\\\":[1,0,0]}\";\n", "  uint8_t mp_item_pattern[] = {\n", "    0x82, 0xa5, 0x6d, 0x70, 0x61, 0x63, 0x6b, 0xc3, 0xa7, 0x76,\n", "    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x93, 0x01, 0x00, 0x00};\n", "\n", "\n", "  if (s <= UINT16_MAX) {\n", "    (*mp)[0] = 0xdc;\n", "    if (s <= 0xff) {\n", "      /* put an extra byte to the left */\n", "      write_size_be(*mp + mpoff++, 0);\n", "      write_size_be(*mp + mpoff++, s);\n", "    } else {\n", "      write_size_be(*mp + mpoff, s);\n", "      mpoff += 2;\n", "    }\n", "  } else {\n", "    (*mp)[0] = 0xdd;\n", "    write_size_be(*mp + mpoff, s);\n", "    mpoff += 4;\n", "  }\n", "\n", "  for (size_t i = 0; i < s; i++) {\n", "    memcpy(*mp + mpoff, mp_item_pattern, sizeof(mp_item_pattern));\n", "    mpoff += sizeof(mp_item_pattern);\n", "    memcpy(*js + jsoff, js_item_pattern, sizeof(js_item_pattern) - 1);\n", "    jsoff += sizeof(js_item_pattern) - 1;\n", "    (*js)[jsoff++] = ',';\n", "  }\n", "  (*js)[--jsoff] = ']';\n", "  (*js)[++jsoff] = 0;\n", "  *mplen = mpoff;\n", "}\n"], "project": "libmpack0", "file": "fixtures.pkl", "function": "array_generator"}, {"comment_all": {"comment": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */", "depth": 0, "reading_ease": 38.99, "reading_grade": 9.6, "line": 58}, "comment_text": "/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */", "comment_tokens": ["Start", "MD5", "accumulation", ".", "Set", "bit", "count", "to", "0", "and", "buffer", "to", "mysterious", "initialization", "constants", "."], "ccode": ["#endif\n", "#endif\n", "\n", "/*\n", " * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n", " * initialization constants.\n", " */\n", "void MD5Init(struct MD5Context *ctx)\n", "{\n", "    ctx->buf[0] = 0x67452301;\n", "    ctx->buf[1] = 0xefcdab89;\n", "    ctx->buf[2] = 0x98badcfe;\n", "    ctx->buf[3] = 0x10325476;\n", "\n", "    ctx->bits[0] = 0;\n", "    ctx->bits[1] = 0;\n", "}\n"], "project": "gastman", "file": "md5.pkl", "function": "MD5Init"}, {"comment_all": {"comment": "/* Note about SIGSEGV_FAULT_ADDRESS_ALIGNMENT: It does not matter whether\n   fault_address is rounded off here because all intervals that we pass to\n   sigsegv_register are page-aligned.  */", "depth": 0, "reading_ease": 48.13, "reading_grade": 12.3, "line": 35}, "comment_text": "/* Note about SIGSEGV_FAULT_ADDRESS_ALIGNMENT: It does not matter whether\n   fault_address is rounded off here because all intervals that we pass to\n   sigsegv_register are page-aligned.  */", "comment_tokens": ["Note", "about", "SIGSEGV_FAULT_ADDRESS_ALIGNMENT", ":", "It", "does", "not", "matter", "whether", "fault_address", "is", "rounded", "off", "here", "because", "all", "intervals", "that", "we", "pass", "to", "sigsegv_register", "are", "page-aligned", "."], "ccode": ["/* Test the dispatcher.\n", "   Copyright (C) 2002-2006, 2008, 2011, 2016  Bruno Haible <bruno@clisp.org>\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program; if not, write to the Free Software Foundation,\n", "   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n", "\n", "#ifndef _MSC_VER\n", "# include <config.h>\n", "#endif\n", "\n", "#include \"sigsegv.h\"\n", "#include <stdint.h>\n", "#include <stdio.h>\n", "\n", "#if HAVE_SIGSEGV_RECOVERY\n", "\n", "#include \"mmaputil.h\"\n", "#include <stdlib.h>\n", "\n", "static sigsegv_dispatcher dispatcher;\n", "\n", "static volatile unsigned int logcount = 0;\n", "static volatile uintptr_t logdata[10];\n", "\n", "/* Note about SIGSEGV_FAULT_ADDRESS_ALIGNMENT: It does not matter whether\n", "   fault_address is rounded off here because all intervals that we pass to\n", "   sigsegv_register are page-aligned.  */\n", "\n", "static int\n", "area_handler (void *fault_address, void *user_arg)\n", "{\n", "  uintptr_t area = *(uintptr_t *)user_arg;\n", "  logdata[logcount++] = area;\n", "  if (logcount >= sizeof (logdata) / sizeof (logdata[0]))\n", "    abort ();\n", "  if (!((uintptr_t)fault_address >= area\n", "        && (uintptr_t)fault_address - area < 0x4000))\n", "    abort ();\n", "  if (mprotect ((void *) area, 0x4000, PROT_READ_WRITE) == 0)\n", "    return 1;\n", "  return 0;\n", "}\n"], "project": "libsigsegv-dev", "file": "sigsegv2.pkl", "function": "area_handler"}, {"comment_all": {"comment": "/*! \\brief\n * This method is used to parse the from header.\n *\n * \\note It was decided not to parse\n * anything in core that is not *needed* so this method gets called by\n * rad_acc module and any other modules that needs the FROM header.\n *\n * params: msg : sip msg\n * returns 0 on success,\n *        -1 on failure.\n */", "depth": 0, "reading_ease": 87.76, "reading_grade": 5.3, "line": 36}, "comment_text": "/*! \\brief\n * This method is used to parse the from header.\n *\n * \\note It was decided not to parse\n * anything in core that is not *needed* so this method gets called by\n * rad_acc module and any other modules that needs the FROM header.\n *\n * params: msg : sip msg\n * returns 0 on success,\n *        -1 on failure.\n */", "comment_tokens": ["!", "\\brief", "This", "method", "is", "used", "to", "parse", "the", "from", "header", ".", "\\note", "It", "was", "decided", "not", "to", "parse", "anything", "in", "core", "that", "is", "not", "needed", "so", "this", "method", "gets", "called", "by", "rad_acc", "module", "and", "any", "other", "modules", "that", "needs", "the", "FROM", "header", ".", "params", ":", "msg", ":", "sip", "msg", "returns", "0", "on", "success", ",", "-1", "on", "failure", "."], "ccode": ["/*\n", " * Copyright (C) 2001-2003 FhG Fokus\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " */\n", "\n", "/*! \\file\n", " * \\brief Parser :: SIP From header parsing\n", " *\n", " * \\ingroup parser\n", " */\n", "\n", "#include \"parse_from.h\"\n", "#include \"parse_to.h\"\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"../dprint.h\"\n", "#include \"msg_parser.h\"\n", "#include \"parse_uri.h\"\n", "#include \"../ut.h\"\n", "#include \"../mem/mem.h\"\n", "\n", "/*! \\brief\n", " * This method is used to parse the from header.\n", " *\n", " * \\note It was decided not to parse\n", " * anything in core that is not *needed* so this method gets called by\n", " * rad_acc module and any other modules that needs the FROM header.\n", " *\n", " * params: msg : sip msg\n", " * returns 0 on success,\n", " *        -1 on failure.\n", " */\n", "int parse_from_header(struct sip_msg *msg)\n", "{\n", "\tstruct to_body *from_b;\n", "\n", "\tif(!msg->from && (parse_headers(msg, HDR_FROM_F, 0) == -1 || !msg->from)) {\n", "\t\tLM_ERR(\"bad msg or missing FROM header\\n\");\n", "\t\tgoto error;\n", "\t}\n", "\n", "\t/* maybe the header is already parsed! */\n", "\tif(msg->from->parsed)\n", "\t\treturn 0;\n", "\n", "\t/* bad luck! :-( - we have to parse it */\n", "\t/* first, get some memory */\n", "\tfrom_b = pkg_malloc(sizeof(struct to_body));\n", "\tif(from_b == 0) {\n", "\t\tPKG_MEM_ERROR;\n", "\t\tgoto error;\n", "\t}\n", "\n", "\t/* now parse it!! */\n", "\tmemset(from_b, 0, sizeof(struct to_body));\n", "\tparse_to(msg->from->body.s, msg->from->body.s + msg->from->body.len + 1,\n", "\t\t\tfrom_b);\n", "\tif(from_b->error == PARSE_ERROR) {\n", "\t\tLM_ERR(\"bad From header [%.*s]\\n\", msg->from->body.len,\n", "\t\t\t\tmsg->from->body.s);\n", "\t\tfree_to(from_b);\n", "\t\tgoto error;\n", "\t}\n", "\tmsg->from->parsed = from_b;\n", "\n", "\treturn 0;\n", "error:\n", "\treturn -1;\n", "}\n"], "project": "kamailio-xmpp-modules", "file": "parse_from.pkl", "function": "parse_from_header"}, {"comment_all": {"comment": "/*\n     * Will the DDX tell us the client driver name?\n     */", "depth": 1, "reading_ease": 104.64, "reading_grade": 0.9, "line": 278}, "comment_text": "/*\n     * Will the DDX tell us the client driver name?\n     */", "comment_tokens": ["Will", "the", "DDX", "tell", "us", "the", "client", "driver", "name", "?"], "ccode": ["\n", "static void initW(Display *dpy, XvPortID port)\n", "{\n", "    char nameBuffer[BUFLEN];\n", "    void *handle;\n", "    int tmp;\n", "    char *clientName = NULL;\n", "    char *err;\n", "    FILE *configFile;\n", "    int nameLen = 0;\n", "    int major,minor,patchLevel,isLocal;\n", "    char *busID = NULL;\n", "\n", "    wrapperInit = 1;\n", "    xW.initialised = 0;\n", "\n", "    if (!wrapperPreInit)\n", "\tif (preInitW( dpy )) return;\n", "\n", "    /*\n", "     * Will the DDX tell us the client driver name?\n", "     */\n", "\n", "    xW.XvMCGetDRInfo = (XvMCGetDRInfoP)\n", "\tdlsym(handle2,\"XvMCGetDRInfo\");\n", "\n", "    if ((err = dlerror()) == NULL) {\n", "\tif (0 == xW.XvMCGetDRInfo( dpy, port, &clientName, &busID, &major,\n", "\t\t\t\t    &minor,&patchLevel, &isLocal)) {\n", "\t    nameLen = strlen(clientName);\n", "\t    XFree(busID);\n", "\t    if (!isLocal) {\n", "\t\tfprintf(stderr,\"XvMCWrapper: X server is not local. Cannot run XvMC.\\n\");\n", "\t\tXFree(clientName);\n", "\t\treturn;\n", "\t    }\n", "\t} else {\n", "\t    clientName = NULL;\n", "\t}\n", "    }\n", "\n", "    if (clientName && (nameLen < BUFLEN-7) && (nameLen > 0)) {\n", "\tnameLen += 3;\n", "\tstrncpy(nameBuffer,\"lib\",BUFLEN-1);\n", "\tstrncpy(nameBuffer+3, clientName, BUFLEN-4);\n", "\tstrncpy(nameBuffer + nameLen, \".so\", BUFLEN-nameLen-1);\n", "\tnameBuffer[BUFLEN-1] = 0;\n", "\tXFree(clientName);\n", "\thandle = dlopenversion(nameBuffer, XVMC_SOVERSION,RTLD_LAZY);\n", "    } else {\n", "\t/*\n", "\t * No. Try to obtain it from the config file.\n", "\t */\n", "\n", "\tif (clientName) XFree(clientName);\n", "\n", "\tconfigFile = fopen(STRS(XVMC_CONFIGDIR) \"/XvMCConfig\",\"r\");\n", "\n", "\txW.initialised = 0;\n", "\txW.vldextension = 0;\n", "\n", "\tif (NULL == configFile) {\n", "\t    fprintf(stderr,\"XvMCWrapper: Could not open config file \\\"%s\\\".\\n\",\n", "\t\t    STRS(XVMC_CONFIGDIR) \"/XvMCConfig\");\n", "\t    perror(\"XvMCWrapper\");\n", "\t    return;\n", "\t}\n", "\n", "\tif (NULL == fgets(nameBuffer, BUFLEN, configFile)) {\n", "\t    fclose(configFile);\n", "\t    fprintf(stderr,\"XvMCWrapper: Could not read XvMC library name.\\n\");\n", "\t    perror(\"XvMCWrapper\");\n", "\t    return;\n", "\t}\n", "\n", "\tfclose(configFile);\n", "\tif ((tmp = strlen(nameBuffer)) == 0) {\n", "\t    fprintf(stderr,\"XvMCWrapper: Zero length XvMC library name.\\n\");\n", "\t    fprintf(stderr,\"%s\\n\",dlerror());\n", "\t    return;\n", "\t}\n", "\n", "\t/*\n", "\t * Skip trailing newlines and garbage.\n", "\t */\n", "\n", "\twhile (iscntrl(nameBuffer[tmp-1])) {\n", "\t    nameBuffer[tmp-1] = 0;\n", "\t    if (--tmp == 0) {\n", "\t\tfprintf(stderr,\"XvMCWrapper: Zero length XvMC library name.\\n\");\n", "\t\treturn;\n", "\t    }\n", "\t}\n", "\thandle = dlopen(nameBuffer,RTLD_LAZY);\n", "    }\n", "    if (!handle) {\n", "\tfprintf(stderr,\"XvMCWrapper: Could not load hardware specific XvMC \"\n", "\t\t\"library \\\"%s\\\".\\n\",nameBuffer);\n", "\tfprintf(stderr,\"%s\\n\",dlerror());\n", "\treturn;\n", "    }\n", "\n", "    XW_RSYM(xW, handle, handle2, XvMCListSurfaceTypes,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCreateContext,);\n", "    XW_RSYM(xW, handle, handle2, XvMCDestroyContext,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCreateSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCDestroySurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCListSubpictureTypes,);\n", "    XW_RSYM(xW, handle, handle2, XvMCHideSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCreateSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCClearSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCompositeSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCDestroySubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCSetSubpicturePalette,);\n", "    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCBlendSubpicture2,);\n", "    XW_RSYM(xW, handle, handle2, XvMCPutSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCSyncSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCFlushSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCGetSurfaceStatus,);\n", "    XW_RSYM(xW, handle, handle2, XvMCRenderSurface,);\n", "    XW_RSYM(xW, handle, handle2, XvMCSyncSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCFlushSubpicture,);\n", "    XW_RSYM(xW, handle, handle2, XvMCGetSubpictureStatus,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCreateBlocks,);\n", "    XW_RSYM(xW, handle, handle2, XvMCDestroyBlocks,);\n", "    XW_RSYM(xW, handle, handle2, XvMCCreateMacroBlocks,);\n", "    XW_RSYM(xW, handle, handle2, XvMCDestroyMacroBlocks,);\n", "    XW_RSYM(xW, handle, handle2, XvMCQueryAttributes,);\n", "    XW_RSYM(xW, handle, handle2, XvMCSetAttribute,);\n", "    XW_RSYM(xW, handle, handle2, XvMCGetAttribute,);\n", "    xW.initialised = 1;\n", "    XW_RSYM2(xW, handle, handle2, XvMCBeginSurface);\n", "    XW_RSYM(xW, handle, handle2, XvMCLoadQMatrix,);\n", "    XW_RSYM(xW, handle, handle2, XvMCPutSlice,);\n", "    XW_RSYM(xW, handle, handle2, XvMCPutSlice2,);\n", "    xW.vldextension = 1;\n", "}\n"], "project": "libxvmc1", "file": "XvMCWrapper.pkl", "function": "initW"}, {"comment_all": {"comment": "/*\n * tio - a simple TTY terminal I/O application\n *\n * Copyright (c) 2017  Martin Lund\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */", "depth": 0, "reading_ease": 54.56, "reading_grade": 11.9, "line": 0}, "comment_text": "/*\n * tio - a simple TTY terminal I/O application\n *\n * Copyright (c) 2017  Martin Lund\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */", "comment_tokens": ["tio", "-", "a", "simple", "TTY", "terminal", "IO", "application", "Copyright", "(", "c", ")", "2017", "Martin", "Lund", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA", "."], "ccode": ["/*\n", " * tio - a simple TTY terminal I/O application\n", " *\n", " * Copyright (c) 2017  Martin Lund\n", " *\n", " * This program is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU General Public License\n", " * as published by the Free Software Foundation; either version 2\n", " * of the License, or (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n", " * 02110-1301, USA.\n", " */\n", "\n", "#include <sys/ioctl.h>\n", "#include <asm/ioctls.h>\n", "#include <asm/termbits.h>\n", "\n", "int setspeed2(int fd, int baudrate)\n", "{\n", "    struct termios2 tio;\n", "    int status;\n", "\n", "    status = ioctl(fd, TCGETS2, &tio);\n", "\n", "    // Set baudrate speed using termios2 interface\n", "    tio.c_cflag &= ~CBAUD;\n", "    tio.c_cflag |= BOTHER;\n", "    tio.c_ispeed = baudrate;\n", "    tio.c_ospeed = baudrate;\n", "\n", "    status = ioctl(fd, TCSETS2, &tio);\n", "\n", "    return status;\n", "}\n"], "project": "tio", "file": "setspeed2.pkl", "function": "setspeed2"}, {"comment_all": {"comment": "// we only want the correct string to be part of the message,\n", "depth": 1, "reading_ease": 84.68, "reading_grade": 4.4, "line": 69}, "comment_text": "// we only want the correct string to be part of the message,\n// the body may contain other stuff, too\n", "comment_tokens": ["we", "only", "want", "the", "correct", "string", "to", "be", "part", "of", "the", "message", ",", "the", "body", "may", "contain", "other", "stuff", ",", "too"], "ccode": ["\n", "gboolean\n", "botcheck_verify(const char *sender, const char *message)\n", "{\n", "\tconst char *correct = prefs_botcheck_answer();\n", "\n", "\t// we only want the correct string to be part of the message,\n", "\t// the body may contain other stuff, too\n", "\tif (strstr(message, correct))\n", "\t{\n", "\t\tpurple_debug_info(\"pidgin-pp\", \"Botcheck: Right answer\\n\");\n", "\t\treturn TRUE;\n", "\t}\n", "\telse\n", "\t{\n", "\t\tpurple_debug_info(\"pidgin-pp\",\n", "\t\t\t\"Botcheck: Wrong answer or initial message\\n\");\n", "\t\treturn FALSE;\n", "\t}\n", "}\n"], "project": "pidgin-privacy-please", "file": "botcheck.pkl", "function": "botcheck_verify"}, {"comment_all": {"comment": "/*+ The number of files referenced. +*/", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 27}, "comment_text": "/*+ The files that are queried. +*/\n/*+ The number of files referenced. +*/\n", "comment_tokens": ["+", "The", "files", "that", "are", "queried", ".", "+", "+", "The", "number", "of", "files", "referenced", ".", "+"], "ccode": ["/***************************************\n", "  $Header: /home/amb/CVS/cxref/query/output.c,v 1.6 2004-06-22 17:31:24 amb Exp $\n", "\n", "  C Cross Referencing & Documentation tool. Version 1.6.\n", "  ******************/ /******************\n", "  Written by Andrew M. Bishop\n", "\n", "  This file Copyright 1995,96,97,2004 Andrew M. Bishop\n", "  It may be distributed under the GNU Public License, version 2, or\n", "  any higher version.  See section COPYING of the GNU Public license\n", "  for conditions under which this file may be redistributed.\n", "  ***************************************/\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include \"memory.h\"\n", "#include \"datatype.h\"\n", "#include \"cxref.h\"\n", "#include \"query.h\"\n", "\n", "\n", "/*+ The command line switch that sets the amount of cross referencing to do. +*/\n", "extern int option_xref;\n", "\n", "extern File *files;             /*+ The files that are queried. +*/\n", "extern int n_files;             /*+ The number of files referenced. +*/\n", "\n", "extern Function *functions;     /*+ The functions that are queried. +*/\n", "extern int n_functions;         /*+ The number of functions referenced. +*/\n", "\n", "extern Variable *variables;     /*+ The variables that are queried. +*/\n", "extern int n_variables;         /*+ The number of variables referenced. +*/\n", "\n", "extern Typedef *typedefs;       /*+ The type definitions that are queried. +*/\n", "extern int n_typedefs;          /*+ The number of typedefs referenced. +*/\n", "\n", "/* Local fuctions */\n", "\n", "static void OutputFile(File file);\n", "static void OutputInclude(Include incl,int depth);\n", "static void OutputFunction(Function func);\n", "static void OutputVariable(Variable var);\n", "static void OutputTypedef(Typedef type);\n", "\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Ouput the cross references for the named thing.\n", "\n", "  char* name The name of the object to ouput the cross references for.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "void OutputCrossRef(char* name)\n", "{\n", " int i,any=0;\n", "\n", " for(i=0;i<n_files;i++)\n", "    if(!strcmp(name,files[i]->name))\n", "       {OutputFile(files[i]);any++;}\n", "\n", " for(i=0;i<n_typedefs;i++)\n", "    if(!strcmp(name,typedefs[i]->name))\n", "      {OutputTypedef(typedefs[i]);any++;}\n", "\n", " for(i=0;i<n_variables;i++)\n", "    if(!strcmp(name,variables[i]->name))\n", "      {OutputVariable(variables[i]);any++;}\n", "\n", " for(i=0;i<n_functions;i++)\n", "    if(!strcmp(name,functions[i]->name))\n", "      {OutputFunction(functions[i]);any++;}\n", "\n", " if(!any)\n", "    printf(\"cxref-query: No match for '%s'.\\n\",name);\n", "}\n"], "project": "cxref-doc", "file": "output.pkl", "function": "OutputCrossRef"}, {"comment_all": {"comment": "/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */", "depth": 1, "reading_ease": 31.89, "reading_grade": 12.3, "line": 3587}, "comment_text": "/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */", "comment_tokens": ["TODO", ".", "We", "should", "be", "able", "to", "replace", "this", "entire", "function", "body", "with", "yypop_buffer_state", "(", ")", ";", "yypush_buffer_state", "(", "new_buffer", ")", ";"], "ccode": ["\n", "/** Switch to a different input buffer.\n", " * @param new_buffer The new input buffer.\n", " * \n", " */\n", "    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n", "{\n", "    \n", "\t/* TODO. We should be able to replace this entire function body\n", "\t * with\n", "\t *\t\tyypop_buffer_state();\n", "\t *\t\tyypush_buffer_state(new_buffer);\n", "     */\n", "\tyyensure_buffer_stack ();\n", "\tif ( YY_CURRENT_BUFFER == new_buffer )\n", "\t\treturn;\n", "\n", "\tif ( YY_CURRENT_BUFFER )\n", "\t\t{\n", "\t\t/* Flush out information for old buffer. */\n", "\t\t*(yy_c_buf_p) = (yy_hold_char);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n", "\tyy_load_buffer_state(  );\n", "\n", "\t/* We don't actually know whether we did this switch during\n", "\t * EOF (yywrap()) processing, but the only time this flag\n", "\t * is looked at is after yywrap() is called, so it's safe\n", "\t * to go ahead and always set it.\n", "\t */\n", "\t(yy_did_buffer_switch_on_eof) = 1;\n", "}\n"], "project": "linux-buildinfo-5.10.0-1023-oem", "file": "lexer.lex.pkl", "function": "yy_switch_to_buffer"}, {"comment_all": {"comment": "/* Copy a box set to a clip\n *\n * @param boxes  The box set to copy from.\n * @param clip   The clip to copy to (return buffer).\n * @returns      Zero if the allocation failed (the clip will be set to\n *               all-clipped), otherwise non-zero.\n */", "depth": 0, "reading_ease": 83.66, "reading_grade": 4.8, "line": 266}, "comment_text": "/* Copy a box set to a clip\n *\n * @param boxes  The box set to copy from.\n * @param clip   The clip to copy to (return buffer).\n * @returns      Zero if the allocation failed (the clip will be set to\n *               all-clipped), otherwise non-zero.\n */", "comment_tokens": ["Copy", "a", "box", "set", "to", "a", "clip", "@", "param", "boxes", "The", "box", "set", "to", "copy", "from", ".", "@", "param", "clip", "The", "clip", "to", "copy", "to", "(", "return", "buffer", ")", ".", "@", "returns", "Zero", "if", "the", "allocation", "failed", "(", "the", "clip", "will", "be", "set", "to", "all-clipped", ")", ",", "otherwise", "non-zero", "."], "ccode": ["\n", "/* Copy a box set to a clip\n", " *\n", " * @param boxes  The box set to copy from.\n", " * @param clip   The clip to copy to (return buffer).\n", " * @returns      Zero if the allocation failed (the clip will be set to\n", " *               all-clipped), otherwise non-zero.\n", " */\n", "static cairo_bool_t\n", "_cairo_boxes_copy_to_clip (const cairo_boxes_t *boxes, cairo_clip_t *clip)\n", "{\n", "    /* XXX cow-boxes? */\n", "    if (boxes->num_boxes == 1) {\n", "\tclip->boxes = &clip->embedded_box;\n", "\tclip->boxes[0] = boxes->chunks.base[0];\n", "\tclip->num_boxes = 1;\n", "\treturn TRUE;\n", "    }\n", "\n", "    clip->boxes = _cairo_boxes_to_array (boxes, &clip->num_boxes);\n", "    if (unlikely (clip->boxes == NULL))\n", "    {\n", "\t_cairo_clip_set_all_clipped (clip);\n", "\treturn FALSE;\n", "    }\n", "\n", "    return TRUE;\n", "}\n"], "project": "libcairo2-dev", "file": "cairo-clip-boxes.pkl", "function": "_cairo_boxes_copy_to_clip"}, {"comment_all": {"comment": "/*----------------------------------------------------------------------------\n   Parse the content of a <datetime.iso8601> XML-RPC XML element, e.g. \n   \"20000301T00:00:00\".\n\n   'str' is that content.\n\n   Example of the format we parse: \"19980717T14:08:55\"\n   Note that this is not quite ISO 8601.  It's a bizarre combination of\n   two ISO 8601 formats.\n\n   Note that Xmlrpc-c recognizes various extensions of the XML-RPC\n   <datetime.iso8601> element type.\n\n   'str' may not be valid XML-RPC (with extensions).  In that case we fail\n   with fault code XMLRPC_PARSE_ERROR.\n-----------------------------------------------------------------------------*/", "depth": 1, "reading_ease": 72.22, "reading_grade": 5.1, "line": 433}, "comment_text": "/*----------------------------------------------------------------------------\n   Parse the content of a <datetime.iso8601> XML-RPC XML element, e.g. \n   \"20000301T00:00:00\".\n\n   'str' is that content.\n\n   Example of the format we parse: \"19980717T14:08:55\"\n   Note that this is not quite ISO 8601.  It's a bizarre combination of\n   two ISO 8601 formats.\n\n   Note that Xmlrpc-c recognizes various extensions of the XML-RPC\n   <datetime.iso8601> element type.\n\n   'str' may not be valid XML-RPC (with extensions).  In that case we fail\n   with fault code XMLRPC_PARSE_ERROR.\n-----------------------------------------------------------------------------*/", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "Parse", "the", "content", "of", "a", "<", "datetime.iso8601", ">", "XML-RPC", "XML", "element", ",", "e.g", ".", "``", "20000301T00:00:00", "''", ".", "'str", "'", "is", "that", "content", ".", "Example", "of", "the", "format", "we", "parse", ":", "``", "19980717T14:08:55", "''", "Note", "that", "this", "is", "not", "quite", "ISO", "8601", ".", "It", "'s", "a", "bizarre", "combination", "of", "two", "ISO", "8601", "formats", ".", "Note", "that", "Xmlrpc-c", "recognizes", "various", "extensions", "of", "the", "XML-RPC", "<", "datetime.iso8601", ">", "element", "type", ".", "'str", "'", "may", "not", "be", "valid", "XML-RPC", "(", "with", "extensions", ")", ".", "In", "that", "case", "we", "fail", "with", "fault", "code", "XMLRPC_PARSE_ERROR", ".", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "-"], "ccode": ["\n", "\n", "\n", "void\n", "xmlrpc_parseDatetime(xmlrpc_env *    const envP,\n", "                     const char *    const datetimeString,\n", "                     xmlrpc_value ** const valuePP) {\n", "/*----------------------------------------------------------------------------\n", "   Parse the content of a <datetime.iso8601> XML-RPC XML element, e.g. \n", "   \"20000301T00:00:00\".\n", "\n", "   'str' is that content.\n", "\n", "   Example of the format we parse: \"19980717T14:08:55\"\n", "   Note that this is not quite ISO 8601.  It's a bizarre combination of\n", "   two ISO 8601 formats.\n", "\n", "   Note that Xmlrpc-c recognizes various extensions of the XML-RPC\n", "   <datetime.iso8601> element type.\n", "\n", "   'str' may not be valid XML-RPC (with extensions).  In that case we fail\n", "   with fault code XMLRPC_PARSE_ERROR.\n", "-----------------------------------------------------------------------------*/\n", "    xmlrpc_datetime dt;\n", "\n", "#if HAVE_REGEX\n", "    parseDtRegex(envP, datetimeString, &dt);\n", "#else\n", "    /* Note: validation is not as strong without regex */\n", "    validateFormatNoRegex(envP, datetimeString);\n", "    if (!envP->fault_occurred)\n", "        parseDtNoRegex(envP, datetimeString, &dt);\n", "#endif\n", "\n", "    if (!envP->fault_occurred) {\n", "        validateXmlrpcDatetimeSome(envP, dt);\n", "\n", "        if (!envP->fault_occurred)\n", "            *valuePP = xmlrpc_datetime_new(envP, dt);\n", "    }\n", "}\n"], "project": "libxmlrpc-c++8v5", "file": "parse_datetime.pkl", "function": "xmlrpc_parseDatetime"}, {"comment_all": {"comment": "/*\n * returns malloc'ed buffer on success and NULL on failure\n */", "depth": 0, "reading_ease": 62.34, "reading_grade": 6.8, "line": 197}, "comment_text": "/*\n * returns malloc'ed buffer on success and NULL on failure\n */", "comment_tokens": ["returns", "malloc'ed", "buffer", "on", "success", "and", "NULL", "on", "failure"], "ccode": ["\n", "/*\n", " * returns malloc'ed buffer on success and NULL on failure\n", " */\n", "static const char *lookup_uid(const char *field, uid_t uid)\n", "{\n", "\tconst char *value;\n", "\tvalue = _auparse_lookup_interpretation(field);\n", "\tif (value)\n", "\t\treturn value;\n", "\tif (uid == 0)\n", "\t\treturn strdup(\"root\");\n", "\telse if (uid == -1)\n", "\t\treturn strdup(\"unset\");\n", "\telse {\n", "\t\tstruct passwd *pw;\n", "\t\tpw = getpwuid(uid);\n", "\t\tif (pw)\n", "\t\t\treturn strdup(pw->pw_name);\n", "\t}\n", "\treturn NULL;\n", "}\n"], "project": "libauparse-dev", "file": "ausearch-parse.pkl", "function": "lookup_uid"}, {"comment_all": {"comment": "/* TODO: try other languages as fallback? */", "depth": 1, "reading_ease": 56.93, "reading_grade": 6.8, "line": 51}, "comment_text": "/* TODO: try other languages as fallback? */", "comment_tokens": ["TODO", ":", "try", "other", "languages", "as", "fallback", "?"], "ccode": ["\n", "const char *\n", "libguess_determine_encoding(const char *inbuf, int buflen, const char *lang)\n", "{\n", "    guess_impl_f impl = guess_find_impl(lang);\n", "\n", "    if (impl != NULL)\n", "        return impl(inbuf, buflen);\n", "\n", "    /* TODO: try other languages as fallback? */\n", "    return NULL;\n", "}\n"], "project": "audacious", "file": "guess.pkl", "function": "libguess_determine_encoding"}, {"comment_all": {"comment": "/**\n * @brief return the log level - the local one if it set,\n *   otherwise the global value\n */", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 155}, "comment_text": "/**\n * @brief return the log level - the local one if it set,\n *   otherwise the global value\n */", "comment_tokens": ["@", "brief", "return", "the", "log", "level", "-", "the", "local", "one", "if", "it", "set", ",", "otherwise", "the", "global", "value"], "ccode": ["\n", "/**\n", " * @brief return the log level - the local one if it set,\n", " *   otherwise the global value\n", " */\n", "int get_debug_level(char *mname, int mnlen) {\n", "\tint mlevel;\n", "\t/*important -- no LOGs inside, because it will loop */\n", "\tif(unlikely(_module_debug_level!=NULL && mnlen>0)) {\n", "\t\tif(_module_debug_level(mname, mnlen, &mlevel)==0) {\n", "\t\t\treturn mlevel;\n", "\t\t}\n", "\t}\n", "\treturn (_local_debug_level != UNSET_LOCAL_DEBUG_LEVEL) ?\n", "\t\t\t\t_local_debug_level : cfg_get(core, core_cfg, debug);\n", "}\n"], "project": "kamailio-tls-modules", "file": "dprint.pkl", "function": "get_debug_level"}, {"comment_all": {"comment": "/* info->hostaliases may be NULL */", "depth": 1, "reading_ease": 33.58, "reading_grade": 9.6, "line": 105}, "comment_text": "/* info->hostaliases may be NULL */", "comment_tokens": ["info-", ">", "hostaliases", "may", "be", "NULL"], "ccode": ["\n", "static int\n", "gfarm_base_host_info_validate(void *vinfo)\n", "{\n", "\tstruct gfarm_host_info *info = vinfo;\n", "\n", "\t/* info->hostaliases may be NULL */\n", "\treturn (\n", "\t    info->hostname != NULL &&\n", "\t    info->architecture != NULL &&\n", "\t    info->ncpu != GFARM_HOST_INFO_NCPU_NOT_SET\n", "\t);\n", "}\n"], "project": "gfmd", "file": "metadb_common.pkl", "function": "gfarm_base_host_info_validate"}, {"comment_all": {"comment": "/* Have we already setup this archive?  */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 716}, "comment_text": "/* Have we already setup this archive?  */", "comment_tokens": ["Have", "we", "already", "setup", "this", "archive", "?"], "ccode": ["\n", "/* Open and setup a nested archive, if not already open.  */\n", "\n", "int\n", "setup_nested_archive (struct archive_info *nested_arch,\n", "\t\t      const char *member_file_name)\n", "{\n", "  FILE * member_file;\n", "\n", "  /* Have we already setup this archive?  */\n", "  if (nested_arch->file_name != NULL\n", "      && streq (nested_arch->file_name, member_file_name))\n", "    return 0;\n", "\n", "  /* Close previous file and discard cached information.  */\n", "  if (nested_arch->file != NULL)\n", "    fclose (nested_arch->file);\n", "  release_archive (nested_arch);\n", "\n", "  member_file = fopen (member_file_name, \"rb\");\n", "  if (member_file == NULL)\n", "    return 1;\n", "  return setup_archive (nested_arch, member_file_name, member_file,\n", "\t\t\tFALSE, FALSE);\n", "}\n"], "project": "binutils-i686-linux-gnu-dbg", "file": "elfcomm.pkl", "function": "setup_nested_archive"}, {"comment_all": {"comment": "/* Release the private data for an simple_object_write structure.  */", "depth": 0, "reading_ease": 46.44, "reading_grade": 8.8, "line": 1356}, "comment_text": "/* Release the private data for an simple_object_write structure.  */", "comment_tokens": ["Release", "the", "private", "data", "for", "an", "simple_object_write", "structure", "."], "ccode": ["\n", "/* Release the private data for an simple_object_write structure.  */\n", "\n", "static void\n", "simple_object_mach_o_release_write (void *data)\n", "{\n", "  XDELETE (data);\n", "}\n"], "project": "binutils-dev", "file": "simple-object-mach-o.pkl", "function": "simple_object_mach_o_release_write"}, {"comment_all": {"comment": "/*prints out an error message when allocating memory fails and exits*/", "depth": 0, "reading_ease": 51.85, "reading_grade": 8.8, "line": 36}, "comment_text": "/*prints out an error message when allocating memory fails and exits*/", "comment_tokens": ["prints", "out", "an", "error", "message", "when", "allocating", "memory", "fails", "and", "exits"], "ccode": ["\n", "/*prints out an error message when allocating memory fails and exits*/\n", "void printOomError()\n", "{\n", "\tprintf(\"Could not allocate enough memory, exiting..\\n\");\n", "\tfflush(stdout);\n", "\texit(1);\n", "}\n"], "project": "augustus", "file": "compileSpliceCands.pkl", "function": "printOomError"}, {"comment_all": {"comment": "/* Keep searching for the old PS3 block and skip over it\n\t\t * when we find it. */", "depth": 2, "reading_ease": 98.55, "reading_grade": 3.2, "line": 383}, "comment_text": "/* Keep searching for the old PS3 block and skip over it\n\t\t * when we find it. */", "comment_tokens": ["Keep", "searching", "for", "the", "old", "PS3", "block", "and", "skip", "over", "it", "when", "we", "find", "it", "."], "ccode": ["\n", "/**\n", " * iptc_jpeg_save_with_ps3:\n", " * @infile: the file stream from which the image data is copied\n", " * @outfile: the output file stream\n", " * @ps3: the Photoshop 3.0 header to add to the output file\n", " * @ps3_size: size in bytes of @ps3\n", " *\n", " * Takes an existing JPEG file, @infile, removes any existing Photoshop\n", " * 3.0 header from it, and adds a new PS3 header, writing the output\n", " * to @outfile.  @infile must be open for reading and is expected to point\n", " * to the beginning of the JPEG file, which should be different from @outfile,\n", " * which must be open for writing.  If @ps3 is NULL, the output will contain\n", " * no PS3 header.  PS3 headers reside in the APP13 section of the JPEG file,\n", " * which is created if necessary.  All other headers and data will be copied\n", " * directly from @infile without modification.\n", " *\n", " * Returns: 0 on success, -1 on error.  Note that even in error, some data\n", " * may have been written to @outfile, and its contents should be considered\n", " * undefined.\n", " */\n", "int\n", "iptc_jpeg_save_with_ps3 (FILE * infile, FILE * outfile,\n", "\t\tconst unsigned char * ps3, unsigned int ps3_size)\n", "{\n", "\tint s;\n", "\n", "\tif (!infile || !outfile)\n", "\t\treturn -1;\n", "\n", "\t/* Copy infile to outfile until we encounter the previous PS3\n", "\t * block, or the right place for the new PS3 block, whichever\n", "\t * comes first. */\n", "\ts = iptc_jpeg_seek_to_ps3 (infile, outfile, 1);\n", "\tif (s < 0)\n", "\t\treturn -1;\n", "\n", "\t/* Insert the new PS3 block */\n", "\tif (ps3) {\n", "\t\tunsigned char buf[4];\n", "\t\tbuf[0] = JPEG_MARKER;\n", "\t\tbuf[1] = JPEG_MARKER_APP13;\n", "\t\tiptc_set_short (buf+2, IPTC_BYTE_ORDER_MOTOROLA, ps3_size + 2);\n", "\t\tif (fwrite (buf, 1, 4, outfile) < 4)\n", "\t\t\treturn -1;\n", "\t\tif (fwrite (ps3, 1, ps3_size, outfile) < ps3_size)\n", "\t\t\treturn -1;\n", "\t}\n", "\n", "\tif (s > 0) {\n", "\t\t/* Skip over the old PS3 block if we've come upon it. */\n", "\t\tif (fseek (infile, 4 + s, SEEK_CUR) < 0)\n", "\t\t\treturn -1;\n", "\t}\n", "\telse {\n", "\t\t/* Keep searching for the old PS3 block and skip over it\n", "\t\t * when we find it. */\n", "\t\ts = iptc_jpeg_seek_to_ps3 (infile, outfile, 0);\n", "\t\tif (s < 0)\n", "\t\t\treturn -1;\n", "\t\tif (s > 0) {\n", "\t\t\tif (fseek (infile, 4 + s, SEEK_CUR) < 0)\n", "\t\t\t\treturn -1;\n", "\t\t}\n", "\t}\n", "\n", "\t/* Copy the remainder of the file */\n", "\tif (iptc_jpeg_seek_to_end (infile, outfile) < 0)\n", "\t\treturn -1;\n", "\n", "\treturn 0;\n", "}\n"], "project": "libiptcdata0", "file": "iptc-jpeg.pkl", "function": "iptc_jpeg_save_with_ps3"}, {"comment_all": {"comment": "/* has now reached t                */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 42}, "comment_text": "/* Indicate progress towards goal   */\n/* has now reached t                */\n", "comment_tokens": ["Indicate", "progress", "towards", "goal", "has", "now", "reached", "t"], "ccode": ["\n", "Void soFar(t)                          /* Indicate progress towards goal   */\n", "Target t; {                            /* has now reached t                */\n", "    if (quiet\n", "#if EXPLAIN_INSTANCE_RESOLUTION\n", "\t      || showInstRes\n", "#endif\n", "\t\t\t    ) return;\n", "    if (useDots) {\n", "\tInt newPos = (Int)((maxPos * ((long)t))/currTarget);\n", "\n", "\tif (newPos>maxPos)\n", "\t    newPos = maxPos;\n", "\n", "\tif (newPos>currPos) {\n", "\t    do\n", "\t\tPutchar('.');\n", "\t    while (newPos>++currPos);\n", "\t    FlushStdout();\n", "\t}\n", "\tFlushStdout();\n", "    }\n", "}\n"], "project": "libhugs-time-bundled", "file": "goal.pkl", "function": "soFar"}, {"comment_all": {"comment": "/* This shouldn't happen. */", "depth": 1, "reading_ease": 59.97, "reading_grade": 5.6, "line": 152}, "comment_text": "/* This shouldn't happen. */", "comment_tokens": ["This", "should", "n't", "happen", "."], "ccode": ["\n", "void FlipByteOrder(uint8_t *src, uint32_t count)\n", "{\n", "   uint8_t *start=src;\n", "   uint8_t *end=src+count-1;\n", "\n", "   if((count&1) || !count)\n", "      return; /* This shouldn't happen. */\n", "\n", "   count >>= 1;\n", "\n", "   while(count--)\n", "   {\n", "      uint8_t tmp = *end;\n", "\n", "      *end=*start;\n", "      *start=tmp;\n", "      end--;\n", "      start++;\n", "   }\n", "}\n"], "project": "libretro-beetle-wswan", "file": "mednafen-endian.pkl", "function": "FlipByteOrder"}, {"comment_all": {"comment": "// STOP_TIMER(\"encode line\") }\n", "depth": 2, "reading_ease": -6.7, "reading_grade": 14.7, "line": 308}, "comment_text": "// STOP_TIMER(\"encode line\") }\n", "comment_tokens": ["STOP_TIMER", "(", "``", "encode", "line", "''", ")", "}"], "ccode": ["\n", "#define TYPE int16_t\n", "#define RENAME(name) name\n", "#include \"ffv1enc_template.c\"\n", "#undef TYPE\n", "#undef RENAME\n", "\n", "#define TYPE int32_t\n", "#define RENAME(name) name ## 32\n", "#include \"ffv1enc_template.c\"\n", "\n", "static int encode_plane(FFV1Context *s, uint8_t *src, int w, int h,\n", "                         int stride, int plane_index, int pixel_stride)\n", "{\n", "    int x, y, i, ret;\n", "    const int ring_size = s->context_model ? 3 : 2;\n", "    int16_t *sample[3];\n", "    s->run_index = 0;\n", "\n", "    memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));\n", "\n", "    for (y = 0; y < h; y++) {\n", "        for (i = 0; i < ring_size; i++)\n", "            sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;\n", "\n", "        sample[0][-1]= sample[1][0  ];\n", "        sample[1][ w]= sample[1][w-1];\n", "// { START_TIMER\n", "        if (s->bits_per_raw_sample <= 8) {\n", "            for (x = 0; x < w; x++)\n", "                sample[0][x] = src[x * pixel_stride + stride * y];\n", "            if((ret = encode_line(s, w, sample, plane_index, 8)) < 0)\n", "                return ret;\n", "        } else {\n", "            if (s->packed_at_lsb) {\n", "                for (x = 0; x < w; x++) {\n", "                    sample[0][x] = ((uint16_t*)(src + stride*y))[x];\n", "                }\n", "            } else {\n", "                for (x = 0; x < w; x++) {\n", "                    sample[0][x] = ((uint16_t*)(src + stride*y))[x] >> (16 - s->bits_per_raw_sample);\n", "                }\n", "            }\n", "            if((ret = encode_line(s, w, sample, plane_index, s->bits_per_raw_sample)) < 0)\n", "                return ret;\n", "        }\n", "// STOP_TIMER(\"encode line\") }\n", "    }\n", "    return 0;\n", "}\n"], "project": "gstreamer1.0-libav", "file": "ffv1enc.pkl", "function": "encode_plane"}, {"comment_all": {"comment": "// Conditional assembly (\"!if\"). Has to be re-entrant.\n", "depth": 0, "reading_ease": 38.99, "reading_grade": 9.6, "line": 275}, "comment_text": "// Conditional assembly (\"!if\"). Has to be re-entrant.\n// Now GotByte = illegal char\n", "comment_tokens": ["Conditional", "assembly", "(", "``", "!", "if", "''", ")", ".", "Has", "to", "be", "re-entrant", ".", "Now", "GotByte", "=", "illegal", "char"], "ccode": ["\n", "// Conditional assembly (\"!if\"). Has to be re-entrant.\n", "static enum eos_t PO_if(void) {// Now GotByte = illegal char\n", "\tintval_t\tcond;\n", "\n", "\tcond = ALU_defined_int();\n", "\tif(GotByte != CHAR_SOB)\n", "\t\tThrow_serious_error(exception_no_left_brace);\n", "\tparse_block_else_block(!!cond);\n", "\treturn(ENSURE_EOS);\n", "}\n"], "project": "cheesecutter", "file": "flow.pkl", "function": "PO_if"}, {"comment_all": {"comment": "/* avc_init needs to be called before this function */", "depth": 1, "reading_ease": 88.74, "reading_grade": 2.9, "line": 72}, "comment_text": "/* avc_init needs to be called before this function */", "comment_tokens": ["avc_init", "needs", "to", "be", "called", "before", "this", "function"], "ccode": ["\n", "int avc_context_to_sid_raw(const char * ctx, security_id_t * sid)\n", "{\n", "\tint rc;\n", "\t/* avc_init needs to be called before this function */\n", "\tassert(avc_running);\n", "\n", "\tavc_get_lock(avc_lock);\n", "\trc = sidtab_context_to_sid(&avc_sidtab, ctx, sid);\n", "\tavc_release_lock(avc_lock);\n", "\treturn rc;\n", "}\n"], "project": "android-libselinux-dev", "file": "avc.pkl", "function": "avc_context_to_sid_raw"}, {"comment_all": {"comment": "/* show results to first killed */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 110}, "comment_text": "/* show results to first killed */", "comment_tokens": ["show", "results", "to", "first", "killed"], "ccode": ["\n", "/*\n", "Attack a piece other than a city.  The piece could be anyone's.\n", "First we have to figure out what is being attacked.\n", "*/\n", "\n", "void\n", "attack_obj(piece_info_t *att_obj, loc_t loc)\n", "{\n", "    void describe(piece_info_t *, piece_info_t *, loc_t);\n", "    void survive(piece_info_t *, loc_t);\n", "\n", "    piece_info_t *def_obj; /* defender */\n", "    int owner;\n", "\n", "    def_obj = find_obj_at_loc (loc);\n", "    ASSERT (def_obj != NULL); /* can't find object to attack? */\n", "\t\n", "    if (def_obj->type == SATELLITE) return; /* can't attack a satellite */\n", "\n", "    while (att_obj->hits > 0 && def_obj->hits > 0) {\n", "\tif (irand (2) == 0) /* defender hits? */\n", "\t    att_obj->hits -= piece_attr[def_obj->type].strength;\n", "\telse def_obj->hits -= piece_attr[att_obj->type].strength;\n", "    }\n", "\n", "    if (att_obj->hits > 0) { /* attacker won? */\n", "\tdescribe (att_obj, def_obj, loc);\n", "\towner = def_obj->owner;\n", "\tkill_obj (def_obj, loc); /* kill loser */\n", "\tsurvive (att_obj, loc); /* move attacker */\n", "    }\n", "    else { /* defender won */\n", "\tdescribe (def_obj, att_obj, loc);\n", "\towner = att_obj->owner;\n", "\tkill_obj (att_obj, loc);\n", "\tsurvive (def_obj, loc);\n", "    }\n", "    /* show results to first killed */\n", "    scan (MAP(owner), loc);\n", "}\n"], "project": "empire", "file": "attack.pkl", "function": "attack_obj"}, {"comment_all": {"comment": "// initialize ->type, ->host, ->retr and ->size\n", "depth": 0, "reading_ease": 90.77, "reading_grade": 2.1, "line": 325}, "comment_text": "// initialize ->type, ->host, ->retr and ->size\n", "comment_tokens": ["initialize", "-", ">", "type", ",", "-", ">", "host", ",", "-", ">", "retr", "and", "-", ">", "size"], "ccode": ["\n", "// initialize ->type, ->host, ->retr and ->size\n", "knetFile *kftp_parse_url(const char *fn, const char *mode)\n", "{\n", "\tknetFile *fp;\n", "\tchar *p;\n", "\tint l;\n", "\tif (strstr(fn, \"ftp://\") != fn) return 0;\n", "\tfor (p = (char*)fn + 6; *p && *p != '/'; ++p);\n", "\tif (*p != '/') return 0;\n", "\tl = p - fn - 6;\n", "\tfp = (knetFile*)calloc(1, sizeof(knetFile));\n", "\tfp->type = KNF_TYPE_FTP;\n", "\tfp->fd = -1;\n", "\t/* the Linux/Mac version of socket_connect() also recognizes a port\n", "\t * like \"ftp\", but the Windows version does not. */\n", "\tfp->port = strdup(\"21\");\n", "\tfp->host = (char*)calloc(l + 1, 1);\n", "\tif (strchr(mode, 'c')) fp->no_reconnect = 1;\n", "\tstrncpy(fp->host, fn + 6, l);\n", "\tfp->retr = (char*)calloc(strlen(p) + 8, 1);\n", "\tsprintf(fp->retr, \"RETR %s\\r\\n\", p);\n", "    fp->size_cmd = (char*)calloc(strlen(p) + 8, 1);\n", "    sprintf(fp->size_cmd, \"SIZE %s\\r\\n\", p);\n", "\tfp->seek_offset = 0;\n", "\treturn fp;\n", "}\n"], "project": "libstatgen-dev", "file": "knetfile.pkl", "function": "kftp_parse_url"}, {"comment_all": {"comment": "/*\n\t** determine maximum number of CPU's for this system\n\t** and specify mask to register all cpu's\n\t*/", "depth": 1, "reading_ease": 47.79, "reading_grade": 10.3, "line": 56}, "comment_text": "/*\n\t** determine maximum number of CPU's for this system\n\t** and specify mask to register all cpu's\n\t*/", "comment_tokens": ["determine", "maximum", "number", "of", "CPU", "'s", "for", "this", "system", "and", "specify", "mask", "to", "register", "all", "cpu", "'s"], "ccode": ["\n", "int\n", "netlink_open(void)\n", "{\n", "\tint\tnlsock, famid;\n", "\tchar\tcpudef[64];\n", "\n", "\t/*\n", "\t** open the netlink socket\n", "\t*/\n", "\tnlsock = nlsock_open();\n", "\n", "\t/*\n", "\t** get the family id for the TASKSTATS family\n", "\t*/\n", "\tfamid = nlsock_getfam(nlsock);\n", "\n", "\t/*\n", "\t** determine maximum number of CPU's for this system\n", "\t** and specify mask to register all cpu's\n", "\t*/\n", "\tsprintf(cpudef, \"0-%d\", getnumcpu() -1);\n", "\n", "\t/*\n", "\t** indicate to listen for processes from all CPU's\n", "\t*/\n", "\tif (nlsock_sendcmd(nlsock, famid, getpid(), TASKSTATS_CMD_GET,\n", "\t\tTASKSTATS_CMD_ATTR_REGISTER_CPUMASK,\n", "\t\t&cpudef, strlen(cpudef)+1) == -1)\n", "\t{\n", "\t\tfprintf(stderr, \"register cpumask failed\\n\");\n", "\t\treturn -1;\n", "\t}\n", "\n", "\treturn nlsock;\n", "}\n"], "project": "atop", "file": "netlink.pkl", "function": "netlink_open"}, {"comment_all": {"comment": "/*\n * array-info - Array Controllers Informations\n * Copyright (C) 2002  Benoit Gaussen (ben@trez42.net)\n *\n * $Log: array_plugin_api.c,v $\n * Revision 1.3  2007/02/01 14:42:35  pere\n * Indent.\n *\n * Revision 1.2  2002/07/30 14:12:46  trez42\n * Functions add and show infos\n *\n * Revision 1.1  2002/07/29 16:50:19  trez42\n * Add plugin support\n * Change directory structure\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/", "depth": 0, "reading_ease": 56.05, "reading_grade": 9.2, "line": 0}, "comment_text": "/*\n * array-info - Array Controllers Informations\n * Copyright (C) 2002  Benoit Gaussen (ben@trez42.net)\n *\n * $Log: array_plugin_api.c,v $\n * Revision 1.3  2007/02/01 14:42:35  pere\n * Indent.\n *\n * Revision 1.2  2002/07/30 14:12:46  trez42\n * Functions add and show infos\n *\n * Revision 1.1  2002/07/29 16:50:19  trez42\n * Add plugin support\n * Change directory structure\n *\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n*/", "comment_tokens": ["array-info", "-", "Array", "Controllers", "Informations", "Copyright", "(", "C", ")", "2002", "Benoit", "Gaussen", "(", "ben", "@", "trez42.net", ")", "$", "Log", ":", "array_plugin_api.c", ",", "v", "$", "Revision", "1.3", "20070201", "14:42:35", "pere", "Indent", ".", "Revision", "1.2", "20020730", "14:12:46", "trez42", "Functions", "add", "and", "show", "infos", "Revision", "1.1", "20020729", "16:50:19", "trez42", "Add", "plugin", "support", "Change", "directory", "structure", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA"], "ccode": ["/*\n", " * array-info - Array Controllers Informations\n", " * Copyright (C) 2002  Benoit Gaussen (ben@trez42.net)\n", " *\n", " * $Log: array_plugin_api.c,v $\n", " * Revision 1.3  2007/02/01 14:42:35  pere\n", " * Indent.\n", " *\n", " * Revision 1.2  2002/07/30 14:12:46  trez42\n", " * Functions add and show infos\n", " *\n", " * Revision 1.1  2002/07/29 16:50:19  trez42\n", " * Add plugin support\n", " * Change directory structure\n", " *\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " * \n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", "*/\n", "\n", "#include <stdarg.h>\n", "\n", "#include \"array_plugin.h\"\n", "\n", "void\n", "array_show_infos(array_infos_t * info, char level)\n", "{\n", "\tunsigned char min_level = 0xff;\n", "\tarray_infos_t *tail;\n", "\n", "\twhile (info) {\n", "\t\tif (level & info->level)\n", "\t\t\tif (info->level < min_level)\n", "\t\t\t\tmin_level = info->level;\n", "\t\ttail = info;\n", "\t\tinfo = info->next;\n", "\t}\n", "\twhile (tail) {\n", "\t\tif (level & tail->level)\n", "\t\t\tprintf(\"%s\", tail->string);\n", "\t\ttail = tail->prev;\n", "\t}\n", "}\n"], "project": "array-info", "file": "array_plugin_api.pkl", "function": "array_show_infos"}, {"comment_all": {"comment": "/* guess we need no more than 100 bytes */", "depth": 1, "reading_ease": 114.12, "reading_grade": -0.8, "line": 109}, "comment_text": "/* guess we need no more than 100 bytes */", "comment_tokens": ["guess", "we", "need", "no", "more", "than", "100", "bytes"], "ccode": ["\n", "/*\n", " * Print fmt and it's arguments (vprintf-style) to a newly allocated\n", " * buffer and return a pointer to that buffer if successful, NULL\n", " * if we ran out of memory.\n", " */\n", "static char *vbprintf (const char *fmt,va_list ap)\n", "{\n", "   /* guess we need no more than 100 bytes */\n", "   int n,size = 100;\n", "   char *buf,*ptr;\n", "   va_list ap_copy;\n", "\n", "   if (fmt == NULL) return (NULL);\n", "\n", "   if (*fmt == '\\0')\n", "\t {\n", "\t\tif ((buf = mem_alloc (1)) == NULL)\n", "\t\t  return (NULL);\n", "\t\t*buf = '\\0';\n", "\t\treturn (buf);\n", "\t }\n", "\n", "   if ((buf = mem_alloc (size)) == NULL)\n", "\t return (NULL);\n", "\n", "   for (;;)\n", "\t {\n", "\t\t/* try to print in the allocated space */\n", "\t\tva_copy (ap_copy,ap);\n", "\t\tn = vsnprintf (buf,size,fmt,ap_copy);\n", "\t\tva_end (ap_copy);\n", "\n", "\t\t/* if that worked, we're finished */\n", "\t\tif (n > -1 && n < size) break;\n", "\n", "\t\t/* else try again with more space */\n", "\t\tif (n > -1)\t\t/* glibc 2.1 */\n", "\t\t  size = n + 1;\t/* precisely what is needed */\n", "\t\telse\t\t\t/* glibc 2.0 */\n", "\t\t  size *= 2;\t/* twice the old size */\n", "\n", "\t\tif ((ptr = mem_realloc (buf,size)) == NULL)\n", "\t\t  {\n", "\t\t\t int saved = errno;\n", "\t\t\t mem_free (buf);\n", "\t\t\t errno = saved;\n", "\t\t\t return (NULL);\n", "\t\t  }\n", "\t\telse buf = ptr;\n", "\t }\n", "\n", "   return (buf);\n", "}\n"], "project": "libdebug0-dev", "file": "log.pkl", "function": "vbprintf"}, {"comment_all": {"comment": "/* Set whether the file descriptor will be monitored for exceptions\n   on the file descriptor. */", "depth": 0, "reading_ease": 57.27, "reading_grade": 8.8, "line": 513}, "comment_text": "/* Set whether the file descriptor will be monitored for exceptions\n   on the file descriptor. */", "comment_tokens": ["Set", "whether", "the", "file", "descriptor", "will", "be", "monitored", "for", "exceptions", "on", "the", "file", "descriptor", "."], "ccode": ["\n", "/* Set whether the file descriptor will be monitored for exceptions\n", "   on the file descriptor. */\n", "void\n", "sel_set_fd_except_handler(struct selector_s *sel, int fd, int state)\n", "{\n", "    fd_control_t *fdc = (fd_control_t *) &(sel->fds[fd]);\n", "\n", "    sel_fd_lock(sel);\n", "    if (!fdc->state)\n", "\tgoto out;\n", "\n", "    if (state == SEL_FD_HANDLER_ENABLED) {\n", "\tif (FD_ISSET(fd, &sel->except_set))\n", "\t    goto out;\n", "\tFD_SET(fd, &sel->except_set);\n", "    } else if (state == SEL_FD_HANDLER_DISABLED) {\n", "\tif (!FD_ISSET(fd, &sel->except_set))\n", "\t    goto out;\n", "\tFD_CLR(fd, &sel->except_set);\n", "    }\n", "    if (sel_update_epoll(sel, fd, EPOLL_CTL_MOD)) {\n", "\twake_fd_sel_thread(sel);\n", "\treturn;\n", "    }\n", "\n", " out:\n", "    sel_fd_unlock(sel);\n", "}\n"], "project": "ser2net", "file": "selector.pkl", "function": "sel_set_fd_except_handler"}, {"comment_all": {"comment": "/* error that might be repairable */", "depth": 2, "reading_ease": 83.32, "reading_grade": 2.9, "line": 188}, "comment_text": "/* error that might be repairable */", "comment_tokens": ["error", "that", "might", "be", "repairable"], "ccode": ["\n", "static void wd_action(int result, char *rbinary, struct list *act)\n", "{\n", "\tint version = 0;\n", "\tchar *name = NULL;\n", "\tint timeout = TRUE;\n", "\n", "\t/* If we have info about the version, use this to decide what to call\n", "\t * in order to repair the problem. Default is we use the global repair\n", "\t * call, but for V1 we use the same program with a different argument.\n", "\t */\n", "\tif (act != NULL) {\n", "\t\tname = act->name;\n", "\t\tversion = act->version;\n", "\t}\n", "\n", "\tif (version == 1) {\n", "\t\trbinary = name;\n", "\t}\n", "\n", "\t/* Decide on repair or return based on error code. */\n", "\tswitch (result) {\n", "\tcase ENOERR:\n", "\t\t/* No error, reset any time-out. */\n", "\t\tif (act != NULL) {\n", "\t\t\tact->last_time = 0;\n", "\t\t\tact->repair_count = 0;\n", "\t\t}\n", "\tcase EDONTKNOW:\n", "\t\t/* Don't know, keep on working */\n", "\t\treturn;\n", "\n", "\tcase EREBOOT:\n", "\tcase ERESET:\n", "\tcase ETOOHOT:\n", "\t\t/* These are not repairable. */\n", "\t\tbreak;\n", "\n", "\tdefault:\n", "\t\t/* error that might be repairable */\n", "\t\tif (act != NULL && retry_timeout > 0) {\n", "\t\t\t/* timer possible and used to allow re-try */\n", "\t\t\ttime_t now = time(NULL);\n", "\t\t\ttimeout = FALSE;\n", "\n", "\t\t\tif (act->last_time == 0) {\n", "\t\t\t\t/* First offence, record time. */\n", "\t\t\t\tact->last_time = now;\n", "\t\t\t} else {\n", "\t\t\t\t/* timer running */\n", "\t\t\t\tint tused = (int)(now - act->last_time);\n", "\n", "\t\t\t\tif (tused > retry_timeout) {\n", "\t\t\t\t\tlog_message(LOG_WARNING, \"Retry timed-out at %d seconds for %s\", tused,\n", "\t\t\t\t\t\tact->name);\n", "\t\t\t\t\ttimeout = TRUE;\n", "\t\t\t\t} else {\n", "\t\t\t\t\tif (verbose)\n", "\t\t\t\t\t\tlog_message(LOG_DEBUG, \"Retry at %d seconds for %s\", tused, act->name);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\tif (timeout) {\n", "\t\t\tint try_repair = TRUE;\n", "\t\t\t/* check for too many failed repair attempts */\n", "\t\t\tif (act != NULL && repair_max > 0) {\n", "\t\t\t\tif (++act->repair_count > repair_max) {\n", "\t\t\t\t\ttry_repair = FALSE;\n", "\t\t\t\t\tlog_message(LOG_WARNING, \"Repair count exceeded (%d for %s)\",\n", "\t\t\t\t\t\tact->repair_count, act->name);\n", "\t\t\t\t} else {\n", "\t\t\t\t\t/* going to repair, reset re-try timer so same period for next try */\n", "\t\t\t\t\tact->last_time = 0;\n", "\t\t\t\t\tif (verbose) {\n", "\t\t\t\t\t\tlog_message(LOG_DEBUG, \"Repair attempt %d for %s\",\n", "\t\t\t\t\t\t\tact->repair_count, act->name);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t}\n", "\n", "\t\t\tif (try_repair) {\n", "\t\t\t\tresult = repair(rbinary, result, name, version);\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\tresult = ENOERR;\n", "\t\t}\n", "\t\tbreak;\n", "\t}\n", "\n", "\t/* if still error, consider reboot */\n", "\tif (result != ENOERR) {\n", "\t\t/* if no-action flag set, do nothing */\n", "\t\tif (no_act) {\n", "\t\t\tif (verbose) {\n", "\t\t\t\tlog_message(LOG_DEBUG, \"Shutdown blocked by --no-action (error %d = '%s')\",\n", "\t\t\t\t\tresult, wd_strerror(result));\n", "\t\t\t}\n", "\t\t} else {\n", "\t\t\tdo_shutdown(result);\n", "\t\t}\n", "\t}\n", "}\n"], "project": "watchdog", "file": "watchdog.pkl", "function": "wd_action"}, {"comment_all": {"comment": "/* XXX Should this be != instead of > ? */", "depth": 1, "reading_ease": 99.23, "reading_grade": 0.9, "line": 601}, "comment_text": "/* XXX Should this be != instead of > ? */", "comment_tokens": ["XXX", "Should", "this", "be", "!", "=", "instead", "of", ">", "?"], "ccode": ["\n", "int\n", "evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,\n", "    struct timeval *ptv)\n", "{\n", "\tev_uint32_t tag;\n", "\tev_uint32_t integer;\n", "\tint len, offset, offset2;\n", "\tint result = -1;\n", "\n", "\tif ((len = evtag_unmarshal_header(evbuf, &tag)) == -1)\n", "\t\treturn (-1);\n", "\tif (tag != need_tag)\n", "\t\tgoto done;\n", "\tif ((offset = decode_int_internal(&integer, evbuf, 0)) == -1)\n", "\t\tgoto done;\n", "\tptv->tv_sec = integer;\n", "\tif ((offset2 = decode_int_internal(&integer, evbuf, offset)) == -1)\n", "\t\tgoto done;\n", "\tptv->tv_usec = integer;\n", "\tif (offset + offset2 > len) /* XXX Should this be != instead of > ? */\n", "\t\tgoto done;\n", "\n", "\tresult = 0;\n", " done:\n", "\tevbuffer_drain(evbuf, len);\n", "\treturn result;\n", "}\n"], "project": "libevent-dev", "file": "event_tagging.pkl", "function": "evtag_unmarshal_timeval"}, {"comment_all": {"comment": "/** start next file entry in a zip archive\n *\n * This function will create a new file within a zzip archive, the\n * one given as the primary argument and additionally to the posix\n * creat(2) - just like zzip_mkdir has an additional argument over\n * the posix mkdir(2) spec. For this function the primary parameter\n * can be null as well thereby creating a real file instead of a new\n * one inside the zip-archive otherwise given. If the primary parameter is\n * not null but wraps a real directory then all new files are also real.\n *\n * This function is not yet implemented, check for #def ZZIP_NO_CREAT\n *\n * Returns NULL on an error setting errno, and opening a file _within_ \n * a zip archive using O_RDONLY (and similar stuff) will surely lead to \n * an error.\n */", "depth": 0, "reading_ease": 48.17, "reading_grade": 14.3, "line": 281}, "comment_text": "/** start next file entry in a zip archive\n *\n * This function will create a new file within a zzip archive, the\n * one given as the primary argument and additionally to the posix\n * creat(2) - just like zzip_mkdir has an additional argument over\n * the posix mkdir(2) spec. For this function the primary parameter\n * can be null as well thereby creating a real file instead of a new\n * one inside the zip-archive otherwise given. If the primary parameter is\n * not null but wraps a real directory then all new files are also real.\n *\n * This function is not yet implemented, check for #def ZZIP_NO_CREAT\n *\n * Returns NULL on an error setting errno, and opening a file _within_ \n * a zip archive using O_RDONLY (and similar stuff) will surely lead to \n * an error.\n */", "comment_tokens": ["start", "next", "file", "entry", "in", "a", "zip", "archive", "This", "function", "will", "create", "a", "new", "file", "within", "a", "zzip", "archive", ",", "the", "one", "given", "as", "the", "primary", "argument", "and", "additionally", "to", "the", "posix", "creat", "(", "2", ")", "-", "just", "like", "zzip_mkdir", "has", "an", "additional", "argument", "over", "the", "posix", "mkdir", "(", "2", ")", "spec", ".", "For", "this", "function", "the", "primary", "parameter", "can", "be", "null", "as", "well", "thereby", "creating", "a", "real", "file", "instead", "of", "a", "new", "one", "inside", "the", "zip-archive", "otherwise", "given", ".", "If", "the", "primary", "parameter", "is", "not", "null", "but", "wraps", "a", "real", "directory", "then", "all", "new", "files", "are", "also", "real", ".", "This", "function", "is", "not", "yet", "implemented", ",", "check", "for", "#", "def", "ZZIP_NO_CREAT", "Returns", "NULL", "on", "an", "error", "setting", "errno", ",", "and", "opening", "a", "file", "_within_", "a", "zip", "archive", "using", "O_RDONLY", "(", "and", "similar", "stuff", ")", "will", "surely", "lead", "to", "an", "error", "."], "ccode": ["\n", "/** start next file entry in a zip archive\n", " *\n", " * This function will create a new file within a zzip archive, the\n", " * one given as the primary argument and additionally to the posix\n", " * creat(2) - just like zzip_mkdir has an additional argument over\n", " * the posix mkdir(2) spec. For this function the primary parameter\n", " * can be null as well thereby creating a real file instead of a new\n", " * one inside the zip-archive otherwise given. If the primary parameter is\n", " * not null but wraps a real directory then all new files are also real.\n", " *\n", " * This function is not yet implemented, check for #def ZZIP_NO_CREAT\n", " *\n", " * Returns NULL on an error setting errno, and opening a file _within_ \n", " * a zip archive using O_RDONLY (and similar stuff) will surely lead to \n", " * an error.\n", " */\n", "ZZIP_FILE *\n", "zzip_file_creat(ZZIP_DIR * dir, zzip_char_t * name, int o_mode)\n", "{\n", "    if (! dir)\n", "        return zzip_open(name, o_mode);\n", "\n", "    if (! _ZZIP_TRY)\n", "    {                           /* not implemented */\n", "        errno = EROFS;\n", "        return 0;\n", "    } else\n", "    {\n", "        errno = EROFS;\n", "        return 0;\n", "    }\n", "}\n"], "project": "zziplib-bin", "file": "write.pkl", "function": "zzip_file_creat"}, {"comment_all": {"comment": "/******************************************************************************\n *\n * FUNCTION:    usage\n *\n * PARAMETERS:  None\n *\n * RETURN:      None\n *\n * DESCRIPTION: Print a usage message\n *\n *****************************************************************************/", "depth": 0, "reading_ease": 34.93, "reading_grade": 11.1, "line": 121}, "comment_text": "/******************************************************************************\n *\n * FUNCTION:    usage\n *\n * PARAMETERS:  None\n *\n * RETURN:      None\n *\n * DESCRIPTION: Print a usage message\n *\n *****************************************************************************/", "comment_tokens": ["FUNCTION", ":", "usage", "PARAMETERS", ":", "None", "RETURN", ":", "None", "DESCRIPTION", ":", "Print", "a", "usage", "message"], "ccode": ["\n", "\n", "/******************************************************************************\n", " *\n", " * FUNCTION:    usage\n", " *\n", " * PARAMETERS:  None\n", " *\n", " * RETURN:      None\n", " *\n", " * DESCRIPTION: Print a usage message\n", " *\n", " *****************************************************************************/\n", "\n", "static void\n", "usage (\n", "    void)\n", "{\n", "\n", "    ACPI_USAGE_HEADER (\"acpiexec [options] AMLfile1 AMLfile2 ...\");\n", "\n", "    ACPI_OPTION (\"-b \\\"CommandLine\\\"\",  \"Batch mode command line execution (cmd1;cmd2;...)\");\n", "    ACPI_OPTION (\"-h -?\",               \"Display this help message\");\n", "    ACPI_OPTION (\"-m [Method]\",         \"Batch mode method execution. Default=MAIN\");\n", "    printf (\"\\n\");\n", "\n", "    ACPI_OPTION (\"-da\",                 \"Disable method abort on error\");\n", "    ACPI_OPTION (\"-df\",                 \"Disable Local fault handler\");\n", "    ACPI_OPTION (\"-di\",                 \"Disable execution of STA/INI methods during init\");\n", "    ACPI_OPTION (\"-do\",                 \"Disable Operation Region address simulation\");\n", "    ACPI_OPTION (\"-dr\",                 \"Disable repair of method return values\");\n", "    ACPI_OPTION (\"-ds\",                 \"Disable method auto-serialization\");\n", "    ACPI_OPTION (\"-dt\",                 \"Disable allocation tracking (performance)\");\n", "    printf (\"\\n\");\n", "\n", "    ACPI_OPTION (\"-ed\",                 \"Enable timer output for Debug Object\");\n", "    ACPI_OPTION (\"-ef\",                 \"Enable display of final memory statistics\");\n", "    ACPI_OPTION (\"-ei\",                 \"Enable additional tests for ACPICA interfaces\");\n", "    ACPI_OPTION (\"-el\",                 \"Enable loading of additional test tables\");\n", "    ACPI_OPTION (\"-eo\",                 \"Enable object evaluation log\");\n", "    ACPI_OPTION (\"-es\",                 \"Enable Interpreter Slack Mode\");\n", "    ACPI_OPTION (\"-et\",                 \"Enable debug semaphore timeout\");\n", "    printf (\"\\n\");\n", "\n", "    ACPI_OPTION (\"-fi <File>\",          \"Specify namespace initialization file\");\n", "    ACPI_OPTION (\"-fv <Value>\",         \"Operation Region initialization fill value\");\n", "    printf (\"\\n\");\n", "\n", "    ACPI_OPTION (\"-l\",                  \"Load tables and namespace only\");\n", "    ACPI_OPTION (\"-r\",                  \"Use hardware-reduced FADT V5\");\n", "    ACPI_OPTION (\"-te\",                 \"Exit loop on timeout instead of aborting method\");\n", "    ACPI_OPTION (\"-to <Seconds>\",       \"Set timeout period for AML while loops\");\n", "    printf (\"\\n\");\n", "\n", "    ACPI_OPTION (\"-v\",                  \"Display version information\");\n", "    ACPI_OPTION (\"-va\",                 \"Display verbose dump of any memory leaks\");\n", "    ACPI_OPTION (\"-vd\",                 \"Display build date and time\");\n", "    ACPI_OPTION (\"-vh\",                 \"Verbose exception handler output\");\n", "    ACPI_OPTION (\"-vi\",                 \"Verbose initialization output\");\n", "    ACPI_OPTION (\"-vr\",                 \"Verbose region handler output\");\n", "    ACPI_OPTION (\"-x <DebugLevel>\",     \"Debug output level\");\n", "\n", "    printf (\"\\n  From within the interactive mode, use '?' or \\\"help\\\" to see\\n\"\n", "        \"  a list of available AML Debugger commands\\n\");\n", "}\n"], "project": "acpica-tools", "file": "aemain.pkl", "function": "usage"}, {"comment_all": {"comment": "/* A function to display information about the available keys that can be used by the player */", "depth": 0, "reading_ease": 72.16, "reading_grade": 7.2, "line": 89}, "comment_text": "/* A function to display information about the available keys that can be used by the player */", "comment_tokens": ["A", "function", "to", "display", "information", "about", "the", "available", "keys", "that", "can", "be", "used", "by", "the", "player"], "ccode": ["\n", "/* A function to display information about the available keys that can be used by the player */\n", "void output_key (int y, int x, char *key, int key_style, char *s, int s_style) {\n", "  int keylen = strlen(key);\n", "  attrset(key_style);\n", "  mvaddstr(y, x+1, key);\n", "  attrset(s_style);\n", "  mvaddch(y, x, '['); \n", "  mvaddch(y, x+keylen+1, ']'); \n", "  mvaddstr(y, x+keylen+3, s); \n", "}\n"], "project": "curseofwar", "file": "output.pkl", "function": "output_key"}, {"comment_all": {"comment": "/* Expand the resource record number rrnum into rr. */", "depth": 2, "reading_ease": 71.82, "reading_grade": 5.2, "line": 57}, "comment_text": "/* Expand the resource record number rrnum into rr. */", "comment_tokens": ["Expand", "the", "resource", "record", "number", "rrnum", "into", "rr", "."], "ccode": ["/*\n", " * DNS Resolver Module User-space Helper for AFSDB records\n", " *\n", " * Copyright (C) Wang Lei (wang840925@gmail.com) 2010\n", " * Authors: Wang Lei (wang840925@gmail.com)\n", " *\n", " * Copyright (C) David Howells (dhowells@redhat.com) 2018\n", " *\n", " * This is a userspace tool for querying AFSDB RR records in the DNS on behalf\n", " * of the kernel, and converting the VL server addresses to IPv4 format so that\n", " * they can be used by the kAFS filesystem.\n", " *\n", " * As some function like res_init() should use the static library, which is a\n", " * bug of libresolv, that is the reason for cifs.upcall to reimplement.\n", " *\n", " * To use this program, you must tell /sbin/request-key how to invoke it.  You\n", " * need to have the keyutils package installed and something like the following\n", " * lines added to your /etc/request-key.conf file:\n", " *\n", " * \t#OP    TYPE         DESCRIPTION CALLOUT INFO PROGRAM ARG1 ARG2 ARG3 ...\n", " * \t====== ============ =========== ============ ==========================\n", " * \tcreate dns_resolver afsdb:*     *            /sbin/key.dns_resolver %k\n", " *\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n", " */\n", "#include \"key.dns.h\"\n", "\n", "static unsigned long afs_ttl = ULONG_MAX;\n", "\n", "/*\n", " *\n", " */\n", "static void afsdb_hosts_to_addrs(ns_msg handle, ns_sect section)\n", "{\n", "\tchar *vllist[MAX_VLS];\t/* list of name servers\t*/\n", "\tint vlsnum = 0;\t\t/* number of name servers in list */\n", "\tint rrnum;\n", "\tns_rr rr;\n", "\tint subtype, i, ret;\n", "\tunsigned int ttl = UINT_MAX, rr_ttl;\n", "\n", "\tdebug(\"AFSDB RR count is %d\", ns_msg_count(handle, section));\n", "\n", "\t/* Look at all the resource records in this section. */\n", "\tfor (rrnum = 0; rrnum < ns_msg_count(handle, section); rrnum++) {\n", "\t\t/* Expand the resource record number rrnum into rr. */\n", "\t\tif (ns_parserr(&handle, section, rrnum, &rr)) {\n", "\t\t\t_error(\"ns_parserr failed : %m\");\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\t/* We're only interested in AFSDB records */\n", "\t\tif (ns_rr_type(rr) == ns_t_afsdb) {\n", "\t\t\tvllist[vlsnum] = malloc(MAXDNAME);\n", "\t\t\tif (!vllist[vlsnum])\n", "\t\t\t\terror(\"Out of memory\");\n", "\n", "\t\t\tsubtype = ns_get16(ns_rr_rdata(rr));\n", "\n", "\t\t\t/* Expand the name server's domain name */\n", "\t\t\tif (ns_name_uncompress(ns_msg_base(handle),\n", "\t\t\t\t\t       ns_msg_end(handle),\n", "\t\t\t\t\t       ns_rr_rdata(rr) + 2,\n", "\t\t\t\t\t       vllist[vlsnum],\n", "\t\t\t\t\t       MAXDNAME) < 0)\n", "\t\t\t\terror(\"ns_name_uncompress failed\");\n", "\n", "\t\t\trr_ttl = ns_rr_ttl(rr);\n", "\t\t\tif (ttl > rr_ttl)\n", "\t\t\t\tttl = rr_ttl;\n", "\n", "\t\t\t/* Check the domain name we've just unpacked and add it to\n", "\t\t\t * the list of VL servers if it is not a duplicate.\n", "\t\t\t * If it is a duplicate, just ignore it.\n", "\t\t\t */\n", "\t\t\tfor (i = 0; i < vlsnum; i++)\n", "\t\t\t\tif (strcasecmp(vllist[i], vllist[vlsnum]) == 0)\n", "\t\t\t\t\tgoto next_one;\n", "\n", "\t\t\t/* Turn the hostname into IP addresses */\n", "\t\t\tret = dns_resolver(vllist[vlsnum], NULL);\n", "\t\t\tif (ret) {\n", "\t\t\t\tdebug(\"AFSDB RR can't resolve.\"\n", "\t\t\t\t      \"subtype:%d, server name:%s, netmask:%u\",\n", "\t\t\t\t      subtype, vllist[vlsnum], mask);\n", "\t\t\t\tgoto next_one;\n", "\t\t\t}\n", "\n", "\t\t\tinfo(\"AFSDB RR subtype:%d, server name:%s, ip:%*.*s, ttl:%u\",\n", "\t\t\t     subtype, vllist[vlsnum],\n", "\t\t\t     (int)payload[payload_index - 1].iov_len,\n", "\t\t\t     (int)payload[payload_index - 1].iov_len,\n", "\t\t\t     (char *)payload[payload_index - 1].iov_base,\n", "\t\t\t     ttl);\n", "\n", "\t\t\t/* prepare for the next record */\n", "\t\t\tvlsnum++;\n", "\t\t\tcontinue;\n", "\n", "\t\tnext_one:\n", "\t\t\tfree(vllist[vlsnum]);\n", "\t\t}\n", "\t}\n", "\n", "\tafs_ttl = ttl;\n", "\tinfo(\"ttl: %u\", ttl);\n", "}\n"], "project": "libkeyutils1", "file": "dns.afsdb.pkl", "function": "afsdb_hosts_to_addrs"}, {"comment_all": {"comment": "/* Could p be a stack address? */", "depth": 0, "reading_ease": 99.23, "reading_grade": 0.9, "line": 191}, "comment_text": "/* Could p be a stack address? */", "comment_tokens": ["Could", "p", "be", "a", "stack", "address", "?"], "ccode": ["\n", "void (*GC_is_visible_print_proc) GC_PROTO((GC_PTR p)) = \n", "\tGC_default_is_visible_print_proc;\n", "\n", "/* Could p be a stack address? */\n", "GC_bool GC_on_stack(p)\n", "ptr_t p;\n", "{\n", "#   ifdef THREADS\n", "\treturn(TRUE);\n", "#   else\n", "\tint dummy;\n", "#   \tifdef STACK_GROWS_DOWN\n", "\t    if ((ptr_t)p >= (ptr_t)(&dummy) && (ptr_t)p < GC_stackbottom ) {\n", "\t    \treturn(TRUE);\n", "\t    }\n", "#\telse\n", "\t    if ((ptr_t)p <= (ptr_t)(&dummy) && (ptr_t)p > GC_stackbottom ) {\n", "\t    \treturn(TRUE);\n", "\t    }\n", "#\tendif\n", "\treturn(FALSE);\n", "#   endif\n", "}\n"], "project": "libmono-system-threading-tasks-dataflow4.0-cil", "file": "ptr_chck.pkl", "function": "GC_on_stack"}, {"comment_all": {"comment": "/* Error checking, mainly for replies to method calls */", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 292}, "comment_text": "/* Error checking, mainly for replies to method calls */", "comment_tokens": ["Error", "checking", ",", "mainly", "for", "replies", "to", "method", "calls"], "ccode": ["\n", "\n", "/* Error checking, mainly for replies to method calls */\n", "\n", "int\n", "mbp_dbus_check_error(DBusMessage *msg)\n", "{\n", "  DBusMessageIter iter;\n", "\n", "  char *errmsg;\n", "\n", "  if (dbus_message_get_type(msg) == DBUS_MESSAGE_TYPE_ERROR)\n", "    {\n", "      dbus_message_iter_init(msg, &iter);\n", "      dbus_message_iter_get_basic(&iter, &errmsg);\n", "\n", "      printf(\"DBus error: %s\\n\", errmsg);\n", "\n", "      return 1;\n", "    }\n", "\n", "  return 0;\n", "}\n"], "project": "gpomme", "file": "dbus-client.pkl", "function": "mbp_dbus_check_error"}, {"comment_all": {"comment": "/* low 32 bits of 64-bit digit */", "depth": 3, "reading_ease": 99.23, "reading_grade": 0.9, "line": 381}, "comment_text": "/* low 32 bits of 64-bit digit */\n/* high 32 bits of 64-bit digit */\n", "comment_tokens": ["low", "32", "bits", "of", "64-bit", "digit", "high", "32", "bits", "of", "64-bit", "digit"], "ccode": ["\n", "static uintnat deserialize_nat(void * dst)\n", "{\n", "  mlsize_t len;\n", "\n", "  len = caml_deserialize_uint_4();\n", "#if defined(ARCH_SIXTYFOUR) && defined(ARCH_BIG_ENDIAN)\n", "  { uint32_t * p;\n", "    mlsize_t i;\n", "    for (i = len, p = dst; i > 1; i -= 2, p += 2) {\n", "      p[1] = caml_deserialize_uint_4();   /* low 32 bits of 64-bit digit */\n", "      p[0] = caml_deserialize_uint_4();   /* high 32 bits of 64-bit digit */\n", "    }\n", "    if (i > 0){\n", "      p[1] = caml_deserialize_uint_4();   /* low 32 bits of 64-bit digit */\n", "      p[0] = 0;                      /* high 32 bits of 64-bit digit */\n", "      ++ len;\n", "    }\n", "  }\n", "#else\n", "  caml_deserialize_block_4(dst, len);\n", "#if defined(ARCH_SIXTYFOUR)\n", "  if (len & 1){\n", "    ((uint32_t *) dst)[len] = 0;\n", "    ++ len;\n", "  }\n", "#endif\n", "#endif\n", "  return len * 4;\n", "}\n"], "project": "libnum-ocaml", "file": "nat_stubs.pkl", "function": "deserialize_nat"}, {"comment_all": {"comment": "/*\n * Returns true if `pattern` is a star-only globbing pattern, that is,\n * it contains at least one non-escaped `*`.\n */", "depth": 0, "reading_ease": 71.14, "reading_grade": 7.6, "line": 115}, "comment_text": "/*\n * Returns true if `pattern` is a star-only globbing pattern, that is,\n * it contains at least one non-escaped `*`.\n */", "comment_tokens": ["Returns", "true", "if", "`", "pattern", "`", "is", "a", "star-only", "globbing", "pattern", ",", "that", "is", ",", "it", "contains", "at", "least", "one", "non-escaped", "``", "."], "ccode": ["\n", "/*\n", " * Returns true if `pattern` is a star-only globbing pattern, that is,\n", " * it contains at least one non-escaped `*`.\n", " */\n", "LTTNG_HIDDEN\n", "bool strutils_is_star_glob_pattern(const char *pattern)\n", "{\n", "\treturn strutils_test_glob_pattern(pattern) &\n", "\t\tSTAR_GLOB_PATTERN_TYPE_FLAG_PATTERN;\n", "}\n"], "project": "python3-lttng", "file": "string-utils.pkl", "function": "strutils_is_star_glob_pattern"}, {"comment_all": {"comment": "/*\n * Return the next object in the iteration.\n */", "depth": 0, "reading_ease": 55.91, "reading_grade": 7.2, "line": 923}, "comment_text": "/*\n * Return the next object in the iteration.\n */", "comment_tokens": ["Return", "the", "next", "object", "in", "the", "iteration", "."], "ccode": ["\n", "/*\n", " * Return the next object in the iteration.\n", " */\n", "static PyObject* PamEnvIter_iternext(PyObject* self)\n", "{\n", "  PamEnvIterObject*\tpamEnvIter = (PamEnvIterObject*)self;\n", "  char**\t\tenv;\n", "  int\t\t\ti;\n", "  PyObject*\t\tresult;\n", "\n", "  if (pamEnvIter->env == 0)\n", "    goto error_exit;\n", "  env = pam_getenvlist(pamEnvIter->env->pamHandle->pamh);\n", "  if (env == 0)\n", "    goto error_exit;\n", "  for (i = 0; env[i] != 0 && i < pamEnvIter->pos; i += 1)\n", "    continue;\n", "  if (env[i] == 0)\n", "    goto error_exit;\n", "  result = pamEnvIter->get_entry(env[i]);\n", "  if (result == 0)\n", "    goto error_exit;\n", "  pamEnvIter->pos += 1;\n", "  return result;\n", "\n", "error_exit:\n", "  clear_slot((PyObject**)&pamEnvIter->env);\n", "  return 0;\n", "}\n"], "project": "libpam-python-doc", "file": "pam_python.pkl", "function": "PamEnvIter_iternext"}, {"comment_all": {"comment": "/**\n * Probe the open device for dimensions.\n */", "depth": 0, "reading_ease": 73.85, "reading_grade": 4.5, "line": 955}, "comment_text": "/**\n * Probe the open device for dimensions.\n */", "comment_tokens": ["Probe", "the", "open", "device", "for", "dimensions", "."], "ccode": ["\n", "/**\n", " * Probe the open device for dimensions.\n", " */\n", "static void\n", "EventReadDevDimensions(InputInfoPtr pInfo)\n", "{\n", "    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;\n", "    struct eventcomm_proto_data *proto_data = priv->proto_data;\n", "    int i;\n", "\n", "    proto_data = EventProtoDataAlloc(pInfo->fd);\n", "    priv->proto_data = proto_data;\n", "\n", "    for (i = 0; i < ABS_MT_CNT; i++)\n", "        proto_data->axis_map[i] = -1;\n", "    proto_data->cur_slot = -1;\n", "\n", "    if (event_query_is_touchpad(proto_data->evdev)) {\n", "        event_query_touch(pInfo);\n", "        event_query_axis_ranges(pInfo);\n", "    }\n", "    event_query_model(proto_data->evdev, &priv->model, &priv->id_vendor,\n", "                      &priv->id_product);\n", "\n", "    xf86IDrvMsg(pInfo, X_PROBED, \"Vendor %#hx Product %#hx\\n\",\n", "                priv->id_vendor, priv->id_product);\n", "}\n"], "project": "xserver-xorg-input-synaptics-dev", "file": "eventcomm.pkl", "function": "EventReadDevDimensions"}, {"comment_all": {"comment": "/* Adapted from the Intel FW hub stuff for 82802ax parts. */", "depth": 0, "reading_ease": 95.17, "reading_grade": 2.5, "line": 18}, "comment_text": "/* Adapted from the Intel FW hub stuff for 82802ax parts. */", "comment_tokens": ["Adapted", "from", "the", "Intel", "FW", "hub", "stuff", "for", "82802ax", "parts", "."], "ccode": ["/*\n", " * This file is part of the flashrom project.\n", " *\n", " * Copyright (C) 2000 Silicon Integrated System Corporation\n", " * Copyright (C) 2009 Kontron Modular Computers\n", " * Copyright (C) 2009 Sean Nelson <audiohacked@gmail.com>\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " */\n", "\n", "/* Adapted from the Intel FW hub stuff for 82802ax parts. */\n", "\n", "#include \"flash.h\"\n", "#include \"chipdrivers.h\"\n", "\n", "static int check_sst_fwhub_block_lock(struct flashctx *flash, unsigned int offset)\n", "{\n", "\tchipaddr registers = flash->virtual_registers;\n", "\tuint8_t blockstatus;\n", "\n", "\tblockstatus = chip_readb(flash, registers + offset + 2);\n", "\tmsg_cdbg(\"Lock status for 0x%06x (size 0x%06x) is %02x, \",\n", "\t\t     offset, flash->chip->page_size, blockstatus);\n", "\tswitch (blockstatus & 0x3) {\n", "\tcase 0x0:\n", "\t\tmsg_cdbg(\"full access\\n\");\n", "\t\tbreak;\n", "\tcase 0x1:\n", "\t\tmsg_cdbg(\"write locked\\n\");\n", "\t\tbreak;\n", "\tcase 0x2:\n", "\t\tmsg_cdbg(\"locked open\\n\");\n", "\t\tbreak;\n", "\tcase 0x3:\n", "\t\tmsg_cdbg(\"write locked down\\n\");\n", "\t\tbreak;\n", "\t}\n", "\t/* Return content of the write_locked bit */\n", "\treturn blockstatus & 0x1;\n", "}\n"], "project": "libflashrom1", "file": "sst_fwhub.pkl", "function": "check_sst_fwhub_block_lock"}, {"comment_all": {"comment": "// well, there's no music, but most games don't break without music...\n", "depth": 2, "reading_ease": 85.69, "reading_grade": 4.0, "line": 43}, "comment_text": "// well, there's no music, but most games don't break without music...\n", "comment_tokens": ["well", ",", "there", "'s", "no", "music", ",", "but", "most", "games", "do", "n't", "break", "without", "music", "..."], "ccode": ["\n", "void\n", "playGameMusic()\n", "{\n", "  if(!music_enabled)\n", "    return;\n", "  if(!game_music)\n", "    return;\n", "  if(Mix_PlayMusic(game_music, -1) == -1) {\n", "    printf(\"Mix_PlayMusic: game %s\\n\", Mix_GetError());\n", "    // well, there's no music, but most games don't break without music...\n", "  }\n", "}\n"], "project": "abe-data", "file": "Sound.pkl", "function": "playGameMusic"}, {"comment_all": {"comment": "// Do any networking initialisation if this is the first use.\n", "depth": 1, "reading_ease": 61.33, "reading_grade": 7.2, "line": 89}, "comment_text": "// Do any networking initialisation if this is the first use.\n", "comment_tokens": ["Do", "any", "networking", "initialisation", "if", "this", "is", "the", "first", "use", "."], "ccode": ["\n", "hFILE *hopen_net(const char *filename, const char *mode)\n", "{\n", "    hFILE_net *fp;\n", "\n", "    // Do any networking initialisation if this is the first use.\n", "    if (! net_inited) { if (net_init() < 0) return NULL; }\n", "\n", "    fp = (hFILE_net *) hfile_init(sizeof (hFILE_net), mode, 0);\n", "    if (fp == NULL) return NULL;\n", "\n", "    fp->netfp = knet_open(filename, mode);\n", "    if (fp->netfp == NULL) { hfile_destroy((hFILE *) fp); return NULL; }\n", "\n", "    fp->base.backend = &net_backend;\n", "    return &fp->base;\n", "}\n"], "project": "tabix", "file": "hfile_net.pkl", "function": "hopen_net"}, {"comment_all": {"comment": "/* close logging (safe if logfile is not owned by LCAS) */", "depth": 1, "reading_ease": 95.17, "reading_grade": 2.5, "line": 1403}, "comment_text": "/* close logging (safe if logfile is not owned by LCAS) */", "comment_tokens": ["close", "logging", "(", "safe", "if", "logfile", "is", "not", "owned", "by", "LCAS", ")"], "ccode": ["\n", "/******************************************************************************\n", "Function:   lcas_term\n", "Description:\n", "    Terminate LCAS module: \n", "\n", "Parameters:\n", "Returns:\n", "    0: termination succeeded\n", "    1: termination failed\n", "******************************************************************************/\n", "int lcas_term()\n", "{\n", "    int                           rc;\n", "    lcas_plugindl_t *             plugin_entry;\n", "    lcas_plugindl_t *             authmod_entry;\n", "\n", "    // lcas_log_debug(0,\"\\n\");\n", "    lcas_log (1,\"Termination LCAS\\n\");\n", "    /*\n", "     *             - Terminate the STANDARD authorization modules\n", "     *               and clean up the authmod structure\n", "     */\n", "    authmod_entry=authmod_list;\n", "    while (authmod_entry)\n", "    {\n", "        lcas_plugindl_t * authmod_next;\n", "        int               i;\n", "\n", "        rc = authmod_entry->procs[TERMPROC]();\n", "        if (rc != LCAS_MOD_SUCCESS)\n", "        {\n", "            lcas_log(0,\"lcas.mod-lcas_term(): failed to terminate standard module %s\\n\",\n", "                    authmod_entry->pluginname);\n", "            return 1;\n", "        }\n", "        lcas_log_debug(1, \"lcas.mod-lcas_term(): standard module %s terminated\\n\",\n", "                authmod_entry->pluginname);\n", "        dlclose(authmod_entry->handle);\n", "\n", "        authmod_next=authmod_entry->next;\n", "        for (i=0; i < authmod_entry->argc; i++)\n", "        {\n", "            if ((authmod_entry->argv)[i] != NULL)\n", "            {\n", "                lcas_log_debug(3,\"Freeing %d - %s\\n\",i,(authmod_entry->argv)[i]);\n", "                free((authmod_entry->argv)[i]);\n", "            }\n", "        }\n", "        free(authmod_entry);\n", "        authmod_entry=authmod_next;\n", "    }\n", "    authmod_list=authmod_entry=NULL;\n", "\n", "    /*\n", "     *             - Terminate the PLUGIN authorization modules\n", "     *               and clean up the plugin structure\n", "     */\n", "    plugin_entry=plugin_list;\n", "    while (plugin_entry)\n", "    {\n", "        lcas_plugindl_t * plugin_next;\n", "        int               i;\n", "\n", "        rc = plugin_entry->procs[TERMPROC]();\n", "        if (rc != LCAS_MOD_SUCCESS)\n", "        {\n", "            lcas_log(0,\"lcas.mod-lcas_term(): failed to terminate plugin module %s\\n\",\n", "                    plugin_entry->pluginname);\n", "            return 1;\n", "        }\n", "        lcas_log_debug(1, \"lcas.mod-lcas_term(): plugin module %s terminated\\n\",\n", "                plugin_entry->pluginname);\n", "        dlclose(plugin_entry->handle);\n", "\n", "        plugin_next=plugin_entry->next;\n", "        for (i=0; i < plugin_entry->argc; i++)\n", "        {\n", "            if ((plugin_entry->argv)[i] != NULL)\n", "            {\n", "                lcas_log_debug(3,\"Freeing %d - %s\\n\",i,(plugin_entry->argv)[i]);\n", "                free((plugin_entry->argv)[i]);\n", "            }\n", "        }\n", "        free(plugin_entry);\n", "        plugin_entry=plugin_next;\n", "    }\n", "    plugin_list=plugin_entry=NULL;\n", "\n", "    /* close logging (safe if logfile is not owned by LCAS) */\n", "    if (lcas_log_close() != 0)\n", "        return 1;\n", "\n", "    lcas_initialized=0;\n", "    return 0;\n", "}\n"], "project": "lcas-interface", "file": "lcas.pkl", "function": "lcas_term"}, {"comment_all": {"comment": "/* 4 bytes - dummy value */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 263}, "comment_text": "/* 4 bytes - dummy value */", "comment_tokens": ["4", "bytes", "-", "dummy", "value"], "ccode": ["\n", "static int send_secondary(usb_dev_handle * udev, struct image * image) {\n", "\n", "\tstruct xloader_msg init_msg;\n", "\tuint8_t buffer[1024];\n", "\tuint32_t need, sent;\n", "\tint ret;\n", "\n", "\tinit_msg = xloader_msg_create(XLOADER_MSG_TYPE_SEND, image);\n", "\n", "\tprintf(\"Sending X-Loader init message...\\n\");\n", "\tret = usb_bulk_write(udev, USB_WRITE_EP, (char *)&init_msg, sizeof(init_msg), WRITE_TIMEOUT);\n", "\tif ( ret != sizeof(init_msg) )\n", "\t\tERROR_RETURN(\"Sending X-Loader init message failed\", -1);\n", "\n", "\tprintf(\"Waiting for X-Loader response...\\n\");\n", "\tSLEEP(5000);\n", "\tret = usb_bulk_read(udev, USB_READ_EP, (char *)&buffer, 4, READ_TIMEOUT); /* 4 bytes - dummy value */\n", "\tif ( ret != 4 )\n", "\t\tERROR_RETURN(\"No response\", -1);\n", "\n", "\tprintf(\"Sending Secondary image...\\n\");\n", "\tprintf_progressbar(0, image->size);\n", "\timage_seek(image, 0);\n", "\tsent = 0;\n", "\twhile ( sent < image->size ) {\n", "\t\tneed = image->size - sent;\n", "\t\tif ( need > sizeof(buffer) )\n", "\t\t\tneed = sizeof(buffer);\n", "\t\tret = image_read(image, buffer, need);\n", "\t\tif ( ret == 0 )\n", "\t\t\tbreak;\n", "\t\tif ( usb_bulk_write(udev, USB_WRITE_EP, (char *)buffer, ret, WRITE_TIMEOUT) != ret )\n", "\t\t\tPRINTF_ERROR_RETURN(\"Sending Secondary image failed\", -1);\n", "\t\tsent += ret;\n", "\t\tprintf_progressbar(sent, image->size);\n", "\t}\n", "\n", "\tprintf(\"Waiting for X-Loader response...\\n\");\n", "\tSLEEP(5000);\n", "\tret = usb_bulk_read(udev, USB_READ_EP, (char *)&buffer, 4, READ_TIMEOUT); /* 4 bytes - dummy value */\n", "\tif ( ret != 4 )\n", "\t\tERROR_RETURN(\"No response\", -1);\n", "\n", "\treturn 0;\n", "\n", "}\n"], "project": "0xffff", "file": "cold-flash.pkl", "function": "send_secondary"}, {"comment_all": {"comment": "/*\n * Copyright (c) 1996 Wolfram Schneider <wosch@FreeBSD.org>. Berlin.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * \t$Id: ostern.c,v 1.8 2015/03/15 00:41:28 millert Exp $\n */", "depth": 0, "reading_ease": 29.18, "reading_grade": 15.4, "line": 2}, "comment_text": "/*\n * Copyright (c) 1996 Wolfram Schneider <wosch@FreeBSD.org>. Berlin.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * \t$Id: ostern.c,v 1.8 2015/03/15 00:41:28 millert Exp $\n */", "comment_tokens": ["Copyright", "(", "c", ")", "1996", "Wolfram", "Schneider", "<", "wosch", "@", "FreeBSD.org", ">", ".", "Berlin", ".", "All", "rights", "reserved", ".", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "1", ".", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "2", ".", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "THIS", "SOFTWARE", "IS", "PROVIDED", "BY", "THE", "AUTHOR", "AND", "CONTRIBUTORS", "``", "AS", "IS", "''", "AND", "ANY", "EXPRESS", "OR", "IMPLIED", "WARRANTIES", ",", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "THE", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "ARE", "DISCLAIMED", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHOR", "OR", "CONTRIBUTORS", "BE", "LIABLE", "FOR", "ANY", "DIRECT", ",", "INDIRECT", ",", "INCIDENTAL", ",", "SPECIAL", ",", "EXEMPLARY", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "(", "INCLUDING", ",", "BUT", "NOT", "LIMITED", "TO", ",", "PROCUREMENT", "OF", "SUBSTITUTE", "GOODS", "OR", "SERVICES", ";", "LOSS", "OF", "USE", ",", "DATA", ",", "OR", "PROFITS", ";", "OR", "BUSINESS", "INTERRUPTION", ")", "HOWEVER", "CAUSED", "AND", "ON", "ANY", "THEORY", "OF", "LIABILITY", ",", "WHETHER", "IN", "CONTRACT", ",", "STRICT", "LIABILITY", ",", "OR", "TORT", "(", "INCLUDING", "NEGLIGENCE", "OR", "OTHERWISE", ")", "ARISING", "IN", "ANY", "WAY", "OUT", "OF", "THE", "USE", "OF", "THIS", "SOFTWARE", ",", "EVEN", "IF", "ADVISED", "OF", "THE", "POSSIBILITY", "OF", "SUCH", "DAMAGE", ".", "$", "Id", ":", "ostern.c", ",", "v", "1.8", "20150315", "00:41:28", "millert", "Exp", "$"], "ccode": ["/*\t$OpenBSD: ostern.c,v 1.8 2015/03/15 00:41:28 millert Exp $\t*/\n", "\n", "/*\n", " * Copyright (c) 1996 Wolfram Schneider <wosch@FreeBSD.org>. Berlin.\n", " * All rights reserved.\n", " *\n", " * Redistribution and use in source and binary forms, with or without\n", " * modification, are permitted provided that the following conditions\n", " * are met:\n", " * 1. Redistributions of source code must retain the above copyright\n", " *    notice, this list of conditions and the following disclaimer.\n", " * 2. Redistributions in binary form must reproduce the above copyright\n", " *    notice, this list of conditions and the following disclaimer in the\n", " *    documentation and/or other materials provided with the distribution.\n", " *\n", " * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n", " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n", " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n", " * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n", " * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n", " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n", " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n", " * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n", " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n", " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n", " * SUCH DAMAGE.\n", " *\n", " * \t$Id: ostern.c,v 1.8 2015/03/15 00:41:28 millert Exp $\n", " */\n", "\n", "#include <stdio.h>\n", "#include <time.h>\n", "\n", "#include \"calendar.h\"\n", "\n", "/* return year day for Easter */\n", "\n", "int\n", "easter(int year)\t/* 0 ... abcd, NOT since 1900 */\n", "{\n", "\tint\te_a, e_b, e_c, e_d, e_e,e_f, e_g, e_h, e_i, e_k;\n", "\tint\te_l, e_m, e_n, e_p, e_q;\n", "\n", "\t/* silly, but it works */\n", "\te_a = year % 19;\n", "\te_b = year / 100;\n", "\te_c = year % 100;\n", "\n", "\te_d = e_b / 4;\n", "\te_e = e_b % 4;\n", "\te_f = (e_b + 8) / 25;\n", "\te_g = (e_b + 1 - e_f) / 3;\n", "\te_h = ((19 * e_a) + 15 + e_b - (e_d + e_g)) % 30;\n", "\te_i = e_c / 4;\n", "\te_k = e_c % 4;\n", "\te_l = (32 + 2 * e_e + 2 * e_i - (e_h + e_k)) % 7;\n", "\te_m = (e_a + 11 * e_h + 22 * e_l) / 451;\n", "\te_n = (e_h + e_l + 114 - (7 * e_m)) / 31;\n", "\te_p = (e_h + e_l + 114 - (7 * e_m)) % 31;\n", "\te_p = e_p + 1;\n", "\n", "\te_q = 31 + 28 + e_p;\n", "\tif (isleap(year))\n", "\t\te_q++;\n", "\n", "\tif (e_n == 4)\n", "\te_q += 31;\n", "\n", "#if DEBUG\n", "\tprintf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\\n\",\n", "\t    e_a, e_b, e_c, e_d, e_e, e_f, e_g, e_h,\n", "\t    e_i, e_k, e_l, e_m, e_n, e_p, e_q);\n", "#endif\n", "\n", "\treturn (e_q);\n", "}\n"], "project": "bsdmainutils", "file": "ostern.pkl", "function": "easter"}, {"comment_all": {"comment": "/*\n * since llist_search only takes string functions with two args\n * make a new strncmp by default uses len = strlen(s1)\n */", "depth": 0, "reading_ease": 70.13, "reading_grade": 8.0, "line": 79}, "comment_text": "/*\n * since llist_search only takes string functions with two args\n * make a new strncmp by default uses len = strlen(s1)\n */", "comment_tokens": ["since", "llist_search", "only", "takes", "string", "functions", "with", "two", "args", "make", "a", "new", "strncmp", "by", "default", "uses", "len", "=", "strlen", "(", "s1", ")"], "ccode": ["\n", "/*\n", " * since llist_search only takes string functions with two args\n", " * make a new strncmp by default uses len = strlen(s1)\n", " */\n", "int llist_strncmp(const char *s1, const char *s2)\n", "{\n", "   int len, rv;\n", "   len = strlen(s1);\n", "   rv = strncmp(s1, s2, len);\n", "   return rv;\n", "}\n"], "project": "ganglia-monitor", "file": "llist.pkl", "function": "llist_strncmp"}, {"comment_all": {"comment": "/* Default to 1 to catch not implemented architectures. */", "depth": 1, "reading_ease": 37.98, "reading_grade": 10.0, "line": 66}, "comment_text": "/* Default to 1 to catch not implemented architectures. */", "comment_tokens": ["Default", "to", "1", "to", "catch", "not", "implemented", "architectures", "."], "ccode": ["#endif\n", "\n", "int processor_flash_enable(void)\n", "{\n", "\t/* Default to 1 to catch not implemented architectures. */\n", "\tint ret = 1;\n", "\n", "\t/* FIXME: detect loongson on FreeBSD and OpenBSD as well.  */\n", "#if defined (__MIPSEL__) && defined (__linux)\n", "\tif (is_loongson()) {\n", "\t\tflashbase = 0x1fc00000;\n", "\t\tret = 0;\n", "\t}\n", "#elif defined(__i386__) || defined(__x86_64__)\n", "\t/* On x86, flash access is not processor specific except on\n", "\t * AMD Elan SC520, AMD Geode and maybe other SoC-style CPUs.\n", "\t * FIXME: Move enable_flash_cs5536 and get_flashbase_sc520 here.\n", "\t */\n", "\tret = 0;\n", "#endif\n", "\treturn ret;\n", "}\n"], "project": "libflashrom1", "file": "processor_enable.pkl", "function": "processor_flash_enable"}, {"comment_all": {"comment": "/* TODO: XRandR rotation and size  */", "depth": 2, "reading_ease": 49.48, "reading_grade": 7.6, "line": 748}, "comment_text": "/* TODO: XRandR rotation and size  */", "comment_tokens": ["TODO", ":", "XRandR", "rotation", "and", "size"], "ccode": ["\n", "static void\n", "handle_xev(void) {\n", "\tXEvent ev;\n", "\tint i, sa_clicked=0;\n", "\tchar buf[32];\n", "\tKeySym ksym;\n", "\n", "\tXNextEvent(dzen.dpy, &ev);\n", "\tswitch(ev.type) {\n", "\t\tcase Expose:\n", "\t\t\tif(ev.xexpose.count == 0)\n", "\t\t\t\tx_redraw(ev.xexpose.window);\n", "\t\t\tbreak;\n", "\t\tcase EnterNotify:\n", "\t\t\tif(dzen.slave_win.ismenu) {\n", "\t\t\t\tfor(i=0; i < dzen.slave_win.max_lines; i++)\n", "\t\t\t\t\tif(ev.xcrossing.window == dzen.slave_win.line[i])\n", "\t\t\t\t\t\tx_hilight_line(i);\n", "\t\t\t}\n", "\t\t\tif(!dzen.slave_win.ishmenu\n", "\t\t\t\t\t&& ev.xcrossing.window == dzen.title_win.win)\n", "\t\t\t\tdo_action(entertitle);\n", "\t\t\tif(ev.xcrossing.window == dzen.slave_win.win)\n", "\t\t\t\tdo_action(enterslave);\n", "\t\t\tbreak;\n", "\t\tcase LeaveNotify:\n", "\t\t\tif(dzen.slave_win.ismenu) {\n", "\t\t\t\tfor(i=0; i < dzen.slave_win.max_lines; i++)\n", "\t\t\t\t\tif(ev.xcrossing.window == dzen.slave_win.line[i])\n", "\t\t\t\t\t\tx_unhilight_line(i);\n", "\t\t\t}\n", "\t\t\tif(!dzen.slave_win.ishmenu\n", "\t\t\t\t\t&& ev.xcrossing.window == dzen.title_win.win)\n", "\t\t\t\tdo_action(leavetitle);\n", "\t\t\tif(ev.xcrossing.window == dzen.slave_win.win) {\n", "\t\t\t\tdo_action(leaveslave);\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase ButtonRelease:\n", "\t\t\tif(dzen.slave_win.ismenu) {\n", "\t\t\t\tfor(i=0; i < dzen.slave_win.max_lines; i++)\n", "\t\t\t\t\tif(ev.xbutton.window == dzen.slave_win.line[i])\n", "\t\t\t\t\t\tdzen.slave_win.sel_line = i;\n", "\t\t\t}\n", "\n", "\t\t\t/* clickable areas */\n", "             for(i=sens_areas_cnt; i>=0; i--) {\n", "\t\t\t\tif(ev.xbutton.window == dzen.title_win.win &&\n", "\t\t\t\t\t\tev.xbutton.button == sens_areas[i].button &&\n", "\t\t\t\t\t\t(ev.xbutton.x >=  sens_areas[i].start_x+xorig &&\n", "\t\t\t\t\t\tev.xbutton.x <=  sens_areas[i].end_x+xorig) &&\n", "\t\t\t\t\t\t(ev.xbutton.y >=  sens_areas[i].start_y &&\n", "\t\t\t\t\t\tev.xbutton.y <=  sens_areas[i].end_y) &&\n", "                        sens_areas[i].active) {\n", "\t\t\t\t\tspawn(sens_areas[i].cmd);\n", "\t\t\t\t\tsa_clicked++;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tif(!sa_clicked) {\n", "\t\t\t\tswitch(ev.xbutton.button) {\n", "\t\t\t\t\tcase Button1:\n", "\t\t\t\t\t\tdo_action(button1);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button2:\n", "\t\t\t\t\t\tdo_action(button2);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button3:\n", "\t\t\t\t\t\tdo_action(button3);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button4:\n", "\t\t\t\t\t\tdo_action(button4);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button5:\n", "\t\t\t\t\t\tdo_action(button5);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button6:\n", "\t\t\t\t\t\tdo_action(button6);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t\tcase Button7:\n", "\t\t\t\t\t\tdo_action(button7);\n", "\t\t\t\t\t\tbreak;\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t\tbreak;\n", "\t\tcase KeyPress:\n", "\t\t\tXLookupString(&ev.xkey, buf, sizeof buf, &ksym, 0);\n", "\t\t\tdo_action(ksym+keymarker);\n", "\t\t\tbreak;\n", "\n", "\t\t/* TODO: XRandR rotation and size  */\n", "\t}\n", "}\n"], "project": "dzen2", "file": "main.pkl", "function": "handle_xev"}, {"comment_all": {"comment": "/* save some or all of current context */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 47}, "comment_text": "/* save some or all of current context */", "comment_tokens": ["save", "some", "or", "all", "of", "current", "context"], "ccode": ["\n", "static struct context_stack *cstack;\n", "\n", "/* save some or all of current context */\n", "\n", "/**/\n", "mod_export void\n", "zcontext_save_partial(int parts)\n", "{\n", "    struct context_stack *cs;\n", "\n", "    queue_signals();\n", "\n", "    cs = (struct context_stack *)malloc(sizeof(struct context_stack));\n", "\n", "    if (parts & ZCONTEXT_HIST) {\n", "\thist_context_save(&cs->hist_stack, !cstack);\n", "    }\n", "    if (parts & ZCONTEXT_LEX) {\n", "\tlex_context_save(&cs->lex_stack, !cstack);\n", "    }\n", "    if (parts & ZCONTEXT_PARSE) {\n", "\tparse_context_save(&cs->parse_stack, !cstack);\n", "    }\n", "\n", "    cs->next = cstack;\n", "    cstack = cs;\n", "\n", "    unqueue_signals();\n", "}\n"], "project": "zsh", "file": "context.pkl", "function": "zcontext_save_partial"}, {"comment_all": {"comment": "// Read extended JEDEC ID bytes\n", "depth": 2, "reading_ease": 83.32, "reading_grade": 2.9, "line": 184}, "comment_text": "// Read extended JEDEC ID bytes\n", "comment_tokens": ["Read", "extended", "JEDEC", "ID", "bytes"], "ccode": ["\n", "static void flash_read_id()\n", "{\n", "\t/* JEDEC ID structure:\n", "\t * Byte No. | Data Type\n", "\t * ---------+----------\n", "\t *        0 | FC_JEDECID Request Command\n", "\t *        1 | MFG ID\n", "\t *        2 | Dev ID 1\n", "\t *        3 | Dev ID 2\n", "\t *        4 | Ext Dev Str Len\n", "\t */\n", "\n", "\tuint8_t data[260] = { FC_JEDECID };\n", "\tint len = 5; // command + 4 response bytes\n", "\n", "\tif (verbose)\n", "\t\tfprintf(stderr, \"read flash ID..\\n\");\n", "\n", "\tflash_chip_select();\n", "\n", "\t// Write command and read first 4 bytes\n", "\tmpsse_xfer_spi(data, len);\n", "\n", "\tif (data[4] == 0xFF)\n", "\t\tfprintf(stderr, \"Extended Device String Length is 0xFF, \"\n", "\t\t\t\t\"this is likely a read error. Ignorig...\\n\");\n", "\telse {\n", "\t\t// Read extended JEDEC ID bytes\n", "\t\tif (data[4] != 0) {\n", "\t\t\tlen += data[4];\n", "\t\t\tmpsse_xfer_spi(data + 5, len - 5);\n", "\t\t}\n", "\t}\n", "\n", "\tflash_chip_deselect();\n", "\n", "\t// TODO: Add full decode of the JEDEC ID.\n", "\tfprintf(stderr, \"flash ID:\");\n", "\tfor (int i = 1; i < len; i++)\n", "\t\tfprintf(stderr, \" 0x%02X\", data[i]);\n", "\tfprintf(stderr, \"\\n\");\n", "}\n"], "project": "fpga-icestorm-chipdb", "file": "iceprog.pkl", "function": "flash_read_id"}, {"comment_all": {"comment": "// strip spaces from elements already loaded\n", "depth": 1, "reading_ease": 48.47, "reading_grade": 8.0, "line": 127}, "comment_text": "// strip spaces from elements already loaded\n", "comment_tokens": ["strip", "spaces", "from", "elements", "already", "loaded"], "ccode": ["\n", "static void OnEndElement(void *userData, const XML_Char *name)\n", "{\n", "    xml_parser_stack_t *stack = (xml_parser_stack_t *) userData;\n", "    xml_variable_t *document = (xml_variable_t *) stack->document;\n", "\n", "    // strip spaces from elements already loaded\n", "    if (!strcmp(stack->path, \"/variable/name\"))\n", "        document->name = XSD_StripSpaces(document->name);\n", "    if (!strcmp(stack->path, \"/variable/description\"))\n", "        document->description = XSD_StripSpaces(document->description);\n", "    if (!strcmp(stack->path, \"/variable/remarks\"))\n", "        document->remarks = XSD_StripSpaces(document->remarks);\n", "\n", "    if (!strcmp(stack->path, \"/variable/value/string\"))\n", "        document->value.string_description = XSD_StripSpaces(document->value.string_description);\n", "    if (!strcmp(stack->path, \"/variable/value/integer\"))\n", "        document->value.integer_description = XSD_StripSpaces(document->value.integer_description);\n", "    if (!strcmp(stack->path, \"/variable/value/float\"))\n", "        document->value.float_description = XSD_StripSpaces(document->value.float_description);\n", "    if (!strcmp(stack->path, \"/variable/value/boolean/true\"))\n", "        document->value.boolean_value.true_description = XSD_StripSpaces(document->value.boolean_value.true_description);\n", "    if (!strcmp(stack->path, \"/variable/value/boolean/false\"))\n", "        document->value.boolean_value.false_description = XSD_StripSpaces(document->value.boolean_value.false_description);\n", "    if (!strcmp(stack->path, \"/variable/value/enum/value\"))\n", "    {\n", "        variable_enum_value_t *last = document->value.enum_value;\n", "        while (last->next)\n", "            last = last->next;\n", "\n", "        last->name = XSD_StripSpaces(last->name);\n", "        last->description = XSD_StripSpaces(last->description);\n", "    }\n", "\n", "    XSD_OnEndElement(stack, name);\n", "}\n"], "project": "ezquake", "file": "xsd_variable.pkl", "function": "OnEndElement"}, {"comment_all": {"comment": "/*\n * Takes a UTF-32 code as input and outputs UTF-8.\n * Based on  Roman Czyborra:  http://czyborra.com/utf/\n */", "depth": 0, "reading_ease": 47.45, "reading_grade": 8.4, "line": 18}, "comment_text": "/*\n * Takes a UTF-32 code as input and outputs UTF-8.\n * Based on  Roman Czyborra:  http://czyborra.com/utf/\n */", "comment_tokens": ["Takes", "a", "UTF-32", "code", "as", "input", "and", "outputs", "UTF-8", ".", "Based", "on", "Roman", "Czyborra", ":", "http", ":", "czyborra.comutf"], "ccode": ["#include \"config.h\"\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <stddef.h>\n", "#ifdef HAVE_STDINT_H\n", "#include <stdint.h>\n", "#endif\n", "#include <unistd.h>\n", "#include <wchar.h>\n", "#include \"unicode.h\"\n", "#include \"utf8error.h\"\n", "\n", "#define FALSE 0\n", "#define TRUE 1\n", "\n", "/*\n", " * Takes a UTF-32 code as input and outputs UTF-8.\n", " * Based on  Roman Czyborra:  http://czyborra.com/utf/\n", " */\n", "\n", "void\n", "fputu8(wchar_t c,FILE *fp)\n", "{\n", "  if (c < 0x80) {\t\t/* ASCII */\n", "    putc (c,fp);\n", "  }\n", "  else if (c < 0x800) {\n", "    putc (0xC0 | c>>6,fp);\n", "    putc (0x80 | (c & 0x3F),fp);\n", "  }\n", "  else if (c < 0x10000) {\n", "    putc (0xE0 | c>>12,fp);\n", "    putc (0x80 | (c>>6 & 0x3F),fp);\n", "    putc (0x80 | (c & 0x3F),fp);\n", "  }\n", "  else if (c < 0x200000) {\t/* 2^21 */\n", "    putc (0xF0 | c>>18,fp);\n", "    putc (0x80 | (c>>12 & 0x3F),fp);\n", "    putc (0x80 | (c>>6 & 0x3F),fp);\n", "    putc (0x80 | (c & 0x3F),fp);\n", "  }\n", "}\n"], "project": "libuninum-dev", "file": "uniio.pkl", "function": "fputu8"}, {"comment_all": {"comment": "/* header name termination char found and enough space in buffer after it */", "depth": 3, "reading_ease": 67.76, "reading_grade": 6.8, "line": 274}, "comment_text": "/* header name termination char found and enough space in buffer after it */", "comment_tokens": ["header", "name", "termination", "char", "found", "and", "enough", "space", "in", "buffer", "after", "it"], "ccode": ["\n", "/**\n", " * parse_hname2_short() - safer version to parse header name stored in short buffers\n", " *   - parse_hanem2() reads 4 bytes at once, expecting to walk through a buffer\n", " *   that contains more than the header name (e.g., sip msg buf, full header buf\n", " *   with name and body)\n", " */\n", "char* parse_hname2_short(char* const begin, const char* const end, struct hdr_field* const hdr)\n", "{\n", "#define HBUF_MAX_SIZE 256\n", "\tchar hbuf[HBUF_MAX_SIZE];\n", "\tchar *p;\n", "\n", "\tif(end-begin>=HBUF_MAX_SIZE-4) {\n", "\t\tp = q_memchr(begin, ':', end - begin);\n", "\t\tif(p && p-4> begin) {\n", "\t\t\t/* header name termination char found and enough space in buffer after it */\n", "\t\t\treturn parse_hname2(begin, end, hdr);\n", "\t\t}\n", "\t\t/* not enough space */\n", "\t\tLM_ERR(\"not enough space to parse the header name in [%.*s] (%d)\\n\",\n", "\t\t\t\t(int)(end-begin), begin, (int)(end-begin));\n", "\t\treturn NULL;\n", "\t}\n", "\t/* pad with whitespace - tipycal char after the ':' of the header name */\n", "\tmemset(hbuf, ' ', HBUF_MAX_SIZE);\n", "\tmemcpy(hbuf, begin, end-begin);\n", "\tp = parse_hname2(hbuf, hbuf + 4 + (end-begin), hdr);\n", "\tif(!p) {\n", "\t\tLM_ERR(\"failed to parse the header name in [%.*s] (%d)\\n\",\n", "\t\t\t\t(int)(end-begin), begin, (int)(end-begin));\n", "\t\treturn NULL;\n", "\t}\n", "\treturn begin + (p-hbuf);\n", "}\n"], "project": "kamailio-ldap-modules", "file": "parse_hname2.pkl", "function": "parse_hname2_short"}, {"comment_all": {"comment": "// These may be redundant because of the memset earlier, but better safe than sorry\n", "depth": 2, "reading_ease": 57.27, "reading_grade": 8.8, "line": 1845}, "comment_text": "// These may be redundant because of the memset earlier, but better safe than sorry\n", "comment_tokens": ["These", "may", "be", "redundant", "because", "of", "the", "memset", "earlier", ",", "but", "better", "safe", "than", "sorry"], "ccode": ["\n", "static void *\n", "worker_comm_thread(void *arg)\n", "{\n", "  int                  n;\n", "  int                  fd;\n", "  int                  addrlen;\n", "  pthread_t            thread_id;\n", "\n", "  struct sockaddr_in   addr;\n", "\n", "  WORKERSIDE_ARGS     *data  = (WORKERSIDE_ARGS *)arg;\n", "  WORKER_DATA         *worker;\n", "\n", "  for ( ;; ) {\n", "\n", "    /* Wait for a worker to connect */\n", "    n = sizeof(addr);\n", "    if ((fd = accept(data->sock_fd, (struct sockaddr *)&addr, (unsigned int *)&n)) < 0) LOG_FATAL_MSG(\"accept\", errno);\n", "\n", "    if ((worker = malloc(sizeof(WORKER_DATA))) == NULL) LOG_FATAL_MSG(\"thread create\", errno);\n", "    memset(worker, 0, sizeof(WORKER_DATA));\n", "\n", "    worker->parent     = data;\n", "    worker->sock_fd    = fd;\n", "    worker->allocated_hits = 0; // These may be redundant because of the memset earlier, but better safe than sorry\n", "    worker->hits = NULL;\n", "\n", "    addrlen = sizeof(worker->ip_addr);\n", "    strncpy(worker->ip_addr, inet_ntoa(addr.sin_addr), addrlen);\n", "    worker->ip_addr[addrlen-1] = 0;\n", "\n", "    if ((n = pthread_create(&thread_id, NULL, workerside_thread, worker)) != 0) LOG_FATAL_MSG(\"thread create\", n);\n", "  }\n", "  \n", "  pthread_exit(NULL);\n", "}\n"], "project": "infernal-doc", "file": "hmmdmstr.pkl", "function": "worker_comm_thread"}, {"comment_all": {"comment": "// if kernel is updated, copy the ramdisk from original image\n", "depth": 2, "reading_ease": 61.33, "reading_grade": 7.2, "line": 565}, "comment_text": "// if kernel is updated, copy the ramdisk from original image\n", "comment_tokens": ["if", "kernel", "is", "updated", ",", "copy", "the", "ramdisk", "from", "original", "image"], "ccode": ["\n", "\n", "\n", "void update_images(t_abootimg *img)\n", "{\n", "  unsigned page_size = img->header.page_size;\n", "  unsigned ksize = img->header.kernel_size;\n", "  unsigned rsize = img->header.ramdisk_size;\n", "  unsigned ssize = img->header.second_size;\n", "\n", "  if (!page_size)\n", "    abort_printf(\"%s: Image page size is null\\n\", img->fname);\n", "\n", "  unsigned n = (ksize + page_size - 1) / page_size;\n", "  unsigned m = (rsize + page_size - 1) / page_size;\n", "  unsigned o = (ssize + page_size - 1) / page_size;\n", "\n", "  unsigned roffset = (1+n)*page_size;\n", "  unsigned soffset = (1+n+m)*page_size;\n", "\n", "  if (img->kernel_fname) {\n", "    printf(\"reading kernel from %s\\n\", img->kernel_fname);\n", "    FILE* stream = fopen(img->kernel_fname, \"r\");\n", "    if (!stream)\n", "      abort_perror(img->kernel_fname);\n", "    struct stat st;\n", "    if (fstat(fileno(stream), &st))\n", "      abort_perror(img->kernel_fname);\n", "    ksize = st.st_size;\n", "    char* k = malloc(ksize);\n", "    if (!k)\n", "      abort_perror(\"\");\n", "    size_t rb = fread(k, ksize, 1, stream);\n", "    if ((rb!=1) || ferror(stream))\n", "      abort_perror(img->kernel_fname);\n", "    else if (feof(stream))\n", "      abort_printf(\"%s: cannot read kernel\\n\", img->kernel_fname);\n", "    fclose(stream);\n", "    img->header.kernel_size = ksize;\n", "    img->kernel = k;\n", "  }\n", "\n", "  if (img->ramdisk_fname) {\n", "    printf(\"reading ramdisk from %s\\n\", img->ramdisk_fname);\n", "    FILE* stream = fopen(img->ramdisk_fname, \"r\");\n", "    if (!stream)\n", "      abort_perror(img->ramdisk_fname);\n", "    struct stat st;\n", "    if (fstat(fileno(stream), &st))\n", "      abort_perror(img->ramdisk_fname);\n", "    rsize = st.st_size;\n", "    char* r = malloc(rsize);\n", "    if (!r)\n", "      abort_perror(\"\");\n", "    size_t rb = fread(r, rsize, 1, stream);\n", "    if ((rb!=1) || ferror(stream))\n", "      abort_perror(img->ramdisk_fname);\n", "    else if (feof(stream))\n", "      abort_printf(\"%s: cannot read ramdisk\\n\", img->ramdisk_fname);\n", "    fclose(stream);\n", "    img->header.ramdisk_size = rsize;\n", "    img->ramdisk = r;\n", "  }\n", "  else if (img->kernel) {\n", "    // if kernel is updated, copy the ramdisk from original image\n", "    char* r = malloc(rsize);\n", "    if (!r)\n", "      abort_perror(\"\");\n", "    if (fseek(img->stream, roffset, SEEK_SET))\n", "      abort_perror(img->fname);\n", "    size_t rb = fread(r, rsize, 1, img->stream);\n", "    if ((rb!=1) || ferror(img->stream))\n", "      abort_perror(img->fname);\n", "    else if (feof(img->stream))\n", "      abort_printf(\"%s: cannot read ramdisk\\n\", img->fname);\n", "    img->ramdisk = r;\n", "  }\n", "\n", "  if (img->second_fname) {\n", "    printf(\"reading second stage from %s\\n\", img->second_fname);\n", "    FILE* stream = fopen(img->second_fname, \"r\");\n", "    if (!stream)\n", "      abort_perror(img->second_fname);\n", "    struct stat st;\n", "    if (fstat(fileno(stream), &st))\n", "      abort_perror(img->second_fname);\n", "    ssize = st.st_size;\n", "    char* s = malloc(ssize);\n", "    if (!s)\n", "      abort_perror(\"\");\n", "    size_t rb = fread(s, ssize, 1, stream);\n", "    if ((rb!=1) || ferror(stream))\n", "      abort_perror(img->second_fname);\n", "    else if (feof(stream))\n", "      abort_printf(\"%s: cannot read second stage\\n\", img->second_fname);\n", "    fclose(stream);\n", "    img->header.second_size = ssize;\n", "    img->second = s;\n", "  }\n", "  else if (img->ramdisk && img->header.second_size) {\n", "    // if ramdisk is updated, copy the second stage from original image\n", "    char* s = malloc(ssize);\n", "    if (!s)\n", "      abort_perror(\"\");\n", "    if (fseek(img->stream, soffset, SEEK_SET))\n", "      abort_perror(img->fname);\n", "    size_t rb = fread(s, ssize, 1, img->stream);\n", "    if ((rb!=1) || ferror(img->stream))\n", "      abort_perror(img->fname);\n", "    else if (feof(img->stream))\n", "      abort_printf(\"%s: cannot read second stage\\n\", img->fname);\n", "    img->second = s;\n", "  }\n", "\n", "  n = (img->header.kernel_size + page_size - 1) / page_size;\n", "  m = (img->header.ramdisk_size + page_size - 1) / page_size;\n", "  o = (img->header.second_size + page_size - 1) / page_size;\n", "  unsigned total_size = (1+n+m+o)*page_size;\n", "\n", "  if (!img->size)\n", "    img->size = total_size;\n", "  else if (total_size > img->size)\n", "    abort_printf(\"%s: updated is too big for the Boot Image (%u vs %u bytes)\\n\", img->fname, total_size, img->size);\n", "}\n"], "project": "abootimg", "file": "abootimg.pkl", "function": "update_images"}, {"comment_all": {"comment": "/**\n *Displays the usage of the test\n *facility.\n *@param a_argc the argc variable passed to the main function.\n *@param a_argv the argv variable passed to the main function.\n */", "depth": 0, "reading_ease": 87.72, "reading_grade": 3.3, "line": 45}, "comment_text": "/**\n *Displays the usage of the test\n *facility.\n *@param a_argc the argc variable passed to the main function.\n *@param a_argv the argv variable passed to the main function.\n */", "comment_tokens": ["Displays", "the", "usage", "of", "the", "test", "facility", ".", "@", "param", "a_argc", "the", "argc", "variable", "passed", "to", "the", "main", "function", ".", "@", "param", "a_argv", "the", "argv", "variable", "passed", "to", "the", "main", "function", "."], "ccode": ["/* -*- Mode: C; indent-tabs-mode:nil; c-basic-offset:8 -*- */\n", "\n", "/*\n", " * This file is part of The Croco Library\n", " *\n", " * This program is free software; you can redistribute it and/or\n", " * modify it under the terms \n", " * of version 2.1 of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the \n", " * GNU Lesser General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n", " * USA\n", " *\n", " * See COPYRIGHTS file for copyright information.\n", " */\n", "\n", "#include <stdio.h>\n", "#include <string.h>\n", "#include \"cr-test-utils.h\"\n", "#include \"cr-parser.h\"\n", "\n", "/**\n", " *@file\n", " *Some test facilities for the #CRParser class.\n", " */\n", "\n", "CRDocHandler *gv_test_handler = { 0 };\n", "\n", "static void\n", "  display_help (char *prg_name);\n", "\n", "static void\n", "  display_about (char *prg_name);\n", "\n", "static enum CRStatus\n", "  test_cr_parser_parse (guchar * a_file_uri);\n", "\n", "/**\n", " *Displays the usage of the test\n", " *facility.\n", " *@param a_argc the argc variable passed to the main function.\n", " *@param a_argv the argv variable passed to the main function.\n", " */\n", "static void\n", "display_help (char *prg_name)\n", "{\n", "        fprintf (stdout, \"\\n\\n\");\n", "        fprintf (stdout, \"usage: %s <file-to-parse>\\n\", prg_name);\n", "        fprintf (stdout, \"\\t <file-to-parse>: the file to parse\\n\");\n", "        fprintf (stdout, \"\\n\\n\");\n", "        fprintf (stdout, \"Tests the cr_parser_parse () method.\\n\");\n", "        fprintf (stdout, \"Returns OK if the status is CR_OK, KO otherwise\\n\");\n", "        fprintf (stdout, \"\\n\\n\");\n", "}\n"], "project": "libcroco-tools", "file": "test2-main.pkl", "function": "display_help"}, {"comment_all": {"comment": "/**\n * @brief Unregister a network manager\n * @ingroup globus_net_manager\n * @details\n * The globus_net_manager_unregister() function removes this network manager\n * from those which will be called by the network manager interface\n * when network events occur. This is typically called by the network\n * manager when its module is deactivated.\n * @param[in] manager\n *     Manager information to unregister.\n *\n */", "depth": 0, "reading_ease": 21.09, "reading_grade": 14.4, "line": 18}, "comment_text": "/**\n * @brief Unregister a network manager\n * @ingroup globus_net_manager\n * @details\n * The globus_net_manager_unregister() function removes this network manager\n * from those which will be called by the network manager interface\n * when network events occur. This is typically called by the network\n * manager when its module is deactivated.\n * @param[in] manager\n *     Manager information to unregister.\n *\n */", "comment_tokens": ["@", "brief", "Unregister", "a", "network", "manager", "@", "ingroup", "globus_net_manager", "@", "details", "The", "globus_net_manager_unregister", "(", ")", "function", "removes", "this", "network", "manager", "from", "those", "which", "will", "be", "called", "by", "the", "network", "manager", "interface", "when", "network", "events", "occur", ".", "This", "is", "typically", "called", "by", "the", "network", "manager", "when", "its", "module", "is", "deactivated", ".", "@", "param", "[", "in", "]", "manager", "Manager", "information", "to", "unregister", "."], "ccode": ["/*\n", " * Copyright 1999-2014 University of Chicago\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "#include \"globus_net_manager.h\"\n", "\n", "/**\n", " * @brief Unregister a network manager\n", " * @ingroup globus_net_manager\n", " * @details\n", " * The globus_net_manager_unregister() function removes this network manager\n", " * from those which will be called by the network manager interface\n", " * when network events occur. This is typically called by the network\n", " * manager when its module is deactivated.\n", " * @param[in] manager\n", " *     Manager information to unregister.\n", " *\n", " */\n", "globus_result_t\n", "globus_net_manager_unregister(\n", "    globus_net_manager_t               *manager)\n", "{\n", "    globus_extension_registry_remove(\n", "        GLOBUS_NET_MANAGER_REGISTRY, (void *) manager->name);\n", "    \n", "    return GLOBUS_SUCCESS;\n", "}\n"], "project": "libglobus-xio-net-manager-driver-dev", "file": "unregister.pkl", "function": "globus_net_manager_unregister"}, {"comment_all": {"comment": "/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */", "depth": 3, "reading_ease": 82.65, "reading_grade": 5.2, "line": 3363}, "comment_text": "/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */", "comment_tokens": ["We", "matched", "a", "single", "character", ",", "the", "EOB", ",", "so", "treat", "this", "as", "a", "final", "EOF", "."], "ccode": ["\n", "/* yy_get_next_buffer - try to read in a new buffer\n", " *\n", " * Returns a code representing an action:\n", " *\tEOB_ACT_LAST_MATCH -\n", " *\tEOB_ACT_CONTINUE_SCAN - continue scanning from current position\n", " *\tEOB_ACT_END_OF_FILE - end of file\n", " */\n", "static int yy_get_next_buffer (void)\n", "{\n", "    \tchar *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n", "\tchar *source = (yytext_ptr);\n", "\tint number_to_move, i;\n", "\tint ret_val;\n", "\n", "\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n", "\t\tYY_FATAL_ERROR(\n", "\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n", "\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n", "\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n", "\t\t\t{\n", "\t\t\t/* We matched a single character, the EOB, so\n", "\t\t\t * treat this as a final EOF.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_END_OF_FILE;\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\t/* We matched some text prior to the EOB, first\n", "\t\t\t * process it.\n", "\t\t\t */\n", "\t\t\treturn EOB_ACT_LAST_MATCH;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t/* Try to read more data. */\n", "\n", "\t/* First move last chars to start of buffer. */\n", "\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);\n", "\n", "\tfor ( i = 0; i < number_to_move; ++i )\n", "\t\t*(dest++) = *(source++);\n", "\n", "\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n", "\t\t/* don't do the read, it's not guaranteed to return an EOF,\n", "\t\t * just force an EOF\n", "\t\t */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n", "\n", "\telse\n", "\t\t{\n", "\t\t\tint num_to_read =\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n", "\n", "\t\twhile ( num_to_read <= 0 )\n", "\t\t\t{ /* Not enough room in the buffer - grow it. */\n", "\n", "\t\t\t/* just a shorter name for the current buffer */\n", "\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n", "\n", "\t\t\tint yy_c_buf_p_offset =\n", "\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n", "\n", "\t\t\tif ( b->yy_is_our_buffer )\n", "\t\t\t\t{\n", "\t\t\t\tint new_size = b->yy_buf_size * 2;\n", "\n", "\t\t\t\tif ( new_size <= 0 )\n", "\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n", "\t\t\t\telse\n", "\t\t\t\t\tb->yy_buf_size *= 2;\n", "\n", "\t\t\t\tb->yy_ch_buf = (char *)\n", "\t\t\t\t\t/* Include room in for 2 EOB chars. */\n", "\t\t\t\t\tyyrealloc( (void *) b->yy_ch_buf,\n", "\t\t\t\t\t\t\t (yy_size_t) (b->yy_buf_size + 2)  );\n", "\t\t\t\t}\n", "\t\t\telse\n", "\t\t\t\t/* Can't grow it, we don't own it. */\n", "\t\t\t\tb->yy_ch_buf = NULL;\n", "\n", "\t\t\tif ( ! b->yy_ch_buf )\n", "\t\t\t\tYY_FATAL_ERROR(\n", "\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n", "\n", "\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n", "\n", "\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n", "\t\t\t\t\t\tnumber_to_move - 1;\n", "\n", "\t\t\t}\n", "\n", "\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n", "\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n", "\n", "\t\t/* Read in more data. */\n", "\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n", "\t\t\t(yy_n_chars), num_to_read );\n", "\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n", "\t\t}\n", "\n", "\tif ( (yy_n_chars) == 0 )\n", "\t\t{\n", "\t\tif ( number_to_move == YY_MORE_ADJ )\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_END_OF_FILE;\n", "\t\t\tyyrestart( yyin  );\n", "\t\t\t}\n", "\n", "\t\telse\n", "\t\t\t{\n", "\t\t\tret_val = EOB_ACT_LAST_MATCH;\n", "\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n", "\t\t\t\tYY_BUFFER_EOF_PENDING;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\telse\n", "\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n", "\n", "\tif (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n", "\t\t/* Extend the array by 50%, plus the number we really need. */\n", "\t\tint new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(\n", "\t\t\t(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );\n", "\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n", "\t\t/* \"- 2\" to take care of EOB's */\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);\n", "\t}\n", "\n", "\t(yy_n_chars) += number_to_move;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n", "\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n", "\n", "\treturn ret_val;\n", "}\n"], "project": "linux-azure-5.8-headers-5.8.0-1033", "file": "lexer.lex.pkl", "function": "yy_get_next_buffer"}, {"comment_all": {"comment": "/* Authentication required but no auth info available */", "depth": 7, "reading_ease": 30.53, "reading_grade": 10.7, "line": 247}, "comment_text": "/* Authentication required but no auth info available */", "comment_tokens": ["Authentication", "required", "but", "no", "auth", "info", "available"], "ccode": ["\n", "\n", "static gint\n", "socket_recv_messages (NiceSocket *sock,\n", "    NiceInputMessage *recv_messages, guint n_recv_messages)\n", "{\n", "  Socks5Priv *priv = sock->priv;\n", "  guint i;\n", "  gint ret = -1;\n", "\n", "  /* Make sure socket has not been freed: */\n", "  g_assert (sock->priv != NULL);\n", "\n", "  switch (priv->state) {\n", "    case SOCKS_STATE_CONNECTED:\n", "      /* Common case: fast pass-through to the base socket once we\u2019re\n", "       * connected. */\n", "      if (priv->base_socket) {\n", "        ret = nice_socket_recv_messages (priv->base_socket,\n", "            recv_messages, n_recv_messages);\n", "      }\n", "\n", "      if (ret <= 0)\n", "        return ret;\n", "\n", "      /* After successfully receiving into at least one NiceInputMessage,\n", "       * update the from address in each valid NiceInputMessage. */\n", "      for (i = 0; i < (guint) ret; i++) {\n", "        if (recv_messages[i].from != NULL)\n", "          *recv_messages[i].from = priv->addr;\n", "      }\n", "\n", "      return ret;\n", "\n", "    case SOCKS_STATE_INIT:\n", "      {\n", "        guint8 data[2];\n", "        GInputVector local_recv_buf = { data, sizeof (data) };\n", "        NiceInputMessage local_recv_message = { &local_recv_buf, 1, NULL, 0 };\n", "\n", "        nice_debug (\"Socks5 state Init\");\n", "\n", "        if (priv->base_socket) {\n", "          ret = nice_socket_recv_messages (priv->base_socket,\n", "              &local_recv_message, 1);\n", "        }\n", "\n", "        if (ret <= 0) {\n", "          return ret;\n", "        } else if (ret == 1 && local_recv_buf.size == sizeof(data)) {\n", "          if (data[0] == 0x05) {\n", "            if (data[1] == 0x02) {\n", "              gchar msg[515];\n", "              gint len = 0;\n", "\n", "              if (priv->username || priv->password) {\n", "                gint ulen = 0;\n", "                gint plen = 0;\n", "\n", "                if (priv->username)\n", "                  ulen = strlen (priv->username);\n", "                if (ulen > 255) {\n", "                  nice_debug (\"Socks5 username length > 255\");\n", "                  goto error;\n", "                }\n", "\n", "                if (priv->password)\n", "                  plen  = strlen (priv->password);\n", "                if (plen > 255) {\n", "                  nice_debug (\"Socks5 password length > 255\");\n", "                  goto error;\n", "                }\n", "\n", "                msg[len++] = 0x01; /* auth version */\n", "                msg[len++] = ulen; /* username length */\n", "                if (ulen > 0)\n", "                  memcpy (msg + len, priv->username, ulen); /* Username */\n", "                len += ulen;\n", "                msg[len++] = plen; /* Password length */\n", "                if (plen > 0)\n", "                  memcpy (msg + len, priv->password, plen); /* Password */\n", "                len += plen;\n", "\n", "                nice_socket_send_reliable (priv->base_socket, NULL, len, msg);\n", "                priv->state = SOCKS_STATE_AUTH;\n", "              } else {\n", "                /* Authentication required but no auth info available */\n", "                goto error;\n", "              }\n", "            } else if (data[1] == 0x00) {\n", "              goto send_connect;\n", "            } else {\n", "              /* method not supported by socks server */\n", "              goto error;\n", "            }\n", "          } else {\n", "            /* invalid SOCKS server version */\n", "            goto error;\n", "          }\n", "        } else {\n", "          /* read error */\n", "          goto error;\n", "        }\n", "      }\n", "      break;\n", "    case SOCKS_STATE_AUTH:\n", "      {\n", "        guint8 data[2];\n", "        GInputVector local_recv_buf = { data, sizeof (data) };\n", "        NiceInputMessage local_recv_message = { &local_recv_buf, 1, NULL, 0 };\n", "\n", "        nice_debug (\"Socks5 state auth\");\n", "        if (priv->base_socket) {\n", "          ret = nice_socket_recv_messages (priv->base_socket,\n", "              &local_recv_message, 1);\n", "        }\n", "\n", "        if (ret <= 0) {\n", "          return ret;\n", "        } else if (ret == 1 && local_recv_buf.size == sizeof(data)) {\n", "          if (data[0] == 0x01 && data[1] == 0x00) {\n", "            /* Authenticated */\n", "            goto send_connect;\n", "          } else {\n", "            /* Authentication failed */\n", "            goto error;\n", "          }\n", "        }\n", "      }\n", "      break;\n", "    case SOCKS_STATE_CONNECT:\n", "      {\n", "        guint8 data[22];\n", "        GInputVector local_recv_buf = { data, sizeof (data) };\n", "        NiceInputMessage local_recv_message = { &local_recv_buf, 1, NULL, 0 };\n", "\n", "        nice_debug (\"Socks5 state connect\");\n", "        if (priv->base_socket) {\n", "          local_recv_buf.size = 4;\n", "          ret = nice_socket_recv_messages (priv->base_socket,\n", "              &local_recv_message, 1);\n", "        }\n", "\n", "        if (ret <= 0) {\n", "          return ret;\n", "        } else if (ret == 1 && local_recv_buf.size == 4) {\n", "          if (data[0] == 0x05) {\n", "            switch (data[1]) {\n", "              case 0x00:\n", "                if (data[2] == 0x00) {\n", "                  switch (data[3]) {\n", "                    case 0x01: /* IPV4 bound address */\n", "                      local_recv_buf.size = 6;\n", "                      ret = nice_socket_recv_messages (priv->base_socket,\n", "                          &local_recv_message, 1);\n", "                      if (ret != 1 || local_recv_buf.size != 6) {\n", "                        /* Could not read server bound address */\n", "                        goto error;\n", "                      }\n", "                      break;\n", "                    case 0x04: /* IPV6 bound address */\n", "                      local_recv_buf.size = 18;\n", "                      ret = nice_socket_recv_messages (priv->base_socket,\n", "                          &local_recv_message, 1);\n", "                      if (ret != 1 || local_recv_buf.size != 18) {\n", "                        /* Could not read server bound address */\n", "                        goto error;\n", "                      }\n", "                      break;\n", "                    default:\n", "                      /* Unsupported address type */\n", "                      goto error;\n", "                  }\n", "                  nice_socket_flush_send_queue (priv->base_socket,\n", "                      &priv->send_queue);\n", "                  priv->state = SOCKS_STATE_CONNECTED;\n", "                } else {\n", "                  /* Wrong reserved value */\n", "                  goto error;\n", "                }\n", "                break;\n", "              case 0x01: /* general SOCKS server failure */\n", "              case 0x02: /* connection not allowed by ruleset */\n", "              case 0x03: /* Network unreachable */\n", "              case 0x04: /* Host unreachable */\n", "              case 0x05: /* Connection refused */\n", "              case 0x06: /* TTL expired */\n", "              case 0x07: /* Command not supported */\n", "              case 0x08: /* Address type not supported */\n", "              default: /* Unknown error */\n", "                goto error;\n", "                break;\n", "            }\n", "          } else {\n", "            /* Wrong server version */\n", "            goto error;\n", "          }\n", "        } else {\n", "          /* Invalid data received */\n", "          goto error;\n", "        }\n", "      }\n", "      break;\n", "    case SOCKS_STATE_ERROR:\n", "    default:\n", "      /* Unknown status */\n", "      goto error;\n", "  }\n", "\n", "  return 0;\n", "\n", " send_connect:\n", "  {\n", "    gchar msg[22];\n", "    gint len = 0;\n", "    union {\n", "      struct sockaddr_storage storage;\n", "      struct sockaddr addr;\n", "      struct sockaddr_in in;\n", "      struct sockaddr_in6 in6;\n", "    } name;\n", "    nice_address_copy_to_sockaddr(&priv->addr, &name.addr);\n", "\n", "    msg[len++] = 0x05; /* SOCKS version */\n", "    msg[len++] = 0x01; /* connect command */\n", "    msg[len++] = 0x00; /* reserved */\n", "    if (name.storage.ss_family == AF_INET) {\n", "      msg[len++] = 0x01; /* IPV4 address type */\n", "      /* Address */\n", "      memcpy (msg + len, &(&name.in)->sin_addr, 4);\n", "      len += 4;\n", "      /* Port */\n", "      memcpy (msg + len, &(&name.in)->sin_port, 2);\n", "      len += 2;\n", "    } else if (name.storage.ss_family == AF_INET6) {\n", "      msg[len++] = 0x04; /* IPV6 address type */\n", "      /* Address */\n", "      memcpy (msg + len, &(&name.in6)->sin6_addr, 16);\n", "      len += 16;\n", "      /* Port */\n", "      memcpy (msg + len, &(&name.in6)->sin6_port, 2);\n", "      len += 2;\n", "    }\n", "\n", "    nice_socket_send_reliable (priv->base_socket, NULL, len, msg);\n", "    priv->state = SOCKS_STATE_CONNECT;\n", "\n", "    return 0;\n", "  }\n", " error:\n", "  nice_debug (\"Socks5 error\");\n", "  if (priv->base_socket)\n", "    nice_socket_free (priv->base_socket);\n", "  priv->base_socket = NULL;\n", "  priv->state = SOCKS_STATE_ERROR;\n", "\n", "  return -1;\n", "}\n"], "project": "libnice-dev", "file": "socks5.pkl", "function": "socket_recv_messages"}, {"comment_all": {"comment": "/* Write all the section headers for the sections.  */", "depth": 1, "reading_ease": 80.28, "reading_grade": 4.1, "line": 834}, "comment_text": "/* Write all the section headers for the sections.  */", "comment_tokens": ["Write", "all", "the", "section", "headers", "for", "the", "sections", "."], "ccode": ["\n", "static bfd_boolean\n", "tekhex_write_object_contents (bfd *abfd)\n", "{\n", "  char buffer[100];\n", "  asymbol **p;\n", "  asection *s;\n", "  struct data_struct *d;\n", "\n", "  tekhex_init ();\n", "\n", "  /* And the raw data.  */\n", "  for (d = abfd->tdata.tekhex_data->data;\n", "       d != NULL;\n", "       d = d->next)\n", "    {\n", "      int low;\n", "      int addr;\n", "\n", "      /* Write it in blocks of 32 bytes.  */\n", "      for (addr = 0; addr < CHUNK_MASK + 1; addr += CHUNK_SPAN)\n", "\t{\n", "\t  if (d->chunk_init[addr / CHUNK_SPAN])\n", "\t    {\n", "\t      char *dst = buffer;\n", "\n", "\t      writevalue (&dst, addr + d->vma);\n", "\t      for (low = 0; low < CHUNK_SPAN; low++)\n", "\t\t{\n", "\t\t  TOHEX (dst, d->chunk_data[addr + low]);\n", "\t\t  dst += 2;\n", "\t\t}\n", "\t      out (abfd, '6', buffer, dst);\n", "\t    }\n", "\t}\n", "    }\n", "\n", "  /* Write all the section headers for the sections.  */\n", "  for (s = abfd->sections; s != NULL; s = s->next)\n", "    {\n", "      char *dst = buffer;\n", "\n", "      writesym (&dst, s->name);\n", "      *dst++ = '1';\n", "      writevalue (&dst, s->vma);\n", "      writevalue (&dst, s->vma + s->size);\n", "      out (abfd, '3', buffer, dst);\n", "    }\n", "\n", "  /* And the symbols.  */\n", "  if (abfd->outsymbols)\n", "    {\n", "      for (p = abfd->outsymbols; *p; p++)\n", "\t{\n", "\t  int section_code = bfd_decode_symclass (*p);\n", "\n", "\t  if (section_code != '?')\n", "\t    {\n", "\t      /* Do not include debug symbols.  */\n", "\t      asymbol *sym = *p;\n", "\t      char *dst = buffer;\n", "\n", "\t      writesym (&dst, sym->section->name);\n", "\n", "\t      switch (section_code)\n", "\t\t{\n", "\t\tcase 'A':\n", "\t\t  *dst++ = '2';\n", "\t\t  break;\n", "\t\tcase 'a':\n", "\t\t  *dst++ = '6';\n", "\t\t  break;\n", "\t\tcase 'D':\n", "\t\tcase 'B':\n", "\t\tcase 'O':\n", "\t\t  *dst++ = '4';\n", "\t\t  break;\n", "\t\tcase 'd':\n", "\t\tcase 'b':\n", "\t\tcase 'o':\n", "\t\t  *dst++ = '8';\n", "\t\t  break;\n", "\t\tcase 'T':\n", "\t\t  *dst++ = '3';\n", "\t\t  break;\n", "\t\tcase 't':\n", "\t\t  *dst++ = '7';\n", "\t\t  break;\n", "\t\tcase 'C':\n", "\t\tcase 'U':\n", "\t\t  bfd_set_error (bfd_error_wrong_format);\n", "\t\t  return FALSE;\n", "\t\t}\n", "\n", "\t      writesym (&dst, sym->name);\n", "\t      writevalue (&dst, sym->value + sym->section->vma);\n", "\t      out (abfd, '3', buffer, dst);\n", "\t    }\n", "\t}\n", "    }\n", "\n", "  /* And the terminator.  */\n", "  if (bfd_bwrite (\"%0781010\\n\", (bfd_size_type) 9, abfd) != 9)\n", "    abort ();\n", "  return TRUE;\n", "}\n"], "project": "binutils-riscv64-linux-gnu-dbg", "file": "tekhex.pkl", "function": "tekhex_write_object_contents"}, {"comment_all": {"comment": "/* GAdmin-OpenVPN - An easy to use GTK+ frontend for the openvpn client.\n * Copyright (C) 2008 - 2012 Magnus Loef <magnus-swe@telia.com> \n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *\n*/", "depth": 0, "reading_ease": 60.95, "reading_grade": 9.4, "line": 0}, "comment_text": "/* GAdmin-OpenVPN - An easy to use GTK+ frontend for the openvpn client.\n * Copyright (C) 2008 - 2012 Magnus Loef <magnus-swe@telia.com> \n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *\n*/", "comment_tokens": ["GAdmin-OpenVPN", "-", "An", "easy", "to", "use", "GTK+", "frontend", "for", "the", "openvpn", "client", ".", "Copyright", "(", "C", ")", "2008", "-", "2012", "Magnus", "Loef", "<", "magnus-swe", "@", "telia.com", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA", "."], "ccode": ["/* GAdmin-OpenVPN - An easy to use GTK+ frontend for the openvpn client.\n", " * Copyright (C) 2008 - 2012 Magnus Loef <magnus-swe@telia.com> \n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 3 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", " * See the GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License along\n", " * with this program; if not, write to the Free Software Foundation, Inc.,\n", " * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n", " *\n", "*/\n", "\n", "\n", "#include \"../config.h\"\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "#include <string.h>\n", "\n", "char * allocate(long allocate_size)\n", "{\n", "    char *ret;\n", "    ret = malloc(allocate_size);\n", "    if( ret == NULL )\n", "    {\n", "        printf(\"Cant allocate enough ram, exiting\\n\");\n", "        exit(1);\n", "    }\n", "    memset(ret, 0, allocate_size);\n", "\n", "    return ret;\n", "}\n"], "project": "gadmin-openvpn-client", "file": "allocate.pkl", "function": "allocate"}, {"comment_all": {"comment": "/* \n * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n */", "depth": 0, "reading_ease": 69.68, "reading_grade": 6.0, "line": 0}, "comment_text": "/* \n * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n */", "comment_tokens": ["Copyright", "1988", ",", "1989", "Hans-J", ".", "Boehm", ",", "Alan", "J.", "Demers", "Copyright", "(", "c", ")", "1991-1994", "by", "Xerox", "Corporation", ".", "All", "rights", "reserved", ".", "Copyright", "(", "c", ")", "2000", "by", "Hewlett-Packard", "Company", ".", "All", "rights", "reserved", ".", "THIS", "MATERIAL", "IS", "PROVIDED", "AS", "IS", ",", "WITH", "ABSOLUTELY", "NO", "WARRANTY", "EXPRESSED", "OR", "IMPLIED", ".", "ANY", "USE", "IS", "AT", "YOUR", "OWN", "RISK", ".", "Permission", "is", "hereby", "granted", "to", "use", "or", "copy", "this", "program", "for", "any", "purpose", ",", "provided", "the", "above", "notices", "are", "retained", "on", "all", "copies", ".", "Permission", "to", "modify", "the", "code", "and", "to", "distribute", "modified", "code", "is", "granted", ",", "provided", "the", "above", "notices", "are", "retained", ",", "and", "a", "notice", "that", "the", "code", "was", "modified", "is", "included", "with", "the", "above", "copyright", "notice", "."], "ccode": ["/* \n", " * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n", " * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n", " * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n", " *\n", " * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n", " * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n", " *\n", " * Permission is hereby granted to use or copy this program\n", " * for any purpose,  provided the above notices are retained on all copies.\n", " * Permission to modify the code and to distribute modified code is granted,\n", " * provided the above notices are retained, and a notice that the code was\n", " * modified is included with the above copyright notice.\n", " */\n", "/* Boehm, February 7, 1996 4:32 pm PST */\n", " \n", "#include <stdio.h>\n", "#include \"private/gc_priv.h\"\n", "\n", "extern ptr_t GC_clear_stack();\t/* in misc.c, behaves like identity */\n", "void GC_extend_size_map();\t/* in misc.c. */\n", "\n", "/* Allocate reclaim list for kind:\t*/\n", "/* Return TRUE on success\t\t*/\n", "GC_bool GC_alloc_reclaim_list(kind)\n", "register struct obj_kind * kind;\n", "{\n", "    struct hblk ** result = (struct hblk **)\n", "    \t\tGC_scratch_alloc((MAXOBJSZ+1) * sizeof(struct hblk *));\n", "    if (result == 0) return(FALSE);\n", "    BZERO(result, (MAXOBJSZ+1)*sizeof(struct hblk *));\n", "    kind -> ok_reclaim_list = result;\n", "    return(TRUE);\n", "}\n"], "project": "libmono-cscompmgd0.0-cil", "file": "malloc.pkl", "function": "GC_alloc_reclaim_list"}, {"comment_all": {"comment": "/*\nCheck object lists.  We look for:\n\n1)  Loops and bad prev pointers.\n\n2)  Dead objects.\n\n3)  Invalid types.\n\n4)  Invalid owners.\n*/", "depth": 0, "reading_ease": 92.59, "reading_grade": 1.4, "line": 159}, "comment_text": "/*\nCheck object lists.  We look for:\n\n1)  Loops and bad prev pointers.\n\n2)  Dead objects.\n\n3)  Invalid types.\n\n4)  Invalid owners.\n*/", "comment_tokens": ["Check", "object", "lists", ".", "We", "look", "for", ":", "1", ")", "Loops", "and", "bad", "prev", "pointers", ".", "2", ")", "Dead", "objects", ".", "3", ")", "Invalid", "types", ".", "4", ")", "Invalid", "owners", "."], "ccode": ["\n", "/*\n", "Check object lists.  We look for:\n", "\n", "1)  Loops and bad prev pointers.\n", "\n", "2)  Dead objects.\n", "\n", "3)  Invalid types.\n", "\n", "4)  Invalid owners.\n", "*/\n", "\n", "void\n", "check_obj(piece_info_t **list, int owner)\n", "{\n", "    long i, j;\n", "    piece_info_t *p;\n", "\t\n", "    for (i = 0; i < NUM_OBJECTS; i++)\n", "\tfor (p = list[i]; p != NULL; p = p->piece_link.next) {\n", "\t    ASSERT (p->owner == owner);\n", "\t    ASSERT (p->type == i);\n", "\t    ASSERT (p->hits > 0);\n", "\t\t\n", "\t    j = p - object;\n", "\t    ASSERT (!in_obj[j]);\n", "\t    in_obj[j] = 1;\n", "\t\n", "\t    if (p->piece_link.prev)\n", "\t\tASSERT (p->piece_link.prev->piece_link.next == p);\n", "\t}\n", "}\n"], "project": "empire", "file": "util.pkl", "function": "check_obj"}, {"comment_all": {"comment": "/* years since 1980 */", "depth": 2, "reading_ease": 119.19, "reading_grade": -2.7, "line": 61}, "comment_text": "/* days since Jan 1. */\n/* years since 1980 */\n", "comment_tokens": ["days", "since", "Jan", "1.", "years", "since", "1980"], "ccode": ["\n", "static char *ending(int);\n", "static void print(struct disc_time);\n", "static struct disc_time convert(int,int);\n", "\n", "/*! @module spider\n", " */\n", "\n", "/*! @decl string discdate(int time)\n", " */\n", "void f_discdate(INT32 args)\n", "{\n", "  time_t t;\n", "  int bob,raw;\n", "  struct disc_time hastur;\n", "  if (args != 1)\n", "    SIMPLE_TOO_FEW_ARGS_ERROR(\"discdate\",1);\n", "  else {\n", "    struct tm *eris;\n", "    t=Pike_sp[-args].u.integer;\n", "    eris=localtime(&t);\n", "    if (!eris) Pike_error (\"localtime() failed to convert %ld\\n\", (long) t);\n", "    bob=eris->tm_yday;\t\t/* days since Jan 1. */\n", "    raw=eris->tm_year;\t\t/* years since 1980 */\n", "    hastur=convert(bob,raw);\n", "  }\n", "  pop_n_elems(args);\n", "  print(hastur);\n", "}\n"], "project": "pike8.0", "file": "discdate.pkl", "function": "f_discdate"}, {"comment_all": {"comment": "/* see if the connection supports the service point interface */", "depth": 1, "reading_ease": 53.88, "reading_grade": 8.0, "line": 176}, "comment_text": "/* see if the connection supports the service point interface */", "comment_tokens": ["see", "if", "the", "connection", "supports", "the", "service", "point", "interface"], "ccode": ["\n", "void\n", "mcd_connection_service_point_setup (McdConnection *connection, gboolean watch)\n", "{\n", "  TpConnection *tp_conn = mcd_connection_get_tp_connection (connection);\n", "\n", "  if (G_UNLIKELY (!tp_conn))\n", "    return;\n", "\n", "  /* see if the connection supports the service point interface */\n", "  tp_cli_connection_call_get_interfaces (tp_conn, -1,\n", "      service_point_interface_check,\n", "      GUINT_TO_POINTER (watch), NULL, G_OBJECT (connection));\n", "}\n"], "project": "libmission-control-plugins0", "file": "mcd-connection-service-points.pkl", "function": "mcd_connection_service_point_setup"}, {"comment_all": {"comment": "/* But I don't know of a better solution.\t\t\t\t*/", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 47}, "comment_text": "/* Make sure we're not in the middle of a collection, and make\t*/\n/* sure we don't start any.\tReturns previous value of GC_dont_gc.\t*/\n/* This is invoked prior to a dlopen call to avoid synchronization\t*/\n/* issues.  We can't just acquire the allocation lock, since startup \t*/\n/* code in dlopen may try to allocate.\t\t\t\t*/\n/* This solution risks heap growth in the presence of many dlopen\t*/\n/* calls in either a multithreaded environment, or if the library\t*/\n/* initialization code allocates substantial amounts of GC'ed memory.\t*/\n/* But I don't know of a better solution.\t\t\t\t*/\n", "comment_tokens": ["Make", "sure", "we", "'re", "not", "in", "the", "middle", "of", "a", "collection", ",", "and", "make", "sure", "we", "do", "n't", "start", "any", ".", "Returns", "previous", "value", "of", "GC_dont_gc", ".", "This", "is", "invoked", "prior", "to", "a", "dlopen", "call", "to", "avoid", "synchronization", "issues", ".", "We", "ca", "n't", "just", "acquire", "the", "allocation", "lock", ",", "since", "startup", "code", "in", "dlopen", "may", "try", "to", "allocate", ".", "This", "solution", "risks", "heap", "growth", "in", "the", "presence", "of", "many", "dlopen", "calls", "in", "either", "a", "multithreaded", "environment", ",", "or", "if", "the", "library", "initialization", "code", "allocates", "substantial", "amounts", "of", "GC'ed", "memory", ".", "But", "I", "do", "n't", "know", "of", "a", "better", "solution", "."], "ccode": ["/*\n", " * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n", " * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n", " * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n", " *\n", " * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n", " * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n", " *\n", " * Permission is hereby granted to use or copy this program\n", " * for any purpose,  provided the above notices are retained on all copies.\n", " * Permission to modify the code and to distribute modified code is granted,\n", " * provided the above notices are retained, and a notice that the code was\n", " * modified is included with the above copyright notice.\n", " *\n", " * Original author: Bill Janssen\n", " * Heavily modified by Hans Boehm and others\n", " */\n", "\n", "/*\n", " * This used to be in dyn_load.c.  It was extracted into a separate file\n", " * to avoid having to link against libdl.{a,so} if the client doesn't call\n", " * dlopen.  Of course this fails if the collector is in a dynamic\n", " * library. -HB\n", " */\n", "\n", "#include \"private/gc_priv.h\"\n", "\n", "# if defined(DYNAMIC_LOADING) && (defined(GC_PTHREADS) && !defined(GC_DARWIN_THREADS)) \\\n", "      || defined(GC_SOLARIS_THREADS)\n", "\n", "# if defined(dlopen) && !defined(GC_USE_LD_WRAP)\n", "    /* To support various threads pkgs, gc.h interposes on dlopen by     */\n", "    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n", "    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n", "    /* real system dlopen() in their implementation. We first remove     */\n", "    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n", "#   undef dlopen\n", "# endif\n", "\n", "  /* Make sure we're not in the middle of a collection, and make\t*/\n", "  /* sure we don't start any.\tReturns previous value of GC_dont_gc.\t*/\n", "  /* This is invoked prior to a dlopen call to avoid synchronization\t*/\n", "  /* issues.  We can't just acquire the allocation lock, since startup \t*/\n", "  /* code in dlopen may try to allocate.\t\t\t\t*/\n", "  /* This solution risks heap growth in the presence of many dlopen\t*/\n", "  /* calls in either a multithreaded environment, or if the library\t*/\n", "  /* initialization code allocates substantial amounts of GC'ed memory.\t*/\n", "  /* But I don't know of a better solution.\t\t\t\t*/\n", "  static void disable_gc_for_dlopen()\n", "  {\n", "    LOCK();\n", "    while (GC_incremental && GC_collection_in_progress()) {\n", "\tGC_collect_a_little_inner(1000);\n", "    }\n", "    ++GC_dont_gc;\n", "    UNLOCK();\n", "  }\n"], "project": "libmono-system-net-http-formatting4.0-cil", "file": "gc_dlopen.pkl", "function": "disable_gc_for_dlopen"}, {"comment_all": {"comment": "/*\n 27) 1999-12-13 17:49:08         43 kB  martin.jpg (archive)\n */", "depth": 0, "reading_ease": 64.37, "reading_grade": 6.0, "line": 45}, "comment_text": "/*\n 27) 1999-12-13 17:49:08         43 kB  martin.jpg (archive)\n */", "comment_tokens": ["27", ")", "1999-12-13", "17:49:08", "43", "kB", "martin.jpg", "(", "archive", ")"], "ccode": ["\n", "/*\n", " 27) 1999-12-13 17:49:08         43 kB  martin.jpg (archive)\n", " */\n", "struct rfile *split_line (char *line, struct rfile *rf)\n", "{\n", "  char *cp, *xp;\n", "\n", "  memset (rf, 0, sizeof(struct rfile));\n", "\n", "  for (cp=line; *cp && isspace(*cp); cp++);\n", "\n", "  /* 27) */\n", "  if ((xp = strchr(cp, ')')) == NULL)\n", "    return NULL;\n", "  if ((rf->nr = (char *)malloc(xp-cp+1)) == NULL)\n", "    return NULL;\n", "  memset (rf->nr, 0, xp-cp+1);\n", "  strncpy (rf->nr, cp, xp-cp);\n", "\n", "  /* 1999-12-13 17:49:08 */\n", "  cp = xp+2;\n", "  if ((rf->date = (char *)malloc(20)) == NULL)\n", "    return NULL;\n", "  memset (rf->date, 0, 20);\n", "  strncpy (rf->date, cp, 19);\n", "\n", "  /* 43 kB */\n", "  cp += 20;\n", "  for (; *cp && isspace(*cp); cp++);\n", "  for (xp=cp; *xp && isdigit(*xp); xp++);\n", "  if ((rf->size = (char *)malloc(xp-cp+1)) == NULL)\n", "    return NULL;\n", "  memset (rf->size, 0, xp-cp+1);\n", "  strncpy (rf->size, cp, xp-cp);\n", "\n", "  for (cp=xp; *cp && isspace(*cp); cp++);\n", "  if (*cp == 'k' && *(cp+1) == 'B')\n", "    cp += 2;\n", "\n", "  /* martin.jpg (archive) */\n", "  for (; *cp && isspace(*cp); cp++);\n", "  if ((xp = strrchr(cp, '(')) != NULL) {\n", "    if ((rf->flags = (char *)malloc(strlen(xp))) == NULL)\n", "      return NULL;\n", "    memset (rf->flags, 0, strlen(xp));\n", "    strncpy (rf->flags, xp, strlen(xp)-1);\n", "    *(xp--) = '\\0';\n", "    if (isspace(*xp)) *xp = '\\0';\n", "  }\n", "  if ((rf->name = (char *)malloc(strlen(cp)+1)) == NULL)\n", "    return NULL;\n", "  memset (rf->name, 0, strlen(cp)+1);\n", "  strncpy (rf->name, cp, strlen(cp));\n", "\n", "  return rf;\n", "}\n"], "project": "gerstensaft", "file": "receive.pkl", "function": "split_line"}, {"comment_all": {"comment": "/**\n * iptc_jpeg_read_ps3:\n * @infile: an open JPEG file with the current position set to the start of the file\n * @buf: an output buffer to store the Photoshop 3.0 data\n * @size: the size of the output buffer\n *\n * Scans the headers of a JPEG file looking for a \"Photoshop 3.0\" header, and if\n * found, stores the raw contents of this header in the @buf buffer.  The Photoshop\n * 3.0 header is a series of records found in the APP13 section of a JPEG file.\n * If a JPEG file contains IPTC metadata, the metadata is stored in one of the\n * Photoshop 3.0 records.\n *\n * Returns: the number of bytes stored on success, 0 if the PS3 header was\n * not found, or -1 if an error occurred.\n */", "depth": 0, "reading_ease": 79.6, "reading_grade": 6.4, "line": 124}, "comment_text": "/**\n * iptc_jpeg_read_ps3:\n * @infile: an open JPEG file with the current position set to the start of the file\n * @buf: an output buffer to store the Photoshop 3.0 data\n * @size: the size of the output buffer\n *\n * Scans the headers of a JPEG file looking for a \"Photoshop 3.0\" header, and if\n * found, stores the raw contents of this header in the @buf buffer.  The Photoshop\n * 3.0 header is a series of records found in the APP13 section of a JPEG file.\n * If a JPEG file contains IPTC metadata, the metadata is stored in one of the\n * Photoshop 3.0 records.\n *\n * Returns: the number of bytes stored on success, 0 if the PS3 header was\n * not found, or -1 if an error occurred.\n */", "comment_tokens": ["iptc_jpeg_read_ps3", ":", "@", "infile", ":", "an", "open", "JPEG", "file", "with", "the", "current", "position", "set", "to", "the", "start", "of", "the", "file", "@", "buf", ":", "an", "output", "buffer", "to", "store", "the", "Photoshop", "3.0", "data", "@", "size", ":", "the", "size", "of", "the", "output", "buffer", "Scans", "the", "headers", "of", "a", "JPEG", "file", "looking", "for", "a", "``", "Photoshop", "3.0", "''", "header", ",", "and", "if", "found", ",", "stores", "the", "raw", "contents", "of", "this", "header", "in", "the", "@", "buf", "buffer", ".", "The", "Photoshop", "3.0", "header", "is", "a", "series", "of", "records", "found", "in", "the", "APP13", "section", "of", "a", "JPEG", "file", ".", "If", "a", "JPEG", "file", "contains", "IPTC", "metadata", ",", "the", "metadata", "is", "stored", "in", "one", "of", "the", "Photoshop", "3.0", "records", ".", "Returns", ":", "the", "number", "of", "bytes", "stored", "on", "success", ",", "0", "if", "the", "PS3", "header", "was", "not", "found", ",", "or", "-1", "if", "an", "error", "occurred", "."], "ccode": ["\n", "/**\n", " * iptc_jpeg_read_ps3:\n", " * @infile: an open JPEG file with the current position set to the start of the file\n", " * @buf: an output buffer to store the Photoshop 3.0 data\n", " * @size: the size of the output buffer\n", " *\n", " * Scans the headers of a JPEG file looking for a \"Photoshop 3.0\" header, and if\n", " * found, stores the raw contents of this header in the @buf buffer.  The Photoshop\n", " * 3.0 header is a series of records found in the APP13 section of a JPEG file.\n", " * If a JPEG file contains IPTC metadata, the metadata is stored in one of the\n", " * Photoshop 3.0 records.\n", " *\n", " * Returns: the number of bytes stored on success, 0 if the PS3 header was\n", " * not found, or -1 if an error occurred.\n", " */\n", "int\n", "iptc_jpeg_read_ps3 (FILE * infile, unsigned char * ps3, unsigned int size)\n", "{\n", "\tint s;\n", "\n", "\tif (!infile || !ps3)\n", "\t\treturn -1;\n", "\n", "\ts = iptc_jpeg_seek_to_ps3 (infile, NULL, 0);\n", "\tif (s <= 0)\n", "\t\treturn s;\n", "\tif (fseek (infile, 4, SEEK_CUR) < 0)\n", "\t\treturn -1;\n", "\n", "\tif ((int)size < s)\n", "\t\treturn -1;\n", "\n", "\tif ((int)fread (ps3, 1, s, infile) < s)\n", "\t\treturn -1;\n", "\n", "\treturn s;\n", "}\n"], "project": "libiptcdata0-dev", "file": "iptc-jpeg.pkl", "function": "iptc_jpeg_read_ps3"}, {"comment_all": {"comment": "/* gib_stack.c\n\nCopyright (C) 1999,2000 Paul Duncan.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies of the Software and its documentation and acknowledgment shall be\ngiven in the documentation and software packages that this Software was\nused.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/", "depth": 0, "reading_ease": 25.5, "reading_grade": 21.0, "line": 0}, "comment_text": "/* gib_stack.c\n\nCopyright (C) 1999,2000 Paul Duncan.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies of the Software and its documentation and acknowledgment shall be\ngiven in the documentation and software packages that this Software was\nused.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/", "comment_tokens": ["gib_stack.c", "Copyright", "(", "C", ")", "1999,2000", "Paul", "Duncan", ".", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "of", "the", "Software", "and", "its", "documentation", "and", "acknowledgment", "shall", "be", "given", "in", "the", "documentation", "and", "software", "packages", "that", "this", "Software", "was", "used", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/* gib_stack.c\n", "\n", "Copyright (C) 1999,2000 Paul Duncan.\n", "\n", "Permission is hereby granted, free of charge, to any person obtaining a copy\n", "of this software and associated documentation files (the \"Software\"), to\n", "deal in the Software without restriction, including without limitation the\n", "rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n", "sell copies of the Software, and to permit persons to whom the Software is\n", "furnished to do so, subject to the following conditions:\n", "\n", "The above copyright notice and this permission notice shall be included in\n", "all copies of the Software and its documentation and acknowledgment shall be\n", "given in the documentation and software packages that this Software was\n", "used.\n", "\n", "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n", "THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n", "IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n", "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "\n", "*/\n", "\n", "#include \"gib_stack.h\"\n", "#include \"gib_utils.h\"\n", "#include \"gib_debug.h\"\n", "\n", "gib_stack *gib_stack_new()\n", "{\n", "\tgib_stack *q = gib_emalloc(sizeof(gib_stack));\n", "\tq->base = NULL;\n", "\treturn q;\n", "}\n"], "project": "giblib-dev", "file": "gib_stack.pkl", "function": "gib_stack_new"}, {"comment_all": {"comment": "/* for 'exit()' */", "depth": 0, "reading_ease": 77.91, "reading_grade": 2.9, "line": 8}, "comment_text": "/* for 'exit()' */", "comment_tokens": ["for", "'exit", "(", ")", "'"], "ccode": ["/*---------------------------------------------------------------------------*\\\n", "** $Author: saulius $\n", "** $Date: 2015-07-21 17:39:27 +0300 (Tue, 21 Jul 2015) $ \n", "** $Revision: 3587 $\n", "** $URL: svn://www.crystallography.net/cod-tools/tags/v2.10/src/externals/cexceptions/cexceptions.c $\n", "\\*---------------------------------------------------------------------------*/\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h> /* for 'exit()' */\n", "#include <string.h>\n", "#include <assert.h>\n", "#include <cexceptions.h>\n", "\n", "int cexception_init( cexception_t *ex )\n", "{\n", "    assert( ex );\n", "    memset( ex, 0, sizeof(*ex));\n", "    return 1;\n", "}\n"], "project": "libcod-usermessage-perl", "file": "cexceptions.pkl", "function": "cexception_init"}, {"comment_all": {"comment": "/* \n    Copyright (C) 2019 Genome Research Ltd.\n    \n    Author: Petr Danecek <pd3@sanger.ac.uk>\n    \n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n    \n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n    \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n*/", "depth": 0, "reading_ease": 36.56, "reading_grade": 16.7, "line": 0}, "comment_text": "/* \n    Copyright (C) 2019 Genome Research Ltd.\n    \n    Author: Petr Danecek <pd3@sanger.ac.uk>\n    \n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n    \n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n    \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n*/", "comment_tokens": ["Copyright", "(", "C", ")", "2019", "Genome", "Research", "Ltd", ".", "Author", ":", "Petr", "Danecek", "<", "pd3", "@", "sanger.ac.uk", ">", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/* \n", "    Copyright (C) 2019 Genome Research Ltd.\n", "    \n", "    Author: Petr Danecek <pd3@sanger.ac.uk>\n", "    \n", "    Permission is hereby granted, free of charge, to any person obtaining a copy\n", "    of this software and associated documentation files (the \"Software\"), to deal\n", "    in the Software without restriction, including without limitation the rights\n", "    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n", "    copies of the Software, and to permit persons to whom the Software is\n", "    furnished to do so, subject to the following conditions:\n", "    \n", "    The above copyright notice and this permission notice shall be included in\n", "    all copies or substantial portions of the Software.\n", "    \n", "    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", "    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", "    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n", "    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n", "    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n", "    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n", "    DEALINGS IN THE SOFTWARE.\n", "*/\n", "\n", "#include <string.h>\n", "#include \"cols.h\"\n", "\n", "cols_t *cols_split(const char *line, cols_t *cols, char delim)\n", "{\n", "    if ( !cols ) cols = (cols_t*) calloc(1,sizeof(cols_t));\n", "    if ( cols->rmme ) free(cols->rmme);\n", "    cols->n = 0;\n", "    cols->rmme = strdup(line);\n", "    char *ss = cols->rmme;\n", "    while (1)\n", "    {\n", "        char *se = ss;\n", "        while ( *se && *se!=delim ) se++;\n", "        char tmp = *se;\n", "        *se = 0;\n", "        cols->n++;\n", "        if ( cols->n > cols->m )\n", "        {\n", "            cols->m += 10;\n", "            cols->off = (char**) realloc(cols->off, sizeof(*cols->off)*cols->m);\n", "        }\n", "        cols->off[ cols->n - 1 ] = ss;\n", "        if ( !tmp ) break;\n", "        ss = se + 1;\n", "    }\n", "    return cols;\n", "}\n"], "project": "bcftools", "file": "cols.pkl", "function": "cols_split"}, {"comment_all": {"comment": "/** \n * \\file newfolder.c\n * Example program to create a folder on the device.\n *\n * Copyright (C) 2006-2009 Linus Walleij <triad@df.lth.se>\n * Copyright (C) 2006 Chris A. Debenham <chris@adebenham.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "depth": 0, "reading_ease": 62.17, "reading_grade": 8.9, "line": 0}, "comment_text": "/** \n * \\file newfolder.c\n * Example program to create a folder on the device.\n *\n * Copyright (C) 2006-2009 Linus Walleij <triad@df.lth.se>\n * Copyright (C) 2006 Chris A. Debenham <chris@adebenham.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */", "comment_tokens": ["\\file", "newfolder.c", "Example", "program", "to", "create", "a", "folder", "on", "the", "device", ".", "Copyright", "(", "C", ")", "2006-2009", "Linus", "Walleij", "<", "triad", "@", "df.lth.se", ">", "Copyright", "(", "C", ")", "2006", "Chris", "A.", "Debenham", "<", "chris", "@", "adebenham.com", ">", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/** \n", " * \\file newfolder.c\n", " * Example program to create a folder on the device.\n", " *\n", " * Copyright (C) 2006-2009 Linus Walleij <triad@df.lth.se>\n", " * Copyright (C) 2006 Chris A. Debenham <chris@adebenham.com>\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the\n", " * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n", " * Boston, MA 02111-1307, USA.\n", " */\n", "#include <stdlib.h>\n", "#include <libgen.h>\n", "\n", "#include \"common.h\"\n", "#include \"pathutils.h\"\n", "#include \"connect.h\"\n", "\n", "extern LIBMTP_folder_t *folders;\n", "extern LIBMTP_file_t *files;\n", "extern LIBMTP_mtpdevice_t *device;\n", "\n", "int newfolder_command (int argc, char **argv)\n", "{\n", "  uint32_t newid;\n", "\n", "  if(argc != 4) {\n", "    printf(\"Usage: newfolder name <parent> <storage>\\n\");\n", "    printf(\"  parent = parent folder or 0 to create the new folder in the root dir\\n\");\n", "    printf(\"  storage = storage id or 0 to create the new folder on the primary storage\\n\");\n", "    return 0;\n", "  }\n", "\n", "  newid = LIBMTP_Create_Folder(device, argv[1], atol(argv[2]), atol(argv[3]));\n", "  if (newid == 0) {\n", "    printf(\"Folder creation failed.\\n\");\n", "    return 1;\n", "  } else {\n", "    printf(\"New folder created with ID: %d\\n\", newid);\n", "  }\n", "  return 0;\n", "}\n"], "project": "libmtp-common", "file": "newfolder.pkl", "function": "newfolder_command"}, {"comment_all": {"comment": "/* same as mk_proxy, but get the host as an ip*/", "depth": 0, "reading_ease": 112.09, "reading_grade": 0.1, "line": 274}, "comment_text": "/* same as mk_proxy, but get the host as an ip*/", "comment_tokens": ["same", "as", "mk_proxy", ",", "but", "get", "the", "host", "as", "an", "ip"], "ccode": ["\n", "\n", "\n", "/* same as mk_proxy, but get the host as an ip*/\n", "struct proxy_l* mk_proxy_from_ip(struct ip_addr* ip, unsigned short port,\n", "\t\t\t\t\t\t\t\t\tint proto)\n", "{\n", "\tstruct proxy_l* p;\n", "\n", "\tp=(struct proxy_l*) pkg_malloc(sizeof(struct proxy_l));\n", "\tif (p==0){\n", "\t\tPKG_MEM_CRITICAL;\n", "\t\tgoto error;\n", "\t}\n", "\tmemset(p,0,sizeof(struct proxy_l));\n", "\n", "\tp->port=port;\n", "\tp->proto=proto;\n", "\tp->host.h_addrtype=ip->af;\n", "\tp->host.h_length=ip->len;\n", "\tp->host.h_addr_list=pkg_malloc(2*sizeof(char*));\n", "\tif (p->host.h_addr_list==0) {\n", "\t\tPKG_MEM_ERROR;\n", "\t\tpkg_free(p);\n", "\t\tgoto error;\n", "\t}\n", "\tp->host.h_addr_list[1]=0;\n", "\tp->host.h_addr_list[0]=pkg_malloc(ip->len+1);\n", "\tif (p->host.h_addr_list[0]==0){\n", "\t\tPKG_MEM_ERROR;\n", "\t\tpkg_free(p->host.h_addr_list);\n", "\t\tpkg_free(p);\n", "\t\tgoto error;\n", "\t}\n", "\n", "\tmemcpy(p->host.h_addr_list[0], ip->u.addr, ip->len);\n", "\tp->host.h_addr_list[0][ip->len]=0;\n", "\n", "\treturn p;\n", "\n", "error:\n", "\treturn 0;\n", "}\n"], "project": "kamailio-ims-modules", "file": "proxy.pkl", "function": "mk_proxy_from_ip"}, {"comment_all": {"comment": "/* Return the last move done by the opponent to color. Both if no move\n * was found or if the last move was a pass, PASS_MOVE is returned.\n */", "depth": 0, "reading_ease": 91.61, "reading_grade": 3.8, "line": 1011}, "comment_text": "/* Return the last move done by the opponent to color. Both if no move\n * was found or if the last move was a pass, PASS_MOVE is returned.\n */", "comment_tokens": ["Return", "the", "last", "move", "done", "by", "the", "opponent", "to", "color", ".", "Both", "if", "no", "move", "was", "found", "or", "if", "the", "last", "move", "was", "a", "pass", ",", "PASS_MOVE", "is", "returned", "."], "ccode": ["\n", "\n", "/* Return the last move done by the opponent to color. Both if no move\n", " * was found or if the last move was a pass, PASS_MOVE is returned.\n", " */\n", "int\n", "get_last_opponent_move(int color)\n", "{\n", "  int k;\n", "  \n", "  for (k = move_history_pointer - 1; k >= 0; k--)\n", "    if (move_history_color[k] == OTHER_COLOR(color))\n", "      return move_history_pos[k];\n", "\n", "  return PASS_MOVE;\n", "}\n"], "project": "gnugo", "file": "board.pkl", "function": "get_last_opponent_move"}, {"comment_all": {"comment": "/* that the user will have a choice of file_names to choose           */", "depth": 1, "reading_ease": 94.15, "reading_grade": 2.9, "line": 77}, "comment_text": "/* If a string has been given for file_needed it is assumed           */\n/* that the user will have a choice of file_names to choose           */\n/* therefore (s)he will be prompted for a name                        */\n/* if a default filename was supplied by the calling function this    */\n/* will be suggested as well, otherwise there is no default           */\n", "comment_tokens": ["If", "a", "string", "has", "been", "given", "for", "file_needed", "it", "is", "assumed", "that", "the", "user", "will", "have", "a", "choice", "of", "file_names", "to", "choose", "therefore", "(", "s", ")", "he", "will", "be", "prompted", "for", "a", "name", "if", "a", "default", "filename", "was", "supplied", "by", "the", "calling", "function", "this", "will", "be", "suggested", "as", "well", ",", "otherwise", "there", "is", "no", "default"], "ccode": ["/**************************************************************************/\n", "/* CodonW codon usage analysis package                                    */\n", "/* Copyright (C) 2005            John F. Peden                            */\n", "/* This program is free software; you can redistribute                    */\n", "/* it and/or modify it under the terms of the GNU General Public License  */\n", "/* as published by the Free Software Foundation; version 2 of the         */\n", "/* License,                                                               */\n", "/*                                                                        */\n", "/* This program is distributed in the hope that it will be useful, but    */\n", "/* WITHOUT ANY WARRANTY; without even the implied warranty of             */\n", "/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           */\n", "/* GNU General Public License for more details.                           */\n", "/* You should have received a copy of the GNU General Public License along*/\n", "/* with this program; if not, write to the Free Software Foundation, Inc.,*/\n", "/* 675 Mass Ave, Cambridge, MA 02139, USA.                                */\n", "/*                                                                        */\n", "/*                                                                        */\n", "/* The author can be contacted by email (jfp#hanson-codonw@yahoo.com Anti-*/\n", "/* Spam please change the # in my email to an _)                          */\n", "/*                                                                        */\n", "/* For the latest version and information see                             */\n", "/* http://codonw.sourceforge.net \t\t\t\t\t  */\n", "/**************************************************************************/\n", "\n", "/* This is a general subroutine, so we might as well redefine TRUE & FALSE*/\n", "#ifndef TRUE\n", "#define TRUE 1\n", "#endif\n", "#ifndef FALSE\n", "#define FALSE 0\n", "#endif\n", "\n", "/* What to do if we can't locate the file we where asked to open          */\n", "/* On most systems we will try and be nice and show a choice of filenames */\n", "\n", "#ifdef _DOS\n", "#define no_file_found() system(\"dir/w\");\n", "#elif BSD || SYSV            \n", "#define no_file_found() system(\"ls -F\");\n", "#elif defined (WIN32) || defined (_WIN) \n", "#define no_file_found() system(\"dir/w\");\n", "#else\n", "#define no_file_found() printf(\"This would have presented a list of files\\n\\tbut I do not know howto your operating system\\n\");\n", "#endif\n", "\n", "/* Include header files                                                   */\n", "#include <stdio.h>             \n", "#include <limits.h> \n", "#include <stdlib.h>  \n", "#include <string.h>\n", "#include <ctype.h>         \n", "#include \"codonW.h\"\n", "\n", "/************** open_file **************************************************/\n", "/* This subroutine is a front end to fopen open. It takes four parameters  */\n", "/* the parameters are used to generate a user prompt for the               */\n", "/* filename, and to give a suggested filename, to give the write perms     */\n", "/* for the file, and whether or not to overwrite existing files.           */\n", "/* File_needed is just a description of the file being opened. It is       */\n", "/* assumed that if this descriptor is missing the file is to be opened     */\n", "/* without further user input. If default_filename is blank then there is  */\n", "/* no default_filename                                                     */\n", "/* write_perm sets up the type of file being opened                        */\n", "/* verbose tells this function whether to check if there is a         */\n", "/* previous version of any file being opened for writing                   */\n", "/***************************************************************************/\n", "\n", "FILE *open_file(char *file_needed, char *default_filename, \n", "char *write_perm, int  verbose )\n", "{\n", "    char   infile_name[MAX_FILENAME_LEN]=\"\";\n", "    FILE  *input=NULL;\n", "    char   temp[4];\n", "    char  *answer = pm->junk;\n", "\n", "    /**********************************************************************/\n", "    /* If a string has been given for file_needed it is assumed           */\n", "    /* that the user will have a choice of file_names to choose           */\n", "    /* therefore (s)he will be prompted for a name                        */\n", "    /* if a default filename was supplied by the calling function this    */\n", "    /* will be suggested as well, otherwise there is no default           */\n", "    /**********************************************************************/\n", "\n", "    if ( strlen(file_needed)) {\n", "        while (!strlen(infile_name) )  {\n", "            printf(\"\\nName of %s (h for help) [%s] \", \n", "                      file_needed,default_filename);\n", "            gets(infile_name);                          /* get filename   */\n", "            \n", "            if ( WasHelpCalled ( infile_name ) ) {\n", "                     chelp(\"open_file_query\");          /* Help ....      */\n", "                     infile_name[0]='\\0';\n", "                     continue;\n", "                }\n", "\n", "            if ( !strlen(infile_name) && default_filename )\n", "                strcpy(infile_name, default_filename);\n", "        }                                         /* end of get filename  */\n", "    } else if ( strlen(default_filename) )        /* use default filename */\n", "        strcpy(infile_name, default_filename);\n", "    else {                                        /* not enough info      */\n", "        fprintf(stderr, \"Programming error: no filename supplied\\n\");\n", "        my_exit (0,\"open file\");\n", "    }\n", "\n", "\n", "    /**********************************************************************/\n", "    /* At this point infile_name contains a possible filename             */\n", "    /* Depending on the mode (write_perm) string this is tested 3 ways    */\n", "    /*                                                                    */\n", "    /* (r or r+) Test if the file exists if not, all the files in the     */\n", "    /* current directory are listed and the the user is prompted for      */\n", "    /* an alternative name or they may quit the programme                 */\n", "    /*                                                                    */\n", "    /* (a, a+) Not tested, just open the file                             */\n", "    /*                                                                    */\n", "    /* (w, w+) If the variable verbose = FALSE then no test          */\n", "    /* If verbose == TRUE then the file is checked to see if         */\n", "    /* it already exsists, if it does then the user is prompted for       */\n", "    /* either for permission to overwrite this file or to                 */\n", "    /* suggest an alternative file_name which is then tested as well      */\n", "    /* the user can type q to quit at any stage of this prompting process */\n", "    /**********************************************************************/\n", "\n", "    if ( !strcmp(write_perm, \"r\") || !strcmp(write_perm, \"r+\") \n", "       ||!strcmp(write_perm, \"rb\") ){\n", "        while ( !(input = fopen (infile_name , write_perm )))  {\n", "            fprintf(stderr,\"\\nThese are the files in the current directory \"\n", "                \"I cannot find %.*s \\n\\n\",strlen(infile_name),infile_name);\n", "            no_file_found();\n", "            fprintf(stderr, \"\\n\\nPlease enter another filename, \"\n", "                \" (Q)uit, (H)elp [%s] \",infile_name);\n", "            gets(answer);\n", "            \n", "            if (strlen (answer)==1 && \n", "                   ((char)toupper((int)answer[0])=='Q'))\n", "                   my_exit(2,\"open_file\");\n", "            else if (WasHelpCalled ( infile_name )){\n", "                   chelp (\"File_not_found\");\n", "                }\n", "            else if (strlen (answer))\n", "                strcpy (infile_name, answer);  \n", "\t\t}                                     /* end of while loop */       \n", "        strcpy ( answer,infile_name);           /* allow transfer    */\n", "        return input;\n", "    }                                               \n", "\n", "    /************************* Append  ***********************************/\n", "    else if ( !strcmp(write_perm, \"a\") || !strcmp(write_perm, \"a+\")\n", "           || !strcmp(write_perm, \"ab\") ) {\n", "        input = fopen (infile_name, write_perm);\n", "        strcpy ( answer,infile_name);      \n", "        return input;\n", "    }                                              \n", "    /************************* Write    **********************************/\n", "    else if ( !strcmp( write_perm, \"w\") || !strcmp(write_perm, \"w+\") \n", "            ||!strcmp( write_perm, \"wb\") ) {\n", "\n", "         while ( verbose == TRUE ) {\n", "            if ( (input = fopen (infile_name , \"r\")) ) {\n", "                fclose(input);                  /* close the filehandle  */\n", "                fprintf(stderr, \"\\nWarning :File %.*s \"\n", "                    \"exists already \\n\\tDo you wish to\"\n", "                    \" overwrite ? (y/n/h/q)\\t [y] \",\n", "                    strlen(infile_name), infile_name);\n", "                fgets(temp, 3, stdin);\n", "\n", "                switch (toupper( (int) temp[0])) {\n", "                case 'Y': \n", "                case '\\0': \n", "                case '\\n':\n", "                    verbose = FALSE;\n", "                    continue;\n", "                case 'Q':\n", "                    my_exit(2,\"open_file2\");\n", "                    break;\n", "                case 'H':\n", "                    chelp(\"file_exists\");\n", "                    continue;\n", "                    break;\n", "                default:\n", "                    fprintf(stderr, \n", "                        \"\\nYou decided not to overwrite, please enter\\n\"\n", "                        \" another filename, (q)uit, (a)ppend, (h)elp \\n\"\n", "                        \" (a/q/h/filename)\\t[a] \");\n", "                    gets(answer);\n", "                }\n", "\n", "                /* if the answer is 'a' then the default file is opened  */\n", "                /* as appendable else if 'q' then the programme exits    */\n", "                /* anything else is taken as a file name                 */\n", "\n", "                if ( strlen(answer) <= 1 ) {\n", "                    switch (toupper( (int) answer[0])) {\n", "                    case 'Q':\n", "                        return (NULL);\n", "                    case 'A':\n", "                    case '\\0':\n", "                    case'\\n':\n", "                        verbose = FALSE;  /* leave the while loop   */\n", "                        strcpy(write_perm, \"a+\");\n", "                        break;\n", "                    case 'H':\n", "                     chelp(\"file_append\");        \n", "                     continue;\n", "                     break;\n", "                    default:\n", "                        continue;\n", "                    };                                /* end of switch   */\n", "                }               \n", "            } else                              /* filename is unique    */\n", "              verbose = FALSE;             /* exit the while loop   */\n", "              }                                 /* match while preserve  */\n", "        input = fopen (infile_name,write_perm); /* opens filehandle      */\n", "        strcpy ( answer,infile_name);         \n", "        return input;\n", "    }                                           /* matchs if w or w+     */\n", "    return (NULL);\n", "}\n"], "project": "codonw", "file": "open_fil.pkl", "function": "open_file"}, {"comment_all": {"comment": "/*\n * os_rwlock_rdlock - pthread_rwlock_rdlock abstraction layer\n */", "depth": 0, "reading_ease": -118.71, "reading_grade": 30.8, "line": 172}, "comment_text": "/*\n * os_rwlock_rdlock - pthread_rwlock_rdlock abstraction layer\n */", "comment_tokens": ["os_rwlock_rdlock", "-", "pthread_rwlock_rdlock", "abstraction", "layer"], "ccode": ["\n", "/*\n", " * os_rwlock_rdlock - pthread_rwlock_rdlock abstraction layer\n", " */\n", "int\n", "os_rwlock_rdlock(os_rwlock_t *__restrict rwlock)\n", "{\n", "\treturn pthread_rwlock_rdlock((pthread_rwlock_t *)rwlock);\n", "}\n"], "project": "libvmmalloc-dev", "file": "os_thread_posix.pkl", "function": "os_rwlock_rdlock"}, {"comment_all": {"comment": "/* Written by Paul Eggert.  */", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 17}, "comment_text": "/* Written by Paul Eggert.  */", "comment_tokens": ["Written", "by", "Paul", "Eggert", "."], "ccode": ["/* Return a safer copy of a file descriptor.\n", "\n", "   Copyright (C) 2005-2006, 2009-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "/* Written by Paul Eggert.  */\n", "\n", "#include <config.h>\n", "\n", "#include \"unistd-safer.h\"\n", "\n", "#include <errno.h>\n", "#include <unistd.h>\n", "\n", "/* Return FD, unless FD would be a copy of standard input, output, or\n", "   error; in that case, return a duplicate of FD, closing FD.  On\n", "   failure to duplicate, close FD, set errno, and return -1.  Preserve\n", "   errno if FD is negative, so that the caller can always inspect\n", "   errno when the returned value is negative.\n", "\n", "   This function is usefully wrapped around functions that return file\n", "   descriptors, e.g., fd_safer (open (\"file\", O_RDONLY)).  */\n", "\n", "int\n", "fd_safer (int fd)\n", "{\n", "  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n", "    {\n", "      int f = dup_safer (fd);\n", "      int e = errno;\n", "      close (fd);\n", "      errno = e;\n", "      fd = f;\n", "    }\n", "\n", "  return fd;\n", "}\n"], "project": "grub-xen-dbg", "file": "fd-safer.pkl", "function": "fd_safer"}, {"comment_all": {"comment": "/* No driver by that name */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 1495}, "comment_text": "/* No driver by that name */", "comment_tokens": ["No", "driver", "by", "that", "name"], "ccode": ["\n", "\n", "/* -- Driver Information -- */\n", "\n", "int ao_driver_id(const char *short_name)\n", "{\n", "\tint i;\n", "\tdriver_list *driver = driver_head;\n", "\n", "\ti = 0;\n", "\twhile (driver) {\n", "\t\tif (strcmp(short_name,\n", "\t\t\t   driver->functions->driver_info()->short_name) == 0)\n", "\t\t\treturn i;\n", "\t\tdriver = driver->next;\n", "\t\ti++;\n", "\t}\n", "\n", "\treturn -1; /* No driver by that name */\n", "}\n"], "project": "libao4", "file": "audio_out.pkl", "function": "ao_driver_id"}, {"comment_all": {"comment": "/* d = a + b (mod c) */", "depth": 0, "reading_ease": 117.16, "reading_grade": -1.9, "line": 11}, "comment_text": "/* d = a + b (mod c) */", "comment_tokens": ["d", "=", "a", "+", "b", "(", "mod", "c", ")"], "ccode": ["/* TomsFastMath, a fast ISO C bignum library.\n", " * \n", " * This project is meant to fill in where LibTomMath\n", " * falls short.  That is speed ;-)\n", " *\n", " * This project is public domain and free for all purposes.\n", " * \n", " * Tom St Denis, tomstdenis@gmail.com\n", " */\n", "#include <tfm_private.h>\n", "\n", "/* d = a + b (mod c) */\n", "int fp_addmod(fp_int *a, fp_int *b, fp_int *c, fp_int *d)\n", "{\n", "  fp_int tmp;\n", "  fp_zero(&tmp);\n", "  fp_add(a, b, &tmp);\n", "  return fp_mod(&tmp, c, d);\n", "}\n"], "project": "libtfm-dev", "file": "fp_addmod.pkl", "function": "fp_addmod"}, {"comment_all": {"comment": "/*\n\t * We need to count even though priv_data could still be\n\t * NULL. Otherwise the statistics will not be right at the\n\t * end.\n\t */", "depth": 1, "reading_ease": 86.2, "reading_grade": 3.8, "line": 1086}, "comment_text": "/*\n\t * We need to count even though priv_data could still be\n\t * NULL. Otherwise the statistics will not be right at the\n\t * end.\n\t */", "comment_tokens": ["We", "need", "to", "count", "even", "though", "priv_data", "could", "still", "be", "NULL", ".", "Otherwise", "the", "statistics", "will", "not", "be", "right", "at", "the", "end", "."], "ccode": ["\n", "extern int inflateReset2(z_streamp strm, int windowBits);\n", "int inflateReset2(z_streamp strm, int windowBits)\n", "{\n", "\n", "\tint rc;\n", "\tstruct _internal_state *w;\n", "\n", "\tif (!has_wrapper_state(strm))\n", "\t\treturn z_inflateReset2(strm, windowBits);\n", "\n", "\tif (strm == NULL)\n", "\t\treturn Z_STREAM_ERROR;\n", "\n", "\tw = (struct _internal_state *)strm->state;\n", "\tif (w == NULL)\n", "\t\treturn Z_STREAM_ERROR;\n", "\n", "\t/*\n", "\t * We need to count even though priv_data could still be\n", "\t * NULL. Otherwise the statistics will not be right at the\n", "\t * end.\n", "\t */\n", "\tpr_trace(\"[%p] inflateReset2 impl=%d\\n\", strm, w->impl);\n", "\tif (zlib_gather_statistics()) {\n", "\t\tpthread_mutex_lock(&zlib_stats_mutex);\n", "\t\tzlib_stats.inflateReset2++;\n", "\t\t__inflate_update_totals(strm);\n", "\t\tpthread_mutex_unlock(&zlib_stats_mutex);\n", "\t}\n", "\n", "\tw->allow_switching = true;\n", "\tw->dictLength = 0;\t/* clear cached dictionary */\n", "\n", "\tstrm->state = w->priv_data;\n", "\trc = (w->impl) ? h_inflateReset2(strm, windowBits) :\n", "\t\t\t z_inflateReset2(strm, windowBits);\n", "\n", "\tstrm->total_in = 0;\n", "\tstrm->total_out = 0;\n", "\tstrm->state = (void *)w;\n", "\n", "\treturn rc;\n", "}\n"], "project": "libzadc4", "file": "wrapper.pkl", "function": "inflateReset2"}, {"comment_all": {"comment": "// so we can check the version number and get help without being root.\n", "depth": 1, "reading_ease": 83.66, "reading_grade": 4.8, "line": 73}, "comment_text": "// Deal with command-line arguments. Do these before the check for root\n// so we can check the version number and get help without being root.\n", "comment_tokens": ["Deal", "with", "command-line", "arguments", ".", "Do", "these", "before", "the", "check", "for", "root", "so", "we", "can", "check", "the", "version", "number", "and", "get", "help", "without", "being", "root", "."], "ccode": ["\n", "\n", "\n", "int main(int argc, char *argv[])\n", "{\n", "    pid_t              pid;\n", "    char               opt;\n", "    struct sockaddr_dn sockaddr;\n", "    struct optdata_dn  optdata;\n", "    int\t\t       insock;\n", "    int                debug;\n", "    int                len = sizeof(sockaddr);\n", "    int                check_user=1;\n", "    char               log_char = 'l'; // Default to syslog(3)\n", "    char               optdata_bytes[] = {  03, 01, 00, 18, 00, 00, 00, 00,\n", "\t\t\t\t\t  0xA0, 02, 00, 00, 01, 00, 00, 00};\n", "\n", "    read_configfile();\n", "    \n", "    // Deal with command-line arguments. Do these before the check for root\n", "    // so we can check the version number and get help without being root.\n", "    opterr = 0;\n", "    optind = 0;\n", "    while ((opt=getopt(argc,argv,\"?vVdhu:Ufl:\")) != EOF)\n", "    {\n", "\tswitch(opt) \n", "\t{\n", "\tcase 'h': \n", "\t    usage(argv[0], stdout);\n", "\t    exit(0);\n", "\n", "\tcase '?':\n", "\t    usage(argv[0], stderr);\n", "\t    exit(0);\n", "\n", "\tcase 'v':\n", "\t    verbosity++;\n", "\t    break;\n", "\n", "\tcase 'f':\n", "\t    optdata_bytes[8] |= 0x02;\n", "\t    block_mode = 1;\n", "\t    break;\n", "\n", "\tcase 'd':\n", "\t    debug++;\n", "\t    break;\n", "\n", "\tcase 'V':\n", "\t    printf(\"\\nvmsmaild from dnprogs version %s\\n\\n\", VERSION);\n", "\t    exit(1);\n", "\t    break;\n", "\n", "\tcase 'U':\n", "\t    check_user=0;\n", "\t    break;\n", "\n", "\tcase 'u':\n", "\t    strcpy(config_vmsmailuser, optarg);\n", "\t    break;\n", "\n", "\tcase 'l':\n", "\t    if (optarg[0] != 's' &&\n", "\t\toptarg[0] != 'm' &&\n", "\t\toptarg[0] != 'e')\n", "\t    {\n", "\t\tusage(argv[0], stderr);\n", "\t\texit(2);\n", "\t    }\n", "\t    log_char = optarg[0];\n", "\t    break;\n", "\n", "\t}\n", "    }\n", "\n", "    // Initialise logging\n", "    init_daemon_logging(\"vmsmaild\", log_char);\n", "\n", "    // See if the vmsmail user exists on this system\n", "    if (check_user)\n", "    {\n", "\tif (!getpwnam(config_vmsmailuser))\n", "\t{\n", "\t    DNETLOG((LOG_ERR, \"user for vmsmail (%s) does not exist, change the user in /etc/vmsmail.conf or use the -U option to get rid of this message\\n\",\n", "\t\t   config_vmsmailuser));\n", "\t}\n", "    }\n", "\n", "    // Wait for something to happen (or check to see if it already has)\n", "    insock = dnet_daemon(DNOBJECT_MAIL11, NULL, verbosity, !debug);\n", " \n", "    if (insock > -1)\n", "    {\n", "        dnet_accept(insock, 0, optdata_bytes, sizeof(optdata_bytes));\n", "\treceive_mail(insock);\n", "    }\n", "    return 0;\n", "}\n"], "project": "libdnet", "file": "vmsmaild.pkl", "function": "main"}, {"comment_all": {"comment": "// This tail recursion could be optimized.\n", "depth": 2, "reading_ease": 56.93, "reading_grade": 6.8, "line": 346}, "comment_text": "// This tail recursion could be optimized.\n", "comment_tokens": ["This", "tail", "recursion", "could", "be", "optimized", "."], "ccode": ["\n", "static unsigned char *FrameFiller_next(FrameFiller *filler)\n", "{\n", "\tunsigned char *p;\n", "\tint x, y, w;\n", "\n", "\tif(filler->bit == -1) {\n", "\t\tfiller->bit = 0;\n", "\t\treturn filler->frame + filler->y * filler->width + filler->x;\n", "\t}\n", "\n", "\tx = filler->x;\n", "\ty = filler->y;\n", "\tp = filler->frame;\n", "\tw = filler->width;\n", "\n", "\tif(filler->bit == 0) {\n", "\t\tx--;\n", "\t\tfiller->bit++;\n", "\t} else {\n", "\t\tx++;\n", "\t\ty += filler->dir;\n", "\t\tfiller->bit--;\n", "\t}\n", "\n", "\tif(filler->dir < 0) {\n", "\t\tif(y < 0) {\n", "\t\t\ty = 0;\n", "\t\t\tx -= 2;\n", "\t\t\tfiller->dir = 1;\n", "\t\t\tif(!filler->mqr && x == 6) {\n", "\t\t\t\tx--;\n", "\t\t\t\ty = 9;\n", "\t\t\t}\n", "\t\t}\n", "\t} else if(y == w) {\n", "\t\ty = w - 1;\n", "\t\tx -= 2;\n", "\t\tfiller->dir = -1;\n", "\t\tif(!filler->mqr && x == 6) {\n", "\t\t\tx--;\n", "\t\t\ty -= 8;\n", "\t\t}\n", "\t}\n", "\tif(x < 0 || y < 0) return NULL;\n", "\n", "\tfiller->x = x;\n", "\tfiller->y = y;\n", "\n", "\tif(p[y * w + x] & 0x80) {\n", "\t\t// This tail recursion could be optimized.\n", "\t\treturn FrameFiller_next(filler);\n", "\t}\n", "\treturn &p[y * w + x];\n", "}\n"], "project": "libqrencode4", "file": "qrencode.pkl", "function": "FrameFiller_next"}, {"comment_all": {"comment": "/*\n * Copyright (C) 2011-2019 by Werner Lemberg.\n *\n * This file is part of the ttfautohint library, and may only be used,\n * modified, and distributed under the terms given in `COPYING'.  By\n * continuing to use, modify, or distribute this file you indicate that you\n * have read `COPYING' and understand and accept it fully.\n *\n * The file `COPYING' mentioned in the previous paragraph is distributed\n * with the ttfautohint library.\n */", "depth": 0, "reading_ease": 55.24, "reading_grade": 9.5, "line": 2}, "comment_text": "/*\n * Copyright (C) 2011-2019 by Werner Lemberg.\n *\n * This file is part of the ttfautohint library, and may only be used,\n * modified, and distributed under the terms given in `COPYING'.  By\n * continuing to use, modify, or distribute this file you indicate that you\n * have read `COPYING' and understand and accept it fully.\n *\n * The file `COPYING' mentioned in the previous paragraph is distributed\n * with the ttfautohint library.\n */", "comment_tokens": ["Copyright", "(", "C", ")", "2011-2019", "by", "Werner", "Lemberg", ".", "This", "file", "is", "part", "of", "the", "ttfautohint", "library", ",", "and", "may", "only", "be", "used", ",", "modified", ",", "and", "distributed", "under", "the", "terms", "given", "in", "`", "COPYING", "'", ".", "By", "continuing", "to", "use", ",", "modify", ",", "or", "distribute", "this", "file", "you", "indicate", "that", "you", "have", "read", "`", "COPYING", "'", "and", "understand", "and", "accept", "it", "fully", ".", "The", "file", "`", "COPYING", "'", "mentioned", "in", "the", "previous", "paragraph", "is", "distributed", "with", "the", "ttfautohint", "library", "."], "ccode": ["/* tadummy.c */\n", "\n", "/*\n", " * Copyright (C) 2011-2019 by Werner Lemberg.\n", " *\n", " * This file is part of the ttfautohint library, and may only be used,\n", " * modified, and distributed under the terms given in `COPYING'.  By\n", " * continuing to use, modify, or distribute this file you indicate that you\n", " * have read `COPYING' and understand and accept it fully.\n", " *\n", " * The file `COPYING' mentioned in the previous paragraph is distributed\n", " * with the ttfautohint library.\n", " */\n", "\n", "\n", "/* originally file `afdummy.c' (2011-Mar-28) from FreeType */\n", "\n", "/* heavily modified 2011 by Werner Lemberg <wl@gnu.org> */\n", "\n", "#include \"tadummy.h\"\n", "#include \"tahints.h\"\n", "\n", "\n", "static FT_Error\n", "ta_dummy_hints_init(TA_GlyphHints hints,\n", "                    TA_StyleMetrics metrics)\n", "{\n", "  ta_glyph_hints_rescale(hints, metrics);\n", "\n", "  hints->x_scale = metrics->scaler.x_scale;\n", "  hints->y_scale = metrics->scaler.y_scale;\n", "  hints->x_delta = metrics->scaler.x_delta;\n", "  hints->y_delta = metrics->scaler.y_delta;\n", "\n", "  return FT_Err_Ok;\n", "}\n"], "project": "ttfautohint", "file": "tadummy.pkl", "function": "ta_dummy_hints_init"}, {"comment_all": {"comment": "/* DEL to ?, others to alpha */", "depth": 3, "reading_ease": 83.32, "reading_grade": 2.9, "line": 495}, "comment_text": "/* DEL to ?, others to alpha */", "comment_tokens": ["DEL", "to", "?", ",", "others", "to", "alpha"], "ccode": ["\n", "/*\n", " * Print out a filename (or other ascii string).\n", " * Return true if truncated.\n", " */\n", "int\n", "printfn(s, ep)\n", "\tregister u_char *s, *ep;\n", "{\n", "\tregister u_char c;\n", "\n", "\tputchar('\"');\n", "\twhile ((c = *s++) != '\\0') {\n", "\t\tif (s > ep) {\n", "\t\t\tputchar('\"');\n", "\t\t\treturn (1);\n", "\t\t}\n", "\t\tif (!isascii(c)) {\n", "\t\t\tc = toascii(c);\n", "\t\t\tputchar('M');\n", "\t\t\tputchar('-');\n", "\t\t}\n", "\t\tif (!isprint(c)) {\n", "\t\t\tc ^= 0x40;\t\t\t/* DEL to ?, others to alpha */\n", "\t\t\tputchar('^');\n", "\t\t}\n", "\t\tputchar(c);\n", "\t}\n", "\tputchar('\"');\n", "\treturn (0);\n", "}\n"], "project": "bootp", "file": "bootptest.pkl", "function": "printfn"}, {"comment_all": {"comment": "/* Return FALSE on failure.\t\t\t\t\t*/", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 104}, "comment_text": "/* Add a heap block map for objects of size sz to obj_map.\t*/\n/* Return FALSE on failure.\t\t\t\t\t*/\n", "comment_tokens": ["Add", "a", "heap", "block", "map", "for", "objects", "of", "size", "sz", "to", "obj_map", ".", "Return", "FALSE", "on", "failure", "."], "ccode": ["\n", "\n", "/* Add a heap block map for objects of size sz to obj_map.\t*/\n", "/* Return FALSE on failure.\t\t\t\t\t*/\n", "GC_bool GC_add_map_entry(sz)\n", "word sz;\n", "{\n", "    register unsigned obj_start;\n", "    register unsigned displ;\n", "    register map_entry_type * new_map;\n", "    word map_entry;\n", "    \n", "    if (sz > MAXOBJSZ) sz = 0;\n", "    if (GC_obj_map[sz] != 0) {\n", "        return(TRUE);\n", "    }\n", "    new_map = (map_entry_type *)GC_scratch_alloc(MAP_SIZE);\n", "    if (new_map == 0) return(FALSE);\n", "#   ifdef PRINTSTATS\n", "        GC_printf1(\"Adding block map for size %lu\\n\", (unsigned long)sz);\n", "#   endif\n", "\tINIT_MAP(new_map);\n", "    if (sz == 0) {\n", "        for(displ = 0; displ <= max_valid_offset; displ++) {\n", "            if (OFFSET_VALID(displ)) {\n", "\t\tmap_entry = BYTES_TO_WORDS(displ);\n", "\t\tif (map_entry > MAX_OFFSET) map_entry = OFFSET_TOO_BIG;\n", "                MAP_ENTRY(new_map,displ) = (map_entry_type)map_entry;\n", "            }\n", "        }\n", "    } else {\n", "        for (obj_start = 0;\n", "             obj_start + WORDS_TO_BYTES(sz) <= HBLKSIZE;\n", "             obj_start += WORDS_TO_BYTES(sz)) {\n", "             for (displ = 0; displ <= max_valid_offset; displ++) {\n", "                 if (OFFSET_VALID(displ)) {\n", "\t\t     map_entry = BYTES_TO_WORDS(displ);\n", "\t\t     if (map_entry > MAX_OFFSET) map_entry = OFFSET_TOO_BIG;\n", "                     MAP_ENTRY(new_map, obj_start + displ) =\n", "\t\t\t\t\t\t(map_entry_type)map_entry;\n", "                 }\n", "             }\n", "        }\n", "    }\n", "    GC_obj_map[sz] = new_map;\n", "    return(TRUE);\n", "}\n"], "project": "libmono-accessibility4.0-cil", "file": "obj_map.pkl", "function": "GC_add_map_entry"}, {"comment_all": {"comment": "/*\n * drv_alsaplayer.c\n * Copyright (C) 1999 Paul N. Fisher <rao@gnu.org>\n *\n *  This file is part of AlsaPlayer.\n *\n *  AlsaPlayer is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  AlsaPlayer is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n */", "depth": 0, "reading_ease": 52.7, "reading_grade": 10.5, "line": 17}, "comment_text": "/*\n * drv_alsaplayer.c\n * Copyright (C) 1999 Paul N. Fisher <rao@gnu.org>\n *\n *  This file is part of AlsaPlayer.\n *\n *  AlsaPlayer is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  AlsaPlayer is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n */", "comment_tokens": ["drv_alsaplayer.c", "Copyright", "(", "C", ")", "1999", "Paul", "N.", "Fisher", "<", "rao", "@", "gnu.org", ">", "This", "file", "is", "part", "of", "AlsaPlayer", ".", "AlsaPlayer", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "AlsaPlayer", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", " * drv_alsaplayer.c\n", " * Copyright (C) 1999 Paul N. Fisher <rao@gnu.org>\n", " *\n", " *  This file is part of AlsaPlayer.\n", " *\n", " *  AlsaPlayer is free software; you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation; either version 3 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  AlsaPlayer is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License\n", " *  along with this program; if not, see <http://www.gnu.org/licenses/>.\n", " *\n", " */\n", "\n", "#include \"mikmod.h\"\n", "\n", "static BOOL alsaplayer_Init (void)\n", "{\n", "\treturn VC_Init ();\n", "}\n"], "project": "alsaplayer-common", "file": "drv_alsaplayer.pkl", "function": "alsaplayer_Init"}, {"comment_all": {"comment": "/* When we're not using capabilities, we need to do this here before\n     we drop root. Also, set buffer size small, to avoid wasting\n     kernel buffers */", "depth": 1, "reading_ease": 75.71, "reading_grade": 5.8, "line": 118}, "comment_text": "/* When we're not using capabilities, we need to do this here before\n     we drop root. Also, set buffer size small, to avoid wasting\n     kernel buffers */", "comment_tokens": ["When", "we", "'re", "not", "using", "capabilities", ",", "we", "need", "to", "do", "this", "here", "before", "we", "drop", "root", ".", "Also", ",", "set", "buffer", "size", "small", ",", "to", "avoid", "wasting", "kernel", "buffers"], "ccode": ["\n", "void dhcp_init(void)\n", "{\n", "#if defined(HAVE_BSD_NETWORK)\n", "  int oneopt = 1;\n", "#endif\n", "\n", "  daemon->dhcpfd = make_fd(daemon->dhcp_server_port);\n", "  if (daemon->enable_pxe)\n", "    daemon->pxefd = make_fd(PXE_PORT);\n", "  else\n", "    daemon->pxefd = -1;\n", "\n", "#if defined(HAVE_BSD_NETWORK)\n", "  /* When we're not using capabilities, we need to do this here before\n", "     we drop root. Also, set buffer size small, to avoid wasting\n", "     kernel buffers */\n", "  \n", "  if (option_bool(OPT_NO_PING))\n", "    daemon->dhcp_icmp_fd = -1;\n", "  else if ((daemon->dhcp_icmp_fd = make_icmp_sock()) == -1 ||\n", "\t   setsockopt(daemon->dhcp_icmp_fd, SOL_SOCKET, SO_RCVBUF, &oneopt, sizeof(oneopt)) == -1 )\n", "    die(_(\"cannot create ICMP raw socket: %s.\"), NULL, EC_BADNET);\n", "  \n", "  /* Make BPF raw send socket */\n", "  init_bpf();\n", "#endif  \n", "}\n"], "project": "dnsmasq-base", "file": "dhcp.pkl", "function": "dhcp_init"}, {"comment_all": {"comment": "/* cloexec.c - set or clear the close-on-exec descriptor flag\n\n   Copyright (C) 1991, 2004-2006, 2009-2020 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation; either version 2.1 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n   The code is taken from glibc/manual/llio.texi  */", "depth": 0, "reading_ease": 55.64, "reading_grade": 9.4, "line": 15}, "comment_text": "/* cloexec.c - set or clear the close-on-exec descriptor flag\n\n   Copyright (C) 1991, 2004-2006, 2009-2020 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation; either version 2.1 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n   The code is taken from glibc/manual/llio.texi  */", "comment_tokens": ["cloexec.c", "-", "set", "or", "clear", "the", "close-on-exec", "descriptor", "flag", "Copyright", "(", "C", ")", "1991", ",", "2004-2006", ",", "2009-2020", "Free", "Software", "Foundation", ",", "Inc", ".", "This", "program", "is", "free", "software", ":", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2.1", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "program", ".", "If", "not", ",", "see", "<", "https", ":", "www.gnu.orglicenses", ">", ".", "The", "code", "is", "taken", "from", "glibcmanualllio.texi"], "ccode": ["/* cloexec.c - set or clear the close-on-exec descriptor flag\n", "\n", "   Copyright (C) 1991, 2004-2006, 2009-2020 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU Lesser General Public License as published by\n", "   the Free Software Foundation; either version 2.1 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU Lesser General Public License for more details.\n", "\n", "   You should have received a copy of the GNU Lesser General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", "\n", "   The code is taken from glibc/manual/llio.texi  */\n", "\n", "#include <config.h>\n", "\n", "#include \"cloexec.h\"\n", "\n", "#include <errno.h>\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "\n", "/* Set the 'FD_CLOEXEC' flag of DESC if VALUE is true,\n", "   or clear the flag if VALUE is false.\n", "   Return 0 on success, or -1 on error with 'errno' set.\n", "\n", "   Note that on MingW, this function does NOT protect DESC from being\n", "   inherited into spawned children.  Instead, either use dup_cloexec\n", "   followed by closing the original DESC, or use interfaces such as\n", "   open or pipe2 that accept flags like O_CLOEXEC to create DESC\n", "   non-inheritable in the first place.  */\n", "\n", "int\n", "set_cloexec_flag (int desc, bool value)\n", "{\n", "#ifdef F_SETFD\n", "\n", "  int flags = fcntl (desc, F_GETFD, 0);\n", "\n", "  if (0 <= flags)\n", "    {\n", "      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n", "\n", "      if (flags == newflags\n", "          || fcntl (desc, F_SETFD, newflags) != -1)\n", "        return 0;\n", "    }\n", "\n", "  return -1;\n", "\n", "#else /* !F_SETFD */\n", "\n", "  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n", "     will be unaffected.  */\n", "  if (desc < 0)\n", "    {\n", "      errno = EBADF;\n", "      return -1;\n", "    }\n", "  if (dup2 (desc, desc) < 0)\n", "    /* errno is EBADF here.  */\n", "    return -1;\n", "\n", "  /* There is nothing we can do on this kind of platform.  Punt.  */\n", "  return 0;\n", "#endif /* !F_SETFD */\n", "}\n"], "project": "libvirt-wireshark", "file": "cloexec.pkl", "function": "set_cloexec_flag"}, {"comment_all": {"comment": "/** Get the input stream.\n * \n */", "depth": 0, "reading_ease": 92.8, "reading_grade": 1.3, "line": 4027}, "comment_text": "/** Get the input stream.\n * \n */", "comment_tokens": ["Get", "the", "input", "stream", "."], "ccode": ["\n", "/** Get the input stream.\n", " * \n", " */\n", "FILE *yyget_in  (void)\n", "{\n", "        return yyin;\n", "}\n"], "project": "linux-cloud-tools-5.8.0-53-generic", "file": "lexer.lex.pkl", "function": "yyget_in"}, {"comment_all": {"comment": "/*\n\t\t\t * For the parser, update file/lineno at the first token\n\t\t\t * of each statement. Generally, \\n is a statement\n\t\t\t * terminator in Kconfig, but it is not always true\n\t\t\t * because \\n could be escaped by a backslash.\n\t\t\t */", "depth": 3, "reading_ease": 62.68, "reading_grade": 8.7, "line": 4212}, "comment_text": "/*\n\t\t\t * For the parser, update file/lineno at the first token\n\t\t\t * of each statement. Generally, \\n is a statement\n\t\t\t * terminator in Kconfig, but it is not always true\n\t\t\t * because \\n could be escaped by a backslash.\n\t\t\t */", "comment_tokens": ["For", "the", "parser", ",", "update", "filelineno", "at", "the", "first", "token", "of", "each", "statement", ".", "Generally", ",", "\\n", "is", "a", "statement", "terminator", "in", "Kconfig", ",", "but", "it", "is", "not", "always", "true", "because", "\\n", "could", "be", "escaped", "by", "a", "backslash", "."], "ccode": ["\n", "#define YYTABLES_NAME \"yytables\"\n", "\n", "/* second stage lexer */\n", "int yylex(void)\n", "{\n", "\tint token;\n", "\n", "repeat:\n", "\ttoken = yylex1();\n", "\n", "\tif (prev_token == T_EOL || prev_token == T_HELPTEXT) {\n", "\t\tif (token == T_EOL) {\n", "\t\t\t/* Do not pass unneeded T_EOL to the parser. */\n", "\t\t\tgoto repeat;\n", "\t\t} else {\n", "\t\t\t/*\n", "\t\t\t * For the parser, update file/lineno at the first token\n", "\t\t\t * of each statement. Generally, \\n is a statement\n", "\t\t\t * terminator in Kconfig, but it is not always true\n", "\t\t\t * because \\n could be escaped by a backslash.\n", "\t\t\t */\n", "\t\t\tcurrent_pos.file = current_file;\n", "\t\t\tcurrent_pos.lineno = yylineno;\n", "\t\t}\n", "\t}\n", "\n", "\tif (prev_prev_token == T_EOL && prev_token == T_WORD &&\n", "\t    (token == T_EQUAL || token == T_COLON_EQUAL || token == T_PLUS_EQUAL))\n", "\t\tBEGIN(ASSIGN_VAL);\n", "\n", "\tprev_prev_token = prev_token;\n", "\tprev_token = token;\n", "\n", "\treturn token;\n", "}\n"], "project": "linux-buildinfo-5.8.0-49-generic", "file": "lexer.lex.pkl", "function": "yylex"}, {"comment_all": {"comment": "/* Vendor Specific Commands get timer value */", "depth": 0, "reading_ease": 48.47, "reading_grade": 8.0, "line": 180}, "comment_text": "/* Vendor Specific Commands get timer value */", "comment_tokens": ["Vendor", "Specific", "Commands", "get", "timer", "value"], "ccode": ["\n", "/* Vendor Specific Commands get timer value */\n", "int VSC_get_timer(unsigned char *timer)\n", "{\n", "  if (verbose) {\n", "    printf(\"Getting Idle3 timer value\\n\");\n", "  }\n", "\n", "  int err = 0;\n", "  char buffer[512];\n", "  struct ata_tf tf;\n", "\n", "  tf_init(&tf, ATA_OP_SMART, 0, 0);\n", "  tf.lob.feat = 0xd5;\n", "  tf.lob.nsect = 0x01;\n", "  tf.lob.lbal = 0xbf;\n", "  tf.lob.lbam = 0x4f;\n", "  tf.lob.lbah = 0xc2;\n", "  tf.dev = 0xa0;\n", "\n", "  memset(buffer,0,sizeof(buffer));\n", "\n", "  if(sg16(fd, SG_READ, SG_PIO, &tf, buffer, 512, 5)) {\n", "    err = errno;\n", "    perror(\"sg16(VSC_GET_TIMER) failed\");\n", "    return err;\n", "  }\n", "  \n", "  *timer=buffer[0];\n", "  return 0;\n", "}\n"], "project": "idle3-tools", "file": "idle3ctl.pkl", "function": "VSC_get_timer"}, {"comment_all": {"comment": "/*\n                                                                                                                                                                     \ng3data : A program for grabbing data from scanned graphs\nCopyright (C) 2000 Jonas Frantz\n                                                                                                                                                                     \n    This file is part of g3data.\n                                                                                                                                                                     \n    g3data is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n                                                                                                                                                                     \n    g3data is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n                                                                                                                                                                     \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n                                                                                                                                                                     \n                                                                                                                                                                     \nAuthors email : jonas.frantz@welho.com\n                                                                                                                                                                     \n*/", "depth": 0, "reading_ease": 57.3, "reading_grade": 10.8, "line": 0}, "comment_text": "/*\n                                                                                                                                                                     \ng3data : A program for grabbing data from scanned graphs\nCopyright (C) 2000 Jonas Frantz\n                                                                                                                                                                     \n    This file is part of g3data.\n                                                                                                                                                                     \n    g3data is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n                                                                                                                                                                     \n    g3data is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n                                                                                                                                                                     \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n                                                                                                                                                                     \n                                                                                                                                                                     \nAuthors email : jonas.frantz@welho.com\n                                                                                                                                                                     \n*/", "comment_tokens": ["g3data", ":", "A", "program", "for", "grabbing", "data", "from", "scanned", "graphs", "Copyright", "(", "C", ")", "2000", "Jonas", "Frantz", "This", "file", "is", "part", "of", "g3data", ".", "g3data", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "g3data", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", ",", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", "USA", "Authors", "email", ":", "jonas.frantz", "@", "welho.com"], "ccode": ["/*\n", "                                                                                                                                                                     \n", "g3data : A program for grabbing data from scanned graphs\n", "Copyright (C) 2000 Jonas Frantz\n", "                                                                                                                                                                     \n", "    This file is part of g3data.\n", "                                                                                                                                                                     \n", "    g3data is free software; you can redistribute it and/or modify\n", "    it under the terms of the GNU General Public License as published by\n", "    the Free Software Foundation; either version 2 of the License, or\n", "    (at your option) any later version.\n", "                                                                                                                                                                     \n", "    g3data is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU General Public License for more details.\n", "                                                                                                                                                                     \n", "    You should have received a copy of the GNU General Public License\n", "    along with this program; if not, write to the Free Software\n", "    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n", "                                                                                                                                                                     \n", "                                                                                                                                                                     \n", "Authors email : jonas.frantz@welho.com\n", "                                                                                                                                                                     \n", "*/\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <gtk/gtk.h>\n", "#include <math.h>\n", "#include \"main.h\"\n", "\n", "/* Extern functions */\n", "\n", "extern\tvoid\tOrder(struct PointValue *RealPos, gint left, gint right, gint ordering);\n", "\n", "/* Extern variables */\n", "\n", "extern\tgint\t\taxiscoords[MAXNUMTABS][4][2];\n", "extern\tgint\t\t**points[MAXNUMTABS];\n", "extern\tgint\t\tnumpoints[MAXNUMTABS];\n", "extern\tgint\t\tordering[MAXNUMTABS];\n", "extern\tgdouble\t\trealcoords[MAXNUMTABS][4];\n", "extern\tgboolean\tUseErrors[MAXNUMTABS];\n", "extern\tgboolean\tlogxy[MAXNUMTABS][2];\n", "extern\tgint\t\tAction[MAXNUMTABS];\n", "extern  gchar\t\t*file_name[MAXNUMTABS];\n", "extern\tgint\t\tViewedTabNum;\n", "\n", "/****************************************************************/\n", "/* This function sets the numpoints entry to numpoints variable\t*/\n", "/* value.\t\t\t\t\t\t\t*/\n", "/****************************************************************/\n", "void SetNumPointsEntry(GtkWidget *np_entry, gint np)\n", "{\n", "  char buf[128];\n", "\n", "    sprintf(buf,\"%d\",np);\n", "    gtk_entry_set_text(GTK_ENTRY(np_entry),buf);\n", "}\n"], "project": "g3data", "file": "points.pkl", "function": "SetNumPointsEntry"}, {"comment_all": {"comment": "/* If an output file is specified, set globs.cmdout to that */", "depth": 1, "reading_ease": 74.86, "reading_grade": 4.1, "line": 346}, "comment_text": "/* If an output file is specified, set globs.cmdout to that */", "comment_tokens": ["If", "an", "output", "file", "is", "specified", ",", "set", "globs.cmdout", "to", "that"], "ccode": ["\n", "/* Symbols to be defined as true for use in Jambase */\n", "\n", "static const char *othersyms[] = { OSMAJOR, OSMINOR, OSPLAT, JAMVERSYM, 0 } ;\n", "\n", "/* Known for sure: \n", " *\tmac needs arg_enviro\n", " *\tOS2 needs extern environ\n", " */\n", "\n", "# ifdef OS_MAC\n", "# define use_environ arg_environ\n", "# ifdef MPW\n", "QDGlobals qd;\n", "# endif\n", "# endif\n", "\n", "# ifndef use_environ\n", "# define use_environ environ\n", "# if !defined( __WATCOM__ ) && !defined( OS_OS2 ) && !defined( OS_NT ) \n", "extern char **environ;\n", "# endif\n", "# endif\n", "\n", "main( int argc, char **argv, char **arg_environ )\n", "{\n", "\tint\t\tn;\n", "\tconst char\t*s;\n", "\tstruct option\toptv[N_OPTS];\n", "\tconst char\t*all = \"all\";\n", "\tint\t\tanyhow = 0;\n", "\tint\t\tstatus;\n", "\n", "# ifdef OS_MAC\n", "\tInitGraf(&qd.thePort);\n", "# endif\n", "\n", "\targc--, argv++;\n", "\n", "\tif( ( n = getoptions( argc, argv, \"d:j:f:gs:t:ano:qv\", optv ) ) < 0 )\n", "\t{\n", "\t    printf( \"\\nusage: jam [ options ] targets...\\n\\n\" );\n", "\n", "            printf( \"-a      Build all targets, even if they are current.\\n\" );\n", "            printf( \"-dx     Display (a)actions (c)causes (d)dependencies\\n\" );\n", "\t    printf( \"        (m)make tree (x)commands (0-9) debug levels.\\n\" );\n", "            printf( \"-fx     Read x instead of Jambase.\\n\" );\n", "\t    printf( \"-g      Build from newest sources first.\\n\" );\n", "            printf( \"-jx     Run up to x shell commands concurrently.\\n\" );\n", "            printf( \"-n      Don't actually execute the updating actions.\\n\" );\n", "            printf( \"-ox     Write the updating actions to file x.\\n\" );\n", "            printf( \"-q      Quit quickly as soon as a target fails.\\n\" );\n", "\t    printf( \"-sx=y   Set variable x=y, overriding environment.\\n\" );\n", "            printf( \"-tx     Rebuild x, even if it is up-to-date.\\n\" );\n", "            printf( \"-v      Print the version of jam and exit.\\n\\n\" );\n", "\n", "\t    exit( EXITBAD );\n", "\t}\n", "\n", "\targc -= n, argv += n;\n", "\n", "\t/* Version info. */\n", "\n", "\tif( ( s = getoptval( optv, 'v', 0 ) ) )\n", "\t{\n", "\t    printf( \"Jam %s. %s. \", VERSION, OSMINOR );\n", "\t    if( *OSPLAT ) printf( \"%s. \", OSPLAT );\n", "\t    printf( \"Copyright 1993-2010 Christopher Seiwald.\\n\" );\n", "\n", "\t    return EXITOK;\n", "\t}\n", "\n", "\t/* Pick up interesting options */\n", "\n", "\tif( ( s = getoptval( optv, 'n', 0 ) ) )\n", "\t    globs.noexec++, DEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 1; \n", "\n", "\tif( ( s = getoptval( optv, 'q', 0 ) ) )\n", "\t    globs.quitquick = 1;\n", "\n", "\tif( ( s = getoptval( optv, 'a', 0 ) ) )\n", "\t    anyhow++;\n", "\n", "\tif( ( s = getoptval( optv, 'j', 0 ) ) )\n", "\t    globs.jobs = atoi( s );\n", "\n", "\tif( ( s = getoptval( optv, 'g', 0 ) ) )\n", "\t    globs.newestfirst = 1;\n", "\n", "\t/* Turn on/off debugging */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'd', n ); n++ )\n", "\t{\n", "\t    int i = atoi( s );\n", "\n", "\t    /* First -d, turn off defaults. */\n", "\n", "\t    if( !n )\n", "\t\tDEBUG_MAKE = DEBUG_MAKEQ = DEBUG_EXEC = 0;\n", "\n", "\t    /* n turns on levels 1-n */\n", "\t    /* +n turns on level n */\n", "\t    /* c turns on named display c */\n", "\n", "\t    if( i < 0 || i >= DEBUG_MAX )\n", "\t    {\n", "\t\tprintf( \"Invalid debug level '%s'.\\n\", s );\n", "\t    }\n", "\t    else if( *s == '+' )\n", "\t    {\n", "\t\tglobs.debug[i] = 1;\n", "\t    }\n", "\t    else if( i ) while( i )\n", "\t    {\n", "\t\tglobs.debug[i--] = 1;\n", "\t    }\n", "\t    else while( *s ) switch( *s++ )\n", "\t    {\n", "\t    case 'a': DEBUG_MAKE = DEBUG_MAKEQ = 1; break;\n", "\t    case 'c': DEBUG_CAUSES = 1; break;\n", "\t    case 'd': DEBUG_DEPENDS = 1; break;\n", "\t    case 'm': DEBUG_MAKEPROG = 1; break;\n", "\t    case 'r': DEBUG_COMPILE = 1; break;\n", "\t    case 'x': DEBUG_EXEC = 1; break;\n", "\t    case '0': break;\n", "\t    default: printf( \"Invalid debug flag '%c'.\\n\", s[-1] );\n", "\t    }\n", "\t}\n", "\n", "\t/* Set JAMDATE first */\n", "\n", "\t{\n", "\t    char buf[ 128 ];\n", "\t    time_t clock;\n", "\t    time( &clock );\n", "\t    strcpy( buf, ctime( &clock ) );\n", "\n", "\t    /* Trim newline from date */\n", "\n", "\t    if( strlen( buf ) == 25 )\n", "\t\tbuf[ 24 ] = 0;\n", "\n", "\t    var_set( \"JAMDATE\", list_new( L0, buf, 0 ), VAR_SET );\n", "\t}\n", "\n", "\t/* And JAMUNAME */\n", "# ifdef unix\n", "\t{\n", "\t    struct utsname u;\n", "\n", "\t    if( uname( &u ) >= 0 )\n", "\t    {\n", "\t\tLIST *l = L0;\n", "\t\tl = list_new( l, u.machine, 0 );\n", "\t\tl = list_new( l, u.version, 0 );\n", "\t\tl = list_new( l, u.release, 0 );\n", "\t\tl = list_new( l, u.nodename, 0 );\n", "\t\tl = list_new( l, u.sysname, 0 );\n", "\t\tvar_set( \"JAMUNAME\", l, VAR_SET );\n", "\t    }\n", "\t}\n", "# endif /* unix */\n", "\n", "\t/*\n", "\t * Jam defined variables OS, OSPLAT\n", "\t */\n", "\n", "\tvar_defines( othersyms );\n", "\n", "\t/* load up environment variables */\n", "\n", "\tvar_defines( (const char **)use_environ );\n", "\n", "\t/* Load up variables set on command line. */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 's', n ); n++ )\n", "\t{\n", "\t    const char *symv[2];\n", "\t    symv[0] = s;\n", "\t    symv[1] = 0;\n", "\t    var_defines( symv );\n", "\t}\n", "\n", "\t/* Initialize built-in rules */\n", "\n", "\tload_builtins();\n", "\n", "\t/* Parse ruleset */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 'f', n ); n++ )\n", "\t    parse_file( s );\n", "\n", "\tif( !n )\n", "\t    parse_file( \"+\" );\n", "\n", "\tstatus = yyanyerrors();\n", "\n", "\t/* Manually touch -t targets */\n", "\n", "\tfor( n = 0; s = getoptval( optv, 't', n ); n++ )\n", "\t    touchtarget( s );\n", "\n", "\t/* If an output file is specified, set globs.cmdout to that */\n", "\n", "\tif( s = getoptval( optv, 'o', 0 ) )\n", "\t{\n", "\t    if( !( globs.cmdout = fopen( s, \"w\" ) ) )\n", "\t    {\n", "\t\tprintf( \"Failed to write to '%s'\\n\", s );\n", "\t\texit( EXITBAD );\n", "\t    }\n", "\t    globs.noexec++;\n", "\t}\n", "\n", "\t/* Now make target */\n", "\n", "\tif( !argc )\n", "\t    status |= make( 1, &all, anyhow );\n", "\telse\n", "\t    status |= make( argc, (const char **)argv, anyhow );\n", "\n", "\t/* Widely scattered cleanup */\n", "\n", "\tvar_done();\n", "\tdonerules();\n", "\tdonestamps();\n", "\tdonestr();\n", "\n", "\t/* close cmdout */\n", "\n", "\tif( globs.cmdout )\n", "\t    fclose( globs.cmdout );\n", "\n", "\treturn status ? EXITBAD : EXITOK;\n", "}\n"], "project": "jam", "file": "jam.pkl", "function": "main"}, {"comment_all": {"comment": "/* sscanf silently accepts negative numbers for %u :( */", "depth": 2, "reading_ease": 38.99, "reading_grade": 9.6, "line": 2292}, "comment_text": "/* sscanf silently accepts negative numbers for %u :( */\n/* To check for extraneous chars in optarg. */\n", "comment_tokens": ["sscanf", "silently", "accepts", "negative", "numbers", "for", "%", "u", ":", "(", "To", "check", "for", "extraneous", "chars", "in", "optarg", "."], "ccode": ["\n", "static char parse_gopts_and_fopts(file_t * f)\n", "{\n", "  const sox_version_info_t* info = sox_version_info();\n", "  while (sox_true) {\n", "    int c;\n", "    int i; /* sscanf silently accepts negative numbers for %u :( */\n", "    char dummy;     /* To check for extraneous chars in optarg. */\n", "\n", "    switch (c=lsx_getopt(&optstate)) {\n", "    case -1:        /* @ one of: file-name, effect name, end of arg-list. */\n", "      return '\\0'; /* i.e. not device. */\n", "\n", "    case 0:         /* Long options with no short equivalent. */\n", "      switch (optstate.lngind) {\n", "      case 0:\n", "        if (optstate.arg)\n", "          sox_append_comment(&f->oob.comments, optstate.arg);\n", "        break;\n", "\n", "      case 1:\n", "#define SOX_BUFMIN 16\n", "        if (sscanf(optstate.arg, \"%i %c\", &i, &dummy) != 1 || i <= SOX_BUFMIN) {\n", "          lsx_fail(\"Buffer size `%s' must be > %d\", optstate.arg, SOX_BUFMIN);\n", "          exit(1);\n", "        }\n", "        sox_globals.bufsiz = i;\n", "        break;\n", "\n", "      case 2:\n", "        combine_method = enum_option(optstate.arg, optstate.lngind, combine_methods);\n", "        break;\n", "\n", "      case 3:\n", "        sox_append_comment(&f->oob.comments, \"\");\n", "        read_comment_file(&f->oob.comments, optstate.arg);\n", "        break;\n", "\n", "      case 4:\n", "        sox_append_comment(&f->oob.comments, \"\");\n", "        if (*optstate.arg)\n", "          sox_append_comment(&f->oob.comments, optstate.arg);\n", "        break;\n", "\n", "      case 5:\n", "        if (f->encoding.reverse_bytes != sox_option_default || f->encoding.opposite_endian)\n", "          usage(\"only one endian option per file is allowed\");\n", "        switch (enum_option(optstate.arg, optstate.lngind, endian_options)) {\n", "          case ENDIAN_little: f->encoding.reverse_bytes = MACHINE_IS_BIGENDIAN; break;\n", "          case ENDIAN_big: f->encoding.reverse_bytes = MACHINE_IS_LITTLEENDIAN; break;\n", "          case ENDIAN_swap: f->encoding.opposite_endian = sox_true; break;\n", "        }\n", "        break;\n", "\n", "      case 6:\n", "        if (sscanf(optstate.arg, \"%i %c\", &i, &dummy) != 1 || i <= SOX_BUFMIN) {\n", "          lsx_fail(\"Buffer size `%s' must be > %d\", optstate.arg, SOX_BUFMIN);\n", "          exit(1);\n", "        }\n", "        sox_globals.input_bufsiz = i;\n", "        break;\n", "\n", "      case 7:\n", "#if defined(HAVE_TERMIOS_H) || defined(HAVE_CONIO_H)\n", "        interactive = sox_true; break;\n", "#else\n", "        lsx_fail(\"Interactive mode has not been enabled at compile time.\");\n", "        exit(1); break;\n", "#endif\n", "      case 8: usage_effect(optstate.arg); break;\n", "      case 9: usage_format(optstate.arg); break;\n", "      case 10: f->no_glob = sox_true; break;\n", "      case 11:\n", "        sox_effects_globals.plot = enum_option(optstate.arg, optstate.lngind, plot_methods);\n", "        break;\n", "      case 12: replay_gain_mode = enum_option(optstate.arg, optstate.lngind, rg_modes); break;\n", "      case 13: display_SoX_version(stdout); exit(0); break;\n", "      case 14: break;\n", "      case 15: effects_filename = lsx_strdup(optstate.arg); break;\n", "      case 16: sox_globals.tmp_path = lsx_strdup(optstate.arg); break;\n", "      case 17: sox_globals.use_threads = sox_false; break;\n", "      case 18: f->signal.length = SOX_IGNORE_LENGTH; break;\n", "      case 19: do_guarded_norm = is_guarded = sox_true;\n", "        norm_level = lsx_strdup(optstate.arg);\n", "        break;\n", "      case 20:\n", "        if (info->flags & sox_version_have_magic)\n", "          sox_globals.use_magic = sox_true;\n", "        else\n", "          lsx_warn(\"this build of SoX does not include `magic'\");\n", "        break;\n", "      case 21: play_rate_arg = lsx_strdup(optstate.arg); break;\n", "      case 22: no_clobber = sox_false; break;\n", "      case 23: no_clobber = sox_true; break;\n", "      case 24: sox_globals.use_threads = sox_true; break;\n", "      case 25:\n", "        if (sscanf(optstate.arg, \"%i %c\", &i, &dummy) != 1 || i < 8 || i > 16) {\n", "          lsx_fail(\"Min DFT size must be in range 8 to 16\");\n", "          exit(1);\n", "        }\n", "        sox_globals.log2_dft_min_size = i;\n", "        break;\n", "      }\n", "      break;\n", "\n", "    case 'G': is_guarded = sox_true; break;\n", "    case 'm': combine_method = sox_mix; break;\n", "    case 'M': combine_method = sox_merge; break;\n", "    case 'T': combine_method = sox_multiply; break;\n", "\n", "    case 'R':                   /* Useful for regression testing. */\n", "      sox_globals.repeatable = sox_true;\n", "      break;\n", "\n", "    case 'd': case 'n': case 'p':\n", "      optstate.ind = optstate.ind;\n", "      return c;\n", "\n", "    case 'h':\n", "      usage(NULL);\n", "      break;\n", "\n", "    case '?':\n", "      usage(\"invalid option\");              /* No return */\n", "      break;\n", "\n", "    case 't':\n", "      f->filetype = optstate.arg;\n", "      if (f->filetype[0] == '.')\n", "        f->filetype++;\n", "      break;\n", "\n", "    case 'r': {\n", "      char k = 0;\n", "      size_t n = sscanf(optstate.arg, \"%lf %c %c\", &f->signal.rate, &k, &dummy);\n", "      if (n < 1 || f->signal.rate <= 0 || (n > 1 && k != 'k') || n > 2) {\n", "        lsx_fail(\"Rate value `%s' is not a positive number\", optstate.arg);\n", "        exit(1);\n", "      }\n", "      f->signal.rate *= k == 'k'? 1000. : 1.;\n", "      break;\n", "    }\n", "\n", "    case 'v':\n", "      if (sscanf(optstate.arg, \"%lf %c\", &f->volume, &dummy) != 1) {\n", "        lsx_fail(\"Volume value `%s' is not a number\", optstate.arg);\n", "        exit(1);\n", "      }\n", "      uservolume = sox_true;\n", "      if (f->volume < 0.0)\n", "        lsx_report(\"Volume adjustment is negative; \"\n", "                  \"this will result in a phase change\");\n", "      break;\n", "\n", "    case 'c':\n", "      if (sscanf(optstate.arg, \"%d %c\", &i, &dummy) != 1 || i <= 0) {\n", "        lsx_fail(\"Channels value `%s' is not a positive integer\", optstate.arg);\n", "        exit(1);\n", "      }\n", "      f->signal.channels = i;\n", "      break;\n", "\n", "    case 'C':\n", "      if (sscanf(optstate.arg, \"%lf %c\", &f->encoding.compression, &dummy) != 1) {\n", "        lsx_fail(\"Compression value `%s' is not a number\", optstate.arg);\n", "        exit(1);\n", "      }\n", "      break;\n", "\n", "    case 'b':\n", "      if (sscanf(optstate.arg, \"%d %c\", &i, &dummy) != 1 || i <= 0) {\n", "        lsx_fail(\"Bits value `%s' is not a positive integer\", optstate.arg);\n", "        exit(1);\n", "      }\n", "      f->encoding.bits_per_sample = i;\n", "      break;\n", "\n", "    case 'e': switch (enum_option(optstate.arg, opt_index('e'), encodings)) {\n", "      case encoding_signed_integer:   f->encoding.encoding = SOX_ENCODING_SIGN2;     break;\n", "      case encoding_unsigned_integer: f->encoding.encoding = SOX_ENCODING_UNSIGNED;  break;\n", "      case encoding_floating_point:   f->encoding.encoding = SOX_ENCODING_FLOAT;     break;\n", "      case encoding_ms_adpcm:         f->encoding.encoding = SOX_ENCODING_MS_ADPCM;  break;\n", "      case encoding_ima_adpcm:        f->encoding.encoding = SOX_ENCODING_IMA_ADPCM; break;\n", "      case encoding_oki_adpcm:        f->encoding.encoding = SOX_ENCODING_OKI_ADPCM; break;\n", "      case encoding_gsm_full_rate:           f->encoding.encoding = SOX_ENCODING_GSM;       break;\n", "      case encoding_u_law: f->encoding.encoding = SOX_ENCODING_ULAW;\n", "        if (f->encoding.bits_per_sample == 0)\n", "          f->encoding.bits_per_sample = 8;\n", "        break;\n", "      case encoding_a_law: f->encoding.encoding = SOX_ENCODING_ALAW;\n", "        if (f->encoding.bits_per_sample == 0)\n", "          f->encoding.bits_per_sample = 8;\n", "        break;\n", "      }\n", "      break;\n", "\n", "    case 'L': case 'B': case 'x':\n", "      if (f->encoding.reverse_bytes != sox_option_default || f->encoding.opposite_endian)\n", "        usage(\"only one endian option per file is allowed\");\n", "      switch (c) {\n", "        case 'L': f->encoding.reverse_bytes   = MACHINE_IS_BIGENDIAN;    break;\n", "        case 'B': f->encoding.reverse_bytes   = MACHINE_IS_LITTLEENDIAN; break;\n", "        case 'x': f->encoding.opposite_endian = sox_true;            break;\n", "      }\n", "      break;\n", "    case 'X': f->encoding.reverse_bits    = sox_option_yes;      break;\n", "    case 'N': f->encoding.reverse_nibbles = sox_option_yes;      break;\n", "\n", "    case 'S': show_progress = sox_option_yes; break;\n", "    case 'q': show_progress = sox_option_no;  break;\n", "    case 'D': no_dither = sox_true; break;\n", "\n", "    case 'V':\n", "      if (optstate.arg == NULL)\n", "        ++sox_globals.verbosity;\n", "      else {\n", "        if (sscanf(optstate.arg, \"%d %c\", &i, &dummy) != 1 || i < 0) {\n", "          sox_globals.verbosity = 2;\n", "          lsx_fail(\"Verbosity value `%s' is not a non-negative integer\", optstate.arg);\n", "          exit(1);\n", "        }\n", "        sox_globals.verbosity = (unsigned)i;\n", "      }\n", "      break;\n", "    }\n", "  }\n", "}\n"], "project": "libsox3", "file": "sox.pkl", "function": "parse_gopts_and_fopts"}, {"comment_all": {"comment": "/* Ensure that we can find the specified callback function,\n   and that it cannot replace/move its param-vector argument,\n   given by u->b.\n*/", "depth": 0, "reading_ease": 51.18, "reading_grade": 11.1, "line": 1993}, "comment_text": "/* Ensure that we can find the specified callback function,\n   and that it cannot replace/move its param-vector argument,\n   given by u->b.\n*/", "comment_tokens": ["Ensure", "that", "we", "can", "find", "the", "specified", "callback", "function", ",", "and", "that", "it", "can", "not", "replacemove", "its", "param-vector", "argument", ",", "given", "by", "u-", ">", "b", "."], "ccode": ["\n", "/* Ensure that we can find the specified callback function,\n", "   and that it cannot replace/move its param-vector argument,\n", "   given by u->b.\n", "*/\n", "\n", "static int check_optimizer_callback (umax *u, const char *fncall)\n", "{\n", "    int n = strcspn(fncall, \"(\");\n", "    int err = 0;\n", "\n", "    if (n > 0 && n < FN_NAMELEN) {\n", "\tchar fname[FN_NAMELEN];\n", "\tuser_var *uvar = NULL;\n", "\tufunc *ufun;\n", "\n", "\t*fname = '\\0';\n", "\tstrncat(fname, fncall, n);\n", "\tufun = get_user_function_by_name(fname);\n", "\tif (u->b == NULL) {\n", "\t    check_optimizer_scalar_parm(u, fncall + n + 1);\n", "\t} else {\n", "\t    uvar = get_user_var_by_data(u->b);\n", "\t}\n", "\tif (ufun != NULL && uvar != NULL) {\n", "\t    user_var_set_flag(uvar, UV_NOREPL);\n", "\t}\n", "    } else if (n >= FN_NAMELEN) {\n", "\terr = E_INVARG;\n", "    }\n", "\n", "    return err;\n", "}\n"], "project": "gretl", "file": "gretl_bfgs.pkl", "function": "check_optimizer_callback"}, {"comment_all": {"comment": "// set the start of the current window\n", "depth": 4, "reading_ease": 89.75, "reading_grade": 2.5, "line": 146}, "comment_text": "// we have seen a word\n// set the start of the current window\n// save intervals falling out of the current window?\n", "comment_tokens": ["we", "have", "seen", "a", "word", "set", "the", "start", "of", "the", "current", "window", "save", "intervals", "falling", "out", "of", "the", "current", "window", "?"], "ccode": ["\n", "const uint64_t *sdust_core(const uint8_t *seq, int l_seq, int T, int W, int *n, sdust_buf_t *buf)\n", "{\n", "\tint rv = 0, rw = 0, L = 0, cv[SD_WTOT], cw[SD_WTOT];\n", "\tint i, start, l; // _start_: start of the current window; _l_: length of a contiguous A/C/G/T (sub)sequence\n", "\tunsigned t; // current word\n", "\n", "\tbuf->P.n = buf->res.n = 0;\n", "\tbuf->w->front = buf->w->count = 0;\n", "\tmemset(cv, 0, SD_WTOT * sizeof(int));\n", "\tmemset(cw, 0, SD_WTOT * sizeof(int));\n", "\tif (l_seq < 0) l_seq = strlen((const char*)seq);\n", "\tfor (i = l = t = 0; i <= l_seq; ++i) {\n", "\t\tint b = i < l_seq? seq_nt4_table[seq[i]] : 4;\n", "\t\tif (b < 4) { // an A/C/G/T base\n", "\t\t\t++l, t = (t<<2 | b) & SD_WMSK;\n", "\t\t\tif (l >= SD_WLEN) { // we have seen a word\n", "\t\t\t\tstart = (l - W > 0? l - W : 0) + (i + 1 - l); // set the start of the current window\n", "\t\t\t\tsave_masked_regions(&buf->res, &buf->P, start); // save intervals falling out of the current window?\n", "\t\t\t\tshift_window(t, buf->w, T, W, &L, &rw, &rv, cw, cv);\n", "\t\t\t\tif (rw * 10 > L * T)\n", "\t\t\t\t\tfind_perfect(&buf->P, buf->w, T, start, L, rv, cv);\n", "\t\t\t}\n", "\t\t} else { // N or the end of sequence; N effectively breaks input into pieces of independent sequences\n", "\t\t\tstart = (l - W + 1 > 0? l - W + 1 : 0) + (i + 1 - l);\n", "\t\t\twhile (buf->P.n) save_masked_regions(&buf->res, &buf->P, start++); // clear up unsaved perfect intervals\n", "\t\t\tl = t = 0;\n", "\t\t}\n", "\t}\n", "\t*n = buf->res.n;\n", "\treturn buf->res.a;\n", "}\n"], "project": "libminimap-dev", "file": "sdust.pkl", "function": "sdust_core"}, {"comment_all": {"comment": "/* Function:  p7_hmm_ScoreDataCreate()\n * Synopsis:  Create a <P7_SCOREDATA> model object, based on MSV-filter\n *            part of profile\n *\n * Purpose:   Allocate a <P7_SCOREDATA> object, then populate\n *            it with data based on the given optimized matrix.\n *\n *            Once a hit passes the MSV filter, and the prefix/suffix\n *            values of P7_SCOREDATA are required, p7_hmm_ScoreDataComputeRest()\n *            must be called.\n *\n * Args:      om         - P7_OPROFILE containing scores used to produce SCOREDATA contents\n *            do_opt_ext - boolean, TRUE if optimal-extension scores are required (for FM-MSV)\n *\n * Returns:   a pointer to the new <P7_SCOREDATA> object.\n *\n * Throws:    <NULL> on allocation failure.\n */", "depth": 0, "reading_ease": 25.29, "reading_grade": 14.8, "line": 155}, "comment_text": "/* Function:  p7_hmm_ScoreDataCreate()\n * Synopsis:  Create a <P7_SCOREDATA> model object, based on MSV-filter\n *            part of profile\n *\n * Purpose:   Allocate a <P7_SCOREDATA> object, then populate\n *            it with data based on the given optimized matrix.\n *\n *            Once a hit passes the MSV filter, and the prefix/suffix\n *            values of P7_SCOREDATA are required, p7_hmm_ScoreDataComputeRest()\n *            must be called.\n *\n * Args:      om         - P7_OPROFILE containing scores used to produce SCOREDATA contents\n *            do_opt_ext - boolean, TRUE if optimal-extension scores are required (for FM-MSV)\n *\n * Returns:   a pointer to the new <P7_SCOREDATA> object.\n *\n * Throws:    <NULL> on allocation failure.\n */", "comment_tokens": ["Function", ":", "p7_hmm_ScoreDataCreate", "(", ")", "Synopsis", ":", "Create", "a", "<", "P7_SCOREDATA", ">", "model", "object", ",", "based", "on", "MSV-filter", "part", "of", "profile", "Purpose", ":", "Allocate", "a", "<", "P7_SCOREDATA", ">", "object", ",", "then", "populate", "it", "with", "data", "based", "on", "the", "given", "optimized", "matrix", ".", "Once", "a", "hit", "passes", "the", "MSV", "filter", ",", "and", "the", "prefixsuffix", "values", "of", "P7_SCOREDATA", "are", "required", ",", "p7_hmm_ScoreDataComputeRest", "(", ")", "must", "be", "called", ".", "Args", ":", "om", "-", "P7_OPROFILE", "containing", "scores", "used", "to", "produce", "SCOREDATA", "contents", "do_opt_ext", "-", "boolean", ",", "TRUE", "if", "optimal-extension", "scores", "are", "required", "(", "for", "FM-MSV", ")", "Returns", ":", "a", "pointer", "to", "the", "new", "<", "P7_SCOREDATA", ">", "object", ".", "Throws", ":", "<", "NULL", ">", "on", "allocation", "failure", "."], "ccode": ["\n", "/* Function:  p7_hmm_ScoreDataCreate()\n", " * Synopsis:  Create a <P7_SCOREDATA> model object, based on MSV-filter\n", " *            part of profile\n", " *\n", " * Purpose:   Allocate a <P7_SCOREDATA> object, then populate\n", " *            it with data based on the given optimized matrix.\n", " *\n", " *            Once a hit passes the MSV filter, and the prefix/suffix\n", " *            values of P7_SCOREDATA are required, p7_hmm_ScoreDataComputeRest()\n", " *            must be called.\n", " *\n", " * Args:      om         - P7_OPROFILE containing scores used to produce SCOREDATA contents\n", " *            do_opt_ext - boolean, TRUE if optimal-extension scores are required (for FM-MSV)\n", " *\n", " * Returns:   a pointer to the new <P7_SCOREDATA> object.\n", " *\n", " * Throws:    <NULL> on allocation failure.\n", " */\n", "P7_SCOREDATA *\n", "p7_hmm_ScoreDataCreate(P7_OPROFILE *om, P7_PROFILE *gm )\n", "{\n", "  P7_SCOREDATA *data = NULL;\n", "  int    status;\n", "\n", "  ESL_ALLOC(data, sizeof(P7_SCOREDATA));\n", "\n", "  data->ssv_scores      = NULL;\n", "  data->ssv_scores_f    = NULL;\n", "  data->opt_ext_fwd     = NULL;\n", "  data->opt_ext_rev     = NULL;\n", "  data->prefix_lengths  = NULL;\n", "  data->suffix_lengths  = NULL;\n", "  data->fwd_scores      = NULL;\n", "  data->fwd_transitions = NULL;\n", "\n", "  scoredata_GetSSVScoreArrays(om, gm, data);\n", "\n", "  return data;\n", "\n", "ERROR:\n", " p7_hmm_ScoreDataDestroy(data);\n", " return NULL;\n", "}\n"], "project": "infernal-doc", "file": "p7_scoredata.pkl", "function": "p7_hmm_ScoreDataCreate"}, {"comment_all": {"comment": "/*\n * image_settings_value_changed() - callback for the \"changed\" signal\n * from the image settings combobox.\n */", "depth": 0, "reading_ease": 43.39, "reading_grade": 9.9, "line": 1448}, "comment_text": "/*\n * image_settings_value_changed() - callback for the \"changed\" signal\n * from the image settings combobox.\n */", "comment_tokens": ["image_settings_value_changed", "(", ")", "-", "callback", "for", "the", "``", "changed", "''", "signal", "from", "the", "image", "settings", "combobox", "."], "ccode": ["\n", "/*\n", " * image_settings_value_changed() - callback for the \"changed\" signal\n", " * from the image settings combobox.\n", " */\n", "\n", "static void image_settings_value_changed(CtkDropDownMenu *widget,\n", "                                         gpointer user_data)\n", "{\n", "    CtkOpenGL *ctk_opengl = CTK_OPENGL(user_data);\n", "    CtrlTarget *ctrl_target = ctk_opengl->ctrl_target;\n", "    gint val = ctk_drop_down_menu_get_current_value(widget);\n", "\n", "    NvCtrlSetAttribute(ctrl_target, NV_CTRL_IMAGE_SETTINGS, val);\n", "    post_image_settings_value_changed(ctk_opengl, val);\n", "\n", "} /* image_settings_value_changed() */\n"], "project": "libxnvctrl0", "file": "ctkopengl.pkl", "function": "image_settings_value_changed"}, {"comment_all": {"comment": "/* Quote escape characters in the data associated with each element\n   of the hash table ASSOC, using quote_escapes */", "depth": 0, "reading_ease": 37.3, "reading_grade": 12.3, "line": 166}, "comment_text": "/* Quote escape characters in the data associated with each element\n   of the hash table ASSOC, using quote_escapes */", "comment_tokens": ["Quote", "escape", "characters", "in", "the", "data", "associated", "with", "each", "element", "of", "the", "hash", "table", "ASSOC", ",", "using", "quote_escapes"], "ccode": ["\n", "/* Quote escape characters in the data associated with each element\n", "   of the hash table ASSOC, using quote_escapes */\n", "HASH_TABLE *\n", "assoc_quote_escapes (h)\n", "     HASH_TABLE *h;\n", "{\n", "  int i;\n", "  BUCKET_CONTENTS *tlist;\n", "  char *t;\n", "\n", "  if (h == 0 || assoc_empty (h))\n", "    return ((HASH_TABLE *)NULL);\n", "  \n", "  for (i = 0; i < h->nbuckets; i++)\n", "    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n", "      {\n", "\tt = quote_escapes ((char *)tlist->data);\n", "\tFREE (tlist->data);\n", "\ttlist->data = t;\n", "      }\n", "\n", "  return h;\n", "}\n"], "project": "bash-doc", "file": "assoc.pkl", "function": "assoc_quote_escapes"}, {"comment_all": {"comment": "/* \n * Return None if a null string is passed as a parameter, and Some str\n * if a string is used.  \n */", "depth": 0, "reading_ease": 86.03, "reading_grade": 6.0, "line": 50}, "comment_text": "/* \n * Return None if a null string is passed as a parameter, and Some str\n * if a string is used.  \n */", "comment_tokens": ["Return", "None", "if", "a", "null", "string", "is", "passed", "as", "a", "parameter", ",", "and", "Some", "str", "if", "a", "string", "is", "used", "."], "ccode": ["\n", "/* \n", " * Return None if a null string is passed as a parameter, and Some str\n", " * if a string is used.  \n", " */\n", "static value\n", "Val_option_string(const char *str) \n", "{\n", "    CAMLparam0();\n", "    CAMLlocal2(some, some_str);\n", "\n", "    if(str == NULL) {\n", "\tCAMLreturn (Val_int(0));\n", "    } else {\n", "\tsome = alloc(1, 0);\n", "\tsome_str = copy_string(str);\n", "\tStore_field(some, 0, some_str);\n", "\tCAMLreturn (some);\n", "    }\n", "}\n"], "project": "libexpat-ocaml-dev", "file": "expat_stubs.pkl", "function": "Val_option_string"}, {"comment_all": {"comment": "/**\n * Free the memory of the pointer contained in the supplied OCaml value `caml_z_stream_pointer`.\n *\n * @param z_streamp_val {value} An OCaml value containing a z_stream pointer to the memory to free.\n */", "depth": 0, "reading_ease": 57.27, "reading_grade": 8.8, "line": 125}, "comment_text": "/**\n * Free the memory of the pointer contained in the supplied OCaml value `caml_z_stream_pointer`.\n *\n * @param z_streamp_val {value} An OCaml value containing a z_stream pointer to the memory to free.\n */", "comment_tokens": ["Free", "the", "memory", "of", "the", "pointer", "contained", "in", "the", "supplied", "OCaml", "value", "`", "caml_z_stream_pointer", "`", ".", "@", "param", "z_streamp_val", "{", "value", "}", "An", "OCaml", "value", "containing", "a", "z_stream", "pointer", "to", "the", "memory", "to", "free", "."], "ccode": ["\n", "/**\n", " * Free the memory of the pointer contained in the supplied OCaml value `caml_z_stream_pointer`.\n", " *\n", " * @param z_streamp_val {value} An OCaml value containing a z_stream pointer to the memory to free.\n", " */\n", "void zlib_free_stream(value z_streamp_val) {\n", "\tcaml_stat_free(ZStreamP_val(z_streamp_val));\n", "\tZStreamP_val(z_streamp_val) = NULL;\n", "}\n"], "project": "haxe", "file": "extc_stubs.pkl", "function": "zlib_free_stream"}, {"comment_all": {"comment": "/* In the caseful case, we can just compare the bytes, whether or not we\nare in UTF-8 mode. */", "depth": 1, "reading_ease": 87.05, "reading_grade": 5.6, "line": 249}, "comment_text": "/* In the caseful case, we can just compare the bytes, whether or not we\nare in UTF-8 mode. */", "comment_tokens": ["In", "the", "caseful", "case", ",", "we", "can", "just", "compare", "the", "bytes", ",", "whether", "or", "not", "we", "are", "in", "UTF-8", "mode", "."], "ccode": ["#endif\n", "\n", "\n", "\n", "/*************************************************\n", "*          Match a back-reference                *\n", "*************************************************/\n", "\n", "/* Normally, if a back reference hasn't been set, the length that is passed is\n", "negative, so the match always fails. However, in JavaScript compatibility mode,\n", "the length passed is zero. Note that in caseless UTF-8 mode, the number of\n", "subject bytes matched may be different to the number of reference bytes.\n", "\n", "Arguments:\n", "  offset      index into the offset vector\n", "  eptr        pointer into the subject\n", "  length      length of reference to be matched (number of bytes)\n", "  md          points to match data block\n", "  caseless    TRUE if caseless\n", "\n", "Returns:      >= 0 the number of subject bytes matched\n", "              -1 no match\n", "              -2 partial match; always given if at end subject\n", "*/\n", "\n", "static int\n", "match_ref(int offset, register PCRE_PUCHAR eptr, int length, match_data *md,\n", "  BOOL caseless)\n", "{\n", "PCRE_PUCHAR eptr_start = eptr;\n", "register PCRE_PUCHAR p = md->start_subject + md->offset_vector[offset];\n", "#if defined SUPPORT_UTF && defined SUPPORT_UCP\n", "BOOL utf = md->utf;\n", "#endif\n", "\n", "#ifdef PCRE_DEBUG\n", "if (eptr >= md->end_subject)\n", "  printf(\"matching subject <null>\");\n", "else\n", "  {\n", "  printf(\"matching subject \");\n", "  pchars(eptr, length, TRUE, md);\n", "  }\n", "printf(\" against backref \");\n", "pchars(p, length, FALSE, md);\n", "printf(\"\\n\");\n", "#endif\n", "\n", "/* Always fail if reference not set (and not JavaScript compatible - in that\n", "case the length is passed as zero). */\n", "\n", "if (length < 0) return -1;\n", "\n", "/* Separate the caseless case for speed. In UTF-8 mode we can only do this\n", "properly if Unicode properties are supported. Otherwise, we can check only\n", "ASCII characters. */\n", "\n", "if (caseless)\n", "  {\n", "#if defined SUPPORT_UTF && defined SUPPORT_UCP\n", "  if (utf)\n", "    {\n", "    /* Match characters up to the end of the reference. NOTE: the number of\n", "    data units matched may differ, because in UTF-8 there are some characters\n", "    whose upper and lower case versions code have different numbers of bytes.\n", "    For example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65\n", "    (3 bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a\n", "    sequence of two of the latter. It is important, therefore, to check the\n", "    length along the reference, not along the subject (earlier code did this\n", "    wrong). */\n", "\n", "    PCRE_PUCHAR endptr = p + length;\n", "    while (p < endptr)\n", "      {\n", "      pcre_uint32 c, d;\n", "      const ucd_record *ur;\n", "      if (eptr >= md->end_subject) return -2;   /* Partial match */\n", "      GETCHARINC(c, eptr);\n", "      GETCHARINC(d, p);\n", "      ur = GET_UCD(d);\n", "      if (c != d && c != d + ur->other_case)\n", "        {\n", "        const pcre_uint32 *pp = PRIV(ucd_caseless_sets) + ur->caseset;\n", "        for (;;)\n", "          {\n", "          if (c < *pp) return -1;\n", "          if (c == *pp++) break;\n", "          }\n", "        }\n", "      }\n", "    }\n", "  else\n", "#endif\n", "\n", "  /* The same code works when not in UTF-8 mode and in UTF-8 mode when there\n", "  is no UCP support. */\n", "    {\n", "    while (length-- > 0)\n", "      {\n", "      pcre_uint32 cc, cp;\n", "      if (eptr >= md->end_subject) return -2;   /* Partial match */\n", "      cc = UCHAR21TEST(eptr);\n", "      cp = UCHAR21TEST(p);\n", "      if (TABLE_GET(cp, md->lcc, cp) != TABLE_GET(cc, md->lcc, cc)) return -1;\n", "      p++;\n", "      eptr++;\n", "      }\n", "    }\n", "  }\n", "\n", "/* In the caseful case, we can just compare the bytes, whether or not we\n", "are in UTF-8 mode. */\n", "\n", "else\n", "  {\n", "  while (length-- > 0)\n", "    {\n", "    if (eptr >= md->end_subject) return -2;   /* Partial match */\n", "    if (UCHAR21INCTEST(p) != UCHAR21INCTEST(eptr)) return -1;\n", "    }\n", "  }\n", "\n", "return (int)(eptr - eptr_start);\n", "}\n"], "project": "libpoco-dev", "file": "pcre_exec.pkl", "function": "match_ref"}, {"comment_all": {"comment": "/* remove the temporary editor filename */", "depth": 1, "reading_ease": 15.64, "reading_grade": 12.3, "line": 740}, "comment_text": "/* remove the temporary editor filename */", "comment_tokens": ["remove", "the", "temporary", "editor", "filename"], "ccode": ["\n", "void \n", "terminate_handler(int sig)\n", "{\n", "#ifdef siglog\n", "  sigfile = open(sigbuff, O_RDWR | O_APPEND);\n", "  write(sigfile, \"Terminate Handler\\n\", strlen(\"Terminate Handler\\n\") + 1);\n", "  close(sigfile);\n", "  sleep(1);\n", "#endif\n", "  kill(child_pid, SIGTERM);\n", "  /* fix the terminal, and exit */\n", "  if(tcsetattr(0, TCSAFLUSH, &oldbuf) == -1) {\n", "    perror(\"clef restoring terminal in terminate handler\");\n", "  }\n", "  printf(\"\\n\");\n", "  Cursor_shape(2);\n", "  fprintf(stderr, \"\\n\");\n", "  /* remove the temporary editor filename */\n", "  unlink(editorfilename);\n", "  exit(0);\n", "}\n"], "project": "axiom-doc", "file": "edible.pkl", "function": "terminate_handler"}, {"comment_all": {"comment": "/* Kill \"unused\" warning */", "depth": 1, "reading_ease": 59.97, "reading_grade": 5.6, "line": 131}, "comment_text": "/* Kill \"unused\" warning */", "comment_tokens": ["Kill", "``", "unused", "''", "warning"], "ccode": ["\n", "void parse_ircomm_lmp(GNetBuf *buf, GString *str)\n", "{\n", "\t/* Kill \"unused\" warning */\n", "\tbuf = buf;\n", "\n", "\tg_string_append(str, \"IrCOMM (IrLPT) \");\n", "\n", "\treturn;\n", "}\n"], "project": "irda-utils", "file": "ircomm.pkl", "function": "parse_ircomm_lmp"}, {"comment_all": {"comment": "/* add */", "depth": 3, "reading_ease": 121.22, "reading_grade": -3.5, "line": 97}, "comment_text": "/* Process the the operations */\n/* operation */\n/* add */\n", "comment_tokens": ["Process", "the", "the", "operations", "operation", "add"], "ccode": ["\n", "int safe_iopf(void *result, const char *const fmt, ...) {\n", "  va_list ap;\n", "  int baseline = 0; /* indicates if the base value is present */\n", "\n", "  const char *c = NULL;\n", "  safe_type_t type = SAFE_IOP_TYPE_DEFAULT;\n", "  /* Result should not be NULL */\n", "  if (!result)\n", "    return 0;\n", "\n", "  va_start(ap, fmt);\n", "  if (fmt == NULL || fmt[0] == '\\0')\n", "    return 0;\n", "  for(c=fmt;(*c);c++) {\n", "    /* Read the type if specified */\n", "    if (!_safe_op_read_type(&type, &c)) {\n", "      return 0;\n", "    }\n", "\n", "    /* Process the the operations */\n", "    switch(*c) { /* operation */\n", "      case '+': /* add */\n", "        _SAFE_IOP_OP_CASE(safe_uadd, safe_sadd);\n", "        break;\n", "      case '-': /* sub */\n", "        _SAFE_IOP_OP_CASE(safe_usub, safe_ssub);\n", "        break;\n", "      case '*': /* mul */\n", "        _SAFE_IOP_OP_CASE(safe_umul, safe_smul);\n", "        break;\n", "      case '/': /* div */\n", "        _SAFE_IOP_OP_CASE(safe_udiv, safe_sdiv);\n", "        break;\n", "      case '%': /* mod */\n", "        _SAFE_IOP_OP_CASE(safe_umod, safe_smod);\n", "        break;\n", "      default:\n", "       /* unknown op */\n", "       return 0;\n", "    }\n", "    /* Reset the type */\n", "   type = SAFE_IOP_TYPE_DEFAULT;\n", "  }\n", "  /* Success! */\n", "  return 1;\n", "}\n"], "project": "libsafe-iop0", "file": "safe_iop.pkl", "function": "safe_iopf"}, {"comment_all": {"comment": "/* Create a new group instance.\n * wrapper function for new_add_var()\n */", "depth": 0, "reading_ease": 66.91, "reading_grade": 5.0, "line": 263}, "comment_text": "/* Create a new group instance.\n * wrapper function for new_add_var()\n */", "comment_tokens": ["Create", "a", "new", "group", "instance", ".", "wrapper", "function", "for", "new_add_var", "(", ")"], "ccode": ["\n", "/* Create a new group instance.\n", " * wrapper function for new_add_var()\n", " */\n", "int cfg_new_ginst(char *group_name, unsigned int group_id)\n", "{\n", "\tstr\tgname;\n", "\n", "\tgname.s = group_name;\n", "\tgname.len = strlen(group_name);\n", "\n", "\treturn new_add_var(&gname, group_id, NULL /* var */,\n", "\t\t\tNULL /* val */, 0 /* type */);\n", "}\n"], "project": "kamailio-kazoo-modules", "file": "cfg.pkl", "function": "cfg_new_ginst"}, {"comment_all": {"comment": "/* Call handlers until one returns nonzero */", "depth": 0, "reading_ease": 56.93, "reading_grade": 6.8, "line": 316}, "comment_text": "/* Call handlers until one returns nonzero */", "comment_tokens": ["Call", "handlers", "until", "one", "returns", "nonzero"], "ccode": ["\n", "/* Call handlers until one returns nonzero */\n", "int\n", "dispatch_handlers(const Event_t *event)\n", "{\n", "  int handled = 0;\n", "  const HFList_t *htmp;\n", "\n", "  assert(event != NULL);\n", "  for (htmp = handlers[event->type]; htmp != NULL; htmp = htmp->next) {\n", "    Debug_unit(&events_unit, \"trying handler %s\", htmp->name);\n", "    handled = (htmp->h(event, htmp->funcdata));\n", "    if (handled != 0) {\n", "      Debug_unit(&events_unit, \"success.\");\n", "      break;\n", "    }\n", "    else {\n", "      Debug_unit(&events_unit, \"failed.\");\n", "    }\n", "  }\n", "  return handled;\n", "}\n"], "project": "libatm1-dev", "file": "events.pkl", "function": "dispatch_handlers"}, {"comment_all": {"comment": "/* There is non-POSIX operating system where fork is not available to\n   applications.  There, we have no pthread_atfork either.  In such a\n   case, we don't call pthread_atfork.  */", "depth": 0, "reading_ease": 71.1, "reading_grade": 5.5, "line": 120}, "comment_text": "/* There is non-POSIX operating system where fork is not available to\n   applications.  There, we have no pthread_atfork either.  In such a\n   case, we don't call pthread_atfork.  */", "comment_tokens": ["There", "is", "non-POSIX", "operating", "system", "where", "fork", "is", "not", "available", "to", "applications", ".", "There", ",", "we", "have", "no", "pthread_atfork", "either", ".", "In", "such", "a", "case", ",", "we", "do", "n't", "call", "pthread_atfork", "."], "ccode": ["\n", "\n", "#ifdef HAVE_PTHREAD_ATFORK\n", "/* There is non-POSIX operating system where fork is not available to\n", "   applications.  There, we have no pthread_atfork either.  In such a\n", "   case, we don't call pthread_atfork.  */\n", "static void\n", "restore_sigmask_for_child_process (void)\n", "{\n", "  pthread_sigmask (SIG_SETMASK, &sigev_unblock, NULL);\n", "}\n"], "project": "libnpth0", "file": "npth-sigev.pkl", "function": "restore_sigmask_for_child_process"}, {"comment_all": {"comment": "/***\n * Function:\n *\treadfile_http_get\t- scan CGI GET data for the requested variable\n * Inputs:\n *\tNone.\n * Returns:\n *\tNothing; exits on error.\n * Modifies:\n *\tMay write to standard output if the variable has been found.\n *\tMay write to standard error and terminate the program.\n */", "depth": 0, "reading_ease": 61.83, "reading_grade": 7.0, "line": 47}, "comment_text": "/***\n * Function:\n *\treadfile_http_get\t- scan CGI GET data for the requested variable\n * Inputs:\n *\tNone.\n * Returns:\n *\tNothing; exits on error.\n * Modifies:\n *\tMay write to standard output if the variable has been found.\n *\tMay write to standard error and terminate the program.\n */", "comment_tokens": ["Function", ":", "readfile_http_get", "-", "scan", "CGI", "GET", "data", "for", "the", "requested", "variable", "Inputs", ":", "None", ".", "Returns", ":", "Nothing", ";", "exits", "on", "error", ".", "Modifies", ":", "May", "write", "to", "standard", "output", "if", "the", "variable", "has", "been", "found", ".", "May", "write", "to", "standard", "error", "and", "terminate", "the", "program", "."], "ccode": ["\n", "static char\t\t*strdup_urldecode(const char * const _s, size_t _len);\n", "\n", "/***\n", " * Function:\n", " *\treadfile_http_get\t- scan CGI GET data for the requested variable\n", " * Inputs:\n", " *\tNone.\n", " * Returns:\n", " *\tNothing; exits on error.\n", " * Modifies:\n", " *\tMay write to standard output if the variable has been found.\n", " *\tMay write to standard error and terminate the program.\n", " */\n", "static void\n", "readfile_http_get(void)\n", "{\n", "\tif (section == NULL)\n", "\t\tsection = \"QUERY_STRING\";\n", "\tconst char *qstr = getenv(section);\n", "\tif (qstr == NULL)\n", "\t\terrx(1, \"No CGI GET data - undefined environment variable %s\",\n", "\t\t    section);\n", "\twhile (*qstr != '\\0') {\n", "\t\tconst char *start = qstr;\n", "\t\twhile (*qstr != '\\0' && *qstr != '&' && *qstr != '=')\n", "\t\t\tqstr++;\n", "\t\tchar * const vname = strdup_urldecode(start, qstr - start);\n", "\n", "\t\tif (*qstr != '=') {\n", "\t\t\tfoundvar(\"\", vname, \"\");\n", "\t\t\tfree(vname);\n", "\t\t\tif (*qstr == '\\0')\n", "\t\t\t\treturn;\n", "\t\t\tif (strncmp(qstr + 1, \"amp;\", 4) == 0)\n", "\t\t\t\tqstr += 5;\n", "\t\t\telse\n", "\t\t\t\tqstr++;\n", "\t\t\tcontinue;\n", "\t\t}\n", "\n", "\t\tstart = ++qstr;\n", "\t\twhile (*qstr != '\\0' && *qstr != '&')\n", "\t\t\tqstr++;\n", "\t\tchar * const vvalue = strdup_urldecode(start, qstr - start);\n", "\t\tfoundvar(\"\", vname, vvalue);\n", "\t\tfree(vname);\n", "\t\tfree(vvalue);\n", "\t\tif (*qstr == '\\0')\n", "\t\t\treturn;\n", "\t\tif (strncmp(qstr + 1, \"amp;\", 4) == 0)\n", "\t\t\tqstr += 5;\n", "\t\telse\n", "\t\t\tqstr++;\n", "\t}\n", "}\n"], "project": "confget", "file": "confget_http_get.pkl", "function": "readfile_http_get"}, {"comment_all": {"comment": "/*\n * libkarma/playlist.c\n *\n * Copyright (c) Frank Zschockelt <libkarma@freakysoft.de> 2005\n * Copyright (c) Keith Bennett <keith@mcs.st-and.ac.uk> 2006\n *\n * You may distribute and modify this program under the terms of \n * the GNU GPL, version 2 or later.\n *\n */", "depth": 0, "reading_ease": 52.56, "reading_grade": 8.5, "line": 0}, "comment_text": "/*\n * libkarma/playlist.c\n *\n * Copyright (c) Frank Zschockelt <libkarma@freakysoft.de> 2005\n * Copyright (c) Keith Bennett <keith@mcs.st-and.ac.uk> 2006\n *\n * You may distribute and modify this program under the terms of \n * the GNU GPL, version 2 or later.\n *\n */", "comment_tokens": ["libkarmaplaylist.c", "Copyright", "(", "c", ")", "Frank", "Zschockelt", "<", "libkarma", "@", "freakysoft.de", ">", "2005", "Copyright", "(", "c", ")", "Keith", "Bennett", "<", "keith", "@", "mcs.st-and.ac.uk", ">", "2006", "You", "may", "distribute", "and", "modify", "this", "program", "under", "the", "terms", "of", "the", "GNU", "GPL", ",", "version", "2", "or", "later", "."], "ccode": ["/*\n", " * libkarma/playlist.c\n", " *\n", " * Copyright (c) Frank Zschockelt <libkarma@freakysoft.de> 2005\n", " * Copyright (c) Keith Bennett <keith@mcs.st-and.ac.uk> 2006\n", " *\n", " * You may distribute and modify this program under the terms of \n", " * the GNU GPL, version 2 or later.\n", " *\n", " */\n", "#include <stdlib.h>\n", "#include <unistd.h>\n", "#include <string.h>\n", "#include <time.h>\n", "\n", "#include \"lkarma.h\"\n", "#include \"properties.h\"\n", "#include \"playlist.h\"\n", "#include \"util.h\"\n", "\n", "uint32_t get_playlist_fid(char * name);\n", "\n", "char * lk_playlist_escape(char * data, unsigned int length)\n", "{\n", "    char * str;\n", "    unsigned int i, count;\n", "    \n", "    str=malloc(length*5+1);\n", "    for(i=0,count=0; i < length; i++, count++){\n", "        if(data[i]=='\\\\'){\n", "            str[count]='\\\\';\n", "            str[++count]='\\\\';\n", "        } else if(data[i]=='\\n'){\n", "            str[count]='\\\\';\n", "            str[++count]='n';\n", "        } else if(data[i]>=32 || data[i]<0) str[count]=data[i];\n", "        else {\n", "            str[count]='\\\\';\n", "            str[++count]='x';\n", "            if((data[i]/16)<10) str[++count]=(data[i]/16)+'0';\n", "            else str[++count]=(data[i]/16)+55;\n", "            if((data[i]%16)<10) str[++count]=(data[i]%16)+'0';\n", "            else str[++count]=(data[i]%16)+55;\n", "        }\n", "    }\n", "    str[count++]=0;\n", "    str=(char *)realloc(str, count);\n", "    return str;\n", "}\n"], "project": "libkarma-dev", "file": "playlist.pkl", "function": "lk_playlist_escape"}, {"comment_all": {"comment": "/* do \"grouping\", items between { and } are one arg */", "depth": 2, "reading_ease": 88.74, "reading_grade": 2.9, "line": 231}, "comment_text": "/* do \"grouping\", items between { and } are one arg */", "comment_tokens": ["do", "``", "grouping", "''", ",", "items", "between", "{", "and", "}", "are", "one", "arg"], "ccode": ["\n", "isc_result_t\n", "isc_commandline_strtoargv(isc_mem_t *mctx, char *s, unsigned int *argcp,\n", "\t\t\t  char ***argvp, unsigned int n) {\n", "\tisc_result_t result;\n", "\n", "restart:\n", "\t/* Discard leading whitespace. */\n", "\twhile (*s == ' ' || *s == '\\t') {\n", "\t\ts++;\n", "\t}\n", "\n", "\tif (*s == '\\0') {\n", "\t\t/* We have reached the end of the string. */\n", "\t\t*argcp = n;\n", "\t\t*argvp = isc_mem_get(mctx, n * sizeof(char *));\n", "\t} else {\n", "\t\tchar *p = s;\n", "\t\twhile (*p != ' ' && *p != '\\t' && *p != '\\0' && *p != '{') {\n", "\t\t\tif (*p == '\\n') {\n", "\t\t\t\t*p = ' ';\n", "\t\t\t\tgoto restart;\n", "\t\t\t}\n", "\t\t\tp++;\n", "\t\t}\n", "\n", "\t\t/* do \"grouping\", items between { and } are one arg */\n", "\t\tif (*p == '{') {\n", "\t\t\tchar *t = p;\n", "\t\t\t/*\n", "\t\t\t * shift all characters to left by 1 to get rid of '{'\n", "\t\t\t */\n", "\t\t\twhile (*t != '\\0') {\n", "\t\t\t\tt++;\n", "\t\t\t\t*(t - 1) = *t;\n", "\t\t\t}\n", "\t\t\twhile (*p != '\\0' && *p != '}') {\n", "\t\t\t\tp++;\n", "\t\t\t}\n", "\t\t\t/* get rid of '}' character */\n", "\t\t\tif (*p == '}') {\n", "\t\t\t\t*p = '\\0';\n", "\t\t\t\tp++;\n", "\t\t\t}\n", "\t\t\t/* normal case, no \"grouping\" */\n", "\t\t} else if (*p != '\\0') {\n", "\t\t\t*p++ = '\\0';\n", "\t\t}\n", "\n", "\t\tresult = isc_commandline_strtoargv(mctx, p, argcp, argvp,\n", "\t\t\t\t\t\t   n + 1);\n", "\t\tif (result != ISC_R_SUCCESS) {\n", "\t\t\treturn (result);\n", "\t\t}\n", "\t\t(*argvp)[n] = s;\n", "\t}\n", "\n", "\treturn (ISC_R_SUCCESS);\n", "}\n"], "project": "bind9-utils", "file": "commandline.pkl", "function": "isc_commandline_strtoargv"}, {"comment_all": {"comment": "/* Close the side of the pipe that is not used: */", "depth": 2, "reading_ease": 112.09, "reading_grade": 0.1, "line": 98}, "comment_text": "/* CHILD - run script */\n/* Close the side of the pipe that is not used: */\n", "comment_tokens": ["CHILD", "-", "run", "script", "Close", "the", "side", "of", "the", "pipe", "that", "is", "not", "used", ":"], "ccode": ["/* ============================================================================\n", " * << File: call_script.c >>\n", " * -------------------------\n", " *  Authors: Emiliano Castagnari (aka Torian) <ecastag@fi.uba.ar>\n", " *           Diego Essaya <dessaya@fi.uba.ar>\n", " *     Date: 14/01/04\n", " *\n", " *  Description:\n", " *    Functions for calling script(1) as a child process and take its\n", " *    output using a pipe.\n", " * ============================================================================\n", " * ============================================================================\n", " *\n", " * ChangeLog: View Changelog\n", " *\n", " * ============================================================================\n", " * Copyright (C) 2003, 2004 Diego Essaya, Emiliano Castagnari\n", " * \n", " * This file is part of gems.\n", " * \n", " * gems is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * gems is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n", " * ============================================================================\n", " */\n", "\n", "#include <unistd.h>\t\t/* fork(), pipe() */\n", "#include <signal.h>\t\t/* kill()   */\n", "#include <sys/wait.h>\t/* wait()   */\n", "#include <string.h>\t\t/* strcat() */\n", "#include <stdlib.h>\t\t/* exit()   */\n", "#include <errno.h>\t\t/* error values - variable errno   */\n", "\n", "#include \"defaults.h\"\n", "#include \"version_server.h\"\n", "#include \"log.h\"\n", "\n", "#include \"call_script.h\"\n", "\n", "#ifndef DEV_FD_DIR\n", "#define DEV_FD_DIR \"/dev/fd/\"\n", "#endif\n", "\n", "/* PID of script. If zero, it means that script is not running. */\n", "static pid_t script_pid = 0;\n", "\n", "/* start_script()\n", " *\n", " * Runs script(1) as a child process and returns in *input_fd the file\n", " * descriptor from which script's output data can be read.\n", " */\n", "status_t start_script(char *script_bin, int *input_fd)\n", "{\n", "\t/* Steps:\n", "\t *   - Create a pipe\n", "\t *   - fork()\n", "\t *     * Child  -> exec(script -fq /dev/fd/nn)\n", "\t *                 where nn is pipefd[1].\n", "\t *     * Father -> read data from pipefd[0]\n", "\t *\n", "\t * FIXME: This function supposes the existence of the /dev/fd/ directory.\n", "\t * Is this portable?...\n", "\t */\n", "\n", "\tint pipefd[2];\n", "\tchar fname[20] = DEV_FD_DIR;\n", "\tchar num_str[5];\n", "\t/* We'll pass 3 arguments to script, so we need a 4 element array of\n", "\t * strings, the last one being NULL */\n", "\tchar *script_argv[] = {NULL, SCRIPT_OPTIONS, NULL, NULL};\n", "\n", "\tscript_argv[0] = script_bin;\n", "\n", "\tg_log(LOG_RUNSCRIPT, script_bin);\n", "\n", "\t/* Create the pipe: */\n", "\tif (pipe(pipefd) == -1)\n", "\t{\n", "\t\tperror(APPNAME);\n", "\t\treturn EXIT_FAIL;\n", "\t}\n", "\n", "\tswitch ((script_pid = fork()))\n", "\t{\n", "\tcase -1:\n", "\t\tperror(APPNAME);\n", "\t\treturn EXIT_FAIL;\n", "\tcase 0:\t/* CHILD - run script */\n", "\t\t/* Close the side of the pipe that is not used: */\n", "\t\tclose(pipefd[0]);\n", "\t\t/* Get the name of the /dev/fd/xx file associated with the pipe */\n", "\t\tsprintf(num_str, \"%d\", pipefd[1]);\n", "\t\tstrcat(fname, num_str);\n", "\t\tscript_argv[2] = fname;\n", "\t\t/* Execute script: */\n", "\t\texecv(script_argv[0], script_argv);\n", "\t\tperror(APPNAME);\n", "\t\texit(-1);\n", "\t}\n", "\n", "\t/* FATHER */\n", "\n", "\t/* Close the side of the pipe that is not used: */\n", "\tclose(pipefd[1]);\n", "\n", "\t*input_fd = pipefd[0];\n", "\treturn CONTINUE;\n", "}\n"], "project": "gems", "file": "call_script.pkl", "function": "start_script"}, {"comment_all": {"comment": "/* Just like mdir_name (dirname-lgpl.c), except, rather than\n   returning NULL upon malloc failure, here, we report the\n   \"memory exhausted\" condition and exit.  */", "depth": 0, "reading_ease": 52.36, "reading_grade": 8.6, "line": 26}, "comment_text": "/* Just like mdir_name (dirname-lgpl.c), except, rather than\n   returning NULL upon malloc failure, here, we report the\n   \"memory exhausted\" condition and exit.  */", "comment_tokens": ["Just", "like", "mdir_name", "(", "dirname-lgpl.c", ")", ",", "except", ",", "rather", "than", "returning", "NULL", "upon", "malloc", "failure", ",", "here", ",", "we", "report", "the", "``", "memory", "exhausted", "''", "condition", "and", "exit", "."], "ccode": ["/* dirname.c -- return all but the last element in a file name\n", "\n", "   Copyright (C) 1990, 1998, 2000-2001, 2003-2006, 2009-2015 Free Software\n", "   Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "#include \"dirname.h\"\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "#include \"xalloc.h\"\n", "\n", "/* Just like mdir_name (dirname-lgpl.c), except, rather than\n", "   returning NULL upon malloc failure, here, we report the\n", "   \"memory exhausted\" condition and exit.  */\n", "\n", "char *\n", "dir_name (char const *file)\n", "{\n", "  char *result = mdir_name (file);\n", "  if (!result)\n", "    xalloc_die ();\n", "  return result;\n", "}\n"], "project": "sharutils-doc", "file": "dirname.pkl", "function": "dir_name"}, {"comment_all": {"comment": "/**\n* Return the list of UID's on this certificate\n*/", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 46}, "comment_text": "/**\n* Return the list of UID's on this certificate\n*/", "comment_tokens": ["Return", "the", "list", "of", "UID", "'s", "on", "this", "certificate"], "ccode": ["/*\n", " * PAM-PKCS11 UID mapper module\n", " * Copyright (C) 2005 Juan Antonio Martinez <jonsito@teleline.es>\n", " * pam-pkcs11 is copyright (C) 2003-2004 of Mario Strasser <mast@gmx.net>\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Lesser General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2.1 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Lesser General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Lesser General Public\n", " * License along with this library; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n", " *\n", " * $Id$\n", " */\n", "\n", "#define __UID_MAPPER_C_\n", "\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "\n", "#include \"../common/cert_st.h\"\n", "#include \"../scconf/scconf.h\"\n", "#include \"../common/debug.h\"\n", "#include \"../common/error.h\"\n", "#include \"../common/strings.h\"\n", "#include \"../common/cert_info.h\"\n", "#include \"mapper.h\"\n", "#include \"uid_mapper.h\"\n", "\n", "/*\n", "* This mapper uses the Unique ID (UID) entry on the certificate to\n", "* find user name.\n", "*/\n", "\n", "static const char *mapfile = \"none\";\n", "static int ignorecase = 0;\n", "static int debug = 0;\n", "\n", "/**\n", "* Return the list of UID's on this certificate\n", "*/\n", "static char ** uid_mapper_find_entries(X509 *x509, void *context) {\n", "\tchar **entries= cert_info(x509,CERT_UID,ALGORITHM_NULL);\n", "        if (!entries) {\n", "                DBG(\"get_unique_id() failed\");\n", "                return NULL;\n", "        }\n", "\n", "        return entries;\n", "}\n"], "project": "libpam-pkcs11", "file": "uid_mapper.pkl", "function": "uid_mapper_find_entries"}, {"comment_all": {"comment": "/*\n * Copyright \u00a9 2016 Red Hat, Inc\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n */", "depth": 0, "reading_ease": 49.75, "reading_grade": 11.6, "line": 14}, "comment_text": "/*\n * Copyright \u00a9 2016 Red Hat, Inc\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n */", "comment_tokens": ["Copyright", "\u00a9", "2016", "Red", "Hat", ",", "Inc", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Library", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Library", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Library", "General", "Public", "License", "along", "with", "this", "library", ".", "If", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", " * Copyright \u00a9 2016 Red Hat, Inc\n", " *\n", " * This library is free software; you can redistribute it and/or\n", " * modify it under the terms of the GNU Library General Public\n", " * License as published by the Free Software Foundation; either\n", " * version 2 of the License, or (at your option) any later version.\n", " *\n", " * This library is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " * Library General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU Library General Public\n", " * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include \"config.h\"\n", "\n", "#include <glib.h>\n", "#include <gio/gio.h>\n", "\n", "#include \"gdkmonitor-x11.h\"\n", "#include \"gdkscreen-x11.h\"\n", "\n", "\n", "G_DEFINE_TYPE (GdkX11Monitor, gdk_x11_monitor, GDK_TYPE_MONITOR)\n", "\n", "static gboolean\n", "gdk_monitor_has_fullscreen_window (GdkMonitor *monitor)\n", "{\n", "  GdkScreen *screen = gdk_display_get_default_screen (monitor->display);\n", "  GList *toplevels, *l;\n", "  GdkWindow *window;\n", "  gboolean has_fullscreen;\n", "\n", "  toplevels = gdk_screen_get_toplevel_windows (screen);\n", "\n", "  has_fullscreen = FALSE;\n", "  for (l = toplevels; l; l = l->next)\n", "    {\n", "      window = l->data;\n", "\n", "      if ((gdk_window_get_state (window) & GDK_WINDOW_STATE_FULLSCREEN) == 0)\n", "        continue;\n", "\n", "      if (gdk_window_get_fullscreen_mode (window) == GDK_FULLSCREEN_ON_ALL_MONITORS ||\n", "          gdk_display_get_monitor_at_window (monitor->display, window) == monitor)\n", "        {\n", "          has_fullscreen = TRUE;\n", "          break;\n", "        }\n", "    }\n", "\n", "  g_list_free (toplevels);\n", "\n", "  return has_fullscreen;\n", "}\n"], "project": "libgail-3-dev", "file": "gdkmonitor-x11.pkl", "function": "gdk_monitor_has_fullscreen_window"}, {"comment_all": {"comment": "/**\n * flickcurl_photosets_getInfo:\n * @fc: flickcurl context\n * @photoset_id: The ID of the photoset to fetch information for.\n * \n * Gets information about a photoset.\n *\n * Implements flickr.photosets.getInfo (0.13)\n * \n * Return value: non-0 on failure\n **/", "depth": 0, "reading_ease": 20.04, "reading_grade": 12.7, "line": 356}, "comment_text": "/**\n * flickcurl_photosets_getInfo:\n * @fc: flickcurl context\n * @photoset_id: The ID of the photoset to fetch information for.\n * \n * Gets information about a photoset.\n *\n * Implements flickr.photosets.getInfo (0.13)\n * \n * Return value: non-0 on failure\n **/", "comment_tokens": ["flickcurl_photosets_getInfo", ":", "@", "fc", ":", "flickcurl", "context", "@", "photoset_id", ":", "The", "ID", "of", "the", "photoset", "to", "fetch", "information", "for", ".", "Gets", "information", "about", "a", "photoset", ".", "Implements", "flickr.photosets.getInfo", "(", "0.13", ")", "Return", "value", ":", "non-0", "on", "failure"], "ccode": ["\n", "\n", "/**\n", " * flickcurl_photosets_getInfo:\n", " * @fc: flickcurl context\n", " * @photoset_id: The ID of the photoset to fetch information for.\n", " * \n", " * Gets information about a photoset.\n", " *\n", " * Implements flickr.photosets.getInfo (0.13)\n", " * \n", " * Return value: non-0 on failure\n", " **/\n", "flickcurl_photoset*\n", "flickcurl_photosets_getInfo(flickcurl* fc, const char* photoset_id)\n", "{\n", "  xmlDocPtr doc = NULL;\n", "  xmlXPathContextPtr xpathCtx = NULL; \n", "  flickcurl_photoset* photoset = NULL;\n", "  \n", "  flickcurl_init_params(fc, 0);\n", "\n", "  if(!photoset_id)\n", "    return NULL;\n", "\n", "  flickcurl_add_param(fc, \"photoset_id\", photoset_id);\n", "\n", "  flickcurl_end_params(fc);\n", "\n", "  if(flickcurl_prepare(fc, \"flickr.photosets.getInfo\"))\n", "    goto tidy;\n", "\n", "  doc = flickcurl_invoke(fc);\n", "  if(!doc)\n", "    goto tidy;\n", "\n", "\n", "  xpathCtx = xmlXPathNewContext(doc);\n", "  if(!xpathCtx) {\n", "    flickcurl_error(fc, \"Failed to create XPath context for document\");\n", "    fc->failed = 1;\n", "    goto tidy;\n", "  }\n", "\n", "  photoset = flickcurl_build_photoset(fc, xpathCtx);\n", "\n", "  tidy:\n", "  if(xpathCtx)\n", "    xmlXPathFreeContext(xpathCtx);\n", "\n", "  if(fc->failed) {\n", "    if(photoset)\n", "      flickcurl_free_photoset(photoset);\n", "    photoset = NULL;\n", "  }\n", "\n", "  return photoset;\n", "}\n"], "project": "libflickcurl0-dbg", "file": "photosets-api.pkl", "function": "flickcurl_photosets_getInfo"}, {"comment_all": {"comment": "/* fw may be invalid, regather it */", "depth": 1, "reading_ease": 73.85, "reading_grade": 4.5, "line": 534}, "comment_text": "/* fw may be invalid, regather it */", "comment_tokens": ["fw", "may", "be", "invalid", ",", "regather", "it"], "ccode": ["\n", "void stfl_form_run(struct stfl_form *f, int timeout)\n", "{\n", "\twchar_t *on_handler = 0;\n", "\n", "\tpthread_mutex_lock(&f->mtx);\n", "\n", "\tif (f->event)\n", "\t\tfree(f->event);\n", "\tf->event = 0;\n", "\n", "\tif (timeout >= 0 && f->event_queue)\n", "\t\tgoto unshift_next_event;\n", "\n", "\tif (timeout == -2)\n", "\t\tgoto unshift_next_event;\n", "\n", "\tif (!f->root) {\n", "\t\tfprintf(stderr, \"STFL Fatal Error: Called stfl_form_run() without root widget.\\n\");\n", "\t\tabort();\n", "\t}\n", "\n", "\tif (!curses_active)\n", "\t{\n", "\t\tinitscr();\n", "\t\tcbreak();\n", "\t\tnoecho();\n", "\t\tnonl();\n", "\t\tkeypad(stdscr, TRUE);\n", "\t\tdoupdate();\n", "\t\tstart_color();\n", "\t\tuse_default_colors();\n", "\t\twbkgdset(stdscr, ' ');\n", "\t\tcurses_active = 1;\n", "\t}\n", "\n", "\tstfl_colorpair_counter = 1;\n", "\tf->root->type->f_prepare(f->root, f);\n", "\n", "\tstruct stfl_widget *fw = stfl_gather_focus_widget(f);\n", "\tf->current_focus_id = fw ? fw->id : 0;\n", "\n", "\tgetbegyx(stdscr, f->root->y, f->root->x);\n", "\tgetmaxyx(stdscr, f->root->h, f->root->w);\n", "\n", "\tif (timeout == -3) {\n", "\t\tWINDOW *dummywin = newwin(0, 0, 0, 0);\n", "\t\tif (dummywin == NULL) {\n", "\t\t\tfprintf(stderr, \"STFL Fatal Error: stfl_form_run() got a NULL pointer from newwin(0, 0, 0, 0).\\n\");\n", "\t\t\tabort();\n", "\t\t}\n", "\t\tf->root->type->f_draw(f->root, f, dummywin);\n", "\t\tdelwin(dummywin);\n", "\t\tpthread_mutex_unlock(&f->mtx);\n", "\t\treturn;\n", "\t}\n", "\n", "\twerase(stdscr);\n", "\tf->root->type->f_draw(f->root, f, stdscr);\n", "\tif (timeout == -1 && f->root->cur_y != -1 && f->root->cur_x != -1) {\n", "\t\twmove(stdscr, f->root->cur_y, f->root->cur_x);\n", "\t}\n", "\trefresh();\n", "\n", "\tif (timeout < 0) {\n", "\t\tpthread_mutex_unlock(&f->mtx);\n", "\t\treturn;\n", "\t}\n", "\n", "\twtimeout(stdscr, timeout == 0 ? -1 : timeout);\n", "\twmove(stdscr, f->cursor_y, f->cursor_x);\n", "\n", "\twint_t wch;\n", "\tpthread_mutex_unlock(&f->mtx);\n", "\tint rc = wget_wch(stdscr, &wch);\n", "\tpthread_mutex_lock(&f->mtx);\n", "\n", "\t/* fw may be invalid, regather it */\n", "\tfw = stfl_gather_focus_widget(f);\n", "\tf->current_focus_id = fw ? fw->id : 0;\n", "\n", "\tstruct stfl_widget *w = fw;\n", "\n", "\tif (rc == ERR) {\n", "\t\tstfl_form_event(f, compat_wcsdup(L\"TIMEOUT\"));\n", "\t\tgoto unshift_next_event;\n", "\t}\n", "\n", "\twchar_t *on_event = stfl_keyname(wch, rc == KEY_CODE_YES);\n", "\tint on_handler_len = wcslen(on_event) + 4;\n", "\ton_handler = malloc(on_handler_len * sizeof(wchar_t));\n", "\tswprintf(on_handler, on_handler_len, L\"on_%ls\", on_event);\n", "\tfree(on_event);\n", "\n", "\twhile (w) {\n", "\t\tconst wchar_t *event = stfl_widget_getkv_str(w, on_handler, 0);\n", "\t\tif (event) {\n", "\t\t\tstfl_form_event(f, compat_wcsdup(event));\n", "\t\t\tgoto unshift_next_event;\n", "\t\t}\n", "\n", "\t\tif (w->type->f_process && w->type->f_process(w, fw, f, wch, rc == KEY_CODE_YES))\n", "\t\t\tgoto unshift_next_event;\n", "\n", "\t\tif (stfl_widget_getkv_int(w, L\"modal\", 0))\n", "\t\t\tgoto generate_event;\n", "\n", "\t\tw = w->parent;\n", "\t}\n", "\n", "\tif (rc != KEY_CODE_YES && wch == L'\\t')\n", "\t{\n", "\t\tstruct stfl_widget *old_fw = fw = stfl_widget_by_id(f->root, f->current_focus_id);\n", "\n", "\t\tif (!fw)\n", "\t\t\tgoto generate_event;\n", "\n", "\t\tdo {\n", "\t\t\tif (fw->first_child)\n", "\t\t\t\tfw = fw->first_child;\n", "\t\t\telse\n", "\t\t\tif (fw->next_sibling)\n", "\t\t\t\tfw = fw->next_sibling;\n", "\t\t\telse\n", "\t\t\t{\n", "\t\t\t\twhile (fw->parent && !fw->parent->next_sibling)\n", "\t\t\t\t\tfw = fw->parent;\n", "\t\t\t\tfw = fw->parent ? fw->parent->next_sibling : 0;\n", "\t\t\t}\n", "\n", "\t\t\tif (!fw && old_fw)\n", "\t\t\t\tfw = f->root;\n", "\t\t} while (fw && !fw->allow_focus);\n", "\n", "\t\tif (old_fw != fw)\n", "\t\t{\n", "\t\t\tif (old_fw && old_fw->type->f_leave)\n", "\t\t\t\told_fw->type->f_leave(old_fw, f);\n", "\n", "\t\t\tif (fw && fw->type->f_enter)\n", "\t\t\t\tfw->type->f_enter(fw, f);\n", "\n", "\t\t\tf->current_focus_id = fw ? fw->id : 0;\n", "\t\t}\n", "\n", "\t\tgoto unshift_next_event;\n", "\t}\n", "\n", "generate_event:\n", "\tstfl_form_event(f, stfl_keyname(wch, rc == KEY_CODE_YES));\n", "\n", "unshift_next_event:;\n", "\tstruct stfl_event *e = f->event_queue;\n", "\tif (e) {\n", "\t\tf->event_queue = e->next;\n", "\t\tf->event = e->event;\n", "\t\tfree(e);\n", "\t}\n", "\n", "\tpthread_mutex_unlock(&f->mtx);\n", "\tfree(on_handler);\n", "}\n"], "project": "libstfl-ruby", "file": "base.pkl", "function": "stfl_form_run"}, {"comment_all": {"comment": "/*checks two strands which can be +,- and . if they are compatible.\n * compatible strands are '++', '--', '+.', '.+', '-.', '.-' and '..'  */", "depth": 0, "reading_ease": 83.32, "reading_grade": 2.9, "line": 90}, "comment_text": "/*checks two strands which can be +,- and . if they are compatible.\n * compatible strands are '++', '--', '+.', '.+', '-.', '.-' and '..'  */", "comment_tokens": ["checks", "two", "strands", "which", "can", "be", "+", ",", "-", "and", ".", "if", "they", "are", "compatible", ".", "compatible", "strands", "are", "'++", "'", ",", "'", "--", "'", ",", "'+", ".", "'", ",", "'.+", "'", ",", "'-", ".", "'", ",", "'.-", "'", "and", "'", "..", "'"], "ccode": ["\n", "/*checks two strands which can be +,- and . if they are compatible.\n", " * compatible strands are '++', '--', '+.', '.+', '-.', '.-' and '..'  */\n", "int isCompatibleStrand(char strand1, char strand2)\n", "{\n", "\tif((strand1==strand2) || (strand1=='.') || (strand2 == '.'))\n", "\t{\n", "\t\treturn TRUE;\n", "\t}\n", "\treturn FALSE;\n", "}\n"], "project": "augustus", "file": "compileSpliceCands.pkl", "function": "isCompatibleStrand"}, {"comment_all": {"comment": "/*\n\t * Temporarily redirect allocation functions to\n\t * static_calloc_aligned, and free function to static_free\n\t * (no-op), until the dlsym lookup has completed.\n\t */", "depth": 1, "reading_ease": 10.91, "reading_grade": 16.2, "line": 236}, "comment_text": "/*\n\t * Temporarily redirect allocation functions to\n\t * static_calloc_aligned, and free function to static_free\n\t * (no-op), until the dlsym lookup has completed.\n\t */", "comment_tokens": ["Temporarily", "redirect", "allocation", "functions", "to", "static_calloc_aligned", ",", "and", "free", "function", "to", "static_free", "(", "no-op", ")", ",", "until", "the", "dlsym", "lookup", "has", "completed", "."], "ccode": ["\n", "static\n", "void lookup_all_symbols(void)\n", "{\n", "\tstruct alloc_functions af;\n", "\n", "\t/*\n", "\t * Temporarily redirect allocation functions to\n", "\t * static_calloc_aligned, and free function to static_free\n", "\t * (no-op), until the dlsym lookup has completed.\n", "\t */\n", "\tsetup_static_allocator();\n", "\n", "\t/* Perform the actual lookups */\n", "\taf.calloc = dlsym(RTLD_NEXT, \"calloc\");\n", "\taf.malloc = dlsym(RTLD_NEXT, \"malloc\");\n", "\taf.free = dlsym(RTLD_NEXT, \"free\");\n", "\taf.realloc = dlsym(RTLD_NEXT, \"realloc\");\n", "\taf.memalign = dlsym(RTLD_NEXT, \"memalign\");\n", "\taf.posix_memalign = dlsym(RTLD_NEXT, \"posix_memalign\");\n", "\n", "\t/* Populate the new allocator functions */\n", "\tmemcpy(&cur_alloc, &af, sizeof(cur_alloc));\n", "}\n"], "project": "liblttng-ust-java-jni", "file": "lttng-ust-malloc.pkl", "function": "lookup_all_symbols"}, {"comment_all": {"comment": "/* xmms_remote_playlist_next(oglspectrum_vp.xmms_session); */", "depth": 5, "reading_ease": -386.39, "reading_grade": 67.4, "line": 301}, "comment_text": "/* xmms_remote_playlist_next(oglspectrum_vp.xmms_session); */", "comment_tokens": ["xmms_remote_playlist_next", "(", "oglspectrum_vp.xmms_session", ")", ";"], "ccode": ["\n", "#define DEFAULT_W\t640\n", "#define DEFAULT_H 480\n", "\n", "void *draw_thread_func(void *arg)\n", "{\n", "\tBool configured = FALSE;\n", "\n", "\twindow_w = prefs_get_int(ap_prefs, \"opengl_spectrum\", \"width\", DEFAULT_W);\t\n", "\twindow_h = prefs_get_int(ap_prefs, \"opengl_spectrum\", \"height\", DEFAULT_H);\n", "\t\n", "\tif ((window = create_window(window_w, window_h)) == 0)\n", "\t{\n", "\t\talsaplayer_error(\"unable to create window\");\n", "\t\tpthread_exit(NULL);\n", "\t}\n", "\t\n", "\tXMapWindow(dpy, window);\n", "\n", "\tglMatrixMode(GL_PROJECTION);\n", "\tglLoadIdentity();\n", "\tglFrustum(-1, 1, -1, 1, 1.5, 10);\n", "\tglMatrixMode(GL_MODELVIEW);\n", "\tglLoadIdentity();\n", "\tglEnable(GL_DEPTH_TEST);\n", "\tglDepthFunc(GL_LESS);\n", "\n", "\twhile(going)\n", "\t{\n", "\t\twhile(XPending(dpy))\n", "\t\t{\n", "\t\t\tXEvent event;\n", "\t\t\tKeySym keysym;\n", "\t\t\tchar buf[16];\n", "\t\t\t\n", "\t\t\tXNextEvent(dpy, &event);\n", "\t\t\tswitch(event.type)\n", "\t\t\t{\n", "\t\t\tcase ConfigureNotify:\n", "\t\t\t\tglViewport(0,0,event.xconfigure.width, event.xconfigure.height);\n", "\t\t\t\twindow_w = event.xconfigure.width;\n", "\t\t\t\twindow_h = event.xconfigure.height;\n", "\t\t\t\tprefs_set_int(ap_prefs, \"opengl_spectrum\", \"width\", window_w);\n", "\t\t\t\tprefs_set_int(ap_prefs, \"opengl_spectrum\", \"height\", window_h);\n", "\t\t\t\tconfigured = TRUE;\n", "\t\t\t\tbreak;\n", "\t\t\tcase KeyPress:\n", "\n", "\t\t\t\t\n", "\t\t\t\tXLookupString (&event.xkey, buf, 16, &keysym, NULL);\n", "\t\t\t\tswitch(keysym)\n", "\t\t\t\t{\n", "\t\t\t\tcase XK_Escape:\n", "\t\t\t\t\t\n", "\t\t\t\t\tgoing = FALSE;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_z:\n", "\t\t\t\t\t/*xmms_remote_playlist_prev(oglspectrum_vp.xmms_session); */\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_x:\n", "\t\t\t\t\t/*xmms_remote_play(oglspectrum_vp.xmms_session); */\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_c:\n", "\t\t\t\t\t/*xmms_remote_pause(oglspectrum_vp.xmms_session); */\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_v:\n", "\t\t\t\t\t/*xmms_remote_stop(oglspectrum_vp.xmms_session); */\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_b:\n", "\t\t\t\t\t/* xmms_remote_playlist_next(oglspectrum_vp.xmms_session); */\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_Up:\t\t\t\t\t\n", "\t\t\t\t\tx_speed -= 0.1;\n", "\t\t\t\t\tif(x_speed < -3.0)\n", "\t\t\t\t\t\tx_speed = -3.0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_Down:\t\t\t\t\t\n", "\t\t\t\t\tx_speed += 0.1;\n", "\t\t\t\t\tif(x_speed > 3.0)\n", "\t\t\t\t\t\tx_speed = 3.0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_Left:\n", "\t\t\t\t\ty_speed -= 0.1;\n", "\t\t\t\t\tif(y_speed < -3.0)\n", "\t\t\t\t\t\ty_speed = -3.0;\n", "\t\t\t\t\t\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_Right:\n", "\t\t\t\t\ty_speed += 0.1;\n", "\t\t\t\t\tif(y_speed > 3.0)\n", "\t\t\t\t\t\ty_speed = 3.0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_w:\n", "\t\t\t\t\tz_speed -= 0.1;\n", "\t\t\t\t\tif(z_speed < -3.0)\n", "\t\t\t\t\t\tz_speed = -3.0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_q:\n", "\t\t\t\t\tz_speed += 0.1;\n", "\t\t\t\t\tif(z_speed > 3.0)\n", "\t\t\t\t\t\tz_speed = 3.0;\n", "\t\t\t\t\tbreak;\n", "\t\t\t\tcase XK_Return:\n", "\t\t\t\t\tx_speed = 0.0;\n", "\t\t\t\t\ty_speed = 0.5;\n", "\t\t\t\t\tz_speed = 0.0;\n", "\t\t\t\t\tx_angle = 20.0;\n", "\t\t\t\t\ty_angle = 45.0;\n", "\t\t\t\t\tz_angle = 0.0;\n", "\t\t\t\t\tbreak;\t\t\t\t\t\n", "\t\t\t\t}\n", "\t\t\t\t\n", "\t\t\t\tbreak;\n", "\t\t\tcase ClientMessage:\n", "\t\t\t\tif ((Atom)event.xclient.data.l[0] == wm_delete_window_atom)\n", "\t\t\t\t{\n", "\t\t\t\t\tgoing = FALSE;\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t\tif(configured)\n", "\t\t{\n", "\t\t\tx_angle += x_speed;\n", "\t\t\tif(x_angle >= 360.0)\n", "\t\t\t\tx_angle -= 360.0;\n", "\t\t\t\n", "\t\t\ty_angle += y_speed;\n", "\t\t\tif(y_angle >= 360.0)\n", "\t\t\t\ty_angle -= 360.0;\n", "\n", "\t\t\tz_angle += z_speed;\n", "\t\t\tif(z_angle >= 360.0)\n", "\t\t\t\tz_angle -= 360.0;\n", "\n", "\t\t\tdraw_bars();\n", "\t\t}\n", "\t}\n", "\n", "\tif (glxcontext)\n", "\t{\n", "\t\tglXMakeCurrent(dpy, 0, NULL);\n", "\t\tglXDestroyContext(dpy, glxcontext);\n", "\t\tglxcontext = NULL;\n", "\t}\n", "\tif (window)\n", "\t{\n", "\t\tif (grabbed_pointer)\n", "\t\t{\n", "\t\t\tXUngrabPointer(dpy, CurrentTime);\n", "\t\t\tgrabbed_pointer = FALSE;\n", "\t\t}\n", "\n", "\t\tXDestroyWindow(dpy, window);\n", "\t\twindow = 0;\n", "\t}\n", "\tpthread_mutex_unlock(&scope_mutex);\n", "\tstop_display(0); /* Close down display */\n", "\tpthread_exit(NULL);\n", "}\n"], "project": "alsaplayer-gtk", "file": "opengl_spectrum.pkl", "function": "draw_thread_func"}, {"comment_all": {"comment": "// test complexity\n", "depth": 3, "reading_ease": -6.7, "reading_grade": 14.7, "line": 239}, "comment_text": "// clear the rid field\n// test complexity\n", "comment_tokens": ["clear", "the", "rid", "field", "test", "complexity"], "ccode": ["\n", "const mm_reg1_t *mm_map(const mm_idx_t *mi, int l_seq, const char *seq, int *n_regs, mm_tbuf_t *b, const mm_mapopt_t *opt, const char *name)\n", "{\n", "\tint j, n_dreg = 0, u = 0;\n", "\tconst uint64_t *dreg = 0;\n", "\n", "\tb->mini.n = b->coef.n = 0;\n", "\tmm_sketch(seq, l_seq, mi->w, mi->k, 0, &b->mini);\n", "\tif (opt->sdust_thres > 0)\n", "\t\tdreg = sdust_core((const uint8_t*)seq, l_seq, opt->sdust_thres, 64, &n_dreg, b->sdb);\n", "\tfor (j = 0; j < b->mini.n; ++j) {\n", "\t\tint k, n;\n", "\t\tconst uint64_t *r;\n", "\t\tint32_t qpos = (uint32_t)b->mini.a[j].y>>1, strand = b->mini.a[j].y&1;\n", "\t\tb->mini.a[j].y = b->mini.a[j].y<<32>>32; // clear the rid field\n", "\t\tif (dreg && n_dreg) { // test complexity\n", "\t\t\tint s = qpos - (mi->k - 1), e = s + mi->k;\n", "\t\t\twhile (u < n_dreg && (uint32_t)dreg[u] <= s) ++u;\n", "\t\t\tif (u < n_dreg && dreg[u]>>32 < e) {\n", "\t\t\t\tint v, l = 0;\n", "\t\t\t\tfor (v = u; v < n_dreg && dreg[v]>>32 < e; ++v) { // iterate over LCRs overlapping this minimizer\n", "\t\t\t\t\tint ss = s > dreg[v]>>32? s : dreg[v]>>32;\n", "\t\t\t\t\tint ee = e < (uint32_t)dreg[v]? e : (uint32_t)dreg[v];\n", "\t\t\t\t\tl += ee - ss;\n", "\t\t\t\t}\n", "\t\t\t\tif (l > mi->k>>1) continue;\n", "\t\t\t}\n", "\t\t}\n", "\t\tr = mm_idx_get(mi, b->mini.a[j].x, &n);\n", "\t\tif (n > mi->max_occ) continue;\n", "\t\tfor (k = 0; k < n; ++k) {\n", "\t\t\tint32_t rpos = (uint32_t)r[k] >> 1;\n", "\t\t\tmm128_t *p;\n", "\t\t\tif (name && (opt->flag&MM_F_NO_SELF) && mi->name && strcmp(name, mi->name[r[k]>>32]) == 0 && rpos == qpos)\n", "\t\t\t\tcontinue;\n", "\t\t\tif (name && (opt->flag&MM_F_AVA) && mi->name && strcmp(name, mi->name[r[k]>>32]) > 0)\n", "\t\t\t\tcontinue;\n", "\t\t\tkv_pushp(mm128_t, b->coef, &p);\n", "\t\t\tif ((r[k]&1) == strand) { // forward strand\n", "\t\t\t\tp->x = (uint64_t)r[k] >> 32 << 32 | (0x80000000U + rpos - qpos);\n", "\t\t\t\tp->y = (uint64_t)j << 32 | rpos;\n", "\t\t\t} else { // reverse strand\n", "\t\t\t\tp->x = (uint64_t)r[k] >> 32 << 32 | (rpos + qpos) | 1ULL<<63;\n", "\t\t\t\tp->y = (uint64_t)j << 32 | rpos;\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\tradix_sort_128x(b->coef.a, b->coef.a + b->coef.n);\n", "\tb->reg.n = 0;\n", "\tget_reg(b, opt->radius, mi->k, opt->min_cnt, opt->max_gap, opt->merge_frac, opt->flag);\n", "\t*n_regs = b->reg.n;\n", "\treturn b->reg.a;\n", "}\n"], "project": "libminimap-dev", "file": "map.pkl", "function": "mm_map"}, {"comment_all": {"comment": "/* signal args don't need sorting since only \"out\" is allowed */", "depth": 1, "reading_ease": 78.25, "reading_grade": 4.8, "line": 637}, "comment_text": "/* signal args don't need sorting since only \"out\" is allowed */", "comment_tokens": ["signal", "args", "do", "n't", "need", "sorting", "since", "only", "``", "out", "''", "is", "allowed"], "ccode": ["\n", "void\n", "signal_info_add_arg (SignalInfo    *info,\n", "                     ArgInfo       *arg)\n", "{\n", "  g_assert (arg->direction == ARG_OUT);\n", "  \n", "  arg_info_ref (arg);\n", "  info->args = g_slist_append (info->args, arg);\n", "  \n", "  /* signal args don't need sorting since only \"out\" is allowed */\n", "}\n"], "project": "libdbus-glib-1-dev", "file": "dbus-gidl.pkl", "function": "signal_info_add_arg"}, {"comment_all": {"comment": "/** Get a connections output file descriptor.\n *\n * @param con_state The connection context.\n * @return The file descriptor.\n */", "depth": 0, "reading_ease": 49.48, "reading_grade": 7.6, "line": 621}, "comment_text": "/** Get a connections output file descriptor.\n *\n * @param con_state The connection context.\n * @return The file descriptor.\n */", "comment_tokens": ["Get", "a", "connections", "output", "file", "descriptor", ".", "@", "param", "con_state", "The", "connection", "context", ".", "@", "return", "The", "file", "descriptor", "."], "ccode": ["\n", "/** Get a connections output file descriptor.\n", " *\n", " * @param con_state The connection context.\n", " * @return The file descriptor.\n", " */\n", "int\n", "econ_get_rd_fd(econ_state_t *con_state)\n", "{\n", "    return con_state->key_stream->fd;\n", "}\n"], "project": "ekeyd-egd-linux", "file": "connection.pkl", "function": "econ_get_rd_fd"}, {"comment_all": {"comment": "// returned\n", "depth": 1, "reading_ease": 36.62, "reading_grade": 8.4, "line": 186}, "comment_text": "// The number of bytes in the output (not including the trailing '\\0') is\n// returned\n", "comment_tokens": ["The", "number", "of", "bytes", "in", "the", "output", "(", "not", "including", "the", "trailing", "'\\0", "'", ")", "is", "returned"], "ccode": ["\n", "int vnlog_base64_encode(       char* dst, int dstlen,\n", "                         const char* src, int srclen )\n", "{\n", "    if(srclen <= 0)\n", "    {\n", "        if(dstlen > 0)\n", "            *dst = '\\0';\n", "        return 0;\n", "    }\n", "\n", "    base64_encodestate s;\n", "    base64_init_encodestate(&s);\n", "\n", "    const int dstlen_needed = vnlog_base64_dstlen_to_encode(srclen);\n", "\n", "    if(dstlen < dstlen_needed)\n", "        return -1;\n", "\n", "    int len = base64_encode_block(src, srclen, dst, &s);\n", "    len += base64_encode_blockend(&dst[len], &s);\n", "    dst[len] = '\\0';\n", "\n", "    // The number of bytes in the output (not including the trailing '\\0') is\n", "    // returned\n", "    return len;\n", "}\n"], "project": "libvnlog-perl", "file": "b64_cencode.pkl", "function": "vnlog_base64_encode"}, {"comment_all": {"comment": "/* daemon_lock_pidfile and fcntl_lock taken from libslack \n * Copyright (C) 1999-2004 raf <raf@raf.org>\n * Licensed under the GPL\n */", "depth": 0, "reading_ease": 55.4, "reading_grade": 7.4, "line": 316}, "comment_text": "/* daemon_lock_pidfile and fcntl_lock taken from libslack \n * Copyright (C) 1999-2004 raf <raf@raf.org>\n * Licensed under the GPL\n */", "comment_tokens": ["daemon_lock_pidfile", "and", "fcntl_lock", "taken", "from", "libslack", "Copyright", "(", "C", ")", "1999-2004", "raf", "<", "raf", "@", "raf.org", ">", "Licensed", "under", "the", "GPL"], "ccode": ["\n", "/* daemon_lock_pidfile and fcntl_lock taken from libslack \n", " * Copyright (C) 1999-2004 raf <raf@raf.org>\n", " * Licensed under the GPL\n", " */\n", "int \n", "fcntl_lock(int fd, int cmd, int type, int whence, int start, int len)\n", "{\n", "        struct flock lock[1];\n", "\n", "        lock->l_type = type;\n", "        lock->l_whence = whence;\n", "        lock->l_start = start;\n", "        lock->l_len = len;\n", "\n", "        return fcntl(fd, cmd, lock);\n", "}\n"], "project": "portreserve", "file": "portreserve.pkl", "function": "fcntl_lock"}, {"comment_all": {"comment": "/* don't call me again */", "depth": 1, "reading_ease": 118.18, "reading_grade": -2.3, "line": 275}, "comment_text": "/* don't call me again */", "comment_tokens": ["do", "n't", "call", "me", "again"], "ccode": ["\n", "static gboolean\n", "start_command_idle(gpointer data)\n", "{\n", "\tTexternalp *ep = data;\n", "\tDEBUG_MSG(\"start_command_idle, ep->pipe_out=%d, ep->channel_out_lcb=%p\\n\",ep->pipe_out,ep->channel_out_lcb);\n", "\tif (ep->pipe_in) {\n", "\t\tDEBUG_MSG(\"start_command_idle, creating channel_in from pipe\\n\");\n", "#ifdef WIN32\n", "\t\tep->channel_in = g_io_channel_win32_new_fd(ep->standard_input);\n", "#else\n", "\t\tep->channel_in = g_io_channel_unix_new(ep->standard_input);\n", "#endif\n", "\t}\n", "\tif (ep->pipe_in) {\n", "\t\tep->refcount++;\n", "\t\tep->buffer_out = ep->buffer_out_position =\n", "\t\t\tdoc_get_chars(ep->bfwin->current_document, ep->begin, ep->end);\n", "\t\tg_io_channel_set_flags(ep->channel_in, G_IO_FLAG_NONBLOCK, NULL);\n", "\t\t/* now we should start writing, correct ? */\n", "\t\tDEBUG_MSG(\"start_command_idle, begin=%d, end=%d, add watch for channel_in\\n\", ep->begin, ep->end);\n", "\t\tg_io_add_watch(ep->channel_in, G_IO_OUT, start_command_write_lcb, ep);\n", "\t}\n", "\tif (ep->pipe_out) {\n", "#ifdef WIN32\n", "\t\tep->channel_out = g_io_channel_win32_new_fd(ep->standard_output);\n", "#else\n", "\t\tep->channel_out = g_io_channel_unix_new(ep->standard_output);\n", "#endif\n", "\t\tDEBUG_MSG(\"start_command_idle, created channel_out from pipe\\n\");\n", "\t}\n", "\tif (ep->channel_out_lcb && ep->pipe_out) {\n", "\t\tep->refcount++;\n", "\t\tg_io_channel_set_flags(ep->channel_out, G_IO_FLAG_NONBLOCK, NULL);\n", "\t\tDEBUG_MSG(\"start_command_idle, add watch for channel_out\\n\");\n", "\t\tg_io_add_watch(ep->channel_out, G_IO_IN | G_IO_PRI | G_IO_ERR | G_IO_HUP, ep->channel_out_lcb,\n", "\t\t\t\t\t   ep->channel_out_data);\n", "\t}\n", "\texternalp_unref(ep);\n", "\tep->start_command_idle_id = 0;\n", "\treturn FALSE;\t\t\t\t/* don't call me again */\n", "}\n"], "project": "bluefish-plugins", "file": "external_commands.pkl", "function": "start_command_idle"}, {"comment_all": {"comment": "/* get the entire property since it is larger than one element long */", "depth": 3, "reading_ease": 67.76, "reading_grade": 6.8, "line": 29}, "comment_text": "/* get the entire property since it is larger than one element long */", "comment_tokens": ["get", "the", "entire", "property", "since", "it", "is", "larger", "than", "one", "element", "long"], "ccode": ["#include \"xproperty.h\"\n", "#include \"docker.h\"\n", "\n", "gboolean xprop_get8(Window window, Atom atom, Atom type, int size,\n", "                    gulong *count, guchar **value)\n", "{\n", "  Atom ret_type;\n", "  int ret_size;\n", "  unsigned long ret_bytes;\n", "  int result;\n", "  unsigned long nelements = *count;\n", "  unsigned long maxread = nelements;\n", "\n", "  *value = NULL;\n", "  \n", "  /* try get the first element */\n", "  result = XGetWindowProperty(display, window, atom, 0l, 1l, False,\n", "                              AnyPropertyType, &ret_type, &ret_size,\n", "                              &nelements, &ret_bytes, value);\n", "  if (! (result == Success && ret_type == type &&\n", "         ret_size == size && nelements > 0)) {\n", "    if (*value) XFree(*value);\n", "    *value = NULL;\n", "    nelements = 0;\n", "  } else {\n", "    /* we didn't the whole property's value, more to get */\n", "    if (! (ret_bytes == 0 || maxread <= nelements)) {\n", "      int remain;\n", "      \n", "      /* get the entire property since it is larger than one element long */\n", "      XFree(*value);\n", "      /*\n", "        the number of longs that need to be retreived to get the property's\n", "        entire value. The last + 1 is the first long that we retrieved above.\n", "      */\n", "      remain = (ret_bytes - 1)/sizeof(long) + 1 + 1;\n", "      /* dont get more than the max */\n", "      if (remain > size/8 * (signed)maxread)\n", "        remain = size/8 * (signed)maxread;\n", "      result = XGetWindowProperty(display, window, atom, 0l, remain,\n", "                                  False, type, &ret_type, &ret_size,\n", "                                  &nelements, &ret_bytes, value);\n", "      /*\n", "       If the property has changed type/size, or has grown since our first\n", "        read of it, then stop here and try again. If it shrank, then this will\n", "        still work.\n", "      */\n", "      if (!(result == Success && ret_type == type &&\n", "            ret_size == size && ret_bytes == 0)) {\n", "        if (*value) XFree(*value);\n", "        xprop_get8(window, atom, type, size, count, value);\n", "      }\n", "    }\n", "  }\n", "\n", "  *count = nelements;\n", "  return *value != NULL;\n", "}\n"], "project": "docker", "file": "xproperty.pkl", "function": "xprop_get8"}, {"comment_all": {"comment": "/* contributed by Daniel F. Fisher */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 7}, "comment_text": "/* contributed by Daniel F. Fisher */", "comment_tokens": ["contributed", "by", "Daniel", "F.", "Fisher"], "ccode": ["/*****************************************************************************/\n", "/*                                                                           */\n", "/* Copyright (c) 1989-2008 Morgan Stanley All rights reserved.*/\n", "/* See .../src/LICENSE for terms of distribution.                           */\n", "/*                                                                           */\n", "/*                                                                           */\n", "/*****************************************************************************/\n", "/* contributed by Daniel F. Fisher */\n", "\n", "/*\n", " * Returns true if test lies in the range from low to high, inclusively. If\n", " * low equals high, test must be the same as this common value. If high is\n", " * less than low, then it is assumed that high has wrapped through a top\n", " * value (ULONG_MAX) and so test must be greater than or equal to low or less\n", " * then or equal to high.  This is implemented by assuming that we are\n", " * dealing with unsigned values.  Then the test range is shift back to zero\n", " * by subtracting low from test and high.  Then is the shifted test value is\n", " * less than or equal to the shifted high value, the betweenness test is\n", " * passed.  Otherwise, it is failed.\n", " */\n", "\n", "/* external function definitions */\n", "int \n", "ulbetween(long unsigned int test, long unsigned int low, long unsigned int high)\n", "{\n", "  if ((test - low) <= (high - low))\n", "    return 1;\n", "  return 0;\n", "}\n"], "project": "aplus-fsf-el", "file": "ulbetween.pkl", "function": "ulbetween"}, {"comment_all": {"comment": "/*****               G Z   E M B E D D I N G   S T R E A M             *****/", "depth": 0, "reading_ease": 104.98, "reading_grade": 2.8, "line": 553}, "comment_text": "/*****               G Z   E M B E D D I N G   S T R E A M             *****/", "comment_tokens": ["G", "Z", "E", "M", "B", "E", "D", "D", "I", "N", "G", "S", "T", "R", "E", "A", "M"], "ccode": ["\n", "\n", "/***************************************************************************/\n", "/***************************************************************************/\n", "/*****                                                                 *****/\n", "/*****               G Z   E M B E D D I N G   S T R E A M             *****/\n", "/*****                                                                 *****/\n", "/***************************************************************************/\n", "/***************************************************************************/\n", "\n", "  static void\n", "  ft_gzip_stream_close( FT_Stream  stream )\n", "  {\n", "    FT_GZipFile  zip    = (FT_GZipFile)stream->descriptor.pointer;\n", "    FT_Memory    memory = stream->memory;\n", "\n", "\n", "    if ( zip )\n", "    {\n", "      /* finalize gzip file descriptor */\n", "      ft_gzip_file_done( zip );\n", "\n", "      FT_FREE( zip );\n", "\n", "      stream->descriptor.pointer = NULL;\n", "    }\n", "\n", "    if ( !stream->read )\n", "      FT_FREE( stream->base );\n", "  }\n"], "project": "freetype2-demos", "file": "ftgzip.pkl", "function": "ft_gzip_stream_close"}, {"comment_all": {"comment": "/* Maarten Boekhold (boekhold@cindy.et.tudelft.nl) oktober 1995 */", "depth": 0, "reading_ease": 52.02, "reading_grade": 6.6, "line": 0}, "comment_text": "/* Maarten Boekhold (boekhold@cindy.et.tudelft.nl) oktober 1995 */", "comment_tokens": ["Maarten", "Boekhold", "(", "boekhold", "@", "cindy.et.tudelft.nl", ")", "oktober", "1995"], "ccode": ["/* Maarten Boekhold (boekhold@cindy.et.tudelft.nl) oktober 1995 */\n", "\n", "#include <sys/types.h>\n", "#include \"dbf.h\"\n", "/*\n", " * routine to change little endian long to host long\n", " */\n", "long get_long(u_char *cp)\n", "{\n", "        long ret;\n", "\n", "        ret = *cp++;\n", "        ret += ((*cp++)<<8);\n", "        ret += ((*cp++)<<16);\n", "        ret += ((*cp++)<<24);\n", "\n", "        return ret;\n", "}\n"], "project": "dbf2mysql", "file": "endian.pkl", "function": "get_long"}, {"comment_all": {"comment": "/* Check the level against the refence verbosity level */", "depth": 1, "reading_ease": 71.82, "reading_grade": 5.2, "line": 209}, "comment_text": "/* Check the level against the refence verbosity level */", "comment_tokens": ["Check", "the", "level", "against", "the", "refence", "verbosity", "level"], "ccode": ["\n", "/*------------------------------------------------------------------*/\n", "\n", "/* ccp4printf\n", "\n", "   This is a wrapper for vprintf\n", "\n", "   If the supplied message is less than or equal to the reference\n", "   verbosity level then the format string and remaining arguments\n", "   are passed to vprintf to be printed on stdout.\n", "   Otherwise nothing is printed.\n", "\n", "   The format string has the same format as the format strings\n", "   passed to printf, with the remaining arguments being the values\n", "   (if any) to be inserted into placeholders in the format string.\n", "\n", "   Returns the number of bytes printed, or zero if no printing was\n", "   performed, or a negative number for an error from vprintf.\n", "*/\n", "int ccp4printf(int level, char *format, ...)\n", "{\n", "  int     nbytes=0;\n", "  va_list args;\n", "\n", "  /* Check the level against the refence verbosity level */\n", "  if (level <= ccp4VerbosityLevel(-1)) { \n", "    /* Use the vprint function to print */\n", "    va_start(args,format);\n", "    nbytes = vprintf(format,args);\n", "    va_end(args);\n", "  }\n", "  /* Return to calling function */\n", "  return nbytes;\n", "}\n"], "project": "libccp4-dev", "file": "ccp4_general.pkl", "function": "ccp4printf"}, {"comment_all": {"comment": "/* Must see what to do with that */", "depth": 6, "reading_ease": 115.13, "reading_grade": -1.2, "line": 366}, "comment_text": "/* Must see what to do with that */", "comment_tokens": ["Must", "see", "what", "to", "do", "with", "that"], "ccode": ["\n", "\n", "\n", "abyss_bool\n", "ConfReadServerFile(const char * const filename,\n", "                   TServer *    const serverP) {\n", "\n", "    struct _TServer * const srvP     = serverP->srvP;\n", "    BIHandler *       const handlerP = srvP->builtinHandlerP;\n", "\n", "    TFile * fileP;\n", "    char z[512];\n", "    char * p;\n", "    unsigned int lineNum;\n", "    TFileStat fs;\n", "\n", "    if (!FileOpen(&fileP, filename, O_RDONLY))\n", "        return FALSE;\n", "\n", "    lineNum = 0;\n", "\n", "    while (ConfReadLine(fileP, z, 512)) {\n", "        ++lineNum;\n", "        p = z;\n", "\n", "        if (ConfNextToken(&p)) {\n", "            const char * const option = ConfGetToken(&p);\n", "            if (option) {\n", "                ConfNextToken(&p);\n", "\n", "                if (xmlrpc_strcaseeq(option, \"port\")) {\n", "                    int32_t n;\n", "                    if (ConfReadInt(p, &n, 1, 65535))\n", "                        srvP->port = n;\n", "                    else\n", "                        TraceExit(\"Invalid port '%s'\", p);\n", "                } else if (xmlrpc_strcaseeq(option, \"serverroot\")) {\n", "                    bool success;\n", "                    chdirx(p, &success);\n", "                    if (!success)\n", "                        TraceExit(\"Invalid server root '%s'\",p);\n", "                } else if (xmlrpc_strcaseeq(option, \"path\")) {\n", "                    if (FileStat(p, &fs))\n", "                        if (fs.st_mode & S_IFDIR) {\n", "                            HandlerSetFilesPath(handlerP, p);\n", "                            continue;\n", "                        }\n", "                    TraceExit(\"Invalid path '%s'\", p);\n", "                } else if (xmlrpc_strcaseeq(option, \"default\")) {\n", "                    const char * filename;\n", "                    \n", "                    while ((filename = ConfGetToken(&p))) {\n", "                        HandlerAddDefaultFN(handlerP, filename);\n", "                        if (!ConfNextToken(&p))\n", "                            break;\n", "                    }\n", "                } else if (xmlrpc_strcaseeq(option, \"keepalive\")) {\n", "                    int32_t n;\n", "                    if (ConfReadInt(p, &n, 1, 65535))\n", "                        srvP->keepalivemaxconn = n;\n", "                    else\n", "                        TraceExit(\"Invalid KeepAlive value '%s'\", p);\n", "                } else if (xmlrpc_strcaseeq(option, \"timeout\")) {\n", "                    int32_t n;\n", "                    if (ConfReadInt(p, &n, 1, 3600)) {\n", "                        srvP->keepalivetimeout = n;\n", "                        /* Must see what to do with that */\n", "                        srvP->timeout = n;\n", "                    } else\n", "                        TraceExit(\"Invalid TimeOut value '%s'\", p);\n", "                } else if (xmlrpc_strcaseeq(option, \"mimetypes\")) {\n", "                    MIMEType * mimeTypeP;\n", "                    readMIMETypesFile(p, &mimeTypeP);\n", "                    if (!mimeTypeP)\n", "                        TraceExit(\"Can't read MIME Types file '%s'\", p);\n", "                    else\n", "                        HandlerSetMimeType(handlerP, mimeTypeP);\n", "                } else if (xmlrpc_strcaseeq(option,\"logfile\")) {\n", "                    srvP->logfilename = strdup(p);\n", "                } else if (xmlrpc_strcaseeq(option,\"user\")) {\n", "                    parseUser(p, srvP);\n", "                } else if (xmlrpc_strcaseeq(option, \"pidfile\")) {\n", "                    parsePidfile(p, srvP);\n", "                } else if (xmlrpc_strcaseeq(option, \"advertiseserver\")) {\n", "                    if (!ConfReadBool(p, &srvP->advertise))\n", "                        TraceExit(\"Invalid boolean value \"\n", "                                  \"for AdvertiseServer option\");\n", "                } else\n", "                    TraceExit(\"Invalid option '%s' at line %u\",\n", "                              option, lineNum);\n", "            }\n", "        }\n", "    }\n", "\n", "    FileClose(fileP);\n", "    return TRUE;\n", "}\n"], "project": "libxmlrpc-c++8v5", "file": "conf.pkl", "function": "ConfReadServerFile"}, {"comment_all": {"comment": "/* Formatted output to strings.\n   Copyright (C) 1999, 2002, 2006, 2009-2019 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, see <https://www.gnu.org/licenses/>.  */*/\n", "depth": 0, "reading_ease": 52.9, "reading_grade": 10.4, "line": 14}, "comment_text": "/* Formatted output to strings.\n   Copyright (C) 1999, 2002, 2006, 2009-2019 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, see <https://www.gnu.org/licenses/>.  */*/\n", "comment_tokens": ["Formatted", "output", "to", "strings", ".", "Copyright", "(", "C", ")", "1999", ",", "2002", ",", "2006", ",", "2009-2019", "Free", "Software", "Foundation", ",", "Inc", ".", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "see", "<", "https", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/* Formatted output to strings.\n", "   Copyright (C) 1999, 2002, 2006, 2009-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License along\n", "   with this program; if not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"vasnprintf.h\"\n", "\n", "#include <stdarg.h>\n", "\n", "char *\n", "asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n", "{\n", "  va_list args;\n", "  char *result;\n", "\n", "  va_start (args, format);\n", "  result = vasnprintf (resultbuf, lengthp, format, args);\n", "  va_end (args);\n", "  return result;\n", "}\n"], "project": "grub-efi", "file": "asnprintf.pkl", "function": "asnprintf"}, {"comment_all": {"comment": "/*\n  Copyright (c) 2007 Stefan Kurtz <kurtz@zbh.uni-hamburg.de>\n  Copyright (c) 2007 Center for Bioinformatics, University of Hamburg\n\n  Permission to use, copy, modify, and distribute this software for any\n  purpose with or without fee is hereby granted, provided that the above\n  copyright notice and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/", "depth": 0, "reading_ease": 39.5, "reading_grade": 15.6, "line": 0}, "comment_text": "/*\n  Copyright (c) 2007 Stefan Kurtz <kurtz@zbh.uni-hamburg.de>\n  Copyright (c) 2007 Center for Bioinformatics, University of Hamburg\n\n  Permission to use, copy, modify, and distribute this software for any\n  purpose with or without fee is hereby granted, provided that the above\n  copyright notice and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/", "comment_tokens": ["Copyright", "(", "c", ")", "2007", "Stefan", "Kurtz", "<", "kurtz", "@", "zbh.uni-hamburg.de", ">", "Copyright", "(", "c", ")", "2007", "Center", "for", "Bioinformatics", ",", "University", "of", "Hamburg", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "and", "distribute", "this", "software", "for", "any", "purpose", "with", "or", "without", "fee", "is", "hereby", "granted", ",", "provided", "that", "the", "above", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "all", "copies", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", "AND", "THE", "AUTHOR", "DISCLAIMS", "ALL", "WARRANTIES", "WITH", "REGARD", "TO", "THIS", "SOFTWARE", "INCLUDING", "ALL", "IMPLIED", "WARRANTIES", "OF", "MERCHANTABILITY", "AND", "FITNESS", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHOR", "BE", "LIABLE", "FOR", "ANY", "SPECIAL", ",", "DIRECT", ",", "INDIRECT", ",", "OR", "CONSEQUENTIAL", "DAMAGES", "OR", "ANY", "DAMAGES", "WHATSOEVER", "RESULTING", "FROM", "LOSS", "OF", "USE", ",", "DATA", "OR", "PROFITS", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "NEGLIGENCE", "OR", "OTHER", "TORTIOUS", "ACTION", ",", "ARISING", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "USE", "OR", "PERFORMANCE", "OF", "THIS", "SOFTWARE", "."], "ccode": ["/*\n", "  Copyright (c) 2007 Stefan Kurtz <kurtz@zbh.uni-hamburg.de>\n", "  Copyright (c) 2007 Center for Bioinformatics, University of Hamburg\n", "\n", "  Permission to use, copy, modify, and distribute this software for any\n", "  purpose with or without fee is hereby granted, provided that the above\n", "  copyright notice and this permission notice appear in all copies.\n", "\n", "  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n", "  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n", "  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n", "  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n", "  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n", "  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n", "  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n", "*/\n", "\n", "#include \"core/error_api.h\"\n", "#include \"match/fmi-mkindex.h\"\n", "#include \"tools/gt_mkfmindex.h\"\n", "\n", "int gt_mkfmindex(int argc, const char **argv, GtError *err)\n", "{\n", "  gt_error_check(err);\n", "  return gt_parseargsandcallmkfmindex(argc, argv, err);\n", "}\n"], "project": "libgenometools0-dev", "file": "gt_mkfmindex.pkl", "function": "gt_mkfmindex"}, {"comment_all": {"comment": "/*\n   This file is part of harvid\n\n   Copyright (C) 2008-2013 Robin Gareus <robin@gareus.org>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */", "depth": 0, "reading_ease": 61.67, "reading_grade": 9.1, "line": 16}, "comment_text": "/*\n   This file is part of harvid\n\n   Copyright (C) 2008-2013 Robin Gareus <robin@gareus.org>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */", "comment_tokens": ["This", "file", "is", "part", "of", "harvid", "Copyright", "(", "C", ")", "2008-2013", "Robin", "Gareus", "<", "robin", "@", "gareus.org", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ".", "If", "not", ",", "see", "<", "http", ":", "www.gnu.orglicenses", ">", "."], "ccode": ["/*\n", "   This file is part of harvid\n", "\n", "   Copyright (C) 2008-2013 Robin Gareus <robin@gareus.org>\n", "\n", "   This program is free software; you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 2, or (at your option)\n", "   any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n", " */\n", "\n", "#include <string.h>\n", "#include \"vinfo.h\"\n", "\n", "void jvi_init (VInfo *ji) {\n", "  memset (ji, 0, sizeof(VInfo));\n", "  memset(&ji->framerate, 0, sizeof(TimecodeRate));\n", "  ji->framerate.num = 25;\n", "  ji->framerate.den = 1;\n", "  ji->out_width = ji->out_height = -1;\n", "  ji->file_frame_offset = 0.0;\n", "}\n"], "project": "harvid", "file": "vinfo.pkl", "function": "jvi_init"}, {"comment_all": {"comment": "/*\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */", "depth": 0, "reading_ease": 58.42, "reading_grade": 10.4, "line": 0}, "comment_text": "/*\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */", "comment_tokens": ["Copyright", "(", "C", ")", "2006", "Andreas", "Granig", "<", "agranig", "@", "linguin.org", ">", "This", "file", "is", "part", "of", "Kamailio", ",", "a", "free", "SIP", "server", ".", "Kamailio", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", "Kamailio", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA"], "ccode": ["/*\n", " * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n", " *\n", " * This file is part of Kamailio, a free SIP server.\n", " *\n", " * Kamailio is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version\n", " *\n", " * Kamailio is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n", " *\n", " */\n", "\n", "#include \"../mem/mem.h\"\n", "#include \"parse_option_tags.h\"\n", "\n", "static inline void free_option_tag(struct option_tag_body **otb)\n", "{\n", "\tif (otb && *otb) {\n", "\t\tpkg_free(*otb);\n", "\t\t*otb = 0;\n", "\t}\n", "}\n"], "project": "kamailio-sqlite-modules", "file": "parse_option_tags.pkl", "function": "free_option_tag"}, {"comment_all": {"comment": "/* From here on, we'll refer to \".\" as our mountpoint, to avoid\n\t * races.\n\t */", "depth": 1, "reading_ease": 99.23, "reading_grade": 0.9, "line": 290}, "comment_text": "/* From here on, we'll refer to \".\" as our mountpoint, to avoid\n\t * races.\n\t */", "comment_tokens": ["From", "here", "on", ",", "we", "'ll", "refer", "to", "``", ".", "''", "as", "our", "mountpoint", ",", "to", "avoid", "races", "."], "ccode": ["\n", "int check_ownership_mnt(uid_t uid, char **mnt) {\n", "/* Check ownership of mount point, chdir into it, and\n", " * canonicalize the path for use in mtab updating.\n", " * Return 0 if everything is in order, 1 on error.\n", " */\n", "\tstruct stat s;\n", "\tchar *cwd;\n", "\n", "\t/* From here on, we'll refer to \".\" as our mountpoint, to avoid\n", "\t * races.\n", "\t */\n", "\tif (chdir(*mnt) != 0) {\n", "\t\tfputs(\"Cannot chdir into mountpoint.\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\tif (stat(\".\", &s) != 0) {\n", "\t\tfputs(\"Cannot examine mountpoint.\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\tif (!S_ISDIR(s.st_mode)) {\n", "\t\tfputs(\"Mountpoint is not a directory.\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\tif (s.st_uid != uid) {\n", "\t\tfputs(\"You do not own that mountpoint.\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\n", "\t/* Canonicalize our pathname based on the current directory to\n", "\t * avoid races.\n", "\t */\n", "\tcwd = getcwd(NULL, 0);\n", "\tif (!cwd) {\n", "\t\tfputs(\"Failed to get current directory\\n\", stderr);\n", "\t\treturn 1;\n", "\t}\n", "\t*mnt = cwd;\n", "\treturn 0;\n", "}\n"], "project": "libecryptfs1", "file": "mount.ecryptfs_private.pkl", "function": "check_ownership_mnt"}, {"comment_all": {"comment": "/* Get the index variable. */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 389}, "comment_text": "/* Get the index variable. */", "comment_tokens": ["Get", "the", "index", "variable", "."], "ccode": ["\n", "\n", "/* get_array_num returns the address of the bc_num in the array\n", "   structure.  If more structure is requried to get to the index,\n", "   this routine does the work to create that structure. VAR_INDEX\n", "   is a zero based index into the arrays storage array. INDEX is\n", "   the index into the bc array. */\n", "\n", "bc_num *\n", "get_array_num (int var_index, unsigned long idx)\n", "{\n", "  bc_var_array *ary_ptr;\n", "  bc_array *a_var;\n", "  bc_array_node *temp;\n", "  int log;\n", "  unsigned int ix, ix1;\n", "  int sub [NODE_DEPTH];\n", "\n", "  /* Get the array entry. */\n", "  ary_ptr = arrays[var_index];\n", "  if (ary_ptr == NULL)\n", "    {\n", "      ary_ptr = arrays[var_index] = bc_malloc (sizeof (bc_var_array));\n", "      ary_ptr->a_value = NULL;\n", "      ary_ptr->a_next = NULL;\n", "      ary_ptr->a_param = FALSE;\n", "    }\n", "\n", "  a_var = ary_ptr->a_value;\n", "  if (a_var == NULL) {\n", "    a_var = ary_ptr->a_value = bc_malloc (sizeof (bc_array));\n", "    a_var->a_tree = NULL;\n", "    a_var->a_depth = 0;\n", "  }\n", "\n", "  /* Get the index variable. */\n", "  sub[0] = idx & NODE_MASK;\n", "  ix = idx >> NODE_SHIFT;\n", "  log = 1;\n", "  while (ix > 0 || log < a_var->a_depth)\n", "    {\n", "      sub[log] = ix & NODE_MASK;\n", "      ix >>= NODE_SHIFT;\n", "      log++;\n", "    }\n", "  \n", "  /* Build any tree that is necessary. */\n", "  while (log > a_var->a_depth)\n", "    {\n", "      temp = bc_malloc (sizeof(bc_array_node));\n", "      if (a_var->a_depth != 0)\n", "\t{\n", "\t  temp->n_items.n_down[0] = a_var->a_tree;\n", "\t  for (ix=1; ix < NODE_SIZE; ix++)\n", "\t    temp->n_items.n_down[ix] = NULL;\n", "\t}\n", "      else\n", "\t{\n", "\t  for (ix=0; ix < NODE_SIZE; ix++)\n", "\t    temp->n_items.n_num[ix] = bc_copy_num(_zero_);\n", "\t}\n", "      a_var->a_tree = temp;\n", "      a_var->a_depth++;\n", "    }\n", "  \n", "  /* Find the indexed variable. */\n", "  temp = a_var->a_tree;\n", "  while ( log-- > 1)\n", "    {\n", "      ix1 = sub[log];\n", "      if (temp->n_items.n_down[ix1] == NULL)\n", "\t{\n", "\t  temp->n_items.n_down[ix1] = bc_malloc (sizeof(bc_array_node));\n", "\t  temp = temp->n_items.n_down[ix1];\n", "\t  if (log > 1)\n", "\t    for (ix=0; ix < NODE_SIZE; ix++)\n", "\t      temp->n_items.n_down[ix] = NULL;\n", "\t  else\n", "\t    for (ix=0; ix < NODE_SIZE; ix++)\n", "\t      temp->n_items.n_num[ix] = bc_copy_num(_zero_);\n", "\t}\n", "      else\n", "\ttemp = temp->n_items.n_down[ix1];\n", "    }\n", "  \n", "  /* Return the address of the indexed variable. */\n", "  return &(temp->n_items.n_num[sub[0]]);\n", "}\n"], "project": "dc", "file": "storage.pkl", "function": "get_array_num"}, {"comment_all": {"comment": "/* Accessor  methods (get/set functions) to struct members. */", "depth": 0, "reading_ease": 38.99, "reading_grade": 9.6, "line": 4016}, "comment_text": "/* Accessor  methods (get/set functions) to struct members. */", "comment_tokens": ["Accessor", "methods", "(", "getset", "functions", ")", "to", "struct", "members", "."], "ccode": ["\twhile ( 0 )\n", "\n", "/* Accessor  methods (get/set functions) to struct members. */\n", "\n", "/** Get the current line number.\n", " * \n", " */\n", "int yyget_lineno  (void)\n", "{\n", "    \n", "    return yylineno;\n", "}\n"], "project": "linux-buildinfo-5.6.0-1007-oem", "file": "lexer.lex.pkl", "function": "yyget_lineno"}, {"comment_all": {"comment": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */", "depth": 0, "reading_ease": 72.12, "reading_grade": 5.1, "line": 3778}, "comment_text": "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n * \n */", "comment_tokens": ["Discard", "all", "buffered", "characters", ".", "On", "the", "next", "scan", ",", "YY_INPUT", "will", "be", "called", ".", "@", "param", "b", "the", "buffer", "state", "to", "be", "flushed", ",", "usually", "@", "c", "YY_CURRENT_BUFFER", "."], "ccode": ["\n", "/** Discard all buffered characters. On the next scan, YY_INPUT will be called.\n", " * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.\n", " * \n", " */\n", "    void yy_flush_buffer (YY_BUFFER_STATE  b )\n", "{\n", "    \tif ( ! b )\n", "\t\treturn;\n", "\n", "\tb->yy_n_chars = 0;\n", "\n", "\t/* We always need two end-of-buffer characters.  The first causes\n", "\t * a transition to the end-of-buffer state.  The second causes\n", "\t * a jam in that state.\n", "\t */\n", "\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n", "\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n", "\n", "\tb->yy_buf_pos = &b->yy_ch_buf[0];\n", "\n", "\tb->yy_at_bol = 1;\n", "\tb->yy_buffer_status = YY_BUFFER_NEW;\n", "\n", "\tif ( b == YY_CURRENT_BUFFER )\n", "\t\tyy_load_buffer_state(  );\n", "}\n"], "project": "linux-cloud-tools-5.8.0-33-generic", "file": "lexer.lex.pkl", "function": "yy_flush_buffer"}, {"comment_all": {"comment": "/*A version of strncasecmp() that is guaranteed to only ignore the case of\n   ASCII characters.*/", "depth": 0, "reading_ease": 64.71, "reading_grade": 8.0, "line": 25}, "comment_text": "/*A version of strncasecmp() that is guaranteed to only ignore the case of\n   ASCII characters.*/", "comment_tokens": ["A", "version", "of", "strncasecmp", "(", ")", "that", "is", "guaranteed", "to", "only", "ignore", "the", "case", "of", "ASCII", "characters", "."], "ccode": ["#endif\n", "\n", "/*A version of strncasecmp() that is guaranteed to only ignore the case of\n", "   ASCII characters.*/\n", "int op_strncasecmp(const char *_a,const char *_b,int _n){\n", "  int i;\n", "  for(i=0;i<_n;i++){\n", "    int a;\n", "    int b;\n", "    int d;\n", "    a=_a[i];\n", "    b=_b[i];\n", "    if(a>='a'&&a<='z')a-='a'-'A';\n", "    if(b>='a'&&b<='z')b-='a'-'A';\n", "    d=a-b;\n", "    if(d)return d;\n", "  }\n", "  return 0;\n", "}\n"], "project": "libopusfile-doc", "file": "internal.pkl", "function": "op_strncasecmp"}, {"comment_all": {"comment": "/* Returns 0 for success, nonzero for failure (in which case bfd_get_error\n   can retrieve the error code).  */", "depth": 0, "reading_ease": 63.7, "reading_grade": 8.4, "line": 302}, "comment_text": "/* Returns 0 for success, nonzero for failure (in which case bfd_get_error\n   can retrieve the error code).  */", "comment_tokens": ["Returns", "0", "for", "success", ",", "nonzero", "for", "failure", "(", "in", "which", "case", "bfd_get_error", "can", "retrieve", "the", "error", "code", ")", "."], "ccode": ["\n", "/* Returns 0 for success, nonzero for failure (in which case bfd_get_error\n", "   can retrieve the error code).  */\n", "\n", "int\n", "bfd_seek (bfd *abfd, file_ptr position, int direction)\n", "{\n", "  int result;\n", "  ufile_ptr offset = 0;\n", "\n", "  while (abfd->my_archive != NULL\n", "\t && !bfd_is_thin_archive (abfd->my_archive))\n", "    {\n", "      offset += abfd->origin;\n", "      abfd = abfd->my_archive;\n", "    }\n", "\n", "  if (abfd->iovec == NULL)\n", "    {\n", "      bfd_set_error (bfd_error_invalid_operation);\n", "      return -1;\n", "    }\n", "\n", "  /* For the time being, a BFD may not seek to it's end.  The problem\n", "     is that we don't easily have a way to recognize the end of an\n", "     element in an archive.  */\n", "  BFD_ASSERT (direction == SEEK_SET || direction == SEEK_CUR);\n", "\n", "  if (direction != SEEK_CUR)\n", "    position += offset;\n", "\n", "  if ((direction == SEEK_CUR && position == 0)\n", "      || (direction == SEEK_SET && (ufile_ptr) position == abfd->where))\n", "    return 0;\n", "\n", "  result = abfd->iovec->bseek (abfd, position, direction);\n", "  if (result != 0)\n", "    {\n", "      /* An EINVAL error probably means that the file offset was\n", "\t absurd.  */\n", "      if (errno == EINVAL)\n", "\tbfd_set_error (bfd_error_file_truncated);\n", "      else\n", "\tbfd_set_error (bfd_error_system_call);\n", "    }\n", "  else\n", "    {\n", "      /* Adjust `where' field.  */\n", "      if (direction == SEEK_CUR)\n", "\tabfd->where += position;\n", "      else\n", "\tabfd->where = position;\n", "    }\n", "\n", "  return result;\n", "}\n"], "project": "binutils-ia64-linux-gnu-dbg", "file": "bfdio.pkl", "function": "bfd_seek"}, {"comment_all": {"comment": "/*\n\t * Copy zero into is_zeroed_trail and pass the copy when allocating the\n\t * extent, so that it is possible to make correct junk/zero fill\n\t * decisions below, even if is_zeroed_trail ends up true when zero is\n\t * false.\n\t */", "depth": 1, "reading_ease": 45.43, "reading_grade": 15.4, "line": 144}, "comment_text": "/*\n\t * Copy zero into is_zeroed_trail and pass the copy when allocating the\n\t * extent, so that it is possible to make correct junk/zero fill\n\t * decisions below, even if is_zeroed_trail ends up true when zero is\n\t * false.\n\t */", "comment_tokens": ["Copy", "zero", "into", "is_zeroed_trail", "and", "pass", "the", "copy", "when", "allocating", "the", "extent", ",", "so", "that", "it", "is", "possible", "to", "make", "correct", "junkzero", "fill", "decisions", "below", ",", "even", "if", "is_zeroed_trail", "ends", "up", "true", "when", "zero", "is", "false", "."], "ccode": ["\n", "static bool\n", "large_ralloc_no_move_expand(tsdn_t *tsdn, extent_t *extent, size_t usize,\n", "    bool zero) {\n", "\tarena_t *arena = extent_arena_get(extent);\n", "\tsize_t oldusize = extent_usize_get(extent);\n", "\textent_hooks_t *extent_hooks = extent_hooks_get(arena);\n", "\tsize_t trailsize = usize - oldusize;\n", "\n", "\tif (extent_hooks->merge == NULL) {\n", "\t\treturn true;\n", "\t}\n", "\n", "\tif (config_fill && unlikely(opt_zero)) {\n", "\t\tzero = true;\n", "\t}\n", "\t/*\n", "\t * Copy zero into is_zeroed_trail and pass the copy when allocating the\n", "\t * extent, so that it is possible to make correct junk/zero fill\n", "\t * decisions below, even if is_zeroed_trail ends up true when zero is\n", "\t * false.\n", "\t */\n", "\tbool is_zeroed_trail = zero;\n", "\tbool commit = true;\n", "\textent_t *trail;\n", "\tbool new_mapping;\n", "\tif ((trail = extents_alloc(tsdn, arena, &extent_hooks,\n", "\t    &arena->extents_dirty, extent_past_get(extent), trailsize, 0,\n", "\t    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL\n", "\t    || (trail = extents_alloc(tsdn, arena, &extent_hooks,\n", "\t    &arena->extents_muzzy, extent_past_get(extent), trailsize, 0,\n", "\t    CACHELINE, false, SC_NSIZES, &is_zeroed_trail, &commit)) != NULL) {\n", "\t\tif (config_stats) {\n", "\t\t\tnew_mapping = false;\n", "\t\t}\n", "\t} else {\n", "\t\tif ((trail = extent_alloc_wrapper(tsdn, arena, &extent_hooks,\n", "\t\t    extent_past_get(extent), trailsize, 0, CACHELINE, false,\n", "\t\t    SC_NSIZES, &is_zeroed_trail, &commit)) == NULL) {\n", "\t\t\treturn true;\n", "\t\t}\n", "\t\tif (config_stats) {\n", "\t\t\tnew_mapping = true;\n", "\t\t}\n", "\t}\n", "\n", "\tif (extent_merge_wrapper(tsdn, arena, &extent_hooks, extent, trail)) {\n", "\t\textent_dalloc_wrapper(tsdn, arena, &extent_hooks, trail);\n", "\t\treturn true;\n", "\t}\n", "\trtree_ctx_t rtree_ctx_fallback;\n", "\trtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);\n", "\tszind_t szind = sz_size2index(usize);\n", "\textent_szind_set(extent, szind);\n", "\trtree_szind_slab_update(tsdn, &extents_rtree, rtree_ctx,\n", "\t    (uintptr_t)extent_addr_get(extent), szind, false);\n", "\n", "\tif (config_stats && new_mapping) {\n", "\t\tarena_stats_mapped_add(tsdn, &arena->stats, trailsize);\n", "\t}\n", "\n", "\tif (zero) {\n", "\t\tif (config_cache_oblivious) {\n", "\t\t\t/*\n", "\t\t\t * Zero the trailing bytes of the original allocation's\n", "\t\t\t * last page, since they are in an indeterminate state.\n", "\t\t\t * There will always be trailing bytes, because ptr's\n", "\t\t\t * offset from the beginning of the extent is a multiple\n", "\t\t\t * of CACHELINE in [0 .. PAGE).\n", "\t\t\t */\n", "\t\t\tvoid *zbase = (void *)\n", "\t\t\t    ((uintptr_t)extent_addr_get(extent) + oldusize);\n", "\t\t\tvoid *zpast = PAGE_ADDR2BASE((void *)((uintptr_t)zbase +\n", "\t\t\t    PAGE));\n", "\t\t\tsize_t nzero = (uintptr_t)zpast - (uintptr_t)zbase;\n", "\t\t\tassert(nzero > 0);\n", "\t\t\tmemset(zbase, 0, nzero);\n", "\t\t}\n", "\t\tassert(is_zeroed_trail);\n", "\t} else if (config_fill && unlikely(opt_junk_alloc)) {\n", "\t\tmemset((void *)((uintptr_t)extent_addr_get(extent) + oldusize),\n", "\t\t    JEMALLOC_ALLOC_JUNK, usize - oldusize);\n", "\t}\n", "\n", "\tarena_extent_ralloc_large_expand(tsdn, arena, extent, oldusize);\n", "\n", "\treturn false;\n", "}\n"], "project": "libjemalloc-dev", "file": "large.pkl", "function": "large_ralloc_no_move_expand"}, {"comment_all": {"comment": "/****************************************************************************\n *\n * ftpfr.c\n *\n *   FreeType API for accessing PFR-specific data (body).\n *\n * Copyright (C) 2002-2019 by\n * David Turner, Robert Wilhelm, and Werner Lemberg.\n *\n * This file is part of the FreeType project, and may only be used,\n * modified, and distributed under the terms of the FreeType project\n * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n * this file you indicate that you have read the license and\n * understand and accept it fully.\n *\n */", "depth": 0, "reading_ease": 62.88, "reading_grade": 8.7, "line": 0}, "comment_text": "/****************************************************************************\n *\n * ftpfr.c\n *\n *   FreeType API for accessing PFR-specific data (body).\n *\n * Copyright (C) 2002-2019 by\n * David Turner, Robert Wilhelm, and Werner Lemberg.\n *\n * This file is part of the FreeType project, and may only be used,\n * modified, and distributed under the terms of the FreeType project\n * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n * this file you indicate that you have read the license and\n * understand and accept it fully.\n *\n */", "comment_tokens": ["ftpfr.c", "FreeType", "API", "for", "accessing", "PFR-specific", "data", "(", "body", ")", ".", "Copyright", "(", "C", ")", "2002-2019", "by", "David", "Turner", ",", "Robert", "Wilhelm", ",", "and", "Werner", "Lemberg", ".", "This", "file", "is", "part", "of", "the", "FreeType", "project", ",", "and", "may", "only", "be", "used", ",", "modified", ",", "and", "distributed", "under", "the", "terms", "of", "the", "FreeType", "project", "license", ",", "LICENSE.TXT", ".", "By", "continuing", "to", "use", ",", "modify", ",", "or", "distribute", "this", "file", "you", "indicate", "that", "you", "have", "read", "the", "license", "and", "understand", "and", "accept", "it", "fully", "."], "ccode": ["/****************************************************************************\n", " *\n", " * ftpfr.c\n", " *\n", " *   FreeType API for accessing PFR-specific data (body).\n", " *\n", " * Copyright (C) 2002-2019 by\n", " * David Turner, Robert Wilhelm, and Werner Lemberg.\n", " *\n", " * This file is part of the FreeType project, and may only be used,\n", " * modified, and distributed under the terms of the FreeType project\n", " * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n", " * this file you indicate that you have read the license and\n", " * understand and accept it fully.\n", " *\n", " */\n", "\n", "#include <ft2build.h>\n", "#include FT_INTERNAL_DEBUG_H\n", "\n", "#include FT_INTERNAL_OBJECTS_H\n", "#include FT_SERVICE_PFR_H\n", "\n", "\n", "  /* check the format */\n", "  static FT_Service_PfrMetrics\n", "  ft_pfr_check( FT_Face  face )\n", "  {\n", "    FT_Service_PfrMetrics  service = NULL;\n", "\n", "\n", "    if ( face )\n", "      FT_FACE_LOOKUP_SERVICE( face, service, PFR_METRICS );\n", "\n", "    return service;\n", "  }\n"], "project": "freetype2-demos", "file": "ftpfr.pkl", "function": "ft_pfr_check"}, {"comment_all": {"comment": "/*\n * Copyright (c) 1997,2008 Andrew G. Morgan  <morgan@kernel.org>\n *\n * This displays the capabilities of given target process(es).\n */", "depth": 0, "reading_ease": 38.48, "reading_grade": 9.8, "line": 0}, "comment_text": "/*\n * Copyright (c) 1997,2008 Andrew G. Morgan  <morgan@kernel.org>\n *\n * This displays the capabilities of given target process(es).\n */", "comment_tokens": ["Copyright", "(", "c", ")", "1997,2008", "Andrew", "G.", "Morgan", "<", "morgan", "@", "kernel.org", ">", "This", "displays", "the", "capabilities", "of", "given", "target", "process", "(", "es", ")", "."], "ccode": ["/*\n", " * Copyright (c) 1997,2008 Andrew G. Morgan  <morgan@kernel.org>\n", " *\n", " * This displays the capabilities of given target process(es).\n", " */\n", "\n", "#include <sys/types.h>\n", "#include <errno.h>\n", "#include <stdio.h>\n", "#include <string.h>\n", "#include <stdlib.h>\n", "#include <sys/capability.h>\n", "\n", "static void usage(int exiter)\n", "{\n", "    fprintf(stderr,\n", "\"usage: getcaps <pid> [<pid> ...]\\n\\n\"\n", "\"  This program displays the capabilities on the queried process(es).\\n\"\n", "\"  The capabilities are displayed in the cap_from_text(3) format.\\n\\n\"\n", "\"  Optional arguments:\\n\"\n", "\"     --help or --usage     display this message.\\n\"\n", "\"     --verbose             use a more verbose output format.\\n\"\n", "\"     --ugly or --legacy    use the archaic legacy output format.\\n\\n\"\n", "\"[Copyright (c) 1997-8,2007,2019 Andrew G. Morgan  <morgan@kernel.org>]\\n\"\n", "\t);\n", "    exit(exiter);\n", "}\n"], "project": "libpam-cap", "file": "getpcaps.pkl", "function": "usage"}, {"comment_all": {"comment": "/* check if timer is running */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 136}, "comment_text": "/* check if timer is running */", "comment_tokens": ["check", "if", "timer", "is", "running"], "ccode": ["\n", "int tty_running(tno)\n", "int tno;\n", "{\n", "  /* check if timer is running */\n", "  if (timer[tno] == (time_t) 0)\n", "    return 0;\n", "  else\n", "    return 1;\n", "}\n"], "project": "ifmail", "file": "ttyio.pkl", "function": "tty_running"}, {"comment_all": {"comment": "/* Compute number of bytes mod 64 */", "depth": 1, "reading_ease": 90.77, "reading_grade": 2.1, "line": 114}, "comment_text": "/* Compute number of bytes mod 64 */", "comment_tokens": ["Compute", "number", "of", "bytes", "mod", "64"], "ccode": ["\n", "/* MD5 block update operation. Continues an MD5 message-digest\n", "   operation, processing another message block, and updating the\n", "   context.\n", "*/\n", "\n", "void MD5Update (MD5_CTX *context, unsigned char *input, \n", "\t\tunsigned int inputLen)\n", "{\n", "    unsigned int i, index, partLen;\n", "\n", "    /* Compute number of bytes mod 64 */\n", "    index = (unsigned int)((context->count[0] >> 3) & 0x3F);\n", "\n", "    /* Update number of bits */\n", "    if ((context->count[0] += ((UINT4)inputLen << 3))\n", "\t< ((UINT4)inputLen << 3)) {\n", "\tcontext->count[1]++;\n", "    }\n", "    context->count[1] += ((UINT4)inputLen >> 29);\n", "\n", "    partLen = 64 - index;\n", "\n", "    /* Transform as many times as possible */\n", "    if (inputLen >= partLen) {\n", "\tmemcpy(&context->buffer[index], input, partLen);\n", "\tMD5Transform(context->state, context->buffer);\n", "\n", "\tfor (i = partLen; i + 63 < inputLen; i += 64) {\n", "\t    MD5Transform (context->state, &input[i]);\n", "\t}\n", "\n", "\tindex = 0;\n", "    } else {\n", "\ti = 0;\n", "    }\n", "\n", "    /* Buffer remaining input */\n", "    memcpy(&context->buffer[index], &input[i], inputLen-i);\n", "}\n"], "project": "gretl-doc", "file": "md5c.pkl", "function": "MD5Update"}, {"comment_all": {"comment": "/*------------------------------------------------------------------------\n |\n |  NAME          msgGetName\n |\n |  FUNCTION      Return the name of this program.\n |\n |  SYNOPSIS      #include \"shhmsg.h\"\n |                char *msgGetName(void);\n |\n |  RETURNS       Pointer to the name of this program, without any path.\n |\n |  DESCRIPTION   The name depends on the string passed to msgSetName().\n */", "depth": 0, "reading_ease": 71.0, "reading_grade": 5.5, "line": 53}, "comment_text": "/*------------------------------------------------------------------------\n |\n |  NAME          msgGetName\n |\n |  FUNCTION      Return the name of this program.\n |\n |  SYNOPSIS      #include \"shhmsg.h\"\n |                char *msgGetName(void);\n |\n |  RETURNS       Pointer to the name of this program, without any path.\n |\n |  DESCRIPTION   The name depends on the string passed to msgSetName().\n */", "comment_tokens": ["--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "--", "|", "|", "NAME", "msgGetName", "|", "|", "FUNCTION", "Return", "the", "name", "of", "this", "program", ".", "|", "|", "SYNOPSIS", "#", "include", "``", "shhmsg.h", "''", "|", "char", "msgGetName", "(", "void", ")", ";", "|", "|", "RETURNS", "Pointer", "to", "the", "name", "of", "this", "program", ",", "without", "any", "path", ".", "|", "|", "DESCRIPTION", "The", "name", "depends", "on", "the", "string", "passed", "to", "msgSetName", "(", ")", "."], "ccode": ["\n", "/*------------------------------------------------------------------------\n", " |\n", " |  NAME          msgGetName\n", " |\n", " |  FUNCTION      Return the name of this program.\n", " |\n", " |  SYNOPSIS      #include \"shhmsg.h\"\n", " |                char *msgGetName(void);\n", " |\n", " |  RETURNS       Pointer to the name of this program, without any path.\n", " |\n", " |  DESCRIPTION   The name depends on the string passed to msgSetName().\n", " */\n", "char *\n", "msgGetName(void)\n", "{\n", "    char *ret;\n", "\n", "  #ifdef __MSDOS__\n", "    static char name[15];\n", "    #define PATHSEP '\\\\'\n", "  #else\n", "    #define PATHSEP '/'\n", "  #endif\n", "\n", "    if (!Argv0)\n", "        return(\"!!!\");\n", "\n", "  #ifdef __MSDOS__\n", "    if ((ret = strrchr(Argv0, PATHSEP)) == NULL)\n", "        ret = Argv0;\n", "    else\n", "        ++ret;\n", "    strcpy(name, ret);\n", "    if ((ret = strchr(name, '.')) != NULL)\n", "        *ret = '\\0';\n", "    strlwr(name);\n", "    ret = name;\n", "\n", "  #else\n", "    if ((ret = strrchr(Argv0, PATHSEP)) == NULL)\n", "        ret = Argv0;\n", "    else\n", "        ++ret;\n", "  #endif\n", "\n", "    return ret;\n", "}\n"], "project": "libshhmsg1", "file": "progname.pkl", "function": "msgGetName"}, {"comment_all": {"comment": "/* Now start chopping up the picture and sending it over. */", "depth": 1, "reading_ease": 86.71, "reading_grade": 3.7, "line": 90}, "comment_text": "/* Now start chopping up the picture and sending it over. */", "comment_tokens": ["Now", "start", "chopping", "up", "the", "picture", "and", "sending", "it", "over", "."], "ccode": ["/**********************************************************************\n", "*       Minolta Dimage V digital camera communication library         *\n", "*               Copyright 2000,2001 Gus Hartmann                      *\n", "*                                                                     *\n", "*    This program is free software; you can redistribute it and/or    *\n", "*    modify it under the terms of the GNU General Public License as   *\n", "*    published by the Free Software Foundation; either version 2 of   *\n", "*    the License, or (at your option) any later version.              *\n", "*                                                                     *\n", "*    This program is distributed in the hope that it will be useful,  *\n", "*    but WITHOUT ANY WARRANTY; without even the implied warranty of   *\n", "*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    *\n", "*    GNU General Public License for more details.                     *\n", "*                                                                     *\n", "*    You should have received a copy of the GNU General Public        *\n", "*    License along with this program; if not, write to the            *\n", "*    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n", "*    Boston, MA  02110-1301  USA\n", "*                                                                     *\n", "**********************************************************************/\n", "\n", "/* $Id$ */\n", "\n", "#include \"config.h\"\n", "\n", "#include \"dimagev.h\"\n", "\n", "#define GP_MODULE \"dimagev\"\n", "\n", "int dimagev_put_file(dimagev_t* dimagev, CameraFile *file) {\n", "\tunsigned char total_packets= (unsigned char) 0, sent_packets= (unsigned char) 0;\n", "\tint left_to_send=0;\n", "\tconst char *data;\n", "\tunsigned long int size;\n", "\n", "\tdimagev_packet *p;\n", "\tunsigned char char_buffer, command_buffer[3], *packet_buffer;\n", "\n", "\tif ( dimagev == NULL ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::null camera device\");\n", "\t\treturn GP_ERROR_BAD_PARAMETERS;\n", "\t}\n", "\n", "\tif ( dimagev->data->host_mode != (unsigned char) 1 ) {\n", "\n", "\t\tdimagev->data->host_mode = (unsigned char) 1;\n", "\n", "\t\tif ( dimagev_send_data(dimagev) < GP_OK ) {\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::unable to set host mode\");\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\t}\n", "\t}\n", "\n", "\tgp_file_get_data_and_size (file, &data, &size);\n", "\n", "\t/* First make the command packet. */\n", "\tcommand_buffer[0] = 0x0e;\n", "\tif ( ( p = dimagev_make_packet(command_buffer, 1, 0) ) == NULL ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::unable to allocate command packet\");\n", "\t\treturn GP_ERROR_NO_MEMORY;\n", "\t}\n", "\n", "\tif ( gp_port_write(dimagev->dev, (char *)p->buffer, p->length) < GP_OK ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::unable to send command packet\");\n", "\t\tfree(p);\n", "\t\treturn GP_ERROR_IO;\n", "\t} else if ( gp_port_read(dimagev->dev, (char *)&char_buffer, 1) < GP_OK ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::no response from camera\");\n", "\t\tfree(p);\n", "\t\treturn GP_ERROR_IO;\n", "\t}\n", "\t\t\n", "\tfree(p);\n", "\n", "\tswitch ( char_buffer ) {\n", "\t\tcase DIMAGEV_ACK:\n", "\t\t\tbreak;\n", "\t\tcase DIMAGEV_NAK:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera did not acknowledge transmission\");\n", "\t\t\t/* Since we haven't sent anything, keep trying until we get a cancel. */\n", "\t\t\treturn dimagev_put_file(dimagev, file);\n", "/*\t\t\treturn GP_ERROR_IO;*/\n", "\t\tcase DIMAGEV_CAN:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera cancels transmission\");\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\tdefault:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera responded with unknown value %x\", char_buffer);\n", "\t\t\treturn GP_ERROR_IO;\n", "\t}\n", "\n", "\t/* Now start chopping up the picture and sending it over. */\n", "\n", "\ttotal_packets = ( size / 993 ) +1;\n", "\n", "\t/* The first packet is a special case. */\n", "\tif ( ( packet_buffer = malloc((size_t)993)) == NULL ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::unable to allocate packet buffer\");\n", "\t\treturn GP_ERROR_NO_MEMORY;\n", "\t}\n", "\n", "\tpacket_buffer[0]= total_packets;\n", "\tmemcpy(&(packet_buffer[1]), data, (size_t) 992);\n", "\n", "\tif ( ( p = dimagev_make_packet(packet_buffer, 993, 0) ) == NULL ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::unable to allocate command packet\");\n", "\t\tfree(packet_buffer);\n", "\t\treturn GP_ERROR_NO_MEMORY;\n", "\t}\n", "\n", "\tfree(packet_buffer);\n", "\n", "\tif ( gp_port_write(dimagev->dev, (char *)p->buffer, p->length) < GP_OK ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::unable to send data packet\");\n", "\t\tfree(p);\n", "\t\treturn GP_ERROR_IO;\n", "\t} else if ( gp_port_read(dimagev->dev, (char *)&char_buffer, 1) < GP_OK ) {\n", "\t\tGP_DEBUG( \"dimagev_put_file::no response from camera\");\n", "\t\tfree(p);\n", "\t\treturn GP_ERROR_IO;\n", "\t}\n", "\t\t\n", "\tfree(p);\n", "\n", "\tswitch ( char_buffer ) {\n", "\t\tcase DIMAGEV_ACK:\n", "\t\t\tbreak;\n", "\t\tcase DIMAGEV_NAK:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera did not acknowledge transmission\");\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\tcase DIMAGEV_CAN:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera cancels transmission\");\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\tdefault:\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::camera responded with unknown value %x\", char_buffer);\n", "\t\t\treturn GP_ERROR_IO;\n", "\t}\n", "\n", "\tleft_to_send = ( size - 992 );\n", "\n", "\tfor ( sent_packets = (unsigned char) 1 ; sent_packets < total_packets ; sent_packets++ ) {\n", "\t\tif ( left_to_send > 993 ) {\n", "\t\t\tif ( ( p = dimagev_make_packet((unsigned char *)&(data[(sent_packets * 993) - 1]),\n", "\t\t\t\t\t\t       993, sent_packets) ) == NULL ) {\n", "\t\t\t\tGP_DEBUG( \"dimagev_put_file::unable to allocate data packet\");\n", "\t\t\t\tfree(p);\n", "\t\t\t\treturn GP_ERROR_NO_MEMORY;\n", "\t\t\t}\n", "\t\t\tleft_to_send-=993;\n", "\t\t} else {\n", "\t\t\tif ( ( p = dimagev_make_packet((unsigned char *)&(data[((sent_packets * 993) - 1)]),\n", "\t\t\t\t\t\t       left_to_send, sent_packets) ) == NULL ) {\n", "\t\t\t\tGP_DEBUG( \"dimagev_put_file::unable to allocate data packet\");\n", "\t\t\t\treturn GP_ERROR_NO_MEMORY;\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\tif ( gp_port_write(dimagev->dev, (char *)p->buffer, p->length) < GP_OK ) {\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::unable to send data packet\");\n", "\t\t\tfree(p);\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\t} else if ( gp_port_read(dimagev->dev, (char *)&char_buffer, 1) < GP_OK ) {\n", "\t\t\tGP_DEBUG( \"dimagev_put_file::no response from camera\");\n", "\t\t\tfree(p);\n", "\t\t\treturn GP_ERROR_IO;\n", "\t\t}\n", "\t\t\t\n", "\t\tfree(p);\n", "\n", "\t\tswitch ( char_buffer ) {\n", "\t\t\tcase DIMAGEV_ACK:\n", "\t\t\t\tbreak;\n", "\t\t\tcase DIMAGEV_NAK:\n", "\t\t\t\tGP_DEBUG( \"dimagev_put_file::camera did not acknowledge transmission\");\n", "\t\t\t\treturn GP_ERROR_IO;\n", "\t\t\tcase DIMAGEV_CAN:\n", "\t\t\t\tGP_DEBUG( \"dimagev_put_file::camera cancels transmission\");\n", "\t\t\t\treturn GP_ERROR_IO;\n", "\t\t\tdefault:\n", "\t\t\t\tGP_DEBUG( \"dimagev_put_file::camera responded with unknown value %x\", char_buffer);\n", "\t\t\t\treturn GP_ERROR_IO;\n", "\t\t}\n", "\t}\n", "\n", "\n", "\n", "\treturn GP_OK;\n", "}\n"], "project": "libgphoto2-l10n", "file": "upload.pkl", "function": "dimagev_put_file"}, {"comment_all": {"comment": "/*\n**  Convert local time (seconds since epoch) to GMT.\n*/", "depth": 0, "reading_ease": 80.28, "reading_grade": 4.1, "line": 239}, "comment_text": "/*\n**  Convert local time (seconds since epoch) to GMT.\n*/", "comment_tokens": ["Convert", "local", "time", "(", "seconds", "since", "epoch", ")", "to", "GMT", "."], "ccode": ["\n", "\n", "/*\n", "**  Convert local time (seconds since epoch) to GMT.\n", "*/\n", "long\n", "LOCALtoGMT(t)\n", "    long\tt;\n", "{\n", "    TIMEINFO\tNow;\n", "\n", "    (void)GetTimeInfo(&Now);\n", "    t += Now.tzone * 60;\n", "    return t;\n", "}\n"], "project": "inn", "file": "misc.pkl", "function": "LOCALtoGMT"}, {"comment_all": {"comment": "/*\n\t\t* Run the actual software blitter \n\t\t*/", "depth": 2, "reading_ease": 49.48, "reading_grade": 7.6, "line": 387}, "comment_text": "/*\n\t\t* Run the actual software blitter \n\t\t*/", "comment_tokens": ["Run", "the", "actual", "software", "blitter"], "ccode": ["\n", "/*!\n", "\\brief Internal blitter setup wrapper for RGBA->RGBA blits.\n", "\n", "Sets up the blitter info based on the 'src' and 'dst' surfaces and rectangles.\n", "\n", "\\param src The source surface.\n", "\\param srcrect The source rectangle.\n", "\\param dst The destination surface.\n", "\\param dstrect The destination rectangle.\n", "\n", "\\returns Returns 1 if blit was performed, 0 otherwise.\n", "*/\n", "int _SDL_gfxBlitRGBACall(SDL_Surface * src, SDL_Rect * srcrect, SDL_Surface * dst, SDL_Rect * dstrect)\n", "{\n", "\t/*\n", "\t* Set up source and destination buffer pointers, then blit \n", "\t*/\n", "\tif (srcrect->w && srcrect->h) {\n", "\t\tSDL_gfxBlitInfo info;\n", "\n", "\t\t/*\n", "\t\t* Set up the blit information \n", "\t\t*/\n", "#if (SDL_MINOR_VERSION == 3)\n", "\t\tinfo.s_pixels = (Uint8 *) src->pixels               + (Uint16) srcrect->y * src->pitch + (Uint16) srcrect->x * src->format->BytesPerPixel;\n", "#else\n", "\t\tinfo.s_pixels = (Uint8 *) src->pixels + src->offset + (Uint16) srcrect->y * src->pitch + (Uint16) srcrect->x * src->format->BytesPerPixel;\n", "#endif\n", "\t\tinfo.s_width = srcrect->w;\n", "\t\tinfo.s_height = srcrect->h;\n", "\t\tinfo.s_skip = (int)(src->pitch - info.s_width * src->format->BytesPerPixel);\n", "#if (SDL_MINOR_VERSION == 3)\n", "\t\tinfo.d_pixels = (Uint8 *) dst->pixels               + (Uint16) dstrect->y * dst->pitch + (Uint16) dstrect->x * dst->format->BytesPerPixel;\n", "#else\n", "\t\tinfo.d_pixels = (Uint8 *) dst->pixels + dst->offset + (Uint16) dstrect->y * dst->pitch + (Uint16) dstrect->x * dst->format->BytesPerPixel;\n", "#endif\n", "\t\tinfo.d_width = dstrect->w;\n", "\t\tinfo.d_height = dstrect->h;\n", "\t\tinfo.d_skip = (int)(dst->pitch - info.d_width * dst->format->BytesPerPixel);\n", "\t\tinfo.aux_data = NULL;\n", "\t\tinfo.src = src->format;\n", "\t\tinfo.table = NULL;\n", "\t\tinfo.dst = dst->format;\n", "\n", "\t\t/*\n", "\t\t* Run the actual software blitter \n", "\t\t*/\n", "\t\t_SDL_gfxBlitBlitterRGBA(&info);\n", "\t\treturn 1;\n", "\t}\n", "\n", "\treturn (0);\n", "}\n"], "project": "libsdl-gfx1.2-5", "file": "SDL_gfxBlitFunc.pkl", "function": "_SDL_gfxBlitRGBACall"}, {"comment_all": {"comment": "/* descriptor format */", "depth": 2, "reading_ease": -6.7, "reading_grade": 14.7, "line": 1157}, "comment_text": "/* descriptor format */\n/* find block command descriptor */\n", "comment_tokens": ["descriptor", "format", "find", "block", "command", "descriptor"], "ccode": ["\n", "static bool\n", "has_blk_ili(uint8_t * sensep, int sb_len)\n", "{\n", "    int resp_code;\n", "    const uint8_t * cup;\n", "\n", "    if (sb_len < 8)\n", "        return false;\n", "    resp_code = (0x7f & sensep[0]);\n", "    if (resp_code >= 0x72) { /* descriptor format */\n", "        /* find block command descriptor */\n", "        if ((cup = sg_scsi_sense_desc_find(sensep, sb_len, 0x5)))\n", "            return (cup[3] & 0x20);\n", "    } else /* fixed */\n", "        return (sensep[2] & 0x20);\n", "    return false;\n", "}\n"], "project": "sg3-utils-udev", "file": "sg_cmds_extra.pkl", "function": "has_blk_ili"}, {"comment_all": {"comment": "/* ==> Do not modify this file!!  It is created automatically\n   from fsf_callg_bl.m using the gen-c-prog.awk script.  <== */", "depth": 0, "reading_ease": 41.02, "reading_grade": 8.8, "line": 0}, "comment_text": "/* ==> Do not modify this file!!  It is created automatically\n   from fsf_callg_bl.m using the gen-c-prog.awk script.  <== */", "comment_tokens": ["==", ">", "Do", "not", "modify", "this", "file", "!", "!", "It", "is", "created", "automatically", "from", "fsf_callg_bl.m", "using", "the", "gen-c-prog.awk", "script", ".", "<", "=="], "ccode": ["/* ==> Do not modify this file!!  It is created automatically\n", "   from fsf_callg_bl.m using the gen-c-prog.awk script.  <== */\n", "\n", "#include <stdio.h>\n", "#include \"ansidecl.h\"\n", "\n", "void  fsf_callg_blurb (FILE *);\n", "void\n", "fsf_callg_blurb (FILE *file)\n", "{\n", "  fputs (\"\\n\", file);\n", "  fputs (\" This table describes the call tree of the program, and was sorted by\\n\", file);\n", "  fputs (\" the total amount of time spent in each function and its children.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\" Each entry in this table consists of several lines.  The line with the\\n\", file);\n", "  fputs (\" index number at the left hand margin lists the current function.\\n\", file);\n", "  fputs (\" The lines above it list the functions that called this function,\\n\", file);\n", "  fputs (\" and the lines below it list the functions this one called.\\n\", file);\n", "  fputs (\" This line lists:\\n\", file);\n", "  fputs (\"     index\tA unique number given to each element of the table.\\n\", file);\n", "  fputs (\"\t\tIndex numbers are sorted numerically.\\n\", file);\n", "  fputs (\"\t\tThe index number is printed next to every function name so\\n\", file);\n", "  fputs (\"\t\tit is easier to look up where the function is in the table.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     % time\tThis is the percentage of the `total' time that was spent\\n\", file);\n", "  fputs (\"\t\tin this function and its children.  Note that due to\\n\", file);\n", "  fputs (\"\t\tdifferent viewpoints, functions excluded by options, etc,\\n\", file);\n", "  fputs (\"\t\tthese numbers will NOT add up to 100%.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     self\tThis is the total amount of time spent in this function.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     children\tThis is the total amount of time propagated into this\\n\", file);\n", "  fputs (\"\t\tfunction by its children.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     called\tThis is the number of times the function was called.\\n\", file);\n", "  fputs (\"\t\tIf the function called itself recursively, the number\\n\", file);\n", "  fputs (\"\t\tonly includes non-recursive calls, and is followed by\\n\", file);\n", "  fputs (\"\t\ta `+' and the number of recursive calls.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     name\tThe name of the current function.  The index number is\\n\", file);\n", "  fputs (\"\t\tprinted after it.  If the function is a member of a\\n\", file);\n", "  fputs (\"\t\tcycle, the cycle number is printed between the\\n\", file);\n", "  fputs (\"\t\tfunction's name and the index number.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\" For the function's parents, the fields have the following meanings:\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     self\tThis is the amount of time that was propagated directly\\n\", file);\n", "  fputs (\"\t\tfrom the function into this parent.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     children\tThis is the amount of time that was propagated from\\n\", file);\n", "  fputs (\"\t\tthe function's children into this parent.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     called\tThis is the number of times this parent called the\\n\", file);\n", "  fputs (\"\t\tfunction `/' the total number of times the function\\n\", file);\n", "  fputs (\"\t\twas called.  Recursive calls to the function are not\\n\", file);\n", "  fputs (\"\t\tincluded in the number after the `/'.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     name\tThis is the name of the parent.  The parent's index\\n\", file);\n", "  fputs (\"\t\tnumber is printed after it.  If the parent is a\\n\", file);\n", "  fputs (\"\t\tmember of a cycle, the cycle number is printed between\\n\", file);\n", "  fputs (\"\t\tthe name and the index number.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\" If the parents of the function cannot be determined, the word\\n\", file);\n", "  fputs (\" `<spontaneous>' is printed in the `name' field, and all the other\\n\", file);\n", "  fputs (\" fields are blank.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\" For the function's children, the fields have the following meanings:\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     self\tThis is the amount of time that was propagated directly\\n\", file);\n", "  fputs (\"\t\tfrom the child into the function.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     children\tThis is the amount of time that was propagated from the\\n\", file);\n", "  fputs (\"\t\tchild's children to the function.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     called\tThis is the number of times the function called\\n\", file);\n", "  fputs (\"\t\tthis child `/' the total number of times the child\\n\", file);\n", "  fputs (\"\t\twas called.  Recursive calls by the child are not\\n\", file);\n", "  fputs (\"\t\tlisted in the number after the `/'.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"     name\tThis is the name of the child.  The child's index\\n\", file);\n", "  fputs (\"\t\tnumber is printed after it.  If the child is a\\n\", file);\n", "  fputs (\"\t\tmember of a cycle, the cycle number is printed\\n\", file);\n", "  fputs (\"\t\tbetween the name and the index number.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\" If there are any cycles (circles) in the call graph, there is an\\n\", file);\n", "  fputs (\" entry for the cycle-as-a-whole.  This entry shows who called the\\n\", file);\n", "  fputs (\" cycle (as parents) and the members of the cycle (as children.)\\n\", file);\n", "  fputs (\" The `+' recursive calls entry shows the number of function calls that\\n\", file);\n", "  fputs (\" were internal to the cycle, and the calls entry for each member shows,\\n\", file);\n", "  fputs (\" for that member, how many times it was called from other members of\\n\", file);\n", "  fputs (\" the cycle.\\n\", file);\n", "  fputs (\"\f\\n\", file);\n", "  fputs (\"Copyright (C) 2012-2020 Free Software Foundation, Inc.\\n\", file);\n", "  fputs (\"\\n\", file);\n", "  fputs (\"Copying and distribution of this file, with or without modification,\\n\", file);\n", "  fputs (\"are permitted in any medium without royalty provided the copyright\\n\", file);\n", "  fputs (\"notice and this notice are preserved.\\n\", file);\n", "}\n"], "project": "binutils-multiarch-dbg", "file": "fsf_callg_bl.pkl", "function": "fsf_callg_blurb"}, {"comment_all": {"comment": "/* to list of Tycons ts            */", "depth": 0, "reading_ease": 100.24, "reading_grade": 0.5, "line": 477}, "comment_text": "/* Add tycons matching pattern pat */\n/* to list of Tycons ts            */\n/* Null pattern matches every tycon*/\n/* (Tycons with NIL kind excluded) */\n", "comment_tokens": ["Add", "tycons", "matching", "pattern", "pat", "to", "list", "of", "Tycons", "ts", "Null", "pattern", "matches", "every", "tycon", "(", "Tycons", "with", "NIL", "kind", "excluded", ")"], "ccode": ["\n", "List addTyconsMatching(pat,ts)          /* Add tycons matching pattern pat */\n", "String pat;                             /* to list of Tycons ts            */\n", "List   ts; {                            /* Null pattern matches every tycon*/\n", "    Tycon tc;\t\t\t\t/* (Tycons with NIL kind excluded) */\n", "    for (tc=TYCMIN; tc<tyconHw; ++tc)\n", "\tif (!pat || stringMatch(pat,textToStr(tycon(tc).text)))\n", "\t    if (nonNull(tycon(tc).kind))\n", "\t\tts = insertTycon(tc,ts);\n", "    return ts;\n", "}\n"], "project": "libhugs-time-bundled", "file": "storage.pkl", "function": "addTyconsMatching"}, {"comment_all": {"comment": "/*\n *  STFL - The Structured Terminal Forms Language/Library\n *  Copyright (C) 2007  Clifford Wolf <clifford@clifford.at>\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 3 of the License, or (at your option) any later version.\n *  \n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *  \n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301 USA\n *\n *  binding.c: Helper functions for key bindings and stuff\n */", "depth": 0, "reading_ease": 60.24, "reading_grade": 9.7, "line": 0}, "comment_text": "/*\n *  STFL - The Structured Terminal Forms Language/Library\n *  Copyright (C) 2007  Clifford Wolf <clifford@clifford.at>\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 3 of the License, or (at your option) any later version.\n *  \n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *  \n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301 USA\n *\n *  binding.c: Helper functions for key bindings and stuff\n */", "comment_tokens": ["STFL", "-", "The", "Structured", "Terminal", "Forms", "LanguageLibrary", "Copyright", "(", "C", ")", "2007", "Clifford", "Wolf", "<", "clifford", "@", "clifford.at", ">", "This", "library", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "Lesser", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "Lesser", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "Lesser", "General", "Public", "License", "along", "with", "this", "library", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA", "binding.c", ":", "Helper", "functions", "for", "key", "bindings", "and", "stuff"], "ccode": ["/*\n", " *  STFL - The Structured Terminal Forms Language/Library\n", " *  Copyright (C) 2007  Clifford Wolf <clifford@clifford.at>\n", " *\n", " *  This library is free software; you can redistribute it and/or\n", " *  modify it under the terms of the GNU Lesser General Public\n", " *  License as published by the Free Software Foundation; either\n", " *  version 3 of the License, or (at your option) any later version.\n", " *  \n", " *  This library is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n", " *  Lesser General Public License for more details.\n", " *  \n", " *  You should have received a copy of the GNU Lesser General Public\n", " *  License along with this library; if not, write to the Free Software\n", " *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n", " *  MA 02110-1301 USA\n", " *\n", " *  binding.c: Helper functions for key bindings and stuff\n", " */\n", "\n", "#include \"stfl_internals.h\"\n", "#include \"stfl_compat.h\"\n", "\n", "#include <string.h>\n", "#include <stdlib.h>\n", "#include <wchar.h>\n", "\n", "wchar_t *stfl_keyname(wchar_t ch, int isfunckey)\n", "{\n", "\tif (!isfunckey)\n", "\t{\n", "\t\tif (ch == L'\\r' || ch == L'\\n')\n", "\t\t\treturn compat_wcsdup(L\"ENTER\");\n", "\n", "\t\tif (ch == L' ')\n", "\t\t\treturn compat_wcsdup(L\"SPACE\");\n", "\n", "\t\tif (ch == L'\\t')\n", "\t\t\treturn compat_wcsdup(L\"TAB\");\n", "\n", "\t\tif (ch == 27)\n", "\t\t\treturn compat_wcsdup(L\"ESC\");\n", "\n", "\t\tif (ch == 127)\n", "\t\t\treturn compat_wcsdup(L\"BACKSPACE\");\n", "\n", "\t\twchar_t *ret;\n", "\t\tif (ch < 32) {\n", "\t\t\tconst char * key = keyname(ch);\n", "\t\t\tunsigned int keylen = strlen(key) + 1, i;\n", "\t\t\tret = malloc(keylen * sizeof(wchar_t));\n", "\t\t\tfor (i=0; i<keylen; i++)\n", "\t\t\t\tret[i] = key[i];\n", "\t\t} else {\n", "\t\t\tret = compat_wcsdup(L\" \");\n", "\t\t\tret[0] = ch;\n", "\t\t}\n", "\t\treturn ret;\n", "\t}\n", "\n", "\tif (KEY_F(0) <= ch && ch <= KEY_F(63)) {\n", "\t\twchar_t *name = malloc(4 * sizeof(wchar_t));\n", "\t\tswprintf(name, 4, L\"F%d\", ch - KEY_F0);\n", "\t\treturn name;\n", "\t}\n", "\n", "\tconst char *event_c = keyname(ch);\n", "\n", "\tif (!event_c)\n", "\t\treturn compat_wcsdup(L\"UNKNOWN\");\n", "\n", "\tif (!strncmp(event_c, \"KEY_\", 4))\n", "\t\tevent_c += 4;\n", "\t\n", "\tint event_len = strlen(event_c) + 1, i;\n", "\twchar_t *event = malloc(event_len * sizeof(wchar_t));\n", "\n", "\tfor (i=0; i<event_len; i++)\n", "\t\tevent[i] = event_c[i];\n", "\n", "\treturn event;\n", "}\n"], "project": "libstfl-dev", "file": "binding.pkl", "function": "stfl_keyname"}, {"comment_all": {"comment": "/*! \\brief Parse an input makeopts file */", "depth": 0, "reading_ease": 99.23, "reading_grade": 0.9, "line": 591}, "comment_text": "/*! \\brief Parse an input makeopts file */", "comment_tokens": ["!", "\\brief", "Parse", "an", "input", "makeopts", "file"], "ccode": ["\n", "/*! \\brief Parse an input makeopts file */\n", "static int parse_tree(const char *tree_file)\n", "{\n", "\tstruct tree *tree;\n", "\txmlNode *menu;\n", "\n", "\tif (!(tree = calloc(1, sizeof(*tree)))) {\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tif (!(tree->root = xmlParseFile(tree_file))) {\n", "\t\tfree(tree);\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tif (!(menu = xmlDocGetRootElement(tree->root))) {\n", "\t\tfprintf(stderr, \"Invalid document: No root element\\n\");\n", "\t\txmlFreeDoc(tree->root);\n", "\t\tfree(tree);\n", "\t\treturn -1;\n", "\t}\n", "\n", "\tif (process_xml_menu_node(tree, menu)) {\n", "\t\txmlFreeDoc(tree->root);\n", "\t\tfree(tree);\n", "\t\treturn -1;\n", "\t}\n", "\n", "\treturn 0;\n", "}\n"], "project": "asterisk-mobile", "file": "menuselect.pkl", "function": "parse_tree"}, {"comment_all": {"comment": "/*\n *      Code to convert a stream input into a dynamic array\n *      that can be parsed as argc and argv.\n *\n *      Authors: Horms <horms@vergenet.net>\n *\n *      Released under the terms of the GNU GPL\n *\n *      ChangeLog\n *      Horms         :   scanf Glibc under Red Hat 7 does not appear\n *                        to return EOF when input ends. Fall through\n *                        code has been added to handle this case correctly\n */", "depth": 0, "reading_ease": 82.34, "reading_grade": 5.3, "line": 0}, "comment_text": "/*\n *      Code to convert a stream input into a dynamic array\n *      that can be parsed as argc and argv.\n *\n *      Authors: Horms <horms@vergenet.net>\n *\n *      Released under the terms of the GNU GPL\n *\n *      ChangeLog\n *      Horms         :   scanf Glibc under Red Hat 7 does not appear\n *                        to return EOF when input ends. Fall through\n *                        code has been added to handle this case correctly\n */", "comment_tokens": ["Code", "to", "convert", "a", "stream", "input", "into", "a", "dynamic", "array", "that", "can", "be", "parsed", "as", "argc", "and", "argv", ".", "Authors", ":", "Horms", "<", "horms", "@", "vergenet.net", ">", "Released", "under", "the", "terms", "of", "the", "GNU", "GPL", "ChangeLog", "Horms", ":", "scanf", "Glibc", "under", "Red", "Hat", "7", "does", "not", "appear", "to", "return", "EOF", "when", "input", "ends", ".", "Fall", "through", "code", "has", "been", "added", "to", "handle", "this", "case", "correctly"], "ccode": ["/*\n", " *      Code to convert a stream input into a dynamic array\n", " *      that can be parsed as argc and argv.\n", " *\n", " *      Authors: Horms <horms@vergenet.net>\n", " *\n", " *      Released under the terms of the GNU GPL\n", " *\n", " *      ChangeLog\n", " *      Horms         :   scanf Glibc under Red Hat 7 does not appear\n", " *                        to return EOF when input ends. Fall through\n", " *                        code has been added to handle this case correctly\n", " */\n", "\n", "#include \"config_stream.h\"\n", "\n", "\n", "/**********************************************************************\n", " * config_stream_read\n", " * Read in a config file and put elements in a dynamic array\n", " * pre: stream: stream to read configuration from\n", " * return: dynamic array whose elements are the space delimited\n", " *         tokens read from the stream. Result is returned\n", " *         once a newline is reached so multiple calls\n", " *         will be required to read an entire stream.\n", " *         Everything including and after a hash (#) on a line is\n", " *         ignored\n", " **********************************************************************/\n", "\n", "dynamic_array_t *\n", "config_stream_read(FILE * stream, const char *first_element)\n", "{\n", "  char token[MAX_LINE_LENGTH];\n", "  char tail[2];\n", "  char format[MAX_LINE_LENGTH];\n", "  char format_whitespace[MAX_LINE_LENGTH];\n", "  int status;\n", "  int ntoken;\n", "  int comment = 0;\n", "  char *s;\n", "  int c;\n", "  int flag;\n", "  dynamic_array_t *a;\n", "\n", "  if ((a = dynamic_array_create((size_t) 0)) == NULL) {\n", "    perror(\"config_file_read: dynamic_array_create\");\n", "    return (NULL);\n", "  }\n", "\n", "  /*insert a argv[0] into the dynamic array */\n", "  if ((a = dynamic_array_add_element(a,\n", "\t\t\t\t     (first_element !=\n", "\t\t\t\t      NULL ? first_element : \"\"),\n", "\t\t\t\t     DESTROY_STR, DUP_STR)) == NULL) {\n", "    perror(\"config_file_read: dynamic_array_add_element\");\n", "    return (NULL);\n", "  }\n", "\n", "  sprintf(format, \"%%%d[^ \\t\\n\\r]%%1[ \\t\\n\\r]\", MAX_LINE_LENGTH);\n", "  sprintf(format_whitespace, \"%%%d[ \\t\\r]%%1[\\n]\", MAX_LINE_LENGTH);\n", "\n", "  ntoken = 0;\n", "  while ((status = fscanf(stream, format, token, tail)) != EOF) {\n", "    if (status == 0) {\n", "      flag = 1;\n", "      while (flag) {\n", "\tc = fgetc(stream);\n", "\tswitch (c) {\n", "\tcase EOF:\n", "\t  dynamic_array_destroy(a, DESTROY_STR);\n", "\t  return (NULL);\n", "\tcase '\\n':\n", "\t  return (a);\n", "\tcase '\\t':\n", "\tcase '\\r':\n", "\tcase ' ':\n", "\t  break;\n", "\tdefault:\n", "\t  ungetc(c, stream);\n", "\t  flag = 0;\n", "\t}\n", "      }\n", "      continue;\n", "    }\n", "    if (!comment && strcmp(token, \"ipvsadm\")) {\n", "      ntoken++;\n", "      if ((a = dynamic_array_add_element(a,\n", "\t\t\t\t\t token,\n", "\t\t\t\t\t DESTROY_STR, DUP_STR)) == NULL) {\n", "\tperror(\"config_file_read: dynamic_array_add_element\");\n", "\tdynamic_array_destroy(a, DESTROY_STR);\n", "\treturn (NULL);\n", "      }\n", "    }\n", "    if ((s = strrchr(tail, '\\n')) != NULL) {\n", "      return (a);\n", "    }\n", "    if (!comment) {\n", "      comment = (strchr((s != NULL ? s : tail), '#') == NULL) ? 0 : 1;\n", "    }\n", "  }\n", "\n", "  if (ntoken == 0) {\n", "    dynamic_array_destroy(a, DESTROY_STR);\n", "    return (NULL);\n", "  }\n", "\n", "  return (a);\n", "}\n"], "project": "ipvsadm", "file": "config_stream.pkl", "function": "config_stream_read"}, {"comment_all": {"comment": "/* Copyright (C) 2000-2013 Boris Wesslowski */", "depth": 0, "reading_ease": 66.4, "reading_grade": 5.2, "line": 0}, "comment_text": "/* Copyright (C) 2000-2013 Boris Wesslowski */\n/* $Id: rcfile.c 731 2013-05-17 14:15:23Z bw $ */\n", "comment_tokens": ["Copyright", "(", "C", ")", "2000-2013", "Boris", "Wesslowski", "$", "Id", ":", "rcfile.c", "731", "2013-05-17", "14:15:23Z", "bw", "$"], "ccode": ["/* Copyright (C) 2000-2013 Boris Wesslowski */\n", "/* $Id: rcfile.c 731 2013-05-17 14:15:23Z bw $ */\n", "\n", "#include <stdio.h>\n", "#include <stdlib.h>\n", "#include <errno.h>\n", "#include <sys/stat.h>\n", "#include <string.h>\n", "#include <ctype.h>\n", "#include \"rcfile.h\"\n", "#include \"main.h\"\n", "#include \"parser.h\"\n", "#include \"utils.h\"\n", "#include \"resolve.h\"\n", "\n", "extern struct options opt;\n", "\n", "char *get_one_parameter(char *string, unsigned char mode)\n", "{\n", "  char *pnt;\n", "\n", "  while (*string == ' ' || *string == '\\t' || *string == '=')\n", "    ++string;\n", "\n", "  pnt = string;\n", "  while (*pnt != '\\n' && *pnt != ' ' && *pnt != '\\t' && *pnt != '\\0' && (mode == HASH_IGNORE || *pnt != '#'))\n", "    ++pnt;\n", "  *pnt = '\\0';\n", "\n", "  return string;\n", "}\n"], "project": "fwlogwatch", "file": "rcfile.pkl", "function": "get_one_parameter"}, {"comment_all": {"comment": "/*\n\treturns the offset of a specific cluster in the\n\tdata region of the file system\n*/", "depth": 1, "reading_ease": 64.71, "reading_grade": 8.0, "line": 586}, "comment_text": "/*\n\treturns the offset of a specific cluster in the\n\tdata region of the file system\n*/", "comment_tokens": ["returns", "the", "offset", "of", "a", "specific", "cluster", "in", "the", "data", "region", "of", "the", "file", "system"], "ccode": ["\n", "off_t getClusterOffset(struct sFileSystem *fs, u_int32_t cluster) {\n", "/*\n", "\treturns the offset of a specific cluster in the\n", "\tdata region of the file system\n", "*/\n", "\n", "\tassert(fs != NULL);\n", "\tassert(cluster > 1);\n", "\n", "\treturn (((off_t)(cluster - 2) * fs->bs.BS_SecPerClus) + fs->firstDataSector) * fs->sectorSize;\n", "\n", "}\n"], "project": "fatsort", "file": "FAT_fs.pkl", "function": "getClusterOffset"}, {"comment_all": {"comment": "/* Return \"true\" if L is empty */", "depth": 0, "reading_ease": 90.77, "reading_grade": 2.1, "line": 35}, "comment_text": "/* Return \"true\" if L is empty */", "comment_tokens": ["Return", "``", "true", "''", "if", "L", "is", "empty"], "ccode": ["\n", "\n", "/* Return \"true\" if L is empty */\n", "int IsEmpty(List L) \n", "{\n", "\treturn L->Next == NULL;\n", "}\n"], "project": "augustus", "file": "list.pkl", "function": "IsEmpty"}, {"comment_all": {"comment": "/* try next */", "depth": 1, "reading_ease": 120.21, "reading_grade": -3.1, "line": 147}, "comment_text": "/* try next */\n/* move to new group */\n", "comment_tokens": ["try", "next", "move", "to", "new", "group"], "ccode": ["\n", "\n", "void makeNextPtyNames(char *cont,char * serv)\n", "{\n", "#ifdef AIX370platform\n", "\tstatic int channelNo = 0;\n", "\tsprintf(cont, \"/dev/ptyp%02x\", channelNo);\n", "\tsprintf(serv, \"/dev/ttyp%02x\", channelNo);\n", "\tchannelNo++;\n", "#endif\n", "#if defined(SUNplatform) ||\\\n", " defined(HP9platform) ||\\\n", " defined(LINUXplatform) ||\\\n", " defined(ubuntuplatform) ||\\\n", " defined(MACOSXplatform) ||\\\n", " defined(BSDplatform)\n", "\tstatic int channelNo = 0;\n", "\tstatic char group[] = \"pqrstuvwxyzPQRST\";\n", "\tstatic int groupNo = 0;\n", "\n", "\tsprintf(cont, \"/dev/pty%c%x\", group[groupNo], channelNo);\n", "\tsprintf(serv, \"/dev/tty%c%x\", group[groupNo], channelNo);\n", "\tchannelNo++;                /* try next */\n", "\tif (channelNo == 16) {      /* move to new group */\n", "\t\tchannelNo = 0;\n", "\t\tgroupNo++;\n", "\t\tif (groupNo == 16) groupNo = 0;        /* recycle */\n", "\t\t}\n", "#endif\n", "}\n"], "project": "axiom-databases", "file": "openpty.pkl", "function": "makeNextPtyNames"}, {"comment_all": {"comment": "/* Don't TAILQ_REMOVE, this is not a real list! */", "depth": 2, "reading_ease": 88.74, "reading_grade": 2.9, "line": 45}, "comment_text": "/* Don't TAILQ_REMOVE, this is not a real list! */", "comment_tokens": ["Do", "n't", "TAILQ_REMOVE", ",", "this", "is", "not", "a", "real", "list", "!"], "ccode": ["\n", "static void\n", "_lldpctl_atom_free_interfaces_list(lldpctl_atom_t *atom)\n", "{\n", "\tstruct _lldpctl_atom_interfaces_list_t *iflist =\n", "\t    (struct _lldpctl_atom_interfaces_list_t *)atom;\n", "\tstruct lldpd_interface *iface, *iface_next;\n", "\tfor (iface = TAILQ_FIRST(iflist->ifs);\n", "\t     iface != NULL;\n", "\t     iface = iface_next) {\n", "\t\t/* Don't TAILQ_REMOVE, this is not a real list! */\n", "\t\tiface_next = TAILQ_NEXT(iface, next);\n", "\t\tfree(iface->name);\n", "\t\tfree(iface);\n", "\t}\n", "\tfree(iflist->ifs);\n", "}\n"], "project": "liblldpctl-dev", "file": "interface.pkl", "function": "_lldpctl_atom_free_interfaces_list"}, {"comment_all": {"comment": "//\tstruct mcu_t * mcu = (struct mcu_t*)avr;\n", "depth": 0, "reading_ease": 100.24, "reading_grade": 0.5, "line": 216}, "comment_text": "//\tstruct mcu_t * mcu = (struct mcu_t*)avr;\n", "comment_tokens": ["struct", "mcu_t", "mcu", "=", "(", "struct", "mcu_t", ")", "avr", ";"], "ccode": ["\n", "static void reset(struct avr_t * avr)\n", "{\n", "//\tstruct mcu_t * mcu = (struct mcu_t*)avr;\n", "}\n"], "project": "libsimavr2", "file": "sim_tiny13.pkl", "function": "reset"}, {"comment_all": {"comment": "/* seq_next -- advance to the next event, return TRUE if found */", "depth": 0, "reading_ease": 86.71, "reading_grade": 3.7, "line": 13}, "comment_text": "/* seq_next -- advance to the next event, return TRUE if found */", "comment_tokens": ["seq_next", "--", "advance", "to", "the", "next", "event", ",", "return", "TRUE", "if", "found"], "ccode": ["/* seqinterf.c -- interface to sequence data type for XLISP */\n", "\n", "#include \"switches.h\"\n", "#include \"xlisp.h\"\n", "#include \"stdio.h\"\n", "#include \"cext.h\"\n", "#include \"userio.h\"\n", "#include \"midifns.h\"\n", "#include \"timebase.h\"\n", "#include \"moxc.h\"\n", "#include \"seq.h\"\n", "#include \"seqinterf.h\"\n", "\n", "/* seq_next -- advance to the next event, return TRUE if found */\n", "/**/\n", "boolean seq_next(seq_type seq)\n", "{\n", "    if (seq->current) {\n", "    seq->current = seq->current->next;\n", "    }\n", "    return seq->current != NULL;\n", "}\n"], "project": "audacity", "file": "seqinterf.pkl", "function": "seq_next"}, {"comment_all": {"comment": "/* 2. Align memory size */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 52}, "comment_text": "/* 2. Align memory size */\n/* Minimum memory_blocks = 8L blocks, where L is the number of lanes */\n", "comment_tokens": ["2", ".", "Align", "memory", "size", "Minimum", "memory_blocks", "=", "8L", "blocks", ",", "where", "L", "is", "the", "number", "of", "lanes"], "ccode": ["\n", "int argon2_ctx(argon2_context *context, argon2_type type) {\n", "    /* 1. Validate all inputs */\n", "    int result = validate_inputs(context);\n", "    uint32_t memory_blocks, segment_length;\n", "    argon2_instance_t instance;\n", "\n", "    if (ARGON2_OK != result) {\n", "        return result;\n", "    }\n", "\n", "    if (Argon2_d != type && Argon2_i != type && Argon2_id != type) {\n", "        return ARGON2_INCORRECT_TYPE;\n", "    }\n", "\n", "    /* 2. Align memory size */\n", "    /* Minimum memory_blocks = 8L blocks, where L is the number of lanes */\n", "    memory_blocks = context->m_cost;\n", "\n", "    if (memory_blocks < 2 * ARGON2_SYNC_POINTS * context->lanes) {\n", "        memory_blocks = 2 * ARGON2_SYNC_POINTS * context->lanes;\n", "    }\n", "\n", "    segment_length = memory_blocks / (context->lanes * ARGON2_SYNC_POINTS);\n", "    /* Ensure that all segments have equal length */\n", "    memory_blocks = segment_length * (context->lanes * ARGON2_SYNC_POINTS);\n", "\n", "    instance.version = context->version;\n", "    instance.memory = NULL;\n", "    instance.passes = context->t_cost;\n", "    instance.memory_blocks = memory_blocks;\n", "    instance.segment_length = segment_length;\n", "    instance.lane_length = segment_length * ARGON2_SYNC_POINTS;\n", "    instance.lanes = context->lanes;\n", "    instance.threads = context->threads;\n", "    instance.type = type;\n", "\n", "    if (instance.threads > instance.lanes) {\n", "        instance.threads = instance.lanes;\n", "    }\n", "\n", "    /* 3. Initialization: Hashing inputs, allocating memory, filling first\n", "     * blocks\n", "     */\n", "    result = initialize(&instance, context);\n", "\n", "    if (ARGON2_OK != result) {\n", "        return result;\n", "    }\n", "\n", "    /* 4. Filling memory */\n", "    result = fill_memory_blocks(&instance);\n", "\n", "    if (ARGON2_OK != result) {\n", "        return result;\n", "    }\n", "    /* 5. Finalization */\n", "    finalize(context, &instance);\n", "\n", "    return ARGON2_OK;\n", "}\n"], "project": "libargon2-0", "file": "argon2.pkl", "function": "argon2_ctx"}, {"comment_all": {"comment": "/* in case stdout and stderr are the same */", "depth": 1, "reading_ease": 105.66, "reading_grade": 0.5, "line": 72}, "comment_text": "/* in case stdout and stderr are the same */", "comment_tokens": ["in", "case", "stdout", "and", "stderr", "are", "the", "same"], "ccode": ["\n", "/* Print a message and return to caller.\n", " * Caller specifies \"errnoflag\". */\n", "\n", "static void err_doit(int errnoflag, const char *fmt, va_list ap) {\n", "\n", "\tint\t\terrno_save;\n", "\tchar\tbuf[MAXLINE];\n", "\n", "\terrno_save = errno;\t\t/* value caller might want printed */\n", "\tvsprintf(buf, fmt, ap);\n", "\tif (errnoflag)\n", "\t\tsprintf(buf+strlen(buf), \": %s\", strerror(errno_save));\n", "\tstrcat(buf, \"\\n\");\n", "\tfflush(stdout);\t\t/* in case stdout and stderr are the same */\n", "\tfputs(buf, stderr);\n", "\tfflush(NULL);\t\t/* flushes all stdio output streams */\n", "\treturn;\n", "\n", "}\n"], "project": "ipband", "file": "error.pkl", "function": "err_doit"}, {"comment_all": {"comment": "/*\n\t * Atomically decrement the evict-disabled count, without acquiring the\n\t * eviction walk-lock. We can't acquire that lock here because there's\n\t * a potential deadlock. When acquiring exclusive eviction access, we\n\t * acquire the eviction walk-lock and then the cache's pass-intr lock.\n\t * The current eviction implementation can hold the pass-intr lock and\n\t * call into this function (see WT-3303 for the details), which might\n\t * deadlock with another thread trying to get exclusive eviction access.\n\t */", "depth": 1, "reading_ease": 45.76, "reading_grade": 11.1, "line": 896}, "comment_text": "/*\n\t * Atomically decrement the evict-disabled count, without acquiring the\n\t * eviction walk-lock. We can't acquire that lock here because there's\n\t * a potential deadlock. When acquiring exclusive eviction access, we\n\t * acquire the eviction walk-lock and then the cache's pass-intr lock.\n\t * The current eviction implementation can hold the pass-intr lock and\n\t * call into this function (see WT-3303 for the details), which might\n\t * deadlock with another thread trying to get exclusive eviction access.\n\t */", "comment_tokens": ["Atomically", "decrement", "the", "evict-disabled", "count", ",", "without", "acquiring", "the", "eviction", "walk-lock", ".", "We", "ca", "n't", "acquire", "that", "lock", "here", "because", "there's", "a", "potential", "deadlock", ".", "When", "acquiring", "exclusive", "eviction", "access", ",", "we", "acquire", "the", "eviction", "walk-lock", "and", "then", "the", "cache", "'s", "pass-intr", "lock", ".", "The", "current", "eviction", "implementation", "can", "hold", "the", "pass-intr", "lock", "and", "call", "into", "this", "function", "(", "see", "WT-3303", "for", "the", "details", ")", ",", "which", "might", "deadlock", "with", "another", "thread", "trying", "to", "get", "exclusive", "eviction", "access", "."], "ccode": ["\n", "/*\n", " * __wt_evict_file_exclusive_off --\n", " *\tRelease exclusive eviction access to a file.\n", " */\n", "void\n", "__wt_evict_file_exclusive_off(WT_SESSION_IMPL *session)\n", "{\n", "\tWT_BTREE *btree;\n", "\n", "\tbtree = S2BT(session);\n", "\n", "\t/*\n", "\t * We have seen subtle bugs with multiple threads racing to turn\n", "\t * eviction on/off.  Make races more likely in diagnostic builds.\n", "\t */\n", "\tWT_DIAGNOSTIC_YIELD;\n", "\n", "\t/*\n", "\t * Atomically decrement the evict-disabled count, without acquiring the\n", "\t * eviction walk-lock. We can't acquire that lock here because there's\n", "\t * a potential deadlock. When acquiring exclusive eviction access, we\n", "\t * acquire the eviction walk-lock and then the cache's pass-intr lock.\n", "\t * The current eviction implementation can hold the pass-intr lock and\n", "\t * call into this function (see WT-3303 for the details), which might\n", "\t * deadlock with another thread trying to get exclusive eviction access.\n", "\t */\n", "#if defined(HAVE_DIAGNOSTIC)\n", "\t{\n", "\tint32_t v;\n", "\n", "\tWT_ASSERT(session, btree->evict_ref == NULL);\n", "\tv = __wt_atomic_subi32(&btree->evict_disabled, 1);\n", "\tWT_ASSERT(session, v >= 0);\n", "\t}\n", "#else\n", "\t(void)__wt_atomic_subi32(&btree->evict_disabled, 1);\n", "#endif\n", "}\n"], "project": "libwiredtiger-java", "file": "evict_lru.pkl", "function": "__wt_evict_file_exclusive_off"}, {"comment_all": {"comment": "/*\n   Compile this with:\n\n   gcc -g -c -Wall test28-add-aliased-function-v1.c\n */", "depth": 0, "reading_ease": 63.36, "reading_grade": 6.4, "line": 0}, "comment_text": "/*\n   Compile this with:\n\n   gcc -g -c -Wall test28-add-aliased-function-v1.c\n */", "comment_tokens": ["Compile", "this", "with", ":", "gcc", "-g", "-c", "-Wall", "test28-add-aliased-function-v1.c"], "ccode": ["/*\n", "   Compile this with:\n", "\n", "   gcc -g -c -Wall test28-add-aliased-function-v1.c\n", " */\n", "\n", "void\n", "foo()\n", "{\n", "}\n"], "project": "libabigail0", "file": "test28-add-aliased-function-v1.pkl", "function": "foo"}, {"comment_all": {"comment": "/*\n     * If we can't load it (because it probably doesn't exist),\n     * we deny access.\n     */", "depth": 1, "reading_ease": 66.74, "reading_grade": 7.2, "line": 117}, "comment_text": "/*\n     * If we can't load it (because it probably doesn't exist),\n     * we deny access.\n     */", "comment_tokens": ["If", "we", "ca", "n't", "load", "it", "(", "because", "it", "probably", "does", "n't", "exist", ")", ",", "we", "deny", "access", "."], "ccode": ["\n", "int\n", "opstaff_check(char *sender)\n", "{\n", "    char buf[1024];\t/* holds the real acl name */\n", "    int retval;\n", "\n", "    snprintf(buf, sizeof buf, \"%s/opstaff.acl\", acl_dir);\n", "    /*\n", "     * If we can't load it (because it probably doesn't exist),\n", "     * we deny access.\n", "     */\n", "    retval = acl_load(buf);\n", "    if (retval < 0) {\n", "\tsyslog(LOG_DEBUG, \"Error in acl_load of %s for %s\",\n", "\t\tbuf, sender ? sender : \"unauth client\");\n", "\treturn 0;\n", "    }\n", "    return acl_check(buf, sender, NULL);\n", "}\n"], "project": "libzephyr4", "file": "access.pkl", "function": "opstaff_check"}, {"comment_all": {"comment": "/* GSM_MAGIC  = (*c >> 4) & 0xF; */", "depth": 1, "reading_ease": 75.88, "reading_grade": 3.7, "line": 19}, "comment_text": "/* GSM_MAGIC  = (*c >> 4) & 0xF; */", "comment_tokens": ["GSM_MAGIC", "=", "(", "c", ">", ">", "4", ")", "&", "0xF", ";"], "ccode": ["/*\n", " * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische\n", " * Universitaet Berlin.  See the accompanying file \"COPYRIGHT\" for\n", " * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.\n", " */\n", "\n", "/* $Header: /tmp_amd/presto/export/kbs/jutta/src/gsm/RCS/gsm_print.c,v 1.1 1992/10/28 00:15:50 jutta Exp $ */\n", "\n", "#include\t<stdio.h>\n", "\n", "#include \"private.h\"\n", "\n", "#include \"gsm.h\"\n", "#include \"proto.h\"\n", "\n", "int gsm_print P3((f, s, c), FILE * f, gsm s, gsm_byte * c)\n", "{\n", "\tword  \tLARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];\n", "\n", "\t/* GSM_MAGIC  = (*c >> 4) & 0xF; */\n", "\n", "\tif (((*c >> 4) & 0x0F) != GSM_MAGIC) return -1;\n", "\n", "\tLARc[0]  = (*c++ & 0xF) << 2;\t\t/* 1 */\n", "\tLARc[0] |= (*c >> 6) & 0x3;\n", "\tLARc[1]  = *c++ & 0x3F;\n", "\tLARc[2]  = (*c >> 3) & 0x1F;\n", "\tLARc[3]  = (*c++ & 0x7) << 2;\n", "\tLARc[3] |= (*c >> 6) & 0x3;\n", "\tLARc[4]  = (*c >> 2) & 0xF;\n", "\tLARc[5]  = (*c++ & 0x3) << 2;\n", "\tLARc[5] |= (*c >> 6) & 0x3;\n", "\tLARc[6]  = (*c >> 3) & 0x7;\n", "\tLARc[7]  = *c++ & 0x7;\n", "\n", "\n", "\tNc[0]  = (*c >> 1) & 0x7F;\n", "\tbc[0]  = (*c++ & 0x1) << 1;\n", "\tbc[0] |= (*c >> 7) & 0x1;\n", "\tMc[0]  = (*c >> 5) & 0x3;\n", "\txmaxc[0]  = (*c++ & 0x1F) << 1;\n", "\txmaxc[0] |= (*c >> 7) & 0x1;\n", "\txmc[0]  = (*c >> 4) & 0x7;\n", "\txmc[1]  = (*c >> 1) & 0x7;\n", "\txmc[2]  = (*c++ & 0x1) << 2;\n", "\txmc[2] |= (*c >> 6) & 0x3;\n", "\txmc[3]  = (*c >> 3) & 0x7;\n", "\txmc[4]  = *c++ & 0x7;\n", "\txmc[5]  = (*c >> 5) & 0x7;\n", "\txmc[6]  = (*c >> 2) & 0x7;\n", "\txmc[7]  = (*c++ & 0x3) << 1;\t\t/* 10 */\n", "\txmc[7] |= (*c >> 7) & 0x1;\n", "\txmc[8]  = (*c >> 4) & 0x7;\n", "\txmc[9]  = (*c >> 1) & 0x7;\n", "\txmc[10]  = (*c++ & 0x1) << 2;\n", "\txmc[10] |= (*c >> 6) & 0x3;\n", "\txmc[11]  = (*c >> 3) & 0x7;\n", "\txmc[12]  = *c++ & 0x7;\n", "\n", "\tNc[1]  = (*c >> 1) & 0x7F;\n", "\tbc[1]  = (*c++ & 0x1) << 1;\n", "\tbc[1] |= (*c >> 7) & 0x1;\n", "\tMc[1]  = (*c >> 5) & 0x3;\n", "\txmaxc[1]  = (*c++ & 0x1F) << 1;\n", "\txmaxc[1] |= (*c >> 7) & 0x1;\n", "\txmc[13]  = (*c >> 4) & 0x7;\n", "\txmc[14]  = (*c >> 1) & 0x7;\n", "\txmc[15]  = (*c++ & 0x1) << 2;\n", "\txmc[15] |= (*c >> 6) & 0x3;\n", "\txmc[16]  = (*c >> 3) & 0x7;\n", "\txmc[17]  = *c++ & 0x7;\n", "\txmc[18]  = (*c >> 5) & 0x7;\n", "\txmc[19]  = (*c >> 2) & 0x7;\n", "\txmc[20]  = (*c++ & 0x3) << 1;\n", "\txmc[20] |= (*c >> 7) & 0x1;\n", "\txmc[21]  = (*c >> 4) & 0x7;\n", "\txmc[22]  = (*c >> 1) & 0x7;\n", "\txmc[23]  = (*c++ & 0x1) << 2;\n", "\txmc[23] |= (*c >> 6) & 0x3;\n", "\txmc[24]  = (*c >> 3) & 0x7;\n", "\txmc[25]  = *c++ & 0x7;\n", "\n", "\n", "\tNc[2]  = (*c >> 1) & 0x7F;\n", "\tbc[2]  = (*c++ & 0x1) << 1;\t\t/* 20 */\n", "\tbc[2] |= (*c >> 7) & 0x1;\n", "\tMc[2]  = (*c >> 5) & 0x3;\n", "\txmaxc[2]  = (*c++ & 0x1F) << 1;\n", "\txmaxc[2] |= (*c >> 7) & 0x1;\n", "\txmc[26]  = (*c >> 4) & 0x7;\n", "\txmc[27]  = (*c >> 1) & 0x7;\n", "\txmc[28]  = (*c++ & 0x1) << 2;\n", "\txmc[28] |= (*c >> 6) & 0x3;\n", "\txmc[29]  = (*c >> 3) & 0x7;\n", "\txmc[30]  = *c++ & 0x7;\n", "\txmc[31]  = (*c >> 5) & 0x7;\n", "\txmc[32]  = (*c >> 2) & 0x7;\n", "\txmc[33]  = (*c++ & 0x3) << 1;\n", "\txmc[33] |= (*c >> 7) & 0x1;\n", "\txmc[34]  = (*c >> 4) & 0x7;\n", "\txmc[35]  = (*c >> 1) & 0x7;\n", "\txmc[36]  = (*c++ & 0x1) << 2;\n", "\txmc[36] |= (*c >> 6) & 0x3;\n", "\txmc[37]  = (*c >> 3) & 0x7;\n", "\txmc[38]  = *c++ & 0x7;\n", "\n", "\tNc[3]  = (*c >> 1) & 0x7F;\n", "\tbc[3]  = (*c++ & 0x1) << 1;\n", "\tbc[3] |= (*c >> 7) & 0x1;\n", "\tMc[3]  = (*c >> 5) & 0x3;\n", "\txmaxc[3]  = (*c++ & 0x1F) << 1;\n", "\txmaxc[3] |= (*c >> 7) & 0x1;\n", "\n", "\txmc[39]  = (*c >> 4) & 0x7;\n", "\txmc[40]  = (*c >> 1) & 0x7;\n", "\txmc[41]  = (*c++ & 0x1) << 2;\n", "\txmc[41] |= (*c >> 6) & 0x3;\n", "\txmc[42]  = (*c >> 3) & 0x7;\n", "\txmc[43]  = *c++ & 0x7;\t\t\t/* 30  */\n", "\txmc[44]  = (*c >> 5) & 0x7;\n", "\txmc[45]  = (*c >> 2) & 0x7;\n", "\txmc[46]  = (*c++ & 0x3) << 1;\n", "\txmc[46] |= (*c >> 7) & 0x1;\n", "\txmc[47]  = (*c >> 4) & 0x7;\n", "\txmc[48]  = (*c >> 1) & 0x7;\n", "\txmc[49]  = (*c++ & 0x1) << 2;\n", "\txmc[49] |= (*c >> 6) & 0x3;\n", "\txmc[50]  = (*c >> 3) & 0x7;\n", "\txmc[51]  = *c & 0x7;\t\t\t/* 33 */\n", "\n", "\tfprintf(f,\n", "\t      \"LARc:\\t%2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d\\n\",\n", "\t       LARc[0],LARc[1],LARc[2],LARc[3],LARc[4],LARc[5],LARc[6],LARc[7]);\n", "\n", "\tfprintf(f, \"#1: \tNc %4.4d    bc %d    Mc %d    xmaxc %d\\n\",\n", "\t\tNc[0], bc[0], Mc[0], xmaxc[0]);\n", "\tfprintf(f,\n", "\"\\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\\n\",\n", "\t\txmc[0],xmc[1],xmc[2],xmc[3],xmc[4],xmc[5],xmc[6],\n", "\t\txmc[7],xmc[8],xmc[9],xmc[10],xmc[11],xmc[12] );\n", "\n", "\tfprintf(f, \"#2: \tNc %4.4d    bc %d    Mc %d    xmaxc %d\\n\",\n", "\t\tNc[1], bc[1], Mc[1], xmaxc[1]);\n", "\tfprintf(f,\n", "\"\\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\\n\",\n", "\t\txmc[13+0],xmc[13+1],xmc[13+2],xmc[13+3],xmc[13+4],xmc[13+5],\n", "\t\txmc[13+6], xmc[13+7],xmc[13+8],xmc[13+9],xmc[13+10],xmc[13+11],\n", "\t\txmc[13+12] );\n", "\n", "\tfprintf(f, \"#3: \tNc %4.4d    bc %d    Mc %d    xmaxc %d\\n\",\n", "\t\tNc[2], bc[2], Mc[2], xmaxc[2]);\n", "\tfprintf(f,\n", "\"\\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\\n\",\n", "\t\txmc[26+0],xmc[26+1],xmc[26+2],xmc[26+3],xmc[26+4],xmc[26+5],\n", "\t\txmc[26+6], xmc[26+7],xmc[26+8],xmc[26+9],xmc[26+10],xmc[26+11],\n", "\t\txmc[26+12] );\n", "\n", "\tfprintf(f, \"#4: \tNc %4.4d    bc %d    Mc %d    xmaxc %d\\n\",\n", "\t\tNc[3], bc[3], Mc[3], xmaxc[3]);\n", "\tfprintf(f,\n", "\"\\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\\n\",\n", "\t\txmc[39+0],xmc[39+1],xmc[39+2],xmc[39+3],xmc[39+4],xmc[39+5],\n", "\t\txmc[39+6], xmc[39+7],xmc[39+8],xmc[39+9],xmc[39+10],xmc[39+11],\n", "\t\txmc[39+12] );\n", "\n", "\treturn 0;\n", "}\n"], "project": "libgsm1-dev", "file": "gsm_print.pkl", "function": "gsm_print"}, {"comment_all": {"comment": "/* Request extra space for the padding: */", "depth": 2, "reading_ease": 73.85, "reading_grade": 4.5, "line": 486}, "comment_text": "/* Request extra space for the padding: */", "comment_tokens": ["Request", "extra", "space", "for", "the", "padding", ":"], "ccode": ["\n", "\n", "static void\n", "gtk_alignment_size_request (GtkWidget      *widget,\n", "\t\t\t    GtkRequisition *requisition)\n", "{\n", "  GtkBin *bin;\n", "  GtkAlignmentPrivate *priv;\n", "\n", "  bin = GTK_BIN (widget);\n", "  priv = GTK_ALIGNMENT_GET_PRIVATE (widget);\n", "\n", "  requisition->width = GTK_CONTAINER (widget)->border_width * 2;\n", "  requisition->height = GTK_CONTAINER (widget)->border_width * 2;\n", "\n", "  if (bin->child && gtk_widget_get_visible (bin->child))\n", "    {\n", "      GtkRequisition child_requisition;\n", "      \n", "      gtk_widget_size_request (bin->child, &child_requisition);\n", "\n", "      requisition->width += child_requisition.width;\n", "      requisition->height += child_requisition.height;\n", "\n", "      /* Request extra space for the padding: */\n", "      requisition->width += (priv->padding_left + priv->padding_right);\n", "      requisition->height += (priv->padding_top + priv->padding_bottom);\n", "    }\n", "}\n"], "project": "libgtk2.0-0", "file": "gtkalignment.pkl", "function": "gtk_alignment_size_request"}, {"comment_all": {"comment": "/* Save the text before the parameter declarations. */", "depth": 2, "reading_ease": 30.53, "reading_grade": 10.7, "line": 1052}, "comment_text": "/* Save the text before the parameter declarations. */", "comment_tokens": ["Save", "the", "text", "before", "the", "parameter", "declarations", "."], "ccode": ["\n", "/* Generate a function definition head.\n", " */\n", "void\n", "gen_func_definition(DeclSpec * decl_spec, Declarator * declarator)\n", "{\n", "    Parameter *p;\n", "    ParameterList *params;\n", "    char *comment = 0;\n", "    int n;\n", "    size_t comment_len;\n", "    long diff;\n", "\n", "    /* Do nothing if the function is already defined in the desired style\n", "     * or if the function uses varargs.\n", "     */\n", "    func_declarator = declarator->head;\n", "    if (func_declarator->func_def == func_style ||\n", "\tuses_varargs(func_declarator))\n", "\treturn;\n", "\n", "    /* Save the text between the function head and the function body.\n", "     * Read the temporary file from after the last ) or ; to the\n", "     * end of the file.\n", "     */\n", "    if ((diff = (ftell(cur_tmp_file()) - cur_begin_comment())) > 0) {\n", "\tcomment_len = (size_t) diff;\n", "\t*(comment = (char *) xmalloc(comment_len)) = '\\0';\n", "\tfseek(cur_tmp_file(), cur_begin_comment(), 0);\n", "\tfread(comment, sizeof(char), comment_len, cur_tmp_file());\n", "    } else {\n", "\tcomment_len = 0;\n", "    }\n", "\n", "    format = FMT_FUNC;\n", "    nestedParams = 0;\n", "\n", "    if (func_declarator->func_def == FUNC_TRADITIONAL\n", "\t|| func_declarator->func_def == FUNC_BOTH) {\n", "\t/* Save the text before the parameter declarations. */\n", "\tparams = &func_declarator->params;\n", "\tn = (int) (params->end_comment - params->begin_comment);\n", "\tif (n > 0) {\n", "\t    *(params->comment = (char *) xmalloc((size_t) (n + 1))) = '\\0';\n", "\t    fseek(cur_tmp_file(), params->begin_comment, 0);\n", "\t    fread(params->comment, sizeof(char), (size_t) n, cur_tmp_file());\n", "\t    params->comment[n] = '\\0';\n", "\t    format = FMT_FUNC_COMMENT;\n", "\t}\n", "\n", "\t/* Get the parameter comments. */\n", "\tfor (p = func_declarator->params.first; p != NULL; p = p->next) {\n", "\t    n = (int) (p->declarator->end_comment - p->declarator->begin_comment);\n", "\t    if (n > 0) {\n", "\t\t*(p->comment = (char *) xmalloc((size_t) n + 1)) = '\\0';\n", "\t\tfseek(cur_tmp_file(), p->declarator->begin_comment, 0);\n", "\t\tfread(p->comment, sizeof(char), (size_t) n, cur_tmp_file());\n", "\t\tp->comment[n] = '\\0';\n", "\t\tformat = FMT_FUNC_COMMENT;\n", "\t    }\n", "\t}\n", "    }\n", "\n", "    check_void_param(func_declarator);\n", "    set_param_decl_spec(func_declarator);\n", "\n", "    /* Go to the beginning of the function head in the temporary file\n", "     * and overwrite it with the converted function head.\n", "     */\n", "    where = FUNC_DEF;\n", "    fseek(cur_tmp_file(), decl_spec->begin, 0);\n", "\n", "    if (func_style == FUNC_BOTH) {\n", "\tchar *cur_func;\n", "\tsize_t func_len;\n", "\n", "\t/* Save the current function definition head. */\n", "\tif ((diff = (cur_begin_comment() - decl_spec->begin)) > 0) {\n", "\t    func_len = (size_t) diff;\n", "\t    cur_func = (char *) xmalloc(func_len);\n", "\t    fread(cur_func, sizeof(char), func_len, cur_tmp_file());\n", "\t} else {\n", "\t    cur_func = 0;\n", "\t    func_len = 0;\n", "\t}\n", "\n", "\tfseek(cur_tmp_file(), decl_spec->begin, 0);\n", "\tfprintf(cur_tmp_file(), \"%s\\n\\n\", func_directive);\n", "\n", "\t/* Output new style function definition head. */\n", "\tif (func_declarator->func_def == FUNC_ANSI) {\n", "\t    if (cur_func != 0)\n", "\t\tfwrite(cur_func, sizeof(char), func_len, cur_tmp_file());\n", "\t} else {\n", "\t    fputs(fmt[format].decl_spec_prefix, cur_tmp_file());\n", "\t    fputs(decl_spec->text, cur_tmp_file());\n", "\t    fputc(' ', cur_tmp_file());\n", "\n", "\t    func_style = FUNC_ANSI;\n", "\t    put_func_declarator(cur_tmp_file(), declarator, FALSE);\n", "\t}\n", "\tfputs(\"\\n#else\\n\\n\", cur_tmp_file());\n", "\n", "\t/* Output old style function definition head. */\n", "\tif (func_declarator->func_def == FUNC_TRADITIONAL\n", "\t    || func_declarator->func_def == FUNC_BOTH) {\n", "\t    if (cur_func != 0)\n", "\t\tfwrite(cur_func, sizeof(char), func_len, cur_tmp_file());\n", "\t} else {\n", "\t    fputs(fmt[format].decl_spec_prefix, cur_tmp_file());\n", "\t    fputs(decl_spec->text, cur_tmp_file());\n", "\t    fputc(' ', cur_tmp_file());\n", "\n", "\t    format = FMT_FUNC;\n", "\t    func_style = FUNC_TRADITIONAL;\n", "\t    put_func_declarator(cur_tmp_file(), declarator, FALSE);\n", "\t    put_param_decl(func_declarator, FALSE);\n", "\t}\n", "\n", "\tfputs(\"\\n#endif\", cur_tmp_file());\n", "\tif (comment != 0 && *comment != '\\n')\n", "\t    fputc('\\n', cur_tmp_file());\n", "\tfunc_style = FUNC_BOTH;\n", "\n", "\tif (cur_func != 0)\n", "\t    free(cur_func);\n", "\n", "    } else {\n", "\t/* Output declarator specifiers. */\n", "\tfputs(fmt[format].decl_spec_prefix, cur_tmp_file());\n", "\tfputs(decl_spec->text, cur_tmp_file());\n", "\tfputc(' ', cur_tmp_file());\n", "\n", "\t/* Output function declarator. */\n", "\tput_func_declarator(cur_tmp_file(), declarator, FALSE);\n", "\tif (func_style == FUNC_TRADITIONAL)\n", "\t    put_param_decl(func_declarator, FALSE);\n", "    }\n", "\n", "    /* Output text between function head and body. */\n", "    if (comment != 0) {\n", "\tfwrite(comment, sizeof(char), comment_len, cur_tmp_file());\n", "\tfree(comment);\n", "    }\n", "\n", "    cur_file_changed();\n", "}\n"], "project": "cproto", "file": "semantic.pkl", "function": "gen_func_definition"}, {"comment_all": {"comment": "/* realize() is called from gtk_header_bar_private_info, so make sure\n     * we special-case that. */", "depth": 1, "reading_ease": 43.39, "reading_grade": 9.9, "line": 897}, "comment_text": "/* realize() is called from gtk_header_bar_private_info, so make sure\n     * we special-case that. */", "comment_tokens": ["realize", "(", ")", "is", "called", "from", "gtk_header_bar_private_info", ",", "so", "make", "sure", "we", "special-case", "that", "."], "ccode": ["\n", "static gtk_header_bar_realize_t orig_gtk_header_bar_realize = NULL;\n", "static void fake_gtk_header_bar_realize (GtkWidget *widget)\n", "{\n", "    gtk_header_bar_private_info_t info;\n", "    GtkSettings *settings;\n", "\n", "    orig_gtk_header_bar_realize (widget);\n", "    settings = gtk_widget_get_settings (widget);\n", "\n", "    /* realize() is called from gtk_header_bar_private_info, so make sure\n", "     * we special-case that. */\n", "    if (G_UNLIKELY (TLSD->in_info_collect))\n", "        return;\n", "\n", "    info = gtk_header_bar_private_info ();\n", "    if (info.decoration_layout_offset == (gsize) -1 || info.decoration_layout_offset == (gsize) -2)\n", "        return;\n", "\n", "    /* Replace signal handlers with our own */\n", "    g_signal_handlers_disconnect_by_func (settings, info.update_window_buttons, widget);\n", "    g_signal_connect_swapped (settings, \"notify::gtk-shell-shows-app-menu\", G_CALLBACK (_gtk_header_bar_update_window_buttons), widget);\n", "    g_signal_connect_swapped (settings, \"notify::gtk-decoration-layout\", G_CALLBACK (_gtk_header_bar_update_window_buttons), widget);\n", "    _gtk_header_bar_update_window_buttons (GTK_HEADER_BAR (widget));\n", "}\n"], "project": "gtk3-nocsd", "file": "gtk3-nocsd.pkl", "function": "fake_gtk_header_bar_realize"}, {"comment_all": {"comment": "/* force an update next round (we'll be past the delta) */", "depth": 1, "reading_ease": 103.63, "reading_grade": 1.3, "line": 287}, "comment_text": "/* force an update next round (we'll be past the delta) */", "comment_tokens": ["force", "an", "update", "next", "round", "(", "we", "'ll", "be", "past", "the", "delta", ")"], "ccode": ["\n", "\n", "void\n", "opal_progress_event_users_increment(void)\n", "{\n", "#if OPAL_ENABLE_DEBUG\n", "    int32_t val;\n", "    val = opal_atomic_add_fetch_32(&num_event_users, 1);\n", "\n", "    OPAL_OUTPUT((debug_output, \"progress: event_users_increment setting count to %d\", val));\n", "#else\n", "    (void)opal_atomic_add_fetch_32(&num_event_users, 1);\n", "#endif\n", "\n", "#if OPAL_PROGRESS_USE_TIMERS\n", "    /* force an update next round (we'll be past the delta) */\n", "    event_progress_last_time -= event_progress_delta;\n", "#else\n", "    /* always reset the tick rate - can't hurt */\n", "    event_progress_counter = 0;\n", "#endif\n", "}\n"], "project": "openmpi-bin", "file": "opal_progress.pkl", "function": "opal_progress_event_users_increment"}, {"comment_all": {"comment": "/* static allocation of return value */", "depth": 1, "reading_ease": 15.64, "reading_grade": 12.3, "line": 503}, "comment_text": "/* static allocation of return value */", "comment_tokens": ["static", "allocation", "of", "return", "value"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  A function to return a safe C identifier from an XML tag or attribute name.\n", "\n", "  char *safe Returns the safe name in a private string (only use once).\n", "\n", "  const char *name The name to convert.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "static char *safe(const char *name)\n", "{\n", " static char *safe=NULL; /* static allocation of return value */\n", " int i;\n", "\n", " safe=realloc(safe,strlen(name)+1);\n", "\n", " for(i=0;name[i];i++)\n", "    if(isalnum(name[i]))\n", "       safe[i]=name[i];\n", "    else\n", "       safe[i]='_';\n", "\n", " safe[i]=0;\n", "\n", " return(safe);\n", "}\n"], "project": "libroutino-slim0", "file": "xsd-to-xmlparser.pkl", "function": "safe"}, {"comment_all": {"comment": "/* Like dup, but do not return STDIN_FILENO, STDOUT_FILENO, or\n   STDERR_FILENO.  If FLAG contains O_CLOEXEC, behave like\n   fcntl(F_DUPFD_CLOEXEC) rather than fcntl(F_DUPFD).  */", "depth": 0, "reading_ease": 52.87, "reading_grade": 8.4, "line": 28}, "comment_text": "/* Like dup, but do not return STDIN_FILENO, STDOUT_FILENO, or\n   STDERR_FILENO.  If FLAG contains O_CLOEXEC, behave like\n   fcntl(F_DUPFD_CLOEXEC) rather than fcntl(F_DUPFD).  */", "comment_tokens": ["Like", "dup", ",", "but", "do", "not", "return", "STDIN_FILENO", ",", "STDOUT_FILENO", ",", "or", "STDERR_FILENO", ".", "If", "FLAG", "contains", "O_CLOEXEC", ",", "behave", "like", "fcntl", "(", "F_DUPFD_CLOEXEC", ")", "rather", "than", "fcntl", "(", "F_DUPFD", ")", "."], "ccode": ["/* Duplicate a file descriptor result, avoiding clobbering\n", "   STD{IN,OUT,ERR}_FILENO, with specific flags.\n", "\n", "   Copyright (C) 2001, 2004-2006, 2009-2019 Free Software Foundation, Inc.\n", "\n", "   This program is free software: you can redistribute it and/or modify\n", "   it under the terms of the GNU General Public License as published by\n", "   the Free Software Foundation; either version 3 of the License, or\n", "   (at your option) any later version.\n", "\n", "   This program is distributed in the hope that it will be useful,\n", "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "   GNU General Public License for more details.\n", "\n", "   You should have received a copy of the GNU General Public License\n", "   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n", "\n", "/* Written by Paul Eggert and Eric Blake.  */\n", "\n", "#include <config.h>\n", "\n", "/* Specification.  */\n", "#include \"unistd-safer.h\"\n", "\n", "#include <fcntl.h>\n", "#include <unistd.h>\n", "\n", "/* Like dup, but do not return STDIN_FILENO, STDOUT_FILENO, or\n", "   STDERR_FILENO.  If FLAG contains O_CLOEXEC, behave like\n", "   fcntl(F_DUPFD_CLOEXEC) rather than fcntl(F_DUPFD).  */\n", "\n", "int\n", "dup_safer_flag (int fd, int flag)\n", "{\n", "  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n", "                STDERR_FILENO + 1);\n", "}\n"], "project": "grub-ieee1275-bin", "file": "dup-safer-flag.pkl", "function": "dup_safer_flag"}, {"comment_all": {"comment": "/*\n * Set a mapping between program,version and port.\n * Calls the pmap service remotely to do the mapping.\n */", "depth": 0, "reading_ease": 71.82, "reading_grade": 5.2, "line": 50}, "comment_text": "/*\n * Set a mapping between program,version and port.\n * Calls the pmap service remotely to do the mapping.\n */", "comment_tokens": ["Set", "a", "mapping", "between", "program", ",", "version", "and", "port", ".", "Calls", "the", "pmap", "service", "remotely", "to", "do", "the", "mapping", "."], "ccode": ["/* @(#)pmap_clnt.c\t2.2 88/08/01 4.0 RPCSRC */\n", "/*\n", " * Sun RPC is a product of Sun Microsystems, Inc. and is provided for\n", " * unrestricted use provided that this legend is included on all tape\n", " * media and as a part of the software program in whole or part.  Users\n", " * may copy or modify Sun RPC without charge, but are not authorized\n", " * to license or distribute it to anyone else except as part of a product or\n", " * program developed by the user.\n", " * \n", " * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE\n", " * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR\n", " * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.\n", " * \n", " * Sun RPC is provided with no support and without any obligation on the\n", " * part of Sun Microsystems, Inc. to assist in its use, correction,\n", " * modification or enhancement.\n", " * \n", " * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE\n", " * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC\n", " * OR ANY PART THEREOF.\n", " * \n", " * In no event will Sun Microsystems, Inc. be liable for any lost revenue\n", " * or profits or other special, indirect and consequential damages, even if\n", " * Sun has been advised of the possibility of such damages.\n", " * \n", " * Sun Microsystems, Inc.\n", " * 2550 Garcia Avenue\n", " * Mountain View, California  94043\n", " */\n", "#if !defined(lint) && defined(SCCSIDS)\n", "static char sccsid[] =\n", "\n", "\t\"@(#)pmap_clnt.c 1.37 87/08/11 Copyr 1984 Sun Micro\";\n", "#endif\n", "\n", "/*\n", " * pmap_clnt.c\n", " * Client interface to pmap rpc service.\n", " *\n", " * Copyright (C) 1984, Sun Microsystems, Inc.\n", " */\n", "\n", "#include <rpc/rpc.h>\n", "#include <rpc/pmap_prot.h>\n", "#include <rpc/pmap_clnt.h>\n", "#include <unistd.h>\n", "\n", "static struct timeval timeout = { 5, 0 };\n", "static struct timeval tottimeout = { 60, 0 };\n", "\n", "/*\n", " * Set a mapping between program,version and port.\n", " * Calls the pmap service remotely to do the mapping.\n", " */\n", "bool_t pmap_set(const unsigned long program, const unsigned long version, int protocol, unsigned short port)\n", "{\n", "\tstruct sockaddr_in myaddress;\n", "\tint socket = -1;\n", "\tregister CLIENT *client;\n", "\tstruct pmap parms;\n", "\tbool_t rslt;\n", "\n", "\tget_myaddress(&myaddress);\n", "\tclient = clntudp_bufcreate(&myaddress, PMAPPROG, PMAPVERS,\n", "\t\t\t\t\t\t\t   timeout, &socket, RPCSMALLMSGSIZE,\n", "\t\t\t\t\t\t\t   RPCSMALLMSGSIZE);\n", "\tif (client == (CLIENT *) NULL)\n", "\t\treturn (FALSE);\n", "\tparms.pm_prog = program;\n", "\tparms.pm_vers = version;\n", "\tparms.pm_prot = protocol;\n", "\tparms.pm_port = port;\n", "\tif (CLNT_CALL(client, PMAPPROC_SET, (xdrproc_t)xdr_pmap, (char*)&parms, (xdrproc_t)xdr_bool, (void*)&rslt,\n", "\t\t\t\t  tottimeout) != RPC_SUCCESS) {\n", "\t\tclnt_perror(client, \"Cannot register service\");\n", "\t\treturn (FALSE);\n", "\t}\n", "\tCLNT_DESTROY(client);\n", "\t(void) close(socket);\n", "\treturn (rslt);\n", "}\n"], "project": "dietlibc-dev", "file": "pmap_clnt.pkl", "function": "pmap_set"}, {"comment_all": {"comment": "/* Return of 0 -> success, -1 -> failure. BLKGETSIZE64, BLKGETSIZE and */", "depth": 0, "reading_ease": 66.91, "reading_grade": 5.0, "line": 441}, "comment_text": "/* Return of 0 -> success, -1 -> failure. BLKGETSIZE64, BLKGETSIZE and */\n/* BLKSSZGET macros problematic (from <linux/fs.h> or <sys/mount.h>). */\n", "comment_tokens": ["Return", "of", "0", "-", ">", "success", ",", "-1", "-", ">", "failure", ".", "BLKGETSIZE64", ",", "BLKGETSIZE", "and", "BLKSSZGET", "macros", "problematic", "(", "from", "<", "linuxfs.h", ">", "or", "<", "sysmount.h", ">", ")", "."], "ccode": ["\n", "/* Return of 0 -> success, -1 -> failure. BLKGETSIZE64, BLKGETSIZE and */\n", "/* BLKSSZGET macros problematic (from <linux/fs.h> or <sys/mount.h>). */\n", "static int\n", "read_blkdev_capacity(int sg_fd, int64_t * num_sect, int * sect_sz)\n", "{\n", "#ifdef BLKSSZGET\n", "    if ((ioctl(sg_fd, BLKSSZGET, sect_sz) < 0) && (*sect_sz > 0)) {\n", "        perror(\"BLKSSZGET ioctl error\");\n", "        return -1;\n", "    } else {\n", " #ifdef BLKGETSIZE64\n", "        uint64_t ull;\n", "\n", "        if (ioctl(sg_fd, BLKGETSIZE64, &ull) < 0) {\n", "\n", "            perror(\"BLKGETSIZE64 ioctl error\");\n", "            return -1;\n", "        }\n", "        *num_sect = ((int64_t)ull / (int64_t)*sect_sz);\n", " #else\n", "        unsigned long ul;\n", "\n", "        if (ioctl(sg_fd, BLKGETSIZE, &ul) < 0) {\n", "            perror(\"BLKGETSIZE ioctl error\");\n", "            return -1;\n", "        }\n", "        *num_sect = (int64_t)ul;\n", " #endif\n", "    }\n", "    return 0;\n", "#else\n", "    *num_sect = 0;\n", "    *sect_sz = 0;\n", "    return -1;\n", "#endif\n", "}\n"], "project": "libsgutils2-2", "file": "sgp_dd.pkl", "function": "read_blkdev_capacity"}, {"comment_all": {"comment": "/* assume they know what they are doing */", "depth": 1, "reading_ease": 89.75, "reading_grade": 2.5, "line": 244}, "comment_text": "/* assume they know what they are doing */", "comment_tokens": ["assume", "they", "know", "what", "they", "are", "doing"], "ccode": ["\n", "int ipath_sysfs_port_open(uint32_t unit, uint32_t port, const char *attr,\n", "\tint flags)\n", "{\n", "    int saved_errno;\n", "    char buf[1024];\n", "    int fd;\n", "    int len, l;\n", "\n", "    snprintf(buf, sizeof(buf), \"%s\", ipath_sysfs_path());\n", "    len = l = strlen(buf) - 1;\n", "    while(l > 0 && isdigit(buf[l]))\n", "\tl--;\n", "    if(l)\n", "\tbuf[++l] = 0;\n", "    else\n", "\tl = len; /* assume they know what they are doing */\n", "    snprintf(buf+l, sizeof(buf)-l, \"%u/ports/%u/%s\", unit, port, attr);\n", "    fd = open(buf, flags);\n", "    saved_errno = errno;\n", "\n", "    if (fd == -1) {\n", "        _IPATH_DBG(\"Failed to open attribute '%s' of unit %d:%d: %s\\n\", attr,\n", "                   unit, port, strerror(errno));\n", "        _IPATH_DBG(\"Offending file name: %s\\n\", buf);\n", "    }\n", "\n", "    errno = saved_errno;\n", "    return fd;\n", "}\n"], "project": "libpsm-infinipath1-dbg", "file": "ipath_sysfs.pkl", "function": "ipath_sysfs_port_open"}, {"comment_all": {"comment": "/* We must open the file, then seek to specified position */", "depth": 2, "reading_ease": 78.25, "reading_grade": 4.8, "line": 504}, "comment_text": "/* We must open the file, then seek to specified position */", "comment_tokens": ["We", "must", "open", "the", "file", ",", "then", "seek", "to", "specified", "position"], "ccode": ["\n", "/***************************************************************/\n", "/*                                                             */\n", "/*  PopFile - we've reached the end.  Pop up to the previous   */\n", "/*  file, or return E_EOF                                      */\n", "/*                                                             */\n", "/***************************************************************/\n", "static int PopFile(void)\n", "{\n", "    IncludeStruct *i;\n", "\n", "    /* Assume we own the file for now */\n", "    RunDisabled &= ~RUN_NOTOWNER;\n", "\n", "    if (!Hush && NumIfs) Eprint(\"%s\", ErrMsg[E_MISS_ENDIF]);\n", "    if (!IStackPtr) return E_EOF;\n", "    i = &IStack[IStackPtr-1];\n", "\n", "    if (i->chain) {\n", "\tint oldRunDisabled = RunDisabled;\n", "\tif (NextChainedFile(i) == OK) {\n", "\t    return OK;\n", "\t}\n", "\tRunDisabled = oldRunDisabled;\n", "    }\n", "\n", "    if (IStackPtr <= 1) {\n", "\treturn E_EOF;\n", "    }\n", "\n", "    IStackPtr--;\n", "\n", "    LineNo = i->LineNo;\n", "    IfFlags = i->IfFlags;\n", "    NumIfs = i->NumIfs;\n", "    CLine = i->CLine;\n", "    fp = NULL;\n", "    STRSET(FileName, i->filename);\n", "    if (!i->ownedByMe) {\n", "\tRunDisabled |= RUN_NOTOWNER;\n", "    }\n", "    if (!CLine && (i->offset != -1L)) {\n", "\t/* We must open the file, then seek to specified position */\n", "\tif (strcmp(i->filename, \"-\")) {\n", "\t    fp = fopen(i->filename, \"r\");\n", "\t    if (!fp || !CheckSafety()) return E_CANT_OPEN;\n", "\t    if (PurgeMode) OpenPurgeFile(i->filename, \"a\");\n", "\t} else {\n", "\t    fp = stdin;\n", "\t    if (PurgeMode) PurgeFP = stdout;\n", "\t}\n", "\tif (fp != stdin)\n", "\t    (void) fseek(fp, i->offset, 0);  /* Trust that it works... */\n", "    }\n", "    free((char *) i->filename);\n", "    return OK;\n", "}\n"], "project": "remind", "file": "files.pkl", "function": "PopFile"}, {"comment_all": {"comment": "/*  Arg_parser - POSIX/GNU command line argument parser. (C version)\n    Copyright (C) 2006-2019 Antonio Diaz Diaz.\n\n    This library is free software. Redistribution and use in source and\n    binary forms, with or without modification, are permitted provided\n    that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n*/", "depth": 0, "reading_ease": 37.6, "reading_grade": 12.2, "line": 0}, "comment_text": "/*  Arg_parser - POSIX/GNU command line argument parser. (C version)\n    Copyright (C) 2006-2019 Antonio Diaz Diaz.\n\n    This library is free software. Redistribution and use in source and\n    binary forms, with or without modification, are permitted provided\n    that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n*/", "comment_tokens": ["Arg_parser", "-", "POSIXGNU", "command", "line", "argument", "parser", ".", "(", "C", "version", ")", "Copyright", "(", "C", ")", "2006-2019", "Antonio", "Diaz", "Diaz", ".", "This", "library", "is", "free", "software", ".", "Redistribution", "and", "use", "in", "source", "and", "binary", "forms", ",", "with", "or", "without", "modification", ",", "are", "permitted", "provided", "that", "the", "following", "conditions", "are", "met", ":", "1", ".", "Redistributions", "of", "source", "code", "must", "retain", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", ".", "2", ".", "Redistributions", "in", "binary", "form", "must", "reproduce", "the", "above", "copyright", "notice", ",", "this", "list", "of", "conditions", "and", "the", "following", "disclaimer", "in", "the", "documentation", "andor", "other", "materials", "provided", "with", "the", "distribution", ".", "This", "library", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "."], "ccode": ["/*  Arg_parser - POSIX/GNU command line argument parser. (C version)\n", "    Copyright (C) 2006-2019 Antonio Diaz Diaz.\n", "\n", "    This library is free software. Redistribution and use in source and\n", "    binary forms, with or without modification, are permitted provided\n", "    that the following conditions are met:\n", "\n", "    1. Redistributions of source code must retain the above copyright\n", "    notice, this list of conditions and the following disclaimer.\n", "\n", "    2. Redistributions in binary form must reproduce the above copyright\n", "    notice, this list of conditions and the following disclaimer in the\n", "    documentation and/or other materials provided with the distribution.\n", "\n", "    This library is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", "*/\n", "\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "#include \"carg_parser.h\"\n", "\n", "\n", "/* assure at least a minimum size for buffer 'buf' */\n", "static void * ap_resize_buffer( void * buf, const int min_size )\n", "  {\n", "  if( buf ) buf = realloc( buf, min_size );\n", "  else buf = malloc( min_size );\n", "  return buf;\n", "  }\n"], "project": "pdlzip", "file": "carg_parser.pkl", "function": "ap_resize_buffer"}, {"comment_all": {"comment": "/* Call s48_free_area on all areas in the list starting with START */", "depth": 0, "reading_ease": 94.15, "reading_grade": 2.9, "line": 147}, "comment_text": "/* Call s48_free_area on all areas in the list starting with START */", "comment_tokens": ["Call", "s48_free_area", "on", "all", "areas", "in", "the", "list", "starting", "with", "START"], "ccode": ["\n", "/* Call s48_free_area on all areas in the list starting with START */\n", "void s48_free_areas(Area* start) {\n", "  while (start != NULL) {\n", "    Area* next = start->next;\n", "    s48_free_area(start);\n", "    start = next;\n", "  }\n", "}\n"], "project": "scheme48-doc", "file": "areas.pkl", "function": "s48_free_areas"}, {"comment_all": {"comment": "/* After all that talk, this was set to 1 anyways... */", "depth": 2, "reading_ease": 95.17, "reading_grade": 2.5, "line": 3791}, "comment_text": "/* After all that talk, this was set to 1 anyways... */", "comment_tokens": ["After", "all", "that", "talk", ",", "this", "was", "set", "to", "1", "anyways", "..."], "ccode": ["\n", "/* Allocates the stack if it does not exist.\n", " *  Guarantees space for at least one push.\n", " */\n", "static void yyensure_buffer_stack (void)\n", "{\n", "\tyy_size_t num_to_alloc;\n", "    \n", "\tif (!(yy_buffer_stack)) {\n", "\n", "\t\t/* First allocation is just for 2 elements, since we don't know if this\n", "\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n", "\t\t * immediate realloc on the next call.\n", "         */\n", "      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n", "\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n", "\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t\t(yy_buffer_stack_top) = 0;\n", "\t\treturn;\n", "\t}\n", "\n", "\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n", "\n", "\t\t/* Increase the buffer to prepare for a possible push. */\n", "\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n", "\n", "\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n", "\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n", "\t\t\t\t\t\t\t\t((yy_buffer_stack),\n", "\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n", "\t\t\t\t\t\t\t\t);\n", "\t\tif ( ! (yy_buffer_stack) )\n", "\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n", "\n", "\t\t/* zero only the new slots.*/\n", "\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n", "\t\t(yy_buffer_stack_max) = num_to_alloc;\n", "\t}\n", "}\n"], "project": "linux-cloud-tools-5.11.0-1028-azure", "file": "lexer.lex.pkl", "function": "yyensure_buffer_stack"}, {"comment_all": {"comment": "/*---                                            compress.c ---*/", "depth": 0, "reading_ease": 36.62, "reading_grade": 8.4, "line": 3}, "comment_text": "/*--- Compression machinery (not incl block sorting)        ---*/\n/*---                                            compress.c ---*/\n", "comment_tokens": ["--", "-", "Compression", "machinery", "(", "not", "incl", "block", "sorting", ")", "--", "-", "--", "-", "compress.c", "--", "-"], "ccode": ["\n", "/*-------------------------------------------------------------*/\n", "/*--- Compression machinery (not incl block sorting)        ---*/\n", "/*---                                            compress.c ---*/\n", "/*-------------------------------------------------------------*/\n", "\n", "/* ------------------------------------------------------------------\n", "   This file is part of bzip2/libbzip2, a program and library for\n", "   lossless, block-sorting data compression.\n", "\n", "   bzip2/libbzip2 version 1.0.8 of 13 July 2019\n", "   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>\n", "\n", "   Please read the WARNING, DISCLAIMER and PATENTS sections in the \n", "   README file.\n", "\n", "   This program is released under the terms of the license contained\n", "   in the file LICENSE.\n", "   ------------------------------------------------------------------ */\n", "\n", "\n", "/* CHANGES\n", "    0.9.0    -- original version.\n", "    0.9.0a/b -- no changes in this file.\n", "    0.9.0c   -- changed setting of nGroups in sendMTFValues() \n", "                so as to do a bit better on small files\n", "*/\n", "\n", "#include \"bzlib_private.h\"\n", "\n", "\n", "/*---------------------------------------------------*/\n", "/*--- Bit stream I/O                              ---*/\n", "/*---------------------------------------------------*/\n", "\n", "/*---------------------------------------------------*/\n", "void BZ2_bsInitWrite ( EState* s )\n", "{\n", "   s->bsLive = 0;\n", "   s->bsBuff = 0;\n", "}\n"], "project": "bzip2-doc", "file": "compress.pkl", "function": "BZ2_bsInitWrite"}, {"comment_all": {"comment": "/* \":cscope kill\" accepts connection numbers or partial names of\n\t     * the pathname of the cscope database as argument.  Only complete\n\t     * with connection numbers. -1 can also be used to kill all\n\t     * connections. */", "depth": 3, "reading_ease": 69.48, "reading_grade": 6.1, "line": 130}, "comment_text": "/* \":cscope kill\" accepts connection numbers or partial names of\n\t     * the pathname of the cscope database as argument.  Only complete\n\t     * with connection numbers. -1 can also be used to kill all\n\t     * connections. */", "comment_tokens": ["``", ":", "cscope", "kill", "''", "accepts", "connection", "numbers", "or", "partial", "names", "of", "the", "pathname", "of", "the", "cscope", "database", "as", "argument", ".", "Only", "complete", "with", "connection", "numbers", ".", "-1", "can", "also", "be", "used", "to", "kill", "all", "connections", "."], "ccode": ["\n", "/*\n", " * Function given to ExpandGeneric() to obtain the cscope command\n", " * expansion.\n", " */\n", "    char_u *\n", "get_cscope_name(expand_T *xp UNUSED, int idx)\n", "{\n", "    int\t\tcurrent_idx;\n", "    int\t\ti;\n", "\n", "    switch (expand_what)\n", "    {\n", "    case EXP_CSCOPE_SUBCMD:\n", "\t/* Complete with sub-commands of \":cscope\":\n", "\t * add, find, help, kill, reset, show */\n", "\treturn (char_u *)cs_cmds[idx].name;\n", "    case EXP_SCSCOPE_SUBCMD:\n", "\t/* Complete with sub-commands of \":scscope\": same sub-commands as\n", "\t * \":cscope\" but skip commands which don't support split windows */\n", "\tfor (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)\n", "\t    if (cs_cmds[i].cansplit)\n", "\t\tif (current_idx++ == idx)\n", "\t\t    break;\n", "\treturn (char_u *)cs_cmds[i].name;\n", "    case EXP_CSCOPE_FIND:\n", "\t{\n", "\t    const char *query_type[] =\n", "\t    {\n", "\t\t\"a\", \"c\", \"d\", \"e\", \"f\", \"g\", \"i\", \"s\", \"t\", NULL\n", "\t    };\n", "\n", "\t    /* Complete with query type of \":cscope find {query_type}\".\n", "\t     * {query_type} can be letters (c, d, ... a) or numbers (0, 1,\n", "\t     * ..., 9) but only complete with letters, since numbers are\n", "\t     * redundant. */\n", "\t    return (char_u *)query_type[idx];\n", "\t}\n", "    case EXP_CSCOPE_KILL:\n", "\t{\n", "\t    static char\tconnection[5];\n", "\n", "\t    /* \":cscope kill\" accepts connection numbers or partial names of\n", "\t     * the pathname of the cscope database as argument.  Only complete\n", "\t     * with connection numbers. -1 can also be used to kill all\n", "\t     * connections. */\n", "\t    for (i = 0, current_idx = 0; i < csinfo_size; i++)\n", "\t    {\n", "\t\tif (csinfo[i].fname == NULL)\n", "\t\t    continue;\n", "\t\tif (current_idx++ == idx)\n", "\t\t{\n", "\t\t    vim_snprintf(connection, sizeof(connection), \"%d\", i);\n", "\t\t    return (char_u *)connection;\n", "\t\t}\n", "\t    }\n", "\t    return (current_idx == idx && idx > 0) ? (char_u *)\"-1\" : NULL;\n", "\t}\n", "    default:\n", "\treturn NULL;\n", "    }\n", "}\n"], "project": "vim-athena", "file": "if_cscope.pkl", "function": "get_cscope_name"}, {"comment_all": {"comment": "/*\n\nCopyright 1987, 1994, 1998  The Open Group\n\nPermission to use, copy, modify, distribute, and sell this software and its\ndocumentation for any purpose is hereby granted without fee, provided that\nthe above copyright notice appear in all copies and that both that\ncopyright notice and this permission notice appear in supporting\ndocumentation.\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nOPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nExcept as contained in this notice, the name of The Open Group shall not be\nused in advertising or otherwise to promote the sale, use or other dealings\nin this Software without prior written authorization from The Open Group.\n\n*/", "depth": 0, "reading_ease": 33.92, "reading_grade": 17.7, "line": 26}, "comment_text": "/*\n\nCopyright 1987, 1994, 1998  The Open Group\n\nPermission to use, copy, modify, distribute, and sell this software and its\ndocumentation for any purpose is hereby granted without fee, provided that\nthe above copyright notice appear in all copies and that both that\ncopyright notice and this permission notice appear in supporting\ndocumentation.\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nOPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nExcept as contained in this notice, the name of The Open Group shall not be\nused in advertising or otherwise to promote the sale, use or other dealings\nin this Software without prior written authorization from The Open Group.\n\n*/", "comment_tokens": ["Copyright", "1987", ",", "1994", ",", "1998", "The", "Open", "Group", "Permission", "to", "use", ",", "copy", ",", "modify", ",", "distribute", ",", "and", "sell", "this", "software", "and", "its", "documentation", "for", "any", "purpose", "is", "hereby", "granted", "without", "fee", ",", "provided", "that", "the", "above", "copyright", "notice", "appear", "in", "all", "copies", "and", "that", "both", "that", "copyright", "notice", "and", "this", "permission", "notice", "appear", "in", "supporting", "documentation", ".", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "OPEN", "GROUP", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", ".", "Except", "as", "contained", "in", "this", "notice", ",", "the", "name", "of", "The", "Open", "Group", "shall", "not", "be", "used", "in", "advertising", "or", "otherwise", "to", "promote", "the", "sale", ",", "use", "or", "other", "dealings", "in", "this", "Software", "without", "prior", "written", "authorization", "from", "The", "Open", "Group", "."], "ccode": ["\n", "/*\n", " * Copyright 1990 Network Computing Devices;\n", " * Portions Copyright 1987 by Digital Equipment Corporation\n", " *\n", " * Permission to use, copy, modify, distribute, and sell this software\n", " * and its documentation for any purpose is hereby granted without fee,\n", " * provided that the above copyright notice appear in all copies and\n", " * that both that copyright notice and this permission notice appear\n", " * in supporting documentation, and that the names of Network Computing\n", " * Devices or Digital not be used in advertising or publicity pertaining\n", " * to distribution of the software without specific, written prior\n", " * permission. Network Computing Devices or Digital make no representations\n", " * about the suitability of this software for any purpose.  It is provided\n", " * \"as is\" without express or implied warranty.\n", " *\n", " * NETWORK COMPUTING DEVICES AND  DIGITAL DISCLAIM ALL WARRANTIES WITH\n", " * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\n", " * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES\n", " * OR DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES\n", " * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n", " * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n", " * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n", " * SOFTWARE.\n", " */\n", "\n", "/*\n", "\n", "Copyright 1987, 1994, 1998  The Open Group\n", "\n", "Permission to use, copy, modify, distribute, and sell this software and its\n", "documentation for any purpose is hereby granted without fee, provided that\n", "the above copyright notice appear in all copies and that both that\n", "copyright notice and this permission notice appear in supporting\n", "documentation.\n", "\n", "The above copyright notice and this permission notice shall be included in\n", "all copies or substantial portions of the Software.\n", "\n", "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n", "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n", "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n", "OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n", "AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n", "CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "\n", "Except as contained in this notice, the name of The Open Group shall not be\n", "used in advertising or otherwise to promote the sale, use or other dealings\n", "in this Software without prior written authorization from The Open Group.\n", "\n", "*/\n", "#ifdef HAVE_CONFIG_H\n", "#include <config.h>\n", "#endif\n", "#include\t\"FSlibint.h\"\n", "\n", "int FSFlush(FSServer *svr)\n", "{\n", "    _FSFlush(svr);\n", "    return 1;\n", "}\n"], "project": "libfs6-dbg", "file": "FSFlush.pkl", "function": "FSFlush"}, {"comment_all": {"comment": "/* ELSE RM encodes a general register */", "depth": 3, "reading_ease": 48.47, "reading_grade": 8.0, "line": 262}, "comment_text": "/* modR/M specifies base register */\n/* ELSE RM encodes a general register */\n", "comment_tokens": ["modRM", "specifies", "base", "register", "ELSE", "RM", "encodes", "a", "general", "register"], "ccode": ["\n", "/* TODO : Mark index modes\n", "    Use addressing mode flags to imply arrays (index), structure (disp),\n", "    two-dimensional arrays [disp + index], classes [ea reg], and so on.\n", "*/\n", "size_t ia32_modrm_decode( unsigned char *buf, unsigned int buf_len,\n", "\t\t\t    x86_op_t *op, x86_insn_t *insn, size_t gen_regs ) {\n", "\t/* create address expression and/or fill operand based on value of\n", "\t * ModR/M byte. Calls sib_decode as appropriate.\n", "\t *    flags specifies whether Reg or mod+R/M fields are being decoded\n", "\t *  returns the number of bytes in the instruction, including modR/M */\n", "\tstruct modRM_byte modrm;\n", "\tsize_t size = 1;\t/* # of bytes decoded [1 for modR/M byte] */\n", "\tx86_ea_t * ea;\n", "\n", "\n", "\tbyte_decode(*buf, &modrm);\t/* get bitfields */\n", "\n", "\t/* first, handle the case where the mod field is a register only */\n", "\tif ( modrm.mod == MODRM_MOD_NOEA ) {\n", "\t\top->type = op_register;\n", "\t\tia32_handle_register(&op->data.reg, modrm.rm + gen_regs);\n", "                /* increase insn size by 1 for modrm byte */\n", " \t\treturn 1;\n", " \t}\n", " \n", "\t/* then deal with cases where there is an effective address */\n", "\tea = &op->data.expression;\n", "\top->type = op_expression;\n", "\top->flags |= op_pointer;\n", "\n", "\tif ( insn->addr_size == 2 ) {\n", "\t\t/* gah! 16 bit mode! */\n", "\t\treturn modrm_decode16( buf, buf_len, op, &modrm);\n", "\t}\n", "\n", "\t/* move to byte after ModR/M */\n", "\t++buf;\n", "\t--buf_len;\n", "\n", "\tif (modrm.mod == MODRM_MOD_NODISP) {\t/* if mod == 00 */\n", "\n", "\t\t/* IF MOD == No displacement, just Indirect Register */\n", "\t\tif (modrm.rm == MODRM_RM_NOREG) {\t/* if r/m == 101 */\n", "\t\t\t/* IF RM == No Register, just Displacement */\n", "\t\t\t/* This is an Intel Moronic Exception TM */\n", "\t\t\timm32_signsized( buf, buf_len, &ea->disp, \n", "\t\t\t\t\tsizeof(int32_t) );\n", "\t\t\tea->disp_size = sizeof(int32_t);\n", "\t\t\tea->disp_sign = (ea->disp < 0) ? 1 : 0;\n", "\t\t\tsize += 4;\t/* add sizeof disp to count */\n", "\n", "\t\t} else if (modrm.rm == MODRM_RM_SIB) {\t/* if r/m == 100 */\n", "\t\t\t/* ELSE IF an SIB byte is present */\n", "\t\t\t/* TODO: check for 0 retval */\n", "\t\t\tsize += sib_decode( buf, buf_len, ea, modrm.mod);\n", "\t\t\t/* move to byte after SIB for displacement */\n", "\t\t\t++buf;\n", "\t\t\t--buf_len;\n", "\t\t} else {\t/* modR/M specifies base register */\n", "\t\t\t/* ELSE RM encodes a general register */\n", "\t\t\tia32_handle_register( &ea->base, modrm.rm + 1 );\n", "\t\t}\n", "\t} else { \t\t\t\t\t/* mod is 01 or 10 */\n", "\t\tif (modrm.rm == MODRM_RM_SIB) {\t/* rm == 100 */\n", "\t\t\t/* IF base is an AddrExpr specified by an SIB byte */\n", "\t\t\t/* TODO: check for 0 retval */\n", "\t\t\tsize += sib_decode( buf, buf_len, ea, modrm.mod);\n", "\t\t\t/* move to byte after SIB for displacement */\n", "\t\t\t++buf;\n", "\t\t\t--buf_len;\n", "\t\t} else {\n", "\t\t\t/* ELSE base is a general register */\n", "\t\t\tia32_handle_register( &ea->base, modrm.rm + 1 );\n", "\t\t}\n", "\n", "\t\t/* ELSE mod + r/m specify a disp##[base] or disp##(SIB) */\n", "\t\tif (modrm.mod == MODRM_MOD_DISP8) {\t\t/* mod == 01 */\n", "\t\t\t/* If this is an 8-bit displacement */\n", "\t\t\timm32_signsized( buf, buf_len, &ea->disp, \n", "\t\t\t\t\tsizeof(char));\n", "\t\t\tea->disp_size = sizeof(char);\n", "\t\t\tea->disp_sign = (ea->disp < 0) ? 1 : 0;\n", "\t\t\tsize += 1;\t/* add sizeof disp to count */\n", "\n", "\t\t} else {\n", "\t\t\t/* Displacement is dependent on address size */\n", "\t\t\timm32_signsized( buf, buf_len, &ea->disp, \n", "\t\t\t\t\tinsn->addr_size);\n", "\t\t\tea->disp_size = insn->addr_size;\n", "\t\t\tea->disp_sign = (ea->disp < 0) ? 1 : 0;\n", "\t\t\tsize += 4;\n", "\t\t}\n", "\t}\n", "\n", "\treturn size;\t\t/* number of bytes found in instruction */\n", "}\n"], "project": "libdisasm0", "file": "ia32_modrm.pkl", "function": "ia32_modrm_decode"}, {"comment_all": {"comment": "/*\n     *  Adjust box size and indentmode to command line specification\n     *  Increase box width/height by width/height of empty sides in order\n     *  to match appearance of box with the user's expectations (if -s).\n     */", "depth": 1, "reading_ease": 41.03, "reading_grade": 15.0, "line": 1580}, "comment_text": "/*\n     *  Adjust box size and indentmode to command line specification\n     *  Increase box width/height by width/height of empty sides in order\n     *  to match appearance of box with the user's expectations (if -s).\n     */", "comment_tokens": ["Adjust", "box", "size", "and", "indentmode", "to", "command", "line", "specification", "Increase", "box", "widthheight", "by", "widthheight", "of", "empty", "sides", "in", "order", "to", "match", "appearance", "of", "box", "with", "the", "user", "'s", "expectations", "(", "if", "-s", ")", "."], "ccode": ["\n", "\n", "/*       _\\|/_\n", "         (o o)\n", " +----oOO-{_}-OOo------------------------------------------------------------+\n", " |                       P r o g r a m   S t a r t                           |\n", " +--------------------------------------------------------------------------*/\n", "\n", "int main (int argc, char *argv[])\n", "{\n", "    int    rc;                           /* general return code */\n", "    size_t pad;\n", "    int    i;\n", "    int    saved_designwidth;            /* opt.design->minwith backup, used for mending */\n", "    int    saved_designheight;           /* opt.design->minheight backup, used for mending */\n", "\n", "    #ifdef DEBUG\n", "        fprintf (stderr, \"BOXES STARTING ...\\n\");\n", "    #endif\n", "\n", "    /*\n", "     *  Process command line options\n", "     */\n", "    #ifdef DEBUG\n", "        fprintf (stderr, \"Processing Command Line ...\\n\");\n", "    #endif\n", "    rc = process_commandline (argc, argv);\n", "    if (rc == 42)\n", "        exit (EXIT_SUCCESS);\n", "    if (rc)\n", "        exit (EXIT_FAILURE);\n", "\n", "    /*\n", "     *  Parse config file, then reset design pointer\n", "     */\n", "    #ifdef DEBUG\n", "        fprintf (stderr, \"Parsing Config File ...\\n\");\n", "    #endif\n", "    if (opt.cld == NULL) {\n", "        rc = yyparse();\n", "        if (rc)\n", "            exit (EXIT_FAILURE);\n", "    }\n", "    else {\n", "        rc = build_design (&designs, opt.cld);\n", "        if (rc)\n", "            exit (EXIT_FAILURE);\n", "        anz_designs = 1;\n", "    }\n", "    BFREE (opt.design);\n", "    opt.design = designs;\n", "\n", "    /*\n", "     *  If \"-l\" option was given, list styles and exit.\n", "     */\n", "    if (opt.l) {\n", "        rc = list_styles();\n", "        exit (rc);\n", "    }\n", "\n", "    /*\n", "     *  Adjust box size and indentmode to command line specification\n", "     *  Increase box width/height by width/height of empty sides in order\n", "     *  to match appearance of box with the user's expectations (if -s).\n", "     */\n", "    if (opt.reqheight > (long) opt.design->minheight)\n", "        opt.design->minheight = opt.reqheight;\n", "    if (opt.reqwidth > (long) opt.design->minwidth)\n", "        opt.design->minwidth = opt.reqwidth;\n", "    if (opt.reqwidth) {\n", "        if (empty_side (opt.design->shape, BRIG))\n", "            opt.design->minwidth  += opt.design->shape[SE].width;\n", "        if (empty_side (opt.design->shape, BLEF))\n", "            opt.design->minwidth  += opt.design->shape[NW].width;\n", "    }\n", "    if (opt.reqheight) {\n", "        if (empty_side (opt.design->shape, BTOP))\n", "            opt.design->minheight += opt.design->shape[NW].height;\n", "        if (empty_side (opt.design->shape, BBOT))\n", "            opt.design->minheight += opt.design->shape[SE].height;\n", "    }\n", "    if (opt.indentmode)\n", "        opt.design->indentmode = opt.indentmode;\n", "    saved_designwidth = opt.design->minwidth;\n", "    saved_designheight = opt.design->minheight;\n", "\n", "    do {\n", "        if (opt.mend == 1)  /* Mending a box works in two phases: */\n", "            opt.r = 0;      /* opt.mend == 2: remove box          */\n", "        --opt.mend;         /* opt.mend == 1: add it back         */\n", "        opt.design->minwidth = saved_designwidth;\n", "        opt.design->minheight = saved_designheight;\n", "\n", "        /*\n", "         *  Read input lines\n", "         */\n", "        #ifdef DEBUG\n", "            fprintf (stderr, \"Reading all input ...\\n\");\n", "        #endif\n", "        rc = read_all_input (opt.mend);\n", "        if (rc)\n", "            exit (EXIT_FAILURE);\n", "        if (input.anz_lines == 0)\n", "            exit (EXIT_SUCCESS);\n", "\n", "        /*\n", "         *  Adjust box size to fit requested padding value\n", "         *  Command line-specified box size takes precedence over padding.\n", "         */\n", "        for (i=0; i<ANZ_SIDES; ++i) {\n", "            if (opt.padding[i] > -1)\n", "                opt.design->padding[i] = opt.padding[i];\n", "        }\n", "        pad  = opt.design->padding[BTOP] + opt.design->padding[BBOT];\n", "        if (pad > 0) {\n", "            pad += input.anz_lines;\n", "            pad += opt.design->shape[NW].height + opt.design->shape[SW].height;\n", "            if (pad > opt.design->minheight) {\n", "                if (opt.reqheight) {\n", "                    for (i=0; i<(int)(pad-opt.design->minheight); ++i) {\n", "                        if (opt.design->padding[i%2?BBOT:BTOP])\n", "                            opt.design->padding[i%2?BBOT:BTOP] -= 1;\n", "                        else if (opt.design->padding[i%2?BTOP:BBOT])\n", "                            opt.design->padding[i%2?BTOP:BBOT] -= 1;\n", "                        else\n", "                            break;\n", "                    }\n", "                }\n", "                else {\n", "                    opt.design->minheight = pad;\n", "                }\n", "            }\n", "        }\n", "        pad = opt.design->padding[BLEF] + opt.design->padding[BRIG];\n", "        if (pad > 0) {\n", "            pad += input.maxline;\n", "            pad += opt.design->shape[NW].width + opt.design->shape[NE].width;\n", "            if (pad > opt.design->minwidth) {\n", "                if (opt.reqwidth) {\n", "                    for (i=0; i<(int)(pad-opt.design->minwidth); ++i) {\n", "                        if (opt.design->padding[i%2?BRIG:BLEF])\n", "                            opt.design->padding[i%2?BRIG:BLEF] -= 1;\n", "                        else if (opt.design->padding[i%2?BLEF:BRIG])\n", "                            opt.design->padding[i%2?BLEF:BRIG] -= 1;\n", "                        else\n", "                            break;\n", "                    }\n", "                }\n", "                else {\n", "                    opt.design->minwidth = pad;\n", "                }\n", "            }\n", "        }\n", "\n", "        if (opt.r) {\n", "            /*\n", "             *  Remove box\n", "             */\n", "            #ifdef DEBUG\n", "                fprintf (stderr, \"Removing Box ...\\n\");\n", "            #endif\n", "            if (opt.killblank == -1) {\n", "                if (empty_side (opt.design->shape, BTOP)\n", "                        && empty_side (opt.design->shape, BBOT))\n", "                    opt.killblank = 0;\n", "                else\n", "                    opt.killblank = 1;\n", "            }\n", "            rc = remove_box();\n", "            if (rc)\n", "                exit (EXIT_FAILURE);\n", "            rc = apply_substitutions (1);\n", "            if (rc)\n", "                exit (EXIT_FAILURE);\n", "            output_input (opt.mend > 0);\n", "        }\n", "\n", "        else {\n", "            /*\n", "             *  Generate box\n", "             */\n", "            sentry_t *thebox;\n", "\n", "            #ifdef DEBUG\n", "                fprintf (stderr, \"Generating Box ...\\n\");\n", "            #endif\n", "            thebox = (sentry_t *) calloc (ANZ_SIDES, sizeof(sentry_t));\n", "            if (thebox == NULL) {\n", "                perror (PROJECT);\n", "                exit (EXIT_FAILURE);\n", "            }\n", "            rc = generate_box (thebox);\n", "            if (rc)\n", "                exit (EXIT_FAILURE);\n", "            output_box (thebox);\n", "        }\n", "    } while (opt.mend > 0);\n", "\n", "    return EXIT_SUCCESS;\n", "}\n"], "project": "boxes", "file": "boxes.pkl", "function": "main"}, {"comment_all": {"comment": "/*! \\brief Create the output makeopts file that results from the user's selections */", "depth": 0, "reading_ease": 76.22, "reading_grade": 5.6, "line": 1494}, "comment_text": "/*! \\brief Create the output makeopts file that results from the user's selections */", "comment_tokens": ["!", "\\brief", "Create", "the", "output", "makeopts", "file", "that", "results", "from", "the", "user", "'s", "selections"], "ccode": ["\n", "/*! \\brief Create the output makeopts file that results from the user's selections */\n", "static int generate_makeopts_file(void)\n", "{\n", "\tFILE *f;\n", "\tstruct category *cat;\n", "\tstruct member *mem;\n", "\tstruct reference *dep;\n", "\tstruct reference *use;\n", "\n", "\tif (!(f = fopen(output_makeopts, \"w\"))) {\n", "\t\tfprintf(stderr, \"Unable to open build configuration file (%s) for writing!\\n\", output_makeopts);\n", "\t\treturn -1;\n", "\t}\n", "\n", "\t/* Traverse all categories and members and output them as var/val pairs */\n", "\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\tfprintf(f, \"%s=\", cat->name);\n", "\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\tif (mem->is_separator) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\tif ((!cat->positive_output && (!mem->enabled || mem->depsfailed || mem->conflictsfailed)) ||\n", "\t\t\t    (cat->positive_output && mem->enabled && !mem->depsfailed && !mem->conflictsfailed))\n", "\t\t\t\tfprintf(f, \"%s \", mem->name);\n", "\t\t}\n", "\t\tfprintf(f, \"\\n\");\n", "\t}\n", "\n", "\t/* Traverse all categories and members, and for every member that is not disabled,\n", "\t   if it has internal dependencies (other members), list those members one time only\n", "\t   in a special variable */\n", "\tfprintf(f, \"MENUSELECT_BUILD_DEPS=\");\n", "\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\tif (mem->is_separator) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\tif ((!cat->positive_output && (!mem->enabled || mem->depsfailed || mem->conflictsfailed)) ||\n", "\t\t\t    (cat->positive_output && mem->enabled && !mem->depsfailed && !mem->conflictsfailed))\n", "\t\t\t\tcontinue;\n", "\n", "\t\t\tAST_LIST_TRAVERSE(&mem->deps, dep, list) {\n", "\t\t\t\t/* we only care about dependencies between members (internal, not external) */\n", "\t\t\t\tif (!dep->member)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t/* if this has already been output, continue */\n", "\t\t\t\tif (dep->member->build_deps_output)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\tfprintf(f, \"%s \", dep->member->name);\n", "\t\t\t\tdep->member->build_deps_output = 1;\n", "\t\t\t}\n", "\t\t\tAST_LIST_TRAVERSE(&mem->uses, use, list) {\n", "\t\t\t\t/* we only care about dependencies between members (internal, not external) */\n", "\t\t\t\tif (!use->member)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t/* if the dependency module is not going to be built, don't list it */\n", "\t\t\t\tif (!use->member->enabled)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\t/* if this has already been output, continue */\n", "\t\t\t\tif (use->member->build_deps_output)\n", "\t\t\t\t\tcontinue;\n", "\t\t\t\tfprintf(f, \"%s \", use->member->name);\n", "\t\t\t\tuse->member->build_deps_output = 1;\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\tfprintf(f, \"\\n\");\n", "\n", "\t/* Output which members were disabled because of failed dependencies or conflicts */\n", "\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\tif (mem->is_separator) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\tif (mem->depsfailed != HARD_FAILURE && mem->conflictsfailed != HARD_FAILURE)\n", "\t\t\t\tcontinue;\n", "\n", "\t\t\tif (!mem->defaultenabled || !strcasecmp(mem->defaultenabled, \"yes\"))\n", "\t\t\t\tfprintf(f, \"MENUSELECT_DEPSFAILED=%s=%s\\n\", cat->name, mem->name);\n", "\t\t}\n", "\t}\n", "\n", "\tfclose(f);\n", "\n", "\t/* there is no need to process remove_on_change rules if we did not have\n", "\t   configuration information to start from\n", "\t*/\n", "\tif (!existing_config)\n", "\t\treturn 0;\n", "\n", "\t/* Traverse all categories and members and remove any files that are supposed\n", "\t   to be removed when an item has been changed */\n", "\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\tunsigned int had_changes = 0;\n", "\t\tchar rmcommand[256] = \"rm -rf \";\n", "\t\tchar touchcommand[256] = \"touch -c \";\n", "\t\tchar *file, *buf;\n", "\n", "\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\tif (mem->is_separator) {\n", "\t\t\t\tcontinue;\n", "\t\t\t}\n", "\n", "\t\t\tif ((mem->enabled == mem->was_enabled) && !mem->was_defaulted)\n", "\t\t\t\tcontinue;\n", "\n", "\t\t\thad_changes = 1;\n", "\n", "\t\t\tif (mem->touch_on_change) {\n", "\t\t\t\tfor (buf = ast_strdupa(mem->touch_on_change), file = strsep(&buf, \" \");\n", "\t\t\t\t     file;\n", "\t\t\t\t     file = strsep(&buf, \" \")) {\n", "\t\t\t\t\tstrcpy(&touchcommand[9], file);\n", "\t\t\t\t\tsystem(touchcommand);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\n", "\t\t\tif (mem->remove_on_change) {\n", "\t\t\t\tfor (buf = ast_strdupa(mem->remove_on_change), file = strsep(&buf, \" \");\n", "\t\t\t\t     file;\n", "\t\t\t\t     file = strsep(&buf, \" \")) {\n", "\t\t\t\t\tstrcpy(&rmcommand[7], file);\n", "\t\t\t\t\tsystem(rmcommand);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\tif (cat->touch_on_change && had_changes) {\n", "\t\t\tfor (buf = ast_strdupa(cat->touch_on_change), file = strsep(&buf, \" \");\n", "\t\t\t     file;\n", "\t\t\t     file = strsep(&buf, \" \")) {\n", "\t\t\t\tstrcpy(&touchcommand[9], file);\n", "\t\t\t\tsystem(touchcommand);\n", "\t\t\t}\n", "\t\t}\n", "\n", "\t\tif (cat->remove_on_change && had_changes) {\n", "\t\t\tfor (buf = ast_strdupa(cat->remove_on_change), file = strsep(&buf, \" \");\n", "\t\t\t     file;\n", "\t\t\t     file = strsep(&buf, \" \")) {\n", "\t\t\t\tstrcpy(&rmcommand[7], file);\n", "\t\t\t\tsystem(rmcommand);\n", "\t\t\t}\n", "\t\t}\n", "\t}\n", "\n", "\treturn 0;\n", "}\n"], "project": "asterisk-mysql", "file": "menuselect.pkl", "function": "generate_makeopts_file"}, {"comment_all": {"comment": "/*\n * This function contains 46 FP additions, 28 FP multiplications,\n * (or, 32 additions, 14 multiplications, 14 fused multiply/add),\n * 25 stack variables, 2 constants, and 24 memory accesses\n */", "depth": 0, "reading_ease": 28.17, "reading_grade": 15.8, "line": 164}, "comment_text": "/*\n * This function contains 46 FP additions, 28 FP multiplications,\n * (or, 32 additions, 14 multiplications, 14 fused multiply/add),\n * 25 stack variables, 2 constants, and 24 memory accesses\n */", "comment_tokens": ["This", "function", "contains", "46", "FP", "additions", ",", "28", "FP", "multiplications", ",", "(", "or", ",", "32", "additions", ",", "14", "multiplications", ",", "14", "fused", "multiplyadd", ")", ",", "25", "stack", "variables", ",", "2", "constants", ",", "and", "24", "memory", "accesses"], "ccode": ["#else\n", "\n", "/* Generated by: ../../../genfft/gen_hc2c.native -compact -variables 4 -pipeline-latency 4 -sign 1 -n 6 -dif -name hc2cb_6 -include rdft/scalar/hc2cb.h */\n", "\n", "/*\n", " * This function contains 46 FP additions, 28 FP multiplications,\n", " * (or, 32 additions, 14 multiplications, 14 fused multiply/add),\n", " * 25 stack variables, 2 constants, and 24 memory accesses\n", " */\n", "#include \"rdft/scalar/hc2cb.h\"\n", "\n", "static void hc2cb_6(R *Rp, R *Ip, R *Rm, R *Im, const R *W, stride rs, INT mb, INT me, INT ms)\n", "{\n", "     DK(KP500000000, +0.500000000000000000000000000000000000000000000);\n", "     DK(KP866025403, +0.866025403784438646763723170752936183471402627);\n", "     {\n", "\t  INT m;\n", "\t  for (m = mb, W = W + ((mb - 1) * 10); m < me; m = m + 1, Rp = Rp + ms, Ip = Ip + ms, Rm = Rm - ms, Im = Im - ms, W = W + 10, MAKE_VOLATILE_STRIDE(24, rs)) {\n", "\t       E T3, Ty, Td, TE, Ta, TO, Tr, TB, Tk, TL, Tn, TH;\n", "\t       {\n", "\t\t    E T1, T2, Tb, Tc;\n", "\t\t    T1 = Rp[0];\n", "\t\t    T2 = Rm[WS(rs, 2)];\n", "\t\t    T3 = T1 + T2;\n", "\t\t    Ty = T1 - T2;\n", "\t\t    Tb = Ip[0];\n", "\t\t    Tc = Im[WS(rs, 2)];\n", "\t\t    Td = Tb - Tc;\n", "\t\t    TE = Tb + Tc;\n", "\t       }\n", "\t       {\n", "\t\t    E T6, Tz, T9, TA;\n", "\t\t    {\n", "\t\t\t E T4, T5, T7, T8;\n", "\t\t\t T4 = Rp[WS(rs, 2)];\n", "\t\t\t T5 = Rm[0];\n", "\t\t\t T6 = T4 + T5;\n", "\t\t\t Tz = T4 - T5;\n", "\t\t\t T7 = Rm[WS(rs, 1)];\n", "\t\t\t T8 = Rp[WS(rs, 1)];\n", "\t\t\t T9 = T7 + T8;\n", "\t\t\t TA = T7 - T8;\n", "\t\t    }\n", "\t\t    Ta = T6 + T9;\n", "\t\t    TO = KP866025403 * (Tz - TA);\n", "\t\t    Tr = KP866025403 * (T6 - T9);\n", "\t\t    TB = Tz + TA;\n", "\t       }\n", "\t       {\n", "\t\t    E Tg, TG, Tj, TF;\n", "\t\t    {\n", "\t\t\t E Te, Tf, Th, Ti;\n", "\t\t\t Te = Ip[WS(rs, 2)];\n", "\t\t\t Tf = Im[0];\n", "\t\t\t Tg = Te - Tf;\n", "\t\t\t TG = Te + Tf;\n", "\t\t\t Th = Ip[WS(rs, 1)];\n", "\t\t\t Ti = Im[WS(rs, 1)];\n", "\t\t\t Tj = Th - Ti;\n", "\t\t\t TF = Th + Ti;\n", "\t\t    }\n", "\t\t    Tk = Tg + Tj;\n", "\t\t    TL = KP866025403 * (TG + TF);\n", "\t\t    Tn = KP866025403 * (Tj - Tg);\n", "\t\t    TH = TF - TG;\n", "\t       }\n", "\t       Rp[0] = T3 + Ta;\n", "\t       Rm[0] = Td + Tk;\n", "\t       {\n", "\t\t    E TC, TI, Tx, TD;\n", "\t\t    TC = Ty + TB;\n", "\t\t    TI = TE - TH;\n", "\t\t    Tx = W[4];\n", "\t\t    TD = W[5];\n", "\t\t    Ip[WS(rs, 1)] = FNMS(TD, TI, Tx * TC);\n", "\t\t    Im[WS(rs, 1)] = FMA(TD, TC, Tx * TI);\n", "\t       }\n", "\t       {\n", "\t\t    E To, Tu, Ts, Tw, Tm, Tq;\n", "\t\t    Tm = FNMS(KP500000000, Ta, T3);\n", "\t\t    To = Tm - Tn;\n", "\t\t    Tu = Tm + Tn;\n", "\t\t    Tq = FNMS(KP500000000, Tk, Td);\n", "\t\t    Ts = Tq - Tr;\n", "\t\t    Tw = Tr + Tq;\n", "\t\t    {\n", "\t\t\t E Tl, Tp, Tt, Tv;\n", "\t\t\t Tl = W[2];\n", "\t\t\t Tp = W[3];\n", "\t\t\t Rp[WS(rs, 1)] = FNMS(Tp, Ts, Tl * To);\n", "\t\t\t Rm[WS(rs, 1)] = FMA(Tl, Ts, Tp * To);\n", "\t\t\t Tt = W[6];\n", "\t\t\t Tv = W[7];\n", "\t\t\t Rp[WS(rs, 2)] = FNMS(Tv, Tw, Tt * Tu);\n", "\t\t\t Rm[WS(rs, 2)] = FMA(Tt, Tw, Tv * Tu);\n", "\t\t    }\n", "\t       }\n", "\t       {\n", "\t\t    E TM, TS, TQ, TU, TK, TP;\n", "\t\t    TK = FNMS(KP500000000, TB, Ty);\n", "\t\t    TM = TK - TL;\n", "\t\t    TS = TK + TL;\n", "\t\t    TP = FMA(KP500000000, TH, TE);\n", "\t\t    TQ = TO + TP;\n", "\t\t    TU = TP - TO;\n", "\t\t    {\n", "\t\t\t E TJ, TN, TR, TT;\n", "\t\t\t TJ = W[0];\n", "\t\t\t TN = W[1];\n", "\t\t\t Ip[0] = FNMS(TN, TQ, TJ * TM);\n", "\t\t\t Im[0] = FMA(TN, TM, TJ * TQ);\n", "\t\t\t TR = W[8];\n", "\t\t\t TT = W[9];\n", "\t\t\t Ip[WS(rs, 2)] = FNMS(TT, TU, TR * TS);\n", "\t\t\t Im[WS(rs, 2)] = FMA(TT, TS, TR * TU);\n", "\t\t    }\n", "\t       }\n", "\t  }\n", "     }\n", "}\n"], "project": "libfftw3-mpi-dev", "file": "hc2cb_6.pkl", "function": "hc2cb_6"}, {"comment_all": {"comment": "/**\n * flickcurl_activity_userPhotos:\n * @fc: flickcurl context\n * @timeframe: The timeframe in which to return updates for. This can be specified in days (<code>'2d'</code>) or hours (<code>'4h'</code>). The default behavoir is to return changes since the beginning of the previous user session. (or NULL)\n * @per_page: Number of items to return per page. If this argument is omitted, it defaults to 10. The maximum allowed value is 50. (or NULL)\n * @page: The page of results to return. If this argument is omitted, it defaults to 1. (or NULL)\n * \n * Returns a list of recent activity on photos belonging to the calling user. Do not poll this method more than once an hour.\n *\n * Implements flickr.activity.userPhotos (1.0)\n * \n * Return value: non-0 on failure\n **/", "depth": 0, "reading_ease": 60.92, "reading_grade": 7.3, "line": 110}, "comment_text": "/**\n * flickcurl_activity_userPhotos:\n * @fc: flickcurl context\n * @timeframe: The timeframe in which to return updates for. This can be specified in days (<code>'2d'</code>) or hours (<code>'4h'</code>). The default behavoir is to return changes since the beginning of the previous user session. (or NULL)\n * @per_page: Number of items to return per page. If this argument is omitted, it defaults to 10. The maximum allowed value is 50. (or NULL)\n * @page: The page of results to return. If this argument is omitted, it defaults to 1. (or NULL)\n * \n * Returns a list of recent activity on photos belonging to the calling user. Do not poll this method more than once an hour.\n *\n * Implements flickr.activity.userPhotos (1.0)\n * \n * Return value: non-0 on failure\n **/", "comment_tokens": ["flickcurl_activity_userPhotos", ":", "@", "fc", ":", "flickcurl", "context", "@", "timeframe", ":", "The", "timeframe", "in", "which", "to", "return", "updates", "for", ".", "This", "can", "be", "specified", "in", "days", "(", "<", "code", ">", "'2d", "'", "<", "code", ">", ")", "or", "hours", "(", "<", "code", ">", "'4h", "'", "<", "code", ">", ")", ".", "The", "default", "behavoir", "is", "to", "return", "changes", "since", "the", "beginning", "of", "the", "previous", "user", "session", ".", "(", "or", "NULL", ")", "@", "per_page", ":", "Number", "of", "items", "to", "return", "per", "page", ".", "If", "this", "argument", "is", "omitted", ",", "it", "defaults", "to", "10", ".", "The", "maximum", "allowed", "value", "is", "50", ".", "(", "or", "NULL", ")", "@", "page", ":", "The", "page", "of", "results", "to", "return", ".", "If", "this", "argument", "is", "omitted", ",", "it", "defaults", "to", "1", ".", "(", "or", "NULL", ")", "Returns", "a", "list", "of", "recent", "activity", "on", "photos", "belonging", "to", "the", "calling", "user", ".", "Do", "not", "poll", "this", "method", "more", "than", "once", "an", "hour", ".", "Implements", "flickr.activity.userPhotos", "(", "1.0", ")", "Return", "value", ":", "non-0", "on", "failure"], "ccode": ["\n", "\n", "/**\n", " * flickcurl_activity_userPhotos:\n", " * @fc: flickcurl context\n", " * @timeframe: The timeframe in which to return updates for. This can be specified in days (<code>'2d'</code>) or hours (<code>'4h'</code>). The default behavoir is to return changes since the beginning of the previous user session. (or NULL)\n", " * @per_page: Number of items to return per page. If this argument is omitted, it defaults to 10. The maximum allowed value is 50. (or NULL)\n", " * @page: The page of results to return. If this argument is omitted, it defaults to 1. (or NULL)\n", " * \n", " * Returns a list of recent activity on photos belonging to the calling user. Do not poll this method more than once an hour.\n", " *\n", " * Implements flickr.activity.userPhotos (1.0)\n", " * \n", " * Return value: non-0 on failure\n", " **/\n", "flickcurl_activity**\n", "flickcurl_activity_userPhotos(flickcurl* fc, const char* timeframe,\n", "                              int per_page, int page)\n", "{\n", "  xmlDocPtr doc = NULL;\n", "  xmlXPathContextPtr xpathCtx = NULL; \n", "  flickcurl_activity** activities = NULL;\n", "  char page_str[10];\n", "  char per_page_str[10];\n", "\n", "  flickcurl_init_params(fc, 0);\n", "\n", "  if(timeframe) {\n", "    flickcurl_add_param(fc, \"timeframe\", timeframe);\n", "  }\n", "  if(page >= 0) {\n", "    sprintf(page_str, \"%d\", page);\n", "    flickcurl_add_param(fc, \"page\", page_str);\n", "  }\n", "  if(per_page >= 0) {\n", "    sprintf(per_page_str, \"%d\", per_page);\n", "    flickcurl_add_param(fc, \"per_page\", per_page_str);\n", "  }\n", "\n", "  flickcurl_end_params(fc);\n", "\n", "  if(flickcurl_prepare(fc, \"flickr.activity.userPhotos\"))\n", "    goto tidy;\n", "\n", "  doc = flickcurl_invoke(fc);\n", "  if(!doc)\n", "    goto tidy;\n", "\n", "\n", "  xpathCtx = xmlXPathNewContext(doc);\n", "  if(!xpathCtx) {\n", "    flickcurl_error(fc, \"Failed to create XPath context for document\");\n", "    fc->failed = 1;\n", "    goto tidy;\n", "  }\n", "\n", "  activities = flickcurl_build_activities(fc, xpathCtx,\n", "                                        (const xmlChar*)\"/rsp/items/item\", NULL);\n", "\n", "  tidy:\n", "  if(xpathCtx)\n", "    xmlXPathFreeContext(xpathCtx);\n", "\n", "  if(fc->failed) {\n", "    if(activities)\n", "      flickcurl_free_activities(activities);\n", "    activities = NULL;\n", "  }\n", "\n", "  return activities;\n", "}\n"], "project": "libflickcurl0-dbg", "file": "activity-api.pkl", "function": "flickcurl_activity_userPhotos"}, {"comment_all": {"comment": "/*\n * Copyright 1999-2014 University of Chicago\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "depth": 0, "reading_ease": 46.17, "reading_grade": 10.9, "line": 7}, "comment_text": "/*\n * Copyright 1999-2014 University of Chicago\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */", "comment_tokens": ["Copyright", "1999-2014", "University", "of", "Chicago", "Licensed", "under", "the", "Apache", "License", ",", "Version", "2.0", "(", "the", "``", "License", "''", ")", ";", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License", ".", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at", "http", ":", "www.apache.orglicensesLICENSE-2.0", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing", ",", "software", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "``", "AS", "IS", "''", "BASIS", ",", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND", ",", "either", "express", "or", "implied", ".", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and", "limitations", "under", "the", "License", "."], "ccode": ["/*\n", " * Copyright 1999-2014 University of Chicago\n", " *\n", " * Licensed under the Apache License, Version 2.0 (the \"License\");\n", " * you may not use this file except in compliance with the License.\n", " * You may obtain a copy of the License at\n", " *\n", " * http://www.apache.org/licenses/LICENSE-2.0\n", " *\n", " * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n", " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", " * See the License for the specific language governing permissions and\n", " * limitations under the License.\n", " */\n", "\n", "#include \"globus_net_manager.h\"\n", "\n", "/**\n", " * @brief Unregister a network manager\n", " * @ingroup globus_net_manager\n", " * @details\n", " * The globus_net_manager_unregister() function removes this network manager\n", " * from those which will be called by the network manager interface\n", " * when network events occur. This is typically called by the network\n", " * manager when its module is deactivated.\n", " * @param[in] manager\n", " *     Manager information to unregister.\n", " *\n", " */\n", "globus_result_t\n", "globus_net_manager_unregister(\n", "    globus_net_manager_t               *manager)\n", "{\n", "    globus_extension_registry_remove(\n", "        GLOBUS_NET_MANAGER_REGISTRY, (void *) manager->name);\n", "    \n", "    return GLOBUS_SUCCESS;\n", "}\n"], "project": "libglobus-xio-net-manager-driver-dev", "file": "unregister.pkl", "function": "globus_net_manager_unregister"}, {"comment_all": {"comment": "// last color\n", "depth": 2, "reading_ease": 77.91, "reading_grade": 2.9, "line": 257}, "comment_text": "// 0=white 1=black\n// found a white-black transition\n// last color\n", "comment_tokens": ["0=white", "1=black", "found", "a", "white-black", "transition", "last", "color"], "ccode": ["\n", "int num_cross_fine(int x0, int x1, int y0, int y1, pix *p, int cs) {\n", "  int rc = 0, col = 0, k, x, y, i, d;\t// rc=crossings  col=0=white\n", "  int dx = x1 - x0, dy = y1 - y0;\n", "\n", "  d = MAX(abs(dx), abs(dy));\n", "  for (i = 0, x = x0, y = y0; i <= d; i++) {\n", "    if (d) {\n", "      x = x0 + i * dx / d;\n", "      y = y0 + i * dy / d;\n", "    }\n", "    k = ((getpixel(p, x, y) < cs) ? 1 : 0);\t// 0=white 1=black\n", "    if (col == 0 && k == 1) rc++; // found a white-black transition\n", "    col = k;        // last color\n", "  }\n", "  return rc;\n", "}\n"], "project": "gocr", "file": "pgm2asc.pkl", "function": "num_cross_fine"}, {"comment_all": {"comment": "/* request.status == 3 */", "depth": 3, "reading_ease": -6.7, "reading_grade": 14.7, "line": 281}, "comment_text": "/* request.status == 3 */\n/* shutting down request */\n/* request.status == 3 */\n/* shutting down request */\n", "comment_tokens": ["request.status", "==", "3", "shutting", "down", "request", "request.status", "==", "3", "shutting", "down", "request"], "ccode": ["\n", "static void *\n", "tempfile_watch(void *data)\n", "{\n", "\n", "\tchar *dirname;\n", "\tDIR\t*dir;\n", "\tint\tlasttime = 0;\n", "\n", "\tif (!(dirname = getenv(\"BFBT_TMPDIR\")))\n", "\t\tdirname = \"/tmp\";\t\n", "\t\n", "\tinitialized = TRUE;\n", "\tif ((dir = opendir(dirname)) == NULL)\n", "\t\tbfbt_message(MSG_TYPE_ERROR_ABORT, \"opendir: %s failed\", dirname);\n", "\twhile(1){\n", "\t\t\n", "\t\ttempfile_scandir(dir);\n", "\n", "\t\tpthread_mutex_lock(&request.mutex);\n", "\t\tif (request.status == 1 || request.status == 3) {\n", "\t\t\tif (request.status == 1) {\t/* starting a new request */\n", "\t\t\t\tif (lasttime) {\n", "\t\t\t\t\ttempfile_request_startup();\n", "\t\t\t\t\tlasttime = 0;\n", "\t\t\t\t} else\n", "\t\t\t\t\tlasttime = 1;\n", "\t\t\t} else /* request.status == 3 */ {\t/* shutting down request */\n", "\t\t\t\tif (lasttime) {\n", "\t\t\t\t\ttempfile_request_shutdown();\n", "\t\t\t\t\tlasttime = 0;\n", "\t\t\t\t} else\n", "\t\t\t\t\tlasttime = 1;\n", "\t\t\t}\n", "\t\t} else\n", "\t\t\twhile (request.status == 0)\n", "\t\t\t\tpthread_cond_wait(&request.cond, &request.mutex);\n", "\t\tpthread_mutex_unlock(&request.mutex);\n", "\t\tpthread_testcancel();\n", "\t}\n", "\treturn NULL;\n", "}\n"], "project": "bfbtester", "file": "tempfiles.pkl", "function": "tempfile_watch"}, {"comment_all": {"comment": "/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 2005 - 2006, Russell Bryant\n *\n * Russell Bryant <russell@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */", "depth": 0, "reading_ease": 68.36, "reading_grade": 6.6, "line": 7}, "comment_text": "/*\n * Asterisk -- An open source telephony toolkit.\n *\n * Copyright (C) 2005 - 2006, Russell Bryant\n *\n * Russell Bryant <russell@digium.com>\n *\n * See http://www.asterisk.org for more information about\n * the Asterisk project. Please do not directly contact\n * any of the maintainers of this project for assistance;\n * the project provides a web site, mailing lists and IRC\n * channels for your use.\n *\n * This program is free software, distributed under the terms of\n * the GNU General Public License Version 2. See the LICENSE file\n * at the top of the source tree.\n */", "comment_tokens": ["Asterisk", "--", "An", "open", "source", "telephony", "toolkit", ".", "Copyright", "(", "C", ")", "2005", "-", "2006", ",", "Russell", "Bryant", "Russell", "Bryant", "<", "russell", "@", "digium.com", ">", "See", "http", ":", "www.asterisk.org", "for", "more", "information", "about", "the", "Asterisk", "project", ".", "Please", "do", "not", "directly", "contact", "any", "of", "the", "maintainers", "of", "this", "project", "for", "assistance", ";", "the", "project", "provides", "a", "web", "site", ",", "mailing", "lists", "and", "IRC", "channels", "for", "your", "use", ".", "This", "program", "is", "free", "software", ",", "distributed", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "Version", "2", ".", "See", "the", "LICENSE", "file", "at", "the", "top", "of", "the", "source", "tree", "."], "ccode": ["/*\n", " * Asterisk -- An open source telephony toolkit.\n", " *\n", " * Copyright (C) 2005 - 2006, Russell Bryant\n", " *\n", " * Russell Bryant <russell@digium.com>\n", " *\n", " * See http://www.asterisk.org for more information about\n", " * the Asterisk project. Please do not directly contact\n", " * any of the maintainers of this project for assistance;\n", " * the project provides a web site, mailing lists and IRC\n", " * channels for your use.\n", " *\n", " * This program is free software, distributed under the terms of\n", " * the GNU General Public License Version 2. See the LICENSE file\n", " * at the top of the source tree.\n", " */\n", "\n", "/*\n", " * \\file\n", " *\n", " * \\author Russell Bryant <russell@digium.com>\n", " *\n", " * \\brief Menu stub\n", " */\n", "\n", "#include <stdlib.h>\n", "#include <stdio.h>\n", "\n", "#include \"menuselect.h\"\n", "\n", "int run_menu(void)\n", "{\n", "\tfprintf(stderr, \"**************************************************\\n\");\n", "\tfprintf(stderr, \"*** Install ncurses to use the menu interface! ***\\n\");\n", "\tfprintf(stderr, \"**************************************************\\n\");\n", "\n", "\treturn -1;\n", "}\n"], "project": "asterisk", "file": "menuselect_stub.pkl", "function": "run_menu"}, {"comment_all": {"comment": "/*\n * x86 instruction attribute tables\n *\n * Written by Masami Hiramatsu <mhiramat@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */", "depth": 0, "reading_ease": 50.87, "reading_grade": 11.2, "line": 0}, "comment_text": "/*\n * x86 instruction attribute tables\n *\n * Written by Masami Hiramatsu <mhiramat@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n */", "comment_tokens": ["x86", "instruction", "attribute", "tables", "Written", "by", "Masami", "Hiramatsu", "<", "mhiramat", "@", "redhat.com", ">", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "59", "Temple", "Place", "-", "Suite", "330", ",", "Boston", ",", "MA", "02111-1307", ",", "USA", "."], "ccode": ["/*\n", " * x86 instruction attribute tables\n", " *\n", " * Written by Masami Hiramatsu <mhiramat@redhat.com>\n", " *\n", " * This program is free software; you can redistribute it and/or modify\n", " * it under the terms of the GNU General Public License as published by\n", " * the Free Software Foundation; either version 2 of the License, or\n", " * (at your option) any later version.\n", " *\n", " * This program is distributed in the hope that it will be useful,\n", " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " * GNU General Public License for more details.\n", " *\n", " * You should have received a copy of the GNU General Public License\n", " * along with this program; if not, write to the Free Software\n", " * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n", " *\n", " */\n", "#include <asm/insn.h>\n", "\n", "/* Attribute tables are generated from opcode map */\n", "#include \"inat-tables.c\"\n", "\n", "/* Attribute search APIs */\n", "insn_attr_t inat_get_opcode_attribute(insn_byte_t opcode)\n", "{\n", "\treturn inat_primary_table[opcode];\n", "}\n"], "project": "kpatch", "file": "inat.pkl", "function": "inat_get_opcode_attribute"}, {"comment_all": {"comment": "/*\n * Spdylay - SPDY Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */", "depth": 0, "reading_ease": 13.92, "reading_grade": 25.4, "line": 0}, "comment_text": "/*\n * Spdylay - SPDY Library\n *\n * Copyright (c) 2012 Tatsuhiro Tsujikawa\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */", "comment_tokens": ["Spdylay", "-", "SPDY", "Library", "Copyright", "(", "c", ")", "2012", "Tatsuhiro", "Tsujikawa", "Permission", "is", "hereby", "granted", ",", "free", "of", "charge", ",", "to", "any", "person", "obtaining", "a", "copy", "of", "this", "software", "and", "associated", "documentation", "files", "(", "the", "``", "Software", "''", ")", ",", "to", "deal", "in", "the", "Software", "without", "restriction", ",", "including", "without", "limitation", "the", "rights", "to", "use", ",", "copy", ",", "modify", ",", "merge", ",", "publish", ",", "distribute", ",", "sublicense", ",", "andor", "sell", "copies", "of", "the", "Software", ",", "and", "to", "permit", "persons", "to", "whom", "the", "Software", "is", "furnished", "to", "do", "so", ",", "subject", "to", "the", "following", "conditions", ":", "The", "above", "copyright", "notice", "and", "this", "permission", "notice", "shall", "be", "included", "in", "all", "copies", "or", "substantial", "portions", "of", "the", "Software", ".", "THE", "SOFTWARE", "IS", "PROVIDED", "``", "AS", "IS", "''", ",", "WITHOUT", "WARRANTY", "OF", "ANY", "KIND", ",", "EXPRESS", "OR", "IMPLIED", ",", "INCLUDING", "BUT", "NOT", "LIMITED", "TO", "THE", "WARRANTIES", "OF", "MERCHANTABILITY", ",", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", "AND", "NONINFRINGEMENT", ".", "IN", "NO", "EVENT", "SHALL", "THE", "AUTHORS", "OR", "COPYRIGHT", "HOLDERS", "BE", "LIABLE", "FOR", "ANY", "CLAIM", ",", "DAMAGES", "OR", "OTHER", "LIABILITY", ",", "WHETHER", "IN", "AN", "ACTION", "OF", "CONTRACT", ",", "TORT", "OR", "OTHERWISE", ",", "ARISING", "FROM", ",", "OUT", "OF", "OR", "IN", "CONNECTION", "WITH", "THE", "SOFTWARE", "OR", "THE", "USE", "OR", "OTHER", "DEALINGS", "IN", "THE", "SOFTWARE", "."], "ccode": ["/*\n", " * Spdylay - SPDY Library\n", " *\n", " * Copyright (c) 2012 Tatsuhiro Tsujikawa\n", " *\n", " * Permission is hereby granted, free of charge, to any person obtaining\n", " * a copy of this software and associated documentation files (the\n", " * \"Software\"), to deal in the Software without restriction, including\n", " * without limitation the rights to use, copy, modify, merge, publish,\n", " * distribute, sublicense, and/or sell copies of the Software, and to\n", " * permit persons to whom the Software is furnished to do so, subject to\n", " * the following conditions:\n", " *\n", " * The above copyright notice and this permission notice shall be\n", " * included in all copies or substantial portions of the Software.\n", " *\n", " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n", " * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n", " * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n", " * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n", " * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n", " * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n", " * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", " */\n", "#include \"spdylay_gzip.h\"\n", "\n", "#include <assert.h>\n", "\n", "int spdylay_gzip_inflate_new(spdylay_gzip **inflater_ptr)\n", "{\n", "  int rv;\n", "  *inflater_ptr = malloc(sizeof(spdylay_gzip));\n", "  if(*inflater_ptr == NULL) {\n", "    return SPDYLAY_ERR_NOMEM;\n", "  }\n", "  (*inflater_ptr)->finished = 0;\n", "  (*inflater_ptr)->zst.next_in = Z_NULL;\n", "  (*inflater_ptr)->zst.avail_in = 0;\n", "  (*inflater_ptr)->zst.zalloc = Z_NULL;\n", "  (*inflater_ptr)->zst.zfree = Z_NULL;\n", "  (*inflater_ptr)->zst.opaque = Z_NULL;\n", "  rv = inflateInit2(&(*inflater_ptr)->zst, 47);\n", "  if(rv != Z_OK) {\n", "    free(*inflater_ptr);\n", "    return SPDYLAY_ERR_GZIP;\n", "  }\n", "  return 0;\n", "}\n"], "project": "libspdylay-utils", "file": "spdylay_gzip.pkl", "function": "spdylay_gzip_inflate_new"}, {"comment_all": {"comment": "/* stdin avoid core dump in strcmp() */", "depth": 2, "reading_ease": 99.23, "reading_grade": 0.9, "line": 106}, "comment_text": "/* stdin avoid core dump in strcmp() */", "comment_tokens": ["stdin", "avoid", "core", "dump", "in", "strcmp", "(", ")"], "ccode": ["\n", "void *\n", "xopen(char *name, int oflag, int mode)\n", "{\n", "\tint\tf;\n", "\txio_t\t*xp;\n", "\txio_t\t*pp = x_root;\n", "\n", "\tif (x_tail == NULL)\n", "\t\tx_tail = &x_stdin.x_next;\n", "\tif (name == NULL) {\n", "\t\txp = &x_stdin;\n", "\t\txp->x_refcnt++;\n", "#ifdef\tNEED_O_BINARY\n", "\t\tif ((oflag & O_BINARY) != 0) {\n", "\t\t\tsetmode(STDIN_FILENO, O_BINARY);\n", "\t\t}\n", "#endif\n", "\t\treturn (xp);\n", "\t}\n", "\tfor (; pp; pp = pp->x_next) {\n", "\t\tif (pp->x_name == NULL)\t/* stdin avoid core dump in strcmp() */\n", "\t\t\tcontinue;\n", "\t\tif ((strcmp(pp->x_name, name) == 0) &&\n", "\t\t    (pp->x_oflag == oflag) && (pp->x_omode == mode)) {\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\tif (pp) {\n", "\t\tpp->x_refcnt++;\n", "\t\treturn ((void *)pp);\n", "\t}\n", "\tif ((f = open(name, oflag, mode)) < 0)\n", "\t\treturn (NULL);\n", "\n", "\tif ((xp = xnewnode(name)) == NULL) {\n", "\t\tclose(f);\n", "\t\treturn (NULL);\n", "\t}\n", "\txp->x_file = f;\n", "\txp->x_oflag = oflag;\n", "\txp->x_omode = mode;\n", "\t*x_tail = xp;\n", "\tx_tail = &xp->x_next;\n", "\treturn ((void *)xp);\n", "}\n"], "project": "cdrkit-doc", "file": "xio.pkl", "function": "xopen"}, {"comment_all": {"comment": "/* wait for the previous move to be received by \n\t\t * all */", "depth": 2, "reading_ease": 86.71, "reading_grade": 3.7, "line": 1114}, "comment_text": "/* wait for the previous move to be received by \n\t\t * all */", "comment_tokens": ["wait", "for", "the", "previous", "move", "to", "be", "received", "by", "all"], "ccode": ["\n", "static ConnState server_handle_conn_play_send(ConnData *cd, int quit)\n", "{\n", "\tint playercolor, x, y;\n", "\n", "\tSDL_LockMutex(gamelist_mutex);\n", "\twhile (players_lagging(cd)) {\n", "\t\t/* wait for the previous move to be received by \n", "\t\t * all */\n", "\t\tSDL_CondWait(cd->game->cond_wait, gamelist_mutex);\n", "\t\tif (cd->game->killed) {\n", "\t\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\t\treturn CONN_KILL;\n", "\t\t}\n", "\t}\n", "\n", "\tif (read_int(cd->fd, &playercolor) < 0) {\n", "\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\treturn CONN_KILL;\n", "\t}\n", "\n", "\tif (playercolor != cd->player_num) {\n", "\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\treturn CONN_KILL;\n", "\t}\n", "\n", "\tif (!quit) {\n", "\t\tif (read_int(cd->fd, &x) < 0\n", "\t\t || read_int(cd->fd, &y) < 0) {\n", "\t\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\t\treturn CONN_KILL;\n", "\t\t}\n", "\t} else {\n", "\t\tx = -2;\n", "\t\ty = -2;\n", "\t}\n", "\n", "\tif (cd->game->killed) {\n", "\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\treturn CONN_KILL;\n", "\t}\n", "\n", "\tif (x != -1 && y != -1) {\n", "\t\tgame_push_move(cd->game, playercolor, x, y);\n", "\t\n", "\t\tdo_log(cd, \" < game %d: player %d sends move ID %d (x %d, y %d)\\n\",\n", "\t\t\tcd->game->id, playercolor, cd->game->move_id, x, y);\n", "\t}\n", "\n", "\tif (quit) {\n", "\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\treturn CONN_KILL;\n", "\t}\n", "\n", "\t/* wait here that everyone gets the move. \n", "\t * this avoids deadlocks */\n", "\twhile (players_lagging(cd)) {\n", "\t\tSDL_CondWait(cd->game->cond_wait, gamelist_mutex);\n", "\t\tif (cd->game->killed) {\n", "\t\t\tSDL_UnlockMutex(gamelist_mutex);\n", "\t\t\treturn CONN_KILL;\n", "\t\t}\n", "\t}\n", "\n", "\tSDL_UnlockMutex(gamelist_mutex);\n", "\treturn CONN_PLAY;\n", "}\n"], "project": "biloba", "file": "server.pkl", "function": "server_handle_conn_play_send"}, {"comment_all": {"comment": "/** Copy in a binary block */", "depth": 0, "reading_ease": 83.32, "reading_grade": 2.9, "line": 32}, "comment_text": "/** Copy in a binary block */", "comment_tokens": ["Copy", "in", "a", "binary", "block"], "ccode": ["\n", "/** Copy in a binary block */\n", "int str_copyb(str* s, const char* in, unsigned len)\n", "{\n", "  if (!str_ready(s, len)) return 0;\n", "  memcpy(s->s, in, len);\n", "  s->len = len;\n", "  s->s[len] = 0;\n", "  return 1;\n", "}\n"], "project": "libbg2-doc", "file": "copy.pkl", "function": "str_copyb"}, {"comment_all": {"comment": "/*\nppedit - A pattern plate editor for Spiro splines.\nCopyright (C) 2007 Raph Levien\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301, USA.\n\n*/", "depth": 0, "reading_ease": 58.62, "reading_grade": 10.3, "line": 0}, "comment_text": "/*\nppedit - A pattern plate editor for Spiro splines.\nCopyright (C) 2007 Raph Levien\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301, USA.\n\n*/", "comment_tokens": ["ppedit", "-", "A", "pattern", "plate", "editor", "for", "Spiro", "splines", ".", "Copyright", "(", "C", ")", "2007", "Raph", "Levien", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "3", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", ",", "USA", "."], "ccode": ["/*\n", "ppedit - A pattern plate editor for Spiro splines.\n", "Copyright (C) 2007 Raph Levien\n", "\n", "This program is free software; you can redistribute it and/or\n", "modify it under the terms of the GNU General Public License\n", "as published by the Free Software Foundation; either version 3\n", "of the License, or (at your option) any later version.\n", "\n", "This program is distributed in the hope that it will be useful,\n", "but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "GNU General Public License for more details.\n", "\n", "You should have received a copy of the GNU General Public License\n", "along with this program; if not, write to the Free Software\n", "Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n", "02110-1301, USA.\n", "\n", "*/\n", "#include \"spiro-config.h\"\n", "#ifdef VERBOSE\n", "#include <stdio.h>\n", "#endif\n", "\n", "#include \"bezctx.h\"\n", "\n", "void bezctx_moveto(bezctx *bc, double x, double y, int is_open)\n", "{\n", "#ifdef VERBOSE\n", "    printf(\"moveto(%g,%g)_%d\\n\",x,y,is_open);\n", "#endif\n", "    bc->moveto(bc, x, y, is_open);\n", "}\n"], "project": "libspiro-dev", "file": "bezctx.pkl", "function": "bezctx_moveto"}, {"comment_all": {"comment": "/* $Id: xmalloc.c,v 1.3 2005/10/19 18:39:13 timo Exp $ */", "depth": 0, "reading_ease": 89.75, "reading_grade": 2.5, "line": 22}, "comment_text": "/* $Id: xmalloc.c,v 1.3 2005/10/19 18:39:13 timo Exp $ */", "comment_tokens": ["$", "Id", ":", "xmalloc.c", ",", "v", "1.3", "20051019", "18:39:13", "timo", "Exp", "$"], "ccode": ["/*\n", " *    bbe - Binary block editor\n", " *\n", " *    Copyright (C) 2005 Timo Savinen\n", " *    This file is part of bbe.\n", " * \n", " *    bbe is free software; you can redistribute it and/or modify\n", " *    it under the terms of the GNU General Public License as published by\n", " *    the Free Software Foundation; either version 2 of the License, or\n", " *    (at your option) any later version.\n", " *\n", " *    bbe is distributed in the hope that it will be useful,\n", " *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *    GNU General Public License for more details.\n", " *\n", " *    You should have received a copy of the GNU General Public License\n", " *    along with bbe; if not, write to the Free Software\n", " *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n", " *\n", " */\n", "\n", "/* $Id: xmalloc.c,v 1.3 2005/10/19 18:39:13 timo Exp $ */\n", "\n", "#include \"bbe.h\"\n", "#include <stdlib.h>\n", "#include <string.h>\n", "\n", "void *\n", "xmalloc (size_t size)\n", "{\n", "    register void *value = malloc(size);\n", "    if (value == 0) panic(\"Out of memory\",NULL,NULL);\n", "    return value;\n", "}\n"], "project": "bbe", "file": "xmalloc.pkl", "function": "xmalloc"}, {"comment_all": {"comment": "/* Always generate the dependencies file */", "depth": 1, "reading_ease": 15.64, "reading_grade": 12.3, "line": 2155}, "comment_text": "/* Always generate the dependencies file */", "comment_tokens": ["Always", "generate", "the", "dependencies", "file"], "ccode": ["\n", "int main(int argc, char *argv[])\n", "{\n", "\tint res = 0;\n", "\tconst char *list_group = NULL;\n", "\tunsigned int x;\n", "\tstatic struct option long_options[] = {\n", "\t\t/*\n", "\t\t * The --check-deps option is used to ask this application to check to\n", "\t\t * see if that an existing menuselect.makeopts file contains all of the\n", "\t\t * modules that have dependencies that have not been met.  If this\n", "\t\t * is not the case, an informative message will be printed to the\n", "\t\t * user and the build will fail.\n", "\t\t */\n", "\t\t{ \"check-deps\",       no_argument,       &check_deps,   1  },\n", "\t\t{ \"enable\",           required_argument, 0,            'e' },\n", "\t\t{ \"enable-category\",  required_argument, 0,            'E' },\n", "\t\t{ \"enable-all\",       no_argument,       0,            'a' },\n", "\t\t{ \"disable\",          required_argument, 0,            'd' },\n", "\t\t{ \"disable-category\", required_argument, 0,            'D' },\n", "\t\t{ \"disable-all\",      no_argument,       0,            'A' },\n", "\t\t{ \"list-options\",     no_argument,       &list_options, 1  },\n", "\t\t{ \"list-category\",    required_argument, 0,            'L' },\n", "\t\t{ \"category-list\",    no_argument,       &list_groups,  1  },\n", "\t\t{ \"help\",             no_argument,       0,            'h' },\n", "\n", "\t\t{ 0, 0, 0, 0 },\n", "\t};\n", "\tint do_menu = 1, do_settings = 1;\n", "\tint c, option_index = 0;\n", "\n", "\tif (open_debug()) {\n", "\t\texit(1);\n", "\t}\n", "\n", "\tLIBXML_TEST_VERSION;\n", "\n", "\t/* Parse the input XML files to build the list of available options */\n", "\tif ((res = build_member_list()))\n", "\t\texit(res);\n", "\n", "\t/* Load module dependencies */\n", "\tif ((res = process_deps()))\n", "\t\texit(res);\n", "\n", "\twhile (calc_dep_failures(0, 1) || calc_conflict_failures(0, 1));\n", "\n", "\twhile ((c = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n", "\t\tswitch (c) {\n", "\t\tcase 'L':\n", "\t\t\tlist_group = optarg;\n", "\t\t\tdo_settings = 0;\n", "\t\t\t/* Fall-through */\n", "\t\tcase 'a':\n", "\t\tcase 'A':\n", "\t\tcase 'e':\n", "\t\tcase 'E':\n", "\t\tcase 'd':\n", "\t\tcase 'D':\n", "\t\t\tdo_menu = 0;\n", "\t\t\tbreak;\n", "\t\tcase 'h':\n", "\t\t\treturn usage(argv[0]);\n", "\t\t\tbreak;\n", "\t\tdefault:\n", "\t\t\tbreak;\n", "\t\t}\n", "\t}\n", "\n", "\tif (check_deps || list_options || list_groups) {\n", "\t\tdo_menu = 0;\n", "\t\tdo_settings = 0;\n", "\t}\n", "\n", "\tif (optind < argc) {\n", "\t\tfor (x = optind; x < argc; x++) {\n", "\t\t\tres = parse_existing_config(argv[x]);\n", "\t\t\tif (!res && !strcasecmp(argv[x], OUTPUT_MAKEOPTS_DEFAULT))\n", "\t\t\t\texisting_config = 1;\n", "\t\t\tres = 0;\n", "\t\t}\n", "\t}\n", "\n", "\t/* Dump the list produced by parsing the various input files */\n", "\tdump_member_list();\n", "\n", "\twhile (calc_dep_failures(0, 0) || calc_conflict_failures(0, 0));\n", "\n", "\tif (!existing_config)\n", "\t\tprocess_defaults();\n", "\telse if (check_deps)\n", "\t\tres = sanity_check();\n", "\n", "\twhile (calc_dep_failures(0, 0) || calc_conflict_failures(0, 0));\n", "\n", "\tprint_debug(\"do_menu=%d, do_settings=%d\\n\", do_menu, do_settings);\n", "\n", "\tif (do_menu && !res) {\n", "\t\tres = run_menu();\n", "\t} else if (!do_settings) {\n", "\t\tif (list_groups) {\n", "\t\t\tstruct category *cat;\n", "\t\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\t\t\tfprintf(stdout, \"%s\\n\", cat->name);\n", "\t\t\t}\n", "\t\t} else if (list_options) {\n", "\t\t\tstruct category *cat;\n", "\t\t\tstruct member *mem;\n", "\t\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\t\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\t\t\tif (mem->is_separator) {\n", "\t\t\t\t\t\tcontinue;\n", "\t\t\t\t\t}\n", "\n", "\t\t\t\t\tfprintf(stdout, \"%c %-30.30s %s\\n\", mem->enabled ? '+' : '-', mem->name, cat->name);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t} else if (!strlen_zero(list_group)) {\n", "\t\t\tstruct category *cat;\n", "\t\t\tstruct member *mem;\n", "\t\t\tif ((cat = find_category(list_group))) {\n", "\t\t\t\tAST_LIST_TRAVERSE(&cat->members, mem, list) {\n", "\t\t\t\t\tif (mem->is_separator) {\n", "\t\t\t\t\t\tcontinue;\n", "\t\t\t\t\t}\n", "\n", "\t\t\t\t\tfprintf(stdout, \"%c %s\\n\", mem->enabled ? '+' : '-', mem->name);\n", "\t\t\t\t}\n", "\t\t\t}\n", "\t\t}\n", "\t} else if (!do_menu && do_settings) {\n", "\t\tstruct member *mem;\n", "\t\tstruct category *cat;\n", "\n", "\t\tprint_debug(\"Doing settings with argc=%d\\n\", argc);\n", "\n", "\t\t/* Reset options processing */\n", "\t\toption_index = 0;\n", "\t\toptind = 1;\n", "\n", "\t\twhile ((c = getopt_long(argc, argv, \"\", long_options, &option_index)) != -1) {\n", "\t\t\tprint_debug(\"Got option %c\\n\", c);\n", "\t\t\tswitch (c) {\n", "\t\t\tcase 'e':\n", "\t\t\t\tif (!strlen_zero(optarg)) {\n", "\t\t\t\t\tif ((mem = find_member(optarg))) {\n", "\t\t\t\t\t\tset_member_enabled(mem);\n", "\t\t\t\t\t} else {\n", "\t\t\t\t\t\tfprintf(stderr, \"'%s' not found\\n\", optarg);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase 'E':\n", "\t\t\t\tif (!strlen_zero(optarg)) {\n", "\t\t\t\t\tif ((cat = find_category(optarg))) {\n", "\t\t\t\t\t\tset_all(cat, 1);\n", "\t\t\t\t\t} else {\n", "\t\t\t\t\t\tfprintf(stderr, \"'%s' not found\\n\", optarg);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase 'a': /* enable-all */\n", "\t\t\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\t\t\t\tset_all(cat, 1);\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase 'd':\n", "\t\t\t\tif (!strlen_zero(optarg)) {\n", "\t\t\t\t\tif ((mem = find_member(optarg))) {\n", "\t\t\t\t\t\tclear_member_enabled(mem);\n", "\t\t\t\t\t} else {\n", "\t\t\t\t\t\tfprintf(stderr, \"'%s' not found\\n\", optarg);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase 'D':\n", "\t\t\t\tif (!strlen_zero(optarg)) {\n", "\t\t\t\t\tif ((cat = find_category(optarg))) {\n", "\t\t\t\t\t\tset_all(cat, 0);\n", "\t\t\t\t\t} else {\n", "\t\t\t\t\t\tfprintf(stderr, \"'%s' not found\\n\", optarg);\n", "\t\t\t\t\t}\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase 'A': /* disable-all */\n", "\t\t\t\tAST_LIST_TRAVERSE(&categories, cat, list) {\n", "\t\t\t\t\tset_all(cat, 0);\n", "\t\t\t\t}\n", "\t\t\t\tbreak;\n", "\t\t\tcase '?':\n", "\t\t\t\tbreak;\n", "\t\t\tdefault:\n", "\t\t\t\tbreak;\n", "\t\t\t}\n", "\t\t}\n", "\t\tres = 0;\n", "\t}\n", "\n", "\tif (!res) {\n", "\t\tres = generate_makeopts_file();\n", "\t}\n", "\n", "\t/* Always generate the dependencies file */\n", "\tif (!res) {\n", "\t\tgenerate_makedeps_file();\n", "\t}\n", "\n", "\t/* free everything we allocated */\n", "\tfree_deps_file();\n", "\tfree_trees();\n", "\tfree_member_list();\n", "\n", "\tclose_debug();\n", "\n", "\txmlCleanupParser();\n", "\n", "\texit(res);\n", "}\n"], "project": "asterisk-modules", "file": "menuselect.pkl", "function": "main"}, {"comment_all": {"comment": "/*++++++++++++++++++++++++++++++++++++++\n  Tidy up all of the local variables in case of a problem and abnormal parser termination.\n  ++++++++++++++++++++++++++++++++++++++*/", "depth": 0, "reading_ease": 55.24, "reading_grade": 9.5, "line": 272}, "comment_text": "/*++++++++++++++++++++++++++++++++++++++\n  Tidy up all of the local variables in case of a problem and abnormal parser termination.\n  ++++++++++++++++++++++++++++++++++++++*/", "comment_tokens": ["++++++++++++++++++++++++++++++++++++++", "Tidy", "up", "all", "of", "the", "local", "variables", "in", "case", "of", "a", "problem", "and", "abnormal", "parser", "termination", ".", "++++++++++++++++++++++++++++++++++++++"], "ccode": ["\n", "\n", "/*++++++++++++++++++++++++++++++++++++++\n", "  Tidy up all of the local variables in case of a problem and abnormal parser termination.\n", "  ++++++++++++++++++++++++++++++++++++++*/\n", "\n", "void ResetTypeAnalyser(void)\n", "{\n", " if(typedefs) DeleteStringList2(typedefs);\n", " typedefs=NULL;\n", "\n", " if(cur_su) DeleteStructUnionType(cur_su);\n", " cur_su=NULL;\n", "\n", " cur_type_su=NULL;\n", "\n", " last_typedef=NULL;\n", "}\n"], "project": "cxref-emacs", "file": "type.pkl", "function": "ResetTypeAnalyser"}, {"comment_all": {"comment": "/* Figure out the font size */", "depth": 1, "reading_ease": 100.24, "reading_grade": 0.5, "line": 1001}, "comment_text": "/* Figure out the font size */", "comment_tokens": ["Figure", "out", "the", "font", "size"], "ccode": ["\n", "/***************************************************************/\n", "/*                                                             */\n", "/*  DoSmallCal - do the small calendar for previous or next    */\n", "/*  month.                                                     */\n", "/*                                                             */\n", "/***************************************************************/\n", "void DoSmallCal(char const *m, int days, int first, int col, int which)\n", "{\n", "    /* Do the small calendar */\n", "    int i, j;\n", "    int row = 2;\n", "\n", "    if (MondayFirst) {\n", "\tfirst--;\n", "\tif (first < 0) first = 6;\n", "    }\n", "    /* Figure out the font size */\n", "\n", "    printf(\"/SmallFontSize MinBoxSize Border sub Border sub 8 div 2 sub def\\n\");\n", "    printf(\"/SmallFont findfont setfont\\n\");\n", "    printf(\"SmallString stringwidth pop /SmallWidth exch def\\n\");\n", "    printf(\"SmallWidth 7 mul xincr Border sub Border sub exch div /tmp exch def\\n\");\n", "    printf(\"tmp SmallFontSize lt {/SmallFontSize tmp def} if\\n\");\n", "    printf(\"/SmallFont findfont SmallFontSize scalefont setfont\\n\");\n", "\n", "   /* Recalculate SmallWidth */\n", "    printf(\"SmallString stringwidth pop /SmallWidth exch def\\n\");\n", "\n", "    /* Save graphics state */\n", "    printf(\"gsave\\n\");\n", "\n", "    /* Move origin to upper-left hand corner of appropriate box */\n", "    printf(\"%d xincr mul MinX add ysmall%d translate\\n\", col, which);\n", "\n", "    /* Print the month */\n", "    printf(\"SmallWidth 7 mul (%s) stringwidth pop sub 2 div Border add Border neg SmallFontSize sub moveto (%s) show\\n\", m, m);\n", "\n", "    /* Print the days of the week */\n", "    for (i=0; i<7; i++) {\n", "\tif (MondayFirst) j=(i+1)%7;\n", "\telse             j=i;\n", "\tprintf(\"Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize sub 2 sub moveto (%c) show\\n\", i, DayName[j][0]);\n", "    }\n", "\n", "    /* Now do the days of the month */\n", "    for (i=1; i<=days; i++) {\n", "\tprintf(\"Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize 2 add %d mul sub moveto (%d) show\\n\", first, row, i);\n", "\tfirst++;\n", "\tif (first == 7) { first = 0; row++; }\n", "    }\n", "\n", "    /* restore graphics state */\n", "    printf(\"grestore\\n\");\n", "}\n"], "project": "remind", "file": "rem2ps.pkl", "function": "DoSmallCal"}, {"comment_all": {"comment": "// _nss_cache_oslogin_getgrent_r_locked()\n// Called internally to return the next entry from the group file\n", "depth": 0, "reading_ease": 42.38, "reading_grade": 10.3, "line": 263}, "comment_text": "// _nss_cache_oslogin_getgrent_r_locked()\n// Called internally to return the next entry from the group file\n", "comment_tokens": ["_nss_cache_oslogin_getgrent_r_locked", "(", ")", "Called", "internally", "to", "return", "the", "next", "entry", "from", "the", "group", "file"], "ccode": ["\n", "// _nss_cache_oslogin_getgrent_r_locked()\n", "// Called internally to return the next entry from the group file\n", "\n", "static enum nss_status _nss_cache_oslogin_getgrent_r_locked(struct group *result,\n", "                                                    char *buffer, size_t buflen,\n", "                                                    int *errnop) {\n", "  enum nss_status ret = NSS_STATUS_SUCCESS;\n", "\n", "  if (g_file == NULL) {\n", "    DEBUG(\"g_file == NULL, going to setgrent\\n\");\n", "    ret = _nss_cache_oslogin_setgrent_locked();\n", "  }\n", "\n", "  if (ret == NSS_STATUS_SUCCESS) {\n", "    fpos_t position;\n", "\n", "    fgetpos(g_file, &position);\n", "    if (fgetgrent_r(g_file, result, buffer, buflen, &result) == 0) {\n", "      DEBUG(\"Returning group %s (%u)\\n\", result->gr_name, result->gr_gid);\n", "    } else {\n", "      /* Rewind back to where we were just before, otherwise the data read\n", "       * into the buffer is probably going to be lost because there's no\n", "       * guarantee that the caller is going to have preserved the line we\n", "       * just read.  Note that glibc's nss/nss_files/files-XXX.c does\n", "       * something similar in CONCAT(_nss_files_get,ENTNAME_r) (around\n", "       * line 242 in glibc 2.4 sources).\n", "       */\n", "      if (errno == ENOENT) {\n", "        errno = 0;\n", "      } else {\n", "        fsetpos(g_file, &position);\n", "      }\n", "      *errnop = errno;\n", "      ret = _nss_cache_oslogin_ent_bad_return_code(*errnop);\n", "    }\n", "  }\n", "\n", "  return ret;\n", "}\n"], "project": "google-compute-engine-oslogin", "file": "nss_cache_oslogin.pkl", "function": "_nss_cache_oslogin_getgrent_r_locked"}, {"comment_all": {"comment": "/* undo effects of setting up yytext */", "depth": 1, "reading_ease": 56.93, "reading_grade": 6.8, "line": 3524}, "comment_text": "/* undo effects of setting up yytext */", "comment_tokens": ["undo", "effects", "of", "setting", "up", "yytext"], "ccode": ["\n", "#ifndef YY_NO_UNPUT\n", "\n", "    static void yyunput (int c, char * yy_bp )\n", "{\n", "\tchar *yy_cp;\n", "    \n", "    yy_cp = (yy_c_buf_p);\n", "\n", "\t/* undo effects of setting up yytext */\n", "\t*yy_cp = (yy_hold_char);\n", "\n", "\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n", "\t\t{ /* need to shift things up to make room */\n", "\t\t/* +2 for EOB chars. */\n", "\t\tint number_to_move = (yy_n_chars) + 2;\n", "\t\tchar *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n", "\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n", "\t\tchar *source =\n", "\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n", "\n", "\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n", "\t\t\t*--dest = *--source;\n", "\n", "\t\tyy_cp += (int) (dest - source);\n", "\t\tyy_bp += (int) (dest - source);\n", "\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n", "\t\t\t(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n", "\n", "\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n", "\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n", "\t\t}\n", "\n", "\t*--yy_cp = (char) c;\n", "\n", "    if ( c == '\\n' ){\n", "        --yylineno;\n", "    }\n", "\n", "\t(yytext_ptr) = yy_bp;\n", "\t(yy_hold_char) = *yy_cp;\n", "\t(yy_c_buf_p) = yy_cp;\n", "}\n"], "project": "linux-azure-5.8-tools-5.8.0-1041", "file": "lexer.lex.pkl", "function": "yyunput"}, {"comment_all": {"comment": "/*\n *  Window Maker window manager\n *\n *  Copyright (c) 1997-2003 Alfredo K. Kojima\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */", "depth": 0, "reading_ease": 59.13, "reading_grade": 10.1, "line": 0}, "comment_text": "/*\n *  Window Maker window manager\n *\n *  Copyright (c) 1997-2003 Alfredo K. Kojima\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */", "comment_tokens": ["Window", "Maker", "window", "manager", "Copyright", "(", "c", ")", "1997-2003", "Alfredo", "K.", "Kojima", "This", "program", "is", "free", "software", ";", "you", "can", "redistribute", "it", "andor", "modify", "it", "under", "the", "terms", "of", "the", "GNU", "General", "Public", "License", "as", "published", "by", "the", "Free", "Software", "Foundation", ";", "either", "version", "2", "of", "the", "License", ",", "or", "(", "at", "your", "option", ")", "any", "later", "version", ".", "This", "program", "is", "distributed", "in", "the", "hope", "that", "it", "will", "be", "useful", ",", "but", "WITHOUT", "ANY", "WARRANTY", ";", "without", "even", "the", "implied", "warranty", "of", "MERCHANTABILITY", "or", "FITNESS", "FOR", "A", "PARTICULAR", "PURPOSE", ".", "See", "the", "GNU", "General", "Public", "License", "for", "more", "details", ".", "You", "should", "have", "received", "a", "copy", "of", "the", "GNU", "General", "Public", "License", "along", "with", "this", "program", ";", "if", "not", ",", "write", "to", "the", "Free", "Software", "Foundation", ",", "Inc.", ",", "51", "Franklin", "Street", ",", "Fifth", "Floor", ",", "Boston", ",", "MA", "02110-1301", "USA", "."], "ccode": ["/*\n", " *  Window Maker window manager\n", " *\n", " *  Copyright (c) 1997-2003 Alfredo K. Kojima\n", " *\n", " *  This program is free software; you can redistribute it and/or modify\n", " *  it under the terms of the GNU General Public License as published by\n", " *  the Free Software Foundation; either version 2 of the License, or\n", " *  (at your option) any later version.\n", " *\n", " *  This program is distributed in the hope that it will be useful,\n", " *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n", " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", " *  GNU General Public License for more details.\n", " *\n", " *  You should have received a copy of the GNU General Public License along\n", " *  with this program; if not, write to the Free Software Foundation, Inc.,\n", " *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n", " */\n", "\n", "#include \"wconfig.h\"\n", "\n", "#include <X11/Xlib.h>\n", "#include <X11/Xutil.h>\n", "#include <X11/Xatom.h>\n", "#include <string.h>\n", "#include <stdlib.h>\n", "\n", "#include \"WindowMaker.h\"\n", "#include \"window.h\"\n", "#include \"GNUstep.h\"\n", "#include \"properties.h\"\n", "\n", "\n", "int PropGetNormalHints(Window window, XSizeHints * size_hints, int *pre_iccm)\n", "{\n", "\tlong supplied_hints;\n", "\n", "\tif (!XGetWMNormalHints(dpy, window, size_hints, &supplied_hints)) {\n", "\t\treturn False;\n", "\t}\n", "\tif (supplied_hints == (USPosition | USSize | PPosition | PSize | PMinSize | PMaxSize\n", "\t\t\t       | PResizeInc | PAspect)) {\n", "\t\t*pre_iccm = 1;\n", "\t} else {\n", "\t\t*pre_iccm = 0;\n", "\t}\n", "\treturn True;\n", "}\n"], "project": "wmaker-common", "file": "properties.pkl", "function": "PropGetNormalHints"}, {"comment_all": {"comment": "/*\n\t\tsprintf(buffer,\"I=%0.3f\",I[0]);\n\t\tglPrint(v1[0], v1[1], v1[2], buffer);\n\t\tsprintf(buffer,\"I=%0.3f\",I[1]);\n\t\tglPrint(v2[0], v2[1], v2[2], buffer);\n\t\tsprintf(buffer,\"I=%0.3f\",I[2]);\n\t\tglPrint(v3[0], v3[1], v3[2], buffer);\n\t\t*/", "depth": 2, "reading_ease": 15.64, "reading_grade": 12.3, "line": 407}, "comment_text": "/*\n\t\tsprintf(buffer,\"I=%0.3f\",I[0]);\n\t\tglPrint(v1[0], v1[1], v1[2], buffer);\n\t\tsprintf(buffer,\"I=%0.3f\",I[1]);\n\t\tglPrint(v2[0], v2[1], v2[2], buffer);\n\t\tsprintf(buffer,\"I=%0.3f\",I[2]);\n\t\tglPrint(v3[0], v3[1], v3[2], buffer);\n\t\t*/", "comment_tokens": ["sprintf", "(", "buffer", ",", "''", "I=", "%", "0.3f", "''", ",", "I", "[", "0", "]", ")", ";", "glPrint", "(", "v1", "[", "0", "]", ",", "v1", "[", "1", "]", ",", "v1", "[", "2", "]", ",", "buffer", ")", ";", "sprintf", "(", "buffer", ",", "''", "I=", "%", "0.3f", "''", ",", "I", "[", "1", "]", ")", ";", "glPrint", "(", "v2", "[", "0", "]", ",", "v2", "[", "1", "]", ",", "v2", "[", "2", "]", ",", "buffer", ")", ";", "sprintf", "(", "buffer", ",", "''", "I=", "%", "0.3f", "''", ",", "I", "[", "2", "]", ")", ";", "glPrint", "(", "v3", "[", "0", "]", ",", "v3", "[", "1", "]", ",", "v3", "[", "2", "]", ",", "buffer", ")", ";"], "ccode": ["/*********************************************************************************************/\n", "void showLabelPrincipalAxes()\n", "{\n", "\tgint i;\n", "\tV4d color  = {0.8,0.8,0.8,1.0 };\n", "\tgchar buffer[BSIZE];\n", "\tgboolean show;\n", "\tgboolean negative;\n", "\tgboolean def;\n", "\tgdouble origin[3];\n", "\tgdouble radius;\n", "\tgdouble scal;\n", "\tgdouble c1[3];\n", "\tgdouble c2[3];\n", "\tgdouble c3[3];\n", "\tgdouble v1[]  = {1,0,0};\n", "\tgdouble v2[]  = {0,1,0};\n", "\tgdouble v3[]  = {0,0,1};\n", "\tgdouble I[]  = {1,1,1};\n", "\n", "\tif(!showAxes) return;\n", "\tif(!testShowPrincipalAxisGL()) return;\n", "\n", "\tgetPrincipalAxisProperties(&show, &negative, &def, origin, &radius, &scal, v1,v2, v3, c1,c2, c3);\n", "\tif(!def) return;\n", "\tgetPrincipalAxisInertias(I);\n", "\n", "\tfor(i=0;i<3;i++)\n", "\t{\n", "\t\tv1[i] *= scal;\n", "\t\tv2[i] *= scal;\n", "\t\tv3[i] *= scal;\n", "\t}\n", "\tfor(i=0;i<3;i++)\n", "\t{\n", "\t\tv1[i] += origin[i];\n", "\t\tv2[i] += origin[i];\n", "\t\tv3[i] += origin[i];\n", "\t}\n", "\t\n", "\n", "\tcolor[0] = FontsStyleLabel.TextColor.red/65535.0; \n", "\tcolor[1] = FontsStyleLabel.TextColor.green/65535.0; \n", "\tcolor[2] = FontsStyleLabel.TextColor.blue/65535.0; \n", "\n", "\tglInitFontsUsing(FontsStyleLabel.fontname);\n", "\n", "\tif(radius<0.1) radius = 0.1;\n", "\tglDisable ( GL_LIGHTING ) ;\n", "\tglColor4dv(color);\n", "\n", "\n", "\tif(ortho)\n", "\t{\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[0]);\n", "\t\tglPrintOrtho(v1[0], v1[1], v1[2], buffer, TRUE, TRUE);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[1]);\n", "\t\tglPrintOrtho(v2[0], v2[1], v2[2], buffer, TRUE, TRUE);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[2]);\n", "\t\tglPrintOrtho(v3[0], v3[1], v3[2], buffer, TRUE, TRUE);\n", "\t}\n", "\telse\n", "\t{\n", "\t\t/*\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[0]);\n", "\t\tglPrint(v1[0], v1[1], v1[2], buffer);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[1]);\n", "\t\tglPrint(v2[0], v2[1], v2[2], buffer);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[2]);\n", "\t\tglPrint(v3[0], v3[1], v3[2], buffer);\n", "\t\t*/\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[0]);\n", "\t\tglPrintScale(v1[0], v1[1], v1[2], 1.1*radius, buffer);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[1]);\n", "\t\tglPrintScale(v2[0], v2[1], v2[2], 1.1*radius, buffer);\n", "\t\tsprintf(buffer,\"I=%0.3f\",I[2]);\n", "\t\tglPrintScale(v3[0], v3[1], v3[2], 1.1*radius, buffer);\n", "\t}\n", "\tglEnable ( GL_LIGHTING ) ;\n", "\tglDeleteFontsList();\n", "}\n"], "project": "gabedit", "file": "LabelsGL.pkl", "function": "showLabelPrincipalAxes"}, {"comment_all": {"comment": "/* \"foo\" -> \"  foo\"\n *  write padlen-srclen spaces, if that is >= 0.  Then copy srclen\n *  characters from src.  Truncate only if total length is larger than\n *  maxlen.  Return number of characters written. */", "depth": 0, "reading_ease": 72.53, "reading_grade": 5.0, "line": 2}, "comment_text": "/* \"foo\" -> \"  foo\"\n *  write padlen-srclen spaces, if that is >= 0.  Then copy srclen\n *  characters from src.  Truncate only if total length is larger than\n *  maxlen.  Return number of characters written. */", "comment_tokens": ["``", "foo", "''", "-", ">", "``", "foo", "''", "write", "padlen-srclen", "spaces", ",", "if", "that", "is", ">", "=", "0", ".", "Then", "copy", "srclen", "characters", "from", "src", ".", "Truncate", "only", "if", "total", "length", "is", "larger", "than", "maxlen", ".", "Return", "number", "of", "characters", "written", "."], "ccode": ["#include \"fmt.h\"\n", "\n", "/* \"foo\" -> \"  foo\"\n", " *  write padlen-srclen spaces, if that is >= 0.  Then copy srclen\n", " *  characters from src.  Truncate only if total length is larger than\n", " *  maxlen.  Return number of characters written. */\n", "size_t fmt_pad(char* dest,const char* src,size_t srclen,size_t padlen,size_t maxlen) {\n", "  long todo;\n", "  char* olddest=dest;\n", "  char* max=dest+maxlen;\n", "  if ((long)srclen<0 || (long)padlen<0 || (long)maxlen<0) return 0;\n", "  todo=(long)(padlen-srclen);\n", "  if (dest==0) {\n", "    unsigned long sum=srclen>padlen?srclen:padlen;\n", "    return sum>maxlen?maxlen:sum;\n", "  }\n", "  for (; todo>0; --todo) {\n", "    if (dest>max) break;\n", "    *dest=' '; ++dest;\n", "  }\n", "  for (todo=(long)(srclen>maxlen?maxlen:srclen); todo>0; --todo) {\n", "    if (dest>max) break;\n", "    *dest=*src; ++dest; ++src;\n", "  }\n", "  return (size_t)(dest-olddest);\n", "}\n"], "project": "libowfat-dietlibc-dev", "file": "fmt_pad.pkl", "function": "fmt_pad"}, {"comment_all": {"comment": "/*\n * This procedure sets the Smc error handler to be the specified\n * routine.  If NULL is passed in the default error handler is restored.\n * The function's return value is the previous error handler.\n */", "depth": 0, "reading_ease": 60.61, "reading_grade": 7.5, "line": 275}, "comment_text": "/*\n * This procedure sets the Smc error handler to be the specified\n * routine.  If NULL is passed in the default error handler is restored.\n * The function's return value is the previous error handler.\n */", "comment_tokens": ["This", "procedure", "sets", "the", "Smc", "error", "handler", "to", "be", "the", "specified", "routine", ".", "If", "NULL", "is", "passed", "in", "the", "default", "error", "handler", "is", "restored", ".", "The", "function", "'s", "return", "value", "is", "the", "previous", "error", "handler", "."], "ccode": ["\n", "\n", "\f\n", "/*\n", " * This procedure sets the Smc error handler to be the specified\n", " * routine.  If NULL is passed in the default error handler is restored.\n", " * The function's return value is the previous error handler.\n", " */\n", "\n", "SmcErrorHandler\n", "SmcSetErrorHandler(SmcErrorHandler handler)\n", "{\n", "    SmcErrorHandler oldHandler = _SmcErrorHandler;\n", "\n", "    if (handler != NULL)\n", "\t_SmcErrorHandler = handler;\n", "    else\n", "\t_SmcErrorHandler = _SmcDefaultErrorHandler;\n", "\n", "    return (oldHandler);\n", "}\n"], "project": "libsm-doc", "file": "sm_error.pkl", "function": "SmcSetErrorHandler"}, {"comment_all": {"comment": "/* Directives allowed in read-only mode */", "depth": 1, "reading_ease": 32.56, "reading_grade": 10.0, "line": 986}, "comment_text": "/* Directives allowed in read-only mode */", "comment_tokens": ["Directives", "allowed", "in", "read-only", "mode"], "ccode": ["\n", "static int\n", "parse_config_line(int c, gnc_t gnc, void *closure,\n", "                  int *action_return, const char **message_return)\n", "{\n", "    char *token;\n", "    if(action_return)\n", "        *action_return = CONFIG_ACTION_DONE;\n", "    if(message_return)\n", "        *message_return = NULL;\n", "\n", "    c = skip_whitespace(c, gnc, closure);\n", "    if(c < 0 || c == '\\n' || c == '#')\n", "        return skip_to_eol(c, gnc, closure);\n", "\n", "    c = getword(c, &token, gnc, closure);\n", "    if(c < -1)\n", "        return c;\n", "\n", "    /* Directives allowed in read-only mode */\n", "    if(strcmp(token, \"quit\") == 0) {\n", "        c = skip_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        *action_return = CONFIG_ACTION_QUIT;\n", "    } else if(strcmp(token, \"dump\") == 0) {\n", "        c = skip_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        *action_return = CONFIG_ACTION_DUMP;\n", "    } else if(strcmp(token, \"monitor\") == 0) {\n", "        c = skip_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        *action_return = CONFIG_ACTION_MONITOR;\n", "    } else if(strcmp(token, \"unmonitor\") == 0) {\n", "        c = skip_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        *action_return = CONFIG_ACTION_UNMONITOR;\n", "    } else if(config_finalised && !local_server_write) {\n", "        /* The remaining directives are only allowed in read-write mode. */\n", "        c = skip_to_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        /* Unfortunately, we cannot report NO here, since we don't know if\n", "           the line is parsable.  Oh, well. */\n", "        goto fail;\n", "    } else if(strcmp(token, \"in\") == 0) {\n", "        struct filter *filter;\n", "        if(config_finalised)\n", "            goto fail;\n", "        c = parse_filter(c, gnc, closure, &filter);\n", "        if(c < -1)\n", "            goto fail;\n", "        add_filter(filter, &input_filters);\n", "    } else if(strcmp(token, \"out\") == 0) {\n", "        struct filter *filter;\n", "        if(config_finalised)\n", "            goto fail;\n", "        c = parse_filter(c, gnc, closure, &filter);\n", "        if(c < -1)\n", "            goto fail;\n", "        add_filter(filter, &output_filters);\n", "    } else if(strcmp(token, \"redistribute\") == 0) {\n", "        struct filter *filter;\n", "        if(config_finalised)\n", "            goto fail;\n", "        c = parse_filter(c, gnc, closure, &filter);\n", "        if(c < -1)\n", "            goto fail;\n", "        add_filter(filter, &redistribute_filters);\n", "    } else if(strcmp(token, \"install\") == 0) {\n", "        struct filter *filter;\n", "        if(config_finalised)\n", "            goto fail;\n", "        c = parse_filter(c, gnc, closure, &filter);\n", "        if(c < -1)\n", "            goto fail;\n", "        add_filter(filter, &install_filters);\n", "    } else if(strcmp(token, \"interface\") == 0) {\n", "        struct interface_conf *if_conf;\n", "        c = parse_ifconf(c, gnc, closure, &if_conf);\n", "        if(c < -1)\n", "            goto fail;\n", "        add_ifconf(if_conf, &interface_confs);\n", "    } else if(strcmp(token, \"default\") == 0) {\n", "        struct interface_conf *if_conf;\n", "        c = parse_anonymous_ifconf(c, gnc, closure, NULL, &if_conf);\n", "        if(c < -1)\n", "            goto fail;\n", "        if(default_interface_conf == NULL)\n", "            default_interface_conf = if_conf;\n", "        else {\n", "            merge_ifconf(default_interface_conf,\n", "                         if_conf, default_interface_conf);\n", "            free(if_conf);\n", "        }\n", "    } else if(strcmp(token, \"flush\") == 0) {\n", "        char *token2;\n", "        c = skip_whitespace(c, gnc, closure);\n", "        c = getword(c, &token2, gnc, closure);\n", "        if(c < -1)\n", "            goto fail;\n", "        if(strcmp(token2, \"interface\") == 0) {\n", "            char *ifname;\n", "            int rc;\n", "            c = getword(c, &ifname, gnc, closure);\n", "            c = skip_eol(c, gnc, closure);\n", "            if(c < -1) {\n", "                free(token2);\n", "                goto fail;\n", "            }\n", "            rc = flush_interface(ifname);\n", "            if(rc <= 0) {\n", "                if(action_return)\n", "                    *action_return = CONFIG_ACTION_NO;\n", "                if(message_return) {\n", "                    if(rc < 0)\n", "                        *message_return = \"Couldn't flush interface\";\n", "                    else\n", "                        *message_return = \"No such interface\";\n", "                }\n", "            }\n", "            free(token2);\n", "            free(ifname);\n", "        } else {\n", "            free(token2);\n", "            goto fail;\n", "        }\n", "    } else if(strcmp(token, \"reopen-logfile\") == 0) {\n", "        c = skip_eol(c, gnc, closure);\n", "        if(c < -1 || !action_return)\n", "            goto fail;\n", "        reopen_logfile();\n", "    } else {\n", "        c = parse_option(c, gnc, closure, token);\n", "        if(c < -1)\n", "            goto fail;\n", "    }\n", "\n", "    free(token);\n", "    return c;\n", "\n", " fail:\n", "    free(token);\n", "    return -2;\n", "}\n"], "project": "babeld", "file": "configuration.pkl", "function": "parse_config_line"}, {"comment_all": {"comment": "/**************************************************************************\n   *\n   * @Function:\n   *   BBox_Line_To\n   *\n   * @Description:\n   *   This function is used as a `line_to' emitter during\n   *   FT_Outline_Decompose().  It simply records the destination point\n   *   in `user->last'; no further computations are necessary because\n   *   bbox already contains both explicit ends of the line segment.\n   *\n   * @Input:\n   *   to ::\n   *     A pointer to the destination vector.\n   *\n   * @InOut:\n   *   user ::\n   *     A pointer to the current walk context.\n   *\n   * @Return:\n   *   Always 0.  Needed for the interface only.\n   */", "depth": 0, "reading_ease": 52.56, "reading_grade": 8.5, "line": 97}, "comment_text": "/**************************************************************************\n   *\n   * @Function:\n   *   BBox_Line_To\n   *\n   * @Description:\n   *   This function is used as a `line_to' emitter during\n   *   FT_Outline_Decompose().  It simply records the destination point\n   *   in `user->last'; no further computations are necessary because\n   *   bbox already contains both explicit ends of the line segment.\n   *\n   * @Input:\n   *   to ::\n   *     A pointer to the destination vector.\n   *\n   * @InOut:\n   *   user ::\n   *     A pointer to the current walk context.\n   *\n   * @Return:\n   *   Always 0.  Needed for the interface only.\n   */", "comment_tokens": ["@", "Function", ":", "BBox_Line_To", "@", "Description", ":", "This", "function", "is", "used", "as", "a", "`", "line_to", "'", "emitter", "during", "FT_Outline_Decompose", "(", ")", ".", "It", "simply", "records", "the", "destination", "point", "in", "`", "user-", ">", "last", "'", ";", "no", "further", "computations", "are", "necessary", "because", "bbox", "already", "contains", "both", "explicit", "ends", "of", "the", "line", "segment", ".", "@", "Input", ":", "to", ":", ":", "A", "pointer", "to", "the", "destination", "vector", ".", "@", "InOut", ":", "user", ":", ":", "A", "pointer", "to", "the", "current", "walk", "context", ".", "@", "Return", ":", "Always", "0", ".", "Needed", "for", "the", "interface", "only", "."], "ccode": ["\n", "\n", "  /**************************************************************************\n", "   *\n", "   * @Function:\n", "   *   BBox_Line_To\n", "   *\n", "   * @Description:\n", "   *   This function is used as a `line_to' emitter during\n", "   *   FT_Outline_Decompose().  It simply records the destination point\n", "   *   in `user->last'; no further computations are necessary because\n", "   *   bbox already contains both explicit ends of the line segment.\n", "   *\n", "   * @Input:\n", "   *   to ::\n", "   *     A pointer to the destination vector.\n", "   *\n", "   * @InOut:\n", "   *   user ::\n", "   *     A pointer to the current walk context.\n", "   *\n", "   * @Return:\n", "   *   Always 0.  Needed for the interface only.\n", "   */\n", "  static int\n", "  BBox_Line_To( FT_Vector*  to,\n", "                TBBox_Rec*  user )\n", "  {\n", "    user->last = *to;\n", "\n", "    return 0;\n", "  }\n"], "project": "freetype2-demos", "file": "ftbbox.pkl", "function": "BBox_Line_To"}, {"comment_all": {"comment": "/*insert a argv[0] into the dynamic array */", "depth": 1, "reading_ease": 55.91, "reading_grade": 7.2, "line": 49}, "comment_text": "/*insert a argv[0] into the dynamic array */", "comment_tokens": ["insert", "a", "argv", "[", "0", "]", "into", "the", "dynamic", "array"], "ccode": ["/*\n", " *      Code to convert a stream input into a dynamic array\n", " *      that can be parsed as argc and argv.\n", " *\n", " *      Authors: Horms <horms@vergenet.net>\n", " *\n", " *      Released under the terms of the GNU GPL\n", " *\n", " *      ChangeLog\n", " *      Horms         :   scanf Glibc under Red Hat 7 does not appear\n", " *                        to return EOF when input ends. Fall through\n", " *                        code has been added to handle this case correctly\n", " */\n", "\n", "#include \"config_stream.h\"\n", "\n", "\n", "/**********************************************************************\n", " * config_stream_read\n", " * Read in a config file and put elements in a dynamic array\n", " * pre: stream: stream to read configuration from\n", " * return: dynamic array whose elements are the space delimited\n", " *         tokens read from the stream. Result is returned\n", " *         once a newline is reached so multiple calls\n", " *         will be required to read an entire stream.\n", " *         Everything including and after a hash (#) on a line is\n", " *         ignored\n", " **********************************************************************/\n", "\n", "dynamic_array_t *\n", "config_stream_read(FILE * stream, const char *first_element)\n", "{\n", "  char token[MAX_LINE_LENGTH];\n", "  char tail[2];\n", "  char format[MAX_LINE_LENGTH];\n", "  char format_whitespace[MAX_LINE_LENGTH];\n", "  int status;\n", "  int ntoken;\n", "  int comment = 0;\n", "  char *s;\n", "  int c;\n", "  int flag;\n", "  dynamic_array_t *a;\n", "\n", "  if ((a = dynamic_array_create((size_t) 0)) == NULL) {\n", "    perror(\"config_file_read: dynamic_array_create\");\n", "    return (NULL);\n", "  }\n", "\n", "  /*insert a argv[0] into the dynamic array */\n", "  if ((a = dynamic_array_add_element(a,\n", "\t\t\t\t     (first_element !=\n", "\t\t\t\t      NULL ? first_element : \"\"),\n", "\t\t\t\t     DESTROY_STR, DUP_STR)) == NULL) {\n", "    perror(\"config_file_read: dynamic_array_add_element\");\n", "    return (NULL);\n", "  }\n", "\n", "  sprintf(format, \"%%%d[^ \\t\\n\\r]%%1[ \\t\\n\\r]\", MAX_LINE_LENGTH);\n", "  sprintf(format_whitespace, \"%%%d[ \\t\\r]%%1[\\n]\", MAX_LINE_LENGTH);\n", "\n", "  ntoken = 0;\n", "  while ((status = fscanf(stream, format, token, tail)) != EOF) {\n", "    if (status == 0) {\n", "      flag = 1;\n", "      while (flag) {\n", "\tc = fgetc(stream);\n", "\tswitch (c) {\n", "\tcase EOF:\n", "\t  dynamic_array_destroy(a, DESTROY_STR);\n", "\t  return (NULL);\n", "\tcase '\\n':\n", "\t  return (a);\n", "\tcase '\\t':\n", "\tcase '\\r':\n", "\tcase ' ':\n", "\t  break;\n", "\tdefault:\n", "\t  ungetc(c, stream);\n", "\t  flag = 0;\n", "\t}\n", "      }\n", "      continue;\n", "    }\n", "    if (!comment && strcmp(token, \"ipvsadm\")) {\n", "      ntoken++;\n", "      if ((a = dynamic_array_add_element(a,\n", "\t\t\t\t\t token,\n", "\t\t\t\t\t DESTROY_STR, DUP_STR)) == NULL) {\n", "\tperror(\"config_file_read: dynamic_array_add_element\");\n", "\tdynamic_array_destroy(a, DESTROY_STR);\n", "\treturn (NULL);\n", "      }\n", "    }\n", "    if ((s = strrchr(tail, '\\n')) != NULL) {\n", "      return (a);\n", "    }\n", "    if (!comment) {\n", "      comment = (strchr((s != NULL ? s : tail), '#') == NULL) ? 0 : 1;\n", "    }\n", "  }\n", "\n", "  if (ntoken == 0) {\n", "    dynamic_array_destroy(a, DESTROY_STR);\n", "    return (NULL);\n", "  }\n", "\n", "  return (a);\n", "}\n"], "project": "ipvsadm", "file": "config_stream.pkl", "function": "config_stream_read"}, {"comment_all": {"comment": "/* If they are both unmapped, we merge, but leave unmapped. */", "depth": 4, "reading_ease": 75.88, "reading_grade": 3.7, "line": 393}, "comment_text": "/* If they are both unmapped, we merge, but leave unmapped. */", "comment_tokens": ["If", "they", "are", "both", "unmapped", ",", "we", "merge", ",", "but", "leave", "unmapped", "."], "ccode": ["\n", "/* Merge all unmapped blocks that are adjacent to other free\t\t*/\n", "/* blocks.  This may involve remapping, since all blocks are either\t*/\n", "/* fully mapped or fully unmapped.\t\t\t\t\t*/\n", "void GC_merge_unmapped(void)\n", "{\n", "    struct hblk * h, *next;\n", "    hdr * hhdr, *nexthdr;\n", "    word size, nextsize;\n", "    int i;\n", "    \n", "    for (i = 0; i <= N_HBLK_FLS; ++i) {\n", "      h = GC_hblkfreelist[i];\n", "      while (h != 0) {\n", "\tGET_HDR(h, hhdr);\n", "\tsize = hhdr->hb_sz;\n", "\tnext = (struct hblk *)((word)h + size);\n", "\tGET_HDR(next, nexthdr);\n", "\t/* Coalesce with successor, if possible */\n", "\t  if (0 != nexthdr && HBLK_IS_FREE(nexthdr)) {\n", "\t    nextsize = nexthdr -> hb_sz;\n", "\t    if (IS_MAPPED(hhdr)) {\n", "\t      GC_ASSERT(!IS_MAPPED(nexthdr));\n", "\t      /* make both consistent, so that we can merge */\n", "\t        if (size > nextsize) {\n", "\t\t  GC_remap((ptr_t)next, nextsize);\n", "\t\t} else {\n", "\t\t  GC_unmap((ptr_t)h, size);\n", "\t\t  hhdr -> hb_flags |= WAS_UNMAPPED;\n", "\t\t}\n", "\t    } else if (IS_MAPPED(nexthdr)) {\n", "\t      GC_ASSERT(!IS_MAPPED(hhdr));\n", "\t      if (size > nextsize) {\n", "\t\tGC_unmap((ptr_t)next, nextsize);\n", "\t      } else {\n", "\t\tGC_remap((ptr_t)h, size);\n", "\t\thhdr -> hb_flags &= ~WAS_UNMAPPED;\n", "\t\thhdr -> hb_last_reclaimed = nexthdr -> hb_last_reclaimed;\n", "\t      }\n", "\t    } else {\n", "\t      /* Unmap any gap in the middle */\n", "\t\tGC_unmap_gap((ptr_t)h, size, (ptr_t)next, nexthdr -> hb_sz);\n", "\t    }\n", "\t    /* If they are both unmapped, we merge, but leave unmapped. */\n", "\t    GC_remove_from_fl(hhdr, i);\n", "\t    GC_remove_from_fl(nexthdr, FL_UNKNOWN);\n", "\t    hhdr -> hb_sz += nexthdr -> hb_sz; \n", "\t    GC_remove_header(next);\n", "\t    GC_add_to_fl(h, hhdr); \n", "\t    /* Start over at beginning of list */\n", "\t    h = GC_hblkfreelist[i];\n", "\t  } else /* not mergable with successor */ {\n", "\t    h = hhdr -> hb_next;\n", "\t  }\n", "      } /* while (h != 0) ... */\n", "    } /* for ... */\n", "}\n"], "project": "libmonosgen-2.0-dev", "file": "allchblk.c", "function": "GC_merge_unmapped"}, {"comment_all": {"comment": "/* Make sure that there is a bottom level index block for address addr  */ /* Return FALSE on failure.\t\t\t\t\t\t*/ /* Add it to the list of bottom indices */ /* pointer to p */ /* bottom_index preceding p */", "depth": 0, "reading_ease": 75.88, "reading_grade": 3.7, "line": 152}, "comment_text": "/* pointer to p */", "comment_tokens": ["Make", "sure", "that", "there", "is", "a", "bottom", "level", "index", "block", "for", "address", "addr", "Return", "FALSE", "on", "failure", ".", "Add", "it", "to", "the", "list", "of", "bottom", "indices", "pointer", "to", "p", "bottom_index", "preceding", "p"], "ccode": ["\n", "/* Make sure that there is a bottom level index block for address addr  */\n", "/* Return FALSE on failure.\t\t\t\t\t\t*/\n", "static GC_bool get_index(addr)\n", "word addr;\n", "{\n", "    word hi = (word)(addr) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n", "    bottom_index * r;\n", "    bottom_index * p;\n", "    bottom_index ** prev;\n", "    bottom_index *pi;\n", "    \n", "#   ifdef HASH_TL\n", "      unsigned i = TL_HASH(hi);\n", "      bottom_index * old;\n", "      \n", "      old = p = GC_top_index[i];\n", "      while(p != GC_all_nils) {\n", "          if (p -> key == hi) return(TRUE);\n", "          p = p -> hash_link;\n", "      }\n", "      r = (bottom_index*)GC_scratch_alloc((word)(sizeof (bottom_index)));\n", "      if (r == 0) return(FALSE);\n", "      BZERO(r, sizeof (bottom_index));\n", "      r -> hash_link = old;\n", "      GC_top_index[i] = r;\n", "#   else\n", "      if (GC_top_index[hi] != GC_all_nils) return(TRUE);\n", "      r = (bottom_index*)GC_scratch_alloc((word)(sizeof (bottom_index)));\n", "      if (r == 0) return(FALSE);\n", "      GC_top_index[hi] = r;\n", "      BZERO(r, sizeof (bottom_index));\n", "#   endif\n", "    r -> key = hi;\n", "    /* Add it to the list of bottom indices */\n", "      prev = &GC_all_bottom_indices;  \t/* pointer to p */\n", "      pi = 0;\t\t\t\t/* bottom_index preceding p */\n", "      while ((p = *prev) != 0 && p -> key < hi) {\n", "\tpi = p;\n", "\tprev = &(p -> asc_link);\n", "      }\n", "      r -> desc_link = pi;\n", "      if (0 == p) {\n", "\tGC_all_bottom_indices_end = r;\n", "      } else {\n", "\tp -> desc_link = r;\n", "      }\n", "      r -> asc_link = p;\n", "      *prev = r;\n", "    return(TRUE);\n", "}\n"], "project": "libmonosgen-2.0-dev", "file": "headers.c", "function": "get_index"}]